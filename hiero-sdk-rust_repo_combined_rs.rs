// Filename: examples/account_alias.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountBalanceQuery, AccountId, AccountInfoQuery, Client, Hbar, PrivateKey, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // Hiero supports a form of auto account creation.
    //
    // You can "create" an account by generating a private key, and then deriving the public key,
    // without any need to interact with the Hiero network.  The public key more or less acts as the user's
    // account ID.  This public key is an account's alias_key: a public key that aliases (or will eventually alias)
    // to a Hiero account.
    //
    // An AccountId takes one of two forms: a normal `AccountId` with no `alias_key` takes the form 0.0.123,
    // while an account ID with an `alias_key` takes the form
    // 0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777
    // Note the prefix of "0.0." indicating the shard and realm.  Also note that the aliasKey is stringified
    // as a hex-encoded ASN1 DER representation of the key.
    //
    // An AccountId with an aliasKey can be used just like a normal AccountId for the purposes of queries and
    // transactions, however most queries and transactions involving such an AccountId won't work until Hbar has
    // been transferred to the alias_key account.
    //
    // There is no record in the Hiero network of an account associated with a given `alias_key`
    // until an amount of Hbar is transferred to the account.  The moment that Hbar is transferred to that `alias_key`
    // AccountId is the moment that that account actually begins to exist in the Hiero ledger.

    println!(r#""Creating" a new account"#);

    let private_key = PrivateKey::generate_ed25519();
    let public_key = private_key.public_key();

    // Assuming that the target shard and realm are known.
    // For now they are virtually always 0 and 0.
    let alias_account_id = public_key.to_account_id(0, 0);

    println!("New account ID: {alias_account_id}");
    println!("Just the aliasKey: {:?}", &alias_account_id.alias);

    // Note that no queries or transactions have taken place yet.
    // This account "creation" process is entirely local.
    //
    // AccountId::from_str can construct an AccountId with an alias_key.
    // It expects a string of the form 0.0.123 in the case of a normal AccountId, or of the form
    // 0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777
    // in the case of an AccountId with an alias.  Note the prefix of "0.0." to indicate the shard and realm.
    //
    // If the shard and realm are known, you may use PublicKey::from_str().to_account_id() to construct the
    // alias_key AccountId.

    println!("Transferring some Hbar to the new account");
    let _ = TransferTransaction::new()
        .hbar_transfer(args.operator_account_id, Hbar::new(-10))
        .hbar_transfer(alias_account_id, Hbar::new(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let balance = AccountBalanceQuery::new()
        .account_id(alias_account_id)
        .execute(&client)
        .await?;

    println!("Balances of the new account: {balance:?}");

    let info = AccountInfoQuery::new()
        .account_id(alias_account_id)
        .execute(&client)
        .await?;

    println!("Info about the new account: {info:?}");

    // Note that once an account exists in the ledger, it is assigned a normal AccountId, which can be retrieved
    // via an AccountInfoQuery.
    //
    // Users may continue to refer to the account by its alias_key AccountId, but they may also
    // now refer to it by its normal AccountId.

    println!("the normal account ID: {}", info.account_id);
    println!("the alias key: {:?}", info.alias_key);
    println!("Example complete!");

    Ok(())
}
// Filename: examples/account_allowance.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountAllowanceApproveTransaction, AccountBalanceQuery, AccountCreateTransaction, AccountDeleteTransaction, AccountId, Client, Hbar, PrivateKey, TransactionId, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[derive(Clone, Debug)]
struct Account {
    key: PrivateKey,
    id: AccountId,
    name: &'static str,
}

async fn create_account(client: &Client, name: &'static str) -> hedera::Result<Account> {
    let key = PrivateKey::generate_ed25519();

    let reciept = AccountCreateTransaction::new()
        .key(key.public_key())
        .initial_balance(Hbar::new(5))
        .account_memo(format!("[sdk::rust::account_allowance_example::{name}]"))
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    let account_id = reciept
        .account_id
        .expect("Created account but no account ID in receipt");

    Ok(Account {
        key,
        id: account_id,
        name,
    })
}

async fn create_accounts(client: &Client) -> anyhow::Result<[Account; 3]> {
    println!("Creating accounts");

    let (alice, bob, charlie) = tokio::try_join!(
        create_account(client, "Alice"),
        create_account(client, "Bob"),
        create_account(client, "Charlie"),
    )?;

    let accounts = [alice, bob, charlie];

    for account in &accounts {
        println!("{}'s ID: {}", account.name, account.id);
    }

    Ok(accounts)
}

// this needs to be a function because rust doesn't have try blocks.
/// Transfer from `alice` (0) to `charlie` (2) via `bob`'s allowance (1).
async fn transfer(client: &Client, accounts: &[Account; 3], value: Hbar) -> hedera::Result<()> {
    let [alice, bob, charlie] = accounts;
    // `approved_{hbar,token}_transfer()` means that the transfer has been approved by an allowance
    // The allowance spender must be pay the fee for the transaction.
    // use `transaction_id()` to set the account ID that will pay the fee for the transaction.
    let _ = TransferTransaction::new()
        .approved_hbar_transfer(alice.id, -value)
        .hbar_transfer(charlie.id, value)
        .transaction_id(TransactionId::generate(bob.id))
        .freeze_with(client)?
        .sign(bob.key.clone())
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    Ok(())
}

async fn demonstrate_allowances(client: &Client, accounts: &[Account; 3]) -> anyhow::Result<()> {
    const FIRST_ALLOWANCE_VALUE: Hbar = Hbar::new(2);
    const FIRST_TRANSFER_VALUE: Hbar = Hbar::new(1);
    const SECOND_ALLOWANCE_VALUE: Hbar = Hbar::new(3);
    const SECOND_TRANSFER_VALUE: Hbar = Hbar::new(2);

    let [alice, bob, charlie] = accounts;

    println!(
        "Approving an allowance of {FIRST_ALLOWANCE_VALUE} with owner {} and spender {}",
        alice.name, bob.name
    );

    let _ = AccountAllowanceApproveTransaction::new()
        .approve_hbar_allowance(alice.id, bob.id, FIRST_ALLOWANCE_VALUE)
        .freeze_with(client)?
        .sign(alice.key.clone())
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    print_balances(client, accounts).await?;

    println!(
        "Transferring {FIRST_TRANSFER_VALUE} from {alice} to {charlie}, but the transaction is signed only by {bob} ({bob} is dipping into their allowance from {alice})",
        alice=alice.name,
        bob=bob.name,
        charlie=charlie.name
    );

    transfer(client, accounts, FIRST_TRANSFER_VALUE).await?;

    let current_balance = FIRST_ALLOWANCE_VALUE - FIRST_TRANSFER_VALUE;

    println!(
        "Transfer succeeded. {bob} should now have {current_balance} left in their allowance.",
        bob = bob.name,
    );

    print_balances(client, accounts).await?;

    println!(
        "Attempting to transfer {SECOND_TRANSFER_VALUE} from {alice} to {charlie} using {bob}'s allowance.",
        alice=alice.name,
        bob=bob.name,
        charlie=charlie.name
    );
    println!(
        "This should fail, because there is only {current_balance} left in {bob}'s allowance.",
        bob = bob.name
    );

    match transfer(client, accounts, SECOND_TRANSFER_VALUE).await {
        Ok(()) => {
            println!("The transfer succeeded. This should not happen.");
        }

        Err(e) => {
            println!("The transfer failed as expected: {e:?}");
        }
    }

    println!(
        "Adjusting {bob}'s allowance to {SECOND_ALLOWANCE_VALUE}.",
        bob = bob.name
    );

    let _ = AccountAllowanceApproveTransaction::new()
        .approve_hbar_allowance(alice.id, bob.id, SECOND_ALLOWANCE_VALUE)
        .freeze_with(client)?
        .sign(alice.key.clone())
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    println!(
        "Attempting to transfer {SECOND_TRANSFER_VALUE} from {alice} to {charlie} using {bob}'s allowance again.",
        alice=alice.name,
        bob=bob.name,
        charlie=charlie.name
    );
    println!("This time it should succeed.");

    transfer(client, accounts, SECOND_TRANSFER_VALUE).await?;

    println!("Transfer succeeded.");

    print_balances(client, accounts).await?;

    println!("Deleting {bob}'s allowance", bob = bob.name);

    let _ = AccountAllowanceApproveTransaction::new()
        .approve_hbar_allowance(alice.id, bob.id, Hbar::ZERO)
        .freeze_with(client)?
        .sign(alice.key.clone())
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    Ok(())
}

async fn clean_up(
    client: &Client,
    operator_id: AccountId,
    accounts: [Account; 3],
) -> anyhow::Result<()> {
    println!("Cleaning up...");

    for account in accounts {
        let _ = AccountDeleteTransaction::new()
            .account_id(account.id)
            .transfer_account_id(operator_id)
            .freeze_with(client)?
            .sign(account.key)
            .execute(client)
            .await?
            .get_receipt(client)
            .await?;

        println!("Deleted `{}` ({})", account.name, account.id);
    }

    Ok(())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key);

    let accounts = create_accounts(&client).await?;

    print_balances(&client, &accounts).await?;

    demonstrate_allowances(&client, &accounts).await?;
    clean_up(&client, args.operator_account_id, accounts).await?;

    println!("End of example");

    Ok(())
}

async fn print_balances(client: &Client, accounts: &[Account; 3]) -> hedera::Result<()> {
    for account in accounts {
        let balance = AccountBalanceQuery::new()
            .account_id(account.id)
            .execute(client)
            .await?
            .hbars;

        println!("{name}'s balance: {balance}", name = account.name);
    }

    Ok(())
}
// Filename: examples/consensus_pub_sub.rs
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};

use clap::Parser;
// `use futures::TryStreamExt`, this is better practice though.
use futures_util::TryStreamExt;
use hedera::{
    AccountId, Client, PrivateKey, TopicId, TopicMessageQuery, TopicMessageSubmitTransaction
};
use parking_lot::RwLock;
use tokio::time::sleep;

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "0.0.34945875")]
    topic: TopicId,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_testnet();

    client.set_operator(args.operator_account_id, args.operator_key);

    let message_send_times = Arc::new(RwLock::new(HashMap::new()));

    tokio::spawn({
        let client = client.clone();
        let message_send_times = message_send_times.clone();

        async move {
            for index in 0.. {
                let message = format!("hello, {index}");
                let time = Instant::now();

                message_send_times.write().insert(message.clone(), time);

                // send a message, crash the example program if it fails
                TopicMessageSubmitTransaction::new()
                    .topic_id(args.topic)
                    .message(message.as_bytes())
                    .execute(&client)
                    .await
                    .unwrap();

                sleep(Duration::from_millis(500)).await;
            }
        }
    });

    let mut stream = TopicMessageQuery::new()
        .topic_id(args.topic)
        .subscribe(&client);

    let mut latencies = Vec::new();

    while let Some(tm) = stream.try_next().await? {
        let message = String::from_utf8(tm.contents)?;

        let times = message_send_times.read();
        let start = times.get(&message).unwrap();
        let latency = start.elapsed();

        println!(
            "recv: {}, message: {:?}, latency: {:.3?}",
            tm.sequence_number, message, latency,
        );

        latencies.push(latency.as_secs_f64());

        if latencies.len() == 100 {
            let avg: f64 = latencies.iter().copied().sum::<f64>() / (latencies.len() as f64);

            println!("---- average latency: {avg:.5}s ----");

            latencies.clear();
        }
    }

    Ok(())
}
// Filename: examples/consensus_pub_sub_chunked.rs
// SPDX-License-Identifier: Apache-2.0

use std::time::Duration;

mod resources;

use clap::Parser;
use futures_util::StreamExt;
use hedera::{
    AccountId, Client, PrivateKey, TopicCreateTransaction, TopicMessageQuery, TopicMessageSubmitTransaction, Transaction
};
use tokio::task::JoinHandle;

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // generate a submit key to use with the topic.
    let submit_key = PrivateKey::generate_ed25519();

    let topic_id = TopicCreateTransaction::new()
        .topic_memo("sdk::rust::consensus_pub_sub_chunked")
        .submit_key(submit_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .topic_id
        .unwrap();

    println!("Created Topic `{topic_id}`");

    println!("Waiting 10s for the mirror node to catch up");

    tokio::time::sleep(Duration::from_secs(10)).await;

    let _handle: JoinHandle<hedera::Result<()>> = tokio::spawn({
        let client = client.clone();
        async move {
            println!(
                "about to prepare a transaction to send a message of {} bytes",
                resources::BIG_CONTENTS.len()
            );

            let mut tx = TopicMessageSubmitTransaction::new();

            // note: this used to set `max_chunks(15)` with a comment saying that the default is 10, but it's 20.
            tx.topic_id(topic_id)
                .message(resources::BIG_CONTENTS)
                .sign_with_operator(&client)?;

            // serialize to bytes so we can be signed "somewhere else" by the submit key
            let transaction_bytes = tx.to_bytes()?;

            // now pretend we sent those bytes across the network
            // parse them into a transaction so we can sign as the submit key
            let tx = Transaction::from_bytes(&transaction_bytes)?;

            // view out the message size from the parsed transaction
            // this can be useful to display what we are about to sign

            let mut tx: TopicMessageSubmitTransaction = tx.downcast().unwrap();

            println!(
                "about to send a transaction with a message of {} bytes",
                tx.get_message().map_or(0, |it| it.len())
            );

            // sign with that submit key
            tx.sign(submit_key);

            // now actually submit the transaction
            // get the receipt to ensure there were no errors
            tx.execute(&client).await?.get_receipt(&client).await?;

            println!("Finished sending the message, press ctrl+c to exit once it's recieved");

            Ok(())
        }
    });

    let client = client.clone();
    let mut stream = TopicMessageQuery::new()
        .topic_id(topic_id)
        .subscribe(&client);

    while let Some(elem) = stream.next().await {
        let elem = match elem {
            Ok(it) => it,
            Err(e) => {
                eprintln!("Error while handling message stream: {e:?}");
                break;
            }
        };

        println!(
            "(seq: `{}`, contents: `{}` bytes) reached consensus at {}",
            elem.sequence_number,
            elem.contents.len(),
            elem.consensus_timestamp
        );
    }

    Ok(())
}
// Filename: examples/consensus_pub_sub_with_submit_key.rs
use std::time::Duration;

use clap::Parser;
use futures_util::StreamExt;
use hedera::{
    AccountId, Client, PrivateKey, TopicCreateTransaction, TopicMessageQuery, TopicMessageSubmitTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key);

    // generate a submit key to use with the topic.
    let submit_key = PrivateKey::generate_ed25519();

    let topic_id = TopicCreateTransaction::new()
        .topic_memo("sdk::rust::consensus_pub_sub_with_submit_key")
        .submit_key(submit_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .topic_id
        .unwrap();

    println!("Created Topic `{topic_id}` with submit key `{submit_key}`");

    println!("Waiting 10s for the mirror node to catch up");

    tokio::time::sleep(Duration::from_secs(10)).await;

    let _handle: tokio::task::JoinHandle<hedera::Result<()>> = tokio::spawn({
        let client = client.clone();
        async move {
            println!("sending 5 messages");

            for i in 0..5 {
                let v: i64 = rand::random();
                let message = format!("random message: {v}");

                println!("publishing message {i}: `{message}`");

                TopicMessageSubmitTransaction::new()
                    .topic_id(topic_id)
                    .message(message)
                    .sign(submit_key.clone())
                    .execute(&client)
                    .await?
                    .get_receipt(&client)
                    .await?;

                tokio::time::sleep(Duration::from_secs(2)).await;
            }

            println!(
                "Finished sending the messages, press ctrl+c to exit once they're all recieved"
            );

            Ok(())
        }
    });

    let client = client.clone();
    let mut stream = TopicMessageQuery::new()
        .topic_id(topic_id)
        .subscribe(&client);

    while let Some(elem) = stream.next().await {
        let elem = match elem {
            Ok(it) => it,
            Err(e) => {
                eprintln!("Error while handling message stream: {e:?}");
                break;
            }
        };

        println!(
            "(seq: `{}`, contents: `{}`) reached consensus at {}",
            elem.sequence_number,
            String::from_utf8_lossy(&elem.contents),
            elem.consensus_timestamp
        );
    }

    Ok(())
}
// Filename: examples/contract/mod.rs
// SPDX-License-Identifier: Apache-2.0

use hedera::{
    AccountId, Client, ContractCreateFlow, ContractExecuteTransaction, ContractFunctionParameters,
    ContractFunctionResult, ContractId, Hbar, PrivateKey, TransactionId,
};

#[derive(Default)]
pub struct ContractStep {
    pub result_inspector: Option<fn(&ContractFunctionResult)>,
    pub parameters: Option<Box<dyn Fn() -> ContractFunctionParameters>>,
    pub payable_amount: Option<Hbar>,
    pub signers: Vec<PrivateKey>,
    pub fee_payer: Option<AccountId>,
}

pub struct ContractHelper {
    contract_id: ContractId,
    steps: Vec<ContractStep>,
}

impl ContractHelper {
    pub fn new(contract_id: ContractId, steps: Vec<ContractStep>) -> Self {
        Self { contract_id, steps }
    }

    pub async fn execute(&self, client: &Client) -> hedera::Result<()> {
        for (index, step) in self.steps.iter().enumerate() {
            println!("Attempting to execute step {index}");

            let mut tx = ContractExecuteTransaction::new();

            tx.contract_id(self.contract_id).gas(10_000_000);

            if let Some(payable_amount) = step.payable_amount {
                tx.payable_amount(payable_amount);
            }

            let function_name = format!("step{index}");
            let params = step.parameters.as_deref().map(|it| it());

            match params {
                Some(params) => tx.function_with_parameters(&function_name, &params),
                None => tx.function(&function_name),
            };

            if let Some(fee_payer) = step.fee_payer {
                tx.transaction_id(TransactionId::generate(fee_payer));
            }

            tx.freeze_with(client)?;

            for signer in &step.signers {
                tx.sign(signer.clone());
            }

            let record = tx
                .execute(client)
                .await?
                .validate_status(false)
                .get_record(client)
                .await?;

            if let Err(e) = record.receipt.validate_status(true) {
                eprintln!("Error occurred during step{index}: {e}");
                eprintln!("Transaction record: {record:?}");
                break;
            }

            let function_result = record.contract_function_result.unwrap();
            println!("gas used: {}", function_result.gas_used);

            if let Some(inspector) = step.result_inspector {
                inspector(&function_result)
            }

            println!(
                "step {index} completed, and returned valid result. (TransactionId `{}`",
                record.transaction_id
            );
        }

        Ok(())
    }
}

pub async fn create_contract(
    client: &Client,
    bytecode: &str,
    constructor_parameters: ContractFunctionParameters,
) -> hedera::Result<ContractId> {
    let contract_id = ContractCreateFlow::new()
        .bytecode_hex(bytecode)?
        .max_chunks(30)
        .gas(8_000_000)
        .constructor_parameters(constructor_parameters.to_bytes(None))
        .execute(client)
        .await?
        .get_receipt(client)
        .await?
        .contract_id
        .unwrap();

    Ok(contract_id)
}
// Filename: examples/create_account.rs
// SPDX-License-Identifier: Apache-2.0

use assert_matches::assert_matches;
use clap::Parser;
use hedera::{AccountCreateTransaction, AccountId, Client, PrivateKey};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_testnet();

    client.set_operator(args.operator_account_id, args.operator_key);

    let new_key = PrivateKey::generate_ed25519();

    println!("private key = {new_key}");
    println!("public key = {}", new_key.public_key());

    let response = AccountCreateTransaction::new()
        .key(new_key.public_key())
        .execute(&client)
        .await?;

    let receipt = response.get_receipt(&client).await?;

    let new_account_id = assert_matches!(receipt.account_id, Some(id) => id);

    println!("account address = {new_account_id}");

    Ok(())
}
// Filename: examples/create_account_threshold_key.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountBalanceQuery, AccountCreateTransaction, AccountId, Client, Hbar, Key, KeyList, PrivateKey, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key);

    // Generate three Ed25519::new private, public key pairs.
    // You do not need the private keys to create the Threshold Key List,
    // you only need the public keys, and if you're doing things correctly,
    // you probably shouldn't have these private keys.
    let private_keys = [
        PrivateKey::generate_ed25519(),
        PrivateKey::generate_ed25519(),
        PrivateKey::generate_ed25519(),
    ];

    println!("public keys:");
    for public_key in private_keys.iter().map(PrivateKey::public_key) {
        println!("{public_key}");
    }

    // require 2 of the 3 keys we generated to sign on anything modifying this account
    let transaction_key = KeyList {
        keys: private_keys
            .iter()
            .map(PrivateKey::public_key)
            .map(Key::from)
            .collect(),
        threshold: Some(2),
    };

    let transaction_response = AccountCreateTransaction::new()
        .key(transaction_key)
        .initial_balance(Hbar::new(10))
        .execute(&client)
        .await?;

    // This will wait for the receipt to become available
    let receipt = transaction_response.get_receipt(&client).await?;

    let new_account_id = receipt.account_id.unwrap();

    println!("account = {new_account_id}");

    let transfer_transaction_response = TransferTransaction::new()
        .hbar_transfer(new_account_id, Hbar::new(10).negated())
        .hbar_transfer(AccountId::from(3), Hbar::new(10))
        // we sign with 2 of the 3 keys
        .sign(private_keys[0].clone())
        .sign(private_keys[1].clone())
        .execute(&client)
        .await?;

    // (important!) wait for the transfer to go to consensus
    transfer_transaction_response.get_receipt(&client).await?;

    let balance_after = AccountBalanceQuery::new()
        .account_id(new_account_id)
        .execute(&client)
        .await?
        .hbars;

    println!("account balance after transfer: {balance_after}");

    Ok(())
}
// Filename: examples/create_file.rs
// SPDX-License-Identifier: Apache-2.0

use assert_matches::assert_matches;
use clap::Parser;
use hedera::{AccountId, Client, FileCreateTransaction, PrivateKey};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_testnet();

    client.set_operator(args.operator_account_id, args.operator_key);

    let receipt = FileCreateTransaction::new()
        .contents(&b"Hiero is great!"[..])
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let new_file_id = assert_matches!(receipt.file_id, Some(id) => id);

    println!("file address = {new_file_id}");

    Ok(())
}
// Filename: examples/create_simple_contract.rs
// SPDX-License-Identifier: Apache-2.0

mod resources;

use clap::Parser;
use hedera::{
    AccountId, Client, ContractCallQuery, ContractCreateTransaction, ContractDeleteTransaction, ContractFunctionParameters, FileCreateTransaction, PrivateKey
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    let bytecode = resources::simple_bytecode();

    // create the contract's bytecode file
    let file_transaction_response = FileCreateTransaction::new()
        // Use the same key as the operator to "own" this file
        .keys([args.operator_key.public_key()])
        .contents(bytecode)
        .execute(&client)
        .await?;

    let file_receipt = file_transaction_response.get_receipt(&client).await?;
    let new_file_id = file_receipt.file_id.unwrap();

    println!("contract bytecode file: {new_file_id}");

    let contract_transaction_response = ContractCreateTransaction::new()
        .bytecode_file_id(new_file_id)
        .gas(500_000)
        .admin_key(args.operator_key.public_key())
        .constructor_parameters(
            ContractFunctionParameters::new()
                .add_string("hello from hedera!")
                .to_bytes(None),
        )
        .execute(&client)
        .await?;

    let contract_receipt = contract_transaction_response.get_receipt(&client).await?;
    let new_contract_id = contract_receipt.contract_id.unwrap();

    println!("new contract ID: {new_contract_id}");

    let contract_call_result = ContractCallQuery::new()
        .contract_id(new_contract_id)
        .gas(500_000)
        .function("greet")
        .execute(&client)
        .await?;

    if let Some(err) = contract_call_result.error_message {
        anyhow::bail!("error calling contract: {err}");
    }

    let message = contract_call_result.get_str(0);
    println!("contract returned message: {message:?}");

    // now delete the contract
    let _contract_delete_result = ContractDeleteTransaction::new()
        .contract_id(new_contract_id)
        .transfer_account_id(args.operator_account_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("Contract successfully deleted");

    Ok(())
}
// Filename: examples/create_stateful_contract.rs
// SPDX-License-Identifier: Apache-2.0

mod resources;

use clap::Parser;
use hedera::{
    AccountId, Client, ContractCallQuery, ContractCreateTransaction, ContractExecuteTransaction, ContractFunctionParameters, FileCreateTransaction, PrivateKey
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    let bytecode = resources::stateful_bytecode();

    // create the contract's bytecode file
    let file_transaction_response = FileCreateTransaction::new()
        // Use the same key as the operator to "own" this file
        .keys([args.operator_key.public_key()])
        .contents(bytecode)
        .execute(&client)
        .await?;

    let file_receipt = file_transaction_response.get_receipt(&client).await?;
    let new_file_id = file_receipt.file_id.unwrap();

    println!("contract bytecode file: {new_file_id}");

    let contract_transaction_response = ContractCreateTransaction::new()
        .bytecode_file_id(new_file_id)
        .gas(500_000)
        .constructor_parameters(
            ContractFunctionParameters::new()
                .add_string("hello from hedera!")
                .to_bytes(None),
        )
        .execute(&client)
        .await?;

    let contract_receipt = contract_transaction_response.get_receipt(&client).await?;
    let new_contract_id = contract_receipt.contract_id.unwrap();

    println!("new contract ID: {new_contract_id}");

    let contract_call_result = ContractCallQuery::new()
        .contract_id(new_contract_id)
        .gas(500_000)
        .function("get_message")
        .execute(&client)
        .await?;

    if let Some(err) = contract_call_result.error_message {
        anyhow::bail!("error calling contract: {err}");
    }

    let message = contract_call_result.get_str(0);
    println!("contract returned message: {message:?}");

    let contract_exec_transaction_response = ContractExecuteTransaction::new()
        .contract_id(new_contract_id)
        .gas(500_000)
        .function_with_parameters(
            "set_message",
            ContractFunctionParameters::new().add_string("hello from hedera again!"),
        )
        .execute(&client)
        .await?;

    // if this doesn't throw then we know the contract executed successfully
    contract_exec_transaction_response
        .get_receipt(&client)
        .await?;

    // now query contract
    let contract_update_result = ContractCallQuery::new()
        .contract_id(new_contract_id)
        .gas(500_000)
        .function("get_message")
        .execute(&client)
        .await?;

    if let Some(err) = contract_update_result.error_message {
        anyhow::bail!("error calling contract: {err}");
    }

    let message2 = contract_update_result.get_str(0);
    println!("contract returned message: {message2:?}");

    Ok(())
}
// Filename: examples/create_topic.rs
// SPDX-License-Identifier: Apache-2.0

use assert_matches::assert_matches;
use clap::Parser;
use hedera::{AccountId, Client, PrivateKey, TopicCreateTransaction};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_testnet();

    client.set_operator(args.operator_account_id, args.operator_key);

    let receipt = TopicCreateTransaction::new()
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let new_topic_id = assert_matches!(receipt.topic_id, Some(id) => id);

    println!("topic address = {new_topic_id}");

    Ok(())
}
// Filename: examples/delete_file.rs
// SPDX-License-Identifier: Apache-2.0

use std::iter;

use clap::Parser;
use hedera::{AccountId, Client, FileCreateTransaction, FileDeleteTransaction, PrivateKey};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    let receipt = FileCreateTransaction::new()
        .contents(&b"Hiero is great!"[..])
        .keys(iter::once(args.operator_key.public_key()))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let new_file_id = receipt.file_id.unwrap();

    println!("file: {new_file_id}");

    FileDeleteTransaction::new()
        .file_id(new_file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("File deleted successfully");

    Ok(())
}
// Filename: examples/file_append_chunked.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountId, FileAppendTransaction, FileContentsQuery, FileCreateTransaction, Hbar, PrivateKey
};

mod resources;

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv().ok();

    let args = Args::parse();

    let client = hedera::Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    let response = FileCreateTransaction::new()
        .keys([args.operator_key.public_key()])
        .contents("[sdk::rust::example::file_append_chunked]\n\n")
        .max_transaction_fee(Hbar::new(2))
        .execute(&client)
        .await?;

    let receipt = response.get_receipt(&client).await?;

    let file_id = receipt.file_id.unwrap();

    println!("file_id: {file_id}");

    let responses = FileAppendTransaction::new()
        .node_account_ids([response.node_account_id])
        .file_id(file_id)
        .contents(resources::BIG_CONTENTS)
        .max_transaction_fee(Hbar::new(5))
        .execute_all(&client)
        .await?;

    let _ = responses.last().unwrap().get_receipt(&client).await?;

    let contents = FileContentsQuery::new()
        .file_id(file_id)
        .execute(&client)
        .await?;

    println!(
        "File content size according to `FileInfoQuery`: `{}` bytes",
        contents.contents.len()
    );

    Ok(())
}
// Filename: examples/generate_key.rs
// SPDX-License-Identifier: Apache-2.0

use hedera::PrivateKey;

fn main() {
    // Generate a Ed25519 key
    // This is the current recommended default for Hiero

    let private = PrivateKey::generate_ed25519();
    let public = private.public_key();

    println!("ed25519 private = {private}");
    println!("ed25519 public = {public}");

    // Generate a ECDSA(secp256k1) key
    // This is recommended for better compatibility with Ethereum

    let private = PrivateKey::generate_ecdsa();
    let public = private.public_key();

    println!("ecdsa(secp256k1) private = {private}");
    println!("ecdsa(secp256k1) public = {public}");
}
// Filename: examples/get_account_balance.rs
// SPDX-License-Identifier: Apache-2.0

use hedera::{AccountBalanceQuery, AccountId, Client, NodeAddressBookQuery};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // let client = Client::for_mainnet();
    let client = Client::for_testnet();
    dbg!(NodeAddressBookQuery::new()
        .execute(&client)
        .await?
        .node_addresses
        .into_iter()
        .map(|it| (it.node_account_id, it.service_endpoints))
        .collect::<Vec<_>>());

    let id = AccountId::from(7);

    let ab = AccountBalanceQuery::new()
        .account_id(id)
        // .node_account_ids([AccountId::from(7)])
        .execute(&client)
        .await?;

    println!("balance = {}", ab.hbars);

    Ok(())
}
// Filename: examples/get_account_info.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{AccountId, AccountInfoQuery, Client, PrivateKey};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_testnet();

    client.set_operator(args.operator_account_id, args.operator_key);

    let id = AccountId::from(34_938_045);

    let info = AccountInfoQuery::new()
        .account_id(id)
        .execute(&client)
        .await?;

    println!("info = {info:#?}");

    Ok(())
}
// Filename: examples/get_exchange_rates.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{AccountId, Client, ExchangeRates, FileContentsQuery, FileId, PrivateKey};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,

    #[clap(long, env, default_value_t = FileId::EXCHANGE_RATES)]
    hedera_exchange_rates_file: FileId,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    let response = FileContentsQuery::new()
        .file_id(args.hedera_exchange_rates_file)
        .execute(&client)
        .await?;

    let ExchangeRates {
        current_rate,
        next_rate,
    } = ExchangeRates::from_bytes(&response.contents)?;

    println!("Current numerator: {}", current_rate.cents);
    println!("Current denominator: {}", current_rate.hbars);
    println!("Current expiration time: {}", current_rate.expiration_time);
    println!(
        "Current Exchange Rate: {}",
        current_rate.exchange_rate_in_cents()
    );

    println!("Next numerator: {}", next_rate.cents);
    println!("Next denominator: {}", next_rate.hbars);
    println!("Next expiration time: {}", next_rate.expiration_time);
    println!("Next Exchange Rate: {}", next_rate.exchange_rate_in_cents());

    Ok(())
}
// Filename: examples/get_file_contents.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{AccountId, Client, FileContentsQuery, FileId, PrivateKey};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "0.0.34945328")]
    file: FileId,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_testnet();

    client.set_operator(args.operator_account_id, args.operator_key);

    let cr = FileContentsQuery::new()
        .file_id(args.file)
        .execute(&client)
        .await?;

    let contents = String::from_utf8(cr.contents)?;

    println!("contents: {contents}");

    Ok(())
}
// Filename: examples/initialize_client_with_mirror_network.rs
// SPDX-License-Identifier: Apache-2.0

use assert_matches::assert_matches;
use clap::Parser;
use hedera::{AccountCreateTransaction, AccountId, Client, Hbar, PrivateKey};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    /*
     * Step 0: Create and Configure the Client
     */
    let client =
        Client::for_mirror_network(vec!["testnet.mirrornode.hedera.com:443".to_owned()]).await?;

    // Set the operator account ID and key that will pay and sign all generated transactions.
    client.set_operator(args.operator_account_id, args.operator_key);

    /*
     * Step 1: Genereate ED25519 key pair
     */
    println!("Generating ED25519 key pair...");
    let private_key = PrivateKey::generate_ed25519();

    /*
     * Step 2: Create an account
     */
    let alice_id = AccountCreateTransaction::new()
        .key(private_key.public_key())
        .initial_balance(Hbar::new(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id;

    let alice_id = assert_matches!(alice_id, Some(id) => id);

    println!("Alice's ID = {alice_id}");

    Ok(())
}
// Filename: examples/long_term_scheduled_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountId, AccountInfoQuery, AccountUpdateTransaction, Client, Hbar, Key, KeyList, PrivateKey, ScheduleInfoQuery, ScheduleSignTransaction, TransferTransaction
};
use time::{Duration, OffsetDateTime};
use tokio::time::sleep;

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    /*
     * Step 0: Create and configure the client
     */
    let client = Client::for_name(&args.hedera_network)?;
    client.set_operator(args.operator_account_id, args.operator_key);

    /*
     * Step 1: Create key pairs
     */
    let key1 = PrivateKey::generate_ed25519();
    let key2 = PrivateKey::generate_ed25519();

    println!("Creating Key List... (w/ threshold, 2 of 2 keys generated above is required to modify the account)");

    let threshold_key = KeyList {
        keys: vec![key1.public_key().into(), key2.public_key().into()],
        threshold: Some(2),
    };

    println!("Created key list: {threshold_key:?}");

    /*
     * Step 2: Create the account
     */
    println!("Creating account with threshold key...");
    let alice_id = AccountCreateTransaction::new()
        .key(Key::KeyList(threshold_key))
        .initial_balance(Hbar::new(2))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    println!("Created account with id: {alice_id}");

    /*
     * Step 3:
     * Schedule a transfer transaction of 1 hbar from the newly created account to the operator account.
     * The transaction will be scheduled with expirationTime = 24 hours from now and waitForExpiry = false.
     */
    println!("Creating new scheduled transaction with 1 day expiry...");
    let mut transfer = TransferTransaction::new();
    transfer
        .hbar_transfer(alice_id, Hbar::new(-1))
        .hbar_transfer(args.operator_account_id, Hbar::new(1));

    let schedule_id = transfer
        .schedule()
        .wait_for_expiry(false)
        .expiration_time(OffsetDateTime::now_utc() + Duration::seconds(86400))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    /*
     * Step 4: Sign the transaction with one key and verify the transaction is not executed
     */
    println!("Signing transaction with key 1...");
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key1.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?;

    println!(
        "Scheduled transaction is not executed yet. Executed at: {:?}",
        info.executed_at
    );

    /*
     * Step 5: Sign the transaction with the second key and verify the transaction is executed
     */

    let account_balance = AccountInfoQuery::new()
        .account_id(alice_id)
        .execute(&client)
        .await?
        .balance;

    println!("Alice's account balance before scheduled transaction: {account_balance}");

    println!("Signing transaction with key 2...");
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key2.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let account_balance = AccountInfoQuery::new()
        .account_id(alice_id)
        .execute(&client)
        .await?
        .balance;

    println!("Alice's account balance after scheduled transaction: {account_balance}");

    let info = ScheduleInfoQuery::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?;

    println!("Scheduled transaction executed at: {:?}", info.executed_at);

    /*
     * Step 6:
     * Schedule another transfer transaction of 1 Hbar from the account to the operator account
     * with an expirationTime of 10 seconds in the future and waitForExpiry=true.
     */
    println!("Creating new scheduled transaction with 10 second expiry...");
    let mut transfer = TransferTransaction::new();
    transfer
        .hbar_transfer(alice_id, Hbar::new(-1))
        .hbar_transfer(args.operator_account_id, Hbar::new(1));

    let schedule_id = transfer
        .schedule()
        .wait_for_expiry(true)
        .expiration_time(OffsetDateTime::now_utc() + Duration::seconds(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    /*
     * Step 7:
     * Sign the transaction with one key and verify the transaction is not executed
     */
    println!("Signing scheduled transaction with key 1...");
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key1.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?;

    println!(
        "Scheduled transaction is not executed yet. Executed at: {:?}",
        info.executed_at
    );

    /*
     * Step 8:
     * Update the account's key to be only the one key
     * that has already signed the scheduled transfer.
     */
    println!("Updating account key to only key 1...");
    _ = AccountUpdateTransaction::new()
        .account_id(alice_id)
        .key(key1.public_key())
        .freeze_with(&client)?
        .sign(key1)
        .sign(key2)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    /*
     * Step 9:
     * Verify that the transfer successfully executes roughly at the time of its expiration.
     */
    let account_balance = AccountInfoQuery::new()
        .account_id(alice_id)
        .execute(&client)
        .await?
        .balance;

    println!("Alice's account balance before scheduled transfer: {account_balance}");

    sleep(std::time::Duration::from_millis(10_000)).await;

    let account_balance = AccountInfoQuery::new()
        .account_id(alice_id)
        .execute(&client)
        .await?
        .balance;

    println!("Alice's account balance after scheduled transfer: {account_balance}");

    println!("Successfully executed scheduled transfer");

    Ok(())
}
// Filename: examples/modify_token_keys.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountId, Client, KeyList, PrivateKey, PublicKey, TokenCreateTransaction, TokenInfoQuery, TokenKeyValidation, TokenUpdateTransaction
};
use time::{Duration, OffsetDateTime};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_id, args.operator_key.clone());

    // Generate a higher-privileged key.
    let admin_key = PrivateKey::generate_ed25519();

    // Generate the lower-privileged keys that will be modified.
    // Note: Lower-privileged keys are KYC, Freeze, Wipe, and Supply, Fee Schedule, Metadata key.
    let supply_key = PrivateKey::generate_ed25519();
    let wipe_key = PrivateKey::generate_ed25519();
    let new_supply_key = PrivateKey::generate_ed25519();

    // Generate an invalid key to update the supply key.
    let unusable = PublicKey::from_str_ed25519(
        "0x0000000000000000000000000000000000000000000000000000000000000000",
    )
    .unwrap();

    // Create the NFT token with admin, wipe, and supply keys.
    let token_id = TokenCreateTransaction::new()
        .name("Example NFT")
        .symbol("ENFT")
        .token_type(hedera::TokenType::NonFungibleUnique)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .admin_key(admin_key.public_key())
        .wipe_key(wipe_key.public_key())
        .supply_key(supply_key.public_key())
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .freeze_with(&client)?
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    println!("Admin Key: {:?}", token_info.admin_key);
    println!("Supply Key: {:?}", token_info.supply_key);
    println!("Wipe Key: {:?}", token_info.wipe_key);

    println!("------");
    println!("Removing Wipe Key...");

    // Remove the wipe key with an empty key list, signing with the admin key.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(KeyList::new())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    println!("Wipe Key (after removal): {:?}", token_info.wipe_key);

    println!("------");
    println!("Removing Admin Key...");

    // Remove the admin key with an empty key list, signing with the admin key.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .admin_key(KeyList::new())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    println!("Admin Key (after removal): {:?}", token_info.admin_key);

    println!("------");
    println!("Updating Supply Key...");

    // Update the supply key with a new key, signing with the old supply key and the new supply key.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .supply_key(new_supply_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(supply_key)
        .sign(new_supply_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    println!("Supply Key (after update): {:?}", token_info.supply_key);

    println!("------");
    println!("Removing Supply Key...");

    // Remove the supply key with an invalid key, signing with the new supply key.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .supply_key(unusable)
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(new_supply_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    let supply_key = token_info.supply_key.unwrap();

    println!("Supply Key (after removal): {:?}", supply_key);

    Ok(())
}
// Filename: examples/multi_app_transfer.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountBalanceQuery, AccountCreateTransaction, AccountId, Client, Hbar, PrivateKey, Transaction, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key);

    // the exchange should possess this key, we're only generating it for demonstration purposes
    let exchange_key = PrivateKey::generate_ed25519();
    // this is the only key we should actually possess
    let user_key = PrivateKey::generate_ed25519();

    // the exchange creates an account for the user to transfer funds to
    let exchange_account_id = AccountCreateTransaction::new()
        // the exchange only accepts transfers that it validates through a side channel (e.g. REST API)
        .receiver_signature_required(true)
        .key(exchange_key.public_key())
        // The owner key has to sign this transaction
        // when receiver_signature_required is true
        .freeze_with(&client)?
        .sign(exchange_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    // for the purpose of this example we create an account for
    // the user with a balance of 5 h
    let user_account_id = AccountCreateTransaction::new()
        .initial_balance(Hbar::new(5))
        .key(user_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    // next we make a transfer from the user account to the
    // exchange account, this requires signing by both parties
    let mut transfer_txn = TransferTransaction::new();

    transfer_txn
        .hbar_transfer(user_account_id, Hbar::new(-2))
        .hbar_transfer(exchange_account_id, Hbar::new(2))
        // the exchange-provided memo required to validate the transaction
        .transaction_memo("https://some-exchange.com/user1/account1")
        // NOTE: to manually sign, you must freeze the Transaction first
        .freeze_with(&client)?
        .sign(user_key);

    // the exchange must sign the transaction in order for it to be accepted by the network
    // assume this is some REST call to the exchange API server
    let signed_txn_bytes = exchange_signs_transaction(exchange_key, &transfer_txn.to_bytes()?)?;

    // parse the transaction bytes returned from the exchange
    let mut signed_transfer_txn = Transaction::from_bytes(&signed_txn_bytes)?
        .downcast::<TransferTransaction>()
        .unwrap();

    // get the amount we are about to transfer
    // we built this with +2, -2 (which we might see in any order)
    let transfer_amount = signed_transfer_txn
        .get_hbar_transfers()
        .values()
        .copied()
        .next()
        .map(|it| if Hbar::ZERO >= it { it } else { -it });

    println!("about to transfer {transfer_amount:?}...");

    // we now execute the signed transaction and wait for it to be accepted
    let transaction_response = signed_transfer_txn.execute(&client).await?;

    // (important!) wait for consensus by querying for the receipt
    transaction_response.get_receipt(&client).await?;

    let sender_balance_after = AccountBalanceQuery::new()
        .account_id(user_account_id)
        .execute(&client)
        .await?
        .hbars;

    let receipt_balance_after = AccountBalanceQuery::new()
        .account_id(exchange_account_id)
        .execute(&client)
        .await?
        .hbars;

    println!("{user_account_id} balance = {sender_balance_after}");
    println!("{exchange_account_id} balance = {receipt_balance_after}");

    Ok(())
}

fn exchange_signs_transaction(
    exchange_key: PrivateKey,
    transaction_data: &[u8],
) -> hedera::Result<Vec<u8>> {
    Transaction::from_bytes(transaction_data)?
        .sign(exchange_key)
        .to_bytes()
}
// Filename: examples/multi_sig_offline.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountId, Client, Hbar, KeyList, PrivateKey, Transaction, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key);

    let user1_key = PrivateKey::generate_ed25519();
    let user2_key = PrivateKey::generate_ed25519();

    println!("private key for user 1 = {user1_key}");
    println!("public key for user 1 = {}", user1_key.public_key());
    println!("private key for user 2 = {user2_key}");
    println!("public key for user 2 = {}", user2_key.public_key());

    // create a multi-sig account
    let keylist = KeyList::from([user1_key.public_key(), user2_key.public_key()]);

    let create_account_transaction = AccountCreateTransaction::new()
        .initial_balance(Hbar::new(2))
        .key(keylist)
        .execute(&client)
        .await?;

    let receipt = create_account_transaction.get_receipt(&client).await?;

    let account_id = receipt.account_id.unwrap();

    println!("account id = {account_id}");

    // create a transfer from new account to 0.0.3
    let mut transfer_transaction = TransferTransaction::new();

    transfer_transaction
        .node_account_ids([(AccountId::from(3))])
        .hbar_transfer(account_id, Hbar::new(-1))
        .hbar_transfer(AccountId::from(3), Hbar::new(1))
        .freeze_with(&client)?;

    // convert transaction to bytes to send to signatories
    let transaction_bytes = transfer_transaction.to_bytes()?;
    let mut transaction_to_execute = Transaction::from_bytes(&transaction_bytes)?;

    // ask users to sign and return signature
    let user1_signature =
        user1_key.sign_transaction(&mut Transaction::from_bytes(&transaction_bytes)?)?;
    let user2_signature =
        user2_key.sign_transaction(&mut Transaction::from_bytes(&transaction_bytes)?)?;

    // recreate the transaction from bytes
    transaction_to_execute.sign_with_operator(&client)?;
    transaction_to_execute.add_signature(user1_key.public_key(), user1_signature);
    transaction_to_execute.add_signature(user2_key.public_key(), user2_signature);

    let result = transaction_to_execute.execute(&client).await?;
    let receipt = result.get_receipt(&client).await?;
    println!("{:?}", receipt.status);

    Ok(())
}
// Filename: examples/nft_update_metadata.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountId, Client, Hbar, NftId, PrivateKey, TokenCreateTransaction, TokenInfoQuery, TokenMintTransaction, TokenNftInfoQuery, TokenType, TokenUpdateNftsTransaction, TransferTransaction
};
use time::{Duration, OffsetDateTime};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // Generate a supply key
    let supply_key = PrivateKey::generate_ed25519();
    // Generate a metadata key
    let metadata_key = PrivateKey::generate_ed25519();
    // Initial metadata
    let metadata: Vec<u8> = vec![1];
    // New metadata
    let new_metadata: Vec<u8> = vec![1, 2];

    let token_create_receipt = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .token_type(TokenType::NonFungibleUnique)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .supply_key(client.get_operator_public_key().unwrap())
        .metadata_key(metadata_key.public_key())
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(args.operator_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_id = token_create_receipt.token_id.unwrap();

    println!("Token id: {token_id:?}");

    let token_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    println!("Token metadata key: {:?}", token_info.metadata_key);

    // Mint the token
    let token_mint_receipt = TokenMintTransaction::new()
        .token_id(token_id)
        .metadata([metadata])
        .freeze_with(&client)?
        .sign(supply_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!(
        "Status of token mint transaction: {:?}",
        token_create_receipt.status
    );

    let nft_serial = *token_mint_receipt.serials.first().unwrap() as u64;

    let nft_id = NftId {
        token_id,
        serial: nft_serial,
    };

    let token_nfts_info = TokenNftInfoQuery::new()
        .nft_id(nft_id)
        .execute(&client)
        .await?;

    println!("Set token NFT metadata: {:?}", token_nfts_info.metadata);

    let account_id = AccountCreateTransaction::new()
        .key(client.get_operator_public_key().unwrap())
        .max_automatic_token_associations(10)
        .initial_balance(Hbar::new(100))
        .freeze_with(&client)?
        .sign(args.operator_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    println!("New Account id: {account_id:?}");

    let transfer_nft_tx = TransferTransaction::new()
        .nft_transfer(
            nft_id,
            client.get_operator_account_id().unwrap(),
            account_id,
        )
        .freeze_with(&client)?
        .sign(args.operator_key.clone())
        .execute(&client)
        .await?;

    let transfer_nft_response = transfer_nft_tx.get_receipt(&client).await?;

    println!(
        "Status of transfer NFT transaction: {:?}",
        transfer_nft_response.status
    );

    let token_update_nfts_receipt = TokenUpdateNftsTransaction::new()
        .token_id(token_id)
        .serials(vec![nft_serial as i64])
        .metadata(new_metadata)
        .freeze_with(&client)?
        .sign(metadata_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!(
        "Status of token update NFT transaction: {:?}",
        token_update_nfts_receipt.status
    );

    let token_nft_info = TokenNftInfoQuery::new()
        .nft_id(nft_id)
        .execute(&client)
        .await?;

    println!("Updated token NFT metadata: {:?}", token_nft_info.metadata);

    Ok(())
}
// Filename: examples/prng.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{AccountId, Client, PrivateKey, PrngTransaction};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key);

    let record = PrngTransaction::new()
        .range(100)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    println!("generated random number = {:?}", record.prng_number);

    Ok(())
}
// Filename: examples/resources/mod.rs
#![allow(dead_code)]

pub const BIG_CONTENTS: &str = include_str!("big_contents.txt");

/// Bytecode for the simple contract example.
pub fn simple_bytecode() -> String {
    const FILE: &str = include_str!("hello-world.json");

    bytecode(FILE)
}
/// Bytecode for the stateful contract example.
pub fn stateful_bytecode() -> String {
    const FILE: &str = include_str!("stateful.json");

    bytecode(FILE)
}

fn bytecode(file: &'static str) -> String {
    let mut obj: miniserde::json::Object = miniserde::json::from_str(file).unwrap();

    let value = obj
        .remove("object")
        .or_else(|| obj.remove("bytecode"))
        .unwrap();

    match value {
        miniserde::json::Value::String(it) => it.clone(),
        _ => unimplemented!(),
    }
}
// Filename: examples/schedule.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountId, Client, Hbar, KeyList, PrivateKey, ScheduleInfoQuery, ScheduleSignTransaction, TransferTransaction
};
use time::OffsetDateTime;

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // Generate a Ed25519 private, public key pair
    let key1 = PrivateKey::generate_ed25519();
    let key2 = PrivateKey::generate_ed25519();

    println!("private key 1 = {key1}");
    println!("public key 1 = {}", key1.public_key());
    println!("private key 2 = {key2}");
    println!("public key 2 = {}", key2.public_key());

    let new_account_id = AccountCreateTransaction::new()
        .key(KeyList::from([key1.public_key(), key2.public_key()]))
        .initial_balance(Hbar::from_tinybars(1000))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    println!("new account ID: {new_account_id}");

    let mut tx = TransferTransaction::new();

    tx.hbar_transfer(new_account_id, -Hbar::new(1))
        .hbar_transfer(args.operator_account_id, Hbar::new(1));

    let response = tx
        .schedule()
        .expiration_time(OffsetDateTime::now_utc() + time::Duration::days(1))
        .wait_for_expiry(true)
        .execute(&client)
        .await?;

    println!("scheduled transaction ID = {}", response.transaction_id);

    let schedule_id = response.get_receipt(&client).await?.schedule_id.unwrap();
    println!("schedule ID = {schedule_id}");

    let record = response.get_record(&client).await?;
    println!("record = {record:?}");

    ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key1)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?;

    println!("schedule info = {info:?}");

    ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key2)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let transaction_id = response.transaction_id;

    println!("The following link should query the mirror node for the scheduled transaction:");

    println!(
        "https://{}.mirrornode.hedera.com/api/v1/transactions/{}",
        args.hedera_network,
        format_args!(
            "{}-{}-{}",
            transaction_id.account_id,
            transaction_id.valid_start.unix_timestamp(),
            transaction_id.valid_start.nanosecond()
        )
    );

    Ok(())
}
// Filename: examples/schedule_identical_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountDeleteTransaction, AccountId, Client, Hbar, Key, KeyList, PrivateKey, ScheduleCreateTransaction, ScheduleId, ScheduleInfoQuery, ScheduleSignTransaction, Status, TransactionReceiptQuery, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    println!("threshold key example");
    println!("keys:");

    let mut private_keys = Vec::with_capacity(3);
    let mut public_keys = Vec::with_capacity(3);
    let mut clients = Vec::with_capacity(3);
    let mut accounts = Vec::with_capacity(3);

    for i in 0..3 {
        let private_key = PrivateKey::generate_ed25519();
        let public_key = private_key.public_key();

        println!("key #{i}");
        println!("private key: {private_key}");
        println!("public key: {public_key}");

        let receipt = AccountCreateTransaction::new()
            .key(public_key)
            .initial_balance(Hbar::new(1))
            .execute(&client)
            .await?
            .get_receipt(&client)
            .await?;

        let account_id = receipt.account_id.unwrap();

        let client = Client::for_name(&args.hedera_network)?;

        client.set_operator(account_id, private_key.clone());

        private_keys.push(private_key);
        public_keys.push(public_key);
        clients.push(client);
        accounts.push(account_id);
        println!("account = {account_id}");
    }

    let key_list = KeyList {
        keys: public_keys.iter().copied().map(Key::from).collect(),
        threshold: Some(2),
    };

    // We are using all of these keys, so the scheduled transaction doesn't automatically go through
    // It works perfectly fine with just one key
    // The key that must sign each transfer out of the account. If receiverSigRequired is true, then
    // it must also sign any transfer into the account.
    let threshold_account = AccountCreateTransaction::new()
        .key(key_list.clone())
        .initial_balance(Hbar::new(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    println!("threshold account = {threshold_account}");

    let mut schedule_id: Option<ScheduleId> = None;

    for (loop_client, operator_id) in clients.iter().zip(&accounts) {
        // Each loopClient creates an identical transaction, sending 1 hbar to each of the created accounts,
        // sent from the threshold Account
        let mut tx = TransferTransaction::new();
        for account in &accounts {
            tx.hbar_transfer(*account, Hbar::new(1));
        }

        tx.hbar_transfer(threshold_account, -Hbar::new(3));

        let mut scheduled_tx = ScheduleCreateTransaction::new();

        scheduled_tx.scheduled_transaction(tx);

        scheduled_tx.payer_account_id(threshold_account);

        let response = scheduled_tx.execute(loop_client).await?;

        let loop_receipt = TransactionReceiptQuery::new()
            .transaction_id(response.transaction_id)
            .node_account_ids([response.node_account_id])
            .execute(loop_client)
            .await?;

        println!(
            "operator [{operator_id}]: schedule_id = {:?}",
            loop_receipt.schedule_id
        );

        // Save the schedule ID, so that it can be asserted for each loopClient submission
        let schedule_id = &*schedule_id.get_or_insert_with(|| loop_receipt.schedule_id.unwrap());

        if Some(schedule_id) != loop_receipt.schedule_id.as_ref() {
            println!(
                "invalid generated schedule id, expected {schedule_id}, got {:?}",
                loop_receipt.schedule_id
            );
        }

        // If the status return by the receipt is related to already created, execute a schedule sign transaction
        if loop_receipt.status == Status::IdenticalScheduleAlreadyCreated {
            let sign_response = ScheduleSignTransaction::new()
                .schedule_id(*schedule_id)
                .node_account_ids([response.node_account_id])
                .execute(loop_client)
                .await?;

            let sign_receipt = TransactionReceiptQuery::new()
                .transaction_id(sign_response.transaction_id)
                .execute(&client)
                .await?;

            if !matches!(
                sign_receipt.status,
                Status::Success | Status::ScheduleAlreadyExecuted
            ) {
                println!(
                    "Bad status while getting receipt of schedule sign with operator {operator_id}: {:?}"
, sign_receipt.status,
                );
                return Ok(());
            }
        }
    }

    println!(
        "{:?}",
        ScheduleInfoQuery::new()
            .schedule_id(schedule_id.unwrap())
            .execute(&client)
            .await?
    );

    let mut threshold_delete_tx = AccountDeleteTransaction::new();

    threshold_delete_tx
        .account_id(threshold_account)
        .transfer_account_id(args.operator_account_id)
        .freeze_with(&client)?;

    for (key, account) in private_keys.into_iter().zip(accounts) {
        threshold_delete_tx.sign(key.clone());

        AccountDeleteTransaction::new()
            .account_id(account)
            .transfer_account_id(args.operator_account_id)
            .freeze_with(&client)?
            .sign(key)
            .execute(&client)
            .await?
            .get_receipt(&client)
            .await?;
    }

    threshold_delete_tx
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: examples/schedule_multi_sig_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountId, Client, Hbar, KeyList, PrivateKey, ScheduleInfoQuery, ScheduleSignTransaction, TransactionId, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // Generate 3 random keys
    let key1 = PrivateKey::generate_ed25519();
    let key2 = PrivateKey::generate_ed25519();
    let key3 = PrivateKey::generate_ed25519();

    // Create a keylist from those keys. This key will be used as the new account's key
    // The reason we want to use a `KeyList` is to simulate a multi-party system where
    // multiple keys are required to sign.
    let key_list = KeyList::from([key1.public_key(), key2.public_key(), key3.public_key()]);

    println!("key1 private = {key1}");
    println!("key1 public = {}", key1.public_key());
    println!("key1 private = {key2}");
    println!("key2 public = {}", key2.public_key());
    println!("key1 private = {key3}");
    println!("key3 public = {}", key3.public_key());
    println!("key_list = {key_list:?}");

    // Creat the account with the `KeyList`
    // The only _required_ property here is `key`
    let response = AccountCreateTransaction::new()
        .node_account_ids([AccountId::from(3)])
        .key(key_list)
        .initial_balance(Hbar::new(10))
        .execute(&client)
        .await?;

    // This will wait for the receipt to become available
    let receipt = response.get_receipt(&client).await?;

    let account_id = receipt.account_id.unwrap();

    println!("accountId = {account_id}");

    // Generate a `TransactionId`. This id is used to query the inner scheduled transaction
    // after we expect it to have been executed
    let transaction_id = TransactionId::generate(args.operator_account_id);

    println!("transaction_id for scheduled transaction = {transaction_id}");

    // Create a transfer transaction with 2/3 signatures.
    let mut transfer = TransferTransaction::new();

    transfer
        .hbar_transfer(account_id, -Hbar::new(1))
        .hbar_transfer(args.operator_account_id, Hbar::new(1));

    // Schedule the transaction
    let receipt = transfer
        .schedule()
        .payer_account_id(args.operator_account_id)
        .admin_key(args.operator_key.public_key())
        .freeze_with(&client)?
        .sign(key2.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Get the schedule ID from the receipt
    let schedule_id = receipt.schedule_id.unwrap();

    println!("schedule_id = {schedule_id}");

    // Get the schedule info to see if `signatories` is populated with 2/3 signatures
    let info = ScheduleInfoQuery::new()
        .node_account_ids([response.node_account_id])
        .schedule_id(schedule_id)
        .execute(&client)
        .await?;

    println!("Schedule Info = {:?}", info);

    let transfer = info
        .scheduled_transaction()?
        .downcast::<TransferTransaction>()
        .unwrap();

    let transfers = transfer.get_hbar_transfers();

    // Make sure the transfer transaction is what we expect
    anyhow::ensure!(transfers.len() == 2, "more transfers than expected");

    anyhow::ensure!(transfers[&account_id] == -Hbar::new(1));
    anyhow::ensure!(transfers[&args.operator_account_id] == Hbar::new(1));

    println!("sending schedule sign transaction");

    // Finally send this last signature to Hiero. This last signature _should_ mean the transaction executes
    // since all 3 signatures have been provided.
    ScheduleSignTransaction::new()
        .node_account_ids([response.node_account_id])
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key3)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Query the schedule info again
    ScheduleInfoQuery::new()
        .node_account_ids([response.node_account_id])
        .schedule_id(schedule_id)
        .execute(&client)
        .await?;

    Ok(())
}
// Filename: examples/scheduled_transaction_multi_sig_threshold.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountBalanceQuery, AccountCreateTransaction, AccountId, Client, Hbar, Key, KeyList, PrivateKey, ScheduleInfoQuery, ScheduleSignTransaction, TransactionRecordQuery, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());
    // Generate four new Ed25519 private, public key pairs.

    let private_keys: [_; 4] = std::array::from_fn(|_| PrivateKey::generate_ed25519());

    for (i, key) in private_keys.iter().enumerate() {
        println!("public key {}: {}", i + 1, key.public_key());
        println!("private key {}, {}", i + 1, key);
    }

    // require 3 of the 4 keys we generated to sign on anything modifying this account
    let transaction_key = KeyList {
        keys: private_keys
            .iter()
            .map(PrivateKey::public_key)
            .map(Key::from)
            .collect(),
        threshold: Some(3),
    };

    let receipt = AccountCreateTransaction::new()
        .key(transaction_key)
        .initial_balance(Hbar::from_tinybars(1))
        .account_memo("3-of-4 multi-sig account")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let multi_sig_account_id = receipt.account_id.unwrap();

    println!("3-of-4 multi-sig account ID: {multi_sig_account_id}");

    let balance = AccountBalanceQuery::new()
        .account_id(multi_sig_account_id)
        .execute(&client)
        .await?;

    println!(
        "Balance of account {multi_sig_account_id}: {}.",
        balance.hbars
    );

    // schedule crypto transfer from multi-sig account to operator account
    let mut transfer_transaction = TransferTransaction::new();
    transfer_transaction
        .hbar_transfer(multi_sig_account_id, Hbar::from_tinybars(-1))
        .hbar_transfer(args.operator_account_id, Hbar::from_tinybars(1));

    let tx_schedule_receipt = transfer_transaction
        .schedule()
        .freeze_with(&client)?
        .sign(private_keys[0].clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("Schedule status: {:?}", tx_schedule_receipt.status);
    let schedule_id = tx_schedule_receipt.schedule_id.unwrap();
    println!("Schedule ID: {schedule_id}");
    let scheduled_tx_id = tx_schedule_receipt.scheduled_transaction_id.unwrap();
    println!("Scheduled tx ID: {scheduled_tx_id}");

    // add 2 signature
    let tx_schedule_sign1_receipt = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(private_keys[1].clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!(
        "1. ScheduleSignTransaction status: {:?}",
        tx_schedule_sign1_receipt.status
    );

    // add 3 signature
    let tx_schedule_sign2_receipt = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(private_keys[2].clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!(
        "2. ScheduleSignTransaction status: {:?}",
        tx_schedule_sign2_receipt.status
    );

    // query schedule
    let schedule_info = ScheduleInfoQuery::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?;

    println!("{:?}", schedule_info);

    // query triggered scheduled tx
    let record_scheduled_tx = TransactionRecordQuery::new()
        .transaction_id(scheduled_tx_id)
        .execute(&client)
        .await?;

    println!("{:?}", record_scheduled_tx);

    Ok(())
}
// Filename: examples/scheduled_transfer.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountBalanceQuery, AccountCreateTransaction, AccountDeleteTransaction, AccountId, Client, Hbar, PrivateKey, ScheduleCreateTransaction, ScheduleInfoQuery, ScheduleSignTransaction, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    env_logger::init();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // A scheduled transaction is a transaction that has been proposed by an account,
    // but which requires more signatures before it will actually execute on the Hiero network.
    //
    // For example, if Alice wants to transfer an amount of Hbar to Bob, and Bob has
    // receiverSignatureRequired set to true, then that transaction must be signed by
    // both Alice and Bob before the transaction will be executed.
    //
    // To solve this problem, Alice can propose the transaction by creating a scheduled
    // transaction on the Hiero network which, if executed, would transfer Hbar from
    // Alice to Bob.  That scheduled transaction will have a ScheduleId by which we can
    // refer to that scheduled transaction.  Alice can communicate the ScheduleId to Bob, and
    // then Bob can use a ScheduleSignTransaction to sign that scheduled transaction.
    //
    // Bob has a 30 minute window in which to sign the scheduled transaction, starting at the
    // moment that Alice creates the scheduled transaction.  If a scheduled transaction
    // is not signed by all of the necessary signatories within the 30 minute window,
    // that scheduled transaction will expire, and will not be executed.
    //
    // Once a scheduled transaction has all of the signatures necessary to execute, it will
    // be executed on the Hiero network automatically.  If you create a scheduled transaction
    // on the Hiero network, but that transaction only requires your signature in order to
    // execute and no one else's, that scheduled transaction will be automatically
    // executed immediately.
    let bobs_key = PrivateKey::generate_ed25519();

    let bobs_id = AccountCreateTransaction::new()
        .receiver_signature_required(true)
        .key(bobs_key.public_key())
        .initial_balance(Hbar::new(10))
        .freeze_with(&client)?
        .sign(bobs_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    println!(
        "Alice's ID: {}",
        args.operator_account_id.to_string_with_checksum(&client)?
    );
    println!("Bob's ID: {}", bobs_id.to_string_with_checksum(&client)?);

    let bobs_initial_balance = AccountBalanceQuery::new()
        .account_id(bobs_id)
        .execute(&client)
        .await?;

    println!("Bob's initial balance:");
    println!("{bobs_initial_balance:?}");

    let mut transfer_to_schedule = TransferTransaction::new();

    transfer_to_schedule
        .hbar_transfer(args.operator_account_id, Hbar::new(-10))
        .hbar_transfer(bobs_id, Hbar::new(10));

    println!("Transfer to be scheduled:");
    println!("{transfer_to_schedule:?}");

    // The `payer_account_id` is the account that will be charged the fee
    // for executing the scheduled transaction if/when it is executed.
    // That fee is separate from the fee that we will pay to execute the
    // ScheduleCreateTransaction itself.
    //
    // To clarify: Alice pays a fee to execute the ScheduleCreateTransaction,
    // which creates the scheduled transaction on the Hiero network.
    // She specifies when creating the scheduled transaction that Bob will pay
    // the fee for the scheduled transaction when it is executed.
    //
    // If `payer_account_id` is not specified, the account who creates the scheduled transaction
    // will be charged for executing the scheduled transaction.
    let schedule_id = ScheduleCreateTransaction::new()
        .scheduled_transaction(transfer_to_schedule)
        .payer_account_id(bobs_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    println!(
        "The schedule_id is: {}",
        schedule_id.to_string_with_checksum(&client)
    );

    // Bob's balance should be unchanged.  The transfer has been scheduled, but it hasn't been executed yet
    // because it requires Bob's signature.
    let bobs_balance_after_schedule = AccountBalanceQuery::new()
        .account_id(bobs_id)
        .execute(&client)
        .await?;

    println!("Bob's balance after scheduling the transfer (should be unchanged):");
    println!("{bobs_balance_after_schedule:?}");

    // Once Alice has communicated the scheduleId to Bob, Bob can query for information about the
    // scheduled transaction.
    let scheduled_transaction_info = ScheduleInfoQuery::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?;

    println!("Info about scheduled transaction:");
    println!("{scheduled_transaction_info:?}");

    // getScheduledTransaction() will return an SDK Transaction object identical to the transaction
    // that was scheduled, which Bob can then inspect like a normal transaction.
    let scheduled_transaction = scheduled_transaction_info.scheduled_transaction()?;

    // We happen to know that this transaction is (or certainly ought to be) a TransferTransaction
    let Ok(scheduled_transfer) = scheduled_transaction.downcast::<TransferTransaction>() else {
        anyhow::bail!("scheduled transaction was not a transfer transaction");
    };

    println!("The scheduled transfer transaction from Bob's POV:");
    println!("{scheduled_transfer:?}");

    ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(bobs_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let balance_after_signing = AccountBalanceQuery::new()
        .account_id(bobs_id)
        .execute(&client)
        .await?;

    println!("Bob's balance after signing the scheduled transaction:");
    println!("{balance_after_signing:?}");

    let post_transaction_info = ScheduleInfoQuery::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?;

    println!("Info on the scheduled transaction, executed_at should no longer be null:");
    println!("{post_transaction_info:?}");

    // Clean up
    AccountDeleteTransaction::new()
        .transfer_account_id(args.operator_account_id)
        .account_id(bobs_id)
        .freeze_with(&client)?
        .sign(bobs_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: examples/sign_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountId, Client, Hbar, KeyList, PrivateKey, TransferTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key);

    let user1_key = PrivateKey::generate_ed25519();
    let user2_key = PrivateKey::generate_ed25519();

    let keylist = KeyList::from([user1_key.public_key(), user2_key.public_key()]);

    let create_account_transaction = AccountCreateTransaction::new()
        .initial_balance(Hbar::new(2))
        .key(keylist)
        .execute(&client)
        .await?;

    let receipt = create_account_transaction.get_receipt(&client).await?;

    let account_id = receipt.account_id.unwrap();

    println!("account id = {account_id}");

    let mut transfer_transaction = TransferTransaction::new();

    transfer_transaction
        .node_account_ids([AccountId::from(3)])
        .hbar_transfer(account_id, Hbar::new(-1))
        .hbar_transfer(AccountId::from(3), Hbar::new(1))
        .freeze_with(&client)?;

    transfer_transaction.sign_with_operator(&client)?;
    user1_key.sign_transaction(&mut transfer_transaction)?;
    user2_key.sign_transaction(&mut transfer_transaction)?;

    let result = transfer_transaction.execute(&client).await?;
    let receipt = result.get_receipt(&client).await?;

    println!("{:?}", receipt.status);

    Ok(())
}
// Filename: examples/staking.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{AccountCreateTransaction, AccountId, AccountInfoQuery, Client, Hbar, PrivateKey};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // Create Alice account
    let new_key = PrivateKey::generate_ed25519();

    println!("private key: {new_key}");
    println!("public key: {}", new_key.public_key());

    // Create an account and stake to an acount ID
    // In this case we're staking to account ID 3 which happens to be
    // the account ID of node 0, we're only doing this as an example.
    // If you really want to stake to node 0, you should use
    // `.setStakedNodeId()` instead
    let new_account_id = AccountCreateTransaction::new()
        .key(new_key.public_key())
        .initial_balance(Hbar::new(10))
        .staked_account_id("0.0.3".parse()?)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    println!("new account ID: {new_account_id}");

    // Show the required key used to sign the account update transaction to
    // stake the accounts hbar i.e. the fee payer key and key to authorize
    // changes to the account should be different
    println!(
        "key required to update staking information: {}",
        new_key.public_key()
    );

    println!(
        "fee payer aka operator key: {}",
        args.operator_key.public_key()
    );

    // Query the account info, it should show the staked account ID
    // to be 0.0.3 just like what we set it to
    let info = AccountInfoQuery::new()
        .account_id(new_account_id)
        .execute(&client)
        .await?;

    println!("staking info: {:?}", info.staking);

    Ok(())
}
// Filename: examples/staking_with_update.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountId, AccountInfoQuery, AccountUpdateTransaction, Client, Hbar, PrivateKey
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // Create Alice account
    let new_key = PrivateKey::generate_ed25519();

    println!("private key: {new_key}");
    println!("public key: {}", new_key.public_key());

    // Create an account and stake to an acount ID
    // In this case we're staking to account ID 3 which happens to be
    // the account ID of node 0, we're only doing this as an example.
    // If you really want to stake to node 0, you should use
    // `.setStakedNodeId()` instead
    let new_account_id = AccountCreateTransaction::new()
        .key(new_key.public_key())
        .initial_balance(Hbar::new(10))
        .staked_account_id("0.0.3".parse()?)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    println!("new account ID: {new_account_id}");

    // Show the required key used to sign the account update transaction to
    // stake the accounts hbar i.e. the fee payer key and key to authorize
    // changes to the account should be different
    println!(
        "key required to update staking information: {}",
        new_key.public_key()
    );

    println!(
        "fee payer aka operator key: {}",
        args.operator_key.public_key()
    );

    // Query the account info, it should show the staked account ID
    // to be 0.0.3 just like what we set it to
    let info = AccountInfoQuery::new()
        .account_id(new_account_id)
        .execute(&client)
        .await?;

    println!("staking info: {:?}", info.staking);

    // Use the `AccountUpdateTransaction` to unstake the account's hbars
    //
    // If this succeeds then we should no longer have a staked account ID
    AccountUpdateTransaction::new()
        .account_id(new_account_id)
        .clear_staked_account_id()
        .sign(new_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Query the account info, it should show the staked account ID
    // to be `None` just like what we set it to
    let info = AccountInfoQuery::new()
        .account_id(new_account_id)
        .execute(&client)
        .await?;

    println!("staking info: {:?}", info.staking);

    Ok(())
}
// Filename: examples/token_airdrop.rs
// SPDX-License-Identifier: Apache-2.0

use std::iter::repeat;

use clap::Parser;
use hedera::{
    AccountBalanceQuery, AccountCreateTransaction, AccountId, Client, Hbar, PrivateKey, TokenAirdropTransaction, TokenCancelAirdropTransaction, TokenClaimAirdropTransaction, TokenCreateTransaction, TokenMintTransaction, TokenRejectTransaction
};
use time::{Duration, OffsetDateTime};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let Args {
        operator_account_id,
        operator_key,
        hedera_network,
    } = Args::parse();

    let client = Client::for_name(&hedera_network)?;

    client.set_operator(operator_account_id, operator_key.clone());
    let private_key_1 = PrivateKey::generate_ecdsa();
    let alice_id = AccountCreateTransaction::new()
        .key(private_key_1.public_key())
        .initial_balance(Hbar::new(10))
        .max_automatic_token_associations(-1)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    let private_key_2 = PrivateKey::generate_ecdsa();
    let bob_id = AccountCreateTransaction::new()
        .key(private_key_2.public_key())
        .max_automatic_token_associations(1)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    let private_key_3 = PrivateKey::generate_ecdsa();
    let carol_id = AccountCreateTransaction::new()
        .key(private_key_3.public_key())
        .max_automatic_token_associations(0)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    let treasury_key = PrivateKey::generate_ecdsa();
    let treasury_account_id = AccountCreateTransaction::new()
        .key(treasury_key.public_key())
        .initial_balance(Hbar::new(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    /*
     * Step 2:
     * Create FT and NFT and mint
     */
    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .decimals(3)
        .initial_supply(100)
        .max_supply(100)
        .treasury_account_id(treasury_account_id)
        .token_supply_type(hedera::TokenSupplyType::Finite)
        .admin_key(operator_key.clone().public_key())
        .freeze_key(operator_key.clone().public_key())
        .supply_key(operator_key.clone().public_key())
        .pause_key(operator_key.clone().public_key())
        .expiration_time(OffsetDateTime::now_utc() + Duration::hours(2))
        .freeze_with(&client)?
        .sign(treasury_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let nft_id = TokenCreateTransaction::new()
        .name("example NFT")
        .symbol("F")
        .max_supply(10)
        .treasury_account_id(treasury_account_id)
        .token_supply_type(hedera::TokenSupplyType::Finite)
        .token_type(hedera::TokenType::NonFungibleUnique)
        .admin_key(operator_key.clone().public_key())
        .freeze_key(operator_key.clone().public_key())
        .supply_key(operator_key.clone().public_key())
        .pause_key(operator_key.clone().public_key())
        .expiration_time(OffsetDateTime::now_utc() + Duration::hours(2))
        .freeze_with(&client)?
        .sign(treasury_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    _ = TokenMintTransaction::new()
        .token_id(nft_id)
        .metadata(repeat(vec![9, 1, 6]).take(4).collect::<Vec<Vec<_>>>())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    /*
     * Step 3:
     * Airdrop fungible tokens to all 3 accounts
     */
    println!("Airdropping tokens to all accounts");

    let tx_record = TokenAirdropTransaction::new()
        .token_transfer(token_id, alice_id, 10)
        .token_transfer(token_id, treasury_account_id, -10)
        .token_transfer(token_id, bob_id, 10)
        .token_transfer(token_id, treasury_account_id, -10)
        .token_transfer(token_id, carol_id, 10)
        .token_transfer(token_id, treasury_account_id, -10)
        .freeze_with(&client)?
        .sign(treasury_key.clone())
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    /*
     * Step 4:
     * Get the transaction record and see one pending airdrop (for carol)
     */
    println!(
        "Pending airdrop length: {}",
        tx_record.pending_airdrop_records.len()
    );
    println!(
        "Pending airdrops: {:?}",
        tx_record.pending_airdrop_records.get(0)
    );

    /*
     * Step 5:
     * Query to verify alice and bob received the airdrops and carol did not
     */
    let alice_balance = AccountBalanceQuery::new()
        .account_id(alice_id)
        .execute(&client)
        .await?;

    let bob_balance = AccountBalanceQuery::new()
        .account_id(bob_id)
        .execute(&client)
        .await?;

    let carol_balance = AccountBalanceQuery::new()
        .account_id(carol_id)
        .execute(&client)
        .await?;

    println!(
        "Alice ft balance after airdrop: {}",
        alice_balance.tokens.get(&token_id).unwrap()
    );
    println!(
        "Bob ft balance after airdrop: {}",
        bob_balance.tokens.get(&token_id).unwrap()
    );
    println!(
        "Carol ft balance after airdrop: {:?}",
        carol_balance.tokens.get(&token_id)
    );

    /*
     * Step 6:
     * Claim the airdrop for carol
     */
    println!("Claiming ft with Carol");

    _ = TokenClaimAirdropTransaction::new()
        .add_pending_airdrop_id(
            tx_record
                .pending_airdrop_records
                .get(0)
                .unwrap()
                .pending_airdrop_id,
        )
        .freeze_with(&client)?
        .sign(private_key_3.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let carol_balance = AccountBalanceQuery::new()
        .account_id(carol_id)
        .execute(&client)
        .await?;

    println!(
        "Carol ft balance after airdrop: {}",
        carol_balance.tokens.get(&token_id).unwrap()
    );

    /*
     * Step 7:
     * Airdrop the NFTs to all three accounts
     */
    println!("Airdropping nfts");
    let tx_record = TokenAirdropTransaction::new()
        .nft_transfer(nft_id.nft(1), treasury_account_id, alice_id)
        .nft_transfer(nft_id.nft(2), treasury_account_id, bob_id)
        .nft_transfer(nft_id.nft(3), treasury_account_id, carol_id)
        .freeze_with(&client)?
        .sign(treasury_key.clone())
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    /*
     * Step 8:
     * Get the transaction record and verify two pending airdrops (for bob & carol)
     */
    println!(
        "Pending airdrops length: {}",
        tx_record.pending_airdrop_records.len()
    );
    println!(
        "Pending airdrops for Bob: {}",
        tx_record.pending_airdrop_records.get(0).unwrap()
    );
    println!(
        "Pending airdrops for Carol: {}",
        tx_record.pending_airdrop_records.get(1).unwrap()
    );

    /*
     * Step 9:
     * Query to verify alice received the airdrop and bob and carol did not
     */
    let alice_balance = AccountBalanceQuery::new()
        .account_id(alice_id)
        .execute(&client)
        .await?;

    let bob_balance = AccountBalanceQuery::new()
        .account_id(bob_id)
        .execute(&client)
        .await?;

    let carol_balance = AccountBalanceQuery::new()
        .account_id(carol_id)
        .execute(&client)
        .await?;

    println!(
        "Alice nft balance after airdrop: {}",
        alice_balance.tokens.get(&nft_id).unwrap()
    );

    println!(
        "Bob nft balance after airdrop: {:?}",
        bob_balance.tokens.get(&nft_id)
    );

    println!(
        "Carol nft balance after airdrop: {:?}",
        carol_balance.tokens.get(&nft_id)
    );

    /*
     * Step 10:
     * Claim the airdrop for bob
     */
    println!("Claiming nft with Bob");
    _ = TokenClaimAirdropTransaction::new()
        .add_pending_airdrop_id(
            tx_record
                .pending_airdrop_records
                .get(0)
                .unwrap()
                .pending_airdrop_id,
        )
        .freeze_with(&client)?
        .sign(private_key_2.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let bob_balance = AccountBalanceQuery::new()
        .account_id(bob_id)
        .execute(&client)
        .await?;

    println!(
        "Bob nft balance after claim: {}",
        bob_balance.tokens.get(&nft_id).unwrap()
    );

    /*
     * Step 11:
     * Cancel the airdrop for carol
     */
    println!("Cancelling nft for Carol");

    _ = TokenCancelAirdropTransaction::new()
        .add_pending_airdrop_id(
            tx_record
                .pending_airdrop_records
                .get(1)
                .unwrap()
                .pending_airdrop_id,
        )
        .freeze_with(&client)?
        .sign(treasury_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let carol_balance = AccountBalanceQuery::new()
        .account_id(carol_id)
        .execute(&client)
        .await?;

    println!(
        "Carol nft balance after cancel: {:?}",
        carol_balance.tokens.get(&nft_id)
    );

    /*
     * Step 12:
     * Reject the NFT for bob
     */
    println!("Rejecting nft with Bob");

    _ = TokenRejectTransaction::new()
        .owner(bob_id)
        .add_nft_id(nft_id.nft(2))
        .freeze_with(&client)?
        .sign(private_key_2)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    /*
     * Step 13:
     * Query to verify bob no longer has the NFT
     */
    let bob_balance = AccountBalanceQuery::new()
        .account_id(bob_id)
        .execute(&client)
        .await?;

    println!(
        "Bob nft balance after reject: {}",
        bob_balance.tokens.get(&nft_id).unwrap()
    );

    /*
     * Step 13:
     * Query to verify the NFT was returned to the Treasury
     */
    let treasury_balance = AccountBalanceQuery::new()
        .account_id(treasury_account_id)
        .execute(&client)
        .await?;

    println!(
        "Treasury nft balance after reject: {}",
        treasury_balance.tokens.get(&nft_id).unwrap()
    );

    /*
     * Step 14:
     * Reject the Fungible token for carol
     */
    println!("Rejecting ft with Carol");

    _ = TokenRejectTransaction::new()
        .owner(carol_id)
        .add_token_id(token_id)
        .freeze_with(&client)?
        .sign(private_key_3.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    /*
     * Step 14:
     * Query to verify Carol no longer has the fungible tokens
     */
    let carol_balance = AccountBalanceQuery::new()
        .account_id(carol_id)
        .execute(&client)
        .await?;

    println!(
        "Carol ft balance after reject: {}",
        carol_balance.tokens.get(&token_id).unwrap()
    );

    /*
     * Step 15:
     * Query to verify Treasury received the rejected fungible tokens
     */
    let treasury_balance = AccountBalanceQuery::new()
        .account_id(treasury_account_id)
        .execute(&client)
        .await?;

    println!(
        "Treasury ft balance after reject: {}",
        treasury_balance.tokens.get(&token_id).unwrap()
    );

    println!("Token airdrop example completed successfully");
    Ok(())
}
// Filename: examples/token_update_metadata_with_admin_key.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountId, Client, PrivateKey, TokenCreateTransaction, TokenInfoQuery, TokenType, TokenUpdateTransaction
};
use time::{Duration, OffsetDateTime};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    let admin_key = PrivateKey::generate_ed25519();

    // Initial metadata
    let metadata: Vec<u8> = vec![1];
    // New metadata
    let new_metadata: Vec<u8> = vec![1, 2];

    let token_create_receipt = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .token_type(TokenType::FungibleCommon)
        .decimals(3)
        .initial_supply(1000000)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .admin_key(admin_key.public_key())
        .metadata(metadata)
        .freeze_with(&client)?
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Get token id
    let token_id = token_create_receipt.token_id.unwrap();
    println!("Created a mutable token: {token_id:?}");

    let token_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    println!(
        "Immutable token's metadata after creation: {:?}",
        token_info.metadata
    );

    let token_update_receipt = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata(new_metadata)
        .freeze_with(&client)?
        .sign(admin_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!(
        "Status of token update transaction: {:?}",
        token_update_receipt.status
    );

    let token_nft_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    println!(
        "Immutable token's metadata after update: {:?}",
        token_nft_info.metadata
    );

    Ok(())
}
// Filename: examples/token_update_metadata_with_metadata_key.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountId, Client, PrivateKey, TokenCreateTransaction, TokenInfoQuery, TokenType, TokenUpdateTransaction
};
use time::{Duration, OffsetDateTime};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();

    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // Generate a metadata key
    let metadata_key = PrivateKey::generate_ed25519();
    // Initial metadata
    let metadata: Vec<u8> = vec![1];
    // New metadata
    let new_metadata: Vec<u8> = vec![1, 2];

    // Create Token with a set metadata key
    let token_create_receipt = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .token_type(TokenType::FungibleCommon)
        .decimals(3)
        .initial_supply(1000000)
        .metadata(metadata)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .admin_key(client.get_operator_public_key().unwrap())
        .metadata_key(metadata_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!(
        "Status of token create transaction: {:?}",
        token_create_receipt.status
    );

    // Get token id
    let token_id = token_create_receipt.token_id.unwrap();
    println!("Token id: {token_id:?}");

    let token_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    println!("Token metadata: {:?}", token_info.metadata);

    let token_update_receipt = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata(new_metadata)
        .freeze_with(&client)?
        .sign(metadata_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!(
        "Status of token update transaction: {:?}",
        token_update_receipt.status
    );

    let token_nft_info = TokenInfoQuery::new()
        .token_id(token_id)
        .execute(&client)
        .await?;

    println!("Updated token metadata: {:?}", token_nft_info.metadata);

    Ok(())
}
// Filename: examples/topic_with_admin_key.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountId, Client, Key, KeyList, PrivateKey, TopicCreateTransaction, TopicId, TopicInfoQuery, TopicUpdateTransaction
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key);

    let (initial_admin_keys, topic_id) = create_topic_with_admin_key(&client).await?;
    update_topic_admin_key_and_memo(&client, initial_admin_keys, topic_id).await?;

    Ok(())
}

async fn create_topic_with_admin_key(
    client: &Client,
) -> anyhow::Result<(Vec<PrivateKey>, TopicId)> {
    // Generate the initial keys that are part of the adminKey's thresholdKey.
    // 3 ED25519 keys part of a 2-of-3 threshold key.
    let initial_admin_keys: Vec<_> = std::iter::repeat_with(PrivateKey::generate_ed25519)
        .take(3)
        .collect();

    let threshold_key = KeyList {
        keys: initial_admin_keys
            .iter()
            .map(PrivateKey::public_key)
            .map(Key::from)
            .collect(),
        threshold: Some(2),
    };

    let mut transaction = TopicCreateTransaction::new();

    transaction
        .topic_memo("demo topic")
        .admin_key(threshold_key)
        .freeze_with(client)?;

    for key in initial_admin_keys.iter().skip(1).cloned() {
        println!("Signing ConsensusTopicCreateTransaction with key {key}");
        transaction.sign(key);
    }

    let topic_id = transaction
        .execute(client)
        .await?
        .get_receipt(client)
        .await?
        .topic_id
        .unwrap();

    println!("Created new topic {topic_id} with 2-of-3 threshold key as admin_key");

    Ok((initial_admin_keys, topic_id))
}

async fn update_topic_admin_key_and_memo(
    client: &Client,
    initial_admin_keys: Vec<PrivateKey>,
    topic_id: TopicId,
) -> anyhow::Result<()> {
    // Generate the new keys that are part of the adminKey's thresholdKey.
    // 4 ED25519 keys part of a 3-of-4 threshold key.
    let new_admin_keys: Vec<_> = std::iter::repeat_with(PrivateKey::generate_ed25519)
        .take(4)
        .collect();

    let threshold_key = KeyList {
        keys: new_admin_keys
            .iter()
            .map(PrivateKey::public_key)
            .map(Key::from)
            .collect(),
        threshold: Some(3),
    };

    let mut transaction = TopicUpdateTransaction::new();

    transaction
        .topic_id(topic_id)
        .topic_memo("updated example topic")
        .admin_key(threshold_key)
        .freeze_with(client)?;

    // Sign with the initial adminKey. 2 of the 3 keys already part of the topic's adminKey.
    // Note that this time we're using a different subset of keys ([1, 0], rather than [1, 2])
    for key in initial_admin_keys.iter().rev().skip(1).cloned() {
        println!("Signing ConsensusTopicUpdateTransaction with initial admin key {key}",);
        transaction.sign(key);
    }

    for key in new_admin_keys.iter().skip(1).cloned() {
        println!("Signing ConsensusTopicUpdateTransaction with new admin key {key}",);
        transaction.sign(key);
    }

    transaction
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    println!("Updated topic {topic_id} with 3-of-4 threshold key as adminKey");

    let topic_info = TopicInfoQuery::new()
        .topic_id(topic_id)
        .execute(client)
        .await?;

    println!("{topic_info:?}");

    Ok(())
}
// Filename: examples/transfer_crypto.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{AccountId, Client, Hbar, PrivateKey, TransferTransaction};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long)]
    sender: Option<AccountId>,

    #[clap(long, default_value = "0.0.1001")]
    receiver: AccountId,

    #[clap(long, default_value = "10 ")]
    amount: Hbar,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_testnet();

    client.set_operator(args.operator_account_id, args.operator_key);

    let sender = args.sender.unwrap_or(args.operator_account_id);

    let _ = TransferTransaction::new()
        .hbar_transfer(sender, -args.amount)
        .hbar_transfer(args.receiver, args.amount)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: examples/transfer_crypto_cost.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{AccountId, Client, Hbar, PrivateKey, TransferTransaction};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long)]
    sender: Option<AccountId>,

    #[clap(long, default_value = "0.0.1001")]
    receiver: AccountId,

    #[clap(long, default_value = "10 ")]
    amount: Hbar,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_testnet();

    client.set_operator(args.operator_account_id, args.operator_key);

    let sender = args.sender.unwrap_or(args.operator_account_id);

    let mut txn = TransferTransaction::new();

    txn.hbar_transfer(sender, -args.amount)
        .hbar_transfer(args.receiver, args.amount);

    // query the cost
    let cost = txn.get_cost(&client).await?;

    println!(" > transfer estimated cost: {}", cost);

    // now execute
    let resp = txn.execute(&client).await?;

    // and then get the actual cost
    let record = resp.get_record(&client).await?;

    println!(" > transfer actual cost: {}", record.transaction_fee);

    Ok(())
}
// Filename: examples/transfer_tokens.rs
// SPDX-License-Identifier: Apache-2.0

use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountDeleteTransaction, AccountId, Client, Hbar, PrivateKey, TokenAssociateTransaction, TokenCreateTransaction, TokenDeleteTransaction, TokenGrantKycTransaction, TokenWipeTransaction, TransferTransaction
};
use time::{Duration, OffsetDateTime};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let Args {
        operator_account_id,
        operator_key,
        hedera_network,
    } = Args::parse();

    let client = Client::for_name(&hedera_network)?;

    client.set_operator(operator_account_id, operator_key.clone());
    let (private_key1, account_id1) = create_account(&client, 1).await?;
    let (private_key2, account_id2) = create_account(&client, 2).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .decimals(3)
        .initial_supply(1_000_000)
        .treasury_account_id(operator_account_id)
        .admin_key(operator_key.clone().public_key())
        .freeze_key(operator_key.clone().public_key())
        .wipe_key(operator_key.clone().public_key())
        .kyc_key(operator_key.clone().public_key())
        .supply_key(operator_key.clone().public_key())
        .expiration_time(OffsetDateTime::now_utc() + Duration::hours(2))
        .freeze_default(false)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    println!("token = {token_id}");

    TokenAssociateTransaction::new()
        .account_id(account_id1)
        .token_ids([token_id])
        .freeze_with(&client)?
        .sign(private_key1.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("Associated account {account_id1} with token {token_id}");

    TokenAssociateTransaction::new()
        .account_id(account_id2)
        .token_ids([token_id])
        .freeze_with(&client)?
        .sign(private_key2.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("Associated account {account_id2} with token {token_id}");

    TokenGrantKycTransaction::new()
        .account_id(account_id1)
        .token_id(token_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("Granted KYC for account {account_id1} on token {token_id}");

    TokenGrantKycTransaction::new()
        .account_id(account_id2)
        .token_id(token_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("Granted KYC for account {account_id2} on token {token_id}");

    TransferTransaction::new()
        .token_transfer(token_id, operator_account_id, -10)
        .token_transfer(token_id, account_id1, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("Sent 10 tokens from account {operator_account_id} to account {account_id1} on token {token_id}");

    TransferTransaction::new()
        .token_transfer(token_id, account_id1, -10)
        .token_transfer(token_id, account_id2, 10)
        .freeze_with(&client)?
        .sign(private_key1.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!(
        "Sent 10 tokens from account {account_id1} to account {account_id2} on token {token_id}"
    );

    TransferTransaction::new()
        .token_transfer(token_id, account_id2, -10)
        .token_transfer(token_id, account_id1, 10)
        .freeze_with(&client)?
        .sign(private_key2.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!(
        "Sent 10 tokens from account {account_id2} to account {account_id1} on token {token_id}"
    );

    TokenWipeTransaction::new()
        .account_id(account_id1)
        .token_id(token_id)
        .amount(10_u64)
        .freeze_with(&client)?
        .sign(private_key1.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("Wiped balance of token {token_id} from account {account_id1}");

    TokenDeleteTransaction::new()
        .token_id(token_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("Deleted token {token_id}");

    delete_account(&client, operator_account_id, 1, account_id1, private_key1).await?;
    delete_account(&client, operator_account_id, 2, account_id2, private_key2).await?;

    Ok(())
}

async fn create_account(
    client: &Client,
    account_number: usize,
) -> anyhow::Result<(PrivateKey, AccountId)> {
    let private_key = PrivateKey::generate_ed25519();
    println!("private key  = {private_key}");
    println!("public key = {}", private_key.public_key());

    let receipt = AccountCreateTransaction::new()
        .key(private_key.public_key())
        .initial_balance(Hbar::from_tinybars(1000))
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    let account_id = receipt.account_id.unwrap();
    println!("created account_id{account_number}: {account_id}");

    Ok((private_key, account_id))
}

async fn delete_account(
    client: &Client,
    operator_account_id: AccountId,
    account_number: usize,
    account_id: AccountId,
    private_key: PrivateKey,
) -> anyhow::Result<()> {
    AccountDeleteTransaction::new()
        .account_id(account_id)
        .transfer_account_id(operator_account_id)
        .freeze_with(client)?
        .sign(private_key)
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    println!("deleted account_id{account_number}: {account_id}");

    Ok(())
}
// Filename: examples/update_account_public_key.rs
use clap::Parser;
use hedera::{
    AccountCreateTransaction, AccountId, AccountInfoQuery, AccountUpdateTransaction, Hbar, PrivateKey
};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env)]
    operator_account_id: AccountId,

    #[clap(long, env)]
    operator_key: PrivateKey,

    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv().ok();

    let args = Args::parse();

    let client = hedera::Client::for_name(&args.hedera_network)?;

    client.set_operator(args.operator_account_id, args.operator_key.clone());

    // First, we create a new account so we don't affect our account

    let key1 = PrivateKey::generate_ed25519();
    let key2 = PrivateKey::generate_ed25519();

    let response = AccountCreateTransaction::new()
        .key(key1.public_key())
        .initial_balance(Hbar::new(1))
        .execute(&client)
        .await?;

    println!("transaction id: {}", response.transaction_id);

    let account_id = response.get_receipt(&client).await?.account_id.unwrap();

    println!("new account id: `{account_id}`");
    println!("account key: `{}`", key1.public_key());

    println!(":: update public key of account `{account_id}`");
    println!("set key = `{}`", key2.public_key());

    // note that we have to sign with both the new key (key2) and the old key (key1).
    let response = AccountUpdateTransaction::new()
        .account_id(account_id)
        .key(key2.public_key())
        .sign(key1.clone())
        .sign(key2.clone())
        .execute(&client)
        .await?;

    println!("transaction id: {}", response.transaction_id);

    let _ = response.get_receipt(&client).await?;

    println!(":: run AccountInfoQuery and check our current key");

    let info = AccountInfoQuery::new()
        .account_id(account_id)
        .execute(&client)
        .await?;

    println!("key: {:?}", info.key);

    Ok(())
}
// Filename: examples/validate_checksum.rs
// SPDX-License-Identifier: Apache-2.0

use std::io::Write;

use clap::Parser;
use hedera::{AccountBalanceQuery, AccountId, Client};

#[derive(Parser, Debug)]
struct Args {
    #[clap(long, env, default_value = "testnet")]
    hedera_network: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let _ = dotenvy::dotenv();
    let args = Args::parse();

    let client = Client::for_name(&args.hedera_network)?;

    // we need to return _something_ to say if stdin has been EOFed on us.
    if manual_checksum_validation(&client).await?.is_none() {
        return Ok(());
    }

    // we need to return _something_ to say if stdin has been EOFed on us.
    if automatic_checksum_validation(&client).await?.is_none() {
        return Ok(());
    }

    Ok(())
}

async fn manual_checksum_validation(client: &Client) -> anyhow::Result<Option<AccountId>> {
    println!("Example for manual checksum validation");

    let account_id = loop {
        let Some(account_id) = parse_account_id()? else {
            return Ok(None);
        };

        match account_id.validate_checksum(client) {
            Ok(()) => {}
            Err(e) => {
                println!("{e}");
                if let hedera::Error::BadEntityId {
                    shard,
                    realm,
                    num,
                    present_checksum,
                    expected_checksum,
                } = e
                {
                    println!(
                        "You entered {shard}.{realm}.{num}-{present_checksum}, the expected checksum was {expected_checksum}"
                    );
                    continue;
                }

                return Err(e.into());
            }
        };

        break account_id;
    };

    let balance = AccountBalanceQuery::new()
        .account_id(account_id)
        .execute(client)
        .await?;

    println!("Balance for account {account_id}: {balance:?}");

    Ok(Some(account_id))
}

async fn automatic_checksum_validation(client: &Client) -> anyhow::Result<Option<AccountId>> {
    println!("Example for automatic checksum validation");

    client.set_auto_validate_checksums(true);

    let Some(account_id) = parse_account_id()? else {
        return Ok(None);
    };

    let balance = AccountBalanceQuery::new()
        .account_id(account_id)
        .execute(client)
        .await?;

    println!("Balance for account {account_id}: {balance:?}");

    Ok(Some(account_id))
}

fn parse_account_id() -> anyhow::Result<Option<AccountId>> {
    loop {
        print!("Enter an account ID with checksum: ");
        let _ = std::io::stdout().flush();
        let stdin = std::io::stdin();
        let line = {
            let mut line = String::new();
            match stdin.read_line(&mut line) {
                Ok(0) => return Ok(None),
                Ok(_) => line,
                Err(e) => return Err(e.into()),
            }
        };

        let line = line.trim();

        let account_id: AccountId = match line.parse() {
            Ok(account_id) => account_id,
            Err(err @ hedera::Error::BasicParse(_)) => {
                println!("{err:?}");
                continue;
            }
            Err(e) => return Err(e.into()),
        };

        let Some(checksum) = account_id.checksum else {
            println!("You must enter a checksum.");
            continue;
        };

        println!("The checksum entered was: {checksum}");

        return Ok(Some(account_id));
    }
}
// Filename: protobufs/build.rs
// SPDX-License-Identifier: Apache-2.0

use std::env;
use std::fs::{
    self,
    create_dir_all,
    read_dir,
};
use std::path::Path;

use regex::RegexBuilder;

const DERIVE_EQ_HASH: &str = "#[derive(Eq, Hash)]";
const SERVICES_FOLDER: &str = "./services/hapi/hedera-protobufs/services";

fn main() -> anyhow::Result<()> {
    // services is the "base" module for the hedera protobufs
    // in the beginning, there was only services and it was named "protos"

    let services_path = Path::new(SERVICES_FOLDER);

    // The contents of this folder will be copied and modified before it is
    // used for code generation. Later we will suppress generation of cargo
    // directives on the copy, so set a directive on the source.
    println!("cargo:rerun-if-changed={}", SERVICES_FOLDER);

    if !services_path.is_dir() {
        anyhow::bail!("Folder {SERVICES_FOLDER} does not exist; do you need to `git submodule update --init`?");
    }

    let out_dir = env::var("OUT_DIR")?;
    let out_path = Path::new(&out_dir);
    let services_tmp_path = out_path.join("services_src");

    // ensure we start fresh
    let _ = fs::remove_dir_all(&services_tmp_path);

    create_dir_all(&services_tmp_path)?;

    // copy over services into our tmp path so we can edit
    fs_extra::copy_items(
        &[services_path],
        &out_path,
        &fs_extra::dir::CopyOptions::new().overwrite(true).copy_inside(false),
    )?;
    fs::rename(out_path.join("services"), &services_tmp_path)?;

    let services: Vec<_> = read_dir(&services_tmp_path)?
        .chain(read_dir(&services_tmp_path.join("auxiliary").join("tss"))?)
        .filter_map(|entry| {
            let entry = entry.ok()?;

            entry.file_type().ok()?.is_file().then(|| entry.path())
        })
        .collect();

    // iterate through each file
    let re_package = RegexBuilder::new(r"^package (.*);$").multi_line(true).build()?;
    for service in &services {
        let contents = fs::read_to_string(service)?;

        // ensure that every `package _` entry is `package proto;`
        let contents = re_package.replace(&contents, "package proto;");

        let contents = contents.replace("com.hedera.hapi.node.addressbook.", "");
        let contents = contents.replace("com.hedera.hapi.services.auxiliary.history.", "");
        let contents = contents.replace("com.hedera.hapi.services.auxiliary.tss.", "");
        let contents = contents.replace("com.hedera.hapi.platform.event.", "");

        let contents = remove_unused_types(&contents);

        fs::write(service, &*contents)?;
    }

    let mut cfg = tonic_build::configure()
        // We have already emitted a cargo directive to trigger a rerun on the source folder
        // that the copy this builds is based on. If the directives are not suppressed, the
        // crate will rebuild on every compile due to the modified time stamps post-dating
        // the start time of the compile action.
        .emit_rerun_if_changed(false);

    // most of the protobufs in "basic types" should be Eq + Hash + Copy
    // any protobufs that would typically be used as parameter, that meet the requirements of those
    // traits
    cfg = cfg
        .type_attribute("proto.ShardID", DERIVE_EQ_HASH)
        .type_attribute("proto.RealmID", DERIVE_EQ_HASH)
        .type_attribute("proto.AccountID", DERIVE_EQ_HASH)
        .type_attribute("proto.AccountID.account", DERIVE_EQ_HASH)
        .type_attribute("proto.FileID", DERIVE_EQ_HASH)
        .type_attribute("proto.ContractID", DERIVE_EQ_HASH)
        .type_attribute("proto.ContractID.contract", DERIVE_EQ_HASH)
        .type_attribute("proto.TransactionID", DERIVE_EQ_HASH)
        .type_attribute("proto.Timestamp", DERIVE_EQ_HASH)
        .type_attribute("proto.NftTransfer", DERIVE_EQ_HASH)
        .type_attribute("proto.Fraction", DERIVE_EQ_HASH)
        .type_attribute("proto.TopicID", DERIVE_EQ_HASH)
        .type_attribute("proto.TokenID", DERIVE_EQ_HASH)
        .type_attribute("proto.ScheduleID", DERIVE_EQ_HASH)
        .type_attribute("proto.FeeComponents", DERIVE_EQ_HASH)
        .type_attribute("proto.Key", DERIVE_EQ_HASH)
        .type_attribute("proto.KeyList", DERIVE_EQ_HASH)
        .type_attribute("proto.ThresholdKey", DERIVE_EQ_HASH)
        .type_attribute("proto.Key.key", DERIVE_EQ_HASH)
        .type_attribute("proto.SignaturePair", DERIVE_EQ_HASH)
        .type_attribute("proto.SignaturePair.signature", DERIVE_EQ_HASH)
        .type_attribute("proto.FeeData", DERIVE_EQ_HASH)
        .type_attribute("proto.TokenBalance", DERIVE_EQ_HASH)
        .type_attribute("proto.TokenAssociation", DERIVE_EQ_HASH)
        .type_attribute("proto.CryptoAllowance", DERIVE_EQ_HASH)
        .type_attribute("proto.TokenAllowance", DERIVE_EQ_HASH)
        .type_attribute("proto.GrantedCryptoAllowance", DERIVE_EQ_HASH)
        .type_attribute("proto.GrantedTokenAllowance", DERIVE_EQ_HASH)
        .type_attribute("proto.Duration", DERIVE_EQ_HASH);

    // the ResponseCodeEnum should be marked as #[non_exhaustive] so
    // adding variants does not trigger a breaking change
    cfg = cfg.type_attribute("proto.ResponseCodeEnum", "#[non_exhaustive]");

    // the ResponseCodeEnum is not documented in the proto source
    cfg = cfg.type_attribute(
        "proto.ResponseCodeEnum",
        r#"#[doc = "
  Returned in `TransactionReceipt`, `Error::PreCheckStatus`, and `Error::ReceiptStatus`.
  
  The success variant is `Success` which is what a `TransactionReceipt` will contain for a
  successful transaction.
      "]"#,
    );

    cfg.compile_protos(&services, &[services_tmp_path.clone()])?;

    // NOTE: prost generates rust doc comments and fails to remove the leading * line
    remove_useless_comments(&Path::new(&env::var("OUT_DIR")?).join("proto.rs"))?;

    // mirror
    // NOTE: must be compiled in a separate folder otherwise it will overwrite the previous build
    let mirror_out_dir = Path::new(&env::var("OUT_DIR")?).join("mirror");
    create_dir_all(&mirror_out_dir)?;

    tonic_build::configure()
        .build_server(false)
        .extern_path(".proto.Timestamp", "crate::services::Timestamp")
        .extern_path(".proto.TopicID", "crate::services::TopicId")
        .extern_path(".proto.FileID", "crate::services::FileId")
        .extern_path(".proto.NodeAddress", "crate::services::NodeAddress")
        .extern_path(
            ".proto.ConsensusMessageChunkInfo",
            "crate::services::ConsensusMessageChunkInfo",
        )
        .out_dir(&mirror_out_dir)
        .compile_protos(
            &["./mirror/consensus_service.proto", "./mirror/mirror_network_service.proto"],
            &["./mirror/", "./services/hapi/hedera-protobufs/services/"],
        )?;

    remove_useless_comments(&mirror_out_dir.join("proto.rs"))?;

    // streams
    // NOTE: must be compiled in a separate folder otherwise it will overwrite the previous build

    let streams_out_dir = Path::new(&env::var("OUT_DIR")?).join("streams");
    create_dir_all(&streams_out_dir)?;

    // NOTE: **ALL** protobufs defined in basic_types must be specified here
    let cfg = tonic_build::configure();
    let cfg = builder::extern_basic_types(cfg);

    cfg.out_dir(&streams_out_dir).compile_protos(
        &["./services/hapi/hedera-protobufs/streams/account_balance_file.proto"],
        &[
            "./services/hapi/hedera-protobufs/streams/",
            "./services/hapi/hedera-protobufs/services/",
        ],
    )?;

    // see note wrt services.
    remove_useless_comments(&streams_out_dir.join("proto.rs"))?;

    // sdk
    // NOTE: must be compiled in a separate folder otherwise it will overwrite the previous build
    let sdk_out_dir = Path::new(&env::var("OUT_DIR")?).join("sdk");
    create_dir_all(&sdk_out_dir)?;

    // note:
    // almost everything in services must be specified here.
    let cfg = tonic_build::configure();
    let cfg = builder::extern_basic_types(cfg)
        .services_same("AssessedCustomFee")
        .services_same("ConsensusCreateTopicTransactionBody")
        .services_same("ConsensusDeleteTopicTransactionBody")
        .services_same("ConsensusMessageChunkInfo")
        .services_same("ConsensusSubmitMessageTransactionBody")
        .services_same("ConsensusUpdateTopicTransactionBody")
        .services_same("ContractCallTransactionBody")
        .services_same("ContractCreateTransactionBody")
        .services_same("ContractDeleteTransactionBody")
        .services_same("ContractUpdateTransactionBody")
        .services_same("CryptoAddLiveHashTransactionBody")
        .services_same("CryptoApproveAllowanceTransactionBody")
        .services_same("CryptoCreateTransactionBody")
        .services_same("CryptoDeleteTransactionBody")
        .services_same("CryptoDeleteAllowanceTransactionBody")
        .services_same("CryptoTransferTransactionBody")
        .services_same("CryptoUpdateTransactionBody")
        .services_same("CryptoDeleteLiveHashTransactionBody")
        .services_same("CustomFee")
        .services_same("Duration")
        .services_same("EthereumTransactionBody")
        .services_same("FileAppendTransactionBody")
        .services_same("FileCreateTransactionBody")
        .services_same("FileDeleteTransactionBody")
        .services_same("FileUpdateTransactionBody")
        .services_same("FixedFee")
        .services_same("FractionalFee")
        .services_same("FreezeTransactionBody")
        .services_same("FreezeType")
        .services_same("LiveHash")
        .services_same("NftRemoveAllowance")
        .services_same("NodeStake")
        .services_same("NodeStakeUpdateTransactionBody")
        .services_same("RoyaltyFee")
        .services_same("SchedulableTransactionBody")
        .services_same("ScheduleCreateTransactionBody")
        .services_same("ScheduleDeleteTransactionBody")
        .services_same("ScheduleSignTransactionBody")
        .services_same("SystemDeleteTransactionBody")
        .services_same("SystemUndeleteTransactionBody")
        .services_same("TokenAssociateTransactionBody")
        .services_same("TokenBurnTransactionBody")
        .services_same("TokenCreateTransactionBody")
        .services_same("TokenDeleteTransactionBody")
        .services_same("TokenDissociateTransactionBody")
        .services_same("TokenFeeScheduleUpdateTransactionBody")
        .services_same("TokenFreezeAccountTransactionBody")
        .services_same("TokenGrantKycTransactionBody")
        .services_same("TokenMintTransactionBody")
        .services_same("TokenPauseTransactionBody")
        .services_same("TokenRevokeKycTransactionBody")
        .services_same("TokenUnfreezeAccountTransactionBody")
        .services_same("TokenUnpauseTransactionBody")
        .services_same("TokenUpdateTransactionBody")
        .services_same("TokenUpdateNftsTransactionBody")
        .services_same("TokenWipeAccountTransactionBody")
        .services_same("TssMessageTransactionBody")
        .services_same("TssVoteTransactionBody")
        .services_same("TssShareSignatureTransactionBody")
        .services_same("TssEncryptionKeyTransactionBody")
        .services_same("Transaction")
        .services_same("TransactionBody")
        .services_same("UncheckedSubmitBody")
        .services_same("UtilPrngTransactionBody")
        .services_same("VirtualAddress");

    cfg.out_dir(&sdk_out_dir).compile_protos(
        &["./sdk/transaction_list.proto"],
        &["./sdk/", services_tmp_path.as_os_str().to_str().unwrap()],
    )?;

    // see note wrt services.
    remove_useless_comments(&sdk_out_dir.join("proto.rs"))?;

    Ok(())
}

fn remove_useless_comments(path: &Path) -> anyhow::Result<()> {
    let mut contents = fs::read_to_string(path)?;

    contents = contents.replace("///*\n", "");
    contents = contents.replace("/// *\n", "");
    contents = contents.replace("/// UNDOCUMENTED", "");

    // Remove code examples in comments
    let re = regex::Regex::new(r"/// ```[\s\S]*?/// ```\n").unwrap();
    contents = re.replace_all(&contents, "").to_string();

    fs::write(path, contents)?;

    Ok(())
}

// Temporary function to remove unused types in transaction.proto
fn remove_unused_types(contents: &str) -> String {
    let contents = contents.replace(
        "import \"event/state_signature_transaction.proto\";",
        "// import \"event/state_signature_transaction.proto\";",
    );

    let contents = contents.replace(
        "import \"auxiliary/history/history_proof_vote.proto\";",
        "// import \"auxiliary/history/history_proof_vote.proto\";",
    );
    let contents = contents.replace(
        "import \"auxiliary/history/history_proof_signature.proto\";",
        "// import \"auxiliary/history/history_proof_signature.proto\";",
    );
    let contents = contents.replace(
        "import \"auxiliary/history/history_proof_key_publication.proto\";",
        "// import \"auxiliary/history/history_proof_key_publication.proto\";",
    );

    let contents = contents.replace("StateSignatureTransaction", "// StateSignatureTransaction");

    let contents =
        contents.replace("HistoryProofSignatureTransaction", "// HistoryProofSignatureTransaction");

    let contents = contents.replace(
        "HistoryProofKeyPublicationTransaction",
        "// HistoryProofKeyPublicationTransaction",
    );

    let contents =
        contents.replace("HistoryProofVoteTransaction", "// HistoryProofVoteTransaction");

    contents
}

trait BuilderExtensions {
    fn services_path<T: AsRef<str>, U: AsRef<str>>(self, proto_name: T, rust_name: U) -> Self
    where
        Self: Sized;

    fn services_same<T: AsRef<str>>(self, name: T) -> Self
    where
        Self: Sized,
    {
        self.services_path(&name, &name)
    }
}

impl BuilderExtensions for tonic_build::Builder {
    fn services_path<T: AsRef<str>, U: AsRef<str>>(self, proto_name: T, rust_name: U) -> Self {
        let proto_name = proto_name.as_ref();
        let rust_name = rust_name.as_ref();

        self.extern_path(format!(".proto.{proto_name}"), format!("crate::services::{rust_name}"))
    }
}

mod builder {
    use crate::BuilderExtensions;

    pub(super) fn extern_basic_types(builder: tonic_build::Builder) -> tonic_build::Builder {
        builder
            .services_same("Fraction")
            .services_same("Timestamp")
            .services_path("AccountID", "AccountId")
            .services_path("TokenID", "TokenId")
            .services_same("AccountAmount")
            .services_same("CurrentAndNextFeeSchedule")
            .services_same("FeeComponents")
            .services_same("FeeData")
            .services_same("FeeSchedule")
            .services_same("Key")
            .services_path("FileID", "FileId")
            .services_same("KeyList")
            .services_same("NftTransfer")
            .services_same("NodeAddress")
            .services_same("NodeAddressBook")
            .services_path("RealmID", "RealmId")
            .services_path("ScheduleID", "ScheduleId")
            .services_path("SemanticVersion", "SemanticVersion")
            .services_path("ServiceEndpoint", "ServiceEndpoint")
            .services_same("ServicesConfigurationList")
            .services_path("Setting", "Setting")
            .services_path("ShardID", "ShardId")
            .services_path("Signature", "Signature")
            .services_path("SignatureList", "SignatureList")
            .services_path("SignatureMap", "SignatureMap")
            .services_path("SignaturePair", "SignaturePair")
            .services_path("ThresholdKey", "ThresholdKey")
            .services_path("ThresholdSignature", "ThresholdSignature")
            .services_path("TimestampSeconds", "TimestampSeconds")
            .services_path("TokenBalance", "TokenBalance")
            .services_path("TokenBalances", "TokenBalances")
            .services_path("TokenRelationship", "TokenRelationship")
            .services_path("TokenTransferList", "TokenTransferList")
            .services_path("TopicID", "TopicId")
            .services_path("TransactionFeeSchedule", "TransactionFeeSchedule")
            .services_path("TransactionID", "TransactionId")
            .services_path("TransferList", "TransferList")
            .services_path("HederaFunctionality", "HederaFunctionality")
            .services_path("SubType", "SubType")
            .services_path("TokenFreezeStatus", "TokenFreezeStatus")
            .services_path("TokenKycStatus", "TokenKycStatus")
            .services_path("TokenSupplyType", "TokenSupplyType")
            .services_path("TokenType", "TokenType")
            .services_path("GrantedCryptoAllowance", "GrantedCryptoAllowance")
            .services_path("GrantedTokenAllowance", "GrantedTokenAllowance")
            .services_path("CryptoAllowance", "CryptoAllowance")
            .services_path("TokenAllowance", "TokenAllowance")
            .services_path("GrantedNftAllowance", "GrantedNftAllowance")
            .services_path("NftAllowance", "NftAllowance")
            .services_path("TokenPauseStatus", "TokenPauseStatus")
            .services_path("TokenAssociation", "TokenAssociation")
            .services_path("ContractID", "ContractId")
            .services_path("StakingInfo", "StakingInfo")
    }
}
// Filename: protobufs/src/fraction.rs
// SPDX-License-Identifier: Apache-2.0

use fraction::Fraction;

impl From<super::services::Fraction> for Fraction {
    fn from(pb: super::services::Fraction) -> Self {
        Fraction::new(pb.numerator as u64, pb.denominator as u64)
    }
}

impl From<Fraction> for super::services::Fraction {
    fn from(frac: Fraction) -> Self {
        Self {
            numerator: frac.numer().copied().unwrap_or_default() as i64,
            denominator: frac.denom().copied().unwrap_or_default() as i64,
        }
    }
}
// Filename: protobufs/src/lib.rs
// SPDX-License-Identifier: Apache-2.0

#![allow(non_camel_case_types)]
#![allow(clippy::default_trait_access, clippy::doc_markdown)]

#[cfg(feature = "time_0_3")]
mod time_0_3;

#[cfg(feature = "fraction")]
mod fraction;

// fixme: Do this, just, don't warn 70 times in generated code.
#[allow(clippy::derive_partial_eq_without_eq)]
pub mod services {
    tonic::include_proto!("proto");
}

// fixme: Do this, just, don't warn 70 times in generated code.
#[allow(clippy::derive_partial_eq_without_eq)]
pub mod mirror {
    tonic::include_proto!("mirror/com.hedera.mirror.api.proto");
}

// fixme: Do this, just, don't warn 70 times in generated code.
#[allow(clippy::derive_partial_eq_without_eq)]
pub mod streams {
    tonic::include_proto!("streams/proto");
}

// fixme: Do this, just, don't warn 70 times in generated code.
#[allow(clippy::derive_partial_eq_without_eq)]
pub mod sdk {
    tonic::include_proto!("sdk/proto");
}
// Filename: protobufs/src/time_0_3.rs
// SPDX-License-Identifier: Apache-2.0

use time_0_3::{
    Duration,
    OffsetDateTime,
};

impl From<super::services::Duration> for Duration {
    fn from(pb: super::services::Duration) -> Self {
        Self::seconds(pb.seconds)
    }
}

impl From<Duration> for super::services::Duration {
    fn from(duration: Duration) -> Self {
        Self { seconds: duration.whole_seconds() }
    }
}

impl From<super::services::TimestampSeconds> for OffsetDateTime {
    fn from(pb: super::services::TimestampSeconds) -> Self {
        OffsetDateTime::from_unix_timestamp(pb.seconds).unwrap()
    }
}

impl From<OffsetDateTime> for super::services::TimestampSeconds {
    fn from(dt: OffsetDateTime) -> Self {
        Self { seconds: dt.unix_timestamp() }
    }
}

impl From<super::services::Timestamp> for OffsetDateTime {
    fn from(pb: super::services::Timestamp) -> Self {
        OffsetDateTime::from_unix_timestamp(pb.seconds).unwrap()
            + Duration::nanoseconds(pb.nanos.into())
    }
}

impl From<OffsetDateTime> for super::services::Timestamp {
    fn from(dt: OffsetDateTime) -> Self {
        Self { seconds: dt.unix_timestamp(), nanos: dt.nanosecond() as i32 }
    }
}
// Filename: src/account/account_allowance_approve_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use services::crypto_service_client::CryptoServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Hbar,
    NftId,
    ToProtobuf,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Creates one or more hbar/token approved allowances **relative to the owner account specified in the allowances of
/// this transaction**.
///
/// Each allowance grants a spender the right to transfer a pre-determined amount of the owner's
/// hbar/token to any other account of the spender's choice. If the owner is not specified in any
/// allowance, the payer of transaction is considered to be the owner for that particular allowance.
///
/// Setting the amount to zero will remove the respective allowance for the spender.
///
pub type AccountAllowanceApproveTransaction = Transaction<AccountAllowanceApproveTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct AccountAllowanceApproveTransactionData {
    /// List of hbar allowances approved by the account owner.
    hbar_allowances: Vec<HbarAllowance>,

    /// List of fungible token allowances approved by the account owner.
    token_allowances: Vec<TokenAllowance>,

    /// List of non-fungible token allowances approved by the account owner.
    nft_allowances: Vec<NftAllowance>,
}

impl AccountAllowanceApproveTransaction {
    /// Approves the hbar allowance.
    pub fn approve_hbar_allowance(
        &mut self,
        owner_account_id: AccountId,
        spender_account_id: AccountId,
        amount: Hbar,
    ) -> &mut Self {
        self.data_mut().hbar_allowances.push(HbarAllowance {
            owner_account_id,
            spender_account_id,
            amount,
        });

        self
    }

    /// Returns the hbar allowances approved by the account owner.
    pub fn hbar_approvals(&self) -> &[HbarAllowance] {
        self.data().hbar_allowances.as_ref()
    }

    /// Approves the token allowance.
    pub fn approve_token_allowance(
        &mut self,
        token_id: TokenId,
        owner_account_id: AccountId,
        spender_account_id: AccountId,
        amount: u64,
    ) -> &mut Self {
        self.data_mut().token_allowances.push(TokenAllowance {
            token_id,
            owner_account_id,
            spender_account_id,
            amount,
        });
        self
    }

    /// Returns the fungible token allowances approved by the account owner
    pub fn token_approvals(&self) -> &[TokenAllowance] {
        self.data().token_allowances.as_ref()
    }

    /// Approve the NFT allowance.
    pub fn approve_token_nft_allowance(
        &mut self,
        nft_id: impl Into<NftId>,
        owner_account_id: AccountId,
        spender_account_id: AccountId,
    ) -> &mut Self {
        let nft_id = nft_id.into();
        let data = self.data_mut();

        if let Some(allowance) = data.nft_allowances.iter_mut().find(|allowance| {
            allowance.token_id == nft_id.token_id
                && allowance.owner_account_id == owner_account_id
                && allowance.spender_account_id == spender_account_id
                && allowance.approved_for_all.is_none()
        }) {
            allowance.serials.push(nft_id.serial as i64);
        } else {
            data.nft_allowances.push(NftAllowance {
                serials: vec![nft_id.serial as i64],
                token_id: nft_id.token_id,
                spender_account_id,
                owner_account_id,
                delegating_spender_account_id: None,
                approved_for_all: None,
            });
        };

        self
    }

    /// Approve the NFT allowance on all serial numbers (present and future).
    pub fn approve_token_nft_allowance_all_serials(
        &mut self,
        token_id: TokenId,
        owner_account_id: AccountId,
        spender_account_id: AccountId,
    ) -> &mut Self {
        self.data_mut().nft_allowances.push(NftAllowance {
            approved_for_all: Some(true),
            delegating_spender_account_id: None,
            spender_account_id,
            owner_account_id,
            token_id,
            serials: Vec::new(),
        });

        self
    }

    /// Returns the non-fungible token allowances approved by the account owner.
    pub fn token_nft_approvals(&self) -> &[NftAllowance] {
        self.data().nft_allowances.as_ref()
    }
}

#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct HbarAllowance {
    /// The account ID of the hbar owner (ie. the grantor of the allowance).
    pub owner_account_id: AccountId,

    /// The account ID of the spender of the hbar allowance.
    pub spender_account_id: AccountId,

    /// The amount of the spender's allowance.
    pub amount: Hbar,
}

#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct TokenAllowance {
    /// The token that the allowance pertains to.
    pub token_id: TokenId,

    /// The account ID of the token owner (ie. the grantor of the allowance).
    pub owner_account_id: AccountId,

    /// The account ID of the spender of the token allowance.
    pub spender_account_id: AccountId,

    /// The amount of the spender's token allowance.
    pub amount: u64,
}

#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct NftAllowance {
    /// The token that the allowance pertains to.
    pub token_id: TokenId,

    /// The account ID of the token owner (ie. the grantor of the allowance).
    pub owner_account_id: AccountId,

    /// The account ID of the spender of the token allowance.
    pub spender_account_id: AccountId,

    /// The list of serial numbers that the spender is permitted to transfer.
    pub serials: Vec<i64>,

    /// If true, the spender has access to all of the owner's NFT units of type tokenId (currently
    /// owned and any in the future).
    pub approved_for_all: Option<bool>,

    /// The account ID of the spender who is granted approvedForAll allowance and granting
    /// approval on an NFT serial to another spender.
    pub delegating_spender_account_id: Option<AccountId>,
}

impl TransactionData for AccountAllowanceApproveTransactionData {}

impl TransactionExecute for AccountAllowanceApproveTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { CryptoServiceClient::new(channel).approve_allowances(request).await })
    }
}

impl ValidateChecksums for AccountAllowanceApproveTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        for hbar_allowance in &self.hbar_allowances {
            hbar_allowance.owner_account_id.validate_checksums(ledger_id)?;
            hbar_allowance.spender_account_id.validate_checksums(ledger_id)?;
        }

        for token_allowance in &self.token_allowances {
            token_allowance.token_id.validate_checksums(ledger_id)?;
            token_allowance.owner_account_id.validate_checksums(ledger_id)?;
            token_allowance.spender_account_id.validate_checksums(ledger_id)?;
        }

        for nft_allowance in &self.nft_allowances {
            nft_allowance.token_id.validate_checksums(ledger_id)?;
            nft_allowance.spender_account_id.validate_checksums(ledger_id)?;
            nft_allowance.owner_account_id.validate_checksums(ledger_id)?;
            if let Some(delegating_spender) = nft_allowance.delegating_spender_account_id {
                delegating_spender.validate_checksums(ledger_id)?;
            }
        }

        Ok(())
    }
}

impl ToTransactionDataProtobuf for AccountAllowanceApproveTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::CryptoApproveAllowance(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for AccountAllowanceApproveTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::CryptoApproveAllowance(self.to_protobuf())
    }
}

impl From<AccountAllowanceApproveTransactionData> for AnyTransactionData {
    fn from(transaction: AccountAllowanceApproveTransactionData) -> Self {
        Self::AccountAllowanceApprove(transaction)
    }
}

impl FromProtobuf<services::CryptoApproveAllowanceTransactionBody>
    for AccountAllowanceApproveTransactionData
{
    fn from_protobuf(pb: services::CryptoApproveAllowanceTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            hbar_allowances: Vec::from_protobuf(pb.crypto_allowances)?,
            token_allowances: Vec::from_protobuf(pb.token_allowances)?,
            nft_allowances: Vec::from_protobuf(pb.nft_allowances)?,
        })
    }
}

impl ToProtobuf for AccountAllowanceApproveTransactionData {
    type Protobuf = services::CryptoApproveAllowanceTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let crypto_allowances = self.hbar_allowances.to_protobuf();

        let token_allowances = self.token_allowances.to_protobuf();

        let nft_allowances = self.nft_allowances.to_protobuf();

        services::CryptoApproveAllowanceTransactionBody {
            crypto_allowances,
            nft_allowances,
            token_allowances,
        }
    }
}

impl FromProtobuf<services::CryptoAllowance> for HbarAllowance {
    fn from_protobuf(pb: services::CryptoAllowance) -> crate::Result<Self> {
        Ok(Self {
            owner_account_id: AccountId::from_protobuf(pb_getf!(pb, owner)?)?,
            spender_account_id: AccountId::from_protobuf(pb_getf!(pb, spender)?)?,
            amount: Hbar::from_tinybars(pb.amount),
        })
    }
}

impl ToProtobuf for HbarAllowance {
    type Protobuf = services::CryptoAllowance;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            owner: Some(self.owner_account_id.to_protobuf()),
            spender: Some(self.spender_account_id.to_protobuf()),
            amount: self.amount.to_tinybars(),
        }
    }
}

impl FromProtobuf<services::TokenAllowance> for TokenAllowance {
    fn from_protobuf(pb: services::TokenAllowance) -> crate::Result<Self> {
        Ok(Self {
            token_id: TokenId::from_protobuf(pb_getf!(pb, token_id)?)?,
            owner_account_id: AccountId::from_protobuf(pb_getf!(pb, owner)?)?,
            spender_account_id: AccountId::from_protobuf(pb_getf!(pb, spender)?)?,
            amount: pb.amount as u64,
        })
    }
}

impl ToProtobuf for TokenAllowance {
    type Protobuf = services::TokenAllowance;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            token_id: Some(self.token_id.to_protobuf()),
            owner: Some(self.owner_account_id.to_protobuf()),
            spender: Some(self.spender_account_id.to_protobuf()),
            amount: self.amount as i64,
        }
    }
}

impl FromProtobuf<services::NftAllowance> for NftAllowance {
    fn from_protobuf(pb: services::NftAllowance) -> crate::Result<Self> {
        Ok(Self {
            token_id: TokenId::from_protobuf(pb_getf!(pb, token_id)?)?,
            owner_account_id: AccountId::from_protobuf(pb_getf!(pb, owner)?)?,
            spender_account_id: AccountId::from_protobuf(pb_getf!(pb, spender)?)?,
            serials: pb.serial_numbers,
            approved_for_all: pb.approved_for_all,
            delegating_spender_account_id: Option::from_protobuf(pb.delegating_spender)?,
        })
    }
}

impl ToProtobuf for NftAllowance {
    type Protobuf = services::NftAllowance;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            token_id: Some(self.token_id.to_protobuf()),
            owner: Some(self.owner_account_id.to_protobuf()),
            spender: Some(self.spender_account_id.to_protobuf()),
            serial_numbers: self.serials.clone(),
            approved_for_all: self.approved_for_all,
            delegating_spender: self.delegating_spender_account_id.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountAllowanceApproveTransaction,
        AccountId,
        AnyTransaction,
        Hbar,
        TokenId,
    };

    fn make_transaction() -> AccountAllowanceApproveTransaction {
        let owner_id = AccountId::new(5, 6, 7);

        let invalid_token_ids = [
            TokenId::new(2, 2, 2),
            TokenId::new(4, 4, 4),
            TokenId::new(6, 6, 6),
            TokenId::new(8, 8, 8),
        ];

        let invalid_account_ids = [
            AccountId::new(1, 1, 1),
            AccountId::new(3, 3, 3),
            AccountId::new(5, 5, 5),
            AccountId::new(7, 7, 7),
            AccountId::new(9, 9, 9),
        ];

        let mut tx = AccountAllowanceApproveTransaction::new_for_tests();

        tx.approve_hbar_allowance(owner_id, invalid_account_ids[0], Hbar::new(3))
            .approve_token_allowance(invalid_token_ids[0], owner_id, invalid_account_ids[1], 6)
            .approve_token_nft_allowance(
                invalid_token_ids[1].nft(123),
                owner_id,
                invalid_account_ids[2],
            )
            .approve_token_nft_allowance(
                invalid_token_ids[1].nft(456),
                owner_id,
                invalid_account_ids[2],
            )
            .approve_token_nft_allowance(
                invalid_token_ids[3].nft(456),
                owner_id,
                invalid_account_ids[2],
            )
            .approve_token_nft_allowance(
                invalid_token_ids[1].nft(789),
                owner_id,
                invalid_account_ids[4],
            )
            .approve_token_nft_allowance_all_serials(
                invalid_token_ids[2],
                owner_id,
                invalid_account_ids[3],
            )
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            CryptoApproveAllowance(
                CryptoApproveAllowanceTransactionBody {
                    crypto_allowances: [
                        CryptoAllowance {
                            owner: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 6,
                                    account: Some(
                                        AccountNum(
                                            7,
                                        ),
                                    ),
                                },
                            ),
                            spender: Some(
                                AccountId {
                                    shard_num: 1,
                                    realm_num: 1,
                                    account: Some(
                                        AccountNum(
                                            1,
                                        ),
                                    ),
                                },
                            ),
                            amount: 300000000,
                        },
                    ],
                    nft_allowances: [
                        NftAllowance {
                            token_id: Some(
                                TokenId {
                                    shard_num: 4,
                                    realm_num: 4,
                                    token_num: 4,
                                },
                            ),
                            owner: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 6,
                                    account: Some(
                                        AccountNum(
                                            7,
                                        ),
                                    ),
                                },
                            ),
                            spender: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 5,
                                    account: Some(
                                        AccountNum(
                                            5,
                                        ),
                                    ),
                                },
                            ),
                            serial_numbers: [
                                123,
                                456,
                            ],
                            approved_for_all: None,
                            delegating_spender: None,
                        },
                        NftAllowance {
                            token_id: Some(
                                TokenId {
                                    shard_num: 8,
                                    realm_num: 8,
                                    token_num: 8,
                                },
                            ),
                            owner: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 6,
                                    account: Some(
                                        AccountNum(
                                            7,
                                        ),
                                    ),
                                },
                            ),
                            spender: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 5,
                                    account: Some(
                                        AccountNum(
                                            5,
                                        ),
                                    ),
                                },
                            ),
                            serial_numbers: [
                                456,
                            ],
                            approved_for_all: None,
                            delegating_spender: None,
                        },
                        NftAllowance {
                            token_id: Some(
                                TokenId {
                                    shard_num: 4,
                                    realm_num: 4,
                                    token_num: 4,
                                },
                            ),
                            owner: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 6,
                                    account: Some(
                                        AccountNum(
                                            7,
                                        ),
                                    ),
                                },
                            ),
                            spender: Some(
                                AccountId {
                                    shard_num: 9,
                                    realm_num: 9,
                                    account: Some(
                                        AccountNum(
                                            9,
                                        ),
                                    ),
                                },
                            ),
                            serial_numbers: [
                                789,
                            ],
                            approved_for_all: None,
                            delegating_spender: None,
                        },
                        NftAllowance {
                            token_id: Some(
                                TokenId {
                                    shard_num: 6,
                                    realm_num: 6,
                                    token_num: 6,
                                },
                            ),
                            owner: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 6,
                                    account: Some(
                                        AccountNum(
                                            7,
                                        ),
                                    ),
                                },
                            ),
                            spender: Some(
                                AccountId {
                                    shard_num: 7,
                                    realm_num: 7,
                                    account: Some(
                                        AccountNum(
                                            7,
                                        ),
                                    ),
                                },
                            ),
                            serial_numbers: [],
                            approved_for_all: Some(
                                true,
                            ),
                            delegating_spender: None,
                        },
                    ],
                    token_allowances: [
                        TokenAllowance {
                            token_id: Some(
                                TokenId {
                                    shard_num: 2,
                                    realm_num: 2,
                                    token_num: 2,
                                },
                            ),
                            owner: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 6,
                                    account: Some(
                                        AccountNum(
                                            7,
                                        ),
                                    ),
                                },
                            ),
                            spender: Some(
                                AccountId {
                                    shard_num: 3,
                                    realm_num: 3,
                                    account: Some(
                                        AccountNum(
                                            3,
                                        ),
                                    ),
                                },
                            ),
                            amount: 6,
                        },
                    ],
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn check_properties() {
        let tx = make_transaction();

        assert!(!tx.hbar_approvals().is_empty());
        assert!(!tx.token_approvals().is_empty());
        assert!(!tx.token_approvals().is_empty());
    }
}
// Filename: src/account/account_allowance_delete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    NftId,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Deletes one or more non-fungible approved allowances from an owner's account. This operation
/// will remove the allowances granted to one or more specific non-fungible token serial numbers. Each owner account
/// listed as wiping an allowance must sign the transaction. Hbar and fungible token allowances
/// can be removed by setting the amount to zero in
/// [`AccountAllowanceApproveTransaction`](crate::AccountAllowanceApproveTransaction).
pub type AccountAllowanceDeleteTransaction = Transaction<AccountAllowanceDeleteTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct AccountAllowanceDeleteTransactionData {
    nft_allowances: Vec<NftRemoveAllowance>,
}

#[derive(Debug, Clone)]
pub struct NftRemoveAllowance {
    /// token that the allowance pertains to
    pub token_id: TokenId,

    /// The account ID that owns token.
    pub owner_account_id: AccountId,

    /// The list of serial numbers to remove allowances from.
    pub serials: Vec<i64>,
}

impl AccountAllowanceDeleteTransaction {
    /// Get the nft allowances that will be removed.
    #[must_use]
    pub fn get_nft_allowances(&self) -> &[NftRemoveAllowance] {
        &self.data().nft_allowances
    }

    /// Remove all nft token allowances.
    pub fn delete_all_token_nft_allowances(
        &mut self,
        nft_id: NftId,
        owner_account_id: AccountId,
    ) -> &mut Self {
        let data = self.data_mut();

        if let Some(allowance) = data.nft_allowances.iter_mut().find(|allowance| {
            allowance.token_id == nft_id.token_id && allowance.owner_account_id == owner_account_id
        }) {
            allowance.serials.push(nft_id.serial as i64);
        } else {
            data.nft_allowances.push(NftRemoveAllowance {
                token_id: nft_id.token_id,
                serials: vec![nft_id.serial as i64],
                owner_account_id,
            });
        }

        self
    }
}

impl TransactionData for AccountAllowanceDeleteTransactionData {}

impl TransactionExecute for AccountAllowanceDeleteTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { CryptoServiceClient::new(channel).delete_allowances(request).await })
    }
}

impl ValidateChecksums for AccountAllowanceDeleteTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        for allowance in &self.nft_allowances {
            allowance.token_id.validate_checksums(ledger_id)?;
            allowance.owner_account_id.validate_checksums(ledger_id)?;
        }
        Ok(())
    }
}

impl ToTransactionDataProtobuf for AccountAllowanceDeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::CryptoDeleteAllowance(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for AccountAllowanceDeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::CryptoDeleteAllowance(self.to_protobuf())
    }
}

impl From<AccountAllowanceDeleteTransactionData> for AnyTransactionData {
    fn from(transaction: AccountAllowanceDeleteTransactionData) -> Self {
        Self::AccountAllowanceDelete(transaction)
    }
}

impl FromProtobuf<services::CryptoDeleteAllowanceTransactionBody>
    for AccountAllowanceDeleteTransactionData
{
    fn from_protobuf(pb: services::CryptoDeleteAllowanceTransactionBody) -> crate::Result<Self> {
        Ok(Self { nft_allowances: Vec::from_protobuf(pb.nft_allowances)? })
    }
}

impl ToProtobuf for AccountAllowanceDeleteTransactionData {
    type Protobuf = services::CryptoDeleteAllowanceTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::CryptoDeleteAllowanceTransactionBody {
            nft_allowances: self.nft_allowances.to_protobuf(),
        }
    }
}

impl FromProtobuf<services::NftRemoveAllowance> for NftRemoveAllowance {
    fn from_protobuf(pb: services::NftRemoveAllowance) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Ok(Self {
            token_id: TokenId::from_protobuf(pb_getf!(pb, token_id)?)?,
            owner_account_id: AccountId::from_protobuf(pb_getf!(pb, owner)?)?,
            serials: pb.serial_numbers,
        })
    }
}

impl ToProtobuf for NftRemoveAllowance {
    type Protobuf = services::NftRemoveAllowance;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            token_id: Some(self.token_id.to_protobuf()),
            owner: Some(self.owner_account_id.to_protobuf()),
            serial_numbers: self.serials.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountAllowanceDeleteTransaction,
        AccountId,
        AnyTransaction,
        TokenId,
    };

    fn make_transaction() -> AccountAllowanceDeleteTransaction {
        let owner_id: AccountId = AccountId::new(5, 6, 7);

        let invalid_token_ids: [TokenId; 2] = [TokenId::new(4, 4, 4), TokenId::new(8, 8, 8)];

        let mut tx = AccountAllowanceDeleteTransaction::new_for_tests();

        tx.delete_all_token_nft_allowances(invalid_token_ids[0].nft(123), owner_id)
            .delete_all_token_nft_allowances(invalid_token_ids[0].nft(456), owner_id)
            .delete_all_token_nft_allowances(invalid_token_ids[1].nft(456), owner_id)
            .delete_all_token_nft_allowances(invalid_token_ids[0].nft(789), owner_id)
            .freeze()
            .unwrap();
        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            CryptoDeleteAllowance(
                CryptoDeleteAllowanceTransactionBody {
                    nft_allowances: [
                        NftRemoveAllowance {
                            token_id: Some(
                                TokenId {
                                    shard_num: 4,
                                    realm_num: 4,
                                    token_num: 4,
                                },
                            ),
                            owner: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 6,
                                    account: Some(
                                        AccountNum(
                                            7,
                                        ),
                                    ),
                                },
                            ),
                            serial_numbers: [
                                123,
                                456,
                                789,
                            ],
                        },
                        NftRemoveAllowance {
                            token_id: Some(
                                TokenId {
                                    shard_num: 8,
                                    realm_num: 8,
                                    token_num: 8,
                                },
                            ),
                            owner: Some(
                                AccountId {
                                    shard_num: 5,
                                    realm_num: 6,
                                    account: Some(
                                        AccountNum(
                                            7,
                                        ),
                                    ),
                                },
                            ),
                            serial_numbers: [
                                456,
                            ],
                        },
                    ],
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }
}
// Filename: src/account/account_balance.rs
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashMap;

use hedera_proto::services;
use prost::Message;

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    FromProtobuf,
    Hbar,
    Tinybar,
    TokenId,
};

/// Response from [`AccountBalanceQuery`][crate::AccountBalanceQuery].
#[derive(Debug, Clone)]
pub struct AccountBalance {
    /// The account that is being referenced.
    pub account_id: AccountId,

    /// Current balance of the referenced account.
    pub hbars: Hbar,

    /// Token balances for the referenced account.
    // #[deprecated = "use a mirror query"]
    pub tokens: HashMap<TokenId, u64>,

    /// Token decimals for the referenced account.
    #[deprecated = "use a mirror query"]
    #[allow(deprecated)]
    pub token_decimals: HashMap<TokenId, u32>,
}

impl AccountBalance {
    /// Create a new `AccountBalance` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::CryptoGetAccountBalanceResponse>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        #[allow(deprecated)]
        services::CryptoGetAccountBalanceResponse {
            header: None,
            account_id: Some(self.account_id.to_protobuf()),
            balance: self.hbars.to_tinybars() as u64,
            token_balances: Vec::default(),
        }
        .encode_to_vec()
    }
}

impl FromProtobuf<services::CryptoGetAccountBalanceResponse> for AccountBalance {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::CryptoGetAccountBalanceResponse) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let account_id = pb_getf!(pb, account_id)?;
        let account_id = AccountId::from_protobuf(account_id)?;

        let balance = Hbar::from_tinybars(pb.balance as Tinybar);

        let mut tokens = HashMap::with_capacity(pb.token_balances.len());
        let mut token_decimals = HashMap::with_capacity(pb.token_balances.len());

        for token in pb.token_balances {
            let token_id = TokenId::from_protobuf(pb_getf!(token, token_id)?)?;

            tokens.insert(token_id, token.balance);
            token_decimals.insert(token_id, token.decimals);
        }

        Ok(Self { account_id, hbars: balance, tokens, token_decimals })
    }
}

impl FromProtobuf<services::response::Response> for AccountBalance {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self> {
        let response = pb_getv!(pb, CryptogetAccountBalance, services::response::Response);

        Self::from_protobuf(response)
    }
}
// Filename: src/account/account_balance_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use services::crypto_get_account_balance_query::BalanceSource;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    Query,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    AccountBalance,
    AccountId,
    BoxGrpcFuture,
    ContractId,
    Error,
    ToProtobuf,
    ValidateChecksums,
};

/// Get the balance of a cryptocurrency account.
///
/// This returns only the balance, so it is a smaller reply
/// than [`AccountInfoQuery`][crate::AccountInfoQuery],
/// which returns the balance plus additional information.
pub type AccountBalanceQuery = Query<AccountBalanceQueryData>;

#[derive(Clone, Debug)]
pub struct AccountBalanceQueryData {
    source: AccountBalanceSource,
}

impl Default for AccountBalanceQueryData {
    fn default() -> Self {
        Self { source: AccountBalanceSource::AccountId(AccountId::from(0)) }
    }
}

impl From<AccountBalanceQueryData> for AnyQueryData {
    #[inline]
    fn from(data: AccountBalanceQueryData) -> Self {
        Self::AccountBalance(data)
    }
}

#[derive(Clone, Debug)]
enum AccountBalanceSource {
    AccountId(AccountId),
    ContractId(ContractId),
}

impl AccountBalanceQuery {
    /// Get the account ID for which information is requested.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        match self.data.source {
            AccountBalanceSource::AccountId(it) => Some(it),
            AccountBalanceSource::ContractId(_) => None,
        }
    }

    /// Sets the account ID for which information is requested.
    ///
    /// This is mutually exclusive with [`contract_id`](Self::contract_id).
    pub fn account_id(&mut self, id: AccountId) -> &mut Self {
        self.data.source = AccountBalanceSource::AccountId(id);
        self
    }

    /// Get the contract ID for which information is requested.
    #[must_use]
    pub fn get_contract_id(&self) -> Option<ContractId> {
        match self.data.source {
            AccountBalanceSource::ContractId(it) => Some(it),
            AccountBalanceSource::AccountId(_) => None,
        }
    }

    /// Sets the contract ID for which information is requested.
    ///
    /// This is mutually exclusive with [`account_id`](Self::account_id).
    pub fn contract_id(&mut self, id: ContractId) -> &mut Self {
        self.data.source = AccountBalanceSource::ContractId(id);
        self
    }
}

impl ToQueryProtobuf for AccountBalanceQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let source = Some(&self.source).as_ref().map(|source| match source {
            AccountBalanceSource::AccountId(id) => BalanceSource::AccountId(id.to_protobuf()),
            AccountBalanceSource::ContractId(id) => BalanceSource::ContractId(id.to_protobuf()),
        });

        services::Query {
            query: Some(services::query::Query::CryptogetAccountBalance(
                services::CryptoGetAccountBalanceQuery {
                    balance_source: source,
                    header: Some(header),
                },
            )),
        }
    }
}

impl QueryExecute for AccountBalanceQueryData {
    type Response = AccountBalance;

    fn is_payment_required(&self) -> bool {
        false
    }

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { CryptoServiceClient::new(channel).crypto_get_balance(request).await })
    }
}

impl ValidateChecksums for AccountBalanceQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        match self.source {
            AccountBalanceSource::AccountId(account_id) => account_id.validate_checksums(ledger_id),
            AccountBalanceSource::ContractId(contract_id) => {
                contract_id.validate_checksums(ledger_id)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        AccountBalanceQuery,
        AccountId,
        ContractId,
    };

    #[test]
    fn serialize_with_account_id() {
        expect![[r#"
            Query {
                query: Some(
                    CryptogetAccountBalance(
                        CryptoGetAccountBalanceQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            balance_source: Some(
                                AccountId(
                                    AccountId {
                                        shard_num: 0,
                                        realm_num: 0,
                                        account: Some(
                                            AccountNum(
                                                5005,
                                            ),
                                        ),
                                    },
                                ),
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &AccountBalanceQuery::new()
                .account_id(crate::AccountId::new(0, 0, 5005))
                .data
                .to_query_protobuf(Default::default()),
        );
    }

    #[test]
    fn serialize_with_contract_id() {
        expect![[r#"
            Query {
                query: Some(
                    CryptogetAccountBalance(
                        CryptoGetAccountBalanceQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            balance_source: Some(
                                ContractId(
                                    ContractId {
                                        shard_num: 0,
                                        realm_num: 0,
                                        contract: Some(
                                            ContractNum(
                                                5005,
                                            ),
                                        ),
                                    },
                                ),
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &AccountBalanceQuery::new()
                .contract_id(crate::ContractId::new(0, 0, 5005))
                .data
                .to_query_protobuf(Default::default()),
        );
    }

    #[test]
    fn get_set_account_id() {
        let mut query = AccountBalanceQuery::new();
        query.account_id(AccountId::new(0, 0, 5005));

        assert_eq!(query.get_account_id(), Some(AccountId::new(0, 0, 5005)));
    }

    #[test]
    fn get_set_contract_id() {
        let mut query = AccountBalanceQuery::new();
        query.contract_id(ContractId::new(0, 0, 5005));

        assert_eq!(query.get_contract_id(), Some(ContractId::new(0, 0, 5005)));
    }
}
// Filename: src/account/account_create_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use time::Duration;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::staked_id::StakedId;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    EvmAddress,
    Hbar,
    Key,
    Transaction,
    ValidateChecksums,
};

/// Create a new Hiero account.
pub type AccountCreateTransaction = Transaction<AccountCreateTransactionData>;

// TODO: shard_id: Option<ShardId>
// TODO: realm_id: Option<RealmId>
// TODO: new_realm_admin_key: Option<Key>,

#[derive(Debug, Clone)]
pub struct AccountCreateTransactionData {
    /// The key that must sign each transfer out of the account.
    ///
    /// If `receiver_signature_required` is true, then it must also sign any transfer
    /// into the account.
    key: Option<Key>,

    /// The initial number of Hbar to put into the account.
    initial_balance: Hbar,

    /// If true, this account's key must sign any transaction depositing into this account.
    receiver_signature_required: bool,

    /// The account is charged to extend its expiration date every this many seconds.
    auto_renew_period: Option<Duration>,

    /// The account to be used at this account's expiration time to extend the
    /// life of the account.  If `None`, this account pays for its own auto renewal fee.
    auto_renew_account_id: Option<AccountId>,

    /// The memo associated with the account.
    account_memo: String,

    /// The maximum number of tokens that an Account can be implicitly associated with.
    ///
    /// Defaults to `0`. Allows up to a maximum value of `1000`.
    /// If the value is set to `-1`, unlimited automatic token associations are allowed.
    max_automatic_token_associations: i32,

    // notably *not* a PublicKey.
    /// A 20-byte EVM address to be used as the account's alias.
    alias: Option<EvmAddress>,

    /// ID of the account or node to which this account is staking, if any.
    staked_id: Option<StakedId>,

    /// If true, the account declines receiving a staking reward. The default value is false.
    decline_staking_reward: bool,
}

impl Default for AccountCreateTransactionData {
    fn default() -> Self {
        Self {
            key: None,
            initial_balance: Hbar::ZERO,
            receiver_signature_required: false,
            auto_renew_period: Some(Duration::days(90)),
            auto_renew_account_id: None,
            account_memo: String::new(),
            max_automatic_token_associations: 0,
            alias: None,
            staked_id: None,
            decline_staking_reward: false,
        }
    }
}

impl AccountCreateTransaction {
    /// Get the key this account will be created with.
    ///
    /// Returns `Some(key)` if previously set, `None` otherwise.
    #[must_use]
    pub fn get_key(&self) -> Option<&Key> {
        self.data().key.as_ref()
    }

    /// Sets the key for this account.
    pub fn key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().key = Some(key.into());
        self
    }

    /// Get the balance that will be transferred to this account on creation.
    ///
    /// Returns `initial_balance` if previously set, `0` otherwise.
    #[must_use]
    pub fn get_initial_balance(&self) -> Hbar {
        self.data().initial_balance
    }

    /// Sets the balance that will be transferred to this account on creation.
    pub fn initial_balance(&mut self, balance: Hbar) -> &mut Self {
        self.data_mut().initial_balance = balance;
        self
    }

    /// Returns `true` if this account must sign any transfer of hbars _to_ itself.
    #[must_use]
    pub fn get_receiver_signature_required(&self) -> bool {
        self.data().receiver_signature_required
    }

    /// Sets to true to require this account to sign any transfer of hbars to this account.
    pub fn receiver_signature_required(&mut self, required: bool) -> &mut Self {
        self.data_mut().receiver_signature_required = required;
        self
    }

    /// Returns the auto renew period for this account.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.data().auto_renew_period
    }

    /// Sets the auto renew period for this account.
    pub fn auto_renew_period(&mut self, period: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = Some(period);
        self
    }

    /// Gets the account to be used at this account's expiration time to extend the
    /// life of the account.  If `None`, this account pays for its own auto renewal fee.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the account to be used at this account's expiration time to extend the
    /// life of the account.  If `None`, this account pays for its own auto renewal fee.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    pub fn auto_renew_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(id);
        self
    }

    /// Get the memo associated with the account
    #[must_use]
    pub fn get_account_memo(&self) -> &str {
        &self.data().account_memo
    }

    /// Sets the memo associated with the account.
    pub fn account_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().account_memo = memo.into();
        self
    }

    /// Get the maximum number of tokens that an Account can be implicitly associated with.
    ///
    /// Defaults to `0`. Allows up to a maximum value of `1000`.
    #[must_use]
    pub fn get_max_automatic_token_associations(&self) -> i32 {
        self.data().max_automatic_token_associations
    }

    /// Sets the maximum number of tokens that an Account can be implicitly associated with.
    pub fn max_automatic_token_associations(&mut self, amount: i32) -> &mut Self {
        self.data_mut().max_automatic_token_associations = amount;
        self
    }

    /// Returns the evm address the account will be created with as an alias.
    ///
    /// # Network Support
    /// Please note that this not currently supported on mainnet.
    #[must_use]
    pub fn get_alias(&self) -> Option<EvmAddress> {
        self.data().alias
    }

    /// Sets the evm address the account will be created with as an alias.
    ///
    /// The last 20 bytes of the keccak-256 hash of a `ECDSA_SECP256K1` primitive key.
    ///
    /// # Network Support
    /// Please note that this not currently supported on mainnet.
    pub fn alias(&mut self, alias: EvmAddress) -> &mut Self {
        self.data_mut().alias = Some(alias);
        self
    }

    /// Returns the ID of the account to which this account is staking.
    /// This is mutually exclusive with `staked_node_id`.
    #[must_use]
    pub fn get_staked_account_id(&self) -> Option<AccountId> {
        self.data().staked_id.and_then(StakedId::to_account_id)
    }

    /// Sets the ID of the account to which this account is staking.
    /// This is mutually exclusive with `staked_node_id`.
    pub fn staked_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().staked_id = Some(StakedId::AccountId(id));
        self
    }

    /// Returns the ID of the node to which this account is staking.
    /// This is mutually exclusive with `staked_account_id`.
    #[must_use]
    pub fn get_staked_node_id(&self) -> Option<u64> {
        self.data().staked_id.and_then(StakedId::to_node_id)
    }

    /// Sets the ID of the node to which this account is staking.
    /// This is mutually exclusive with `staked_account_id`.
    pub fn staked_node_id(&mut self, id: u64) -> &mut Self {
        self.data_mut().staked_id = Some(StakedId::NodeId(id));
        self
    }

    /// Returns `true` if the account should decline receiving staking rewards, `false` otherwise.
    #[must_use]
    pub fn get_decline_staking_reward(&self) -> bool {
        self.data().decline_staking_reward
    }

    /// If `true`, the account declines receiving a staking reward. The default value is false.
    pub fn decline_staking_reward(&mut self, decline: bool) -> &mut Self {
        self.data_mut().decline_staking_reward = decline;
        self
    }
}

impl TransactionData for AccountCreateTransactionData {}

impl TransactionExecute for AccountCreateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { CryptoServiceClient::new(channel).create_account(request).await })
    }
}

impl ValidateChecksums for AccountCreateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.staked_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for AccountCreateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::CryptoCreateAccount(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for AccountCreateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::CryptoCreateAccount(self.to_protobuf())
    }
}

impl From<AccountCreateTransactionData> for AnyTransactionData {
    fn from(transaction: AccountCreateTransactionData) -> Self {
        Self::AccountCreate(transaction)
    }
}

impl FromProtobuf<services::CryptoCreateTransactionBody> for AccountCreateTransactionData {
    fn from_protobuf(pb: services::CryptoCreateTransactionBody) -> crate::Result<Self> {
        let alias = (!pb.alias.is_empty()).then(|| EvmAddress::try_from(pb.alias)).transpose()?;

        Ok(Self {
            key: Option::from_protobuf(pb.key)?,
            initial_balance: Hbar::from_tinybars(pb.initial_balance as i64),
            receiver_signature_required: pb.receiver_sig_required,
            auto_renew_period: pb.auto_renew_period.map(Into::into),
            auto_renew_account_id: None,
            account_memo: pb.memo,
            max_automatic_token_associations: pb.max_automatic_token_associations,
            alias,
            staked_id: Option::from_protobuf(pb.staked_id)?,
            decline_staking_reward: pb.decline_reward,
        })
    }
}

impl ToProtobuf for AccountCreateTransactionData {
    type Protobuf = services::CryptoCreateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let key = self.key.to_protobuf();
        let auto_renew_period = self.auto_renew_period.to_protobuf();
        let staked_id = self.staked_id.map(|it| match it {
            StakedId::NodeId(id) => {
                services::crypto_create_transaction_body::StakedId::StakedNodeId(id as i64)
            }
            StakedId::AccountId(id) => {
                services::crypto_create_transaction_body::StakedId::StakedAccountId(
                    id.to_protobuf(),
                )
            }
        });

        #[allow(deprecated)]
        services::CryptoCreateTransactionBody {
            key,
            initial_balance: self.initial_balance.to_tinybars() as u64,
            proxy_account_id: None,
            send_record_threshold: i64::MAX as u64,
            receive_record_threshold: i64::MAX as u64,
            receiver_sig_required: self.receiver_signature_required,
            auto_renew_period,
            shard_id: None,
            realm_id: None,
            new_realm_admin_key: None,
            memo: self.account_memo.clone(),
            max_automatic_token_associations: i32::from(self.max_automatic_token_associations),
            alias: self.alias.map_or(vec![], |it| it.to_bytes().to_vec()),
            decline_reward: self.decline_staking_reward,
            staked_id,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use hex_literal::hex;
    use time::Duration;

    use crate::account::AccountCreateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::staked_id::StakedId;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
    };
    use crate::{
        AccountCreateTransaction,
        AccountId,
        AnyTransaction,
        EvmAddress,
        Hbar,
        PublicKey,
    };

    fn key() -> PublicKey {
        unused_private_key().public_key()
    }

    const INITIAL_BALANCE: Hbar = Hbar::from_tinybars(450);
    const ACCOUNT_MEMO: &str = "some memo";
    const RECEIVER_SIGNATURE_REQUIRED: bool = true;
    const AUTO_RENEW_PERIOD: Duration = Duration::hours(10);
    const STAKED_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 3);
    const STAKED_NODE_ID: u64 = 4;
    const ALIAS: EvmAddress = EvmAddress(hex!("5c562e90feaf0eebd33ea75d21024f249d451417"));
    const MAX_AUTOMATIC_TOKEN_ASSOCIATIONS: i32 = 100;

    fn make_transaction() -> AccountCreateTransaction {
        let mut tx = AccountCreateTransaction::new_for_tests();

        tx.key(key())
            .initial_balance(INITIAL_BALANCE)
            .account_memo(ACCOUNT_MEMO)
            .receiver_signature_required(RECEIVER_SIGNATURE_REQUIRED)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .staked_account_id(STAKED_ACCOUNT_ID)
            .alias(ALIAS)
            .max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
            .freeze()
            .unwrap();

        return tx;
    }

    fn make_transaction2() -> AccountCreateTransaction {
        let mut tx = AccountCreateTransaction::new_for_tests();

        tx.key(key())
            .initial_balance(INITIAL_BALANCE)
            .account_memo(ACCOUNT_MEMO)
            .receiver_signature_required(RECEIVER_SIGNATURE_REQUIRED)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .staked_node_id(STAKED_NODE_ID)
            .alias(ALIAS)
            .max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
            .freeze()
            .unwrap();

        return tx;
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            CryptoCreateAccount(
                CryptoCreateTransactionBody {
                    key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    initial_balance: 450,
                    proxy_account_id: None,
                    send_record_threshold: 9223372036854775807,
                    receive_record_threshold: 9223372036854775807,
                    receiver_sig_required: true,
                    auto_renew_period: Some(
                        Duration {
                            seconds: 36000,
                        },
                    ),
                    shard_id: None,
                    realm_id: None,
                    new_realm_admin_key: None,
                    memo: "some memo",
                    max_automatic_token_associations: 100,
                    decline_reward: false,
                    alias: [
                        92,
                        86,
                        46,
                        144,
                        254,
                        175,
                        14,
                        235,
                        211,
                        62,
                        167,
                        93,
                        33,
                        2,
                        79,
                        36,
                        157,
                        69,
                        20,
                        23,
                    ],
                    staked_id: Some(
                        StakedAccountId(
                            AccountId {
                                shard_num: 0,
                                realm_num: 0,
                                account: Some(
                                    AccountNum(
                                        3,
                                    ),
                                ),
                            },
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn serialize2() {
        let tx = make_transaction2();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            CryptoCreateAccount(
                CryptoCreateTransactionBody {
                    key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    initial_balance: 450,
                    proxy_account_id: None,
                    send_record_threshold: 9223372036854775807,
                    receive_record_threshold: 9223372036854775807,
                    receiver_sig_required: true,
                    auto_renew_period: Some(
                        Duration {
                            seconds: 36000,
                        },
                    ),
                    shard_id: None,
                    realm_id: None,
                    new_realm_admin_key: None,
                    memo: "some memo",
                    max_automatic_token_associations: 100,
                    decline_reward: false,
                    alias: [
                        92,
                        86,
                        46,
                        144,
                        254,
                        175,
                        14,
                        235,
                        211,
                        62,
                        167,
                        93,
                        33,
                        2,
                        79,
                        36,
                        157,
                        69,
                        20,
                        23,
                    ],
                    staked_id: Some(
                        StakedNodeId(
                            4,
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes2() {
        let tx = make_transaction2();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        #[allow(deprecated)]
        let tx = services::CryptoCreateTransactionBody {
            key: Some(key().to_protobuf()),
            initial_balance: INITIAL_BALANCE.to_tinybars() as u64,
            proxy_account_id: None,
            send_record_threshold: i64::MAX as u64,
            receive_record_threshold: i64::MAX as u64,
            receiver_sig_required: RECEIVER_SIGNATURE_REQUIRED,
            auto_renew_period: Some(AUTO_RENEW_PERIOD.to_protobuf()),
            shard_id: None,
            realm_id: None,
            new_realm_admin_key: None,
            memo: ACCOUNT_MEMO.to_owned(),
            max_automatic_token_associations: MAX_AUTOMATIC_TOKEN_ASSOCIATIONS,
            decline_reward: false,
            alias: ALIAS.to_bytes().to_vec(),
            staked_id: Some(services::crypto_create_transaction_body::StakedId::StakedAccountId(
                STAKED_ACCOUNT_ID.to_protobuf(),
            )),
        };

        let tx = AccountCreateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.key, Some(key().into()));
        assert_eq!(tx.initial_balance, INITIAL_BALANCE);
        assert_eq!(tx.account_memo, ACCOUNT_MEMO);
        assert_eq!(tx.receiver_signature_required, RECEIVER_SIGNATURE_REQUIRED);
        assert_eq!(tx.auto_renew_period, Some(AUTO_RENEW_PERIOD));
        assert_eq!(tx.staked_id.and_then(StakedId::to_account_id), Some(STAKED_ACCOUNT_ID));
        assert_eq!(tx.alias, Some(ALIAS));
        assert_eq!(tx.max_automatic_token_associations, MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);
    }

    #[test]
    fn properties() {
        let tx = make_transaction();

        assert_eq!(tx.get_key(), Some(&key().into()));
        assert_eq!(tx.get_initial_balance(), INITIAL_BALANCE);
        assert_eq!(tx.get_account_memo(), ACCOUNT_MEMO);
        assert_eq!(tx.get_receiver_signature_required(), RECEIVER_SIGNATURE_REQUIRED);
        assert_eq!(tx.get_auto_renew_period(), Some(AUTO_RENEW_PERIOD));
        assert_eq!(tx.get_staked_account_id(), Some(STAKED_ACCOUNT_ID));
        assert_eq!(tx.get_alias(), Some(ALIAS));
        assert_eq!(tx.get_max_automatic_token_associations(), MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);
    }

    #[test]
    fn get_set_key() {
        let mut tx = AccountCreateTransaction::new();
        tx.key(key());

        assert_eq!(tx.get_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_key_frozen_panics() {
        let mut tx = make_transaction();

        tx.key(key());
    }

    #[test]
    fn get_set_initial_balance() {
        let mut tx = AccountCreateTransaction::new();
        tx.initial_balance(INITIAL_BALANCE);

        assert_eq!(tx.get_initial_balance(), INITIAL_BALANCE);
    }

    #[test]
    #[should_panic]
    fn get_set_initial_balance_frozen_panics() {
        let mut tx = make_transaction();

        tx.initial_balance(INITIAL_BALANCE);
    }

    #[test]
    fn get_set_account_memo() {
        let mut tx = AccountCreateTransaction::new();
        tx.account_memo(ACCOUNT_MEMO);

        assert_eq!(tx.get_account_memo(), ACCOUNT_MEMO);
    }

    #[test]
    #[should_panic]
    fn get_set_account_memo_frozen_panics() {
        let mut tx = make_transaction();

        tx.account_memo(ACCOUNT_MEMO);
    }

    #[test]
    fn get_set_receiver_signature_required() {
        let mut tx = AccountCreateTransaction::new();
        tx.receiver_signature_required(RECEIVER_SIGNATURE_REQUIRED);

        assert_eq!(tx.get_receiver_signature_required(), RECEIVER_SIGNATURE_REQUIRED);
    }

    #[test]
    #[should_panic]
    fn get_set_receiver_signature_required_frozen_panics() {
        let mut tx = make_transaction();

        tx.receiver_signature_required(RECEIVER_SIGNATURE_REQUIRED);
    }

    #[test]
    fn get_set_auto_renew_period() {
        let mut tx = AccountCreateTransaction::new();
        tx.auto_renew_period(AUTO_RENEW_PERIOD);

        assert_eq!(tx.get_auto_renew_period(), Some(AUTO_RENEW_PERIOD));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_period_frozen_panics() {
        let mut tx = make_transaction();

        tx.auto_renew_period(AUTO_RENEW_PERIOD);
    }

    #[test]
    fn get_set_staked_account_id() {
        let mut tx = AccountCreateTransaction::new();
        tx.staked_account_id(STAKED_ACCOUNT_ID);

        assert_eq!(tx.get_staked_account_id(), Some(STAKED_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_staked_account_id_frozen_panics() {
        let mut tx = make_transaction();

        tx.staked_account_id(STAKED_ACCOUNT_ID);
    }

    #[test]
    fn get_set_alias() {
        let mut tx = AccountCreateTransaction::new();
        tx.alias(ALIAS);

        assert_eq!(tx.get_alias(), Some(ALIAS));
    }

    #[test]
    #[should_panic]
    fn get_set_alias_frozen_panics() {
        let mut tx = make_transaction();

        tx.alias(ALIAS);
    }

    #[test]
    fn get_set_max_automatic_token_associations() {
        let mut tx = AccountCreateTransaction::new();
        tx.max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);

        assert_eq!(tx.get_max_automatic_token_associations(), MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);
    }

    #[test]
    #[should_panic]
    fn get_set_max_automatic_token_associations_frozen_panics() {
        let mut tx = make_transaction();

        tx.max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);
    }
}
// Filename: src/account/account_delete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Transaction,
    ValidateChecksums,
};

/// Mark an account as deleted, moving all its current hbars to another account.
///
/// It will remain in the ledger, marked as deleted, until it expires.
/// Transfers into it a deleted account will fail.
///
pub type AccountDeleteTransaction = Transaction<AccountDeleteTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct AccountDeleteTransactionData {
    /// The account ID which will receive all remaining hbars.
    transfer_account_id: Option<AccountId>,

    /// The account ID which should be deleted.
    account_id: Option<AccountId>,
}

impl AccountDeleteTransaction {
    /// Get the account ID which should be deleted.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the account ID which should be deleted.
    pub fn account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(id);
        self
    }

    /// Get the account ID which will receive all remaining hbars.
    #[must_use]
    pub fn get_transfer_account_id(&self) -> Option<AccountId> {
        self.data().transfer_account_id
    }

    /// Sets the account ID which will receive all remaining hbars.
    pub fn transfer_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().transfer_account_id = Some(id);
        self
    }
}

impl TransactionData for AccountDeleteTransactionData {}

impl TransactionExecute for AccountDeleteTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { CryptoServiceClient::new(channel).crypto_delete(request).await })
    }
}

impl ValidateChecksums for AccountDeleteTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.transfer_account_id.validate_checksums(ledger_id)?;
        self.account_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for AccountDeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::CryptoDelete(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for AccountDeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::CryptoDelete(self.to_protobuf())
    }
}

impl From<AccountDeleteTransactionData> for AnyTransactionData {
    fn from(transaction: AccountDeleteTransactionData) -> Self {
        Self::AccountDelete(transaction)
    }
}

impl FromProtobuf<services::CryptoDeleteTransactionBody> for AccountDeleteTransactionData {
    fn from_protobuf(pb: services::CryptoDeleteTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            transfer_account_id: Option::from_protobuf(pb.transfer_account_id)?,
            account_id: Option::from_protobuf(pb.delete_account_id)?,
        })
    }
}

impl ToProtobuf for AccountDeleteTransactionData {
    type Protobuf = services::CryptoDeleteTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let account_id = self.account_id.to_protobuf();
        let transfer_account_id = self.transfer_account_id.to_protobuf();

        services::CryptoDeleteTransactionBody { transfer_account_id, delete_account_id: account_id }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::account::AccountDeleteTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountDeleteTransaction,
        AccountId,
        AnyTransaction,
    };

    const ACCOUNT_ID: AccountId = AccountId::new(0, 0, 5007);
    const TRANSFER_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 9);

    fn make_transaction() -> AccountDeleteTransaction {
        let mut tx = AccountDeleteTransaction::new_for_tests();

        tx.account_id(ACCOUNT_ID).transfer_account_id(TRANSFER_ACCOUNT_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            CryptoDelete(
                CryptoDeleteTransactionBody {
                    transfer_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    9,
                                ),
                            ),
                        },
                    ),
                    delete_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    5007,
                                ),
                            ),
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::CryptoDeleteTransactionBody {
            delete_account_id: Some(ACCOUNT_ID.to_protobuf()),
            transfer_account_id: Some(TRANSFER_ACCOUNT_ID.to_protobuf()),
        };

        let tx = AccountDeleteTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.account_id, Some(ACCOUNT_ID));
        assert_eq!(tx.transfer_account_id, Some(TRANSFER_ACCOUNT_ID));
    }

    #[test]
    fn get_set_account_id() {
        let mut tx = AccountDeleteTransaction::new();
        tx.account_id(ACCOUNT_ID);

        assert_eq!(tx.get_account_id(), Some(ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panics() {
        let mut tx = make_transaction();

        tx.account_id(ACCOUNT_ID);
    }

    #[test]
    fn get_set_transfer_account_id() {
        let mut tx = AccountDeleteTransaction::new();
        tx.transfer_account_id(TRANSFER_ACCOUNT_ID);

        assert_eq!(tx.get_transfer_account_id(), Some(TRANSFER_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_transfer_account_id_frozen_panics() {
        let mut tx = make_transaction();

        tx.transfer_account_id(TRANSFER_ACCOUNT_ID);
    }
}
// Filename: src/account/account_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use hedera_proto::services;

use crate::entity_id::{
    Checksum,
    PartialEntityId,
    ValidateChecksums,
};
use crate::ledger_id::RefLedgerId;
use crate::{
    Client,
    EntityId,
    Error,
    EvmAddress,
    FromProtobuf,
    PublicKey,
    ToProtobuf,
};

/// A unique identifier for a cryptocurrency account on Hiero.
#[derive(Copy, Hash, PartialEq, Eq, Clone)]
pub struct AccountId {
    /// A non-negative number identifying the shard containing this account.
    pub shard: u64,

    /// A non-negative number identifying the realm within the shard containing this account.
    pub realm: u64,

    /// A non-negative number identifying the entity within the realm containing this account.
    pub num: u64,

    /// An alias for `num` if the account was created from a public key directly.
    pub alias: Option<PublicKey>,

    /// The last 20 bytes of the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
    pub evm_address: Option<EvmAddress>,

    /// A checksum if the account ID was read from a user inputted string which inclueded a checksum
    pub checksum: Option<Checksum>,
}

impl AccountId {
    /// Create a new `AccountId`.
    pub const fn new(shard: u64, realm: u64, num: u64) -> Self {
        Self { shard, realm, num, alias: None, evm_address: None, checksum: None }
    }

    /// Create a new `AccountId` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`] if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`] if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Create an `AccountId` from a solidity address.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `address` cannot be parsed as a solidity address.
    pub fn from_solidity_address(address: &str) -> crate::Result<Self> {
        let EntityId { shard, realm, num, checksum } = EntityId::from_solidity_address(address)?;

        Ok(Self { shard, realm, num, alias: None, evm_address: None, checksum })
    }

    /// Create an `AccountId` from an evm address.
    ///
    /// Accepts "0x___" Ethereum public address.
    #[must_use]
    pub fn from_evm_address(address: &EvmAddress, shard: u64, realm: u64) -> Self {
        Self { shard, realm, num: 0, alias: None, evm_address: Some(*address), checksum: None }
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }

    /// Convert `self` into a solidity `address`.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `self.shard` is larger than `u32::MAX`.
    pub fn to_solidity_address(&self) -> crate::Result<String> {
        EntityId { shard: self.shard, realm: self.realm, num: self.num, checksum: None }
            .to_solidity_address()
    }

    /// Convert `self` to a string with a valid checksum.
    ///
    /// # Errors
    /// - [`Error::CannotCreateChecksum`] if self has an `alias` or `evm_address`.
    pub fn to_string_with_checksum(&self, client: &Client) -> Result<String, Error> {
        if self.alias.is_some() || self.evm_address.is_some() {
            Err(Error::CannotCreateChecksum)
        } else {
            Ok(EntityId::to_string_with_checksum(self.to_string(), client))
        }
    }

    /// Validates `self.checksum` (if it exists) for `client`.
    ///
    /// # Errors
    /// - [`Error::BadEntityId`] if there is a checksum, and the checksum is not valid for the client's `ledger_id`.
    pub fn validate_checksum(&self, client: &Client) -> crate::Result<()> {
        if self.alias.is_some() || self.evm_address.is_some() {
            Ok(())
        } else {
            EntityId::validate_checksum(self.shard, self.realm, self.num, self.checksum, client)
        }
    }
}

impl ValidateChecksums for AccountId {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        if self.alias.is_some() || self.evm_address.is_some() {
            Ok(())
        } else {
            EntityId::validate_checksum_for_ledger_id(
                self.shard,
                self.realm,
                self.num,
                self.checksum,
                ledger_id,
            )
        }
    }
}

impl Debug for AccountId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for AccountId {
    // allowed because `alias` would go before `shard` and `realm` and create a confusing reading experience:
    // `write!(f, "{}.{}.{alias}", self.shard, self.realm);`
    #[allow(clippy::uninlined_format_args)]
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        if let Some(alias) = &self.alias {
            write!(f, "{}.{}.{}", self.shard, self.realm, alias)
        } else if let Some(evm_address) = &self.evm_address {
            write!(f, "{evm_address}")
        } else {
            write!(f, "{}.{}.{}", self.shard, self.realm, self.num)
        }
    }
}

impl ToProtobuf for AccountId {
    type Protobuf = services::AccountId;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::AccountId {
            realm_num: self.realm as i64,
            shard_num: self.shard as i64,
            account: Some(match &self.alias {
                None => services::account_id::Account::AccountNum(self.num as i64),
                Some(alias) => services::account_id::Account::Alias(ToProtobuf::to_bytes(alias)),
            }),
        }
    }
}

impl FromProtobuf<services::AccountId> for AccountId {
    fn from_protobuf(pb: services::AccountId) -> crate::Result<Self> {
        let account = pb_getf!(pb, account)?;

        let (num, alias, evm_address) = match account {
            services::account_id::Account::AccountNum(num) => (num, None, None),
            services::account_id::Account::Alias(bytes) => {
                match <&EvmAddress>::try_from(bytes.as_slice()).ok() {
                    Some(evm_address) => (0, None, Some(*evm_address)),
                    None => (0, Some(FromProtobuf::from_bytes(&bytes)?), None),
                }
            }
        };

        Ok(Self {
            num: num as u64,
            alias,
            evm_address,
            shard: pb.shard_num as u64,
            realm: pb.realm_num as u64,
            checksum: None,
        })
    }
}

impl From<u64> for AccountId {
    fn from(num: u64) -> Self {
        Self { num, alias: None, evm_address: None, checksum: None, shard: 0, realm: 0 }
    }
}

impl From<PublicKey> for AccountId {
    fn from(alias: PublicKey) -> Self {
        Self { num: 0, shard: 0, realm: 0, evm_address: None, alias: Some(alias), checksum: None }
    }
}

impl FromStr for AccountId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // override the error message for better context.
        let partial = PartialEntityId::from_str(s)
        .map_err(|_| Error::basic_parse("expecting <shard>.<realm>.<num> (ex. `0.0.1001`) or <shard>.<realm>.<alias> (ex. `0.0.0a410c8fe4912e3652b61dd222b1b4d7773261537d7ebad59df6cd33622a693e"))?;

        match partial {
            PartialEntityId::ShortNum(it) => Ok(it.into()),
            PartialEntityId::LongNum(it) => Ok(it.into()),

            // 0x<evm_address>
            PartialEntityId::ShortOther(evm_address) => {
                Ok(Self::from_evm_address(&evm_address.parse()?, 0, 0))
            }

            // <shard>.<realm>.<alias>
            PartialEntityId::LongOther { shard, realm, last } => Ok(Self {
                shard,
                realm,
                num: 0,
                alias: Some(last.parse()?),
                evm_address: None,
                checksum: None,
            }),
        }
    }
}

impl From<EntityId> for AccountId {
    fn from(value: EntityId) -> Self {
        let EntityId { shard, realm, num, checksum } = value;
        Self { shard, realm, num, checksum, alias: None, evm_address: None }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use assert_matches::assert_matches;
    use hex_literal::hex;

    use crate::ethereum::EvmAddress;
    use crate::ledger_id::RefLedgerId;
    use crate::{
        AccountId,
        Client,
        ValidateChecksums,
    };

    #[test]
    fn parse() {
        let account_id: AccountId = "0.0.1001".parse().unwrap();

        assert_eq!(
            account_id,
            AccountId {
                shard: 0,
                realm: 0,
                num: 1001,
                alias: None,
                evm_address: None,
                checksum: None
            }
        );
    }

    #[test]
    fn to_from_bytes_roundtrip() {
        let account_id = AccountId {
            shard: 0,
            realm: 0,
            num: 1001,
            alias: None,
            evm_address: None,
            checksum: None,
        };

        assert_eq!(account_id, AccountId::from_bytes(&account_id.to_bytes()).unwrap());
    }

    #[test]
    fn from_evm_address_string() {
        let evm_address = hex!("302a300506032b6570032100114e6abc371b82da");
        assert_eq!(
            AccountId::from_str("0x302a300506032b6570032100114e6abc371b82da").unwrap(),
            AccountId {
                shard: 0,
                realm: 0,
                num: 0,
                alias: None,
                evm_address: Some(EvmAddress(evm_address)),
                checksum: None
            }
        )
    }

    #[test]
    fn to_evm_address_string() {
        assert_eq!(
            &AccountId {
                shard: 0,
                realm: 0,
                num: 0,
                alias: None,
                evm_address: Some(EvmAddress(hex!("302a300506032b6570032100114e6abc371b82da"))),
                checksum: None
            }
            .to_string(),
            "0x302a300506032b6570032100114e6abc371b82da"
        )
    }

    #[test]
    fn good_checksum_on_mainnet() {
        let account_id = AccountId::from_str("0.0.123-vfmkw").unwrap();

        ValidateChecksums::validate_checksums(&account_id, RefLedgerId::MAINNET).unwrap();
    }

    #[test]
    fn good_checksum_on_testnet() {
        let account_id = AccountId::from_str("0.0.123-esxsf").unwrap();

        ValidateChecksums::validate_checksums(&account_id, RefLedgerId::TESTNET).unwrap();
    }

    #[test]
    fn good_checksum_on_previewnet() {
        let account_id = AccountId::from_str("0.0.123-ogizo").unwrap();

        ValidateChecksums::validate_checksums(&account_id, RefLedgerId::PREVIEWNET).unwrap();
    }

    #[tokio::test]
    async fn to_string_with_checksum() {
        assert_eq!(
            AccountId::from_str("0.0.123")
                .unwrap()
                .to_string_with_checksum(&Client::for_testnet())
                .unwrap(),
            "0.0.123-esxsf"
        );
    }

    #[tokio::test]
    async fn bad_checksum_on_previewnet() {
        let client = Client::for_previewnet();
        let id = AccountId::from_str("0.0.123-ntjli").unwrap();

        assert_matches!(
            id.validate_checksum(&client),
            Err(crate::Error::BadEntityId {
                shard: 0,
                realm: 0,
                num: 123,
                present_checksum: _,
                expected_checksum: _
            })
        );
    }

    #[test]
    fn malformed_id_fails() {
        assert_matches!(AccountId::from_str("0.0."), Err(crate::Error::BasicParse(_)));
    }

    #[test]
    fn malformed_checksum() {
        assert_matches!(AccountId::from_str("0.0.123-ntjl"), Err(crate::Error::BasicParse(_)));
    }

    #[test]
    fn malformed_checksum_2() {
        assert_matches!(AccountId::from_str("0.0.123-ntjl1"), Err(crate::Error::BasicParse(_)));
    }

    #[test]
    fn malformed_alias() {
        assert_matches!(AccountId::from_str("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf777"), Err(crate::Error::KeyParse(_)));
    }
    #[test]
    fn malformed_alias_2() {
        assert_matches!(AccountId::from_str("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf777g"), Err(crate::Error::KeyParse(_)));
    }
    #[test]
    fn malformed_alias_key_3() {
        assert_matches!(AccountId::from_str("0.0.303a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777"), Err(crate::Error::KeyParse(_)));
    }

    #[test]
    fn from_string_alias_key() {
        expect_test::expect!["0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777"]
        .assert_eq(&AccountId::from_str("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777").unwrap().to_string())
    }

    #[test]
    fn from_string_evm_address() {
        expect_test::expect!["0x302a300506032b6570032100114e6abc371b82da"].assert_eq(
            &AccountId::from_str("0x302a300506032b6570032100114e6abc371b82da").unwrap().to_string(),
        );
    }

    #[test]
    fn from_solidity_address() {
        expect_test::expect!["0.0.5005"].assert_eq(
            &AccountId::from_solidity_address("000000000000000000000000000000000000138D")
                .unwrap()
                .to_string(),
        );
    }

    #[test]
    fn from_solidity_address_0x() {
        expect_test::expect!["0.0.5005"].assert_eq(
            &AccountId::from_solidity_address("0x000000000000000000000000000000000000138D")
                .unwrap()
                .to_string(),
        );
    }

    #[test]
    fn from_bytes() {
        let bytes = AccountId {
            shard: 0,
            realm: 0,
            num: 5005,
            alias: None,
            evm_address: None,
            checksum: None,
        }
        .to_bytes();

        expect_test::expect!["0.0.5005"]
            .assert_eq(&AccountId::from_bytes(&bytes).unwrap().to_string());
    }

    #[test]
    fn from_bytes_alias() {
        let bytes = AccountId::from_str("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777").unwrap().to_bytes();

        expect_test::expect!["0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777"].assert_eq(&AccountId::from_bytes(&bytes).unwrap().to_string());
    }

    #[test]
    fn from_bytes_evm_address() {
        let bytes =
            AccountId::from_str("0x302a300506032b6570032100114e6abc371b82da").unwrap().to_bytes();
        expect_test::expect!["0.0.0"]
            .assert_eq(&AccountId::from_bytes(&bytes).unwrap().to_string());
    }

    #[test]
    fn to_solidity_address() {
        let id = AccountId {
            shard: 0,
            realm: 0,
            num: 5005,
            alias: None,
            evm_address: None,
            checksum: None,
        };

        expect_test::expect!["000000000000000000000000000000000000138d"]
            .assert_eq(&id.to_solidity_address().unwrap());
    }

    #[test]
    fn from_evm_address() {
        let evm_address =
            EvmAddress::from_str("0x302a300506032b6570032100114e6abc371b82da").unwrap();

        let id = AccountId::from_evm_address(&evm_address, 0, 0);

        expect_test::expect!["0x302a300506032b6570032100114e6abc371b82da"]
            .assert_eq(&id.to_string());
    }
}
// Filename: src/account/account_info.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use prost::Message;
use time::{
    Duration,
    OffsetDateTime,
};

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    FromProtobuf,
    Hbar,
    Key,
    LedgerId,
    PublicKey,
    StakingInfo,
    Tinybar,
};

/// Response from [`AccountInfoQuery`][crate::AccountInfoQuery].
#[derive(Debug, Clone)]
pub struct AccountInfo {
    /// The account that is being referenced.
    pub account_id: AccountId,

    /// The Contract Account ID comprising of both the contract instance and the cryptocurrency
    /// account owned by the contract instance, in the format used by Solidity.
    pub contract_account_id: String,

    /// If true, then this account has been deleted, it will disappear when it expires, and all
    /// transactions for it will fail except the transaction to extend its expiration date.
    pub is_deleted: bool,

    /// The Account ID of the account to which this is proxy staked.
    ///
    /// If `proxy_account_id` is `None`, an invalid account, or an account that isn't a node,
    /// then this account is automatically proxy staked to a node chosen by the network,
    /// but without earning payments.
    ///
    /// If the `proxy_account_id` account refuses to accept proxy staking, or if it is not currently
    /// running a node, then it will behave as if `proxy_account_id` is `None`.
    #[deprecated]
    pub proxy_account_id: Option<AccountId>,

    /// The total number of hbars proxy staked to this account.
    pub proxy_received: Hbar,

    /// The key for the account, which must sign in order to transfer out, or to modify the
    /// account in any way other than extending its expiration date.
    pub key: Key,

    /// Current balance of the referenced account.
    pub balance: Hbar,

    /// The threshold amount for which an account record is created (and this account
    /// charged for them) for any send/withdraw transaction.
    #[deprecated]
    pub send_record_threshold: Hbar,

    /// The threshold amount for which an account record is created
    /// (and this account charged for them) for any transaction above this amount.
    #[deprecated]
    pub receive_record_threshold: Hbar,

    /// If true, no transaction can transfer to this account unless signed by
    /// this account's key.
    pub is_receiver_signature_required: bool,

    /// The time at which this account is set to expire.
    pub expiration_time: Option<OffsetDateTime>,

    /// The duration for expiration time will extend every this many seconds.
    pub auto_renew_period: Option<Duration>,

    /// The memo associated with the account.
    pub account_memo: String,

    /// The number of NFTs owned by this account
    pub owned_nfts: u64,

    /// The maximum number of tokens that an Account can be implicitly associated with.
    pub max_automatic_token_associations: u32,

    /// The alias of this account.
    pub alias_key: Option<PublicKey>,

    /// The ethereum transaction nonce associated with this account.
    pub ethereum_nonce: u64,

    /// The ledger ID the response was returned from.
    pub ledger_id: LedgerId,

    /// Staking metadata for this account.
    pub staking: Option<StakingInfo>,
}

impl AccountInfo {
    /// Create a new `AccountInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::crypto_get_info_response::AccountInfo>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        #[allow(deprecated)]
        services::crypto_get_info_response::AccountInfo {
            account_id: Some(self.account_id.to_protobuf()),
            contract_account_id: self.contract_account_id.clone(),
            deleted: self.is_deleted,
            proxy_received: self.proxy_received.to_tinybars(),
            key: Some(self.key.to_protobuf()),
            balance: self.balance.to_tinybars() as u64,
            receiver_sig_required: self.is_receiver_signature_required,
            expiration_time: self.expiration_time.to_protobuf(),
            auto_renew_period: self.auto_renew_period.to_protobuf(),
            memo: self.account_memo.clone(),
            owned_nfts: self.owned_nfts as i64,
            max_automatic_token_associations: self.max_automatic_token_associations as i32,
            alias: self.alias_key.as_ref().map(ToProtobuf::to_bytes).unwrap_or_default(),
            ledger_id: self.ledger_id.to_bytes(),
            ethereum_nonce: self.ethereum_nonce as i64,
            staking_info: self.staking.to_protobuf(),

            // implemented deprecated fields
            proxy_account_id: self.proxy_account_id.to_protobuf(),
            generate_receive_record_threshold: self.receive_record_threshold.to_tinybars() as u64,
            generate_send_record_threshold: self.send_record_threshold.to_tinybars() as u64,

            // unimplemented fields
            live_hashes: Vec::default(),
            token_relationships: Vec::default(),
        }
        .encode_to_vec()
    }
}

impl FromProtobuf<services::response::Response> for AccountInfo {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let response = pb_getv!(pb, CryptoGetInfo, services::response::Response);
        let info = pb_getf!(response, account_info)?;
        Self::from_protobuf(info)
    }
}

impl FromProtobuf<services::crypto_get_info_response::AccountInfo> for AccountInfo {
    fn from_protobuf(pb: services::crypto_get_info_response::AccountInfo) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let key = pb_getf!(pb, key)?;
        let account_id = pb_getf!(pb, account_id)?;
        let alias_key = PublicKey::from_alias_bytes(&pb.alias)?;
        let ledger_id = LedgerId::from_bytes(pb.ledger_id);
        let staking = Option::from_protobuf(pb.staking_info)?;

        #[allow(deprecated)]
        Ok(Self {
            ledger_id,
            staking,
            account_id: AccountId::from_protobuf(account_id)?,
            contract_account_id: pb.contract_account_id,
            is_deleted: pb.deleted,
            proxy_received: Hbar::from_tinybars(pb.proxy_received),
            key: Key::from_protobuf(key)?,
            balance: Hbar::from_tinybars(pb.balance as Tinybar),
            expiration_time: pb.expiration_time.map(Into::into),
            auto_renew_period: pb.auto_renew_period.map(Into::into),
            account_memo: pb.memo,
            owned_nfts: pb.owned_nfts as u64,
            max_automatic_token_associations: pb.max_automatic_token_associations as u32,
            alias_key,
            ethereum_nonce: pb.ethereum_nonce as u64,
            is_receiver_signature_required: pb.receiver_sig_required,

            // deprecated fields
            proxy_account_id: Option::from_protobuf(pb.proxy_account_id)?,
            send_record_threshold: Hbar::from_tinybars(pb.generate_send_record_threshold as i64),
            receive_record_threshold: Hbar::from_tinybars(
                pb.generate_receive_record_threshold as i64,
            ),
        })
    }
}
// Filename: src/account/account_info_flow.rs
// SPDX-License-Identifier: Apache-2.0

use crate::transaction::TransactionExecute;
use crate::{
    AccountId,
    AccountInfoQuery,
    Client,
    Error,
    Key,
    PublicKey,
    Transaction,
};

async fn query_pk(client: &Client, account_id: AccountId) -> crate::Result<PublicKey> {
    let key = AccountInfoQuery::new().account_id(account_id).execute(client).await?.key;

    match key {
        Key::Single(it) => Ok(it),
        _ => {
            Err(Error::signature_verify("`{account_id}`: unsupported key kind: {key:?}".to_owned()))
        }
    }
}

/// Verify the `signature` for `msg` via the given account's public key.
///
/// # Errors
/// - [`Error::SignatureVerify`] if the signature algorithm doesn't match the account's public key.
/// - [`Error::SignatureVerify`] if the signature is invalid for the account's public key.
/// - See [`AccountInfoQuery::execute`]
pub async fn verify_signature(
    client: &Client,
    account_id: AccountId,
    msg: &[u8],
    signature: &[u8],
) -> crate::Result<()> {
    let key = query_pk(client, account_id).await?;

    key.verify(msg, signature)
}

/// Returns `Ok(())` if the given account's public key has signed the given transaction.
/// # Errors
/// - [`Error::SignatureVerify`] if the private key associated with the account's public key did _not_ sign this transaction,
///   or the signature associated was invalid.
/// - See [`AccountInfoQuery::execute`]
pub async fn verify_transaction_signature<D: TransactionExecute>(
    client: &Client,
    account_id: AccountId,
    transaction: &mut Transaction<D>,
) -> crate::Result<()> {
    let key = query_pk(client, account_id).await?;

    key.verify_transaction(transaction)
}
// Filename: src/account/account_info_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use tonic::transport::Channel;

use crate::account::AccountInfo;
use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Query,
    ToProtobuf,
    ValidateChecksums,
};

/// Get all the information about an account, including the balance.
///
/// This does not get the list of account records.
///
pub type AccountInfoQuery = Query<AccountInfoQueryData>;

#[derive(Default, Clone, Debug)]
pub struct AccountInfoQueryData {
    account_id: Option<AccountId>,
}

impl From<AccountInfoQueryData> for AnyQueryData {
    #[inline]
    fn from(data: AccountInfoQueryData) -> Self {
        Self::AccountInfo(data)
    }
}

impl AccountInfoQuery {
    /// Gets the account ID for which information is requested.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data.account_id
    }

    /// Sets the account ID for which information is requested.
    pub fn account_id(&mut self, id: AccountId) -> &mut Self {
        self.data.account_id = Some(id);
        self
    }
}

impl ToQueryProtobuf for AccountInfoQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let account_id = self.account_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::CryptoGetInfo(services::CryptoGetInfoQuery {
                account_id,
                header: Some(header),
            })),
        }
    }
}

impl QueryExecute for AccountInfoQueryData {
    type Response = AccountInfo;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { CryptoServiceClient::new(channel).get_account_info(request).await })
    }
}

impl ValidateChecksums for AccountInfoQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        AccountId,
        AccountInfoQuery,
        Hbar,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    CryptoGetInfo(
                        CryptoGetInfoQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            account_id: Some(
                                AccountId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    account: Some(
                                        AccountNum(
                                            5005,
                                        ),
                                    ),
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &AccountInfoQuery::new()
                .account_id(AccountId {
                    shard: 0,
                    realm: 0,
                    num: 5005,
                    alias: None,
                    evm_address: None,
                    checksum: None,
                })
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        );
    }

    #[test]
    fn get_set_account_id() {
        let mut query = AccountInfoQuery::new();
        query.account_id(AccountId::new(0, 0, 5005));

        assert_eq!(query.get_account_id(), Some(AccountId::new(0, 0, 5005)));
    }
}
// Filename: src/account/account_records_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    FromProtobuf,
    Query,
    ToProtobuf,
    TransactionRecord,
    ValidateChecksums,
};

/// Get all the records for an account for any transfers into it and out of it,
/// that were above the threshold, during the last 25 hours.
pub type AccountRecordsQuery = Query<AccountRecordsQueryData>;

#[derive(Debug, Clone, Default)]
pub struct AccountRecordsQueryData {
    account_id: Option<AccountId>,
}

impl From<AccountRecordsQueryData> for AnyQueryData {
    #[inline]
    fn from(data: AccountRecordsQueryData) -> Self {
        Self::AccountRecords(data)
    }
}

impl AccountRecordsQuery {
    /// Gets the account ID for which the records should be retrieved.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data.account_id
    }

    /// Sets the account ID for which the records should be retrieved.
    pub fn account_id(&mut self, id: AccountId) -> &mut Self {
        self.data.account_id = Some(id);
        self
    }
}

impl ToQueryProtobuf for AccountRecordsQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let account_id = self.account_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::CryptoGetAccountRecords(
                services::CryptoGetAccountRecordsQuery { account_id, header: Some(header) },
            )),
        }
    }
}

impl QueryExecute for AccountRecordsQueryData {
    type Response = Vec<TransactionRecord>;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { CryptoServiceClient::new(channel).get_account_records(request).await })
    }
}

impl ValidateChecksums for AccountRecordsQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)
    }
}

impl FromProtobuf<services::response::Response> for Vec<TransactionRecord> {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let response = pb_getv!(pb, CryptoGetAccountRecords, services::response::Response);

        Vec::<TransactionRecord>::from_protobuf(response.records)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        AccountId,
        AccountRecordsQuery,
        Hbar,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    CryptoGetAccountRecords(
                        CryptoGetAccountRecordsQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            account_id: Some(
                                AccountId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    account: Some(
                                        AccountNum(
                                            5005,
                                        ),
                                    ),
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &AccountRecordsQuery::new()
                .account_id(crate::AccountId {
                    shard: 0,
                    realm: 0,
                    num: 5005,
                    alias: None,
                    evm_address: None,
                    checksum: None,
                })
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        );
    }

    #[test]
    fn get_set_account_id() {
        let mut query = AccountRecordsQuery::new();
        query.account_id(AccountId::new(0, 0, 5005));

        assert_eq!(query.get_account_id(), Some(AccountId::new(0, 0, 5005)));
    }
}
// Filename: src/account/account_update_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use time::{
    Duration,
    OffsetDateTime,
};
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::staked_id::StakedId;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Key,
    Transaction,
    ValidateChecksums,
};

/// Change properties for the given account.
///
/// Any null field is ignored (left unchanged). This
/// transaction must be signed by the existing key for this account. If
/// the transaction is changing the key field, then the transaction must be
/// signed by both the old key (from before the change) and the new key.
///
pub type AccountUpdateTransaction = Transaction<AccountUpdateTransactionData>;

// TODO: shard_id: Option<ShardId>
// TODO: realm_id: Option<RealmId>
// TODO: new_realm_admin_key: Option<Key>,

#[derive(Debug, Clone, Default)]
pub struct AccountUpdateTransactionData {
    /// The account ID which is being updated in this transaction.
    account_id: Option<AccountId>,

    /// The new key.
    key: Option<Key>,

    /// If true, this account's key must sign any transaction depositing into this account.
    receiver_signature_required: Option<bool>,

    /// The account is charged to extend its expiration date every this many seconds.
    auto_renew_period: Option<Duration>,

    auto_renew_account_id: Option<AccountId>,

    /// The ID of the account to which this account is proxy staked.
    ///
    /// If `proxy_account_id` is `None`, or is an invalid account, or is an account
    /// that isn't a node, then this account is automatically proxy staked to
    /// a node chosen by the network, but without earning payments.
    ///
    /// If the `proxy_account_id` account refuses to accept proxy staking, or
    /// if it is not currently running a node, then it
    /// will behave as if `proxy_account_id` was `None`.
    #[deprecated]
    proxy_account_id: Option<AccountId>,

    /// The new expiration time to extend to (ignored if equal to or before the current one).
    expiration_time: Option<OffsetDateTime>,

    /// The memo associated with the account.
    account_memo: Option<String>,

    /// The maximum number of tokens that an Account can be implicitly associated with.
    ///
    /// Defaults to `0`. Allows up to a maximum value of `1000`.
    /// If the value is set to `-1`, unlimited automatic token associations are allowed.
    max_automatic_token_associations: Option<i32>,

    /// ID of the account or node to which this account is staking, if any.
    staked_id: Option<StakedId>,

    /// If true, the account declines receiving a staking reward. The default value is false.
    decline_staking_reward: Option<bool>,
}

impl AccountUpdateTransaction {
    /// Returns the ID for the account that is being updated.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the ID for the account that is being updated.
    pub fn account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(id);
        self
    }

    /// Gets the new expiration time to extend to (ignored if equal to or before the current one).
    #[must_use]
    pub fn get_expiration_time(&self) -> Option<OffsetDateTime> {
        self.data().expiration_time
    }

    /// Sets the new expiration time to extend to (ignored if equal to or before the current one).
    pub fn expiration_time(&mut self, at: OffsetDateTime) -> &mut Self {
        self.data_mut().expiration_time = Some(at);
        self
    }

    /// Returns the key that the account will be updated to.
    #[must_use]
    pub fn get_key(&self) -> Option<&Key> {
        self.data().key.as_ref()
    }

    /// Sets the key for this account.
    pub fn key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().key = Some(key.into());
        self
    }

    /// If true, this account's key must sign any transaction depositing hbar into this account.
    #[must_use]
    pub fn get_receiver_signature_required(&self) -> Option<bool> {
        self.data().receiver_signature_required
    }

    /// Set to true to require this account to sign any transfer of hbars to this account.
    pub fn receiver_signature_required(&mut self, required: bool) -> &mut Self {
        self.data_mut().receiver_signature_required = Some(required);
        self
    }

    /// Gets the ID of the account to which this account will be updated to be proxy staked to.
    #[deprecated]
    #[allow(deprecated)]
    #[must_use]
    pub fn get_proxy_account_id(&self) -> Option<AccountId> {
        self.data().proxy_account_id
    }

    /// Sets the proxy account ID for this account.
    ///
    /// If `proxy_account_id` is `None`, or is an invalid account, or is an account
    /// that isn't a node, then this account is automatically proxy staked to
    /// a node chosen by the network, but without earning payments.
    ///
    /// If the `proxy_account_id` account refuses to accept proxy staking, or
    /// if it is not currently running a node, then it
    /// will behave as if `proxy_account_id` was `None`.
    #[deprecated]
    #[allow(deprecated)]
    pub fn proxy_account_id(&mut self, proxy_account_id: AccountId) -> &mut Self {
        self.data_mut().proxy_account_id = Some(proxy_account_id);
        self
    }

    /// Returns the new auto renew period.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.data().auto_renew_period
    }

    /// Sets the auto renew period for this account.
    pub fn auto_renew_period(&mut self, period: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = Some(period);
        self
    }

    /// Returns the new auto renew account id.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the account to be used at this account's expiration time to extend the
    /// life of the account.  If `None`, this account pays for its own auto renewal fee.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    pub fn auto_renew_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(id);
        self
    }

    /// Returns the memo associated with the account.
    #[must_use]
    pub fn get_account_memo(&self) -> Option<&str> {
        self.data().account_memo.as_deref()
    }

    /// Sets the memo associated with the account.
    pub fn account_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().account_memo = Some(memo.into());
        self
    }

    /// Returns the maximum number of tokens that an Account can be implicitly associated with.
    #[must_use]
    pub fn get_max_automatic_token_associations(&self) -> Option<i32> {
        self.data().max_automatic_token_associations
    }

    /// Sets the maximum number of tokens that an Account can be implicitly associated with.
    ///
    pub fn max_automatic_token_associations(&mut self, amount: i32) -> &mut Self {
        self.data_mut().max_automatic_token_associations = Some(amount);
        self
    }

    /// Returns the ID of the account to which this account is staking.
    /// This is mutually exclusive with `staked_node_id`.
    #[must_use]
    pub fn get_staked_account_id(&self) -> Option<AccountId> {
        self.data().staked_id.and_then(StakedId::to_account_id)
    }

    /// Sets the ID of the account to which this account is staking.
    /// This is mutually exclusive with `staked_node_id`.
    pub fn staked_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().staked_id = Some(id.into());
        self
    }

    /// Clears the account's staked account ID.
    pub fn clear_staked_account_id(&mut self) -> &mut Self {
        self.staked_account_id(AccountId::from(0))
    }

    /// Returns the ID of the node to which this account is staking.
    /// This is mutually exclusive with `staked_account_id`.
    #[must_use]
    pub fn get_staked_node_id(&self) -> Option<u64> {
        self.data().staked_id.and_then(StakedId::to_node_id)
    }

    /// Sets the ID of the node to which this account is staking.
    /// This is mutually exclusive with `staked_account_id`.
    pub fn staked_node_id(&mut self, id: u64) -> &mut Self {
        self.data_mut().staked_id = Some(id.into());
        self
    }

    /// Clears the account's staked node ID.
    pub fn clear_staked_node_id(&mut self) -> &mut Self {
        self.staked_node_id(u64::MAX)
    }

    /// Returns `true` if this account should decline receiving a staking reward,
    /// `false` if it should _not_,
    /// and `None` if the value should remain unchanged.
    #[must_use]
    pub fn get_decline_staking_reward(&self) -> Option<bool> {
        self.data().decline_staking_reward
    }

    /// If set to true, the account declines receiving a staking reward. The default value is false.
    pub fn decline_staking_reward(&mut self, decline: bool) -> &mut Self {
        self.data_mut().decline_staking_reward = Some(decline);
        self
    }
}

impl TransactionData for AccountUpdateTransactionData {}

impl TransactionExecute for AccountUpdateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { CryptoServiceClient::new(channel).update_account(request).await })
    }
}

impl ValidateChecksums for AccountUpdateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)?;
        self.staked_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for AccountUpdateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::CryptoUpdateAccount(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for AccountUpdateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::CryptoUpdateAccount(self.to_protobuf())
    }
}

impl From<AccountUpdateTransactionData> for AnyTransactionData {
    fn from(transaction: AccountUpdateTransactionData) -> Self {
        Self::AccountUpdate(transaction)
    }
}

impl FromProtobuf<services::CryptoUpdateTransactionBody> for AccountUpdateTransactionData {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::CryptoUpdateTransactionBody) -> crate::Result<Self> {
        use services::crypto_update_transaction_body::ReceiverSigRequiredField;

        let receiver_signature_required = pb.receiver_sig_required_field.map(|it| match it {
            ReceiverSigRequiredField::ReceiverSigRequired(it)
            | ReceiverSigRequiredField::ReceiverSigRequiredWrapper(it) => it,
        });

        Ok(Self {
            account_id: Option::from_protobuf(pb.account_id_to_update)?,
            key: Option::from_protobuf(pb.key)?,
            receiver_signature_required,
            auto_renew_period: pb.auto_renew_period.map(Into::into),
            auto_renew_account_id: None,
            proxy_account_id: Option::from_protobuf(pb.proxy_account_id)?,
            expiration_time: pb.expiration_time.map(Into::into),
            account_memo: pb.memo,
            max_automatic_token_associations: pb.max_automatic_token_associations,
            staked_id: Option::from_protobuf(pb.staked_id)?,
            decline_staking_reward: pb.decline_reward,
        })
    }
}

impl ToProtobuf for AccountUpdateTransactionData {
    type Protobuf = services::CryptoUpdateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let account_id = self.account_id.to_protobuf();
        let key = self.key.to_protobuf();
        let auto_renew_period = self.auto_renew_period.to_protobuf();
        let expiration_time = self.expiration_time.to_protobuf();

        let receiver_signature_required = self.receiver_signature_required.map(|required| {
            services::crypto_update_transaction_body::ReceiverSigRequiredField::ReceiverSigRequiredWrapper(required)
        });

        let staked_id = self.staked_id.map(|id| match id {
            StakedId::NodeId(id) => {
                services::crypto_update_transaction_body::StakedId::StakedNodeId(id as i64)
            }
            StakedId::AccountId(id) => {
                services::crypto_update_transaction_body::StakedId::StakedAccountId(
                    id.to_protobuf(),
                )
            }
        });

        #[allow(deprecated)]
        services::CryptoUpdateTransactionBody {
            account_id_to_update: account_id,
            key,
            proxy_account_id: self.proxy_account_id.to_protobuf(),
            proxy_fraction: 0,
            auto_renew_period,
            expiration_time,
            memo: self.account_memo.clone(),
            max_automatic_token_associations: self.max_automatic_token_associations.map(Into::into),
            decline_reward: self.decline_staking_reward,
            send_record_threshold_field: None,
            receive_record_threshold_field: None,
            receiver_sig_required_field: receiver_signature_required,
            staked_id,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use time::{
        Duration,
        OffsetDateTime,
    };

    use crate::account::AccountUpdateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::staked_id::StakedId;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
    };
    use crate::{
        AccountId,
        AccountUpdateTransaction,
        AnyTransaction,
        PublicKey,
    };

    fn key() -> PublicKey {
        unused_private_key().public_key()
    }

    const ACCOUNT_ID: AccountId = AccountId::new(0, 0, 2002);
    const PROXY_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 1001);
    const AUTO_RENEW_PERIOD: Duration = Duration::hours(10);
    const EXPIRATION_TIME: OffsetDateTime = match OffsetDateTime::from_unix_timestamp(1554158543) {
        Ok(it) => it,
        Err(_) => panic!("Panic in `const` unwrap"),
    };

    const RECEIVER_SIGNATURE_REQUIRED: bool = false;
    const MAX_AUTOMATIC_TOKEN_ASSOCIATIONS: i32 = 100;
    const ACCOUNT_MEMO: &str = "Some memo";
    const STAKED_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 3);
    const STAKED_NODE_ID: u64 = 4;

    #[allow(deprecated)]
    fn make_transaction() -> AccountUpdateTransaction {
        let mut tx = AccountUpdateTransaction::new_for_tests();

        tx.key(key())
            .account_id(ACCOUNT_ID)
            .proxy_account_id(PROXY_ACCOUNT_ID)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .expiration_time(EXPIRATION_TIME)
            .receiver_signature_required(RECEIVER_SIGNATURE_REQUIRED)
            .max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
            .account_memo(ACCOUNT_MEMO)
            .staked_account_id(STAKED_ACCOUNT_ID)
            .freeze()
            .unwrap();

        return tx;
    }

    #[allow(deprecated)]
    fn make_transaction2() -> AccountUpdateTransaction {
        let mut tx = AccountUpdateTransaction::new_for_tests();

        tx.key(key())
            .account_id(ACCOUNT_ID)
            .proxy_account_id(PROXY_ACCOUNT_ID)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .expiration_time(EXPIRATION_TIME)
            .receiver_signature_required(RECEIVER_SIGNATURE_REQUIRED)
            .max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
            .account_memo(ACCOUNT_MEMO)
            .staked_node_id(STAKED_NODE_ID)
            .freeze()
            .unwrap();

        return tx;
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            CryptoUpdateAccount(
                CryptoUpdateTransactionBody {
                    account_id_to_update: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    2002,
                                ),
                            ),
                        },
                    ),
                    key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    proxy_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    1001,
                                ),
                            ),
                        },
                    ),
                    proxy_fraction: 0,
                    auto_renew_period: Some(
                        Duration {
                            seconds: 36000,
                        },
                    ),
                    expiration_time: Some(
                        Timestamp {
                            seconds: 1554158543,
                            nanos: 0,
                        },
                    ),
                    memo: Some(
                        "Some memo",
                    ),
                    max_automatic_token_associations: Some(
                        100,
                    ),
                    decline_reward: None,
                    send_record_threshold_field: None,
                    receive_record_threshold_field: None,
                    receiver_sig_required_field: Some(
                        ReceiverSigRequiredWrapper(
                            false,
                        ),
                    ),
                    staked_id: Some(
                        StakedAccountId(
                            AccountId {
                                shard_num: 0,
                                realm_num: 0,
                                account: Some(
                                    AccountNum(
                                        3,
                                    ),
                                ),
                            },
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn serialize2() {
        let tx = make_transaction2();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            CryptoUpdateAccount(
                CryptoUpdateTransactionBody {
                    account_id_to_update: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    2002,
                                ),
                            ),
                        },
                    ),
                    key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    proxy_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    1001,
                                ),
                            ),
                        },
                    ),
                    proxy_fraction: 0,
                    auto_renew_period: Some(
                        Duration {
                            seconds: 36000,
                        },
                    ),
                    expiration_time: Some(
                        Timestamp {
                            seconds: 1554158543,
                            nanos: 0,
                        },
                    ),
                    memo: Some(
                        "Some memo",
                    ),
                    max_automatic_token_associations: Some(
                        100,
                    ),
                    decline_reward: None,
                    send_record_threshold_field: None,
                    receive_record_threshold_field: None,
                    receiver_sig_required_field: Some(
                        ReceiverSigRequiredWrapper(
                            false,
                        ),
                    ),
                    staked_id: Some(
                        StakedNodeId(
                            4,
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes2() {
        let tx = make_transaction2();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        #[allow(deprecated)]
        let tx = services::CryptoUpdateTransactionBody {
            account_id_to_update: Some(ACCOUNT_ID.to_protobuf()),
            key: Some(key().to_protobuf()),
            proxy_account_id: Some(PROXY_ACCOUNT_ID.to_protobuf()),
            send_record_threshold_field: None,
            receive_record_threshold_field: None,
            receiver_sig_required_field: Some(services::crypto_update_transaction_body::ReceiverSigRequiredField::ReceiverSigRequiredWrapper(RECEIVER_SIGNATURE_REQUIRED)),
            auto_renew_period: Some(AUTO_RENEW_PERIOD.to_protobuf()),
            memo: Some(ACCOUNT_MEMO.to_owned()),
            max_automatic_token_associations: Some(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS as i32),
            decline_reward: None,
            staked_id: Some(services::crypto_update_transaction_body::StakedId::StakedAccountId(
                STAKED_ACCOUNT_ID.to_protobuf(),
            )),
            proxy_fraction: 0,
            expiration_time: Some(EXPIRATION_TIME.to_protobuf()),
        };

        let tx = AccountUpdateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.account_id, Some(ACCOUNT_ID));
        #[allow(deprecated)]
        {
            assert_eq!(tx.proxy_account_id, Some(PROXY_ACCOUNT_ID));
        }
        assert_eq!(tx.auto_renew_period, Some(AUTO_RENEW_PERIOD));
        assert_eq!(tx.expiration_time, Some(EXPIRATION_TIME));
        assert_eq!(tx.receiver_signature_required, Some(RECEIVER_SIGNATURE_REQUIRED));
        assert_eq!(tx.max_automatic_token_associations, Some(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS));
        assert_eq!(tx.account_memo, Some(ACCOUNT_MEMO.to_owned()));
        assert_eq!(tx.staked_id.and_then(StakedId::to_account_id), Some(STAKED_ACCOUNT_ID));
    }

    #[test]
    fn get_set_account_id() {
        let mut tx = AccountUpdateTransaction::new();
        tx.account_id(ACCOUNT_ID);

        assert_eq!(tx.get_account_id(), Some(ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panics() {
        let mut tx = make_transaction();
        tx.account_id(ACCOUNT_ID);
    }

    #[test]
    #[allow(deprecated)]
    fn get_set_proxy_account_id() {
        let mut tx = AccountUpdateTransaction::new();
        tx.proxy_account_id(PROXY_ACCOUNT_ID);

        assert_eq!(tx.get_proxy_account_id(), Some(PROXY_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    #[allow(deprecated)]
    fn get_set_proxy_account_id_frozen_panics() {
        let mut tx = make_transaction();
        tx.proxy_account_id(PROXY_ACCOUNT_ID);
    }

    #[test]
    fn get_set_auto_renew_period() {
        let mut tx = AccountUpdateTransaction::new();
        tx.auto_renew_period(AUTO_RENEW_PERIOD);

        assert_eq!(tx.get_auto_renew_period(), Some(AUTO_RENEW_PERIOD));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_period_frozen_panics() {
        let mut tx = make_transaction();
        tx.auto_renew_period(AUTO_RENEW_PERIOD);
    }

    #[test]
    fn get_set_expiration_time() {
        let mut tx = AccountUpdateTransaction::new();
        tx.expiration_time(EXPIRATION_TIME);

        assert_eq!(tx.get_expiration_time(), Some(EXPIRATION_TIME));
    }

    #[test]
    #[should_panic]
    fn get_set_expiration_time_frozen_panics() {
        let mut tx = make_transaction();
        tx.expiration_time(EXPIRATION_TIME);
    }

    #[test]
    fn get_set_receiver_signature_required() {
        let mut tx = AccountUpdateTransaction::new();
        tx.receiver_signature_required(RECEIVER_SIGNATURE_REQUIRED);

        assert_eq!(tx.get_receiver_signature_required(), Some(RECEIVER_SIGNATURE_REQUIRED));
    }

    #[test]
    #[should_panic]
    fn get_set_receiver_signature_required_frozen_panics() {
        let mut tx = make_transaction();
        tx.receiver_signature_required(RECEIVER_SIGNATURE_REQUIRED);
    }

    #[test]
    fn get_set_max_automatic_token_associations() {
        let mut tx = AccountUpdateTransaction::new();
        tx.max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);

        assert_eq!(
            tx.get_max_automatic_token_associations(),
            Some(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
        );
    }

    #[test]
    #[should_panic]
    fn get_set_max_automatic_token_associations_frozen_panics() {
        let mut tx = make_transaction();
        tx.max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);
    }

    #[test]
    fn get_set_account_memo() {
        let mut tx = AccountUpdateTransaction::new();
        tx.account_memo(ACCOUNT_MEMO);

        assert_eq!(tx.get_account_memo(), Some(ACCOUNT_MEMO));
    }

    #[test]
    #[should_panic]
    fn get_set_account_memo_frozen_panics() {
        let mut tx = make_transaction();
        tx.account_memo(ACCOUNT_MEMO);
    }

    #[test]
    fn get_set_staked_account_id() {
        let mut tx = AccountUpdateTransaction::new();
        tx.staked_account_id(STAKED_ACCOUNT_ID);

        assert_eq!(tx.get_staked_account_id(), Some(STAKED_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_staked_account_id_frozen_panics() {
        let mut tx = make_transaction();
        tx.staked_account_id(STAKED_ACCOUNT_ID);
    }

    #[test]
    fn get_set_staked_node_id() {
        let mut tx = AccountUpdateTransaction::new();
        tx.staked_node_id(STAKED_NODE_ID);

        assert_eq!(tx.get_staked_node_id(), Some(STAKED_NODE_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_staked_node_id_frozen_panics() {
        let mut tx = make_transaction();
        tx.staked_node_id(STAKED_NODE_ID);
    }
}
// Filename: src/account/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod account_allowance_approve_transaction;
mod account_allowance_delete_transaction;
mod account_balance;
mod account_balance_query;
mod account_create_transaction;
mod account_delete_transaction;
mod account_id;
mod account_info;
// note(sr): there's absolutely no way I'm going to write an enum or struct for namespacing here.
/// Flow for verifying signatures via account info.
pub mod account_info_flow;
mod account_info_query;
mod account_records_query;
mod account_update_transaction;
mod proxy_staker;

pub use account_allowance_approve_transaction::AccountAllowanceApproveTransaction;
pub(crate) use account_allowance_approve_transaction::AccountAllowanceApproveTransactionData;
pub use account_allowance_delete_transaction::AccountAllowanceDeleteTransaction;
pub(crate) use account_allowance_delete_transaction::AccountAllowanceDeleteTransactionData;
pub use account_balance::AccountBalance;
pub use account_balance_query::AccountBalanceQuery;
pub(crate) use account_balance_query::AccountBalanceQueryData;
pub use account_create_transaction::AccountCreateTransaction;
pub(crate) use account_create_transaction::AccountCreateTransactionData;
pub use account_delete_transaction::AccountDeleteTransaction;
pub(crate) use account_delete_transaction::AccountDeleteTransactionData;
pub use account_id::AccountId;
pub use account_info::AccountInfo;
pub use account_info_query::AccountInfoQuery;
pub(crate) use account_info_query::AccountInfoQueryData;
pub use account_records_query::AccountRecordsQuery;
pub(crate) use account_records_query::AccountRecordsQueryData;
pub use account_update_transaction::AccountUpdateTransaction;
pub(crate) use account_update_transaction::AccountUpdateTransactionData;
pub use proxy_staker::{
    AllProxyStakers,
    ProxyStaker,
};
// Filename: src/account/proxy_staker.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use crate::{
    AccountId,
    FromProtobuf,
    Hbar,
};

/// Response from [`AccountStakersQuery`][crate::AccountStakersQuery].
pub type AllProxyStakers = Vec<ProxyStaker>;

/// Information about a single account that is proxy staking.
#[derive(Debug, Clone)]
pub struct ProxyStaker {
    /// The Account ID that is proxy staking.
    pub account_id: AccountId,

    /// The number of hbars that are currently proxy staked.
    pub amount: Hbar,
}

impl FromProtobuf<services::response::Response> for AllProxyStakers {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let response = pb_getv!(pb, CryptoGetProxyStakers, services::response::Response);
        let stakers = pb_getf!(response, stakers)?;

        AllProxyStakers::from_protobuf(stakers.proxy_staker)
    }
}

impl FromProtobuf<services::ProxyStaker> for ProxyStaker {
    fn from_protobuf(pb: services::ProxyStaker) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let account_id = pb_getf!(pb, account_id)?;

        Ok(Self {
            account_id: AccountId::from_protobuf(account_id)?,
            amount: Hbar::from_tinybars(pb.amount),
        })
    }
}
// Filename: src/address_book/mod.rs
// SPDX-License-Identifier: Apache-2.0

pub mod node_create_transaction;
pub mod node_delete_transaction;
pub mod node_update_transaction;

pub use node_create_transaction::NodeCreateTransaction;
pub(crate) use node_create_transaction::NodeCreateTransactionData;
pub use node_delete_transaction::NodeDeleteTransaction;
pub(crate) use node_delete_transaction::NodeDeleteTransactionData;
pub use node_update_transaction::NodeUpdateTransaction;
pub(crate) use node_update_transaction::NodeUpdateTransactionData;
// Filename: src/address_book/node_create_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use std::net::Ipv4Addr;

use hedera_proto::services;
use hedera_proto::services::address_book_service_client::AddressBookServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::service_endpoint::ServiceEndpoint;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Key,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

/// A transaction body to add a new consensus node to the network address book.
///
/// This transaction body SHALL be considered a "privileged transaction".
///
/// This message supports a transaction to create a new node in the network
/// address book. The transaction, once complete, enables a new consensus node
/// to join the network, and requires governing council authorization.
pub type NodeCreateTransaction = Transaction<NodeCreateTransactionData>;

/// A transaction body to add a new consensus node to the network address book.
#[derive(Debug, Clone, Default)]
pub struct NodeCreateTransactionData {
    /// A Node account identifier.
    account_id: Option<AccountId>,

    /// A short description of the node.
    description: String,

    /// A list of service endpoints for gossip.
    gossip_endpoints: Vec<ServiceEndpoint>,

    /// A list of service endpoints for gRPC calls.
    service_endpoints: Vec<ServiceEndpoint>,

    /// A certificate used to sign gossip events.
    gossip_ca_certificate: Vec<u8>,

    /// A hash of the node gRPC TLS certificate.
    grpc_certificate_hash: Vec<u8>,

    /// An administrative key controlled by the node operator.
    admin_key: Option<Key>,
}

impl NodeCreateTransaction {
    /// Returns the account associated with the new node.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the account associated with the new node.
    pub fn account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(account_id);
        self
    }

    /// Returns the description of the new node.
    #[must_use]
    pub fn get_description(&self) -> &str {
        &self.data().description
    }

    /// Sets the description of the new node.
    pub fn description(&mut self, description: impl Into<String>) -> &mut Self {
        self.data_mut().description = description.into();
        self
    }

    /// Returns the list of service endpoints for gossip.
    #[must_use]
    pub fn get_gossip_endpoints(&self) -> Vec<ServiceEndpoint> {
        self.data().gossip_endpoints.clone()
    }

    /// Sets the list of service endpoints for gossip.
    pub fn gossip_endpoints(
        &mut self,
        gossip_endpoint: impl IntoIterator<Item = ServiceEndpoint>,
    ) -> &mut Self {
        self.data_mut().gossip_endpoints = gossip_endpoint.into_iter().collect();
        self
    }

    /// Adds a service endpoint for gossip to the list of service endpoints.
    pub fn add_gossip_endpoint(&mut self, gossip_endpoint: ServiceEndpoint) -> &mut Self {
        self.data_mut().gossip_endpoints.push(gossip_endpoint);
        self
    }

    /// Returns the list of service endpoints for gRPC calls.
    #[must_use]
    pub fn get_service_endpoints(&self) -> Vec<ServiceEndpoint> {
        self.data().service_endpoints.clone()
    }

    /// Sets the list of service endpoints for gRPC calls.
    pub fn service_endpoints(
        &mut self,
        service_endpoint: impl IntoIterator<Item = ServiceEndpoint>,
    ) -> &mut Self {
        self.data_mut().service_endpoints = service_endpoint.into_iter().collect();
        self
    }

    /// Adds a service endpoint to the list of service endpoints for gRPC calls.
    pub fn add_service_endpoint(&mut self, service_endpoint: ServiceEndpoint) -> &mut Self {
        self.data_mut().service_endpoints.push(service_endpoint);
        self
    }

    /// Returns the certificate used to sign gossip events.
    #[must_use]
    pub fn get_gossip_ca_certificate(&self) -> &[u8] {
        &self.data().gossip_ca_certificate
    }

    /// Sets the certificate used to sign gossip events.
    pub fn gossip_ca_certificate(
        &mut self,
        gossip_ca_certificate: impl Into<Vec<u8>>,
    ) -> &mut Self {
        self.data_mut().gossip_ca_certificate = gossip_ca_certificate.into();
        self
    }

    /// Returns the hash of the node gRPC TLS certificate.
    #[must_use]
    pub fn get_grpc_certificate_hash(&self) -> &[u8] {
        &self.data().grpc_certificate_hash
    }

    /// Sets the hash of the node gRPC TLS certificate.
    pub fn grpc_certificate_hash(
        &mut self,
        grpc_certificate_hash: impl Into<Vec<u8>>,
    ) -> &mut Self {
        self.data_mut().grpc_certificate_hash = grpc_certificate_hash.into();
        self
    }

    /// Returns the admin key.
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.data().admin_key.as_ref()
    }

    /// Sets the admin key.
    pub fn admin_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().admin_key = Some(key.into());
        self
    }
}

impl TransactionData for NodeCreateTransactionData {}

impl TransactionExecute for NodeCreateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { AddressBookServiceClient::new(channel).create_node(request).await })
    }
}

impl ValidateChecksums for NodeCreateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)?;
        Ok(())
    }
}

impl ToTransactionDataProtobuf for NodeCreateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::NodeCreate(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for NodeCreateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::NodeCreate(self.to_protobuf())
    }
}

impl From<NodeCreateTransactionData> for AnyTransactionData {
    fn from(transaction: NodeCreateTransactionData) -> Self {
        Self::NodeCreate(transaction)
    }
}

impl FromProtobuf<services::NodeCreateTransactionBody> for NodeCreateTransactionData {
    fn from_protobuf(pb: services::NodeCreateTransactionBody) -> crate::Result<Self> {
        let gossip_endpoints = pb
            .gossip_endpoint
            .iter()
            .map(|it| {
                let ip_addr_v4 = &it.ip_address_v4[..];
                let ip = Ipv4Addr::new(ip_addr_v4[0], ip_addr_v4[1], ip_addr_v4[2], ip_addr_v4[3]);
                ServiceEndpoint {
                    ip_address_v4: Some(ip),
                    port: it.port,
                    domain_name: it.domain_name.clone(),
                }
            })
            .collect();
        let service_endpoints = pb
            .service_endpoint
            .iter()
            .map(|it| {
                let ip_addr_v4 = &it.ip_address_v4[..];
                let ip = Ipv4Addr::new(ip_addr_v4[0], ip_addr_v4[1], ip_addr_v4[2], ip_addr_v4[3]);
                ServiceEndpoint {
                    ip_address_v4: Some(ip),
                    port: it.port,
                    domain_name: it.domain_name.clone(),
                }
            })
            .collect();

        Ok(Self {
            account_id: FromProtobuf::from_protobuf(pb.account_id)?,
            description: pb.description,
            gossip_endpoints: gossip_endpoints,
            service_endpoints: service_endpoints,
            gossip_ca_certificate: pb.gossip_ca_certificate,
            grpc_certificate_hash: pb.grpc_certificate_hash,
            admin_key: Option::from_protobuf(pb.admin_key)?,
        })
    }
}

impl ToProtobuf for NodeCreateTransactionData {
    type Protobuf = services::NodeCreateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let gossip_endpoints =
            self.gossip_endpoints.iter().map(|it| it.to_protobuf()).collect::<Vec<_>>();
        let service_endpoints =
            self.service_endpoints.iter().map(|it| it.to_protobuf()).collect::<Vec<_>>();

        services::NodeCreateTransactionBody {
            account_id: self.account_id.to_protobuf(),
            description: self.description.clone(),
            gossip_endpoint: gossip_endpoints,
            service_endpoint: service_endpoints,
            gossip_ca_certificate: self.gossip_ca_certificate.clone(),
            grpc_certificate_hash: self.grpc_certificate_hash.clone(),
            admin_key: self.admin_key.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::net::Ipv4Addr;

    use expect_test::expect_file;
    use hedera_proto::services;

    use super::NodeCreateTransaction;
    use crate::address_book::NodeCreateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::service_endpoint::ServiceEndpoint;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
        TEST_ACCOUNT_ID,
    };
    use crate::{
        AnyTransaction,
        Key,
    };

    const TEST_DESCRIPTION: &str = "test description";
    const TEST_GOSSIP_CA_CERTIFICATE: &[u8] = &[1, 2, 3, 4];
    const TEST_GRPC_CERTIFICATE_HASH: &[u8] = &[5, 6, 7, 8];

    fn make_ip_address_list() -> Vec<ServiceEndpoint> {
        vec![ServiceEndpoint {
            ip_address_v4: Some(Ipv4Addr::new(127, 0, 0, 1)),
            port: 1234,
            domain_name: "".to_owned(),
        }]
    }

    fn make_transaction() -> NodeCreateTransaction {
        let mut tx = NodeCreateTransaction::new_for_tests();

        tx.account_id(TEST_ACCOUNT_ID)
            .description(TEST_DESCRIPTION)
            .gossip_endpoints(make_ip_address_list())
            .service_endpoints(make_ip_address_list())
            .gossip_ca_certificate(TEST_GOSSIP_CA_CERTIFICATE)
            .grpc_certificate_hash(TEST_GRPC_CERTIFICATE_HASH)
            .admin_key(unused_private_key().public_key())
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/node_create_transaction/serialize.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2)
    }

    #[test]
    fn from_proto_body() {
        let tx = services::NodeCreateTransactionBody {
            account_id: Some(TEST_ACCOUNT_ID.to_protobuf()),
            description: TEST_DESCRIPTION.to_owned(),
            gossip_endpoint: make_ip_address_list()
                .into_iter()
                .map(|it| it.to_protobuf())
                .collect(),
            service_endpoint: make_ip_address_list()
                .into_iter()
                .map(|it| it.to_protobuf())
                .collect(),
            gossip_ca_certificate: TEST_GOSSIP_CA_CERTIFICATE.to_vec(),
            grpc_certificate_hash: TEST_GRPC_CERTIFICATE_HASH.to_vec(),
            admin_key: Some(unused_private_key().public_key().to_protobuf()),
        };

        let data = NodeCreateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.account_id, Some(TEST_ACCOUNT_ID));
        assert_eq!(data.description, TEST_DESCRIPTION);
        assert_eq!(data.gossip_endpoints, make_ip_address_list());
        assert_eq!(data.service_endpoints, make_ip_address_list());
        assert_eq!(data.gossip_ca_certificate, TEST_GOSSIP_CA_CERTIFICATE);
        assert_eq!(data.grpc_certificate_hash, TEST_GRPC_CERTIFICATE_HASH);
        assert_eq!(data.admin_key, Some(Key::from(unused_private_key().public_key())));
    }

    #[test]
    fn get_set_account_id() {
        let account_id = TEST_ACCOUNT_ID;
        let mut tx = NodeCreateTransaction::new();
        tx.account_id(account_id.to_owned());

        assert_eq!(tx.get_account_id(), Some(account_id));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panic() {
        make_transaction().account_id(TEST_ACCOUNT_ID);
    }

    #[test]
    fn get_set_description() {
        let description = TEST_DESCRIPTION.to_owned();
        let mut tx = NodeCreateTransaction::new();
        tx.description(description.to_owned());

        assert_eq!(tx.get_description(), TEST_DESCRIPTION);
    }

    #[test]
    #[should_panic]
    fn get_set_description_frozen_panic() {
        make_transaction().description(TEST_DESCRIPTION);
    }

    #[test]
    fn get_set_gossip_endpoints() {
        let gossip_endpoints = make_ip_address_list();
        let mut tx = NodeCreateTransaction::new();
        tx.gossip_endpoints(gossip_endpoints.to_owned());

        assert_eq!(tx.get_gossip_endpoints(), gossip_endpoints);
    }

    #[test]
    #[should_panic]
    fn get_set_gossip_endpoint_frozen_panic() {
        make_transaction().gossip_endpoints(make_ip_address_list());
    }

    #[test]
    fn get_set_service_endpoints() {
        let service_endpoints = make_ip_address_list();
        let mut tx = NodeCreateTransaction::new();
        tx.service_endpoints(service_endpoints.to_owned());

        assert_eq!(tx.get_service_endpoints(), service_endpoints);
    }

    #[test]
    #[should_panic]
    fn get_set_service_endpoints_frozen_panic() {
        make_transaction().service_endpoints(make_ip_address_list());
    }

    #[test]
    fn get_set_grpc_certificate_hash() {
        let mut tx = NodeCreateTransaction::new();
        tx.grpc_certificate_hash(TEST_GOSSIP_CA_CERTIFICATE);

        assert_eq!(tx.get_grpc_certificate_hash(), TEST_GOSSIP_CA_CERTIFICATE);
    }

    #[test]
    #[should_panic]
    fn get_set_grpc_certificate_hash_frozen_panic() {
        make_transaction().grpc_certificate_hash(TEST_GOSSIP_CA_CERTIFICATE);
    }

    #[test]
    fn get_set_admin_key() {
        let mut tx = NodeCreateTransaction::new();
        tx.admin_key(unused_private_key().public_key());

        assert_eq!(tx.get_admin_key(), Some(&Key::from(unused_private_key().public_key())));
    }

    #[test]
    #[should_panic]
    fn get_set_admin_key_frozen_panic() {
        make_transaction().admin_key(Key::from(unused_private_key().public_key()));
    }
}
// Filename: src/address_book/node_delete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::address_book_service_client::AddressBookServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

/// A transaction body to delete a node from the network address book.
///
/// This transaction body SHALL be considered a "privileged transaction".
///
/// - A `NodeDeleteTransactionBody` MUST be signed by the governing council.
/// - Upon success, the address book entry SHALL enter a "pending delete"
///    state.
/// - All address book entries pending deletion SHALL be removed from the
///    active network configuration during the next `freeze` transaction with
///    the field `freeze_type` set to `PREPARE_UPGRADE`.<br/>
/// - A deleted address book node SHALL be removed entirely from network state.
/// - A deleted address book node identifier SHALL NOT be reused.
///
/// ### Record Stream Effects
/// Upon completion the "deleted" `node_id` SHALL be in the transaction
/// receipt.
pub type NodeDeleteTransaction = Transaction<NodeDeleteTransactionData>;

/// A transaction body to delete a node from the network address book.
#[derive(Debug, Clone, Default)]
pub struct NodeDeleteTransactionData {
    /// A consensus node identifier in the network state.
    node_id: u64,
}

impl NodeDeleteTransaction {
    /// Returns the node ID associated with the node to be deleted.
    #[must_use]
    pub fn get_node_id(&self) -> u64 {
        self.data().node_id
    }

    /// Sets the node ID associated with the node to be deleted.
    pub fn node_id(&mut self, node_id: u64) -> &mut Self {
        self.data_mut().node_id = node_id;
        self
    }
}

impl TransactionData for NodeDeleteTransactionData {}

impl TransactionExecute for NodeDeleteTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { AddressBookServiceClient::new(channel).delete_node(request).await })
    }
}

impl ValidateChecksums for NodeDeleteTransactionData {
    fn validate_checksums(&self, _ledger_id: &RefLedgerId) -> Result<(), Error> {
        Ok(())
    }
}

impl ToTransactionDataProtobuf for NodeDeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::NodeDelete(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for NodeDeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::NodeDelete(self.to_protobuf())
    }
}

impl From<NodeDeleteTransactionData> for AnyTransactionData {
    fn from(transaction: NodeDeleteTransactionData) -> Self {
        Self::NodeDelete(transaction)
    }
}

impl FromProtobuf<services::NodeDeleteTransactionBody> for NodeDeleteTransactionData {
    fn from_protobuf(pb: services::NodeDeleteTransactionBody) -> crate::Result<Self> {
        Ok(Self { node_id: pb.node_id })
    }
}

impl ToProtobuf for NodeDeleteTransactionData {
    type Protobuf = services::NodeDeleteTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::NodeDeleteTransactionBody { node_id: self.node_id }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect_file;
    use hedera_proto::services;

    use super::NodeDeleteTransaction;
    use crate::address_book::NodeDeleteTransactionData;
    use crate::protobuf::FromProtobuf;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::AnyTransaction;

    fn make_transaction() -> NodeDeleteTransaction {
        let mut tx = NodeDeleteTransaction::new_for_tests();

        tx.node_id(1).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/node_delete_transaction/serialize.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2)
    }

    #[test]
    fn from_proto_body() {
        let tx = services::NodeDeleteTransactionBody { node_id: 1 };

        let data = NodeDeleteTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.node_id, 1);
    }

    #[test]
    fn get_set_node_id() {
        let mut tx = NodeDeleteTransaction::new();
        tx.node_id(1);

        assert_eq!(tx.get_node_id(), 1);
    }

    #[test]
    #[should_panic]
    fn get_set_node_id_frozen_panic() {
        make_transaction().node_id(1);
    }
}
// Filename: src/address_book/node_update_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use std::net::Ipv4Addr;

use hedera_proto::services;
use hedera_proto::services::address_book_service_client::AddressBookServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::service_endpoint::ServiceEndpoint;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Key,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

/// Transaction body to modify address book node attributes.
///
/// - This transaction SHALL enable the node operator, as identified by the
///    `admin_key`, to modify operational attributes of the node.
/// - This transaction MUST be signed by the active `admin_key` for the node.
/// - If this transaction sets a new value for the `admin_key`, then both the
///    current `admin_key`, and the new `admin_key` MUST sign this transaction.
/// - This transaction SHALL NOT change any field that is not set (is null) in
///    this transaction body.
/// - This SHALL create a pending update to the node, but the change SHALL NOT
///    be immediately applied to the active configuration.
/// - All pending node updates SHALL be applied to the active network
///    configuration during the next `freeze` transaction with the field
///    `freeze_type` set to `PREPARE_UPGRADE`.
///
/// ### Record Stream Effects
/// Upon completion the `node_id` for the updated entry SHALL be in the
/// transaction receipt.
pub type NodeUpdateTransaction = Transaction<NodeUpdateTransactionData>;

/// Transaction body to modify address book node attributes.
#[derive(Debug, Clone, Default)]
pub struct NodeUpdateTransactionData {
    /// A consensus node identifier in the network state.
    node_id: u64,

    /// A Node account identifier.
    account_id: Option<AccountId>,

    /// A short description of the node.
    description: Option<String>,

    /// A list of service endpoints for gossip.
    gossip_endpoints: Vec<ServiceEndpoint>,

    /// A list of service endpoints for gRPC calls.
    service_endpoints: Vec<ServiceEndpoint>,

    /// A certificate used to sign gossip events.
    gossip_ca_certificate: Option<Vec<u8>>,

    /// A hash of the node gRPC TLS certificate.
    grpc_certificate_hash: Option<Vec<u8>>,

    /// An administrative key controlled by the node operator.
    admin_key: Option<Key>,
}

impl NodeUpdateTransaction {
    /// Returns the account associated with the new node.
    #[must_use]
    pub fn get_node_id(&self) -> u64 {
        self.data().node_id
    }

    /// Sets the account associated with the new node.
    pub fn node_id(&mut self, node_id: u64) -> &mut Self {
        self.data_mut().node_id = node_id;
        self
    }

    /// Returns the account associated with the new node.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the account associated with the new node.
    pub fn account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(account_id);
        self
    }

    /// Returns the description of the new node.
    #[must_use]
    pub fn get_description(&self) -> Option<&str> {
        self.data().description.as_deref()
    }

    /// Sets the description of the new node.
    pub fn description(&mut self, description: impl Into<String>) -> &mut Self {
        self.data_mut().description = Some(description.into());
        self
    }

    /// Returns the list of service endpoints for gossip.
    #[must_use]
    pub fn get_gossip_endpoints(&self) -> Vec<ServiceEndpoint> {
        self.data().gossip_endpoints.clone()
    }

    /// Sets the list of service endpoints for gossip.
    pub fn gossip_endpoints(
        &mut self,
        gossip_endpoint: impl IntoIterator<Item = ServiceEndpoint>,
    ) -> &mut Self {
        self.data_mut().gossip_endpoints = gossip_endpoint.into_iter().collect();
        self
    }

    /// Adds a service endpoint for gossip to the list of service endpoints.
    pub fn add_gossip_endpoint(&mut self, gossip_endpoint: ServiceEndpoint) -> &mut Self {
        self.data_mut().gossip_endpoints.push(gossip_endpoint);
        self
    }

    /// Returns the updated list of service endpoints for gRPC calls.
    #[must_use]
    pub fn get_service_endpoints(&self) -> Vec<ServiceEndpoint> {
        self.data().service_endpoints.clone()
    }

    /// Sets the updated list of service endpoints for gRPC calls.
    pub fn service_endpoints(
        &mut self,
        service_endpoint: impl IntoIterator<Item = ServiceEndpoint>,
    ) -> &mut Self {
        self.data_mut().service_endpoints = service_endpoint.into_iter().collect();
        self
    }

    /// Adds a service endpoint to the list of service endpoints for gRPC calls.
    pub fn add_service_endpoint(&mut self, service_endpoint: ServiceEndpoint) -> &mut Self {
        self.data_mut().service_endpoints.push(service_endpoint);
        self
    }

    /// Returns the updated certificate used to sign gossip events.
    #[must_use]
    pub fn get_gossip_ca_certificate(&self) -> Option<Vec<u8>> {
        self.data().gossip_ca_certificate.clone()
    }

    /// Updates the certificate used to sign gossip events.
    pub fn gossip_ca_certificate(
        &mut self,
        gossip_ca_certificate: impl Into<Vec<u8>>,
    ) -> &mut Self {
        self.data_mut().gossip_ca_certificate = Some(gossip_ca_certificate.into());
        self
    }

    /// Returns the updated hash of the node gRPC TLS certificate.
    #[must_use]
    pub fn get_grpc_certificate_hash(&self) -> Option<Vec<u8>> {
        self.data().grpc_certificate_hash.clone()
    }

    /// Updates the hash of the node gRPC TLS certificate.
    pub fn grpc_certificate_hash(
        &mut self,
        grpc_certificate_hash: impl Into<Vec<u8>>,
    ) -> &mut Self {
        self.data_mut().grpc_certificate_hash = Some(grpc_certificate_hash.into());
        self
    }

    /// Returns the updated admin key.
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.data().admin_key.as_ref()
    }

    /// Updated the admin key.
    pub fn admin_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().admin_key = Some(key.into());
        self
    }
}

impl TransactionData for NodeUpdateTransactionData {}

impl TransactionExecute for NodeUpdateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { AddressBookServiceClient::new(channel).update_node(request).await })
    }
}

impl ValidateChecksums for NodeUpdateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)?;
        Ok(())
    }
}

impl ToTransactionDataProtobuf for NodeUpdateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::NodeUpdate(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for NodeUpdateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::NodeUpdate(self.to_protobuf())
    }
}

impl From<NodeUpdateTransactionData> for AnyTransactionData {
    fn from(transaction: NodeUpdateTransactionData) -> Self {
        Self::NodeUpdate(transaction)
    }
}

impl FromProtobuf<services::NodeUpdateTransactionBody> for NodeUpdateTransactionData {
    fn from_protobuf(pb: services::NodeUpdateTransactionBody) -> crate::Result<Self> {
        let gossip_endpoints = pb
            .gossip_endpoint
            .iter()
            .map(|it| {
                let ip_addr_v4 = &it.ip_address_v4[..];
                let ip = Ipv4Addr::new(ip_addr_v4[0], ip_addr_v4[1], ip_addr_v4[2], ip_addr_v4[3]);
                ServiceEndpoint {
                    ip_address_v4: Some(ip),
                    port: it.port,
                    domain_name: it.domain_name.clone(),
                }
            })
            .collect();
        let service_endpoints = pb
            .service_endpoint
            .iter()
            .map(|it| {
                let ip_addr_v4 = &it.ip_address_v4[..];
                let ip = Ipv4Addr::new(ip_addr_v4[0], ip_addr_v4[1], ip_addr_v4[2], ip_addr_v4[3]);
                ServiceEndpoint {
                    ip_address_v4: Some(ip),
                    port: it.port,
                    domain_name: it.domain_name.clone(),
                }
            })
            .collect();

        Ok(Self {
            node_id: pb.node_id,
            account_id: FromProtobuf::from_protobuf(pb.account_id)?,
            description: pb.description,
            gossip_endpoints: gossip_endpoints,
            service_endpoints: service_endpoints,
            gossip_ca_certificate: pb.gossip_ca_certificate,
            grpc_certificate_hash: pb.grpc_certificate_hash,
            admin_key: Option::from_protobuf(pb.admin_key)?,
        })
    }
}

impl ToProtobuf for NodeUpdateTransactionData {
    type Protobuf = services::NodeUpdateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let gossip_endpoints =
            self.gossip_endpoints.iter().map(|it| it.to_protobuf()).collect::<Vec<_>>();
        let service_endpoints =
            self.service_endpoints.iter().map(|it| it.to_protobuf()).collect::<Vec<_>>();

        services::NodeUpdateTransactionBody {
            node_id: self.node_id,
            account_id: self.account_id.to_protobuf(),
            description: self.description.clone(),
            gossip_endpoint: gossip_endpoints,
            service_endpoint: service_endpoints,
            gossip_ca_certificate: self.gossip_ca_certificate.clone(),
            grpc_certificate_hash: self.grpc_certificate_hash.clone(),
            admin_key: self.admin_key.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::net::Ipv4Addr;

    use expect_test::expect_file;
    use hedera_proto::services;

    use super::NodeUpdateTransaction;
    use crate::address_book::NodeUpdateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::service_endpoint::ServiceEndpoint;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
        TEST_ACCOUNT_ID,
    };
    use crate::{
        AnyTransaction,
        Key,
    };

    const TEST_DESCRIPTION: &str = "test description";
    const TEST_GOSSIP_CA_CERTIFICATE: &[u8] = &[1, 2, 3, 4];
    const TEST_GRPC_CERTIFICATE_HASH: &[u8] = &[5, 6, 7, 8];

    fn make_ip_address_list() -> Vec<ServiceEndpoint> {
        vec![
            ServiceEndpoint {
                ip_address_v4: Some(Ipv4Addr::new(127, 0, 0, 1)),
                port: 1234,
                domain_name: "".to_owned(),
            },
            ServiceEndpoint {
                ip_address_v4: Some(Ipv4Addr::new(127, 0, 0, 1)),
                port: 8008,
                domain_name: "".to_owned(),
            },
        ]
    }

    fn make_transaction() -> NodeUpdateTransaction {
        let mut tx = NodeUpdateTransaction::new_for_tests();

        tx.account_id(TEST_ACCOUNT_ID)
            .description(TEST_DESCRIPTION)
            .gossip_endpoints(make_ip_address_list())
            .service_endpoints(make_ip_address_list())
            .gossip_ca_certificate(TEST_GOSSIP_CA_CERTIFICATE)
            .grpc_certificate_hash(TEST_GRPC_CERTIFICATE_HASH)
            .admin_key(unused_private_key().public_key())
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/node_update_transaction/serialize.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2)
    }

    #[test]
    fn from_proto_body() {
        let tx = services::NodeUpdateTransactionBody {
            node_id: 1,
            account_id: Some(TEST_ACCOUNT_ID.to_protobuf()),
            description: Some(TEST_DESCRIPTION.to_owned()),
            gossip_endpoint: make_ip_address_list()
                .into_iter()
                .map(|it| it.to_protobuf())
                .collect(),
            service_endpoint: make_ip_address_list()
                .into_iter()
                .map(|it| it.to_protobuf())
                .collect(),
            gossip_ca_certificate: Some(TEST_GOSSIP_CA_CERTIFICATE.to_vec()),
            grpc_certificate_hash: Some(TEST_GRPC_CERTIFICATE_HASH.to_vec()),
            admin_key: Some(unused_private_key().public_key().to_protobuf()),
        };

        let data = NodeUpdateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.account_id, Some(TEST_ACCOUNT_ID));
        assert_eq!(data.description, Some(TEST_DESCRIPTION.to_string()));
        assert_eq!(data.gossip_endpoints, make_ip_address_list());
        assert_eq!(data.service_endpoints, make_ip_address_list());
        assert_eq!(data.gossip_ca_certificate, Some(TEST_GOSSIP_CA_CERTIFICATE.to_vec()));
        assert_eq!(data.grpc_certificate_hash, Some(TEST_GRPC_CERTIFICATE_HASH.to_vec()));
        assert_eq!(data.admin_key, Some(Key::from(unused_private_key().public_key())));
    }

    #[test]
    fn get_set_node_id() {
        let mut tx = NodeUpdateTransaction::new();
        tx.node_id(1);

        assert_eq!(tx.get_node_id(), 1);
    }

    #[test]
    #[should_panic]
    fn get_set_node_id_frozen_panic() {
        make_transaction().node_id(1);
    }

    #[test]
    fn get_set_account_id() {
        let account_id = TEST_ACCOUNT_ID;
        let mut tx = NodeUpdateTransaction::new();
        tx.account_id(account_id.to_owned());

        assert_eq!(tx.get_account_id(), Some(account_id));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panic() {
        make_transaction().account_id(TEST_ACCOUNT_ID);
    }

    #[test]
    fn get_set_description() {
        let description = TEST_DESCRIPTION.to_owned();
        let mut tx = NodeUpdateTransaction::new();
        tx.description(description.to_owned());

        assert_eq!(tx.get_description(), Some(TEST_DESCRIPTION));
    }

    #[test]
    #[should_panic]
    fn get_set_description_frozen_panic() {
        make_transaction().description(TEST_DESCRIPTION);
    }

    #[test]
    fn get_set_gossip_endpoints() {
        let gossip_endpoints = make_ip_address_list();
        let mut tx = NodeUpdateTransaction::new();
        tx.gossip_endpoints(gossip_endpoints.to_owned());

        assert_eq!(tx.get_gossip_endpoints(), gossip_endpoints);
    }

    #[test]
    #[should_panic]
    fn get_set_gossip_endpoint_frozen_panic() {
        make_transaction().gossip_endpoints(make_ip_address_list());
    }

    #[test]
    fn get_set_service_endpoints() {
        let service_endpoints = make_ip_address_list();
        let mut tx = NodeUpdateTransaction::new();
        tx.service_endpoints(service_endpoints.to_owned());

        assert_eq!(tx.get_service_endpoints(), service_endpoints);
    }

    #[test]
    #[should_panic]
    fn get_set_service_endpoints_frozen_panic() {
        make_transaction().service_endpoints(make_ip_address_list());
    }

    #[test]
    fn get_set_grpc_certificate_hash() {
        let mut tx = NodeUpdateTransaction::new();
        tx.grpc_certificate_hash(TEST_GOSSIP_CA_CERTIFICATE);

        assert_eq!(tx.get_grpc_certificate_hash(), Some(TEST_GOSSIP_CA_CERTIFICATE.to_vec()));
    }

    #[test]
    #[should_panic]
    fn get_set_grpc_certificate_hash_frozen_panic() {
        make_transaction().grpc_certificate_hash(TEST_GOSSIP_CA_CERTIFICATE);
    }

    #[test]
    fn get_set_admin_key() {
        let mut tx = NodeUpdateTransaction::new();
        tx.admin_key(unused_private_key().public_key());

        assert_eq!(tx.get_admin_key(), Some(&Key::from(unused_private_key().public_key())));
    }

    #[test]
    #[should_panic]
    fn get_set_admin_key_frozen_panic() {
        make_transaction().admin_key(Key::from(unused_private_key().public_key()));
    }
}
// Filename: src/client/config.rs
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashMap;
use std::str::FromStr;

use crate::signer::AnySigner;
use crate::{
    AccountId,
    PrivateKey,
};

struct FromStrProxy<T>(T);

impl<'de, T: FromStr> serde::Deserialize<'de> for FromStrProxy<T>
where
    T::Err: std::fmt::Display,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        String::deserialize(deserializer)
            .and_then(|it| it.parse().map_err(D::Error::custom))
            .map(Self)
    }
}

#[derive(serde_derive::Deserialize)]
pub(super) struct Operator {
    account_id: FromStrProxy<AccountId>,
    private_key: FromStrProxy<PrivateKey>,
}

impl From<Operator> for super::Operator {
    fn from(value: Operator) -> Self {
        Self { account_id: value.account_id.0, signer: AnySigner::PrivateKey(value.private_key.0) }
    }
}

#[derive(serde_derive::Deserialize)]
#[serde(untagged)]
pub(super) enum Either<L, R> {
    Left(L),
    Right(R),
}

#[derive(serde_derive::Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) enum NetworkName {
    Mainnet,
    Testnet,
    Previewnet,
}

#[derive(serde_derive::Deserialize)]
#[serde(rename_all = "camelCase")]
pub(super) struct ClientConfigInner {
    operator: Option<Operator>,
    network: Either<HashMap<String, FromStrProxy<AccountId>>, NetworkName>,
    mirror_network: Option<Either<Vec<String>, NetworkName>>,
}

impl From<ClientConfigInner> for ClientConfig {
    fn from(value: ClientConfigInner) -> Self {
        Self {
            operator: value.operator.map(Into::into),
            network: match value.network {
                Either::Left(it) => Either::Left(it.into_iter().map(|(k, v)| (k, v.0)).collect()),
                Either::Right(it) => Either::Right(it),
            },
            mirror_network: value.mirror_network,
        }
    }
}

pub(super) struct ClientConfig {
    pub(super) operator: Option<super::Operator>,
    pub(super) network: Either<HashMap<String, AccountId>, NetworkName>,
    pub(super) mirror_network: Option<Either<Vec<String>, NetworkName>>,
}
// Filename: src/client/mod.rs
// SPDX-License-Identifier: Apache-2.0

use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt;
use std::num::{
    NonZeroU64,
    NonZeroUsize,
};
use std::sync::atomic::{
    AtomicBool,
    AtomicU64,
    Ordering,
};
use std::time::Duration;

pub(crate) use network::{
    Network,
    NetworkData,
};
pub(crate) use operator::Operator;
use parking_lot::RwLock;
use tokio::sync::watch;
use triomphe::Arc;

use self::network::managed::ManagedNetwork;
use self::network::mirror::MirrorNetwork;
pub(crate) use self::network::mirror::MirrorNetworkData;
use crate::ping_query::PingQuery;
use crate::signer::AnySigner;
use crate::{
    AccountId,
    ArcSwapOption,
    Error,
    Hbar,
    LedgerId,
    NodeAddressBook,
    NodeAddressBookQuery,
    PrivateKey,
    PublicKey,
};

#[cfg(feature = "serde")]
mod config;

mod network;
mod operator;

#[derive(Copy, Clone)]
pub(crate) struct ClientBackoff {
    pub(crate) max_backoff: Duration,
    // min backoff.
    pub(crate) initial_backoff: Duration,
    pub(crate) max_attempts: usize,
    pub(crate) request_timeout: Option<Duration>,
    pub(crate) grpc_timeout: Option<Duration>,
}

impl Default for ClientBackoff {
    fn default() -> Self {
        Self {
            max_backoff: Duration::from_millis(backoff::default::MAX_INTERVAL_MILLIS),
            initial_backoff: Duration::from_millis(backoff::default::INITIAL_INTERVAL_MILLIS),
            max_attempts: 10,
            request_timeout: None,
            grpc_timeout: None,
        }
    }
}

// yes, client is complicated enough for this, even if it's only internal.
struct ClientBuilder {
    network: ManagedNetwork,
    operator: Option<Operator>,
    max_transaction_fee: Option<NonZeroU64>,
    max_query_payment: Option<NonZeroU64>,
    ledger_id: Option<LedgerId>,
    auto_validate_checksums: bool,
    regenerate_transaction_ids: bool,
    update_network: bool,
    backoff: ClientBackoff,
}

impl ClientBuilder {
    #[must_use]
    fn new(network: ManagedNetwork) -> Self {
        Self {
            network,
            operator: None,
            max_transaction_fee: None,
            max_query_payment: None,
            ledger_id: None,
            auto_validate_checksums: false,
            regenerate_transaction_ids: true,
            update_network: true,
            backoff: ClientBackoff::default(),
        }
    }

    fn disable_network_updating(self) -> Self {
        Self { update_network: false, ..self }
    }

    fn ledger_id(self, ledger_id: Option<LedgerId>) -> Self {
        Self { ledger_id, ..self }
    }

    fn build(self) -> Client {
        let Self {
            network,
            operator,
            max_transaction_fee,
            max_query_payment,
            ledger_id,
            auto_validate_checksums,
            regenerate_transaction_ids,
            update_network,
            backoff,
        } = self;

        let network_update_tx = match update_network {
            true => network::managed::spawn_network_update(
                network.clone(),
                Some(Duration::from_secs(24 * 60 * 60)),
            ),
            // yeah, we just drop the rx.
            false => watch::channel(None).0,
        };

        Client(Arc::new(ClientInner {
            network,
            operator: ArcSwapOption::new(operator.map(Arc::new)),
            max_transaction_fee_tinybar: AtomicU64::new(
                max_transaction_fee.map_or(0, NonZeroU64::get),
            ),
            max_query_payment_tinybar: AtomicU64::new(max_query_payment.map_or(0, NonZeroU64::get)),
            ledger_id: ArcSwapOption::new(ledger_id.map(Arc::new)),
            auto_validate_checksums: AtomicBool::new(auto_validate_checksums),
            regenerate_transaction_ids: AtomicBool::new(regenerate_transaction_ids),
            network_update_tx,
            backoff: RwLock::new(backoff),
        }))
    }
}

struct ClientInner {
    network: ManagedNetwork,
    operator: ArcSwapOption<Operator>,
    max_transaction_fee_tinybar: AtomicU64,
    max_query_payment_tinybar: AtomicU64,
    ledger_id: ArcSwapOption<LedgerId>,
    auto_validate_checksums: AtomicBool,
    regenerate_transaction_ids: AtomicBool,
    network_update_tx: watch::Sender<Option<Duration>>,
    backoff: RwLock<ClientBackoff>,
}

/// Managed client for use on the Hiero network.
#[derive(Clone)]
pub struct Client(Arc<ClientInner>);

impl fmt::Debug for Client {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // todo: put anything important here.
        f.debug_struct("Client").finish_non_exhaustive()
    }
}

impl Client {
    #[cfg(feature = "serde")]
    fn from_config_data(config: config::ClientConfig) -> crate::Result<Self> {
        let config::ClientConfig { operator, network, mirror_network } = config;

        // fixme: check to ensure net and mirror net are the same when they're a network name (no other SDK actually checks this though)
        let client = match network {
            config::Either::Left(network) => Client::for_network(network)?,
            config::Either::Right(it) => match it {
                config::NetworkName::Mainnet => Client::for_mainnet(),
                config::NetworkName::Testnet => Client::for_testnet(),
                config::NetworkName::Previewnet => Client::for_previewnet(),
            },
        };

        let mirror_network = mirror_network.map(|mirror_network| match mirror_network {
            config::Either::Left(mirror_network) => {
                MirrorNetwork::from_addresses(mirror_network.into_iter().map(Cow::Owned).collect())
            }
            config::Either::Right(it) => match it {
                config::NetworkName::Mainnet => MirrorNetwork::mainnet(),
                config::NetworkName::Testnet => MirrorNetwork::testnet(),
                config::NetworkName::Previewnet => MirrorNetwork::previewnet(),
            },
        });

        if let Some(operator) = operator {
            client.0.operator.store(Some(Arc::new(operator)));
        }

        if let Some(mirror_network) = mirror_network {
            client.set_mirror_network(mirror_network.load().addresses());
        }

        Ok(client)
    }

    /// Create a client from the given json config.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if an error occurs parsing the configuration.
    #[cfg(feature = "serde")]
    pub fn from_config(json: &str) -> crate::Result<Self> {
        let config = serde_json::from_str::<config::ClientConfigInner>(json)
            .map_err(crate::Error::basic_parse)?
            .into();

        Self::from_config_data(config)
    }

    /// Returns the addresses for the configured mirror network.
    ///
    /// Unless _explicitly_ set, the return value isn't guaranteed to be anything in particular in order to allow future changes without breaking semver.
    /// However, when a function such as `for_testnet` is used, _some_ valid value will be returned.
    ///
    /// Current return values (reminder that these are semver exempt)
    ///
    /// - mainnet: `["mainnet-public.mirrornode.hedera.com:443"]`
    /// - testnet: `["testnet.mirrornode.hedera.com:443"]`
    /// - previewnet: `["previewnet.mirrornode.hedera.com:443"]`
    ///
    /// # Examples
    ///
    /// ```
    /// # #[tokio::main]
    /// # async fn main() {
    /// use hedera::Client;
    ///
    /// let client = Client::for_testnet();
    ///
    /// // note: This isn't *guaranteed* in a semver sense, but this is the current result.
    /// let expected = Vec::from(["testnet.mirrornode.hedera.com:443".to_owned()]);
    /// assert_eq!(expected, client.mirror_network());
    ///
    /// # }
    /// ```
    #[must_use]
    pub fn mirror_network(&self) -> Vec<String> {
        self.mirrornet().load().addresses().collect()
    }

    /// Sets the addresses to use for the mirror network.
    ///
    /// This is mostly useful if you used [`Self::for_network`] and need to set a mirror network.
    pub fn set_mirror_network<I: IntoIterator<Item = String>>(&self, addresses: I) {
        self.mirrornet().store(
            MirrorNetworkData::from_addresses(addresses.into_iter().map(Cow::Owned).collect())
                .into(),
        );
    }

    /// Construct a client with the given nodes configured.
    ///
    /// Note that this disables network auto-updating.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if an error occurs parsing the configuration.
    // allowed for API compatibility.
    #[allow(clippy::needless_pass_by_value)]
    pub fn for_network(network: HashMap<String, AccountId>) -> crate::Result<Self> {
        let network =
            ManagedNetwork::new(Network::from_addresses(&network)?, MirrorNetwork::default());

        Ok(ClientBuilder::new(network).disable_network_updating().build())
    }

    /// Construct a client from a select mirror network
    pub async fn for_mirror_network(mirror_networks: Vec<String>) -> crate::Result<Self> {
        let network_addresses: HashMap<String, AccountId> = HashMap::new();
        let network = ManagedNetwork::new(
            Network::from_addresses(&network_addresses)?,
            MirrorNetwork::from_addresses(mirror_networks.into_iter().map(Cow::Owned).collect()),
        );

        let client = ClientBuilder::new(network).build();
        let address_book = NodeAddressBookQuery::default().execute(&client).await?;

        client.set_network_from_address_book(address_book);

        Ok(client)
    }

    /// Construct a Hiero client pre-configured for mainnet access.
    #[must_use]
    pub fn for_mainnet() -> Self {
        ClientBuilder::new(ManagedNetwork::mainnet()).ledger_id(Some(LedgerId::mainnet())).build()
    }

    /// Construct a Hiero client pre-configured for testnet access.
    #[must_use]
    pub fn for_testnet() -> Self {
        ClientBuilder::new(ManagedNetwork::testnet()).ledger_id(Some(LedgerId::testnet())).build()
    }

    /// Construct a Hiero client pre-configured for previewnet access.
    #[must_use]
    pub fn for_previewnet() -> Self {
        ClientBuilder::new(ManagedNetwork::previewnet())
            .ledger_id(Some(LedgerId::previewnet()))
            .build()
    }

    /// Updates the network to use the given address book.
    ///
    /// Note: This is only really useful if you used `for_network`, because the network can auto-update.
    ///
    /// If network auto-updating is enabled this will eventually be overridden.
    // allowed for API compatibility.
    #[allow(clippy::needless_pass_by_value)]
    pub fn set_network_from_address_book(&self, address_book: NodeAddressBook) {
        self.net().update_from_address_book(&address_book);
    }

    /// Updates the network to use the given addresses.
    ///
    /// Note: This is only really useful if you used `for_network`, because the network can auto-update.
    ///
    /// If network auto-updating is enabled this will eventually be overridden.
    ///
    /// Tend to prefer [`set_network_from_address_book`](Self::set_network_from_address_book) where possible.
    ///
    /// # Errors
    /// [`Error::BasicParse`](crate::Error::BasicParse) If any node address is unparsable.
    // allowed for API compatibility.
    #[allow(clippy::needless_pass_by_value)]
    pub fn set_network(&self, network: HashMap<String, AccountId>) -> crate::Result<()> {
        self.net().update_from_addresses(&network)?;

        Ok(())
    }

    /// Returns the nodes associated with this client.
    #[must_use]
    pub fn network(&self) -> HashMap<String, AccountId> {
        self.net().0.load().addresses()
    }

    /// Returns the max number of times a node can be retried before removing it from the network.
    pub fn max_node_attempts(&self) -> Option<NonZeroUsize> {
        self.net().0.load().max_node_attempts()
    }

    /// Set the max number of times a node can return a bad gRPC status before we remove it from the list.
    pub fn set_max_node_attempts(&self, attempts: usize) {
        self.net().0.load().set_max_node_attempts(NonZeroUsize::new(attempts))
    }

    /// Returns the max backoff interval for network nodes if gRPC response fail.    
    pub fn max_node_backoff(&self) -> Duration {
        self.net().0.load().max_backoff()
    }

    /// Sets max backoff interval for network nodes
    pub fn set_max_node_backoff(&self, max_node_backoff: Duration) {
        self.net().0.load().set_max_backoff(max_node_backoff)
    }

    /// Returns the initial backoff interval for network nodes if gRPC response fail.    
    pub fn min_node_backoff(&self) -> Duration {
        self.net().0.load().min_backoff()
    }

    /// Sets initial backoff interval for network nodes
    pub fn set_min_node_backoff(&self, min_node_backoff: Duration) {
        self.net().0.load().set_min_backoff(min_node_backoff)
    }

    /// Construct a hedera client pre-configured for access to the given network.
    ///
    /// Currently supported network names are `"mainnet"`, `"testnet"`, and `"previewnet"`.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if the network name is not a supported network name.
    pub fn for_name(name: &str) -> crate::Result<Self> {
        match name {
            "mainnet" => Ok(Self::for_mainnet()),
            "testnet" => Ok(Self::for_testnet()),
            "previewnet" => Ok(Self::for_previewnet()),
            "localhost" => {
                let mut network: HashMap<String, AccountId> = HashMap::new();
                network.insert("127.0.0.1:50211".to_string(), AccountId::new(0, 0, 3));

                let client = Client::for_network(network).unwrap();
                client.set_mirror_network(["127.0.0.1:5600".to_string()]);
                Ok(client)
            }
            _ => Err(Error::basic_parse(format!("Unknown network name {name}"))),
        }
    }

    // optimized function to avoid allocations/pointer chasing.
    // this shouldn't be exposed because it exposes repr.
    pub(crate) fn ledger_id_internal(&self) -> arc_swap::Guard<Option<Arc<LedgerId>>> {
        self.0.ledger_id.load()
    }

    /// Sets the ledger ID for the Client's network.
    pub fn set_ledger_id(&self, ledger_id: Option<LedgerId>) {
        self.0.ledger_id.store(ledger_id.map(Arc::new));
    }

    /// Returns true if checksums should be automatically validated.
    #[must_use]
    pub fn auto_validate_checksums(&self) -> bool {
        self.0.auto_validate_checksums.load(Ordering::Relaxed)
    }

    /// Enable or disable automatic entity ID checksum validation.
    pub fn set_auto_validate_checksums(&self, value: bool) {
        self.0.auto_validate_checksums.store(value, Ordering::Relaxed);
    }

    /// Returns true if transaction IDs should be automatically regenerated.
    ///
    /// This is `true` by default.
    #[must_use]
    pub fn default_regenerate_transaction_id(&self) -> bool {
        self.0.regenerate_transaction_ids.load(Ordering::Relaxed)
    }

    /// Enable or disable transaction ID regeneration.
    pub fn set_default_regenerate_transaction_id(&self, value: bool) {
        self.0.regenerate_transaction_ids.store(value, Ordering::Relaxed);
    }

    /// Sets the account that will, by default, be paying for transactions and queries built with
    /// this client.
    ///
    /// The operator account ID is used to generate the default transaction ID for all transactions
    /// executed with this client.
    ///
    /// The operator private key is used to sign all transactions executed by this client.
    pub fn set_operator(&self, id: AccountId, key: PrivateKey) {
        self.0
            .operator
            .store(Some(Arc::new(Operator { account_id: id, signer: AnySigner::PrivateKey(key) })));
    }

    /// Sets the account that will, by default, be paying for transactions and queries built with
    /// this client.
    ///
    /// The operator account ID is used to generate the default transaction ID for all transactions
    /// executed with this client.
    ///
    /// The operator signer is used to sign all transactions executed by this client.
    pub fn set_operator_with<F: Fn(&[u8]) -> Vec<u8> + Send + Sync + 'static>(
        &self,
        id: AccountId,
        public_key: PublicKey,
        f: F,
    ) {
        self.0.operator.store(Some(Arc::new(Operator {
            account_id: id,
            signer: AnySigner::arbitrary(Box::new(public_key), f),
        })));
    }

    /// Gets a reference to the configured network.
    pub(crate) fn net(&self) -> &Network {
        &self.0.network.primary
    }

    /// Gets a reference to the configured mirror network.
    pub(crate) fn mirrornet(&self) -> &MirrorNetwork {
        &self.0.network.mirror
    }

    /// Sets the maximum transaction fee to be used when no explicit max transaction fee is set.
    ///
    /// Note: Setting `amount` to zero is "unlimited"
    /// # Panics
    /// - if amount is negative
    pub fn set_default_max_transaction_fee(&self, amount: Hbar) {
        assert!(amount >= Hbar::ZERO);
        self.0.max_transaction_fee_tinybar.store(amount.to_tinybars() as u64, Ordering::Relaxed);
    }

    /// Gets the maximum transaction fee the paying account is willing to pay.
    #[must_use]
    pub fn default_max_transaction_fee(&self) -> Option<Hbar> {
        let val = self.0.max_transaction_fee_tinybar.load(Ordering::Relaxed);

        (val > 0).then(|| Hbar::from_tinybars(val as i64))
    }

    /// Gets the maximum query fee the paying account is willing to pay.
    #[must_use]
    pub fn default_max_query_payment(&self) -> Option<Hbar> {
        let val = self.0.max_query_payment_tinybar.load(Ordering::Relaxed);

        (val > 0).then(|| Hbar::from_tinybars(val as i64))
    }

    /// Sets the maximum query payment to be used when no explicit max query payment is set.
    ///
    /// Note: Setting `amount` to zero is "unlimited"
    /// # Panics
    /// - if amount is negative
    pub fn set_default_max_query_payment(&self, amount: Hbar) {
        assert!(amount >= Hbar::ZERO);
        self.0.max_query_payment_tinybar.store(amount.to_tinybars() as u64, Ordering::Relaxed);
    }

    /// Returns the maximum amount of time that will be spent on a request.
    #[must_use]
    pub fn request_timeout(&self) -> Option<Duration> {
        self.backoff().request_timeout
    }

    /// Sets the maximum amount of time that will be spent on a request.
    pub fn set_request_timeout(&self, timeout: Option<Duration>) {
        self.0.backoff.write().request_timeout = timeout;
    }

    /// Returns the maximum number of attempts for a request.
    #[must_use]
    pub fn max_attempts(&self) -> usize {
        self.backoff().max_attempts
    }

    /// Sets the maximum number of attempts for a request.
    pub fn set_max_attempts(&self, max_attempts: usize) {
        self.0.backoff.write().max_attempts = max_attempts;
    }

    /// The initial backoff for a request being executed.
    #[doc(alias = "initial_backoff")]
    #[must_use]
    pub fn min_backoff(&self) -> Duration {
        self.backoff().initial_backoff
    }

    /// Sets the initial backoff for a request being executed.
    #[doc(alias = "set_initial_backoff")]
    pub fn set_min_backoff(&self, max_backoff: Duration) {
        self.0.backoff.write().max_backoff = max_backoff;
    }

    /// Returns the maximum amount of time a request will wait between attempts.
    #[must_use]
    pub fn max_backoff(&self) -> Duration {
        self.backoff().max_backoff
    }

    /// Sets the maximum amount of time a request will wait between attempts.
    pub fn set_max_backoff(&self, max_backoff: Duration) {
        self.0.backoff.write().max_backoff = max_backoff;
    }

    #[must_use]
    pub(crate) fn backoff(&self) -> ClientBackoff {
        *self.0.backoff.read()
    }

    // keep this internal (repr)
    pub(crate) fn load_operator(&self) -> arc_swap::Guard<Option<Arc<Operator>>> {
        self.0.operator.load()
    }

    // keep this internal (repr)
    pub(crate) fn full_load_operator(&self) -> Option<Arc<Operator>> {
        self.0.operator.load_full()
    }

    /// Send a ping to the given node.
    pub async fn ping(&self, node_account_id: AccountId) -> crate::Result<()> {
        PingQuery::new(node_account_id).execute(self, None).await
    }

    /// Send a ping to the given node, canceling the ping after `timeout` has elapsed.
    pub async fn ping_with_timeout(
        &self,
        node_account_id: AccountId,
        timeout: Duration,
    ) -> crate::Result<()> {
        PingQuery::new(node_account_id).execute(self, Some(timeout)).await
    }

    /// Send a ping to all nodes.
    pub async fn ping_all(&self) -> crate::Result<()> {
        futures_util::future::try_join_all(
            self.net().0.load().node_ids().iter().map(|it| self.ping(*it)),
        )
        .await?;

        Ok(())
    }

    /// Send a ping to all nodes, canceling the ping after `timeout` has elapsed.
    pub async fn ping_all_with_timeout(&self, timeout: Duration) -> crate::Result<()> {
        futures_util::future::try_join_all(
            self.net().0.load().node_ids().iter().map(|it| self.ping_with_timeout(*it, timeout)),
        )
        .await?;

        Ok(())
    }

    /// Returns the frequency at which the network will update (if it will update at all).
    #[must_use = "this function has no side-effects"]
    pub fn network_update_period(&self) -> Option<Duration> {
        *self.0.network_update_tx.borrow()
    }

    /// Sets the frequency at which the network will update.
    ///
    /// Note that network updates will not affect any in-flight requests.
    pub fn set_network_update_period(&self, period: Option<Duration>) {
        self.0.network_update_tx.send_if_modified(|place| {
            let changed = *place == period;
            if changed {
                *place = period;
            }

            changed
        });
    }

    /// Returns the Account ID for the operator.
    #[must_use]
    pub fn get_operator_account_id(&self) -> Option<AccountId> {
        self.load_operator().as_deref().map(|it| it.account_id)
    }

    /// Returns the `PublicKey` for the current operator.
    #[must_use]
    pub fn get_operator_public_key(&self) -> Option<PublicKey> {
        self.load_operator().as_deref().map(|it| it.signer.public_key())
    }
}
// Filename: src/client/network/managed.rs
use std::time::Duration;

use rand::Rng;
use tokio::sync::watch;
use triomphe::Arc;

use super::mirror::MirrorNetwork;
use super::Network;
use crate::NodeAddressBookQuery;

#[derive(Clone)]
pub(crate) struct ManagedNetwork(Arc<ManagedNetworkInner>);

impl ManagedNetwork {
    /// The time to wait before updating the network for the first time.
    const NETWORK_FIRST_UPDATE_DELAY: Duration = Duration::from_secs(10);

    pub(crate) fn new(
        primary: Network,
        mirror: MirrorNetwork,
        // first_update_delay: Duration,
    ) -> Self {
        Self(Arc::new(ManagedNetworkInner { primary, mirror }))
    }

    pub(crate) fn mainnet() -> Self {
        Self::new(Network::mainnet(), MirrorNetwork::mainnet())
    }

    pub(crate) fn testnet() -> Self {
        Self::new(Network::testnet(), MirrorNetwork::testnet())
    }

    pub(crate) fn previewnet() -> Self {
        Self::new(Network::previewnet(), MirrorNetwork::previewnet())
    }
}

impl std::ops::Deref for ManagedNetwork {
    type Target = ManagedNetworkInner;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

pub(crate) struct ManagedNetworkInner {
    /// The network made up of Consensus nodes, IE, the "real"? network.
    pub(crate) primary: Network,
    //
    pub(crate) mirror: MirrorNetwork,
}

pub(crate) fn spawn_network_update(
    network: ManagedNetwork,
    initial_update_interval: Option<Duration>,
) -> watch::Sender<Option<Duration>> {
    let (tx, rx) = watch::channel(initial_update_interval);

    // note: this 100% dies if there's no runtime.
    tokio::task::spawn(update_network(network, rx));

    tx
}

// note: This keeps the `ManagedNetwork` alive (has a strong reference),
// however when network updates are no longer needed the sender can be dropped,
// which will eventually lead to this function returning and the strong count being decremented.
async fn update_network(
    network: ManagedNetwork,
    mut update_interval_rx: watch::Receiver<Option<Duration>>,
) {
    tokio::time::sleep(ManagedNetwork::NETWORK_FIRST_UPDATE_DELAY).await;

    'outer: loop {
        // log::debug!("updating network");
        let start = tokio::time::Instant::now();

        // note: ideally we'd have a `select!` on the channel closing, but, we can't
        // since there's no `async fn closed()`, and honestly, I'm not 100% certain these futures are cancel safe.
        match NodeAddressBookQuery::new()
            .execute_mirrornet(network.mirror.load().channel(), None)
            .await
        {
            Ok(it) => network.primary.update_from_address_book(&it),
            Err(e) => {
                log::warn!("{e:?}");
            }
        }

        // precompued jitter to theoretically avoid a thundering herd problem (in practice this probably won't matter much)
        let jitter = rand::thread_rng().gen_range(0..100);

        // some slightly complicated logic to make sure we
        // 1. Wait until the `update_interval` has elapsed
        // 2. Don't update the network when updating is disabled (`update_interval` == None)
        // 3. Wait the minimal amount of time if the update interval is changed while we're waiting
        //    (say it's been 23 hours out of 24, and then it's changed to a 12 hour interval, we'd want to update *now*)
        'wait: loop {
            // note that `wait_for` will *always* check the current value, even if it's been seen.
            // However, `closed` takes priority over `seen`, which is fine (we'd just want to return rather than wait).
            let update_interval = match update_interval_rx.wait_for(Option::is_some).await {
                // the value is `Some` so this unwrap is okay (although unfortunate)
                Ok(it) => it.unwrap(),
                Err(e) => {
                    log::debug!("client network update shutdown: {e}");
                    return;
                }
            };

            tokio::select! {
                // We very specifically want to use a `sleep_until` here because it means we don't wait at all if the time is in the past
                // and this can be called multiple times per `'outer` loop which means we don't want to wait the sum of all times.
                _ = tokio::time::sleep_until(start + update_interval + Duration::from_millis(jitter)) => {
                    continue 'outer
                }

                // it's fine to not do anything at all with the result here, if it's `Err` we'll pick it up on the next `'wait` loop (the channel will never unclose),
                // if it isn't, well, we'll also pick it up on the next `'wait` loop (it doesn't matter if the value changes again, even to closed).
                _ = update_interval_rx.changed() => continue 'wait,
            }
        }
    }
}
// Filename: src/client/network/mirror.rs
// SPDX-License-Identifier: Apache-2.0

use std::borrow::Cow;
use std::ops::Deref;
use std::time::Duration;

use hyper::Uri;
use hyper_openssl::client::legacy::HttpsConnector;
use hyper_util::client::legacy::connect::HttpConnector;
use once_cell::sync::OnceCell;
use openssl::ssl::{
    SslConnector,
    SslMethod,
    SslVerifyMode,
};
use tonic::transport::{
    Channel,
    Endpoint,
};
use triomphe::Arc;

use crate::ArcSwap;

pub(crate) const MAINNET: &str = "mainnet-public.mirrornode.hedera.com:443";

pub(crate) const TESTNET: &str = "testnet.mirrornode.hedera.com:443";

pub(crate) const PREVIEWNET: &str = "previewnet.mirrornode.hedera.com:443";

#[derive(Default)]
pub(crate) struct MirrorNetwork(ArcSwap<MirrorNetworkData>);

impl Deref for MirrorNetwork {
    type Target = ArcSwap<MirrorNetworkData>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl MirrorNetwork {
    pub(crate) fn mainnet() -> Self {
        Self::network(MAINNET)
    }

    pub(crate) fn testnet() -> Self {
        Self::network(TESTNET)
    }

    pub(crate) fn previewnet() -> Self {
        Self::network(PREVIEWNET)
    }

    fn network(address: &'static str) -> Self {
        Self(ArcSwap::new(Arc::new(MirrorNetworkData::from_static(&[address]))))
    }

    #[cfg(feature = "serde")]
    pub(crate) fn from_addresses(addresses: Vec<Cow<'static, str>>) -> Self {
        Self(ArcSwap::new(Arc::new(MirrorNetworkData::from_addresses(addresses))))
    }
}

#[derive(Clone, Default)]
pub(crate) struct MirrorNetworkData {
    addresses: Vec<Cow<'static, str>>,
    channel: OnceCell<Channel>,
}

impl MirrorNetworkData {
    pub(crate) fn from_addresses(addresses: Vec<Cow<'static, str>>) -> Self {
        Self { addresses, channel: OnceCell::new() }
    }

    pub(crate) fn from_static(network: &[&'static str]) -> Self {
        let addresses = network.iter().map(|&addr| Cow::Borrowed(addr)).collect();

        Self { addresses, channel: OnceCell::new() }
    }

    pub(crate) fn channel(&self) -> Channel {
        self.channel
            .get_or_init(|| {
                let endpoint = self.addresses.iter().next().unwrap();
                let uri = format!("https://{endpoint}");
                let uri_parsed = Uri::from_maybe_shared(uri).unwrap();

                // Configure OpenSSL
                let mut ssl_builder = SslConnector::builder(SslMethod::tls()).unwrap();
                ssl_builder.set_verify(SslVerifyMode::PEER);
                ssl_builder.set_alpn_protos(b"\x02h2").unwrap();

                // Create HTTPS connector with OpenSSL
                let mut http = HttpConnector::new();
                http.enforce_http(false);
                let https = HttpsConnector::with_connector(http, ssl_builder).unwrap();

                Endpoint::from_shared(uri_parsed.to_string())
                    .unwrap()
                    .connect_timeout(Duration::from_secs(10))
                    .keep_alive_timeout(Duration::from_secs(10))
                    .keep_alive_while_idle(true)
                    .tcp_keepalive(Some(Duration::from_secs(10)))
                    .connect_with_connector_lazy(https)
            })
            .clone()
    }

    pub(crate) fn addresses(&self) -> impl Iterator<Item = String> + '_ {
        self.addresses.iter().cloned().map(Cow::into_owned)
    }
}
// Filename: src/client/network/mod.rs
// SPDX-License-Identifier: Apache-2.0

pub(super) mod managed;
pub(super) mod mirror;

use std::borrow::Cow;
use std::collections::{
    BTreeSet,
    HashMap,
};
use std::fmt;
use std::net::Ipv4Addr;
use std::num::NonZeroUsize;
use std::str::FromStr;
use std::time::{
    Duration,
    Instant,
};

use backoff::backoff::Backoff;
use once_cell::sync::OnceCell;
use parking_lot::RwLock;
use rand::thread_rng;
use tonic::transport::{
    Channel,
    Endpoint,
};
use triomphe::Arc;

use crate::{
    AccountId,
    ArcSwap,
    Error,
    NodeAddressBook,
};

pub(crate) const MAINNET: &[(u64, &[&str])] = &[
    (3, &["13.124.142.126", "15.164.44.66", "15.165.118.251", "34.239.82.6", "35.237.200.180"]),
    (4, &["3.130.52.236", "35.186.191.247"]),
    (5, &["3.18.18.254", "23.111.186.250", "35.192.2.25", "74.50.117.35", "107.155.64.98"]),
    (6, &["13.52.108.243", "13.71.90.154", "35.199.161.108", "104.211.205.124"]),
    (7, &["3.114.54.4", "35.203.82.240"]),
    (8, &["35.183.66.150", "35.236.5.219"]),
    (9, &["35.181.158.250", "35.197.192.225"]),
    (10, &["3.248.27.48", "35.242.233.154", "177.154.62.234"]),
    (11, &["13.53.119.185", "35.240.118.96"]),
    (12, &["35.177.162.180", "35.204.86.32", "170.187.184.238"]),
    (13, &["34.215.192.104", "35.234.132.107"]),
    (14, &["35.236.2.27", "52.8.21.141"]),
    (15, &["3.121.238.26", "35.228.11.53"]),
    (16, &["18.157.223.230", "34.91.181.183"]),
    (17, &["18.232.251.19", "34.86.212.247"]),
    (18, &["141.94.175.187"]),
    (19, &["13.244.166.210", "13.246.51.42", "18.168.4.59", "34.89.87.138"]),
    (20, &["34.82.78.255", "52.39.162.216"]),
    (21, &["13.36.123.209", "34.76.140.109"]),
    (22, &["34.64.141.166", "52.78.202.34"]),
    (23, &["3.18.91.176", "35.232.244.145", "69.167.169.208"]),
    (24, &["18.135.7.211", "34.89.103.38"]),
    (25, &["13.232.240.207", "34.93.112.7"]),
    (26, &["13.228.103.14", "34.87.150.174"]),
    (27, &["13.56.4.96", "34.125.200.96"]),
    (28, &["18.139.47.5", "35.198.220.75"]),
    (29, &["34.142.71.129", "54.74.60.120", "80.85.70.197"]),
    (30, &["34.201.177.212", "35.234.249.150"]),
    (31, &["3.77.94.254", "34.107.78.179"]),
];

pub(crate) const TESTNET: &[(u64, &[&str])] = &[
    (3, &["0.testnet.hedera.com", "34.94.106.61", "50.18.132.211"]),
    (4, &["1.testnet.hedera.com", "35.237.119.55", "3.212.6.13"]),
    (5, &["2.testnet.hedera.com", "35.245.27.193", "52.20.18.86"]),
    (6, &["3.testnet.hedera.com", "34.83.112.116", "54.70.192.33"]),
    (7, &["4.testnet.hedera.com", "34.94.160.4", "54.176.199.109"]),
    (8, &["5.testnet.hedera.com", "34.106.102.218", "35.155.49.147"]),
    (9, &["6.testnet.hedera.com", "34.133.197.230", "52.14.252.207"]),
];

pub(crate) const PREVIEWNET: &[(u64, &[&str])] = &[
    (3, &["0.previewnet.hedera.com", "35.231.208.148", "3.211.248.172", "40.121.64.48"]),
    (4, &["1.previewnet.hedera.com", "35.199.15.177", "3.133.213.146", "40.70.11.202"]),
    (5, &["2.previewnet.hedera.com", "35.225.201.195", "52.15.105.130", "104.43.248.63"]),
    (6, &["3.previewnet.hedera.com", "35.247.109.135", "54.241.38.1", "13.88.22.47"]),
    (7, &["4.previewnet.hedera.com", "35.235.65.51", "54.177.51.127", "13.64.170.40"]),
    (8, &["5.previewnet.hedera.com", "34.106.247.65", "35.83.89.171", "13.78.232.192"]),
    (9, &["6.previewnet.hedera.com", "34.125.23.49", "50.18.17.93", "20.150.136.89"]),
];

#[derive(Default)]
pub(crate) struct Network(pub(crate) ArcSwap<NetworkData>);

impl Network {
    pub(super) fn mainnet() -> Self {
        NetworkData::from_static(MAINNET).into()
    }

    pub(super) fn testnet() -> Self {
        NetworkData::from_static(TESTNET).into()
    }

    pub(super) fn previewnet() -> Self {
        NetworkData::from_static(PREVIEWNET).into()
    }

    pub(super) fn from_addresses(addresses: &HashMap<String, AccountId>) -> crate::Result<Self> {
        Ok(NetworkData::from_addresses(addresses)?.into())
    }

    fn try_rcu<T: Into<Arc<NetworkData>>, E, F: FnMut(&Arc<NetworkData>) -> Result<T, E>>(
        &self,
        mut f: F,
    ) -> Result<Arc<NetworkData>, E> {
        // note: we can't use the `arc_swap` rcu function because we return a result
        let mut cur = self.0.load();
        loop {
            let new = f(&cur)?.into();
            let prev = self.0.compare_and_swap(&*cur, new);
            let swapped = Arc::ptr_eq(&*cur, &*prev);
            if swapped {
                return Ok(arc_swap::Guard::into_inner(cur));
            }

            cur = prev;
        }
    }

    fn rcu<T: Into<Arc<NetworkData>>, F: FnMut(&Arc<NetworkData>) -> T>(
        &self,
        mut f: F,
    ) -> Arc<NetworkData> {
        match self.try_rcu(|it| -> Result<T, std::convert::Infallible> { Ok(f(it)) }) {
            Ok(it) => it,
            Err(e) => match e {},
        }
    }

    pub(crate) fn update_from_addresses(
        &self,
        addresses: &HashMap<String, AccountId>,
    ) -> crate::Result<()> {
        self.try_rcu(|old| old.with_addresses(addresses))?;

        Ok(())
    }

    pub(crate) fn update_from_address_book(&self, address_book: &NodeAddressBook) {
        // todo: skip the updating whem `map` is the same and `connections` is the same.
        self.rcu(|old| NetworkData::with_address_book(old, address_book));
    }
}

impl From<NetworkData> for Network {
    fn from(value: NetworkData) -> Self {
        Self(ArcSwap::new(Arc::new(value)))
    }
}

// note: `Default` here is mostly only useful so that we don't need to implement `from_addresses` twice, notably this doesn't allocate.
#[derive(Default)]
pub(crate) struct NetworkData {
    map: HashMap<AccountId, usize>,
    node_ids: Box<[AccountId]>,
    backoff: RwLock<NodeBackoff>,
    // Health stuff has to be in an Arc because it needs to stick around even if the map changes.
    health: Box<[Arc<parking_lot::RwLock<NodeHealth>>]>,
    connections: Box<[NodeConnection]>,
}

impl NetworkData {
    pub(crate) fn from_addresses(addresses: &HashMap<String, AccountId>) -> crate::Result<Self> {
        Self::default().with_addresses(addresses)
    }

    pub(crate) fn from_static(network: &'static [(u64, &'static [&'static str])]) -> Self {
        let mut map = HashMap::with_capacity(network.len());
        let mut node_ids = Vec::with_capacity(network.len());
        let mut connections = Vec::with_capacity(network.len());
        let mut health = Vec::with_capacity(network.len());

        for (i, (num, address)) in network.iter().copied().enumerate() {
            let node_account_id = AccountId::from(num);

            map.insert(node_account_id, i);
            node_ids.push(node_account_id);
            health.push(Arc::default());
            connections.push(NodeConnection::new_static(address));
        }

        Self {
            map,
            node_ids: node_ids.into_boxed_slice(),
            health: health.into_boxed_slice(),
            connections: connections.into_boxed_slice(),
            backoff: NodeBackoff::default().into(),
        }
    }

    fn with_address_book(old: &Self, address_book: &NodeAddressBook) -> Self {
        let address_book = &address_book.node_addresses;

        let mut map = HashMap::with_capacity(address_book.len());
        let mut node_ids = Vec::with_capacity(address_book.len());
        let mut connections = Vec::with_capacity(address_book.len());
        let mut health = Vec::with_capacity(address_book.len());

        for (i, address) in address_book.iter().enumerate() {
            let new: BTreeSet<_> = address
                .service_endpoints
                .iter()
                .filter(|it| it.port() == NodeConnection::PLAINTEXT_PORT)
                .map(|it| (*it.ip()).into())
                .collect();

            // if the node is the exact same we want to reuse everything (namely the connections and `healthy`).
            // if the node has different routes then we still want to reuse `healthy` but replace the channel with a new channel.
            // if the node just flat out doesn't exist in `old`, we want to add the new node.
            // and, last but not least, if the node doesn't exist in `new` we want to get rid of it.
            let upsert = match old.map.get(&address.node_account_id) {
                Some(&account) => {
                    let connection =
                        match old.connections[account].addresses.symmetric_difference(&new).count()
                        {
                            0 => old.connections[account].clone(),
                            _ => NodeConnection { addresses: new, channel: OnceCell::new() },
                        };

                    (old.health[account].clone(), connection)
                }
                None => {
                    (Arc::default(), NodeConnection { addresses: new, channel: OnceCell::new() })
                }
            };

            map.insert(address.node_account_id, i);
            node_ids.push(address.node_account_id);
            health.push(upsert.0);
            connections.push(upsert.1);
        }

        Self {
            map,
            node_ids: node_ids.into_boxed_slice(),
            health: health.into_boxed_slice(),
            connections: connections.into_boxed_slice(),
            backoff: NodeBackoff::default().into(),
        }
    }

    fn with_addresses(&self, addresses: &HashMap<String, AccountId>) -> crate::Result<Self> {
        use std::collections::hash_map::Entry;
        let mut map: HashMap<AccountId, usize> = HashMap::new();
        let mut node_ids = Vec::new();
        let mut connections: Vec<NodeConnection> = Vec::new();
        let mut health = Vec::new();

        for (address, node) in addresses {
            let next_index = node_ids.len();

            let address = address.parse()?;

            match map.entry(*node) {
                Entry::Occupied(entry) => {
                    connections[*entry.get()].addresses.insert(address);
                }
                Entry::Vacant(entry) => {
                    entry.insert(next_index);
                    node_ids.push(*node);
                    // fixme: keep the channel around more.
                    connections.push(NodeConnection {
                        addresses: BTreeSet::from([address]),
                        channel: OnceCell::new(),
                    });

                    health.push(match self.map.get(node) {
                        Some(it) => self.health[*it].clone(),
                        None => Arc::default(),
                    });
                }
            };
        }

        Ok(Self {
            map,
            node_ids: node_ids.into_boxed_slice(),
            health: health.into_boxed_slice(),
            connections: connections.into_boxed_slice(),
            backoff: NodeBackoff::default().into(),
        })
    }

    pub(crate) fn node_ids(&self) -> &[AccountId] {
        &self.node_ids
    }

    pub(crate) fn node_indexes_for_ids(&self, ids: &[AccountId]) -> crate::Result<Vec<usize>> {
        let mut indexes = Vec::new();
        for id in ids {
            indexes.push(
                self.map
                    .get(id)
                    .copied()
                    .ok_or_else(|| Error::NodeAccountUnknown(Box::new(*id)))?,
            );
        }

        Ok(indexes)
    }

    // Sets the max attempts that an unhealthy node can retry
    pub(crate) fn set_max_node_attempts(&self, max_attempts: Option<NonZeroUsize>) {
        self.backoff.write().max_attempts = max_attempts
    }

    // Returns the max attempts that an unhealthy node can retry
    pub(crate) fn max_node_attempts(&self) -> Option<NonZeroUsize> {
        self.backoff.read().max_attempts
    }

    // Sets the max backoff for a node.
    pub(crate) fn set_max_backoff(&self, max_backoff: Duration) {
        self.backoff.write().max_backoff = max_backoff
    }

    // Return the initial backoff for a node.
    #[must_use]
    pub(crate) fn max_backoff(&self) -> Duration {
        self.backoff.read().max_backoff
    }

    // Sets the initial backoff for a request being executed.
    pub(crate) fn set_min_backoff(&self, min_backoff: Duration) {
        self.backoff.write().min_backoff = min_backoff
    }

    // Return the initial backoff for a request being executed.
    #[must_use]
    pub(crate) fn min_backoff(&self) -> Duration {
        self.backoff.read().min_backoff
    }

    pub(crate) fn mark_node_unhealthy(&self, node_index: usize) {
        let now = Instant::now();

        self.health[node_index].write().mark_unhealthy(*self.backoff.read(), now);
    }

    pub(crate) fn mark_node_healthy(&self, node_index: usize) {
        self.health[node_index].write().mark_healthy(Instant::now());
    }

    pub(crate) fn is_node_healthy(&self, node_index: usize, now: Instant) -> bool {
        // a healthy node has a healthiness before now.

        self.health[node_index].read().is_healthy(now)
    }

    pub(crate) fn node_recently_pinged(&self, node_index: usize, now: Instant) -> bool {
        self.health[node_index].read().recently_pinged(now)
    }

    pub(crate) fn healthy_node_indexes(&self, time: Instant) -> impl Iterator<Item = usize> + '_ {
        (0..self.node_ids.len()).filter(move |index| self.is_node_healthy(*index, time))
    }

    pub(crate) fn healthy_node_ids(&self) -> impl Iterator<Item = AccountId> + '_ {
        self.healthy_node_indexes(Instant::now()).map(|it| self.node_ids[it])
    }
    pub(crate) fn random_node_ids(&self) -> Vec<AccountId> {
        let mut node_ids: Vec<_> = self.healthy_node_ids().collect();
        // self.remove_dead_nodes();

        if node_ids.is_empty() {
            log::warn!("No healthy nodes, randomly picking some unhealthy ones");
            // hack, slowpath, don't care perf, fix this better later tho.
            node_ids = self.node_ids.to_vec();
        }

        let node_sample_amount = (node_ids.len() + 2) / 3;

        let node_id_indecies =
            rand::seq::index::sample(&mut thread_rng(), node_ids.len(), node_sample_amount);

        node_id_indecies.into_iter().map(|index| node_ids[index]).collect()
    }

    pub(crate) fn channel(&self, index: usize) -> (AccountId, Channel) {
        let id = self.node_ids[index];

        let channel = self.connections[index].channel();

        (id, channel)
    }

    pub(crate) fn addresses(&self) -> HashMap<String, AccountId> {
        self.map
            .iter()
            .flat_map(|(&account, &index)| {
                self.connections[index].addresses.iter().map(move |it| (it.to_string(), account))
            })
            .collect()
    }
}

#[derive(Default)]
enum NodeHealth {
    /// The node has never been used, so we don't know anything about it.
    ///
    /// However, we'll vaguely consider it healthy (`is_healthy` returns `true`).
    #[default]
    Unused,

    /// When we used or pinged the node we got some kind of error with it (like a BUSY response).
    ///
    /// Repeated errors cause the backoff to increase.
    ///
    /// Once we've reached `healthyAt` the node is *semantically* in the ``unused`` state,
    /// other than retaining the backoff until a `healthy` request happens.
    Unhealthy { backoff: NodeBackoff, healthy_at: Instant, attempts: usize },

    /// When we last used the node the node acted as normal, so, we get to treat it as a healthy node for 15 minutes.
    Healthy { used_at: Instant },
}

#[derive(Copy, Clone)]
pub(crate) struct NodeBackoff {
    pub(crate) current_interval: Duration,
    pub(crate) max_backoff: Duration,
    pub(crate) min_backoff: Duration,
    pub(crate) max_attempts: Option<NonZeroUsize>,
}

impl Default for NodeBackoff {
    fn default() -> Self {
        Self {
            current_interval: Duration::from_millis(250),
            max_backoff: Duration::from_secs(60 * 60),
            min_backoff: Duration::from_millis(250),
            max_attempts: NonZeroUsize::new(10),
        }
    }
}

impl NodeHealth {
    fn backoff(&self, backoff_config: NodeBackoff) -> (backoff::ExponentialBackoff, usize) {
        // If node is already labeled Unhealthy, preserve backoff and attempt amount
        // For new Unhealthy nodes, apply config and start attempt count at 0
        let (node_backoff, attempts) = match self {
            Self::Unhealthy { backoff, healthy_at: _, attempts } => (*backoff, attempts),
            _ => (backoff_config, &0),
        };

        (
            backoff::ExponentialBackoff {
                current_interval: node_backoff.current_interval,
                initial_interval: node_backoff.min_backoff,
                max_elapsed_time: None,
                max_interval: node_backoff.max_backoff,
                ..Default::default()
            },
            *attempts + 1,
        )
    }

    pub(crate) fn mark_unhealthy(&mut self, backoff_config: NodeBackoff, now: Instant) {
        let (mut backoff, unhealthy_node_attempts) = self.backoff(backoff_config);

        // Remove node if max_attempts has been reached and max_attempts is not 0
        if backoff_config
            .max_attempts
            .map_or(false, |max_attempts| unhealthy_node_attempts > max_attempts.get())
        {
            log::debug!("Node has reached the max amount of retries, removing from network")
        }

        // Generates the next current_interval with a random duration
        let next_backoff = backoff.next_backoff().expect("`max_elapsed_time` is hardwired to None");

        let healthy_at = now + next_backoff;

        *self = Self::Unhealthy {
            backoff: NodeBackoff {
                current_interval: next_backoff,
                max_backoff: backoff.max_interval,
                min_backoff: backoff.initial_interval,
                max_attempts: backoff_config.max_attempts,
            },
            healthy_at,
            attempts: unhealthy_node_attempts,
        };
    }

    pub(crate) fn mark_healthy(&mut self, now: Instant) {
        *self = Self::Healthy { used_at: now };
    }

    pub(crate) fn is_healthy(&self, now: Instant) -> bool {
        // a healthy node has a healthiness before now.
        match self {
            Self::Unhealthy { backoff: _, healthy_at, attempts: _ } => healthy_at < &now,
            _ => true,
        }
    }

    pub(crate) fn recently_pinged(&self, now: Instant) -> bool {
        match self {
            // when used at was less than 15 minutes ago we consider ourselves "pinged", otherwise we're basically `.unused`.
            Self::Healthy { used_at } => now < *used_at + Duration::from_secs(15 * 60),
            // likewise an unhealthy node (healthyAt > now) has been "pinged" (although we don't want to use it probably we at least *have* gotten *something* from it)
            Self::Unhealthy { backoff: _, healthy_at, attempts: _ } => now < *healthy_at,

            // an unused node is by definition not pinged.
            Self::Unused => false,
        }
    }
}

#[derive(Clone, Ord, PartialOrd, Eq, PartialEq)]
struct HostAndPort {
    host: Cow<'static, str>,
    port: u16,
}

impl HostAndPort {
    const fn from_static(host: &'static str) -> Self {
        Self { host: Cow::Borrowed(host), port: NodeConnection::PLAINTEXT_PORT }
    }
}

impl FromStr for HostAndPort {
    type Err = crate::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (host, port) = s.split_once(':').ok_or_else(|| Error::basic_parse("Invalid uri"))?;

        Ok(Self {
            host: Cow::Owned(host.to_owned()),
            port: port.parse().map_err(Error::basic_parse)?,
        })
    }
}

impl fmt::Display for HostAndPort {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.host, self.port)
    }
}

impl From<Ipv4Addr> for HostAndPort {
    fn from(value: Ipv4Addr) -> Self {
        Self { host: Cow::Owned(value.to_string()), port: NodeConnection::PLAINTEXT_PORT }
    }
}

#[derive(Clone)]
struct NodeConnection {
    addresses: BTreeSet<HostAndPort>,
    channel: OnceCell<Channel>,
}

impl NodeConnection {
    const PLAINTEXT_PORT: u16 = 50211;

    fn new_static(addresses: &[&'static str]) -> NodeConnection {
        Self {
            addresses: addresses.iter().copied().map(HostAndPort::from_static).collect(),
            channel: OnceCell::default(),
        }
    }

    pub(crate) fn channel(&self) -> Channel {
        let channel = self
            .channel
            .get_or_init(|| {
                let addresses = self.addresses.iter().map(|it| {
                    Endpoint::from_shared(format!("tcp://{it}"))
                        .unwrap()
                        .keep_alive_timeout(Duration::from_secs(10))
                        .keep_alive_while_idle(true)
                        .tcp_keepalive(Some(Duration::from_secs(10)))
                        .connect_timeout(Duration::from_secs(10))
                });

                Channel::balance_list(addresses)
            })
            .clone();

        channel
    }
}
// Filename: src/client/operator.rs
use crate::signer::AnySigner;
use crate::{
    AccountId,
    PublicKey,
    TransactionId,
};

#[derive(Debug)]
pub(crate) struct Operator {
    pub(crate) account_id: AccountId,
    pub(crate) signer: AnySigner,
}

impl Operator {
    #[must_use]
    pub(crate) fn sign(&self, body_bytes: &[u8]) -> (PublicKey, Vec<u8>) {
        self.signer.sign(body_bytes)
    }

    #[must_use]
    pub(crate) fn generate_transaction_id(&self) -> TransactionId {
        TransactionId::generate(self.account_id)
    }
}
// Filename: src/contract/contract_bytecode_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    ContractId,
    Error,
    FromProtobuf,
    Query,
    ToProtobuf,
    ValidateChecksums,
};

/// Get the runtime bytecode for a smart contract instance.
pub type ContractBytecodeQuery = Query<ContractBytecodeQueryData>;

#[derive(Default, Debug, Clone)]
pub struct ContractBytecodeQueryData {
    /// The contract for which information is requested.
    contract_id: Option<ContractId>,
}

impl ContractBytecodeQuery {
    /// Gets the contract for which information is requested.
    #[must_use]
    pub fn get_contract_id(&self) -> Option<ContractId> {
        self.data.contract_id
    }

    /// Sets the contract for which information is requested.
    pub fn contract_id(&mut self, contract_id: ContractId) -> &mut Self {
        self.data.contract_id = Some(contract_id);
        self
    }
}

impl From<ContractBytecodeQueryData> for AnyQueryData {
    #[inline]
    fn from(data: ContractBytecodeQueryData) -> Self {
        Self::ContractBytecode(data)
    }
}

impl ToQueryProtobuf for ContractBytecodeQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let contract_id = self.contract_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::ContractGetBytecode(
                services::ContractGetBytecodeQuery { contract_id, header: Some(header) },
            )),
        }
    }
}

impl QueryExecute for ContractBytecodeQueryData {
    type Response = Vec<u8>;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async {
            SmartContractServiceClient::new(channel).contract_get_bytecode(request).await
        })
    }
}

impl ValidateChecksums for ContractBytecodeQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.contract_id.validate_checksums(ledger_id)
    }
}

impl FromProtobuf<services::response::Response> for Vec<u8> {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let pb = pb_getv!(pb, ContractGetBytecodeResponse, services::response::Response);

        Ok(pb.bytecode)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        ContractBytecodeQuery,
        ContractId,
        Hbar,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    ContractGetBytecode(
                        ContractGetBytecodeQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            contract_id: Some(
                                ContractId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    contract: Some(
                                        ContractNum(
                                            5005,
                                        ),
                                    ),
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &ContractBytecodeQuery::new()
                .contract_id(crate::ContractId::new(0, 0, 5005))
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        );
    }

    #[test]
    fn get_set_contract_id() {
        let mut query = ContractBytecodeQuery::new();
        query.contract_id(ContractId::new(0, 0, 5005));

        assert_eq!(query.get_contract_id(), Some(ContractId::new(0, 0, 5005)));
    }
}
// Filename: src/contract/contract_call_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    ContractFunctionParameters,
    ContractFunctionResult,
    ContractId,
    Error,
    Query,
    ToProtobuf,
    ValidateChecksums,
};

/// Call a function of the given smart contract instance.
/// It will consume the entire given amount of gas.
///
/// This is performed locally on the particular node that the client is communicating with.
/// It cannot change the state of the contract instance (and so, cannot spend
/// anything from the instance's cryptocurrency account).
///
pub type ContractCallQuery = Query<ContractCallQueryData>;

#[derive(Default, Debug, Clone)]
pub struct ContractCallQueryData {
    /// The contract instance to call.
    contract_id: Option<ContractId>,

    /// The amount of gas to use for the call.
    gas: u64,

    /// The function parameters as their raw bytes.
    function_parameters: Vec<u8>,

    /// The sender for this transaction.
    sender_account_id: Option<AccountId>,
}

impl ContractCallQuery {
    /// Gets the contract instance to call.
    #[must_use]
    pub fn get_contract_id(&self) -> Option<ContractId> {
        self.data.contract_id
    }

    /// Sets the contract to make a static call against.
    pub fn contract_id(&mut self, contract_id: ContractId) -> &mut Self {
        self.data.contract_id = Some(contract_id);
        self
    }

    /// Gets the amount of gas to use for the call.
    #[must_use]
    pub fn get_gas(&self) -> u64 {
        self.data.gas
    }

    /// Sets the amount of gas to use for the call.
    pub fn gas(&mut self, gas: u64) -> &mut Self {
        self.data.gas = gas;
        self
    }

    /// Gets the function parameters as their raw bytes.
    #[must_use]
    pub fn get_contract_parameters(&self) -> &[u8] {
        self.data.function_parameters.as_ref()
    }

    /// Sets the function parameters as their raw bytes.
    pub fn function_parameters(&mut self, data: Vec<u8>) -> &mut Self {
        self.data.function_parameters = data;
        self
    }

    /// Sets the function with no parameters.
    pub fn function(&mut self, name: &str) -> &mut Self {
        self.function_with_parameters(name, &ContractFunctionParameters::new())
    }

    /// Sets the function with parameters.
    pub fn function_with_parameters(
        &mut self,
        name: &str,
        parameters: &ContractFunctionParameters,
    ) -> &mut Self {
        self.function_parameters(parameters.to_bytes(Some(name)))
    }

    /// Gets the sender for this transaction.
    #[must_use]
    pub fn get_sender_account_id(&self) -> Option<AccountId> {
        self.data.sender_account_id
    }

    /// Sets the sender for this transaction.
    pub fn sender_account_id(&mut self, sender_account_id: AccountId) -> &mut Self {
        self.data.sender_account_id = Some(sender_account_id);
        self
    }
}

impl From<ContractCallQueryData> for AnyQueryData {
    #[inline]
    fn from(data: ContractCallQueryData) -> Self {
        Self::ContractCall(data)
    }
}

impl ToQueryProtobuf for ContractCallQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let contract_id = self.contract_id.to_protobuf();
        let sender_id = self.sender_account_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::ContractCallLocal(
                #[allow(deprecated)]
                services::ContractCallLocalQuery {
                    contract_id,
                    gas: self.gas as i64,
                    function_parameters: self.function_parameters.clone(),
                    max_result_size: 0,
                    header: Some(header),
                    sender_id,
                },
            )),
        }
    }
}

impl QueryExecute for ContractCallQueryData {
    type Response = ContractFunctionResult;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async {
            SmartContractServiceClient::new(channel).contract_call_local_method(request).await
        })
    }
}

impl ValidateChecksums for ContractCallQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.contract_id.validate_checksums(ledger_id)?;
        self.sender_account_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::query::ToQueryProtobuf;
    use crate::{
        AccountId,
        ContractCallQuery,
        ContractFunctionParameters,
        ContractId,
        Hbar,
    };

    fn make_query() -> ContractCallQuery {
        let mut query = ContractCallQuery::new();

        query
            .contract_id(crate::ContractId::new(0, 0, 5005))
            .gas(1541)
            .sender_account_id("1.2.3".parse().unwrap())
            .max_payment_amount(Hbar::from_tinybars(100_000));

        query
    }

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    ContractCallLocal(
                        ContractCallLocalQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            contract_id: Some(
                                ContractId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    contract: Some(
                                        ContractNum(
                                            5005,
                                        ),
                                    ),
                                },
                            ),
                            gas: 1541,
                            function_parameters: [
                                18,
                                74,
                                131,
                                250,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                64,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                128,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                5,
                                72,
                                101,
                                108,
                                108,
                                111,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                6,
                                119,
                                111,
                                114,
                                108,
                                100,
                                33,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                            ],
                            max_result_size: 0,
                            sender_id: Some(
                                AccountId {
                                    shard_num: 1,
                                    realm_num: 2,
                                    account: Some(
                                        AccountNum(
                                            3,
                                        ),
                                    ),
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &make_query()
                .function_with_parameters(
                    "foo",
                    ContractFunctionParameters::new().add_string("Hello").add_string("world!"),
                )
                .data
                .to_query_protobuf(services::QueryHeader::default()),
        );
    }

    #[test]
    fn function_parameters() {
        expect![[r#"
            Query {
                query: Some(
                    ContractCallLocal(
                        ContractCallLocalQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            contract_id: Some(
                                ContractId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    contract: Some(
                                        ContractNum(
                                            5005,
                                        ),
                                    ),
                                },
                            ),
                            gas: 1541,
                            function_parameters: [
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                64,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                128,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                5,
                                72,
                                101,
                                108,
                                108,
                                111,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                6,
                                119,
                                111,
                                114,
                                108,
                                100,
                                33,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                            ],
                            max_result_size: 0,
                            sender_id: Some(
                                AccountId {
                                    shard_num: 1,
                                    realm_num: 2,
                                    account: Some(
                                        AccountNum(
                                            3,
                                        ),
                                    ),
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &make_query()
                .function_parameters(
                    ContractFunctionParameters::new()
                        .add_string("Hello")
                        .add_string("world!")
                        .to_bytes(None),
                )
                .data
                .to_query_protobuf(services::QueryHeader::default()),
        );
    }

    #[test]
    fn get_set_contract_id() {
        let mut query = ContractCallQuery::new();
        query.contract_id(ContractId::new(0, 0, 5005));

        assert_eq!(query.get_contract_id(), Some(ContractId::new(0, 0, 5005)));
    }

    #[test]
    fn get_set_gas() {
        let mut query = ContractCallQuery::new();
        query.gas(1541);

        assert_eq!(query.get_gas(), 1541);
    }

    #[test]
    fn get_set_contract_parameters() {
        const BYTES: [u8; 6] = [0x0a, 0x0b, 0x0c, 0x01, 0x02, 0x03];
        let mut query = ContractCallQuery::new();
        query.function_parameters(Vec::from(BYTES));

        assert_eq!(query.get_contract_parameters(), &BYTES);
    }

    #[test]
    fn get_set_sender_account_id() {
        let mut query = ContractCallQuery::new();
        query.sender_account_id(AccountId::new(1, 2, 3));

        assert_eq!(query.get_sender_account_id(), Some(AccountId::new(1, 2, 3)));
    }
}
// Filename: src/contract/contract_create_flow.rs
// SPDX-License-Identifier: Apache-2.0

use time::Duration;

use crate::signer::AnySigner;
use crate::staked_id::StakedId;
use crate::{
    AccountId,
    Client,
    ContractCreateTransaction,
    Error,
    FileAppendTransaction,
    FileCreateTransaction,
    FileDeleteTransaction,
    FileId,
    Hbar,
    Key,
    PrivateKey,
    PublicKey,
    TransactionResponse,
};

/// Create a new smart contract
///
/// The operation of this flow is as follows:
/// 1. Create a file for the contract's bytecode (via a [`FileCreateTransaction`] and zero or more [`FileAppendTransaction`]s)
/// 2. Execute a [`ContractCreateTransaction`] using the provided information and the newly created file.
/// 3. Delete the file created in step 1.
#[derive(Default, Debug)]
pub struct ContractCreateFlow {
    bytecode: Vec<u8>,
    file_append_max_chunks: Option<usize>,
    node_account_ids: Option<Vec<AccountId>>,
    contract_data: ContractData,
}

impl ContractCreateFlow {
    /// Create a new `ContractCreateFlow`.
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns bytes of the smart contract.
    #[must_use]
    pub fn get_bytecode(&self) -> &[u8] {
        &self.bytecode
    }

    /// Sets the raw bytes of the smart contract.
    pub fn bytecode(&mut self, bytecode: Vec<u8>) -> &mut Self {
        self.bytecode = bytecode;

        self
    }

    /// Sets the bytecode of the smart contract in hex.
    ///
    /// # Errors
    /// - [`Error::BasicParse`](Error::BasicParse) if `bytecode` is invalid hex.
    pub fn bytecode_hex(&mut self, bytecode: &str) -> crate::Result<&mut Self> {
        self.bytecode = hex::decode(bytecode).map_err(Error::basic_parse)?;

        Ok(self)
    }

    /// Returns the account IDs of the nodes the transactions may be submitted to.
    #[must_use]
    pub fn get_node_account_ids(&self) -> Option<&[AccountId]> {
        self.node_account_ids.as_deref()
    }

    /// Sets the account IDs of the nodes the transactions may be submitted to.
    ///
    /// Defaults to the full list of nodes configured on the client.
    pub fn node_account_ids(
        &mut self,
        node_account_ids: impl IntoIterator<Item = AccountId>,
    ) -> &mut Self {
        self.node_account_ids = Some(node_account_ids.into_iter().collect());

        self
    }

    /// Returns maximum number of chunks the `FileAppendTransaction` can be split into.
    ///
    /// If null, the default value for a [`FileAppendTransaction`] will be used.
    #[must_use]
    pub fn get_max_chunks(&self) -> Option<usize> {
        self.file_append_max_chunks
    }

    /// Sets the maximum number of chunks the [`FileAppendTransaction`] can be split into.
    pub fn max_chunks(&mut self, max_chunks: usize) -> &mut Self {
        self.file_append_max_chunks = Some(max_chunks);

        self
    }

    /// Returns the parameters to pass to the constructor.
    #[must_use]
    pub fn get_constructor_parameters(&self) -> &[u8] {
        &self.contract_data.constructor_parameters
    }

    /// Sets the parameters to pass to the constructor.
    pub fn constructor_parameters(
        &mut self,
        constructor_parameters: impl Into<Vec<u8>>,
    ) -> &mut Self {
        self.contract_data.constructor_parameters = constructor_parameters.into();

        self
    }

    /// Returns the gas limit to deploy the smart contract.
    #[must_use]
    pub fn get_gas(&self) -> u64 {
        self.contract_data.gas
    }

    /// Sets the gas limit to deploy the smart contract.
    pub fn gas(&mut self, gas: u64) -> &mut Self {
        self.contract_data.gas = gas;

        self
    }

    /// Returns the initial balance to put into the cryptocurrency account associated with the new
    /// smart contract.
    #[must_use]
    pub fn get_initial_balance(&self) -> Hbar {
        self.contract_data.initial_balance
    }

    /// Sets the initial balance to put into the cryptocurrency account associated with the new
    /// smart contract.
    pub fn initial_balance(&mut self, initial_balance: Hbar) -> &mut Self {
        self.contract_data.initial_balance = initial_balance;

        self
    }

    /// Retunrs the maximum number of tokens that the contract can be automatically associated with.
    #[must_use]
    pub fn get_max_automatic_token_associations(&self) -> i32 {
        self.contract_data.max_automatic_token_associations
    }

    /// Sets the maximum number of tokens that the contract can be automatically associated with.
    pub fn max_automatic_token_associations(
        &mut self,
        max_automatic_token_associations: i32,
    ) -> &mut Self {
        self.contract_data.max_automatic_token_associations = max_automatic_token_associations;

        self
    }

    /// If `true`, the contract will decline receiving a staking reward.
    ///
    /// The default value is false.
    #[must_use]
    pub fn get_decline_staking_reward(&self) -> bool {
        self.contract_data.decline_staking_reward
    }

    /// If set to `true`, the contract will decline receiving a staking reward.
    pub fn decline_staking_reward(&mut self, decline_staking_reward: bool) -> &mut Self {
        self.contract_data.decline_staking_reward = decline_staking_reward;

        self
    }

    /// Reutrns the admin key for the new contract.
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.contract_data.admin_key.as_ref()
    }

    /// Sets the admin key for the new contract.
    pub fn admin_key(&mut self, admin_key: impl Into<Key>) -> &mut Self {
        self.contract_data.admin_key = Some(admin_key.into());

        self
    }

    /// Returns the account to be used at the contract's expiration time to extend the life of the contract.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.contract_data.auto_renew_account_id
    }

    /// Sets the account to be used at the contract's expiration time to extend the life of the contract.
    pub fn auto_renew_account_id(&mut self, auto_renew_account_id: AccountId) -> &mut Self {
        self.contract_data.auto_renew_account_id = Some(auto_renew_account_id);

        self
    }

    /// Returns the auto renew period for the smart contract.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.contract_data.auto_renew_period
    }

    /// Sets the auto renew period for the smart contract.
    pub fn auto_renew_period(&mut self, auto_renew_period: Duration) -> &mut Self {
        self.contract_data.auto_renew_period = Some(auto_renew_period);

        self
    }

    /// Returns the memo for the new smart contract.
    #[must_use]
    pub fn get_contract_memo(&self) -> Option<&str> {
        self.contract_data.contract_memo.as_deref()
    }

    /// Sets the memo for the new smart contract.
    pub fn contract_memo(&mut self, contract_memo: String) -> &mut Self {
        self.contract_data.contract_memo = Some(contract_memo);

        self
    }

    /// Returns the ID of the account to which the contract is staking.
    pub fn get_staked_account_id(&self) -> Option<AccountId> {
        self.contract_data.staked_id.and_then(StakedId::to_account_id)
    }

    /// Sets the ID of the account to which the contract is staking.
    pub fn staked_account_id(&mut self, staked_account_id: AccountId) -> &mut Self {
        self.contract_data.staked_id = Some(StakedId::AccountId(staked_account_id));

        self
    }

    /// Returns ID of the node to which the contract is staking.
    pub fn get_staked_node_id(&self) -> Option<u64> {
        self.contract_data.staked_id.and_then(StakedId::to_node_id)
    }

    /// Sets the ID of the node to which the contract is staking.
    pub fn staked_node_id(&mut self, staked_node_id: u64) -> &mut Self {
        self.contract_data.staked_id = Some(StakedId::NodeId(staked_node_id));

        self
    }

    /// Sets the client to use for freezing the generated *``ContractCreateTransaction``*.
    ///
    /// By default freezing will use the client provided to ``execute``.
    ///
    /// Note: This *only* affects the ``ContractCreateTransaction`` currently, that is not guaranteed to always be the case.
    pub fn freeze_with(&mut self, client: Client) -> &mut Self {
        self.contract_data.freeze_with_client = Some(client);

        self
    }

    /// Sets the signer for use in the ``ContractCreateTransaction``
    ///
    /// Important: Only *one* signer is allowed.
    pub fn sign(&mut self, key: PrivateKey) -> &mut Self {
        self.contract_data.signer = Some(AnySigner::PrivateKey(key));

        self
    }

    /// Sets the signer for use in the ``ContractCreateTransaction``
    ///
    /// Important: Only *one* signer is allowed.
    pub fn sign_with<F: Fn(&[u8]) -> Vec<u8> + Send + Sync + 'static>(
        &mut self,
        public_key: PublicKey,
        signer: F,
    ) -> &mut Self {
        self.contract_data.signer = Some(AnySigner::arbitrary(Box::new(public_key), signer));

        self
    }

    /// Generates the required transactions and executes them all.
    pub async fn execute(&self, client: &Client) -> crate::Result<TransactionResponse> {
        self.execute_with_optional_timeout(client, None).await
    }

    /// Generates the required transactions and executes them all.
    pub async fn execute_with_timeout(
        &self,
        client: &Client,
        timeout_per_transaction: std::time::Duration,
    ) -> crate::Result<TransactionResponse> {
        self.execute_with_optional_timeout(client, Some(timeout_per_transaction)).await
    }

    async fn execute_with_optional_timeout(
        &self,
        client: &Client,
        timeout_per_transaction: Option<std::time::Duration>,
    ) -> crate::Result<TransactionResponse> {
        // todo: proper error
        let operator_public_key = client
            .load_operator()
            .as_deref()
            .map(|it| it.signer.public_key())
            .expect("Must call `Client.set_operator` to use contract create flow");

        let bytecode = split_bytecode(&self.bytecode);
        let file_id = make_file_create_transaction(
            bytecode.0,
            operator_public_key,
            self.node_account_ids.clone(),
        )
        .execute_with_optional_timeout(client, timeout_per_transaction)
        .await?
        .get_receipt_query()
        .execute_with_optional_timeout(client, timeout_per_transaction)
        .await?
        .file_id
        .expect("Creating a file means there's a file ID");

        if let Some(file_append_bytecode) = bytecode.1 {
            // note: FileAppendTransaction already waits for receipts, so we don't need to wait for one before executing the ContractCreateTransaction.
            make_file_append_transaction(
                file_id,
                file_append_bytecode,
                self.file_append_max_chunks,
                self.node_account_ids.clone(),
            )
            .execute_all_with_optional_timeout(client, timeout_per_transaction)
            .await?;
        }

        let response = make_contract_create_transaction(
            file_id,
            &self.contract_data,
            self.node_account_ids.clone(),
        )?
        .execute_with_optional_timeout(client, timeout_per_transaction)
        .await?;

        response
            .get_receipt_query()
            .execute_with_optional_timeout(client, timeout_per_transaction)
            .await?;

        // todo: Should this return `response` even if this fails?
        make_file_delete_transaction(file_id, self.node_account_ids.clone())
            .execute_with_optional_timeout(client, timeout_per_transaction)
            .await?
            .get_receipt_query()
            .execute_with_optional_timeout(client, timeout_per_transaction)
            .await?;

        Ok(response)
    }
}

// Not to be confused with ContractCreateTrasnactionData which is missing a couple fields.
#[derive(Default, Debug)]
struct ContractData {
    constructor_parameters: Vec<u8>,
    gas: u64,
    initial_balance: Hbar,
    max_automatic_token_associations: i32,
    decline_staking_reward: bool,
    admin_key: Option<Key>,
    //  proxy_account_id: Option<AccountId>
    auto_renew_account_id: Option<AccountId>,
    auto_renew_period: Option<time::Duration>,
    contract_memo: Option<String>,
    staked_id: Option<StakedId>,
    freeze_with_client: Option<Client>,
    signer: Option<AnySigner>,
}

fn split_bytecode(bytecode: &[u8]) -> (Vec<u8>, Option<Vec<u8>>) {
    const MAX_FILE_CREATE_DATA_BYTES: usize = 2048;

    let bytecode = hex::encode(bytecode).into_bytes();

    if bytecode.len() <= MAX_FILE_CREATE_DATA_BYTES {
        return (bytecode, None);
    }

    let mut file_create_bytecode = bytecode;
    let file_append_bytecode = file_create_bytecode.split_off(MAX_FILE_CREATE_DATA_BYTES);

    // note: this uses `subdata` because `Data` is it's own subsequence...
    // It's weirdly written such that the `fileAppendData` wouldn't start at index 0
    // even though that's literally what you'd expect.
    (file_create_bytecode, Some(file_append_bytecode))
}

fn make_file_create_transaction(
    bytecode: Vec<u8>,
    key: PublicKey,
    node_account_ids: Option<Vec<AccountId>>,
) -> FileCreateTransaction {
    let mut tmp = FileCreateTransaction::new();

    tmp.contents(bytecode).keys([key]);

    if let Some(node_account_ids) = node_account_ids {
        tmp.node_account_ids(node_account_ids);
    }

    tmp
}

fn make_file_append_transaction(
    file_id: FileId,
    bytecode: Vec<u8>,
    max_chunks: Option<usize>,
    node_account_ids: Option<Vec<AccountId>>,
) -> FileAppendTransaction {
    let mut tmp = FileAppendTransaction::new();

    tmp.file_id(file_id).contents(bytecode);

    if let Some(max_chunks) = max_chunks {
        tmp.max_chunks(max_chunks);
    }

    if let Some(node_account_ids) = node_account_ids {
        tmp.node_account_ids(node_account_ids);
    }

    tmp
}

fn make_contract_create_transaction(
    file_id: FileId,
    data: &ContractData,
    node_account_ids: Option<Vec<AccountId>>,
) -> crate::Result<ContractCreateTransaction> {
    let mut tmp = ContractCreateTransaction::new();

    tmp.bytecode_file_id(file_id)
        .constructor_parameters(data.constructor_parameters.clone())
        .gas(data.gas)
        .initial_balance(data.initial_balance)
        .max_automatic_token_associations(data.max_automatic_token_associations)
        .decline_staking_reward(data.decline_staking_reward);

    if let Some(admin_key) = &data.admin_key {
        tmp.admin_key(admin_key.clone());
    }

    // if let Some(proxy_account_id) = data.proxy_account_id {
    //     tmp.proxy_account_id(proxy_account_id);
    // }

    if let Some(auto_renew_account_id) = data.auto_renew_account_id {
        tmp.auto_renew_account_id(auto_renew_account_id);
    }

    if let Some(auto_renew_period) = data.auto_renew_period {
        tmp.auto_renew_period(auto_renew_period);
    }

    if let Some(contract_memo) = &data.contract_memo {
        tmp.contract_memo(contract_memo.clone());
    }

    match data.staked_id {
        Some(StakedId::AccountId(account_id)) => {
            tmp.staked_account_id(account_id);
        }
        Some(StakedId::NodeId(node_id)) => {
            tmp.staked_node_id(node_id);
        }
        None => {}
    }

    if let Some(node_account_ids) = node_account_ids {
        tmp.node_account_ids(node_account_ids);
    }

    if let Some(client) = &data.freeze_with_client {
        tmp.freeze_with(client)?;
    }

    if let Some(signer) = &data.signer {
        tmp.sign_signer(signer.clone());
    }

    Ok(tmp)
}

fn make_file_delete_transaction(
    file_id: FileId,
    node_account_ids: Option<Vec<AccountId>>,
) -> FileDeleteTransaction {
    let mut tmp = FileDeleteTransaction::new();

    tmp.file_id(file_id);

    if let Some(node_account_ids) = node_account_ids {
        tmp.node_account_ids(node_account_ids);
    }

    tmp
}

#[cfg(test)]
mod tests {
    use time::Duration;

    use crate::{
        AccountId,
        ContractCreateFlow,
        Hbar,
        PrivateKey,
    };

    #[test]
    fn get_set_bytecode() {
        const BYTECODE: [u8; 3] = [2, 3, 4];
        let mut flow = ContractCreateFlow::new();
        flow.bytecode(BYTECODE.into());

        assert_eq!(flow.get_bytecode(), &BYTECODE)
    }

    #[test]
    fn get_set_max_chunks() {
        let mut flow = ContractCreateFlow::new();
        flow.max_chunks(15);

        assert_eq!(flow.get_max_chunks(), Some(15));
    }

    #[test]
    fn get_set_node_account_ids() {
        const ACCOUNT_IDS: [AccountId; 3] =
            [AccountId::new(1, 2, 3), AccountId::new(1, 3, 2), AccountId::new(2, 1, 3)];
        let mut flow = ContractCreateFlow::new();
        flow.node_account_ids(ACCOUNT_IDS);

        assert_eq!(flow.get_node_account_ids(), Some(ACCOUNT_IDS.as_slice()))
    }

    #[test]
    fn get_set_constructor_parameters() {
        const PARAMS: [u8; 3] = *b"123";
        let mut flow = ContractCreateFlow::new();
        flow.constructor_parameters(PARAMS);

        assert_eq!(flow.get_constructor_parameters(), PARAMS);
    }

    #[test]
    fn get_set_gas() {
        let mut flow = ContractCreateFlow::new();
        flow.gas(31415);

        assert_eq!(flow.get_gas(), 31415);
    }

    #[test]
    fn get_set_initial_balance() {
        let mut flow = ContractCreateFlow::new();
        flow.initial_balance(Hbar::new(2));

        assert_eq!(flow.get_initial_balance(), Hbar::new(2));
    }

    #[test]
    fn get_set_max_automatic_token_associations() {
        let mut flow = ContractCreateFlow::new();
        flow.max_automatic_token_associations(15);

        assert_eq!(flow.get_max_automatic_token_associations(), 15);
    }

    #[test]
    fn get_set_decline_staking_reward() {
        let mut flow = ContractCreateFlow::new();
        flow.decline_staking_reward(true);

        assert_eq!(flow.get_decline_staking_reward(), true);
    }

    #[test]
    fn get_set_admin_key() {
        let key = PrivateKey::generate_ecdsa().public_key();
        let mut flow = ContractCreateFlow::new();
        flow.admin_key(key);

        assert_eq!(flow.get_admin_key(), Some(&key.into()));
    }

    #[test]
    fn get_set_auto_renew_account_id() {
        let mut flow = ContractCreateFlow::new();
        flow.auto_renew_account_id(AccountId::new(0, 1, 2));

        assert_eq!(flow.get_auto_renew_account_id(), Some(AccountId::new(0, 1, 2)));
    }

    #[test]
    fn get_set_auto_renew_period() {
        let mut flow = ContractCreateFlow::new();
        flow.auto_renew_period(Duration::seconds(1231));

        assert_eq!(flow.get_auto_renew_period(), Some(Duration::seconds(1231)));
    }

    #[test]
    fn get_set_contract_memo() {
        let mut flow = ContractCreateFlow::new();
        flow.contract_memo("xyz abc".to_owned());

        assert_eq!(flow.get_contract_memo(), Some("xyz abc"));
    }

    #[test]
    fn get_set_staked_account_id() {
        let mut flow = ContractCreateFlow::new();
        flow.staked_account_id(AccountId::new(0, 1, 2));

        assert_eq!(flow.get_staked_account_id(), Some(AccountId::new(0, 1, 2)));
    }

    #[test]
    fn get_set_staked_node_id() {
        let mut flow = ContractCreateFlow::new();
        flow.staked_node_id(4);

        assert_eq!(flow.get_staked_node_id(), Some(4));
    }
}
// Filename: src/contract/contract_create_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use time::Duration;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::staked_id::StakedId;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    FileId,
    Hbar,
    Key,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

/// Start a new smart contract instance.
pub type ContractCreateTransaction = Transaction<ContractCreateTransactionData>;

#[derive(Debug, Clone)]
pub struct ContractCreateTransactionData {
    bytecode: Option<Vec<u8>>,

    bytecode_file_id: Option<FileId>,

    admin_key: Option<Key>,

    gas: u64,

    initial_balance: Hbar,

    auto_renew_period: Duration,

    constructor_parameters: Vec<u8>,

    contract_memo: String,

    max_automatic_token_associations: i32,

    auto_renew_account_id: Option<AccountId>,

    /// ID of the account or node to which this contract is staking, if any.
    staked_id: Option<StakedId>,

    decline_staking_reward: bool,
}

impl Default for ContractCreateTransactionData {
    fn default() -> Self {
        Self {
            bytecode: None,
            bytecode_file_id: None,
            admin_key: None,
            gas: 0,
            initial_balance: Hbar::ZERO,
            auto_renew_period: Duration::days(90),
            constructor_parameters: Vec::new(),
            contract_memo: String::new(),
            max_automatic_token_associations: 0,
            auto_renew_account_id: None,
            staked_id: None,
            decline_staking_reward: false,
        }
    }
}

impl ContractCreateTransaction {
    /// Returns the `FileId` to be used as the bytecode for this smart contract.
    #[must_use]
    pub fn get_bytecode_file_id(&self) -> Option<FileId> {
        self.data().bytecode_file_id
    }

    /// Sets the file to use as the bytes for the smart contract.
    pub fn bytecode_file_id(&mut self, file_id: FileId) -> &mut Self {
        self.data_mut().bytecode_file_id = Some(file_id);
        self
    }

    /// Returns the bytecode for the smart contract.
    #[must_use]
    pub fn get_bytecode(&self) -> Option<&[u8]> {
        self.data().bytecode.as_deref()
    }

    /// Sets the bytes of the smart contract.
    pub fn bytecode(&mut self, bytecode: impl AsRef<[u8]>) -> &mut Self {
        self.data_mut().bytecode = Some(bytecode.as_ref().to_vec());
        self
    }

    /// Returns the admin key.
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.data().admin_key.as_ref()
    }

    /// Sets the admin key.
    pub fn admin_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().admin_key = Some(key.into());
        self
    }

    /// Returns the gas limit to deploy the smart contract.
    #[must_use]
    pub fn get_gas(&self) -> u64 {
        self.data().gas
    }

    /// Sets the gas limit to deploy the smart contract.
    pub fn gas(&mut self, gas: u64) -> &mut Self {
        self.data_mut().gas = gas;
        self
    }

    /// Returns the initial balance to put into the cryptocurrency account associated with the new smart contract.
    #[must_use]
    pub fn get_initial_balance(&self) -> Hbar {
        self.data().initial_balance
    }

    /// Sets the initial balance to put into the cryptocurrency account associated with the new
    /// smart contract.
    pub fn initial_balance(&mut self, balance: Hbar) -> &mut Self {
        self.data_mut().initial_balance = balance;
        self
    }

    /// Returns the auto renew period for this smart contract.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Duration {
        self.data().auto_renew_period
    }

    /// Sets the auto renew period for this smart contract.
    pub fn auto_renew_period(&mut self, period: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = period;
        self
    }

    /// Returns the parameters to pass to the constructor.
    #[must_use]
    pub fn get_constructor_parameters(&self) -> &[u8] {
        self.data().constructor_parameters.as_ref()
    }

    /// Sets the parameters to pass to the constructor.
    pub fn constructor_parameters(&mut self, parameters: impl AsRef<[u8]>) -> &mut Self {
        self.data_mut().constructor_parameters = parameters.as_ref().to_vec();
        self
    }

    /// Returns the memo for the new smart contract.
    #[must_use]
    pub fn get_contract_memo(&self) -> &str {
        self.data().contract_memo.as_str()
    }

    /// Sets the memo for the new smart contract.
    pub fn contract_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().contract_memo = memo.into();
        self
    }

    /// Returns the maximum number of tokens that the contract can be automatically associated with.
    #[must_use]
    pub fn get_max_automatic_token_associations(&self) -> i32 {
        self.data().max_automatic_token_associations
    }

    /// Sets the maximum number of tokens that this contract can be automatically associated with.
    pub fn max_automatic_token_associations(&mut self, max: i32) -> &mut Self {
        self.data_mut().max_automatic_token_associations = max;
        self
    }

    /// Returns the account ot be used at the contract's expiration time to extend the
    /// life of the contract
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the account to be used at the contract's expiration time to extend the
    /// life of the contract.
    pub fn auto_renew_account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(account_id);
        self
    }

    /// Returns the ID of the account to which this contract is staking.
    #[must_use]
    pub fn get_staked_account_id(&self) -> Option<AccountId> {
        self.data().staked_id.and_then(StakedId::to_account_id)
    }

    /// Sets the ID of the account to which this contract is staking.
    ///
    /// This is mutually exclusive with [`staked_node_id`](Self::staked_node_id).
    pub fn staked_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().staked_id = Some(id.into());
        self
    }

    /// Returns the ID of the node to which this contract is staking.
    #[must_use]
    pub fn get_staked_node_id(&self) -> Option<u64> {
        self.data().staked_id.and_then(StakedId::to_node_id)
    }

    /// Sets the ID of the node to which this contract is staking.
    /// This is mutually exclusive with [`staked_account_id`](Self::staked_account_id).
    pub fn staked_node_id(&mut self, id: u64) -> &mut Self {
        self.data_mut().staked_id = Some(id.into());
        self
    }

    /// Returns `true` if the contract will decline receiving staking rewards, `false` otherwise.
    #[must_use]
    pub fn get_decline_staking_reward(&self) -> bool {
        self.data().decline_staking_reward
    }

    /// If `true` the contract should declie receiving staking rewards. The default value is `false`.
    pub fn decline_staking_reward(&mut self, decline: bool) -> &mut Self {
        self.data_mut().decline_staking_reward = decline;
        self
    }
}

impl TransactionData for ContractCreateTransactionData {
    fn default_max_transaction_fee(&self) -> crate::Hbar {
        crate::Hbar::new(20)
    }
}

impl TransactionExecute for ContractCreateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { SmartContractServiceClient::new(channel).create_contract(request).await })
    }
}

impl ValidateChecksums for ContractCreateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.bytecode_file_id.validate_checksums(ledger_id)?;
        self.auto_renew_account_id.validate_checksums(ledger_id)?;
        self.staked_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for ContractCreateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::ContractCreateInstance(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for ContractCreateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::ContractCreateInstance(self.to_protobuf())
    }
}

impl From<ContractCreateTransactionData> for AnyTransactionData {
    fn from(transaction: ContractCreateTransactionData) -> Self {
        Self::ContractCreate(transaction)
    }
}

impl FromProtobuf<services::ContractCreateTransactionBody> for ContractCreateTransactionData {
    fn from_protobuf(pb: services::ContractCreateTransactionBody) -> crate::Result<Self> {
        use services::contract_create_transaction_body::InitcodeSource;
        let (bytecode, bytecode_file_id) = match pb.initcode_source {
            Some(InitcodeSource::FileId(it)) => (None, Some(FileId::from_protobuf(it)?)),
            Some(InitcodeSource::Initcode(it)) => (Some(it), None),
            None => (None, None),
        };

        Ok(Self {
            bytecode,
            bytecode_file_id,
            admin_key: Option::from_protobuf(pb.admin_key)?,
            gas: pb.gas as u64,
            initial_balance: Hbar::from_tinybars(pb.initial_balance),
            auto_renew_period: pb_getf!(pb, auto_renew_period)?.into(),
            constructor_parameters: pb.constructor_parameters,
            contract_memo: pb.memo,
            max_automatic_token_associations: pb.max_automatic_token_associations,
            auto_renew_account_id: Option::from_protobuf(pb.auto_renew_account_id)?,
            staked_id: Option::from_protobuf(pb.staked_id)?,
            decline_staking_reward: pb.decline_reward,
        })
    }
}

impl ToProtobuf for ContractCreateTransactionData {
    type Protobuf = services::ContractCreateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let admin_key = self.admin_key.to_protobuf();
        let auto_renew_period = self.auto_renew_period.into();
        let auto_renew_account_id = self.auto_renew_account_id.to_protobuf();

        let initcode_source = match (&self.bytecode, &self.bytecode_file_id) {
            (_, Some(file_id)) => {
                Some(services::contract_create_transaction_body::InitcodeSource::FileId(
                    file_id.to_protobuf(),
                ))
            }

            (Some(bytecode), _) => {
                Some(services::contract_create_transaction_body::InitcodeSource::Initcode(
                    bytecode.clone(),
                ))
            }

            _ => None,
        };

        let staked_id = match self.staked_id {
            Some(StakedId::NodeId(node_id)) => Some(
                services::contract_create_transaction_body::StakedId::StakedNodeId(node_id as i64),
            ),

            Some(StakedId::AccountId(account_id)) => {
                Some(services::contract_create_transaction_body::StakedId::StakedAccountId(
                    account_id.to_protobuf(),
                ))
            }

            _ => None,
        };

        #[allow(deprecated)]
        services::ContractCreateTransactionBody {
            admin_key,
            gas: self.gas as i64,
            initial_balance: self.initial_balance.to_tinybars(),
            proxy_account_id: None,
            auto_renew_period: Some(auto_renew_period),
            constructor_parameters: self.constructor_parameters.clone(),
            shard_id: None,
            realm_id: None,
            new_realm_admin_key: None,
            memo: self.contract_memo.clone(),
            max_automatic_token_associations: self.max_automatic_token_associations,
            auto_renew_account_id,
            decline_reward: self.decline_staking_reward,
            initcode_source,
            staked_id,
        }
    }
}

#[cfg(test)]
mod tests {

    use expect_test::expect;
    use hedera_proto::services;
    use time::Duration;

    use crate::contract::ContractCreateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        ContractCreateTransaction,
        FileId,
        Hbar,
        PublicKey,
    };

    const BYTECODE: [u8; 4] = [0xde, 0xad, 0xbe, 0xef];
    const BYTECODE_FILE_ID: FileId = FileId::new(0, 0, 3003);

    fn admin_key() -> PublicKey {
        unused_private_key().public_key()
    }

    const GAS: u64 = 0;
    const INITIAL_BALANCE: Hbar = Hbar::from_tinybars(1000);
    const MAX_AUTOMATIC_TOKEN_ASSOCIATIONS: i32 = 101;
    const AUTO_RENEW_PERIOD: Duration = Duration::hours(10);
    const CONSTRUCTOR_PARAMETERS: [u8; 5] = [10, 11, 12, 13, 25];
    const AUTO_RENEW_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 30);
    const STAKED_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 3);
    const STAKED_NODE_ID: u64 = 4;

    fn make_transaction() -> ContractCreateTransaction {
        let mut tx = ContractCreateTransaction::new_for_tests();

        tx.bytecode_file_id(BYTECODE_FILE_ID)
            .admin_key(admin_key())
            .gas(GAS)
            .initial_balance(INITIAL_BALANCE)
            .staked_account_id(STAKED_ACCOUNT_ID)
            .max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .constructor_parameters(CONSTRUCTOR_PARAMETERS)
            .auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID)
            .freeze()
            .unwrap();

        tx
    }

    fn make_transaction2() -> ContractCreateTransaction {
        let mut tx = ContractCreateTransaction::new_for_tests();

        tx.bytecode(&BYTECODE)
            .admin_key(admin_key())
            .gas(GAS)
            .initial_balance(INITIAL_BALANCE)
            .staked_node_id(STAKED_NODE_ID)
            .max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .constructor_parameters(CONSTRUCTOR_PARAMETERS)
            .auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ContractCreateInstance(
                ContractCreateTransactionBody {
                    admin_key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    gas: 0,
                    initial_balance: 1000,
                    proxy_account_id: None,
                    auto_renew_period: Some(
                        Duration {
                            seconds: 36000,
                        },
                    ),
                    constructor_parameters: [
                        10,
                        11,
                        12,
                        13,
                        25,
                    ],
                    shard_id: None,
                    realm_id: None,
                    new_realm_admin_key: None,
                    memo: "",
                    max_automatic_token_associations: 101,
                    auto_renew_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    30,
                                ),
                            ),
                        },
                    ),
                    decline_reward: false,
                    initcode_source: Some(
                        FileId(
                            FileId {
                                shard_num: 0,
                                realm_num: 0,
                                file_num: 3003,
                            },
                        ),
                    ),
                    staked_id: Some(
                        StakedAccountId(
                            AccountId {
                                shard_num: 0,
                                realm_num: 0,
                                account: Some(
                                    AccountNum(
                                        3,
                                    ),
                                ),
                            },
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn serialize2() {
        let tx = make_transaction2();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ContractCreateInstance(
                ContractCreateTransactionBody {
                    admin_key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    gas: 0,
                    initial_balance: 1000,
                    proxy_account_id: None,
                    auto_renew_period: Some(
                        Duration {
                            seconds: 36000,
                        },
                    ),
                    constructor_parameters: [
                        10,
                        11,
                        12,
                        13,
                        25,
                    ],
                    shard_id: None,
                    realm_id: None,
                    new_realm_admin_key: None,
                    memo: "",
                    max_automatic_token_associations: 101,
                    auto_renew_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    30,
                                ),
                            ),
                        },
                    ),
                    decline_reward: false,
                    initcode_source: Some(
                        Initcode(
                            [
                                222,
                                173,
                                190,
                                239,
                            ],
                        ),
                    ),
                    staked_id: Some(
                        StakedNodeId(
                            4,
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes2() {
        let tx = make_transaction2();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        #[allow(deprecated)]
        let tx = services::ContractCreateTransactionBody {
            admin_key: Some(admin_key().to_protobuf()),
            initial_balance: INITIAL_BALANCE.to_tinybars(),
            proxy_account_id: None,
            auto_renew_period: Some(AUTO_RENEW_PERIOD.to_protobuf()),
            shard_id: None,
            realm_id: None,
            new_realm_admin_key: None,
            memo: String::new(),
            max_automatic_token_associations: MAX_AUTOMATIC_TOKEN_ASSOCIATIONS,
            decline_reward: false,
            staked_id: Some(services::contract_create_transaction_body::StakedId::StakedAccountId(
                STAKED_ACCOUNT_ID.to_protobuf(),
            )),
            gas: GAS as _,
            constructor_parameters: CONSTRUCTOR_PARAMETERS.to_vec(),
            auto_renew_account_id: Some(AUTO_RENEW_ACCOUNT_ID.to_protobuf()),
            initcode_source: Some(
                services::contract_create_transaction_body::InitcodeSource::FileId(
                    BYTECODE_FILE_ID.to_protobuf(),
                ),
            ),
        };
        let tx = ContractCreateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.bytecode, None);
        assert_eq!(tx.bytecode_file_id, Some(BYTECODE_FILE_ID));
        assert_eq!(tx.admin_key, Some(admin_key().into()));
        assert_eq!(tx.gas, GAS);
        assert_eq!(tx.initial_balance, INITIAL_BALANCE);
        assert_eq!(tx.staked_id, Some(crate::staked_id::StakedId::AccountId(STAKED_ACCOUNT_ID)));
        assert_eq!(tx.max_automatic_token_associations, MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);
        assert_eq!(tx.auto_renew_period, AUTO_RENEW_PERIOD);
        assert_eq!(tx.constructor_parameters, CONSTRUCTOR_PARAMETERS);
        assert_eq!(tx.auto_renew_account_id, Some(AUTO_RENEW_ACCOUNT_ID));
    }

    #[test]
    fn get_set_bytecode() {
        let mut tx = ContractCreateTransaction::new();
        tx.bytecode(BYTECODE);

        assert_eq!(tx.get_bytecode(), Some(BYTECODE.as_slice()));
    }

    #[test]
    #[should_panic]
    fn get_set_bytecode_frozen_panics() {
        make_transaction().bytecode(BYTECODE);
    }

    #[test]
    fn get_set_bytecode_file_id() {
        let mut tx = ContractCreateTransaction::new();
        tx.bytecode_file_id(BYTECODE_FILE_ID);

        assert_eq!(tx.get_bytecode_file_id(), Some(BYTECODE_FILE_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_bytecode_file_id_frozen_panics() {
        make_transaction().bytecode_file_id(BYTECODE_FILE_ID);
    }

    #[test]
    fn get_set_admin_key() {
        let mut tx = ContractCreateTransaction::new();
        tx.admin_key(admin_key());

        assert_eq!(tx.get_admin_key(), Some(&admin_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_admin_key_frozen_panics() {
        make_transaction().admin_key(admin_key());
    }

    #[test]
    fn get_set_gas() {
        let mut tx = ContractCreateTransaction::new();
        tx.gas(GAS);

        assert_eq!(tx.get_gas(), GAS);
    }

    #[test]
    #[should_panic]
    fn get_set_gas_frozen_panics() {
        make_transaction().gas(GAS);
    }

    #[test]
    fn get_set_initial_balance() {
        let mut tx = ContractCreateTransaction::new();
        tx.initial_balance(INITIAL_BALANCE);

        assert_eq!(tx.get_initial_balance(), INITIAL_BALANCE);
    }

    #[test]
    #[should_panic]
    fn get_set_initial_balance_frozen_panics() {
        make_transaction().initial_balance(INITIAL_BALANCE);
    }

    #[test]
    fn get_set_max_automatic_token_associations() {
        let mut tx = ContractCreateTransaction::new();
        tx.max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);

        assert_eq!(tx.get_max_automatic_token_associations(), MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);
    }

    #[test]
    #[should_panic]
    fn get_set_max_automatic_token_associations_frozen_panics() {
        make_transaction().max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);
    }

    #[test]
    fn get_set_auto_renew_period() {
        let mut tx = ContractCreateTransaction::new();
        tx.auto_renew_period(AUTO_RENEW_PERIOD);

        assert_eq!(tx.get_auto_renew_period(), AUTO_RENEW_PERIOD);
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_period_frozen_panics() {
        make_transaction().auto_renew_period(AUTO_RENEW_PERIOD);
    }

    #[test]
    fn get_set_constructor_parameters() {
        let mut tx = ContractCreateTransaction::new();
        tx.constructor_parameters(CONSTRUCTOR_PARAMETERS);

        assert_eq!(tx.get_constructor_parameters(), CONSTRUCTOR_PARAMETERS);
    }

    #[test]
    #[should_panic]
    fn get_set_constructor_parameters_frozen_panics() {
        make_transaction().constructor_parameters(CONSTRUCTOR_PARAMETERS);
    }

    #[test]
    fn get_set_auto_renew_account_id() {
        let mut tx = ContractCreateTransaction::new();
        tx.auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID);

        assert_eq!(tx.get_auto_renew_account_id(), Some(AUTO_RENEW_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_account_id_frozen_panics() {
        make_transaction().auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID);
    }

    #[test]
    fn get_set_staked_account_id() {
        let mut tx = ContractCreateTransaction::new();
        tx.staked_account_id(STAKED_ACCOUNT_ID);

        assert_eq!(tx.get_staked_account_id(), Some(STAKED_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_staked_account_id_frozen_panics() {
        make_transaction().staked_account_id(STAKED_ACCOUNT_ID);
    }

    #[test]
    fn get_set_staked_node_id() {
        let mut tx = ContractCreateTransaction::new();
        tx.staked_node_id(STAKED_NODE_ID);

        assert_eq!(tx.get_staked_node_id(), Some(STAKED_NODE_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_staked_node_id_frozen_panics() {
        make_transaction().staked_node_id(STAKED_NODE_ID);
    }
}
// Filename: src/contract/contract_delete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    ContractId,
    Error,
    Transaction,
    ValidateChecksums,
};

/// Marks a contract as deleted and transfers its remaining hBars, if any, to
/// a designated receiver.
///
pub type ContractDeleteTransaction = Transaction<ContractDeleteTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct ContractDeleteTransactionData {
    contract_id: Option<ContractId>,

    transfer_account_id: Option<AccountId>,

    transfer_contract_id: Option<ContractId>,
}

impl ContractDeleteTransaction {
    /// Returns the ID of the contract that should be deleted.
    #[must_use]
    pub fn get_contract_id(&self) -> Option<ContractId> {
        self.data().contract_id
    }

    /// Sets ID of the contract which should be deleted.
    pub fn contract_id(&mut self, id: ContractId) -> &mut Self {
        self.data_mut().contract_id = Some(id);
        self
    }

    /// Returns the ID of the account which will receive all remaining hbars.
    #[must_use]
    pub fn get_transfer_account_id(&self) -> Option<AccountId> {
        self.data().transfer_account_id
    }

    /// Sets the ID of the account which will receive all remaining hbars.
    pub fn transfer_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().transfer_account_id = Some(id);
        self
    }

    /// Returns ID of the contract which will receive all rmaining hbars.
    #[must_use]
    pub fn get_transfer_contract_id(&self) -> Option<ContractId> {
        self.data().transfer_contract_id
    }

    /// Sets the the ID of the contract which will receive all remaining hbars.
    pub fn transfer_contract_id(&mut self, id: ContractId) -> &mut Self {
        self.data_mut().transfer_contract_id = Some(id);
        self
    }
}

impl TransactionData for ContractDeleteTransactionData {}

impl TransactionExecute for ContractDeleteTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { SmartContractServiceClient::new(channel).delete_contract(request).await })
    }
}

impl ValidateChecksums for ContractDeleteTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.contract_id.validate_checksums(ledger_id)?;
        self.transfer_account_id.validate_checksums(ledger_id)?;
        self.transfer_contract_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for ContractDeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::ContractDeleteInstance(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for ContractDeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::ContractDeleteInstance(self.to_protobuf())
    }
}

impl FromProtobuf<services::ContractDeleteTransactionBody> for ContractDeleteTransactionData {
    fn from_protobuf(pb: services::ContractDeleteTransactionBody) -> crate::Result<Self> {
        use services::contract_delete_transaction_body::Obtainers;

        let (transfer_account_id, transfer_contract_id) = match pb.obtainers {
            Some(Obtainers::TransferAccountId(it)) => (Some(AccountId::from_protobuf(it)?), None),
            Some(Obtainers::TransferContractId(it)) => (None, Some(ContractId::from_protobuf(it)?)),
            None => (None, None),
        };

        Ok(Self {
            contract_id: Option::from_protobuf(pb.contract_id)?,
            transfer_account_id,
            transfer_contract_id,
        })
    }
}

impl From<ContractDeleteTransactionData> for AnyTransactionData {
    fn from(transaction: ContractDeleteTransactionData) -> Self {
        Self::ContractDelete(transaction)
    }
}

impl ToProtobuf for ContractDeleteTransactionData {
    type Protobuf = services::ContractDeleteTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let delete_contract_id = self.contract_id.to_protobuf();

        let obtainers = match (&self.transfer_account_id, &self.transfer_contract_id) {
            (Some(account_id), None) => {
                Some(services::contract_delete_transaction_body::Obtainers::TransferAccountId(
                    account_id.to_protobuf(),
                ))
            }

            (None, Some(contract_id)) => {
                Some(services::contract_delete_transaction_body::Obtainers::TransferContractId(
                    contract_id.to_protobuf(),
                ))
            }

            _ => None,
        };

        services::ContractDeleteTransactionBody {
            contract_id: delete_contract_id,
            permanent_removal: false,
            obtainers,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::contract::ContractDeleteTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        ContractDeleteTransaction,
        ContractId,
    };

    const CONTRACT_ID: ContractId = ContractId::new(0, 0, 5007);
    const TRANSFER_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 9);
    const TRANSFER_CONTRACT_ID: ContractId = ContractId::new(0, 0, 5008);

    fn make_transaction() -> ContractDeleteTransaction {
        let mut tx = ContractDeleteTransaction::new_for_tests();

        tx.contract_id(CONTRACT_ID)
            .transfer_account_id(TRANSFER_ACCOUNT_ID)
            .transfer_contract_id(TRANSFER_CONTRACT_ID)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ContractDeleteInstance(
                ContractDeleteTransactionBody {
                    contract_id: Some(
                        ContractId {
                            shard_num: 0,
                            realm_num: 0,
                            contract: Some(
                                ContractNum(
                                    5007,
                                ),
                            ),
                        },
                    ),
                    permanent_removal: false,
                    obtainers: None,
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::ContractDeleteTransactionBody {
            contract_id: Some(CONTRACT_ID.to_protobuf()),
            obtainers: Some(
                services::contract_delete_transaction_body::Obtainers::TransferAccountId(
                    TRANSFER_ACCOUNT_ID.to_protobuf(),
                ),
            ),
            permanent_removal: false,
        };

        let tx = ContractDeleteTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.contract_id, Some(CONTRACT_ID));
        assert_eq!(tx.transfer_account_id, Some(TRANSFER_ACCOUNT_ID));
        assert_eq!(tx.transfer_contract_id, None);
    }

    #[test]
    fn get_set_contract_id() {
        let mut tx = ContractDeleteTransaction::new();
        tx.contract_id(CONTRACT_ID);

        assert_eq!(tx.get_contract_id(), Some(CONTRACT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_contract_id_frozen_panics() {
        make_transaction().contract_id(CONTRACT_ID);
    }

    #[test]
    fn get_set_transfer_account_id() {
        let mut tx = ContractDeleteTransaction::new();
        tx.transfer_account_id(TRANSFER_ACCOUNT_ID);

        assert_eq!(tx.get_transfer_account_id(), Some(TRANSFER_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_transfer_account_id_frozen_panics() {
        make_transaction().transfer_account_id(TRANSFER_ACCOUNT_ID);
    }

    #[test]
    fn get_set_transfer_contract_id() {
        let mut tx = ContractDeleteTransaction::new();
        tx.transfer_contract_id(TRANSFER_CONTRACT_ID);

        assert_eq!(tx.get_transfer_contract_id(), Some(TRANSFER_CONTRACT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_transfer_contract_id_frozen_panics() {
        make_transaction().transfer_contract_id(TRANSFER_CONTRACT_ID);
    }
}
// Filename: src/contract/contract_execute_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    ContractFunctionParameters,
    ContractId,
    Error,
    Hbar,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

/// Call a function of the given smart contract instance, giving it
/// parameters as its inputs.
///
/// It can use the given amount of gas, and any unspent gas will
/// be refunded to the paying account.
///
/// If this function stores information, it is charged gas to store it.
/// There is a fee in hbars to maintain that storage until the expiration time,
/// and that fee is added as part of the transaction fee.
///
pub type ContractExecuteTransaction = Transaction<ContractExecuteTransactionData>;

#[derive(Default, Debug, Clone)]
pub struct ContractExecuteTransactionData {
    /// The contract instance to call.
    contract_id: Option<ContractId>,

    /// The maximum amount of gas to use for the call.
    gas: u64,

    /// The number of hbars sent with this function call.
    payable_amount: Hbar,

    /// The function parameters as their raw bytes.
    function_parameters: Vec<u8>,
}

impl ContractExecuteTransaction {
    /// Returns the contract instance to call.
    #[must_use]
    pub fn get_contract_id(&self) -> Option<ContractId> {
        self.data().contract_id
    }

    /// Sets the contract instance to call.
    pub fn contract_id(&mut self, contract_id: ContractId) -> &mut Self {
        self.data_mut().contract_id = Some(contract_id);
        self
    }

    /// Returns the maximum amount of gas to use for the call.
    #[must_use]
    pub fn get_gas(&self) -> u64 {
        self.data().gas
    }

    /// Sets the maximum amount of gas to use for the call.
    pub fn gas(&mut self, gas: u64) -> &mut Self {
        self.data_mut().gas = gas;
        self
    }

    /// Returns the number of hbars to be sent with this function call.
    #[must_use]
    pub fn get_payable_amount(&self) -> Hbar {
        self.data().payable_amount
    }

    /// Sets the number of hbars to be sent with this function call.
    pub fn payable_amount(&mut self, amount: Hbar) -> &mut Self {
        self.data_mut().payable_amount = amount;
        self
    }

    /// Returns the function parameters as their raw bytes.
    #[must_use]
    pub fn get_function_parameters(&self) -> &[u8] {
        &self.data().function_parameters
    }

    /// Sets the function parameters as their raw bytes.
    pub fn function_parameters(&mut self, data: Vec<u8>) -> &mut Self {
        self.data_mut().function_parameters = data;
        self
    }

    /// Sets the function with no parameters.
    pub fn function(&mut self, name: &str) -> &mut Self {
        self.function_with_parameters(name, &ContractFunctionParameters::new())
    }

    /// Sets the function with parameters.
    pub fn function_with_parameters(
        &mut self,
        name: &str,
        parameters: &ContractFunctionParameters,
    ) -> &mut Self {
        self.function_parameters(parameters.to_bytes(Some(name)))
    }
}

impl TransactionData for ContractExecuteTransactionData {}

impl TransactionExecute for ContractExecuteTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async {
            SmartContractServiceClient::new(channel).contract_call_method(request).await
        })
    }
}

impl ValidateChecksums for ContractExecuteTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.contract_id.validate_checksums(ledger_id)?;
        Ok(())
    }
}

impl ToTransactionDataProtobuf for ContractExecuteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::ContractCall(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for ContractExecuteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::ContractCall(self.to_protobuf())
    }
}

impl From<ContractExecuteTransactionData> for AnyTransactionData {
    fn from(transaction: ContractExecuteTransactionData) -> Self {
        Self::ContractExecute(transaction)
    }
}

impl FromProtobuf<services::ContractCallTransactionBody> for ContractExecuteTransactionData {
    fn from_protobuf(pb: services::ContractCallTransactionBody) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Ok(Self {
            contract_id: Option::from_protobuf(pb.contract_id)?,
            gas: pb.gas as u64,
            payable_amount: Hbar::from_tinybars(pb.amount),
            function_parameters: pb.function_parameters,
        })
    }
}

impl ToProtobuf for ContractExecuteTransactionData {
    type Protobuf = services::ContractCallTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        #[allow(deprecated)]
        services::ContractCallTransactionBody {
            gas: self.gas as i64,
            amount: self.payable_amount.to_tinybars(),
            contract_id: self.contract_id.to_protobuf(),
            function_parameters: self.function_parameters.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::contract::ContractExecuteTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        ContractExecuteTransaction,
        ContractId,
        Hbar,
    };

    const CONTRACT_ID: ContractId = ContractId::new(0, 0, 5007);
    const GAS: u64 = 10;
    const PAYABLE_AMOUNT: Hbar = Hbar::from_tinybars(1000);

    fn function_parameters() -> Vec<u8> {
        Vec::from([24, 43, 11])
    }

    fn make_transaction() -> ContractExecuteTransaction {
        let mut tx = ContractExecuteTransaction::new_for_tests();

        tx.contract_id(CONTRACT_ID)
            .gas(GAS)
            .payable_amount(PAYABLE_AMOUNT)
            .function_parameters(function_parameters())
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ContractCall(
                ContractCallTransactionBody {
                    contract_id: Some(
                        ContractId {
                            shard_num: 0,
                            realm_num: 0,
                            contract: Some(
                                ContractNum(
                                    5007,
                                ),
                            ),
                        },
                    ),
                    gas: 10,
                    amount: 1000,
                    function_parameters: [
                        24,
                        43,
                        11,
                    ],
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::ContractCallTransactionBody {
            contract_id: Some(CONTRACT_ID.to_protobuf()),
            gas: GAS as _,
            amount: PAYABLE_AMOUNT.to_tinybars(),
            function_parameters: function_parameters(),
        };

        let tx = ContractExecuteTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.contract_id, Some(CONTRACT_ID));
        assert_eq!(tx.gas, GAS);
        assert_eq!(tx.payable_amount, PAYABLE_AMOUNT);
        assert_eq!(tx.function_parameters, function_parameters());
    }

    #[test]
    fn get_set_contract_id() {
        let mut tx = ContractExecuteTransaction::new();
        tx.contract_id(CONTRACT_ID);

        assert_eq!(tx.get_contract_id(), Some(CONTRACT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_contract_id_frozen_panics() {
        make_transaction().contract_id(CONTRACT_ID);
    }

    #[test]
    fn get_set_gas() {
        let mut tx = ContractExecuteTransaction::new();
        tx.gas(GAS);

        assert_eq!(tx.get_gas(), GAS);
    }

    #[test]
    #[should_panic]
    fn get_set_gas_frozen_panics() {
        make_transaction().gas(GAS);
    }

    #[test]
    fn get_set_payable_amount() {
        let mut tx = ContractExecuteTransaction::new();
        tx.payable_amount(PAYABLE_AMOUNT);

        assert_eq!(tx.get_payable_amount(), PAYABLE_AMOUNT);
    }

    #[test]
    #[should_panic]
    fn get_set_payable_amount_frozen_panics() {
        make_transaction().payable_amount(PAYABLE_AMOUNT);
    }

    #[test]
    fn get_set_function_parameters() {
        let mut tx = ContractExecuteTransaction::new();
        tx.function_parameters(function_parameters());

        assert_eq!(tx.get_function_parameters(), function_parameters());
    }

    #[test]
    #[should_panic]
    fn get_set_function_parameters_frozen_panics() {
        make_transaction().function_parameters(function_parameters());
    }
}
// Filename: src/contract/contract_function_parameters.rs
use std::cmp::max;
use std::str::FromStr;

use num_bigint::{
    BigInt,
    BigUint,
    Sign,
};

use self::private::Sealed;
use crate::contract::contract_function_selector::ContractFunctionSelector;
use crate::ethereum::SolidityAddress;

/// Builder for encoding parameters for a Solidity contract constructor/function call.
#[derive(Debug, Clone, Default)]
pub struct ContractFunctionParameters {
    args: Vec<Argument>,
}

#[derive(Debug, Clone)]
struct Argument {
    type_name: &'static str,
    value_bytes: Vec<u8>,
    is_dynamic: bool,
}

mod private {
    pub trait Sealed {}
    impl Sealed for String {}
    impl Sealed for str {}
    impl Sealed for [u8; 32] {}
}

pub trait AsBytes32: Sealed {
    fn as_bytes32(&self) -> &[u8];
}

impl<T: Sealed + AsRef<[u8]> + ?Sized> AsBytes32 for T {
    fn as_bytes32(&self) -> &[u8] {
        self.as_ref()
    }
}

trait IntEncode {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>);
}

impl IntEncode for u8 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (false, self.to_be_bytes().to_vec())
    }
}

impl IntEncode for i8 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (self.is_negative(), self.to_be_bytes().to_vec())
    }
}

impl IntEncode for u16 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (false, self.to_be_bytes().to_vec())
    }
}

impl IntEncode for i16 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (self.is_negative(), self.to_be_bytes().to_vec())
    }
}

impl IntEncode for u32 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (false, self.to_be_bytes().to_vec())
    }
}

impl IntEncode for i32 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (self.is_negative(), self.to_be_bytes().to_vec())
    }
}

impl IntEncode for u64 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (false, self.to_be_bytes().to_vec())
    }
}

impl IntEncode for i64 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (self.is_negative(), self.to_be_bytes().to_vec())
    }
}

impl IntEncode for u128 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (false, self.to_be_bytes().to_vec())
    }
}

impl IntEncode for i128 {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (self.is_negative(), self.to_be_bytes().to_vec())
    }
}

impl IntEncode for BigUint {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (false, self.to_bytes_be())
    }
}

impl IntEncode for BigInt {
    fn get_is_negative_and_be_bytes(&self) -> (bool, Vec<u8>) {
        (self.sign() == Sign::Minus, self.to_signed_bytes_be())
    }
}

// todo: remove this
#[allow(clippy::needless_pass_by_value)]
impl ContractFunctionParameters {
    /// Create a new, empty `ContractFunctionParameters`
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns the encoding of the currently added parameters as bytes.
    ///
    /// You can continue adding arguments after calling this function.
    // passing an `&Option<A>` or an `Option<&A>` would just be pointlessly more restrictive,
    // since downstream code can just...
    // Call this with `Option<&A>` anyway if they want to keep ownership of it.
    pub fn to_bytes(&self, func_name: Option<&str>) -> Vec<u8> {
        let mut current_dynamic_offset = self.args.len() * 32;
        let mut arg_bytes = Vec::new();
        let mut dynamic_arg_bytes = Vec::new();
        let mut function_selector = func_name.map(ContractFunctionSelector::new);
        for arg in &self.args {
            if let Some(selector) = &mut function_selector {
                selector.add_param_type(arg.type_name);
            }
            if arg.is_dynamic {
                arg_bytes.extend_from_slice(
                    left_pad_32_bytes(current_dynamic_offset.to_be_bytes().as_slice(), false)
                        .as_slice(),
                );
                dynamic_arg_bytes.extend_from_slice(arg.value_bytes.as_slice());
                current_dynamic_offset += arg.value_bytes.len();
            } else {
                arg_bytes.extend_from_slice(arg.value_bytes.as_slice());
            }
        }

        arg_bytes.append(&mut dynamic_arg_bytes);

        if let Some(selector) = &mut function_selector {
            let mut out_bytes = Vec::from(selector.finish());
            out_bytes.append(&mut arg_bytes);
            out_bytes
        } else {
            arg_bytes
        }
    }

    /// Add a `string` argument to the `ContractFunctionParameters`
    pub fn add_string<T: AsRef<str>>(&mut self, val: T) -> &mut Self {
        self.args.push(Argument {
            type_name: "string",
            value_bytes: encode_dynamic_bytes(val.as_ref().as_bytes()),
            is_dynamic: true,
        });
        self
    }

    /// Add a `string[]` argument to the `ContractFunctionParameters`
    pub fn add_string_array<T: AsRef<str>>(&mut self, val: &[T]) -> &mut Self {
        self.args.push(Argument {
            type_name: "string[]",
            value_bytes: encode_array_of_dynamic_byte_arrays(
                val.iter().map(|s| s.as_ref().as_bytes()),
                val.len(),
            ),
            is_dynamic: true,
        });
        self
    }

    /// Add a `bytes` argument to the `ContractFunctionParameters`
    pub fn add_bytes(&mut self, val: &[u8]) -> &mut Self {
        self.args.push(Argument {
            type_name: "bytes",
            value_bytes: encode_dynamic_bytes(val),
            is_dynamic: true,
        });
        self
    }

    /// Add a `bytes[]` argument to the `ContractFunctionParameters`
    pub fn add_bytes_array(&mut self, val: &[&[u8]]) -> &mut Self {
        self.args.push(Argument {
            type_name: "bytes[]",
            value_bytes: encode_array_of_dynamic_byte_arrays(val, val.len()),
            is_dynamic: true,
        });
        self
    }

    /// Add a `bytes32` argument to the `ContractFunctionParameters`
    pub fn add_bytes32<T: AsBytes32 + ?Sized>(&mut self, val: &T) -> &mut Self {
        self.args.push(Argument {
            type_name: "bytes32",
            value_bytes: encode_array_of_32_byte(val),
            is_dynamic: false,
        });
        self
    }

    /// Add a `bytes32[]` argument to the `ContractFunctionParameters`
    pub fn add_bytes32_array(&mut self, val: &[[u8; 32]]) -> &mut Self {
        self.args.push(Argument {
            type_name: "bytes32",
            value_bytes: encode_array_of_32_byte_elements(val.iter().copied(), val.len()),
            is_dynamic: true,
        });
        self
    }

    /// Add a `bool` argument to the `ContractFunctionParameters`
    pub fn add_bool(&mut self, val: bool) -> &mut Self {
        self.args.push(Argument {
            type_name: "bool",
            value_bytes: left_pad_32_bytes(
                // a bool in rust is guaranteed to be of value 0 or 1
                u32::from(val).to_be_bytes().as_slice(),
                false,
            )
            .to_vec(),
            is_dynamic: false,
        });
        self
    }

    fn add_int<T>(&mut self, val: &T, type_name: &'static str, byte_count: isize) -> &mut Self
    where
        T: IntEncode,
    {
        self.args.push(Argument {
            type_name,
            value_bytes: truncate_and_left_pad_32_bytes(val, byte_count).to_vec(),
            is_dynamic: false,
        });
        self
    }

    fn add_int_array<T>(
        &mut self,
        values: &[T],
        type_name: &'static str,
        byte_count: isize,
    ) -> &mut Self
    where
        T: IntEncode,
    {
        self.args.push(Argument {
            type_name,
            value_bytes: encode_array_of_32_byte_elements(
                values.iter().map(|val| truncate_and_left_pad_32_bytes(val, byte_count)),
                values.len(),
            ),
            is_dynamic: true,
        });
        self
    }

    /// Add an `int8` argument to the `ContractFunctionParameters`
    pub fn add_int8(&mut self, val: i8) -> &mut Self {
        self.add_int(&val, "int8", 1)
    }

    /// Add an `int16` argument to the `ContractFunctionParameters`
    pub fn add_int16(&mut self, val: i16) -> &mut Self {
        self.add_int(&val, "int16", 2)
    }

    /// Add an `int24` argument to the `ContractFunctionParameters`
    pub fn add_int24(&mut self, val: i32) -> &mut Self {
        self.add_int(&val, "int24", 3)
    }

    /// Add an `int32` argument to the `ContractFunctionParameters`
    pub fn add_int32(&mut self, val: i32) -> &mut Self {
        self.add_int(&val, "int32", 4)
    }

    /// Add an `int40` argument to the `ContractFunctionParameters`
    pub fn add_int40(&mut self, val: i64) -> &mut Self {
        self.add_int(&val, "int40", 5)
    }

    /// Add an `int48` argument to the `ContractFunctionParameters`
    pub fn add_int48(&mut self, val: i64) -> &mut Self {
        self.add_int(&val, "int48", 6)
    }

    /// Add an `int56` argument to the `ContractFunctionParameters`
    pub fn add_int56(&mut self, val: i64) -> &mut Self {
        self.add_int(&val, "int56", 7)
    }

    /// Add an `int64` argument to the `ContractFunctionParameters`
    pub fn add_int64(&mut self, val: i64) -> &mut Self {
        self.add_int(&val, "int64", 8)
    }

    /// Add an `int72` argument to the `ContractFunctionParameters`
    pub fn add_int72(&mut self, val: i128) -> &mut Self {
        self.add_int(&val, "int72", 9)
    }

    /// Add an `int80` argument to the `ContractFunctionParameters`
    pub fn add_int80(&mut self, val: i128) -> &mut Self {
        self.add_int(&val, "int80", 10)
    }

    /// Add an `int88` argument to the `ContractFunctionParameters`
    pub fn add_int88(&mut self, val: i128) -> &mut Self {
        self.add_int(&val, "int88", 11)
    }

    /// Add an `int96` argument to the `ContractFunctionParameters`
    pub fn add_int96(&mut self, val: i128) -> &mut Self {
        self.add_int(&val, "int96", 12)
    }

    /// Add an `int104` argument to the `ContractFunctionParameters`
    pub fn add_int104(&mut self, val: i128) -> &mut Self {
        self.add_int(&val, "int104", 13)
    }

    /// Add an `int112` argument to the `ContractFunctionParameters`
    pub fn add_int112(&mut self, val: i128) -> &mut Self {
        self.add_int(&val, "int112", 14)
    }

    /// Add an `int120` argument to the `ContractFunctionParameters`
    pub fn add_int120(&mut self, val: i128) -> &mut Self {
        self.add_int(&val, "int120", 15)
    }

    /// Add an `int128` argument to the `ContractFunctionParameters`
    pub fn add_int128(&mut self, val: i128) -> &mut Self {
        self.add_int(&val, "int128", 16)
    }

    /// Add an `int136` argument to the `ContractFunctionParameters`
    pub fn add_int136(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int136", 17)
    }

    /// Add an `int144` argument to the `ContractFunctionParameters`
    pub fn add_int144(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int144", 18)
    }

    /// Add an `int152` argument to the `ContractFunctionParameters`
    pub fn add_int152(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int152", 19)
    }

    /// Add an `int160` argument to the `ContractFunctionParameters`
    pub fn add_int160(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int160", 20)
    }

    /// Add an `int168` argument to the `ContractFunctionParameters`
    pub fn add_int168(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int168", 21)
    }

    /// Add an `int176` argument to the `ContractFunctionParameters`
    pub fn add_int176(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int176", 22)
    }

    /// Add an `int184` argument to the `ContractFunctionParameters`
    pub fn add_int184(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int184", 23)
    }

    /// Add an `int192` argument to the `ContractFunctionParameters`
    pub fn add_int192(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int192", 24)
    }

    /// Add an `int200` argument to the `ContractFunctionParameters`
    pub fn add_int200(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int200", 25)
    }

    /// Add an `int208` argument to the `ContractFunctionParameters`
    pub fn add_int208(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int208", 26)
    }

    /// Add an `int216` argument to the `ContractFunctionParameters`
    pub fn add_int216(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int216", 27)
    }

    /// Add an `int224` argument to the `ContractFunctionParameters`
    pub fn add_int224(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int224", 28)
    }

    /// Add an `int232` argument to the `ContractFunctionParameters`
    pub fn add_int232(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int232", 29)
    }

    /// Add an `int240` argument to the `ContractFunctionParameters`
    pub fn add_int240(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int240", 30)
    }

    /// Add an `int248` argument to the `ContractFunctionParameters`
    pub fn add_int248(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int248", 31)
    }

    /// Add an `int256` argument to the `ContractFunctionParameters`
    pub fn add_int256(&mut self, val: BigInt) -> &mut Self {
        self.add_int(&val, "int256", 32)
    }

    /// Add an `int8[]` argument to the `ContractFunctionParameters`
    pub fn add_int8_array(&mut self, values: &[i8]) -> &mut Self {
        self.add_int_array(values, "int8[]", 1)
    }

    /// Add an `int16[]` argument to the `ContractFunctionParameters`
    pub fn add_int16_array(&mut self, values: &[i16]) -> &mut Self {
        self.add_int_array(values, "int16[]", 2)
    }

    /// Add an `int24[]` argument to the `ContractFunctionParameters`
    pub fn add_int24_array(&mut self, values: &[i32]) -> &mut Self {
        self.add_int_array(values, "int24[]", 3)
    }

    /// Add an `int32[]` argument to the `ContractFunctionParameters`
    pub fn add_int32_array(&mut self, values: &[i32]) -> &mut Self {
        self.add_int_array(values, "int32[]", 4)
    }

    /// Add an `int40[]` argument to the `ContractFunctionParameters`
    pub fn add_int40_array(&mut self, values: &[i64]) -> &mut Self {
        self.add_int_array(values, "int40[]", 5)
    }

    /// Add an `int48[]` argument to the `ContractFunctionParameters`
    pub fn add_int48_array(&mut self, values: &[i64]) -> &mut Self {
        self.add_int_array(values, "int48[]", 6)
    }

    /// Add an `int56[]` argument to the `ContractFunctionParameters`
    pub fn add_int56_array(&mut self, values: &[i64]) -> &mut Self {
        self.add_int_array(values, "int56[]", 7)
    }

    /// Add an `int64[]` argument to the `ContractFunctionParameters`
    pub fn add_int64_array(&mut self, values: &[i64]) -> &mut Self {
        self.add_int_array(values, "int64[]", 8)
    }

    /// Add an `int72[]` argument to the `ContractFunctionParameters`
    pub fn add_int72_array(&mut self, values: &[i128]) -> &mut Self {
        self.add_int_array(values, "int72[]", 9)
    }

    /// Add an `int80[]` argument to the `ContractFunctionParameters`
    pub fn add_int80_array(&mut self, values: &[i128]) -> &mut Self {
        self.add_int_array(values, "int80[]", 10)
    }

    /// Add an `int88[]` argument to the `ContractFunctionParameters`
    pub fn add_int88_array(&mut self, values: &[i128]) -> &mut Self {
        self.add_int_array(values, "int88[]", 11)
    }

    /// Add an `int96[]` argument to the `ContractFunctionParameters`
    pub fn add_int96_array(&mut self, values: &[i128]) -> &mut Self {
        self.add_int_array(values, "int96[]", 12)
    }

    /// Add an `int104[]` argument to the `ContractFunctionParameters`
    pub fn add_int104_array(&mut self, values: &[i128]) -> &mut Self {
        self.add_int_array(values, "int104[]", 13)
    }

    /// Add an `int112[]` argument to the `ContractFunctionParameters`
    pub fn add_int112_array(&mut self, values: &[i128]) -> &mut Self {
        self.add_int_array(values, "int112[]", 14)
    }

    /// Add an `int120[]` argument to the `ContractFunctionParameters`
    pub fn add_int120_array(&mut self, values: &[i128]) -> &mut Self {
        self.add_int_array(values, "int120[]", 15)
    }

    /// Add an `int128[]` argument to the `ContractFunctionParameters`
    pub fn add_int128_array(&mut self, values: &[i128]) -> &mut Self {
        self.add_int_array(values, "int128[]", 16)
    }

    /// Add an `int136[]` argument to the `ContractFunctionParameters`
    pub fn add_int136_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int136[]", 17)
    }

    /// Add an `int144[]` argument to the `ContractFunctionParameters`
    pub fn add_int144_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int144[]", 18)
    }

    /// Add an `int152[]` argument to the `ContractFunctionParameters`
    pub fn add_int152_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int152[]", 19)
    }

    /// Add an `int160[]` argument to the `ContractFunctionParameters`
    pub fn add_int160_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int160[]", 20)
    }

    /// Add an `int168[]` argument to the `ContractFunctionParameters`
    pub fn add_int168_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int168[]", 21)
    }

    /// Add an `int176[]` argument to the `ContractFunctionParameters`
    pub fn add_int176_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int176[]", 22)
    }

    /// Add an `int184[]` argument to the `ContractFunctionParameters`
    pub fn add_int184_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int184[]", 23)
    }

    /// Add an `int192[]` argument to the `ContractFunctionParameters`
    pub fn add_int192_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int192[]", 24)
    }

    /// Add an `int200[]` argument to the `ContractFunctionParameters`
    pub fn add_int200_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int200[]", 25)
    }

    /// Add an `int208[]` argument to the `ContractFunctionParameters`
    pub fn add_int208_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int208[]", 26)
    }

    /// Add an `int216[]` argument to the `ContractFunctionParameters`
    pub fn add_int216_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int216[]", 27)
    }

    /// Add an `int224[]` argument to the `ContractFunctionParameters`
    pub fn add_int224_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int224[]", 28)
    }

    /// Add an `int232[]` argument to the `ContractFunctionParameters`
    pub fn add_int232_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int232[]", 29)
    }

    /// Add an `int240[]` argument to the `ContractFunctionParameters`
    pub fn add_int240_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int240[]", 30)
    }

    /// Add an `int248[]` argument to the `ContractFunctionParameters`
    pub fn add_int248_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int248[]", 31)
    }

    /// Add an `int256[]` argument to the `ContractFunctionParameters`
    pub fn add_int256_array(&mut self, values: &[BigInt]) -> &mut Self {
        self.add_int_array(values, "int256[]", 32)
    }

    /// Add a `uint8` argument to the `ContractFunctionParameters`
    pub fn add_uint8(&mut self, val: u8) -> &mut Self {
        self.add_int(&val, "uint8", 1)
    }

    /// Add a `uint16` argument to the `ContractFunctionParameters`
    pub fn add_uint16(&mut self, val: u16) -> &mut Self {
        self.add_int(&val, "uint16", 2)
    }

    /// Add a `uint24` argument to the `ContractFunctionParameters`
    pub fn add_uint24(&mut self, val: u32) -> &mut Self {
        self.add_int(&val, "uint24", 3)
    }

    /// Add a `uint32` argument to the `ContractFunctionParameters`
    pub fn add_uint32(&mut self, val: u32) -> &mut Self {
        self.add_int(&val, "uint32", 4)
    }

    /// Add a `uint40` argument to the `ContractFunctionParameters`
    pub fn add_uint40(&mut self, val: u64) -> &mut Self {
        self.add_int(&val, "uint40", 5)
    }

    /// Add a `uint48` argument to the `ContractFunctionParameters`
    pub fn add_uint48(&mut self, val: u64) -> &mut Self {
        self.add_int(&val, "uint48", 6)
    }

    /// Add a `uint56` argument to the `ContractFunctionParameters`
    pub fn add_uint56(&mut self, val: u64) -> &mut Self {
        self.add_int(&val, "uint56", 7)
    }

    /// Add a `uint64` argument to the `ContractFunctionParameters`
    pub fn add_uint64(&mut self, val: u64) -> &mut Self {
        self.add_int(&val, "uint64", 8)
    }

    /// Add a `uint72` argument to the `ContractFunctionParameters`
    pub fn add_uint72(&mut self, val: u128) -> &mut Self {
        self.add_int(&val, "uint72", 9)
    }

    /// Add a `uint80` argument to the `ContractFunctionParameters`
    pub fn add_uint80(&mut self, val: u128) -> &mut Self {
        self.add_int(&val, "uint80", 10)
    }

    /// Add a `uint88` argument to the `ContractFunctionParameters`
    pub fn add_uint88(&mut self, val: u128) -> &mut Self {
        self.add_int(&val, "uint88", 11)
    }

    /// Add a `uint96` argument to the `ContractFunctionParameters`
    pub fn add_uint96(&mut self, val: u128) -> &mut Self {
        self.add_int(&val, "uint96", 12)
    }

    /// Add a `uint104` argument to the `ContractFunctionParameters`
    pub fn add_uint104(&mut self, val: u128) -> &mut Self {
        self.add_int(&val, "uint104", 13)
    }

    /// Add a `uint112` argument to the `ContractFunctionParameters`
    pub fn add_uint112(&mut self, val: u128) -> &mut Self {
        self.add_int(&val, "uint112", 14)
    }

    /// Add a `uint120` argument to the `ContractFunctionParameters`
    pub fn add_uint120(&mut self, val: u128) -> &mut Self {
        self.add_int(&val, "uint120", 15)
    }

    /// Add a `uint128` argument to the `ContractFunctionParameters`
    pub fn add_uint128(&mut self, val: u128) -> &mut Self {
        self.add_int(&val, "uint128", 16)
    }

    /// Add a `uint136` argument to the `ContractFunctionParameters`
    pub fn add_uint136(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint136", 17)
    }

    /// Add a `uint144` argument to the `ContractFunctionParameters`
    pub fn add_uint144(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint144", 18)
    }

    /// Add a `uint152` argument to the `ContractFunctionParameters`
    pub fn add_uint152(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint152", 19)
    }

    /// Add a `uint160` argument to the `ContractFunctionParameters`
    pub fn add_uint160(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint160", 20)
    }

    /// Add a `uint168` argument to the `ContractFunctionParameters`
    pub fn add_uint168(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint168", 21)
    }

    /// Add a `uint176` argument to the `ContractFunctionParameters`
    pub fn add_uint176(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint176", 22)
    }

    /// Add a `uint184` argument to the `ContractFunctionParameters`
    pub fn add_uint184(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint184", 23)
    }

    /// Add a `uint192` argument to the `ContractFunctionParameters`
    pub fn add_uint192(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint192", 24)
    }

    /// Add a `uint200` argument to the `ContractFunctionParameters`
    pub fn add_uint200(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint200", 25)
    }

    /// Add a `uint208` argument to the `ContractFunctionParameters`
    pub fn add_uint208(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint208", 26)
    }

    /// Add a `uint216` argument to the `ContractFunctionParameters`
    pub fn add_uint216(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint216", 27)
    }

    /// Add a `uint224` argument to the `ContractFunctionParameters`
    pub fn add_uint224(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint224", 28)
    }

    /// Add a `uint232` argument to the `ContractFunctionParameters`
    pub fn add_uint232(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint232", 29)
    }

    /// Add a `uint240` argument to the `ContractFunctionParameters`
    pub fn add_uint240(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint240", 30)
    }

    /// Add a `uint248` argument to the `ContractFunctionParameters`
    pub fn add_uint248(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint248", 31)
    }

    /// Add a `uint256` argument to the `ContractFunctionParameters`
    pub fn add_uint256(&mut self, val: BigUint) -> &mut Self {
        self.add_int(&val, "uint256", 32)
    }

    /// Add a `uint8[]` argument to the `ContractFunctionParameters`
    pub fn add_uint8_array(&mut self, values: &[u8]) -> &mut Self {
        self.add_int_array(values, "uint8[]", 1)
    }

    /// Add a `uint16[]` argument to the `ContractFunctionParameters`
    pub fn add_uint16_array(&mut self, values: &[u16]) -> &mut Self {
        self.add_int_array(values, "uint16[]", 2)
    }

    /// Add a `uint24[]` argument to the `ContractFunctionParameters`
    pub fn add_uint24_array(&mut self, values: &[u32]) -> &mut Self {
        self.add_int_array(values, "uint24[]", 3)
    }

    /// Add a `uint32[]` argument to the `ContractFunctionParameters`
    pub fn add_uint32_array(&mut self, values: &[u32]) -> &mut Self {
        self.add_int_array(values, "uint32[]", 4)
    }

    /// Add a `uint40[]` argument to the `ContractFunctionParameters`
    pub fn add_uint40_array(&mut self, values: &[u64]) -> &mut Self {
        self.add_int_array(values, "uint40[]", 5)
    }

    /// Add a `uint48[]` argument to the `ContractFunctionParameters`
    pub fn add_uint48_array(&mut self, values: &[u64]) -> &mut Self {
        self.add_int_array(values, "uint48[]", 6)
    }

    /// Add a `uint56[]` argument to the `ContractFunctionParameters`
    pub fn add_uint56_array(&mut self, values: &[u64]) -> &mut Self {
        self.add_int_array(values, "uint56[]", 7)
    }

    /// Add a `uint64[]` argument to the `ContractFunctionParameters`
    pub fn add_uint64_array(&mut self, values: &[u64]) -> &mut Self {
        self.add_int_array(values, "uint64[]", 8)
    }

    /// Add a `uint72[]` argument to the `ContractFunctionParameters`
    pub fn add_uint72_array(&mut self, values: &[u128]) -> &mut Self {
        self.add_int_array(values, "uint72[]", 9)
    }

    /// Add a `uint80[]` argument to the `ContractFunctionParameters`
    pub fn add_uint80_array(&mut self, values: &[u128]) -> &mut Self {
        self.add_int_array(values, "uint80[]", 10)
    }

    /// Add a `uint88[]` argument to the `ContractFunctionParameters`
    pub fn add_uint88_array(&mut self, values: &[u128]) -> &mut Self {
        self.add_int_array(values, "uint88[]", 11)
    }

    /// Add a `uint96[]` argument to the `ContractFunctionParameters`
    pub fn add_uint96_array(&mut self, values: &[u128]) -> &mut Self {
        self.add_int_array(values, "uint96[]", 12)
    }

    /// Add a `uint104[]` argument to the `ContractFunctionParameters`
    pub fn add_uint104_array(&mut self, values: &[u128]) -> &mut Self {
        self.add_int_array(values, "uint104[]", 13)
    }

    /// Add a `uint112[]` argument to the `ContractFunctionParameters`
    pub fn add_uint112_array(&mut self, values: &[u128]) -> &mut Self {
        self.add_int_array(values, "uint112[]", 14)
    }

    /// Add a `uint120[]` argument to the `ContractFunctionParameters`
    pub fn add_uint120_array(&mut self, values: &[u128]) -> &mut Self {
        self.add_int_array(values, "uint120[]", 15)
    }

    /// Add a `uint128[]` argument to the `ContractFunctionParameters`
    pub fn add_uint128_array(&mut self, values: &[u128]) -> &mut Self {
        self.add_int_array(values, "uint128[]", 16)
    }

    /// Add a `uint136[]` argument to the `ContractFunctionParameters`
    pub fn add_uint136_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint136[]", 17)
    }

    /// Add a `uint144[]` argument to the `ContractFunctionParameters`
    pub fn add_uint144_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint144[]", 18)
    }

    /// Add a `uint152[]` argument to the `ContractFunctionParameters`
    pub fn add_uint152_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint152[]", 19)
    }

    /// Add a `uint160[]` argument to the `ContractFunctionParameters`
    pub fn add_uint160_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint160[]", 20)
    }

    /// Add a `uint168[]` argument to the `ContractFunctionParameters`
    pub fn add_uint168_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint168[]", 21)
    }

    /// Add a `uint176[]` argument to the `ContractFunctionParameters`
    pub fn add_uint176_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint176[]", 22)
    }

    /// Add a `uint184[]` argument to the `ContractFunctionParameters`
    pub fn add_uint184_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint184[]", 23)
    }

    /// Add a `uint192[]` argument to the `ContractFunctionParameters`
    pub fn add_uint192_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint192[]", 24)
    }

    /// Add a `uint200[]` argument to the `ContractFunctionParameters`
    pub fn add_uint200_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint200[]", 25)
    }

    /// Add a `uint208[]` argument to the `ContractFunctionParameters`
    pub fn add_uint208_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint208[]", 26)
    }

    /// Add a `uint216[]` argument to the `ContractFunctionParameters`
    pub fn add_uint216_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint216[]", 27)
    }

    /// Add a `uint224[]` argument to the `ContractFunctionParameters`
    pub fn add_uint224_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint224[]", 28)
    }

    /// Add a `uint232[]` argument to the `ContractFunctionParameters`
    pub fn add_uint232_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint232[]", 29)
    }

    /// Add a `uint240[]` argument to the `ContractFunctionParameters`
    pub fn add_uint240_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint240[]", 30)
    }

    /// Add a `uint248[]` argument to the `ContractFunctionParameters`
    pub fn add_uint248_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint248[]", 31)
    }

    /// Add a `uint256[]` argument to the `ContractFunctionParameters`
    pub fn add_uint256_array(&mut self, values: &[BigUint]) -> &mut Self {
        self.add_int_array(values, "uint256[]", 32)
    }

    /// Add an `address` argument to the `ContractFunctionParameters`
    pub fn add_address(&mut self, address: &str) -> &mut Self {
        self.args.push(Argument {
            type_name: "address",
            value_bytes: encode_address(address).to_vec(),
            is_dynamic: false,
        });
        self
    }

    /// Add an `address[]` argument to the `ContractFunctionParameters`
    pub fn add_address_array(&mut self, addresses: &[&str]) -> &mut Self {
        self.args.push(Argument {
            type_name: "address[]",
            value_bytes: encode_array_of_32_byte_elements(
                addresses.iter().map(|addr| encode_address(addr)),
                addresses.len(),
            ),
            is_dynamic: true,
        });
        self
    }

    /// Add a `function` argument to the `ContractFunctionParameters`
    ///
    /// # Panics
    /// If the `address` isn't a valid evm address.
    pub fn add_function(
        &mut self,
        address: &str,
        mut selector: ContractFunctionSelector,
    ) -> &mut Self {
        let mut value_bytes = SolidityAddress::from_str(address).unwrap().to_bytes().to_vec();
        value_bytes.extend(selector.finish());
        right_pad_32_bytes(&mut value_bytes);

        self.args.push(Argument {
            type_name: "function",
            value_bytes: value_bytes,
            is_dynamic: false,
        });
        self
    }
}

fn left_pad_32_bytes(bytes: &[u8], is_negative: bool) -> [u8; 32] {
    let pad_byte = if is_negative { 0xFF } else { 0x00 };

    let mut result = [pad_byte; 32];
    result[(32 - bytes.len())..].copy_from_slice(bytes);
    result
}

fn truncate_and_left_pad_32_bytes<T>(val: &T, byte_count: isize) -> [u8; 32]
where
    T: IntEncode,
{
    let (is_negative, full_value_bytes) = val.get_is_negative_and_be_bytes();
    let truncated_value_bytes =
        &full_value_bytes[max((full_value_bytes.len() as isize) - byte_count, 0) as usize..];
    left_pad_32_bytes(truncated_value_bytes, is_negative)
}

/// Pads out `buf` so that it's len % 32 == 0
fn right_pad_32_bytes(buf: &mut Vec<u8>) {
    let rem = buf.len() % 32;
    if rem != 0 {
        let padding = [0_u8; 32];
        buf.extend_from_slice(&padding[..(32 - rem)])
    }
}

fn encode_address(address: &str) -> [u8; 32] {
    left_pad_32_bytes(SolidityAddress::from_str(address).unwrap().0 .0.as_slice(), false)
}

fn encode_dynamic_bytes(bytes: &[u8]) -> Vec<u8> {
    let mut out_bytes = left_pad_32_bytes(bytes.len().to_be_bytes().as_slice(), false).to_vec();
    out_bytes.extend(bytes);
    right_pad_32_bytes(&mut out_bytes);
    out_bytes
}

fn encode_array_of_dynamic_byte_arrays<I>(elements: I, elements_len: usize) -> Vec<u8>
where
    I: IntoIterator,
    I::Item: AsRef<[u8]>,
{
    let head_len = (elements_len + 1) * 32;
    let mut out_bytes = Vec::with_capacity(head_len);
    out_bytes.extend_from_slice(
        left_pad_32_bytes(elements_len.to_be_bytes().as_slice(), false).as_slice(),
    );
    let mut current_offset = elements_len * 32;
    let mut body_bytes: Vec<u8> = Vec::new();
    for element in elements {
        let element = element.as_ref();
        out_bytes.extend_from_slice(
            left_pad_32_bytes(current_offset.to_be_bytes().as_slice(), false).as_slice(),
        );
        current_offset += element.len();
        body_bytes.extend(element);
    }
    out_bytes.extend(body_bytes);
    out_bytes
}

fn encode_array_of_32_byte_elements<I>(elements: I, elements_len: usize) -> Vec<u8>
where
    I: IntoIterator<Item = [u8; 32]>,
{
    let mut out_bytes = left_pad_32_bytes(elements_len.to_be_bytes().as_slice(), false).to_vec();
    out_bytes.reserve(out_bytes.len() + (elements_len * 32));
    out_bytes.extend(elements.into_iter().flatten());
    out_bytes
}

fn encode_array_of_32_byte<T: AsBytes32 + ?Sized>(elements: &T) -> Vec<u8> {
    let slice = elements.as_bytes32();
    if slice.len() > 32 {
        panic!("32 bytes exceeded in contract function call")
    }

    let mut new_bytes = slice.to_vec();
    right_pad_32_bytes(&mut new_bytes);
    new_bytes
}

#[cfg(test)]
mod tests {
    use num_bigint::{
        BigInt,
        BigUint,
    };

    use crate::contract::contract_function_parameters::ContractFunctionParameters;
    use crate::contract::contract_function_selector::ContractFunctionSelector;

    #[test]
    fn misc_params() {
        let param_bytes = ContractFunctionParameters::new()
            .add_uint8(0x1)
            .add_int8(-0x2)
            .add_uint32(0x3)
            .add_int32(-0x4)
            .add_uint64(0x4)
            .add_int64(-0x5)
            .add_uint256(BigUint::from(0x6_u32))
            .add_int256(BigInt::from(-0x7))
            .add_uint8_array([0x1, 0x2, 0x3, 0x4].as_slice())
            .add_int8_array([-0x5, 0x6, 0x7, -0x8].as_slice())
            .add_uint32_array([0x9, 0xA, 0xB, 0xC].as_slice())
            .add_int32_array([-0xD, 0xE, 0xF, -0x10].as_slice())
            .add_uint64_array([0x11, 0x12, 0x13, 0x14].as_slice())
            .add_int64_array([-0x15, 0x16, 0x17, -0x18].as_slice())
            .add_uint256_array([BigUint::from(0x19_u32)].as_slice())
            .add_int256_array([BigInt::from(-0x1A)].as_slice())
            .to_bytes(Some("foo"));

        assert_eq!(
            hex::encode(param_bytes),
            "11bcd903\
                0000000000000000000000000000000000000000000000000000000000000001\
                fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\
                0000000000000000000000000000000000000000000000000000000000000003\
                fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\
                0000000000000000000000000000000000000000000000000000000000000004\
                fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\
                0000000000000000000000000000000000000000000000000000000000000006\
                fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9\
                0000000000000000000000000000000000000000000000000000000000000200\
                00000000000000000000000000000000000000000000000000000000000002a0\
                0000000000000000000000000000000000000000000000000000000000000340\
                00000000000000000000000000000000000000000000000000000000000003e0\
                0000000000000000000000000000000000000000000000000000000000000480\
                0000000000000000000000000000000000000000000000000000000000000520\
                00000000000000000000000000000000000000000000000000000000000005c0\
                0000000000000000000000000000000000000000000000000000000000000600\
                0000000000000000000000000000000000000000000000000000000000000004\
                0000000000000000000000000000000000000000000000000000000000000001\
                0000000000000000000000000000000000000000000000000000000000000002\
                0000000000000000000000000000000000000000000000000000000000000003\
                0000000000000000000000000000000000000000000000000000000000000004\
                0000000000000000000000000000000000000000000000000000000000000004\
                fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\
                0000000000000000000000000000000000000000000000000000000000000006\
                0000000000000000000000000000000000000000000000000000000000000007\
                fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\
                0000000000000000000000000000000000000000000000000000000000000004\
                0000000000000000000000000000000000000000000000000000000000000009\
                000000000000000000000000000000000000000000000000000000000000000a\
                000000000000000000000000000000000000000000000000000000000000000b\
                000000000000000000000000000000000000000000000000000000000000000c\
                0000000000000000000000000000000000000000000000000000000000000004\
                fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3\
                000000000000000000000000000000000000000000000000000000000000000e\
                000000000000000000000000000000000000000000000000000000000000000f\
                fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0\
                0000000000000000000000000000000000000000000000000000000000000004\
                0000000000000000000000000000000000000000000000000000000000000011\
                0000000000000000000000000000000000000000000000000000000000000012\
                0000000000000000000000000000000000000000000000000000000000000013\
                0000000000000000000000000000000000000000000000000000000000000014\
                0000000000000000000000000000000000000000000000000000000000000004\
                ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeb\
                0000000000000000000000000000000000000000000000000000000000000016\
                0000000000000000000000000000000000000000000000000000000000000017\
                ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe8\
                0000000000000000000000000000000000000000000000000000000000000001\
                0000000000000000000000000000000000000000000000000000000000000019\
                0000000000000000000000000000000000000000000000000000000000000001\
                ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe6"
        )
    }

    #[test]
    fn address_params() {
        let param_bytes = ContractFunctionParameters::new()
            .add_address("1122334455667788990011223344556677889900")
            .add_address("0x1122334455667788990011223344556677889900")
            .add_address_array(
                [
                    "1122334455667788990011223344556677889900",
                    "1122334455667788990011223344556677889900",
                ]
                .as_slice(),
            )
            .to_bytes(Some("foo"));

        assert_eq!(
            hex::encode(param_bytes),
            "7d48c86d\
                0000000000000000000000001122334455667788990011223344556677889900\
                0000000000000000000000001122334455667788990011223344556677889900\
                0000000000000000000000000000000000000000000000000000000000000060\
                0000000000000000000000000000000000000000000000000000000000000002\
                0000000000000000000000001122334455667788990011223344556677889900\
                0000000000000000000000001122334455667788990011223344556677889900"
        )
    }

    #[test]
    fn function_params() {
        let param_bytes = ContractFunctionParameters::new()
            .add_function(
                "1122334455667788990011223344556677889900",
                ContractFunctionSelector::from([1, 2, 3, 4]),
            )
            .add_function(
                "0x1122334455667788990011223344556677889900",
                ContractFunctionSelector::new("randomFunction").add_bool().clone(),
            )
            .to_bytes(Some("foo"));

        assert_eq!(
            hex::encode(param_bytes),
            "c99c40cd\
                1122334455667788990011223344556677889900010203040000000000000000\
                112233445566778899001122334455667788990063441d820000000000000000"
        );
    }

    // regression test for https://github.com/hashgraph/hedera-sdk-rust/issues/715
    #[test]
    fn long_string() {
        let s = "abcd".repeat(63);

        let bytes = ContractFunctionParameters::new().add_string(s).to_bytes(None);

        // sigh, the things we do to not have to manually format.
        let mut buf = String::with_capacity(bytes.len() * 2 + ((bytes.len() * 2) / 64));
        for line in bytes.chunks(32).map(hex::encode) {
            if !buf.is_empty() {
                buf.push('\n');
            }

            buf.push_str(&line);
        }

        expect_test::expect![[r#"
            0000000000000000000000000000000000000000000000000000000000000020
            00000000000000000000000000000000000000000000000000000000000000fc
            6162636461626364616263646162636461626364616263646162636461626364
            6162636461626364616263646162636461626364616263646162636461626364
            6162636461626364616263646162636461626364616263646162636461626364
            6162636461626364616263646162636461626364616263646162636461626364
            6162636461626364616263646162636461626364616263646162636461626364
            6162636461626364616263646162636461626364616263646162636461626364
            6162636461626364616263646162636461626364616263646162636461626364
            6162636461626364616263646162636461626364616263646162636400000000"#]]
        .assert_eq(&buf);
    }

    #[test]
    fn string_to_bytes32() {
        let s = "alice".to_string();

        let bytes = ContractFunctionParameters::new().add_bytes32(&s).to_bytes(None);

        // sigh, the things we do to not have to manually format.
        let mut buf = String::with_capacity(bytes.len() * 2 + ((bytes.len() * 2) / 64));
        for line in bytes.chunks(32).map(hex::encode) {
            if !buf.is_empty() {
                buf.push('\n');
            }

            buf.push_str(&line);
        }

        expect_test::expect!["616c696365000000000000000000000000000000000000000000000000000000"]
            .assert_eq(&buf);
    }

    #[test]
    fn str_to_bytes32() {
        let s = "alice";

        let bytes = ContractFunctionParameters::new().add_bytes32(s).to_bytes(None);

        let mut buf = String::with_capacity(bytes.len() * 2 + ((bytes.len() * 2) / 64));
        for line in bytes.chunks(32).map(hex::encode) {
            if !buf.is_empty() {
                buf.push('\n');
            }

            buf.push_str(&line);
        }

        expect_test::expect!["616c696365000000000000000000000000000000000000000000000000000000"]
            .assert_eq(&buf);
    }

    #[test]
    fn bytes_to_bytes32() {
        let mut array = [0u8; 32];

        let str_sample = "aliceandbob".as_bytes();

        for (i, &byte) in str_sample.iter().enumerate() {
            array[i] = byte;
        }

        let bytes = ContractFunctionParameters::new().add_bytes32(&array).to_bytes(None);

        let mut buf = String::with_capacity(bytes.len() * 2 + ((bytes.len() * 2) / 64));
        for line in bytes.chunks(32).map(hex::encode) {
            if !buf.is_empty() {
                buf.push('\n');
            }

            buf.push_str(&line);
        }

        expect_test::expect!["616c696365616e64626f62000000000000000000000000000000000000000000"]
            .assert_eq(&buf);
    }

    #[test]
    #[should_panic]
    fn bytes32_panic() {
        let str_sample = "alice bought some burgers from bob";

        // should panic if input is more than 32 bytes in add_bytes32
        ContractFunctionParameters::new().add_bytes32(str_sample).to_bytes(None);
    }
}
// Filename: src/contract/contract_function_result.rs
// SPDX-License-Identifier: Apache-2.0

use std::borrow::Cow;
use std::str;

use hedera_proto::services;
use num_bigint::{
    BigInt,
    BigUint,
};

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    ContractId,
    ContractLogInfo,
    ContractNonceInfo,
    FromProtobuf,
};

/// The result returned by a call to a smart contract function.
#[derive(Debug, Clone)]
pub struct ContractFunctionResult {
    /// The smart contract instance whose function was called.
    pub contract_id: ContractId,

    /// The new contract's 20-byte EVM address.
    pub evm_address: Option<ContractId>,

    /// The raw bytes returned by the function.
    pub bytes: Vec<u8>,

    /// Message if there was an error during smart contract execution.
    pub error_message: Option<String>,

    /// Bloom filter for record.
    pub bloom: Vec<u8>,

    /// Units of gas used to execute contract.
    pub gas_used: u64,

    /// The amount of gas available for the call.
    pub gas: u64,

    /// Number of HBAR sent (the function must be payable if this is nonzero).
    pub hbar_amount: u64,

    /// The parameters passed into the contract call.
    pub contract_function_parameters_bytes: Vec<u8>,

    /// The account that is the "sender." If not present it is the accountId from the transactionId.
    pub sender_account_id: Option<AccountId>,

    /// Logs that this call and any called functions produced.
    pub logs: Vec<ContractLogInfo>,

    /// A list of updated contract account nonces containing the new nonce value for each contract account.
    /// This is always empty in a ContractLocalCallQuery response, since no internal creations can happen in a static EVM call.
    pub contract_nonces: Vec<ContractNonceInfo>,

    /// If not null this field specifies what the value of the signer account nonce is post transaction execution.
    /// For transactions that don't update the signer nonce, this field should be null.
    pub signer_nonce: Option<u64>,
}

impl ContractFunctionResult {
    const SLOT_SIZE: usize = 32;

    #[must_use]
    fn get_fixed_bytes<const N: usize>(&self, slot: usize) -> Option<&[u8; N]> {
        self.get_fixed_bytes_at(slot * Self::SLOT_SIZE + (Self::SLOT_SIZE - N))
    }

    // fixme(sr): name is weird, but I can't think of a better one.
    // basically, there's `get_fixed_bytes` which works off of "slots" (multiples of 32 bytes), and this version, which can be from anywhere.
    #[must_use]
    fn get_fixed_bytes_at<const N: usize>(&self, offset: usize) -> Option<&[u8; N]> {
        self.bytes.get(offset..).and_then(|it| it.get(..N)).map(|it| it.try_into().unwrap())
    }

    // fixme(sr): name is weird, but I can't think of a better one.
    #[must_use]
    fn get_u32_at(&self, offset: usize) -> Option<u32> {
        self.get_fixed_bytes_at(28 + offset).map(|it| u32::from_be_bytes(*it))
    }

    #[must_use]
    fn offset_len_pair(&self, offset: usize) -> Option<(usize, usize)> {
        let offset = self.get_u32(offset)? as usize;
        let len = self.get_u32_at(offset)? as usize;
        Some((offset, len))
    }

    /// Get the whole raw function result.
    #[must_use]
    pub fn as_bytes(&self) -> &[u8] {
        &self.bytes
    }

    // note: This would be best named `get_str_lossy` but consistency :/
    /// Get the value at `index` as a solidity `string`.
    ///
    /// Theoretically, all strings here should be utf8, but this function does _lossy_ conversion.
    #[must_use]
    pub fn get_str(&self, index: usize) -> Option<Cow<str>> {
        self.get_bytes(index).map(String::from_utf8_lossy)
    }
    /// Get the value at `index` as a solidity `string[]`.
    ///
    /// Theoretically, all strings here should be utf8, but this function does _lossy_ conversion.
    #[must_use]
    pub fn get_str_array(&self, index: usize) -> Option<Vec<Cow<str>>> {
        let (offset, len) = self.offset_len_pair(index)?;

        let mut v = Vec::with_capacity(len);
        for i in 0..len {
            let str_offset =
                self.get_u32_at(offset + Self::SLOT_SIZE + (i * Self::SLOT_SIZE))? as usize;
            let str_offset = offset + str_offset + Self::SLOT_SIZE;
            let len = self.get_u32_at(str_offset)? as usize;

            let bytes =
                self.bytes.get((str_offset + Self::SLOT_SIZE)..).and_then(|it| it.get(..len))?;

            v.push(String::from_utf8_lossy(bytes));
        }

        Some(v)
    }

    /// Get the value at `index` as solidity `bytes`.
    #[must_use]
    pub fn get_bytes(&self, index: usize) -> Option<&[u8]> {
        let (offset, len) = self.offset_len_pair(index)?;
        self.bytes.get((offset + Self::SLOT_SIZE)..).and_then(|it| it.get(..len))
    }

    /// Get the value at `index` as solidity `bytes32`.
    ///
    /// This is the native word size for the solidity ABI.
    #[must_use]
    pub fn get_bytes32(&self, index: usize) -> Option<&[u8; 32]> {
        self.get_fixed_bytes(index)
    }

    /// Get the value at `index` as a solidity `address` and then hex-encode the result.
    #[must_use]
    pub fn get_address(&self, index: usize) -> Option<String> {
        self.get_fixed_bytes::<20>(index).map(hex::encode)
    }

    /// Get the value at `index` as a solidity `bool`.
    #[must_use]
    pub fn get_bool(&self, index: usize) -> Option<bool> {
        self.get_u8(index).map(|it| it != 0)
    }

    /// Get the value at `index` as a solidity `u8`.
    #[must_use]
    pub fn get_u8(&self, index: usize) -> Option<u8> {
        self.get_fixed_bytes(index).copied().map(u8::from_be_bytes)
    }

    /// Get the value at `index` as a solidity `i8`.
    #[must_use]
    pub fn get_i8(&self, index: usize) -> Option<i8> {
        self.get_fixed_bytes(index).copied().map(i8::from_be_bytes)
    }

    /// Get the value at `index` as a solidity `u32`.
    pub fn get_u32(&self, index: usize) -> Option<u32> {
        self.get_fixed_bytes(index).copied().map(u32::from_be_bytes)
    }

    /// Get the value at `index` as a solidity `i32`.
    #[must_use]
    pub fn get_i32(&self, index: usize) -> Option<i32> {
        self.get_fixed_bytes(index).copied().map(i32::from_be_bytes)
    }

    /// Get the value at `index` as a solidity `u64`.
    #[must_use]
    pub fn get_u64(&self, index: usize) -> Option<u64> {
        self.get_fixed_bytes(index).copied().map(u64::from_be_bytes)
    }

    /// Get the value at `index` as a solidity `i64`.
    #[must_use]
    pub fn get_i64(&self, index: usize) -> Option<i64> {
        self.get_fixed_bytes(index).copied().map(i64::from_be_bytes)
    }

    /// Get the value at `index` as a solidity `u256` (`uint`).
    ///
    /// This is the native unsigned integer size for the solidity ABI.
    #[must_use]
    pub fn get_u256(&self, index: usize) -> Option<BigUint> {
        self.get_bytes32(index).map(|it| BigUint::from_bytes_be(it))
    }

    /// Get the value at `index` as a solidity `i256` (`int`).
    ///
    /// This is the native unsigned integer size for the solidity ABI.
    #[must_use]
    pub fn get_i256(&self, index: usize) -> Option<BigInt> {
        self.get_bytes32(index).map(|it| BigInt::from_signed_bytes_be(it))
    }
}

impl FromProtobuf<services::ContractFunctionResult> for ContractFunctionResult {
    fn from_protobuf(pb: services::ContractFunctionResult) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let contract_id = pb_getf!(pb, contract_id)?;
        let contract_id = ContractId::from_protobuf(contract_id)?;

        let sender_account_id = Option::from_protobuf(pb.sender_id)?;

        let evm_address =
            pb.evm_address.and_then(|address| <[u8; 20]>::try_from(address).ok()).map(|address| {
                ContractId::from_evm_address_bytes(contract_id.shard, contract_id.realm, address)
            });

        let error_message = if pb.error_message.is_empty() { None } else { Some(pb.error_message) };

        // if an exception was thrown, the call result is encoded like the params
        // for a function `Error(string)`
        // https://solidity.readthedocs.io/en/v0.6.2/control-structures.html#revert
        // `map_or` wouldn't actually work here, because `contract_call_result
        #[allow(clippy::map_unwrap_or)]
        let bytes = if error_message.is_some() {
            pb.contract_call_result
                .strip_prefix(&[0x08, 0xc3, 0x79, 0xa0])
                .map(<[u8]>::to_vec)
                .unwrap_or(pb.contract_call_result)
        } else {
            pb.contract_call_result
        };

        let signer_nonce = pb.signer_nonce.map(|it| it as u64);

        Ok(Self {
            contract_id,
            bytes,
            error_message,
            bloom: pb.bloom,
            gas_used: pb.gas_used,
            gas: pb.gas as u64,
            hbar_amount: pb.amount as u64,
            contract_function_parameters_bytes: pb.function_parameters,
            sender_account_id,
            evm_address,
            logs: Vec::from_protobuf(pb.log_info)?,
            contract_nonces: Vec::from_protobuf(pb.contract_nonces)?,
            signer_nonce,
        })
    }
}

impl FromProtobuf<services::response::Response> for ContractFunctionResult {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let pb = pb_getv!(pb, ContractCallLocal, services::response::Response);

        let result = pb_getf!(pb, function_result)?;
        let result = ContractFunctionResult::from_protobuf(result)?;

        Ok(result)
    }
}

impl ToProtobuf for ContractFunctionResult {
    type Protobuf = services::ContractFunctionResult;

    fn to_protobuf(&self) -> Self::Protobuf {
        #[allow(deprecated)]
        services::ContractFunctionResult {
            contract_id: Some(self.contract_id.to_protobuf()),
            contract_call_result: self.bytes.clone(),
            error_message: self.error_message.clone().unwrap_or_default(),
            bloom: self.bloom.clone(),
            gas_used: self.gas,
            log_info: self.logs.to_protobuf(),
            created_contract_i_ds: Vec::new(),
            evm_address: self.evm_address.and_then(|it| it.evm_address.map(|it| it.to_vec())),
            gas: self.gas as i64,
            amount: self.hbar_amount as i64,
            function_parameters: self.contract_function_parameters_bytes.clone(),
            sender_id: self.sender_account_id.to_protobuf(),
            contract_nonces: self.contract_nonces.to_protobuf(),
            signer_nonce: self.signer_nonce.map(|it| it as i64),
        }
    }
}

#[cfg(test)]
mod tests {
    use hedera_proto::services;
    use hex_literal::hex;
    use num_bigint::{
        BigInt,
        BigUint,
    };

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::{
        AccountId,
        ContractFunctionResult,
        ContractId,
        ContractNonceInfo,
    };

    const CALL_RESULT: [u8; 320] = hex!(
        "00000000000000000000000000000000000000000000000000000000ffffffff"
        "7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        "00000000000000000000000011223344556677889900aabbccddeeff00112233"
        "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        "00000000000000000000000000000000000000000000000000000000000000c0"
        "0000000000000000000000000000000000000000000000000000000000000100"
        "000000000000000000000000000000000000000000000000000000000000000d"
        "48656c6c6f2c20776f726c642100000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000014"
        "48656c6c6f2c20776f726c642c20616761696e21000000000000000000000000"
    );

    const STRING_ARRAY_RESULT: [u8; 256] = hex!(
        "0000000000000000000000000000000000000000000000000000000000000020"
        "0000000000000000000000000000000000000000000000000000000000000002"
        "0000000000000000000000000000000000000000000000000000000000000040"
        "0000000000000000000000000000000000000000000000000000000000000080"
        "000000000000000000000000000000000000000000000000000000000000000C"
        "72616E646F6D2062797465730000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000000E"
        "72616E646F6D2062797465732032000000000000000000000000000000000000"
    );

    // previous one, just offset by a bit, to ensure the logic works.
    // notes below, where `slot` is just an offset at a multiple of 32 bytes.
    const STRING_ARRAY_RESULT_2: [u8; 320] = hex!(
        // empty value at slot 0
        "0000000000000000000000000000000000000000000000000000000000000000"
        // reference to slot 3 at slot 1
        // this is interpreted as a string[]
        "0000000000000000000000000000000000000000000000000000000000000060"
        // empty value at slot 2
        "0000000000000000000000000000000000000000000000000000000000000000"
        // length of string (2 items) at slot 3
        "0000000000000000000000000000000000000000000000000000000000000002"
        // relative offset of strings[0] (2 slots) at slot 4
        "0000000000000000000000000000000000000000000000000000000000000040"
        // relative offset of strings[1] (4 slots) at slot 5
        "0000000000000000000000000000000000000000000000000000000000000080"
        // length of strings[0] (12 bytes) at slot 6
        "000000000000000000000000000000000000000000000000000000000000000c"
        // first 12 bytes: value of strings[0], rest is filler, at slot 7
        "72616e646f6d206279746573000000000000000000000000c0ffee0000000000"
        // length of strings[1] (14 bytes) at slot 8
        "000000000000000000000000000000000000000000000000000000000000000e"
        // first 14 bytes: value of strings[0], rest is filler, at slot 7
        "72616E646F6D2062797465732032000000000000decaff000000000000000000"
    );

    #[test]
    fn evm_address() {
        const EVM_ADDRESS: [u8; 20] = hex!("98329e006610472e6b372c080833f6d79ed833cf");
        let result = services::ContractFunctionResult {
            contract_id: Some(ContractId::new(3, 7, 13).to_protobuf()),
            evm_address: Some(EVM_ADDRESS.to_vec()),
            ..Default::default()
        };

        let result = ContractFunctionResult::from_protobuf(result).unwrap();

        assert_eq!(result.contract_id, ContractId::new(3, 7, 13));

        // ensure that we follow *Java* behavior (every SDK has different behavior here)
        assert_eq!(result.evm_address, Some(ContractId::from_evm_address_bytes(3, 7, EVM_ADDRESS)));
    }

    #[test]
    #[allow(deprecated)]
    fn provides_results() {
        let result = services::ContractFunctionResult {
            contract_id: Some(ContractId::from(3).to_protobuf()),
            contract_call_result: CALL_RESULT.to_vec(),
            sender_id: Some(
                AccountId {
                    shard: 31,
                    realm: 41,
                    num: 65,
                    alias: None,
                    evm_address: None,
                    checksum: None,
                }
                .to_protobuf(),
            ),
            contract_nonces: vec![services::ContractNonceInfo {
                contract_id: Some(services::ContractId {
                    shard_num: 1,
                    realm_num: 2,
                    contract: Some(services::contract_id::Contract::ContractNum(3)),
                }),
                nonce: 10,
            }],
            ..Default::default()
        };

        let result = ContractFunctionResult::from_protobuf(result).unwrap();

        assert_eq!(result.get_bool(0).unwrap(), true);
        assert_eq!(result.get_i32(0).unwrap(), -1);
        assert_eq!(result.get_i64(0).unwrap(), u32::MAX as u64 as i64);
        assert_eq!(result.get_i256(0).unwrap(), BigInt::from(u32::MAX));
        assert_eq!(result.get_i256(1).unwrap(), (BigInt::from(1) << 255) - 1);
        assert_eq!(&result.get_address(2).unwrap(), "11223344556677889900aabbccddeeff00112233");
        assert_eq!(result.get_u32(3).unwrap(), u32::MAX);
        assert_eq!(result.get_u64(3).unwrap(), u64::MAX);
        // BigInteger can represent the full range and so should be 2^256 - 1
        assert_eq!(result.get_u256(3).unwrap(), (BigUint::from(1_u8) << 256) - 1_u32);

        assert_eq!(result.get_str(4).unwrap(), "Hello, world!");
        assert_eq!(result.get_str(5).unwrap(), "Hello, world, again!");

        assert_eq!(
            result.sender_account_id,
            Some(AccountId {
                shard: 31,
                realm: 41,
                num: 65,
                alias: None,
                evm_address: None,
                checksum: None,
            })
        );

        assert_eq!(
            result.contract_nonces,
            [ContractNonceInfo {
                contract_id: ContractId {
                    shard: 1,
                    realm: 2,
                    num: 3,
                    checksum: None,
                    evm_address: None
                },
                nonce: 10
            }]
        )
    }

    #[test]
    fn str_array_results() {
        let result = services::ContractFunctionResult {
            contract_id: Some(ContractId::from(3).to_protobuf()),
            contract_call_result: STRING_ARRAY_RESULT.to_vec(),
            ..Default::default()
        };

        let result = ContractFunctionResult::from_protobuf(result).unwrap();

        let strings = result.get_str_array(0).unwrap();
        assert_eq!(strings[0], "random bytes");
        assert_eq!(strings[1], "random bytes 2")
    }

    // previous one, just offset by a bit, to ensure the logic works.
    #[test]
    fn str_array_results2() {
        let result = services::ContractFunctionResult {
            contract_id: Some(ContractId::from(3).to_protobuf()),
            contract_call_result: STRING_ARRAY_RESULT_2.to_vec(),
            ..Default::default()
        };

        let result = ContractFunctionResult::from_protobuf(result).unwrap();

        let strings = result.get_str_array(1).unwrap();
        assert_eq!(strings[0], "random bytes");
        assert_eq!(strings[1], "random bytes 2")
    }
}
// Filename: src/contract/contract_function_selector.rs
use sha3::{
    Digest,
    Keccak256,
};

/// Builder class for Solidity function selectors.
#[derive(Debug, Clone)]
pub struct ContractFunctionSelector(ContractFunctionSelectorState);

// this isn't intended for storage on the heap, so, boxing the hasher is... futile.
#[allow(clippy::large_enum_variant)]
#[derive(Debug, Clone)]
enum ContractFunctionSelectorState {
    Building { digest: sha3::Keccak256, needs_comma: bool },
    Finished([u8; 4]),
}

use ContractFunctionSelectorState::{
    Building,
    Finished,
};

impl From<[u8; 4]> for ContractFunctionSelector {
    fn from(value: [u8; 4]) -> Self {
        Self(Finished(value))
    }
}

impl ContractFunctionSelector {
    pub fn new(func_name: &str) -> Self {
        let mut digest = Keccak256::new_with_prefix(func_name.as_bytes());
        digest.update(b"(");
        Self(Building { digest, needs_comma: false })
    }

    pub(crate) fn add_param_type(&mut self, param_type_name: &str) -> &mut Self {
        let Building { digest, needs_comma } = &mut self.0 else {
            panic!("Cannot add param type to finished ContractFunctionSelector")
        };

        if *needs_comma {
            digest.update(b",");
        }

        digest.update(param_type_name.as_bytes());
        *needs_comma = true;

        self
    }

    pub fn finish(&mut self) -> [u8; 4] {
        match &mut self.0 {
            Building { digest, .. } => {
                digest.update(b")");
                let finished_bytes = digest.clone().finalize()[0..4].try_into().unwrap();
                self.0 = Finished(finished_bytes);
                finished_bytes
            }
            Finished(finished_bytes) => *finished_bytes,
        }
    }

    pub fn add_string(&mut self) -> &mut Self {
        self.add_param_type("string")
    }

    pub fn add_string_array(&mut self) -> &mut Self {
        self.add_param_type("string[]")
    }

    pub fn add_bytes(&mut self) -> &mut Self {
        self.add_param_type("bytes")
    }

    pub fn add_bytes_array(&mut self) -> &mut Self {
        self.add_param_type("bytes[]")
    }

    pub fn add_bytes32(&mut self) -> &mut Self {
        self.add_param_type("bytes32")
    }

    pub fn add_bytes32_array(&mut self) -> &mut Self {
        self.add_param_type("bytes32[]")
    }

    pub fn add_bool(&mut self) -> &mut Self {
        self.add_param_type("bool")
    }

    pub fn add_int8(&mut self) -> &mut Self {
        self.add_param_type("int8")
    }

    pub fn add_int16(&mut self) -> &mut Self {
        self.add_param_type("int16")
    }

    pub fn add_int32(&mut self) -> &mut Self {
        self.add_param_type("int32")
    }

    pub fn add_int64(&mut self) -> &mut Self {
        self.add_param_type("int64")
    }

    pub fn add_int256(&mut self) -> &mut Self {
        self.add_param_type("int256")
    }

    pub fn add_uint8(&mut self) -> &mut Self {
        self.add_param_type("uint8")
    }

    pub fn add_uint16(&mut self) -> &mut Self {
        self.add_param_type("uint16")
    }

    pub fn add_uint32(&mut self) -> &mut Self {
        self.add_param_type("uint32")
    }

    pub fn add_uint64(&mut self) -> &mut Self {
        self.add_param_type("uint64")
    }

    pub fn add_uint256(&mut self) -> &mut Self {
        self.add_param_type("uint256")
    }

    pub fn add_int8_array(&mut self) -> &mut Self {
        self.add_param_type("int8[]")
    }

    pub fn add_int16_array(&mut self) -> &mut Self {
        self.add_param_type("int16[]")
    }

    pub fn add_int32_array(&mut self) -> &mut Self {
        self.add_param_type("int32[]")
    }

    pub fn add_int64_array(&mut self) -> &mut Self {
        self.add_param_type("int64[]")
    }

    pub fn add_int256_array(&mut self) -> &mut Self {
        self.add_param_type("int256[]")
    }

    pub fn add_uint8_array(&mut self) -> &mut Self {
        self.add_param_type("uint8[]")
    }

    pub fn add_uint16_array(&mut self) -> &mut Self {
        self.add_param_type("uint16[]")
    }

    pub fn add_uint32_array(&mut self) -> &mut Self {
        self.add_param_type("uint32[]")
    }

    pub fn add_uint64_array(&mut self) -> &mut Self {
        self.add_param_type("uint64[]")
    }

    pub fn add_uint256_array(&mut self) -> &mut Self {
        self.add_param_type("uint256[]")
    }

    pub fn add_address(&mut self) -> &mut Self {
        self.add_param_type("address")
    }

    pub fn add_address_array(&mut self) -> &mut Self {
        self.add_param_type("address[]")
    }

    pub fn add_function(&mut self) -> &mut Self {
        self.add_param_type("function")
    }
}

#[cfg(test)]
mod tests {
    use super::ContractFunctionSelector;

    #[test]
    fn selector() {
        let signature = ContractFunctionSelector::new("testFunction")
            .add_address()
            .add_address_array()
            .add_bool()
            .add_bytes()
            .add_bytes32()
            .add_bytes32_array()
            .add_bytes_array()
            .add_function()
            .add_int8()
            .add_int8_array()
            .add_int32()
            .add_int32_array()
            .add_int64()
            .add_int64_array()
            .add_int256()
            .add_int256_array()
            .add_uint8()
            .add_uint8_array()
            .add_uint32()
            .add_uint32_array()
            .add_uint64()
            .add_uint64_array()
            .add_uint256()
            .add_uint256_array()
            .add_string()
            .add_string_array()
            .finish();

        assert_eq!(hex::encode(signature), "4438e4ce");
    }

    #[test]
    #[should_panic]
    fn selector_error() {
        let mut signature = ContractFunctionSelector::new("testFunction");
        signature.add_address();

        signature.finish();

        signature.add_string_array();
    }
}
// Filename: src/contract/contract_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use hedera_proto::services;

use crate::entity_id::{
    Checksum,
    PartialEntityId,
    ValidateChecksums,
};
use crate::ethereum::SolidityAddress;
use crate::ledger_id::RefLedgerId;
use crate::{
    Client,
    EntityId,
    Error,
    FromProtobuf,
    ToProtobuf,
};

/// A unique identifier for a smart contract on Hiero.
#[derive(Hash, PartialEq, Eq, Clone, Copy)]
pub struct ContractId {
    /// A non-negative number identifying the shard containing this contract instance.
    pub shard: u64,

    /// A non-negative number identifying the realm within the shard containing this contract instance.
    pub realm: u64,

    /// A non-negative number identifying the entity within the realm containing this contract instance.
    ///
    /// Note: Exactly one of `evm_address` and `num` must exist.
    pub num: u64,

    /// A checksum if the contract ID was read from a user inputted string which inclueded a checksum
    pub checksum: Option<Checksum>,

    /// EVM address identifying the entity within the realm containing this contract instance.
    ///
    /// Note: Exactly one of `evm_address` and `num` must exist.
    pub evm_address: Option<[u8; 20]>,
}

impl ContractId {
    /// Create a `ContractId` from the given shard/realm/num
    #[must_use]
    pub const fn new(shard: u64, realm: u64, num: u64) -> Self {
        Self { shard, realm, num, evm_address: None, checksum: None }
    }

    /// Create a `ContractId` from a `shard.realm.evm_address` set.
    #[must_use]
    pub fn from_evm_address_bytes(shard: u64, realm: u64, evm_address: [u8; 20]) -> Self {
        Self { shard, realm, num: 0, evm_address: Some(evm_address), checksum: None }
    }

    /// Create a `ContractId` from a `shard.realm.evm_address` set.
    ///
    /// # Errors
    /// [`Error::BasicParse`] if `address` is invalid hex, or the wrong length.
    pub fn from_evm_address(shard: u64, realm: u64, address: &str) -> crate::Result<Self> {
        Ok(Self {
            shard,
            realm,
            num: 0,
            evm_address: Some(SolidityAddress::from_str(address)?.to_bytes()),
            checksum: None,
        })
    }

    /// Create a `ContractId` from a solidity address.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `address` cannot be parsed as a solidity address.
    pub fn from_solidity_address(address: &str) -> crate::Result<Self> {
        let EntityId { shard, realm, num, checksum } = EntityId::from_solidity_address(address)?;

        Ok(Self { shard, realm, num, evm_address: None, checksum })
    }

    /// Create a new `ContractId` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }

    /// Convert `self` into a solidity `address`.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `self.shard` is larger than `u32::MAX`.
    pub fn to_solidity_address(&self) -> crate::Result<String> {
        if let Some(address) = self.evm_address {
            return Ok(hex::encode(address));
        }

        EntityId { shard: self.shard, realm: self.realm, num: self.num, checksum: None }
            .to_solidity_address()
    }

    /// Convert `self` to a string with a valid checksum.
    ///
    /// # Errors
    /// - [`Error::CannotCreateChecksum`] if self has an `evm_address`.
    pub fn to_string_with_checksum(&self, client: &Client) -> Result<String, Error> {
        if self.evm_address.is_some() {
            Err(Error::CannotCreateChecksum)
        } else {
            Ok(EntityId::to_string_with_checksum(self.to_string(), client))
        }
    }

    /// Validates `self.checksum` (if it exists) for `client`.
    ///
    /// # Errors
    /// - [`Error::BadEntityId`] if there is a checksum, and the checksum is not valid for the client's `ledger_id`.
    pub fn validate_checksum(&self, client: &Client) -> Result<(), Error> {
        if self.evm_address.is_some() {
            Ok(())
        } else {
            EntityId::validate_checksum(self.shard, self.realm, self.num, self.checksum, client)
        }
    }
}

impl ValidateChecksums for ContractId {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        if self.evm_address.is_some() {
            Ok(())
        } else {
            EntityId::validate_checksum_for_ledger_id(
                self.shard,
                self.realm,
                self.num,
                self.checksum,
                ledger_id,
            )
        }
    }
}

impl Debug for ContractId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for ContractId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        if let Some(address) = &self.evm_address {
            write!(f, "{}.{}.{}", self.shard, self.realm, SolidityAddress::from_ref(address))
        } else {
            write!(f, "{}.{}.{}", self.shard, self.realm, self.num)
        }
    }
}

impl FromProtobuf<services::ContractId> for ContractId {
    fn from_protobuf(pb: services::ContractId) -> crate::Result<Self> {
        let contract = pb_getf!(pb, contract)?;

        let (num, evm_address) = match contract {
            services::contract_id::Contract::ContractNum(it) => (it as u64, None),
            services::contract_id::Contract::EvmAddress(it) => {
                (0, Some(SolidityAddress::try_from(it)?.to_bytes()))
            }
        };

        Ok(Self {
            evm_address,
            num,
            shard: pb.shard_num as u64,
            realm: pb.realm_num as u64,
            checksum: None,
        })
    }
}

impl ToProtobuf for ContractId {
    type Protobuf = services::ContractId;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ContractId {
            contract: Some(match &self.evm_address {
                Some(address) => services::contract_id::Contract::EvmAddress(address.to_vec()),
                None => services::contract_id::Contract::ContractNum(self.num as i64),
            }),
            realm_num: self.realm as i64,
            shard_num: self.shard as i64,
        }
    }
}

impl From<[u8; 20]> for ContractId {
    fn from(address: [u8; 20]) -> Self {
        Self { shard: 0, realm: 0, num: 0, evm_address: Some(address), checksum: None }
    }
}

impl From<u64> for ContractId {
    fn from(num: u64) -> Self {
        Self { num, shard: 0, realm: 0, evm_address: None, checksum: None }
    }
}

impl FromStr for ContractId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // override the error message for better context.
        let partial = PartialEntityId::from_str(s).map_err(|_| {
            Error::basic_parse(format!(
                "expecting <shard>.<realm>.<num> or <shard>.<realm>.<evm_address>, got `{s}`"
            ))
        })?;

        match partial {
            PartialEntityId::ShortNum(it) => Ok(Self::from(it)),
            PartialEntityId::LongNum(it) => Ok(Self::from(it)),
            PartialEntityId::ShortOther(_) => Err(Error::basic_parse(format!(
                "expecting <shard>.<realm>.<num> or <shard>.<realm>.<evm_address>, got `{s}`"
            ))),
            PartialEntityId::LongOther { shard, realm, last } => {
                let evm_address = Some(SolidityAddress::from_str(last)?.to_bytes());

                Ok(Self { shard, realm, num: 0, evm_address, checksum: None })
            }
        }
    }
}

impl From<EntityId> for ContractId {
    fn from(value: EntityId) -> Self {
        let EntityId { shard, realm, num, checksum } = value;

        Self { shard, realm, num, evm_address: None, checksum }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use crate::ContractId;

    #[test]
    fn parse() {
        expect_test::expect!["0.0.5005"]
            .assert_eq(&ContractId::from_str("0.0.5005").unwrap().to_string());
    }

    #[test]
    fn from_solidity_address() {
        expect_test::expect!["0.0.5005"].assert_eq(
            &ContractId::from_solidity_address("000000000000000000000000000000000000138D")
                .unwrap()
                .to_string(),
        );
    }

    #[test]
    fn from_solidity_address_0x() {
        expect_test::expect!["0.0.5005"].assert_eq(
            &ContractId::from_solidity_address("0x000000000000000000000000000000000000138D")
                .unwrap()
                .to_string(),
        );
    }

    #[test]
    fn from_evm_address() {
        expect_test::expect!["1.2.98329e006610472e6b372c080833f6d79ed833cf"].assert_eq(
            &ContractId::from_evm_address(1, 2, "98329e006610472e6B372C080833f6D79ED833cf")
                .unwrap()
                .to_string(),
        )
    }

    #[test]
    fn from_evm_address_0x() {
        expect_test::expect!["1.2.98329e006610472e6b372c080833f6d79ed833cf"].assert_eq(
            &ContractId::from_evm_address(1, 2, "0x98329e006610472e6B372C080833f6D79ED833cf")
                .unwrap()
                .to_string(),
        )
    }

    #[test]
    fn parse_evm_address() {
        expect_test::expect!["1.2.98329e006610472e6b372c080833f6d79ed833cf"].assert_eq(
            &ContractId::from_str("1.2.0x98329e006610472e6B372C080833f6D79ED833cf")
                .unwrap()
                .to_string(),
        )
    }

    #[test]
    fn to_from_bytes() {
        let a = ContractId::from_str("1.2.3").unwrap();
        assert_eq!(ContractId::from_bytes(&a.to_bytes()).unwrap(), a);
        let b = ContractId::from_evm_address(1, 2, "0x98329e006610472e6B372C080833f6D79ED833cf")
            .unwrap();
        assert_eq!(ContractId::from_bytes(&b.to_bytes()).unwrap(), b);
    }

    #[test]
    fn to_solidity_address() {
        expect_test::expect!["000000000000000000000000000000000000138d"].assert_eq(
            &ContractId { shard: 0, realm: 0, num: 5005, checksum: None, evm_address: None }
                .to_solidity_address()
                .unwrap(),
        )
    }

    #[test]
    fn to_solidity_address_2() {
        expect_test::expect!["98329e006610472e6b372c080833f6d79ed833cf"].assert_eq(
            &ContractId::from_evm_address(1, 2, "0x98329e006610472e6B372C080833f6D79ED833cf")
                .unwrap()
                .to_solidity_address()
                .unwrap(),
        )
    }
}
// Filename: src/contract/contract_info.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use time::{
    Duration,
    OffsetDateTime,
};

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    ContractId,
    FromProtobuf,
    Key,
    LedgerId,
    StakingInfo,
};

/// Current information on a smart contract instance.
#[derive(Debug, Clone)]
pub struct ContractInfo {
    /// ID of the contract instance, in the format used by transactions.
    pub contract_id: ContractId,

    /// ID of the cryptocurrency account owned by the contract instance,
    /// in the format used in transactions.
    pub account_id: AccountId,

    /// ID of both the contract instance and the cryptocurrency account owned by the contract
    /// instance, in the format used by Solidity.
    pub contract_account_id: String,

    /// The admin key of the contract instance.
    pub admin_key: Option<Key>,

    /// The current time at which this contract instance (and its account) is set to expire.
    pub expiration_time: Option<OffsetDateTime>,

    /// The auto renew period for this contract instance.
    pub auto_renew_period: Option<Duration>,

    /// Number of bytes of storage being used by this instance.
    pub storage: u64,

    /// The memo associated with the contract.
    pub contract_memo: String,

    /// The current balance, in tinybars.
    pub balance: u64,

    /// Whether the contract has been deleted.
    pub is_deleted: bool,

    /// ID of the an account to charge for auto-renewal of this contract.
    pub auto_renew_account_id: Option<AccountId>,

    /// The maximum number of tokens that a contract can be implicitly associated with.
    pub max_automatic_token_associations: u32,

    /// The ledger ID the response was returned from
    pub ledger_id: LedgerId,

    /// Staking metadata for this contract.
    pub staking_info: Option<StakingInfo>,
}

impl ContractInfo {
    /// Create a new `StakingInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::contract_get_info_response::ContractInfo>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::response::Response> for ContractInfo {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let response = pb_getv!(pb, ContractGetInfo, services::response::Response);
        let info = pb_getf!(response, contract_info)?;
        Self::from_protobuf(info)
    }
}

impl FromProtobuf<services::contract_get_info_response::ContractInfo> for ContractInfo {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::contract_get_info_response::ContractInfo) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let contract_id = pb_getf!(pb, contract_id)?;
        let account_id = pb_getf!(pb, account_id)?;
        let expiration_time = pb.expiration_time.map(Into::into);
        let auto_renew_period = pb.auto_renew_period.map(Into::into);
        let auto_renew_account_id = Option::from_protobuf(pb.auto_renew_account_id)?;
        let admin_key = Option::from_protobuf(pb.admin_key)?;
        let ledger_id = LedgerId::from_bytes(pb.ledger_id);
        let staking_info = Option::from_protobuf(pb.staking_info)?;

        Ok(Self {
            contract_id: ContractId::from_protobuf(contract_id)?,
            account_id: AccountId::from_protobuf(account_id)?,
            contract_account_id: pb.contract_account_id,
            is_deleted: pb.deleted,
            balance: pb.balance,
            expiration_time,
            auto_renew_period,
            auto_renew_account_id,
            contract_memo: pb.memo,
            max_automatic_token_associations: pb.max_automatic_token_associations as u32,
            admin_key,
            storage: pb.storage as u64,
            ledger_id,
            staking_info,
        })
    }
}

impl ToProtobuf for ContractInfo {
    type Protobuf = services::contract_get_info_response::ContractInfo;

    fn to_protobuf(&self) -> Self::Protobuf {
        #[allow(deprecated)]
        services::contract_get_info_response::ContractInfo {
            contract_id: Some(self.contract_id.to_protobuf()),
            account_id: Some(self.account_id.to_protobuf()),
            contract_account_id: self.contract_account_id.clone(),
            admin_key: self.admin_key.to_protobuf(),
            expiration_time: self.expiration_time.to_protobuf(),
            auto_renew_period: self.auto_renew_period.to_protobuf(),
            storage: self.storage as i64,
            memo: self.contract_memo.clone(),
            balance: self.balance,
            deleted: self.is_deleted,
            ledger_id: self.ledger_id.to_bytes(),
            auto_renew_account_id: self.auto_renew_account_id.to_protobuf(),
            max_automatic_token_associations: self.max_automatic_token_associations as i32,
            staking_info: self.staking_info.to_protobuf(),

            // unimplemented fields
            token_relationships: Vec::new(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use prost::Message;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::{
        ContractInfo,
        LedgerId,
    };

    fn make_info() -> services::contract_get_info_response::ContractInfo {
        services::contract_get_info_response::ContractInfo {
            contract_id: Some(services::ContractId {
                shard_num: 0,
                realm_num: 0,
                contract: Some(services::contract_id::Contract::ContractNum(1)),
            }),
            account_id: Some(services::AccountId {
                shard_num: 0,
                realm_num: 0,
                account: Some(services::account_id::Account::AccountNum(2)),
            }),
            contract_account_id: "0.0.3".to_owned(),
            expiration_time: Some(services::Timestamp { seconds: 0, nanos: 4_000 }),
            auto_renew_period: Some(services::Duration { seconds: 24 * 60 * 60 }),
            storage: 6,
            memo: "7".to_owned(),
            balance: 8,
            ledger_id: LedgerId::testnet().to_bytes(),

            ..Default::default()
        }
    }

    #[test]
    fn from_protobuf() {
        expect![[r#"
            ContractInfo {
                contract_id: "0.0.1",
                account_id: "0.0.2",
                contract_account_id: "0.0.3",
                admin_key: None,
                expiration_time: Some(
                    1970-01-01 0:00:00.000004 +00:00:00,
                ),
                auto_renew_period: Some(
                    Duration {
                        seconds: 86400,
                        nanoseconds: 0,
                    },
                ),
                storage: 6,
                contract_memo: "7",
                balance: 8,
                is_deleted: false,
                auto_renew_account_id: None,
                max_automatic_token_associations: 0,
                ledger_id: "testnet",
                staking_info: None,
            }
        "#]]
        .assert_debug_eq(&ContractInfo::from_protobuf(make_info()).unwrap());
    }

    #[test]
    fn to_protobuf() {
        expect![[r#"
            ContractInfo {
                contract_id: Some(
                    ContractId {
                        shard_num: 0,
                        realm_num: 0,
                        contract: Some(
                            ContractNum(
                                1,
                            ),
                        ),
                    },
                ),
                account_id: Some(
                    AccountId {
                        shard_num: 0,
                        realm_num: 0,
                        account: Some(
                            AccountNum(
                                2,
                            ),
                        ),
                    },
                ),
                contract_account_id: "0.0.3",
                admin_key: None,
                expiration_time: Some(
                    Timestamp {
                        seconds: 0,
                        nanos: 4000,
                    },
                ),
                auto_renew_period: Some(
                    Duration {
                        seconds: 86400,
                    },
                ),
                storage: 6,
                memo: "7",
                balance: 8,
                deleted: false,
                token_relationships: [],
                ledger_id: [
                    1,
                ],
                auto_renew_account_id: None,
                max_automatic_token_associations: 0,
                staking_info: None,
            }
        "#]]
        .assert_debug_eq(&ContractInfo::from_protobuf(make_info()).unwrap().to_protobuf())
    }

    #[test]
    fn from_bytes() {
        expect![[r#"
            ContractInfo {
                contract_id: "0.0.1",
                account_id: "0.0.2",
                contract_account_id: "0.0.3",
                admin_key: None,
                expiration_time: Some(
                    1970-01-01 0:00:00.000004 +00:00:00,
                ),
                auto_renew_period: Some(
                    Duration {
                        seconds: 86400,
                        nanoseconds: 0,
                    },
                ),
                storage: 6,
                contract_memo: "7",
                balance: 8,
                is_deleted: false,
                auto_renew_account_id: None,
                max_automatic_token_associations: 0,
                ledger_id: "testnet",
                staking_info: None,
            }
        "#]]
        .assert_debug_eq(&ContractInfo::from_bytes(&make_info().encode_to_vec()).unwrap());
    }
}
// Filename: src/contract/contract_info_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    ContractId,
    ContractInfo,
    Error,
    Query,
    ToProtobuf,
    ValidateChecksums,
};

/// Get information about a smart contract instance.
pub type ContractInfoQuery = Query<ContractInfoQueryData>;

#[derive(Default, Debug, Clone)]
pub struct ContractInfoQueryData {
    /// The contract for which information is requested.
    contract_id: Option<ContractId>,
}

impl ContractInfoQuery {
    /// Returns the contract for which information is requested.
    #[must_use]
    pub fn get_contract_id(&self) -> Option<ContractId> {
        self.data.contract_id
    }

    /// Sets the contract for which information is requested.
    pub fn contract_id(&mut self, contract_id: ContractId) -> &mut Self {
        self.data.contract_id = Some(contract_id);
        self
    }
}

impl From<ContractInfoQueryData> for AnyQueryData {
    #[inline]
    fn from(data: ContractInfoQueryData) -> Self {
        Self::ContractInfo(data)
    }
}

impl ToQueryProtobuf for ContractInfoQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let contract_id = self.contract_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::ContractGetInfo(services::ContractGetInfoQuery {
                contract_id,
                header: Some(header),
            })),
        }
    }
}

impl QueryExecute for ContractInfoQueryData {
    type Response = ContractInfo;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async {
            SmartContractServiceClient::new(channel).get_contract_info(request).await
        })
    }
}

impl ValidateChecksums for ContractInfoQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.contract_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        ContractId,
        ContractInfoQuery,
        Hbar,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    ContractGetInfo(
                        ContractGetInfoQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            contract_id: Some(
                                ContractId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    contract: Some(
                                        ContractNum(
                                            5005,
                                        ),
                                    ),
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &ContractInfoQuery::new()
                .contract_id(crate::ContractId {
                    shard: 0,
                    realm: 0,
                    num: 5005,
                    evm_address: None,
                    checksum: None,
                })
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        );
    }

    #[test]
    fn get_set_contract_id() {
        let mut query = ContractInfoQuery::new();
        query.contract_id(ContractId::new(0, 0, 5005));

        assert_eq!(query.get_contract_id(), Some(ContractId::new(0, 0, 5005)));
    }
}
// Filename: src/contract/contract_log_info.rs
use hedera_proto::services;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::ContractId;

/// The log information for an event returned by a smart contract function call.
/// One function call may return several such events.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ContractLogInfo {
    /// Address of the contract that emitted the event.
    pub contract_id: ContractId,

    /// Bloom filter for this log.
    pub bloom: Vec<u8>,

    /// A list of topics this log is relevent to.
    pub topics: Vec<Vec<u8>>,

    /// The log's data payload.
    pub data: Vec<u8>,
}

impl ContractLogInfo {
    /// Create a new `ContractLogInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::ContractLoginfo> for ContractLogInfo {
    fn from_protobuf(pb: services::ContractLoginfo) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Ok(Self {
            contract_id: ContractId::from_protobuf(pb_getf!(pb, contract_id)?)?,
            bloom: pb.bloom,
            topics: pb.topic,
            data: pb.data,
        })
    }
}

impl ToProtobuf for ContractLogInfo {
    type Protobuf = services::ContractLoginfo;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            contract_id: Some(self.contract_id.to_protobuf()),
            bloom: self.bloom.clone(),
            topic: self.topics.clone(),
            data: self.data.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use prost::Message;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::ContractLogInfo;

    fn make_info() -> services::ContractLoginfo {
        services::ContractLoginfo {
            contract_id: Some(services::ContractId {
                shard_num: 0,
                realm_num: 0,
                contract: Some(services::contract_id::Contract::ContractNum(10)),
            }),
            bloom: b"bloom".to_vec(),
            topic: Vec::from([b"bloom".to_vec()]),
            data: b"data".to_vec(),
        }
    }

    #[test]
    fn from_protobuf() {
        expect![[r#"
            ContractLogInfo {
                contract_id: "0.0.10",
                bloom: [
                    98,
                    108,
                    111,
                    111,
                    109,
                ],
                topics: [
                    [
                        98,
                        108,
                        111,
                        111,
                        109,
                    ],
                ],
                data: [
                    100,
                    97,
                    116,
                    97,
                ],
            }
        "#]]
        .assert_debug_eq(&ContractLogInfo::from_protobuf(make_info()).unwrap());
    }

    #[test]
    fn to_protobuf() {
        expect![[r#"
            ContractLoginfo {
                contract_id: Some(
                    ContractId {
                        shard_num: 0,
                        realm_num: 0,
                        contract: Some(
                            ContractNum(
                                10,
                            ),
                        ),
                    },
                ),
                bloom: [
                    98,
                    108,
                    111,
                    111,
                    109,
                ],
                topic: [
                    [
                        98,
                        108,
                        111,
                        111,
                        109,
                    ],
                ],
                data: [
                    100,
                    97,
                    116,
                    97,
                ],
            }
        "#]]
        .assert_debug_eq(&ContractLogInfo::from_protobuf(make_info()).unwrap().to_protobuf())
    }

    #[test]
    fn from_bytes() {
        expect![[r#"
            ContractLogInfo {
                contract_id: "0.0.10",
                bloom: [
                    98,
                    108,
                    111,
                    111,
                    109,
                ],
                topics: [
                    [
                        98,
                        108,
                        111,
                        111,
                        109,
                    ],
                ],
                data: [
                    100,
                    97,
                    116,
                    97,
                ],
            }
        "#]]
        .assert_debug_eq(&ContractLogInfo::from_bytes(&make_info().encode_to_vec()).unwrap());
    }
}
// Filename: src/contract/contract_nonce_info.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::ContractId;

/// Info about a contract account's nonce value.
/// The nonce for a contract is only incremented when that contract creates another contract.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ContractNonceInfo {
    /// The contract's ID.
    pub contract_id: ContractId,
    /// The contract's nonce.
    pub nonce: u64,
}

impl ContractNonceInfo {
    /// Create a new `ContractNonceInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::ContractNonceInfo> for ContractNonceInfo {
    fn from_protobuf(pb: services::ContractNonceInfo) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Ok(Self {
            contract_id: ContractId::from_protobuf(pb_getf!(pb, contract_id)?)?,
            nonce: pb.nonce as u64,
        })
    }
}

impl ToProtobuf for ContractNonceInfo {
    type Protobuf = services::ContractNonceInfo;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            contract_id: Some(self.contract_id.to_protobuf()),
            nonce: self.nonce as i64,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::ContractNonceInfo;

    const INFO: services::ContractNonceInfo = services::ContractNonceInfo {
        contract_id: Some(services::ContractId {
            shard_num: 0,
            realm_num: 0,
            contract: Some(services::contract_id::Contract::ContractNum(2)),
        }),
        nonce: 2,
    };

    #[test]
    fn from_protobuf() {
        expect![[r#"
            ContractNonceInfo {
                contract_id: "0.0.2",
                nonce: 2,
            }
        "#]]
        .assert_debug_eq(&ContractNonceInfo::from_protobuf(INFO).unwrap());
    }

    #[test]
    fn to_protobuf() {
        expect![[r#"
            ContractNonceInfo {
                contract_id: Some(
                    ContractId {
                        shard_num: 0,
                        realm_num: 0,
                        contract: Some(
                            ContractNum(
                                2,
                            ),
                        ),
                    },
                ),
                nonce: 2,
            }
        "#]]
        .assert_debug_eq(&ContractNonceInfo::from_protobuf(INFO).unwrap().to_protobuf());
    }

    #[test]
    fn from_bytes() {
        expect![[r#"
            ContractNonceInfo {
                contract_id: Some(
                    ContractId {
                        shard_num: 0,
                        realm_num: 0,
                        contract: Some(
                            ContractNum(
                                2,
                            ),
                        ),
                    },
                ),
                nonce: 2,
            }
        "#]]
        .assert_debug_eq(
            &ContractNonceInfo::from_bytes(&prost::Message::encode_to_vec(&INFO))
                .unwrap()
                .to_protobuf(),
        );
    }
}
// Filename: src/contract/contract_update_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use time::{
    Duration,
    OffsetDateTime,
};
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::staked_id::StakedId;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    ContractId,
    Error,
    Key,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

/// Updates the fields of a smart contract to the given values.
pub type ContractUpdateTransaction = Transaction<ContractUpdateTransactionData>;

#[derive(Debug, Default, Clone)]
pub struct ContractUpdateTransactionData {
    contract_id: Option<ContractId>,

    expiration_time: Option<OffsetDateTime>,

    admin_key: Option<Key>,

    auto_renew_period: Option<Duration>,

    contract_memo: Option<String>,

    max_automatic_token_associations: Option<i32>,

    auto_renew_account_id: Option<AccountId>,

    proxy_account_id: Option<AccountId>,

    /// ID of the account or node to which this contract is staking, if any.
    staked_id: Option<StakedId>,

    decline_staking_reward: Option<bool>,
}

impl ContractUpdateTransaction {
    /// Returns the contract to be updated.
    #[must_use]
    pub fn get_contract_id(&self) -> Option<ContractId> {
        self.data().contract_id
    }

    /// Sets the contract to be updated.
    pub fn contract_id(&mut self, contract_id: ContractId) -> &mut Self {
        self.data_mut().contract_id = Some(contract_id);
        self
    }

    /// Returns the new admin key.
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.data().admin_key.as_ref()
    }

    /// Sets the new admin key.
    pub fn admin_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().admin_key = Some(key.into());
        self
    }

    /// Returns the new expiration time to extend to (ignored if equal to or before the current one).
    #[must_use]
    pub fn get_expiration_time(&self) -> Option<OffsetDateTime> {
        self.data().expiration_time
    }

    /// Sets the new expiration time to extend to (ignored if equal to or before the current one).
    pub fn expiration_time(&mut self, at: OffsetDateTime) -> &mut Self {
        self.data_mut().expiration_time = Some(at);
        self
    }

    /// Returns the auto renew period for this smart contract.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.data().auto_renew_period
    }

    /// Sets the auto renew period for this smart contract.
    pub fn auto_renew_period(&mut self, period: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = Some(period);
        self
    }

    /// Returns the new memo for the smart contract.
    #[must_use]
    pub fn get_contract_memo(&self) -> Option<&str> {
        self.data().contract_memo.as_deref()
    }

    /// Sets the new memo for the smart contract.
    pub fn contract_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().contract_memo = Some(memo.into());
        self
    }

    /// Returns the maximum number of tokens that this contract can be automatically associated with.
    #[must_use]
    pub fn get_max_automatic_token_associations(&self) -> Option<i32> {
        self.data().max_automatic_token_associations
    }

    /// Sets the maximum number of tokens that this contract can be automatically associated with.
    pub fn max_automatic_token_associations(&mut self, max: i32) -> &mut Self {
        self.data_mut().max_automatic_token_associations = Some(max);
        self
    }

    /// Returns the account to be used at the contract's expiration time to extend the
    /// life of the contract.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the account to be used at the contract's expiration time to extend the
    /// life of the contract.
    pub fn auto_renew_account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(account_id);
        self
    }

    /// Returns the ID of the account to which this contract is proxy staked.
    #[must_use]
    pub fn get_proxy_account_id(&self) -> Option<AccountId> {
        self.data().proxy_account_id
    }

    /// Sets the ID of the account to which this contract is proxy staked.
    pub fn proxy_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().proxy_account_id = Some(id);
        self
    }

    /// Returns the ID of the account to which this contract is staking.
    #[must_use]
    pub fn get_staked_account_id(&self) -> Option<AccountId> {
        self.data().staked_id.and_then(StakedId::to_account_id)
    }

    /// Sets the ID of the account to which this contract is staking.
    /// This is mutually exclusive with `staked_node_id`.
    pub fn staked_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().staked_id = Some(id.into());
        self
    }

    /// Returns the ID of the node to which this contract is staking.
    #[must_use]
    pub fn get_staked_node_id(&self) -> Option<u64> {
        self.data().staked_id.and_then(StakedId::to_node_id)
    }

    /// Sets the ID of the node to which this contract is staking.
    /// This is mutually exclusive with `staked_account_id`.
    pub fn staked_node_id(&mut self, id: u64) -> &mut Self {
        self.data_mut().staked_id = Some(id.into());
        self
    }

    /// Returns `true` if the contract will be updated decline staking rewards,
    /// `false` if it will be updated to _not_,
    /// and `None` if it will not be updated.
    #[must_use]
    pub fn get_decline_staking_reward(&self) -> Option<bool> {
        self.data().decline_staking_reward
    }

    /// Sets to true, the contract declines receiving a staking reward. The default value is false.
    pub fn decline_staking_reward(&mut self, decline: bool) -> &mut Self {
        self.data_mut().decline_staking_reward = Some(decline);
        self
    }
}

impl TransactionData for ContractUpdateTransactionData {}

impl TransactionExecute for ContractUpdateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { SmartContractServiceClient::new(channel).update_contract(request).await })
    }
}

impl ValidateChecksums for ContractUpdateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.contract_id.validate_checksums(ledger_id)?;
        self.auto_renew_account_id.validate_checksums(ledger_id)?;
        self.staked_id.validate_checksums(ledger_id)?;
        self.proxy_account_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for ContractUpdateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::ContractUpdateInstance(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for ContractUpdateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::ContractUpdateInstance(self.to_protobuf())
    }
}

impl FromProtobuf<services::ContractUpdateTransactionBody> for ContractUpdateTransactionData {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::ContractUpdateTransactionBody) -> crate::Result<Self> {
        use services::contract_update_transaction_body::MemoField;

        Ok(Self {
            contract_id: Option::from_protobuf(pb.contract_id)?,
            expiration_time: pb.expiration_time.map(Into::into),
            admin_key: Option::from_protobuf(pb.admin_key)?,
            auto_renew_period: pb.auto_renew_period.map(Into::into),
            contract_memo: pb.memo_field.map(|it| match it {
                MemoField::Memo(it) | MemoField::MemoWrapper(it) => it,
            }),
            max_automatic_token_associations: pb.max_automatic_token_associations,
            auto_renew_account_id: Option::from_protobuf(pb.auto_renew_account_id)?,
            proxy_account_id: Option::from_protobuf(pb.proxy_account_id)?,
            staked_id: Option::from_protobuf(pb.staked_id)?,
            decline_staking_reward: pb.decline_reward,
        })
    }
}

impl ToProtobuf for ContractUpdateTransactionData {
    type Protobuf = services::ContractUpdateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let contract_id = self.contract_id.to_protobuf();
        let expiration_time = self.expiration_time.map(Into::into);
        let admin_key = self.admin_key.to_protobuf();
        let auto_renew_period = self.auto_renew_period.map(Into::into);
        let auto_renew_account_id = self.auto_renew_account_id.to_protobuf();

        let staked_id = self.staked_id.map(|id| match id {
            StakedId::NodeId(id) => {
                services::contract_update_transaction_body::StakedId::StakedNodeId(id as i64)
            }

            StakedId::AccountId(id) => {
                services::contract_update_transaction_body::StakedId::StakedAccountId(
                    id.to_protobuf(),
                )
            }
        });

        let memo_field = self
            .contract_memo
            .clone()
            .map(services::contract_update_transaction_body::MemoField::MemoWrapper);

        #[allow(deprecated)]
        services::ContractUpdateTransactionBody {
            contract_id,
            expiration_time,
            admin_key,
            proxy_account_id: self.proxy_account_id.to_protobuf(),
            auto_renew_period,
            max_automatic_token_associations: self
                .max_automatic_token_associations
                .map(|max| max as i32),
            auto_renew_account_id,
            decline_reward: self.decline_staking_reward,
            staked_id,
            file_id: None,
            memo_field,
        }
    }
}

impl From<ContractUpdateTransactionData> for AnyTransactionData {
    fn from(transaction: ContractUpdateTransactionData) -> Self {
        Self::ContractUpdate(transaction)
    }
}

#[cfg(test)]
mod tests {

    use expect_test::expect;
    use hedera_proto::services;
    use time::{
        Duration,
        OffsetDateTime,
    };

    use crate::contract::ContractUpdateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        ContractId,
        ContractUpdateTransaction,
        PublicKey,
    };

    fn admin_key() -> PublicKey {
        unused_private_key().public_key()
    }

    const CONTRACT_ID: ContractId = ContractId::new(0, 0, 5007);

    const MAX_AUTOMATIC_TOKEN_ASSOCIATIONS: i32 = 101;
    const AUTO_RENEW_PERIOD: Duration = Duration::days(1);
    const CONTRACT_MEMO: &str = "3";
    const EXPIRATION_TIME: OffsetDateTime =
        match OffsetDateTime::from_unix_timestamp_nanos(4_000_000) {
            Ok(it) => it,
            Err(_) => panic!("Panic in `const` unwrap"),
        };
    const PROXY_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 4);
    const AUTO_RENEW_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 30);
    const STAKED_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 3);
    const STAKED_NODE_ID: u64 = 4;

    fn make_transaction() -> ContractUpdateTransaction {
        let mut tx = ContractUpdateTransaction::new_for_tests();

        tx.contract_id(CONTRACT_ID)
            .admin_key(admin_key())
            .max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .contract_memo(CONTRACT_MEMO)
            .expiration_time(EXPIRATION_TIME)
            .proxy_account_id(PROXY_ACCOUNT_ID)
            .auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID)
            .staked_account_id(STAKED_ACCOUNT_ID)
            .freeze()
            .unwrap();

        tx
    }

    fn make_transaction2() -> ContractUpdateTransaction {
        let mut tx = ContractUpdateTransaction::new_for_tests();

        tx.contract_id(CONTRACT_ID)
            .admin_key(admin_key())
            .max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .contract_memo(CONTRACT_MEMO)
            .expiration_time(EXPIRATION_TIME)
            .proxy_account_id(PROXY_ACCOUNT_ID)
            .auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID)
            .staked_node_id(STAKED_NODE_ID)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ContractUpdateInstance(
                ContractUpdateTransactionBody {
                    contract_id: Some(
                        ContractId {
                            shard_num: 0,
                            realm_num: 0,
                            contract: Some(
                                ContractNum(
                                    5007,
                                ),
                            ),
                        },
                    ),
                    expiration_time: Some(
                        Timestamp {
                            seconds: 0,
                            nanos: 4000000,
                        },
                    ),
                    admin_key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    proxy_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    4,
                                ),
                            ),
                        },
                    ),
                    auto_renew_period: Some(
                        Duration {
                            seconds: 86400,
                        },
                    ),
                    file_id: None,
                    max_automatic_token_associations: Some(
                        101,
                    ),
                    auto_renew_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    30,
                                ),
                            ),
                        },
                    ),
                    decline_reward: None,
                    memo_field: Some(
                        MemoWrapper(
                            "3",
                        ),
                    ),
                    staked_id: Some(
                        StakedAccountId(
                            AccountId {
                                shard_num: 0,
                                realm_num: 0,
                                account: Some(
                                    AccountNum(
                                        3,
                                    ),
                                ),
                            },
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn serialize2() {
        let tx = make_transaction2();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ContractUpdateInstance(
                ContractUpdateTransactionBody {
                    contract_id: Some(
                        ContractId {
                            shard_num: 0,
                            realm_num: 0,
                            contract: Some(
                                ContractNum(
                                    5007,
                                ),
                            ),
                        },
                    ),
                    expiration_time: Some(
                        Timestamp {
                            seconds: 0,
                            nanos: 4000000,
                        },
                    ),
                    admin_key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    proxy_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    4,
                                ),
                            ),
                        },
                    ),
                    auto_renew_period: Some(
                        Duration {
                            seconds: 86400,
                        },
                    ),
                    file_id: None,
                    max_automatic_token_associations: Some(
                        101,
                    ),
                    auto_renew_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    30,
                                ),
                            ),
                        },
                    ),
                    decline_reward: None,
                    memo_field: Some(
                        MemoWrapper(
                            "3",
                        ),
                    ),
                    staked_id: Some(
                        StakedNodeId(
                            4,
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes2() {
        let tx = make_transaction2();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        #[allow(deprecated)]
        let tx = services::ContractUpdateTransactionBody {
            contract_id: Some(CONTRACT_ID.to_protobuf()),
            expiration_time: Some(EXPIRATION_TIME.to_protobuf()),
            admin_key: Some(admin_key().to_protobuf()),
            proxy_account_id: Some(PROXY_ACCOUNT_ID.to_protobuf()),
            auto_renew_period: Some(AUTO_RENEW_PERIOD.to_protobuf()),
            max_automatic_token_associations: Some(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS),
            auto_renew_account_id: Some(AUTO_RENEW_ACCOUNT_ID.to_protobuf()),
            decline_reward: None,
            memo_field: Some(services::contract_update_transaction_body::MemoField::MemoWrapper(
                CONTRACT_MEMO.to_owned(),
            )),
            staked_id: Some(services::contract_update_transaction_body::StakedId::StakedAccountId(
                STAKED_ACCOUNT_ID.to_protobuf(),
            )),
            file_id: None,
        };

        let tx = ContractUpdateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.contract_id, Some(CONTRACT_ID));
        assert_eq!(tx.admin_key, Some(admin_key().into()));
        assert_eq!(tx.max_automatic_token_associations, Some(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS));
        assert_eq!(tx.auto_renew_period, Some(AUTO_RENEW_PERIOD));
        assert_eq!(tx.contract_memo, Some(CONTRACT_MEMO.to_owned()));
        assert_eq!(tx.expiration_time, Some(EXPIRATION_TIME));
        assert_eq!(tx.proxy_account_id, Some(PROXY_ACCOUNT_ID));
        assert_eq!(tx.auto_renew_account_id, Some(AUTO_RENEW_ACCOUNT_ID));
        assert_eq!(tx.staked_id, Some(crate::staked_id::StakedId::AccountId(STAKED_ACCOUNT_ID)));
    }

    mod get_set {
        use super::*;

        #[test]
        fn contract_id() {
            let mut tx = ContractUpdateTransaction::new();
            tx.contract_id(CONTRACT_ID);

            assert_eq!(tx.get_contract_id(), Some(CONTRACT_ID));
        }

        #[test]
        #[should_panic]
        fn contract_id_frozen_panics() {
            make_transaction().contract_id(CONTRACT_ID);
        }

        #[test]
        fn admin_key() {
            let mut tx = ContractUpdateTransaction::new();
            tx.admin_key(super::admin_key());

            assert_eq!(tx.get_admin_key(), Some(&super::admin_key().into()));
        }

        #[test]
        #[should_panic]
        fn admin_key_frozen_panics() {
            make_transaction().admin_key(super::admin_key());
        }

        #[test]
        fn max_automatic_token_associations() {
            let mut tx = ContractUpdateTransaction::new();
            tx.max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);

            assert_eq!(
                tx.get_max_automatic_token_associations(),
                Some(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS)
            );
        }

        #[test]
        #[should_panic]
        fn max_automatic_token_associations_frozen_panics() {
            make_transaction().max_automatic_token_associations(MAX_AUTOMATIC_TOKEN_ASSOCIATIONS);
        }

        #[test]
        fn auto_renew_period() {
            let mut tx = ContractUpdateTransaction::new();
            tx.auto_renew_period(AUTO_RENEW_PERIOD);

            assert_eq!(tx.get_auto_renew_period(), Some(AUTO_RENEW_PERIOD));
        }

        #[test]
        #[should_panic]
        fn auto_renew_period_frozen_panics() {
            make_transaction().auto_renew_period(AUTO_RENEW_PERIOD);
        }

        #[test]
        fn contract_memo() {
            let mut tx = ContractUpdateTransaction::new();
            tx.contract_memo(CONTRACT_MEMO);

            assert_eq!(tx.get_contract_memo(), Some(CONTRACT_MEMO));
        }

        #[test]
        #[should_panic]
        fn contract_memo_frozen_panics() {
            make_transaction().contract_memo(CONTRACT_MEMO);
        }

        #[test]
        fn expiration_time() {
            let mut tx = ContractUpdateTransaction::new();
            tx.expiration_time(EXPIRATION_TIME);

            assert_eq!(tx.get_expiration_time(), Some(EXPIRATION_TIME));
        }

        #[test]
        #[should_panic]
        fn expiration_time_frozen_panics() {
            make_transaction().expiration_time(EXPIRATION_TIME);
        }

        #[test]
        fn proxy_account_id() {
            let mut tx = ContractUpdateTransaction::new();
            tx.proxy_account_id(PROXY_ACCOUNT_ID);

            assert_eq!(tx.get_proxy_account_id(), Some(PROXY_ACCOUNT_ID));
        }

        #[test]
        #[should_panic]
        fn proxy_account_id_frozen_panics() {
            make_transaction().proxy_account_id(PROXY_ACCOUNT_ID);
        }

        #[test]
        fn auto_renew_account_id() {
            let mut tx = ContractUpdateTransaction::new();
            tx.auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID);

            assert_eq!(tx.get_auto_renew_account_id(), Some(AUTO_RENEW_ACCOUNT_ID));
        }

        #[test]
        #[should_panic]
        fn auto_renew_account_id_frozen_panics() {
            make_transaction().auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID);
        }

        #[test]
        fn staked_account_id() {
            let mut tx = ContractUpdateTransaction::new();
            tx.staked_account_id(STAKED_ACCOUNT_ID);

            assert_eq!(tx.get_staked_account_id(), Some(STAKED_ACCOUNT_ID));
        }

        #[test]
        #[should_panic]
        fn staked_account_id_frozen_panics() {
            make_transaction().staked_account_id(STAKED_ACCOUNT_ID);
        }

        #[test]
        fn staked_node_id() {
            let mut tx = ContractUpdateTransaction::new();
            tx.staked_node_id(STAKED_NODE_ID);

            assert_eq!(tx.get_staked_node_id(), Some(STAKED_NODE_ID));
        }

        #[test]
        #[should_panic]
        fn staked_node_id_frozen_panics() {
            make_transaction().staked_node_id(STAKED_NODE_ID);
        }
    }
}
// Filename: src/contract/delegate_contract_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt;
use std::str::FromStr;

use hedera_proto::services;

use crate::entity_id::{
    Checksum,
    PartialEntityId,
};
use crate::ethereum::SolidityAddress;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::{
    EntityId,
    Error,
};

/// A unique identifier for a smart contract on Hiero.
#[derive(Hash, PartialEq, Eq, Clone, Copy)]
pub struct DelegateContractId {
    /// A non-negative number identifying the shard containing this contract instance.
    pub shard: u64,

    /// A non-negative number identifying the realm within the shard containing this contract instance.
    pub realm: u64,

    /// A non-negative number identifying the entity within the realm containing this contract instance.
    ///
    /// Note: Exactly one of `evm_address` and `num` must exist.
    pub num: u64,

    /// A checksum if the contract ID was read from a user inputted string which inclueded a checksum
    pub checksum: Option<Checksum>,

    /// EVM address identifying the entity within the realm containing this contract instance.
    ///
    /// Note: Exactly one of `evm_address` and `num` must exist.
    pub evm_address: Option<[u8; 20]>,
}

impl DelegateContractId {
    /// Create a `DelegateContractId` from the given shard/realm/num
    #[must_use]
    pub fn new(shard: u64, realm: u64, num: u64) -> Self {
        Self { shard, realm, num, evm_address: None, checksum: None }
    }

    /// Create a `DelegateContractId` from a solidity address.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `address` cannot be parsed as a solidity address.
    pub fn from_solidity_address(address: &str) -> crate::Result<Self> {
        let EntityId { shard, realm, num, checksum } = EntityId::from_solidity_address(address)?;

        Ok(Self { shard, realm, num, evm_address: None, checksum })
    }
}

impl fmt::Debug for DelegateContractId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl fmt::Display for DelegateContractId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(address) = &self.evm_address {
            write!(f, "{}.{}.{}", self.shard, self.realm, SolidityAddress::from_ref(address))
        } else {
            write!(f, "{}.{}.{}", self.shard, self.realm, self.num)
        }
    }
}

impl FromStr for DelegateContractId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // override the error message for better context.
        let partial = PartialEntityId::from_str(s).map_err(|_| {
            Error::basic_parse(format!(
                "expecting <shard>.<realm>.<num> or <shard>.<realm>.<evm_address>, got `{s}`"
            ))
        })?;

        match partial {
            PartialEntityId::ShortNum(it) => Ok(Self::from(it)),
            PartialEntityId::LongNum(it) => Ok(Self::from(it)),
            PartialEntityId::ShortOther(_) => Err(Error::basic_parse(format!(
                "expecting <shard>.<realm>.<num> or <shard>.<realm>.<evm_address>, got `{s}`"
            ))),
            PartialEntityId::LongOther { shard, realm, last } => {
                let evm_address = Some(SolidityAddress::from_str(last)?.to_bytes());

                Ok(Self { shard, realm, num: 0, evm_address, checksum: None })
            }
        }
    }
}

impl From<[u8; 20]> for DelegateContractId {
    fn from(address: [u8; 20]) -> Self {
        Self { shard: 0, realm: 0, num: 0, evm_address: Some(address), checksum: None }
    }
}

impl From<u64> for DelegateContractId {
    fn from(num: u64) -> Self {
        Self::new(0, 0, num)
    }
}

impl From<EntityId> for DelegateContractId {
    fn from(value: EntityId) -> Self {
        let EntityId { shard, realm, num, checksum } = value;

        Self { shard, realm, num, evm_address: None, checksum }
    }
}

impl FromProtobuf<services::ContractId> for DelegateContractId {
    fn from_protobuf(pb: services::ContractId) -> crate::Result<Self> {
        let contract = pb_getf!(pb, contract)?;

        let (num, evm_address) = match contract {
            services::contract_id::Contract::ContractNum(it) => (it as u64, None),
            services::contract_id::Contract::EvmAddress(it) => {
                (0, Some(SolidityAddress::try_from(it)?.to_bytes()))
            }
        };

        Ok(Self {
            evm_address,
            num,
            shard: pb.shard_num as u64,
            realm: pb.realm_num as u64,
            checksum: None,
        })
    }
}

impl ToProtobuf for DelegateContractId {
    type Protobuf = services::ContractId;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ContractId {
            contract: Some(match &self.evm_address {
                Some(address) => services::contract_id::Contract::EvmAddress(address.to_vec()),
                None => services::contract_id::Contract::ContractNum(self.num as i64),
            }),
            realm_num: self.realm as i64,
            shard_num: self.shard as i64,
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use expect_test::expect;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::DelegateContractId;

    #[test]
    fn from_string() {
        expect!["0.0.5005"]
            .assert_eq(&DelegateContractId::from_str("0.0.5005").unwrap().to_string());
    }

    #[test]
    fn from_solidity_address() {
        expect!["0.0.5005"].assert_eq(
            &DelegateContractId::from_solidity_address("000000000000000000000000000000000000138D")
                .unwrap()
                .to_string(),
        );
    }

    #[test]
    fn from_solidity_address_with_0x() {
        expect!["0.0.5005"].assert_eq(
            &DelegateContractId::from_solidity_address(
                "0x000000000000000000000000000000000000138D",
            )
            .unwrap()
            .to_string(),
        );
    }

    #[test]
    fn from_bytes() {
        expect!["0.0.5005"].assert_eq(
            &DelegateContractId::from_bytes(&DelegateContractId::new(0, 0, 5005).to_bytes())
                .unwrap()
                .to_string(),
        );
    }
}
// Filename: src/contract/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod contract_bytecode_query;
mod contract_call_query;
mod contract_create_flow;
mod contract_create_transaction;
mod contract_delete_transaction;
mod contract_execute_transaction;
mod contract_function_parameters;
mod contract_function_result;
mod contract_function_selector;
mod contract_id;
mod contract_info;
mod contract_info_query;
mod contract_log_info;
mod contract_nonce_info;
mod contract_update_transaction;
mod delegate_contract_id;

pub use contract_bytecode_query::ContractBytecodeQuery;
pub(crate) use contract_bytecode_query::ContractBytecodeQueryData;
pub use contract_call_query::ContractCallQuery;
pub(crate) use contract_call_query::ContractCallQueryData;
pub use contract_create_flow::ContractCreateFlow;
pub use contract_create_transaction::ContractCreateTransaction;
pub(crate) use contract_create_transaction::ContractCreateTransactionData;
pub use contract_delete_transaction::ContractDeleteTransaction;
pub(crate) use contract_delete_transaction::ContractDeleteTransactionData;
pub use contract_execute_transaction::ContractExecuteTransaction;
pub(crate) use contract_execute_transaction::ContractExecuteTransactionData;
pub use contract_function_parameters::ContractFunctionParameters;
pub use contract_function_result::ContractFunctionResult;
pub use contract_id::ContractId;
pub use contract_info::ContractInfo;
pub use contract_info_query::ContractInfoQuery;
pub(crate) use contract_info_query::ContractInfoQueryData;
pub use contract_log_info::ContractLogInfo;
pub use contract_nonce_info::ContractNonceInfo;
pub use contract_update_transaction::ContractUpdateTransaction;
pub(crate) use contract_update_transaction::ContractUpdateTransactionData;
pub use delegate_contract_id::DelegateContractId;
// Filename: src/custom_fee_limit.rs
use hedera_proto::services::{
    self,
};

use crate::custom_fixed_fee::CustomFixedFee;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::AccountId;

/// A custom transfer fee that was assessed during the handling of a `CryptoTransfer`.
#[derive(Debug, Eq, PartialEq, Clone)]
pub struct CustomFeeLimit {
    /// The account of the fee payer
    pub account_id: Option<AccountId>,

    /// The maximum fees that the user is willing to pay for the message.
    pub fees: Vec<CustomFixedFee>,
}

impl CustomFeeLimit {
    pub fn new(account_id: Option<AccountId>, fees: Vec<CustomFixedFee>) -> Self {
        Self { account_id, fees }
    }
}

impl FromProtobuf<services::CustomFeeLimit> for CustomFeeLimit {
    fn from_protobuf(pb: services::CustomFeeLimit) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let mut fees = Vec::new();
        for fee in pb.fees {
            fees.push(CustomFixedFee {
                amount: fee.amount as u64,
                denominating_token_id: Option::from_protobuf(fee.denominating_token_id)?,
                fee_collector_account_id: None,
            });
        }

        Ok(Self { account_id: Option::from_protobuf(pb.account_id)?, fees })
    }
}

impl ToProtobuf for CustomFeeLimit {
    type Protobuf = services::CustomFeeLimit;

    fn to_protobuf(&self) -> Self::Protobuf {
        let fees: Vec<services::FixedFee> =
            self.fees.iter().map(|fee| fee.to_fixed_fee_protobuf()).collect();

        services::CustomFeeLimit { account_id: self.account_id.to_protobuf(), fees }
    }
}
// Filename: src/custom_fixed_fee.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use crate::{
    AccountId,
    FixedFee,
    FixedFeeData,
    FromProtobuf,
    ToProtobuf,
    TokenId,
};

/// A custom fee definition for a consensus topic.
///
/// This fee definition is specific to an Hiero Consensus Service (HCS) topic
/// and SHOULD NOT be used in any other context.
///
/// All fields for this message are REQUIRED.
///
/// Only "fixed" fee definitions are supported because there is no basis for
/// a fractional fee on a consensus submit transaction.
#[derive(Debug, Hash, PartialEq, Eq, Clone, Default)]
pub struct CustomFixedFee {
    /// The amount of HBAR or other token described by this `FixedFee` SHALL
    /// be charged to the transction payer for each message submitted to a
    /// topic that assigns this consensus custom fee.
    pub amount: u64,

    /// The denomination of the fee; taken as hbar if left unset and, in a TokenCreate, taken as the id
    /// of the newly created token if set to the sentinel value of 0.0.0
    pub denominating_token_id: Option<TokenId>,

    /// The account to receive the custom fee.
    pub fee_collector_account_id: Option<AccountId>,
}

impl CustomFixedFee {
    /// Creates a new `CustomFixedFee`
    pub fn new(
        amount: u64,
        denominating_token_id: Option<TokenId>,
        fee_collector_account_id: Option<AccountId>,
    ) -> Self {
        Self { amount, denominating_token_id, fee_collector_account_id }
    }
}

impl CustomFixedFee {
    pub(crate) fn to_fixed_fee_protobuf(&self) -> services::FixedFee {
        services::FixedFee {
            amount: self.amount as i64,
            denominating_token_id: self.denominating_token_id.to_protobuf(),
        }
    }
}

impl From<CustomFixedFee> for FixedFee {
    fn from(v: CustomFixedFee) -> Self {
        Self {
            fee: FixedFeeData {
                amount: v.amount as i64,
                denominating_token_id: v.denominating_token_id,
            },
            fee_collector_account_id: v.fee_collector_account_id,
            all_collectors_are_exempt: false,
        }
    }
}

impl ToProtobuf for CustomFixedFee {
    type Protobuf = services::FixedCustomFee;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            fixed_fee: Some(services::FixedFee {
                amount: self.amount as i64,
                denominating_token_id: self.denominating_token_id.to_protobuf(),
            }),
            fee_collector_account_id: self.fee_collector_account_id.to_protobuf(),
        }
    }
}

impl FromProtobuf<services::FixedCustomFee> for CustomFixedFee {
    fn from_protobuf(pb: services::FixedCustomFee) -> crate::Result<Self> {
        let fee = FixedFeeData::from_protobuf(pb.fixed_fee.unwrap())?;

        Ok(Self {
            amount: fee.amount as u64,
            denominating_token_id: fee.denominating_token_id,
            fee_collector_account_id: Option::from_protobuf(pb.fee_collector_account_id)?,
        })
    }
}

impl FromProtobuf<services::FixedFee> for CustomFixedFee {
    fn from_protobuf(pb: services::FixedFee) -> crate::Result<Self> {
        let fee = FixedFeeData::from_protobuf(pb)?;

        Ok(Self {
            amount: fee.amount as u64,
            denominating_token_id: fee.denominating_token_id,
            fee_collector_account_id: None,
        })
    }
}
// Filename: src/downcast.rs
// SPDX-License-Identifier: Apache-2.0

// not happy about needing this.
/// Downcast from one type to another.
pub trait DowncastOwned<T>: Sized {
    fn downcast_owned(self) -> Result<T, Self>;
}
// Filename: src/entity_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use tinystr::TinyAsciiStr;

use crate::ethereum::SolidityAddress;
use crate::ledger_id::RefLedgerId;
use crate::{
    Client,
    Error,
};

#[derive(Hash, PartialEq, Eq, Clone, Copy)]
pub struct Checksum(TinyAsciiStr<5>);

impl Checksum {
    fn from_bytes(bytes: [u8; 5]) -> Checksum {
        Checksum(TinyAsciiStr::from_bytes(&bytes).unwrap())
    }
}

impl FromStr for Checksum {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let ascii_str: TinyAsciiStr<5> = s
            .parse()
            .map_err(|e| Error::basic_parse(format!("Expected checksum to be valid ascii: {e}")))?;

        if ascii_str.len() != 5 || !ascii_str.is_ascii_alphabetic_lowercase() {
            return Err(Error::basic_parse("Expected checksum to be exactly 5 lowercase letters"));
        }

        Ok(Self(ascii_str))
    }
}

impl Display for Checksum {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_str(self.0.as_str())
    }
}

impl Debug for Checksum {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{}\"", self.0.as_str())
    }
}

pub trait ValidateChecksums {
    /// Validates all entity-id checksums for `self` with the given ledger-id.
    ///
    /// # Errors
    /// - [`Error::BadEntityId`] if any of the expected checksums don't match the actual checksums.
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> crate::Result<()>;
}

impl<T: ValidateChecksums> ValidateChecksums for Option<T> {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> crate::Result<()> {
        if let Some(id) = &self {
            id.validate_checksums(ledger_id)?;
        }
        Ok(())
    }
}

/// The ID of an entity on the Hiero network.
#[derive(Hash, PartialEq, Eq, Clone, Copy)]
pub struct EntityId {
    /// A non-negative number identifying the shard containing this entity.
    pub shard: u64,

    /// A non-negative number identifying the realm within the shard containing this entity.
    pub realm: u64,

    /// A non-negative number identifying the entity within the realm containing this entity.
    pub num: u64,

    /// A checksum if the entity ID was read from a user inputted string which inclueded a checksum
    pub checksum: Option<Checksum>,
}

#[derive(Copy, Clone)]
pub(crate) enum PartialEntityId<'a> {
    ShortNum(u64),
    LongNum(EntityId),
    ShortOther(&'a str),
    LongOther { shard: u64, realm: u64, last: &'a str },
}

impl<'a> PartialEntityId<'a> {
    pub(crate) fn finish<T>(self) -> crate::Result<T>
    where
        EntityId: Into<T>,
    {
        match self {
            Self::ShortNum(num) => Ok(EntityId::from(num).into()),
            Self::LongNum(id) => Ok(id.into()),
            _ => Err(Error::basic_parse("expected `<shard>.<realm>.<num>`".to_owned())),
        }
    }

    // `FromStr` doesn't allow lifetime bounds.
    pub(crate) fn from_str(s: &'a str) -> crate::Result<Self> {
        let expecting =
            || Error::basic_parse(format!("expected `<shard>.<realm>.<num>`, got `{s}`"));

        // entity ID parsing is painful because there are 4 formats...
        // This way avoids allocations at the code of an extra layer of nesting.
        match s.split_once('.') {
            Some((shard, rest)) => {
                let (realm, last) = rest.split_once('.').ok_or_else(expecting)?;

                if last.is_empty() {
                    return Err(expecting());
                }

                let shard = shard.parse().map_err(|_| expecting())?;
                let realm = realm.parse().map_err(|_| expecting())?;

                match last.rsplit_once('-') {
                    Some((num, checksum)) => {
                        let num = num.parse().map_err(|_| expecting())?;
                        let checksum = Some(checksum.parse()?);

                        Ok(Self::LongNum(EntityId { shard, realm, num, checksum }))
                    }

                    None => match last.parse() {
                        Ok(num) => {
                            Ok(Self::LongNum(EntityId { shard, realm, num, checksum: None }))
                        }

                        Err(_) => Ok(Self::LongOther { shard, realm, last }),
                    },
                }
            }
            None => match s.parse() {
                Ok(it) => return Ok(Self::ShortNum(it)),
                Err(_) => return Ok(Self::ShortOther(s)),
            },
        }
    }
}

impl EntityId {
    /// Parse an entity ID from a solidity address
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `address` cannot be parsed as a solidity address.
    pub(crate) fn from_solidity_address(address: &str) -> crate::Result<Self> {
        SolidityAddress::from_str(address).map(Self::from)
    }

    /// Convert `self` into a solidity `address`.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `self.shard` is larger than `u32::MAX`.
    pub(crate) fn to_solidity_address(self) -> crate::Result<String> {
        SolidityAddress::try_from(self).map(|it| it.to_string())
    }

    pub(crate) fn generate_checksum(entity_id_string: &str, ledger_id: &RefLedgerId) -> Checksum {
        const P3: usize = 26 * 26 * 26; // 3 digits in base 26
        const P5: usize = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26
        const M: usize = 1_000_003; // min prime greater than a million. Used for the final permutation.
        const W: usize = 31; // Sum s of digit values weights them by powers of W. Should be coprime to P5.

        let h = [ledger_id.as_bytes().to_vec(), vec![0u8; 6]].concat();

        // Digits with 10 for ".", so if addr == "0.0.123" then d == [0, 10, 0, 10, 1, 2, 3]
        let d = entity_id_string.chars().map(|c| {
            if c == '.' {
                10_usize
            } else {
                c.to_digit(10).unwrap() as usize
            }
        });

        let mut s = 0; // Weighted sum of all positions (mod P3)
        let mut s0 = 0; // Sum of even positions (mod 11)
        let mut s1 = 0; // Sum of odd positions (mod 11)
        for (i, digit) in d.enumerate() {
            s = (W * s + digit) % P3;
            if i % 2 == 0 {
                s0 = (s0 + digit) % 11;
            } else {
                s1 = (s1 + digit) % 11;
            }
        }

        let mut sh = 0; // Hash of the ledger ID
        for b in h {
            sh = (W * sh + (b as usize)) % P5;
        }

        // The checksum, as a single number
        let mut c = ((((entity_id_string.len() % 5) * 11 + s0) * 11 + s1) * P3 + s + sh) % P5;
        c = (c * M) % P5;

        let mut answer = [0_u8; 5];
        for i in (0..5).rev() {
            answer[i] = b'a' + ((c % 26) as u8);
            c /= 26;
        }

        Checksum::from_bytes(answer)
    }

    /// Validates that the the checksum computed for the given `shard.realm.num` matches the given checksum.
    ///
    /// # Errors
    /// - [`Error::CannotPerformTaskWithoutLedgerId`] if the client has no `ledger_id`.
    /// - [`Error::BadEntityId`] if there is a checksum, and the checksum is not valid for the client's `ledger_id`.
    pub(crate) fn validate_checksum(
        shard: u64,
        realm: u64,
        num: u64,
        checksum: Option<Checksum>,
        client: &Client,
    ) -> crate::Result<()> {
        let Some(present_checksum) = checksum else {
            return Ok(());
        };

        let ledger_id = client.ledger_id_internal();
        let ledger_id = ledger_id
            .as_deref()
            .expect("Client had no ledger ID (help: call `client.set_ledger_id()`");

        Self::validate_checksum_internal(
            shard,
            realm,
            num,
            present_checksum,
            ledger_id.as_ref_ledger_id(),
        )
    }

    pub(crate) fn validate_checksum_for_ledger_id(
        shard: u64,
        realm: u64,
        num: u64,
        checksum: Option<Checksum>,
        ledger_id: &RefLedgerId,
    ) -> Result<(), Error> {
        if let Some(present_checksum) = checksum {
            Self::validate_checksum_internal(shard, realm, num, present_checksum, ledger_id)
        } else {
            Ok(())
        }
    }

    fn validate_checksum_internal(
        shard: u64,
        realm: u64,
        num: u64,
        present_checksum: Checksum,
        ledger_id: &RefLedgerId,
    ) -> Result<(), Error> {
        let expected_checksum =
            Self::generate_checksum(&format!("{shard}.{realm}.{num}"), ledger_id);
        if present_checksum == expected_checksum {
            Ok(())
        } else {
            Err(Error::BadEntityId { shard, realm, num, present_checksum, expected_checksum })
        }
    }

    pub(crate) fn to_string_with_checksum(mut entity_id_string: String, client: &Client) -> String {
        let ledger_id = client.ledger_id_internal();
        let ledger_id = ledger_id
            .as_ref()
            .expect("Client had no ledger ID (help: call `client.set_ledger_id()`");

        let checksum = Self::generate_checksum(&entity_id_string, ledger_id.as_ref_ledger_id());
        entity_id_string.push('-');
        entity_id_string.push_str(&checksum.0);

        entity_id_string
    }
}

impl Debug for EntityId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for EntityId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}.{}.{}", self.shard, self.realm, self.num)
    }
}

impl From<u64> for EntityId {
    fn from(num: u64) -> Self {
        Self { num, shard: 0, realm: 0, checksum: None }
    }
}

impl FromStr for EntityId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        PartialEntityId::from_str(s)?.finish()
    }
}

#[cfg(test)]
mod tests {
    use crate::ledger_id::RefLedgerId;
    use crate::{
        EntityId,
        TopicId,
    };

    #[test]
    fn from_solidity_address() {
        assert_eq!(
            EntityId::from_solidity_address("000000000000000000000000000000000000138D").unwrap(),
            EntityId { shard: 0, realm: 0, num: 5005, checksum: None }
        );
    }

    #[test]
    fn from_solidity_address_with_0x() {
        assert_eq!(
            EntityId::from_solidity_address("0x000000000000000000000000000000000000138D").unwrap(),
            EntityId { shard: 0, realm: 0, num: 5005, checksum: None }
        );
    }

    #[test]
    fn to_solidity_address() {
        assert!(EntityId { shard: 0, realm: 0, num: 5005, checksum: None }
            .to_solidity_address()
            .unwrap()
            .eq_ignore_ascii_case("000000000000000000000000000000000000138D"));
    }

    #[test]
    fn generate_checksum_mainnet() {
        const EXPECTED: [&str; 256] = [
            "uvnqa", "dfkxr", "lpifi", "tzfmz", "cjcuq", "ktach", "tcxjy", "bmurp", "jwrzg",
            "sgpgx", "hiafh", "rdxmy", "uuuup", "eqscg", "ompjx", "yimro", "iejzf", "sahgw",
            "bweon", "lsbwe", "diuio", "nerqf", "qvoxw", "armfn", "knjne", "ujguv", "efecm",
            "obbkd", "xwyru", "hsvzl", "zjolv", "jfltm", "mwjbd", "wsgiu", "godql", "qkayc",
            "afyft", "kbvnk", "txsvb", "dtqcs", "vkipc", "fgfwt", "ixdek", "stamb", "coxts",
            "mkvbj", "wgsja", "gcpqr", "pymyi", "zukfz", "rlcsj", "tqaaa", "xgxhr", "hcupi",
            "qyrwz", "aupeq", "kqmmh", "umjty", "eihbp", "oeejg", "fuwvq", "pqudh", "thrky",
            "ddosp", "mzmag", "wvjhx", "grgpo", "qndxf", "ajbew", "keymn", "bvqyx", "lrogo",
            "pilof", "zeivw", "jagdn", "swdle", "csasv", "mnyam", "wjvid", "gfspu", "xwlce",
            "hsijv", "ljfrm", "vfczd", "fbagu", "owxol", "ysuwc", "iosdt", "skplk", "cgmtb",
            "txffl", "dtcnc", "hjzut", "rfxck", "bbukb", "kxrrs", "utozj", "epmha", "oljor",
            "yhgwi", "hhghj", "prdpa", "ybawr", "gkyei", "ouvlz", "xestq", "foqbh", "nyniy",
            "wikqp", "eshyg", "euakq", "ndxsh", "vnuzy", "dxshp", "mhppg", "urmwx", "dbkeo",
            "llhmf", "tvetw", "cfcbn", "wbunx", "elrvo", "mvpdf", "vfmkw", "dpjsn", "lzhae",
            "ujehv", "ctbpm", "lcyxd", "tmweu", "toore", "bylyv", "kijgm", "ssgod", "bcdvu",
            "jmbdl", "rvylc", "afvst", "iptak", "qzqib", "rbiul", "zlgcc", "hvdjt", "qfark",
            "yoxzb", "gyvgs", "pisoj", "xspwa", "gcndr", "omkli", "oocxs", "wyafj", "fhxna",
            "nruur", "wbsci", "elpjz", "mvmrq", "vfjzh", "dphgy", "lzeop", "maxaz", "ukuiq",
            "curqh", "leoxy", "tomfp", "byjng", "kigux", "sseco", "bcbkf", "jlyrw", "jnreg",
            "rxolx", "ahlto", "irjbf", "rbgiw", "zldqn", "hvaye", "qeyfv", "yovnm", "gysvd",
            "halhn", "pkipe", "xufwv", "gedem", "ooamd", "wxxtu", "fhvbl", "nrsjc", "wbpqt",
            "elmyk", "enfku", "mxcsl", "vhaac", "dqxht", "maupk", "ukrxb", "cupes", "lemmj",
            "tojua", "byhbr", "klges", "svdmj", "bfaua", "joybr", "ryvji", "aisqz", "ispyq",
            "rcngh", "zmkny", "rthvp", "hyahz", "qhxpq", "yruxh", "hbsey", "plpmp", "xvmug",
            "gfkbx", "ophjo", "wzerf", "pgbyw", "zfulg", "hprsx", "pzpao", "yjmif", "gtjpw",
            "pdgxn", "xnefe", "fxbmv", "ogyum", "gnwcd", "wsoon", "fclwe", "nmjdv", "vwglm",
            "egdtd", "mqbau", "uzyil", "djvqc", "ltsxt", "eaqfk", "ufiru", "cpfzl", "kzdhc",
            "tjaot", "bsxwk", "kcveb", "smsls", "awptj", "jgnba", "bnkir", "rscvb", "acacs",
            "ilxkj", "qvusa", "zfrzr", "hpphi",
        ];

        for (index, expected) in EXPECTED.iter().enumerate() {
            let actual = EntityId::generate_checksum(
                &TopicId::from(index as u64).to_string(),
                &RefLedgerId::MAINNET,
            )
            .to_string();

            assert_eq!(expected, &actual);
        }
    }

    #[test]
    fn generate_checksum_testnet() {
        const EXPECTED: [&str; 256] = [
            "eiyxj", "mswfa", "vctmr", "dmqui", "lwobz", "ugljq", "cqirh", "lafyy", "tkdgp",
            "buaog", "qvlmq", "ariuh", "eigby", "oedjp", "yaarg", "hvxyx", "rrvgo", "bnsof",
            "ljpvw", "vfndn", "mwfpx", "wscxo", "ajaff", "kexmw", "uauun", "dwsce", "nspjv",
            "xomrm", "hkjzd", "rghgu", "iwzte", "ssxav", "wjuim", "gfrqd", "qboxu", "zxmfl",
            "jtjnc", "tpgut", "dleck", "nhbkb", "extwl", "otrec", "skolt", "cgltk", "mcjbb",
            "vygis", "fudqj", "pqaya", "zlyfr", "jhvni", "aynzs", "ddlhj", "guipa", "qqfwr",
            "amdei", "kialz", "udxtq", "dzvbh", "nvsiy", "xrpqp", "piicz", "zefkq", "cvcsh",
            "mqzzy", "wmxhp", "giupg", "qerwx", "aapeo", "jwmmf", "tsjtw", "ljcgg", "veznx",
            "yvwvo", "irudf", "snrkw", "cjosn", "mfmae", "wbjhv", "fxgpm", "ptdxd", "hjwjn",
            "rftre", "uwqyv", "esogm", "oolod", "ykivu", "iggdl", "scdlc", "byast", "ltyak",
            "dkqmu", "ngnul", "qxlcc", "atijt", "kpfrk", "ulczb", "ehags", "ocxoj", "xyuwa",
            "husdr", "quros", "zeowj", "homea", "pyjlr", "yigti", "gseaz", "pcbiq", "xlyqh",
            "fvvxy", "oftfp", "ohlrz", "wrizq", "fbghh", "nldoy", "vvawp", "eeyeg", "movlx",
            "uysto", "diqbf", "lsniw", "fpfvg", "nzdcx", "wjako", "esxsf", "ncuzw", "vmshn",
            "dwppe", "mgmwv", "uqkem", "dahmd", "dbzyn", "llxge", "tvunv", "cfrvm", "kppdd",
            "szmku", "bjjsl", "jthac", "sdeht", "anbpk", "aoubu", "iyrjl", "riorc", "zslyt",
            "icjgk", "qmgob", "ywdvs", "hgbdj", "ppyla", "xzvsr", "ybofb", "gllms", "oviuj",
            "xfgca", "fpdjr", "nzari", "wixyz", "esvgq", "ncsoh", "vmpvy", "voiii", "dyfpz",
            "micxq", "usafh", "dbxmy", "lluup", "tvscg", "cfpjx", "kpmro", "szjzf", "tbclp",
            "bkztg", "juxax", "seuio", "aorqf", "iyoxw", "rimfn", "zsjne", "icguv", "qmecm",
            "qnwow", "yxtwn", "hhree", "prolv", "ybltm", "gljbd", "ovgiu", "xfdql", "fpayc",
            "nyyft", "oaqsd", "wknzu", "eulhl", "neipc", "vofwt", "dydek", "miamb", "urxts",
            "dbvbj", "llsja", "tyrmb", "ciots", "ksmbj", "tcjja", "bmgqr", "jwdyi", "sgbfz",
            "apynq", "izvvh", "bgtcy", "rllpi", "zviwz", "ifgeq", "qpdmh", "yzaty", "hiybp",
            "psvjg", "ycsqx", "gmpyo", "ytngf", "itfsp", "rddag", "znahx", "hwxpo", "qguxf",
            "yqsew", "hapmn", "pkmue", "xukbv", "qbhjm", "gfzvw", "opxdn", "wzule", "fjrsv",
            "ntpam", "wdmid", "enjpu", "mxgxl", "vhefc", "nobmt", "dstzd", "mcrgu", "umool",
            "cwlwc", "lgjdt", "tqglk", "cadtb", "kkbas", "styij", "lavqa", "bfock", "jplkb",
            "rzirs", "ajfzj", "itdha", "rdaor",
        ];

        for (index, expected) in EXPECTED.iter().enumerate() {
            let actual = EntityId::generate_checksum(
                &TopicId::from(index as u64).to_string(),
                RefLedgerId::TESTNET,
            )
            .to_string();

            assert_eq!(expected, &actual);
        }
    }
}
// Filename: src/error.rs
// SPDX-License-Identifier: Apache-2.0

use std::error::Error as StdError;
use std::result::Result as StdResult;

use crate::entity_id::Checksum;
use crate::{
    AccountId,
    Hbar,
    Status,
    TransactionId,
};

/// `Result<T, Error>`
pub type Result<T> = StdResult<T, Error>;

pub(crate) type BoxStdError = Box<dyn StdError + Send + Sync + 'static>;

/// Represents any possible error from a fallible function in the Hiero SDK.
#[derive(Debug, thiserror::Error)]
#[non_exhaustive]
pub enum Error {
    /// Request timed out.
    #[error("failed to complete request within the maximum time allowed; most recent attempt failed with: {0}")]
    TimedOut(#[source] Box<Error>),

    /// GRPC status code was an error.
    #[error("grpc: {0:?}")]
    GrpcStatus(#[from] tonic::Status),

    /// Failed to parse an SDK type from a protobuf response.
    #[error("failed to create a SDK type from a protobuf response: {0}")]
    FromProtobuf(#[source] BoxStdError),

    // todo: bikeshed this.
    /// Freeze failed due to there being no explicitly set node account IDs and no client being provided to generate them.
    #[error("freeze failed due to node account IDs being unset")]
    FreezeUnsetNodeAccountIds,

    /// A transaction failed pre-check.
    ///
    /// The transaction had the ID `transaction_id`.
    ///
    /// Caused by `status` being an error.
    #[error("transaction `{transaction_id}` failed pre-check with status `{status:?}`")]
    TransactionPreCheckStatus {
        /// The status that caused the [`Transaction`](crate::Transaction) to fail pre-check.
        status: Status,

        /// The `TransactionId` of the failed [`Transaction`](crate::Transaction) .
        transaction_id: Box<TransactionId>,

        /// The estimated transaction fee, if the status was [`InsufficientTxFee`].
        cost: Option<Hbar>,
    },

    /// A [`Query`](crate::Query) for `transaction_id` failed pre-check.
    ///
    /// Caused by `status` being an error.
    #[error("query for transaction `{transaction_id}` failed pre-check with status `{status:?}`")]
    QueryPreCheckStatus {
        /// The `Status` that caused the [`Query`](crate::Query) to fail pre-check.
        status: Status,
        /// The associated transaction's ID.
        transaction_id: Box<TransactionId>,
    },

    /// A [`Query`](crate::Query) failed pre-check.
    ///
    /// The query had an associated `PaymentTransaction` with ID `transaction_id`.
    ///
    /// Caused by `status` being an error.
    #[error(
    "query with payment transaction `{transaction_id}` failed pre-check with status `{status:?}`"
    )]
    QueryPaymentPreCheckStatus {
        /// The `Status` that caused the [`Query`](crate::Query) to fail pre-check.
        status: Status,
        /// The associated `PaymentTransaction`'s `TransactionId`.
        transaction_id: Box<TransactionId>,
    },

    /// A [`Query`](crate::Query) failed pre-check.
    ///
    /// The query had no `PaymentTransaction`.
    ///
    /// Caused by `status` being an error.
    #[error("query with no payment transaction failed pre-check with status `{status:?}`")]
    QueryNoPaymentPreCheckStatus {
        /// The `Status` that caused the [`Query`](crate::Query) to fail pre-check.
        status: Status,
    },

    /// Failed to parse a basic type from string
    /// (ex. [`AccountId`](crate::AccountId), [`ContractId`](crate::ContractId), [`TransactionId`](crate::TransactionId), etc.).
    #[error("failed to parse: {0}")]
    BasicParse(#[source] BoxStdError),

    /// An entity ID had an invalid checksum
    #[error("entity ID {shard}.{realm}.{num}-{present_checksum} was incorrect")]
    BadEntityId {
        /// The shard number
        shard: u64,
        /// The realm number
        realm: u64,
        /// The entity number
        num: u64,
        /// The (invalid) checksum that was present on the entity ID
        present_checksum: Checksum,
        /// The checksum that SHOULD HAVE BEEN on the entity ID
        expected_checksum: Checksum,
    },

    /// An entity ID cannot be converted to a string with a checksum, because it is in an alternate form,
    /// such as an `alias` or `evm_address`
    #[error("an entity ID with an `alias` or `evm_address` cannot have a checksum")]
    CannotCreateChecksum,

    /// Failed to parse a [`PublicKey`](crate::PublicKey) or [`PrivateKey`](crate::PrivateKey).
    #[error("failed to parse a key: {0}")]
    KeyParse(#[source] BoxStdError),

    /// Failed to derive a [`PrivateKey`](crate::PrivateKey) from another `PrivateKey`.
    ///
    /// Examples of when this can happen (non-exhaustive):
    /// - [`PrivateKey::derive`](fn@crate::PrivateKey::derive) when the `PrivateKey` doesn't have a chain code.
    /// - [`PrivateKey::derive`](fn@crate::PrivateKey::derive)
    ///   or [`PrivateKey::legacy_derive`](fn@crate::PrivateKey::legacy_derive) on an `Ecsda` key.
    #[error("Failed to derive a key: {0}")]
    KeyDerive(#[source] BoxStdError),

    /// Failed to parse a [`Mnemonic`](crate::Mnemonic) due to the given `reason`.
    ///
    /// the `Mnemonic` is provided because invalid `Mnemonics`
    /// can technically still provide valid [`PrivateKeys`](crate::PrivateKey).
    #[cfg(feature = "mnemonic")]
    #[error("failed to parse a mnemonic: {reason}")]
    MnemonicParse {
        /// This error's source.
        #[source]
        reason: MnemonicParseError,
        /// The `Mnemonic` in question.
        mnemonic: crate::Mnemonic,
    },

    /// An error occurred while attempting to convert a [`Mnemonic`](crate::Mnemonic) to a [`PrivateKey`](crate::PrivateKey)
    #[cfg(feature = "mnemonic")]
    #[error("failed to convert a mnemonic to entropy: {0}")]
    MnemonicEntropy(#[from] MnemonicEntropyError),

    /// The [`Client`](crate::Client) had no payer account (operator)
    /// and the attempted request had no explicit [`TransactionId`].
    #[error("client must be configured with a payer account or requests must be given an explicit transaction id")]
    NoPayerAccountOrTransactionId,

    /// Cost of a [`Query`](crate::Query) is more expensive than `max_query_payment`.
    ///
    /// The actual cost of the `Query` is `query_cost`.
    #[error("cost of {query_cost} without explicit payment is greater than the maximum allowed payment of {max_query_payment}")]
    MaxQueryPaymentExceeded {
        /// the configured maximum query payment.
        max_query_payment: Hbar,

        /// How much the query actually cost.
        query_cost: Hbar,
    },

    /// The associated node account was not found in the network.
    #[error("node account `{0}` was not found in the configured network")]
    NodeAccountUnknown(Box<AccountId>),

    /// Received an unrecognized status code from the Hiero Network.
    ///
    /// This can happen when the SDK is outdated, try updating your SDK.
    #[error("received unrecognized status code: {0}, try updating your SDK")]
    ResponseStatusUnrecognized(i32),

    // fixme(sr): Citation needed (unsure if this is accurate).
    /// Getting the receipt for `transaction_id` failed with `status`.
    #[error("receipt for transaction `{transaction_id:?}` failed with status `{status:?}`")]
    ReceiptStatus {
        /// The Error's status code.
        status: Status,
        /// The [`Transaction`](crate::Transaction)'s ID.
        transaction_id: Option<Box<TransactionId>>,
    },

    /// Failed to verify a signature.
    #[error("failed to verify a signature: {0}")]
    SignatureVerify(#[source] BoxStdError),
}

impl Error {
    pub(crate) fn from_protobuf<E: Into<BoxStdError>>(error: E) -> Self {
        Self::FromProtobuf(error.into())
    }

    pub(crate) fn key_parse<E: Into<BoxStdError>>(error: E) -> Self {
        Self::KeyParse(error.into())
    }

    pub(crate) fn key_derive<E: Into<BoxStdError>>(error: E) -> Self {
        Self::KeyDerive(error.into())
    }

    pub(crate) fn basic_parse<E: Into<BoxStdError>>(error: E) -> Self {
        Self::BasicParse(error.into())
    }

    pub(crate) fn signature_verify(error: impl Into<BoxStdError>) -> Self {
        Self::SignatureVerify(error.into())
    }
}

/// Failed to parse a mnemonic.
#[cfg(feature = "mnemonic")]
#[derive(Debug, thiserror::Error)]
#[non_exhaustive]
pub enum MnemonicParseError {
    /// The [`Mnemonic`](crate::Mnemonic) contains an unexpected length.
    #[error("bad length: expected `12` or `24` words, found `{0}`")]
    BadLength(usize),

    /// The [`Mnemonic`](crate::Mnemonic) contains words that aren't in the wordlist.
    #[error("unknown words at indecies: `{0:?}`")]
    UnknownWords(Vec<usize>),

    /// The [`Mnemonic`](crate::Mnemonic) has an invalid checksum.
    #[error("checksum mismatch: expected `{expected:02x}`, found `{actual:02x}`")]
    ChecksumMismatch {
        /// The checksum that was expected.
        expected: u8,
        /// The checksum that was actually found.
        actual: u8,
    },
}

/// Failed to convert a [`Mnemonic`](crate::Mnemonic) to a [`PrivateKey`](crate::PrivateKey)
// todo: find a better name before release.
#[cfg(feature = "mnemonic")]
#[derive(Debug, thiserror::Error)]
#[non_exhaustive]
pub enum MnemonicEntropyError {
    /// Encountered a [`Mnemonic`](crate::Mnemonic) of unexpected length.
    #[error("bad length: expected `{expected}` words, found {actual} words")]
    BadLength {
        /// The number of words that were expected (12, 22, or 24)
        expected: usize,
        /// The number of words that were actually found.
        actual: usize,
    },

    /// The [`Mnemonic`](crate::Mnemonic) has an invalid checksum.
    #[error("checksum mismatch: expected `{expected:02x}`, found `{actual:02x}`")]
    ChecksumMismatch {
        /// The checksum that was expected.
        expected: u8,
        /// The checksum that was actually found.
        actual: u8,
    },

    /// Used a passphrase with a legacy [`Mnemonic`](crate::Mnemonic).
    #[error("used a passphrase with a legacy mnemonic")]
    LegacyWithPassphrase,
}
// Filename: src/ethereum/ethereum_data.rs
// SPDX-License-Identifier: Apache-2.0

use core::fmt;

use bytes::{
    BufMut,
    BytesMut,
};
use rlp::Rlp;

use crate::Error;

/// Data for an [`EthereumTransaction`](crate::EthereumTransaction).
#[derive(Debug, Clone)]
#[non_exhaustive]
pub enum EthereumData {
    /// Data for a legacy ethereum transaction.
    Legacy(LegacyEthereumData),

    /// Data for an Eip 1559 ethereum transaction.
    Eip1559(Eip1559EthereumData),
}

impl EthereumData {
    pub(super) fn call_data_mut(&mut self) -> &mut Vec<u8> {
        match self {
            EthereumData::Legacy(it) => &mut it.call_data,
            EthereumData::Eip1559(it) => &mut it.call_data,
        }
    }

    pub(crate) fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        match bytes.split_first() {
            // note: eating the 2 here involves a bit of extra work.
            Some((2, bytes)) => Eip1559EthereumData::decode_rlp(&Rlp::new(bytes))
                .map(Self::Eip1559)
                .map_err(Error::basic_parse),

            Some(_) => Ok(Self::Legacy(LegacyEthereumData::from_bytes(bytes)?)),
            None => Err(Error::basic_parse("Empty ethereum transaction data")),
        }
    }

    /// convert this data to rlp encoded bytes.
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        match self {
            EthereumData::Legacy(it) => it.to_bytes(),
            EthereumData::Eip1559(it) => it.to_bytes(),
        }
    }
}

/// Data for a legacy ethereum transaction.
#[derive(Clone)]
#[non_exhaustive]
pub struct LegacyEthereumData {
    /// Transaction's nonce.
    pub nonce: Vec<u8>,

    /// Price for 1 gas.
    pub gas_price: Vec<u8>,

    /// The amount of gas available for the transaction.
    pub gas_limit: Vec<u8>,

    /// The receiver of the transaction.
    pub to: Vec<u8>,

    /// The transaction value.
    pub value: Vec<u8>,

    /// The V value of the signature.
    pub v: Vec<u8>,

    /// The raw call data.
    pub call_data: Vec<u8>,

    /// The R value of the signature.
    pub r: Vec<u8>,

    /// The S value of the signature.
    pub s: Vec<u8>,
}

// manual impl of debug for the hex encoding of everything :/
impl fmt::Debug for LegacyEthereumData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Self { nonce, gas_price, gas_limit, to, value, v, call_data, r, s } = self;
        f.debug_struct("LegacyEthereumData")
            .field("nonce", &hex::encode(nonce))
            .field("gas_price", &hex::encode(gas_price))
            .field("gas_limit", &hex::encode(gas_limit))
            .field("to", &hex::encode(to))
            .field("value", &hex::encode(value))
            .field("v", &hex::encode(v))
            .field("call_data", &hex::encode(call_data))
            .field("r", &hex::encode(r))
            .field("s", &hex::encode(s))
            .finish()
    }
}

impl LegacyEthereumData {
    fn decode_rlp(rlp: &Rlp) -> Result<Self, rlp::DecoderError> {
        if rlp.item_count()? != 9 {
            return Err(rlp::DecoderError::RlpIncorrectListLen);
        }

        Ok(Self {
            nonce: rlp.val_at(0)?,
            gas_price: rlp.val_at(1)?,
            gas_limit: rlp.val_at(2)?,
            to: rlp.val_at(3)?,
            value: rlp.val_at(4)?,
            call_data: rlp.val_at(5)?,
            v: rlp.val_at(6)?,
            r: rlp.val_at(7)?,
            s: rlp.val_at(8)?,
        })
    }

    /// Deserialize this data from rlp encoded bytes.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if decoding the bytes fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        // todo: test this.
        Self::decode_rlp(&Rlp::new(bytes)).map_err(Error::basic_parse)
    }

    /// Convert this data to rlp encoded bytes.
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        // todo: test this.
        let mut rlp = rlp::RlpStream::new_list(9);

        rlp.append(&self.nonce)
            .append(&self.gas_price)
            .append(&self.gas_limit)
            .append(&self.to)
            .append(&self.value)
            .append(&self.call_data)
            .append(&self.v)
            .append(&self.r)
            .append(&self.s);

        rlp.out().to_vec()
    }
}

/// Data for an Eip 1559 ethereum transaction.
#[derive(Clone)]
#[non_exhaustive]
pub struct Eip1559EthereumData {
    /// ID of the chain.
    pub chain_id: Vec<u8>,

    /// Transaction's nonce.
    pub nonce: Vec<u8>,

    /// An 'optional' additional fee in Ethereum that is paid directly to miners in order to incentivize
    /// them to include your transaction in a block. Not used in Hiero.
    pub max_priority_gas: Vec<u8>,

    /// The maximum amount, in tinybars, that the payer of the hedera transaction
    /// is willing to pay to complete the transaction.
    pub max_gas: Vec<u8>,

    /// The amount of gas available for the transaction.
    pub gas_limit: Vec<u8>,

    /// The receiver of the transaction.
    pub to: Vec<u8>,

    /// The transaction value.
    pub value: Vec<u8>,

    /// The raw call data.
    pub call_data: Vec<u8>,

    /// Specifies an array of addresses and storage keys that the transaction plans to access.
    pub access_list: Vec<Vec<u8>>,

    /// Recovery parameter used to ease the signature verification.
    pub recovery_id: Vec<u8>,

    /// The R value of the signature.
    pub r: Vec<u8>,

    /// The S value of the signature.
    pub s: Vec<u8>,
}

// manual impl of debug for the hex encoding of everything.
impl fmt::Debug for Eip1559EthereumData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        struct HexList<'a, T: AsRef<[u8]>>(&'a [T]);

        impl<'a, T: AsRef<[u8]>> fmt::Debug for HexList<'a, T> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_list().entries(self.0.iter().map(hex::encode)).finish()
            }
        }

        let Self {
            chain_id,
            nonce,
            max_priority_gas,
            max_gas,
            gas_limit,
            to,
            value,
            call_data,
            access_list,
            recovery_id,
            r,
            s,
        } = self;

        f.debug_struct("Eip1559EthereumData")
            .field("chain_id", &hex::encode(chain_id))
            .field("nonce", &hex::encode(nonce))
            .field("max_priority_gas", &hex::encode(max_priority_gas))
            .field("max_gas", &hex::encode(max_gas))
            .field("gas_limit", &hex::encode(gas_limit))
            .field("to", &hex::encode(to))
            .field("value", &hex::encode(value))
            .field("call_data", &hex::encode(call_data))
            .field("access_list", &HexList(access_list))
            .field("recovery_id", &hex::encode(recovery_id))
            .field("r", &hex::encode(r))
            .field("s", &hex::encode(s))
            .finish()
    }
}

impl Eip1559EthereumData {
    fn decode_rlp(rlp: &Rlp) -> Result<Self, rlp::DecoderError> {
        if rlp.item_count()? != 12 {
            return Err(rlp::DecoderError::RlpIncorrectListLen);
        }

        Ok(Self {
            chain_id: rlp.val_at(0)?,
            nonce: rlp.val_at(1)?,
            max_priority_gas: rlp.val_at(2)?,
            max_gas: rlp.val_at(3)?,
            gas_limit: rlp.val_at(4)?,
            to: rlp.val_at(5)?,
            value: rlp.val_at(6)?,
            call_data: rlp.val_at(7)?,
            access_list: rlp.list_at(8)?,
            recovery_id: rlp.val_at(9)?,
            r: rlp.val_at(10)?,
            s: rlp.val_at(11)?,
        })
    }

    /// Deserialize this data from rlp encoded bytes.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if decoding the bytes fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        let (&first, bytes) = bytes
            .split_first()
            .ok_or_else(|| Error::basic_parse("Empty ethereum transaction data"))?;

        if first != 2 {
            return Err(Error::basic_parse(rlp::DecoderError::Custom("Invalid kind")));
        }

        Self::decode_rlp(&Rlp::new(bytes)).map_err(Error::basic_parse)
    }

    /// Convert this data to rlp encoded bytes.
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut buffer = BytesMut::new();
        buffer.put_u8(0x02);
        let mut rlp = rlp::RlpStream::new_list_with_buffer(buffer, 12);

        rlp.append(&self.chain_id)
            .append(&self.nonce)
            .append(&self.max_priority_gas)
            .append(&self.max_gas)
            .append(&self.gas_limit)
            .append(&self.to)
            .append(&self.value)
            .append(&self.call_data)
            .append_list::<Vec<_>, _>(self.access_list.as_slice())
            .append(&self.recovery_id)
            .append(&self.r)
            .append(&self.s);

        rlp.out().to_vec()
    }
}

#[cfg(test)]
mod test {
    use expect_test::expect;
    use hex_literal::hex;

    use crate::ethereum::EthereumData;
    // https://github.com/hashgraph/hedera-services/blob/1e01d9c6b8923639b41359c55413640b589c4ec7/hapi-utils/src/test/java/com/hedera/services/ethereum/EthTxDataTest.java#L49
    const RAW_TX_TYPE_0: &[u8]  =
        &hex!("f864012f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc18180827653820277a0f9fbff985d374be4a55f296915002eec11ac96f1ce2df183adf992baa9390b2fa00c1e867cc960d9c74ec2e6a662b7908ec4c8cc9f3091e886bcefbeb2290fb792");

    const RAW_TX_TYPE_2: &[u8] =
        &hex!("02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66");

    #[test]
    fn legacy_to_from_bytes() {
        let data = EthereumData::from_bytes(RAW_TX_TYPE_0).unwrap();

        assert_eq!(hex::encode(RAW_TX_TYPE_0), hex::encode(data.to_bytes()));

        expect![[r#"
            Legacy(
                LegacyEthereumData {
                    nonce: "01",
                    gas_price: "2f",
                    gas_limit: "018000",
                    to: "7e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181",
                    value: "",
                    v: "0277",
                    call_data: "7653",
                    r: "f9fbff985d374be4a55f296915002eec11ac96f1ce2df183adf992baa9390b2f",
                    s: "0c1e867cc960d9c74ec2e6a662b7908ec4c8cc9f3091e886bcefbeb2290fb792",
                },
            )
        "#]]
        .assert_debug_eq(&data);

        // We don't currently support a way to get the ethereum hash, but we could
        // assert_eq!(hex!("9ffbd69c44cf643ed8d1e756b505e545e3b5dd3a6b5ef9da1d8eca6679706594"), data.ethereum_hash);
    }

    #[test]
    fn eip1559_to_from_bytes() {
        let data = EthereumData::from_bytes(RAW_TX_TYPE_2).unwrap();
        assert_eq!(hex::encode(RAW_TX_TYPE_2), hex::encode(data.to_bytes()));

        expect![[r#"
            Eip1559(
                Eip1559EthereumData {
                    chain_id: "012a",
                    nonce: "02",
                    max_priority_gas: "2f",
                    max_gas: "2f",
                    gas_limit: "018000",
                    to: "7e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181",
                    value: "0de0b6b3a7640000",
                    call_data: "123456",
                    access_list: [],
                    recovery_id: "01",
                    r: "df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479",
                    s: "1aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66",
                },
            )
        "#]]
        .assert_debug_eq(&data);
    }
}
// Filename: src/ethereum/ethereum_flow.rs
// SPDX-License-Identifier: Apache-2.0

use std::mem;

use super::ethereum_data::EthereumData;
use crate::{
    Client,
    EthereumTransaction,
    FileAppendTransaction,
    FileCreateTransaction,
    FileId,
    Hbar,
    TransactionResponse,
};

/// Flow for executing ethereum transactions.
#[derive(Default, Debug)]
pub struct EthereumFlow {
    ethereum_data: Option<EthereumData>,
    max_gas_allowance: Option<Hbar>,
}

impl EthereumFlow {
    const MAX_ETHEREUM_DATA_SIZE: usize = 5120;

    /// Create a new `EthereumFlow` ready for configuartion.
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns the raw Ethereum transaction (RLP encoded type 0, 1, and 2).
    #[must_use]
    pub fn get_ethereum_data(&self) -> Option<&EthereumData> {
        self.ethereum_data.as_ref()
    }

    /// Sets the raw Ethereum transaction data (RLP encoded type 0, 1, and 2).
    ///
    /// # Errors
    /// - [`Error::BasicParse`](crate::Error::BasicParse) if the given `data` cannot be parsed as [`EthereumData`].
    pub fn ethereum_data(&mut self, data: &[u8]) -> crate::Result<&mut Self> {
        self.ethereum_data = Some(EthereumData::from_bytes(data)?);

        Ok(self)
    }

    /// Returns the maximum amount that the payer of the hedera transaction is willing to pay to complete the transaction.
    #[must_use]
    pub fn get_max_gas_allowance(&self) -> Option<Hbar> {
        self.max_gas_allowance
    }

    /// Sets the maximum amount that the payer of the ethereum transaction is willing to pay to complete the transaction.
    pub fn max_gas_allowance(&mut self, hbar: Hbar) -> &mut Self {
        self.max_gas_allowance = Some(hbar);

        self
    }

    /// Generates the required transactions and executes them all.
    pub async fn execute(&self, client: &Client) -> crate::Result<TransactionResponse> {
        self.execute_with_optional_timeout(client, None).await
    }

    /// Generates the required transactions and executes them all.
    pub async fn execute_with_timeout(
        &self,
        client: &Client,
        timeout_per_transaction: std::time::Duration,
    ) -> crate::Result<TransactionResponse> {
        self.execute_with_optional_timeout(client, Some(timeout_per_transaction)).await
    }

    async fn execute_with_optional_timeout(
        &self,
        client: &Client,
        timeout_per_transaction: Option<std::time::Duration>,
    ) -> crate::Result<TransactionResponse> {
        let mut ethereum_data = self
            .ethereum_data
            .clone()
            .expect("Must set ethereum data before calling execute on ethereum flow");

        let ethereum_data_bytes = ethereum_data.to_bytes();

        let mut ethereum_transaction = EthereumTransaction::new();

        if let Some(allowance) = self.max_gas_allowance {
            ethereum_transaction.max_gas_allowance_hbar(allowance);
        }

        if ethereum_data_bytes.len() <= Self::MAX_ETHEREUM_DATA_SIZE {
            return ethereum_transaction
                .ethereum_data(ethereum_data_bytes)
                .execute_with_optional_timeout(client, timeout_per_transaction)
                .await;
        }

        let call_data = mem::take(ethereum_data.call_data_mut());
        let file_id = create_file(client, call_data, timeout_per_transaction).await?;
        let ethereum_data_bytes = ethereum_data.to_bytes();
        ethereum_transaction.call_data_file_id(file_id).ethereum_data(ethereum_data_bytes);

        ethereum_transaction.execute_with_optional_timeout(client, timeout_per_transaction).await
    }
}

fn split_call_data(call_data: Vec<u8>) -> (Vec<u8>, Option<Vec<u8>>) {
    const FILE_APPEND_DEFAULT_CHUNK_SIZE: usize = 4096;

    if call_data.len() <= FILE_APPEND_DEFAULT_CHUNK_SIZE {
        return (call_data, None);
    }

    let mut file_create_call_data = call_data;
    let file_append_call_data = file_create_call_data.split_off(FILE_APPEND_DEFAULT_CHUNK_SIZE);

    // note: this uses `subdata` because `Data` is it's own subsequence...
    // It's weirdly written such that the `fileAppendData` wouldn't start at index 0
    // even though that's literally what you'd expect.
    (file_create_call_data, Some(file_append_call_data))
}

async fn create_file(
    client: &Client,
    call_data: Vec<u8>,
    timeout_per_transaction: Option<std::time::Duration>,
) -> crate::Result<FileId> {
    let (file_create_data, file_append_data) = split_call_data(call_data);

    let file_id = FileCreateTransaction::new()
        .contents(file_create_data)
        .execute_with_optional_timeout(client, timeout_per_transaction)
        .await?
        .get_receipt_query()
        .execute_with_optional_timeout(client, timeout_per_transaction)
        .await?
        .file_id
        .expect("Creating a file means there's a file ID");

    if let Some(file_append_data) = file_append_data {
        FileAppendTransaction::new()
            .file_id(file_id)
            .contents(file_append_data)
            .execute_all_with_optional_timeout(client, timeout_per_transaction)
            .await?;
    }

    Ok(file_id)
}
// Filename: src/ethereum/ethereum_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    FileId,
    Hbar,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

/// Submit an Ethereum transaction.
pub type EthereumTransaction = Transaction<EthereumTransactionData>;

#[derive(Debug, Default, Clone)]
pub struct EthereumTransactionData {
    /// The raw Ethereum transaction (RLP encoded type 0, 1, and 2).
    ethereum_data: Vec<u8>,

    /// For large transactions (for example contract create) this should be used to
    /// set the FileId of an HFS file containing the call_data
    /// of the ethereum_data. The data in the ethereum_data will be re-written with
    /// the call_data element as a zero length string with the original contents in
    /// the referenced file at time of execution. The ethereum_data will need to be
    /// "rehydrated" with the call_data for signature validation to pass.
    call_data_file_id: Option<FileId>,

    /// The maximum amount that the payer of the hedera transaction
    /// is willing to pay to complete the transaction.
    max_gas_allowance_hbar: Hbar,
}

impl EthereumTransaction {
    /// Returns the raw Ethereum transaction (RLP encoded type 0, 1, and 2).
    #[must_use]
    pub fn get_ethereum_data(&self) -> &[u8] {
        &self.data().ethereum_data
    }

    /// Sets the raw Ethereum transaction (RLP encoded type 0, 1, and 2).
    pub fn ethereum_data(&mut self, data: Vec<u8>) -> &mut Self {
        self.data_mut().ethereum_data = data;
        self
    }

    /// Returns the file ID to find the raw Ethereum transaction (RLP encoded type 0, 1, and 2).
    #[must_use]
    pub fn get_call_data_file_id(&self) -> Option<FileId> {
        self.data().call_data_file_id
    }

    /// Sets a file ID to find the raw Ethereum transaction (RLP encoded type 0, 1, and 2).
    ///
    /// For large transactions (for example contract create) this should be used to
    /// set the [`FileId`] of an HFS file containing the `call_data`
    /// of the `ethereum_data`. The data in `the ethereum_data` will be re-written with
    /// the `call_data` element as a zero length string with the original contents in
    /// the referenced file at time of execution. `The ethereum_data` will need to be
    /// "rehydrated" with the `call_data` for signature validation to pass.
    pub fn call_data_file_id(&mut self, id: FileId) -> &mut Self {
        self.data_mut().call_data_file_id = Some(id);
        self
    }

    /// Returns the maximum amount that the payer of the hedera transaction
    /// is willing to pay to complete the transaction.
    #[must_use]
    pub fn get_max_gas_allowance_hbar(&self) -> Hbar {
        self.data().max_gas_allowance_hbar
    }

    /// Sets the maximum amount that the payer of the hedera transaction
    /// is willing to pay to complete the transaction.
    pub fn max_gas_allowance_hbar(&mut self, allowance: Hbar) -> &mut Self {
        self.data_mut().max_gas_allowance_hbar = allowance;
        self
    }
}

impl TransactionData for EthereumTransactionData {}

impl TransactionExecute for EthereumTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { SmartContractServiceClient::new(channel).call_ethereum(request).await })
    }
}

impl ValidateChecksums for EthereumTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.call_data_file_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for EthereumTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        let call_data = self.call_data_file_id.to_protobuf();

        services::transaction_body::Data::EthereumTransaction(services::EthereumTransactionBody {
            ethereum_data: self.ethereum_data.clone(),
            call_data,
            max_gas_allowance: self.max_gas_allowance_hbar.to_tinybars(),
        })
    }
}

impl From<EthereumTransactionData> for AnyTransactionData {
    fn from(transaction: EthereumTransactionData) -> Self {
        Self::Ethereum(transaction)
    }
}

impl FromProtobuf<services::EthereumTransactionBody> for EthereumTransactionData {
    fn from_protobuf(pb: services::EthereumTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            ethereum_data: pb.ethereum_data,
            call_data_file_id: Option::from_protobuf(pb.call_data)?,
            max_gas_allowance_hbar: Hbar::from_tinybars(pb.max_gas_allowance),
        })
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        EthereumTransaction,
    };

    fn make_transaction() -> EthereumTransaction {
        let mut tx = EthereumTransaction::new_for_tests();

        tx.ethereum_data(vec![0xde, 0xad, 0xbe, 0xef])
            .call_data_file_id("4.5.6".parse().unwrap())
            .max_gas_allowance_hbar("3".parse().unwrap())
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            EthereumTransaction(
                EthereumTransactionBody {
                    ethereum_data: [
                        222,
                        173,
                        190,
                        239,
                    ],
                    call_data: Some(
                        FileId {
                            shard_num: 4,
                            realm_num: 5,
                            file_num: 6,
                        },
                    ),
                    max_gas_allowance: 300000000,
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }
}
// Filename: src/ethereum/evm_address.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt;
use std::str::FromStr;

use hex::FromHexError;

use crate::{
    EntityId,
    Error,
};

/// An address as implemented in the Ethereum Virtual Machine.
#[derive(Copy, Clone, Eq, PartialEq, Hash)]
#[repr(transparent)]
pub struct EvmAddress(pub(crate) [u8; 20]);

impl EvmAddress {
    #[must_use]
    pub(crate) fn from_ref(bytes: &[u8; 20]) -> &Self {
        // safety: `self` is `#[repr(transpart)] over `[u8; 20]`
        unsafe { &*(bytes.as_ptr().cast::<EvmAddress>()) }
    }

    /// Gets the underlying bytes this EVM address is made from.
    #[must_use]
    pub fn to_bytes(self) -> [u8; 20] {
        self.0
    }
}

// potential point of confusion: This type is specifically for the `shard.realm.num` in 20 byte format.
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub(crate) struct SolidityAddress(pub(crate) EvmAddress);

impl SolidityAddress {
    #[must_use]
    pub(crate) fn from_ref(bytes: &[u8; 20]) -> &Self {
        // safety: `self` is `#[repr(transpart)] over `EvmAddress`, which is repr transparent over `[u8; 20]`.
        unsafe { &*(bytes.as_ptr().cast::<SolidityAddress>()) }
    }

    #[must_use]
    pub(crate) fn to_bytes(self) -> [u8; 20] {
        self.0.to_bytes()
    }
}

impl From<SolidityAddress> for EntityId {
    fn from(value: SolidityAddress) -> Self {
        let value = value.to_bytes();
        // todo: once split_array_ref is stable, all the unwraps and panics will go away.
        let (shard, value) = value.split_at(4);
        let (realm, num) = value.split_at(8);

        Self {
            shard: u64::from(u32::from_be_bytes(shard.try_into().unwrap())),
            realm: u64::from_be_bytes(realm.try_into().unwrap()),
            num: u64::from_be_bytes(num.try_into().unwrap()),
            checksum: None,
        }
    }
}

impl TryFrom<EntityId> for SolidityAddress {
    type Error = Error;

    fn try_from(value: EntityId) -> Result<Self, Self::Error> {
        // fixme: use the right error type
        let shard = u32::try_from(value.shard).map_err(Error::basic_parse)?.to_be_bytes();
        let realm = value.realm.to_be_bytes();
        let num = value.num.to_be_bytes();

        let mut buf = [0; 20];

        buf[0..][..shard.len()].copy_from_slice(&shard);
        buf[shard.len()..][..realm.len()].copy_from_slice(&realm);
        buf[(shard.len() + realm.len())..][..num.len()].copy_from_slice(&num);

        Ok(Self::from(buf))
    }
}

impl From<[u8; 20]> for SolidityAddress {
    fn from(value: [u8; 20]) -> Self {
        Self(EvmAddress(value))
    }
}

impl<'a> From<&'a [u8; 20]> for &'a SolidityAddress {
    fn from(value: &'a [u8; 20]) -> Self {
        SolidityAddress::from_ref(value)
    }
}

impl<'a> TryFrom<&'a [u8]> for &'a SolidityAddress {
    type Error = Error;

    fn try_from(value: &'a [u8]) -> Result<Self, Self::Error> {
        value.try_into().map(SolidityAddress::from_ref).map_err(|_| error_len(value.len()))
    }
}

impl TryFrom<Vec<u8>> for SolidityAddress {
    type Error = Error;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        <&SolidityAddress>::try_from(value.as_slice()).copied()
    }
}

impl FromStr for SolidityAddress {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut buf = [0; 20];

        // note: *optional* 0x prefix.
        let address = s.strip_prefix("0x").unwrap_or(s);

        hex::decode_to_slice(address, &mut buf).map(|()| Self(EvmAddress(buf))).map_err(|err| {
            match err {
                FromHexError::InvalidStringLength => error_len(address.len() / 2),
                err => Error::basic_parse(err),
            }
        })
    }
}

fn error_len(bytes: usize) -> crate::Error {
    Error::basic_parse(format!("expected 20 byte (40 character) evm address, got: `{bytes}` bytes"))
}

impl fmt::Debug for SolidityAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl fmt::Display for SolidityAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:x}", self.0)
    }
}

impl From<[u8; 20]> for EvmAddress {
    fn from(value: [u8; 20]) -> Self {
        Self(value)
    }
}

impl<'a> From<&'a [u8; 20]> for &'a EvmAddress {
    fn from(value: &'a [u8; 20]) -> Self {
        EvmAddress::from_ref(value)
    }
}

impl<'a> TryFrom<&'a [u8]> for &'a EvmAddress {
    type Error = Error;

    fn try_from(value: &'a [u8]) -> Result<Self, Self::Error> {
        value.try_into().map(EvmAddress::from_ref).map_err(|_| error_len(value.len()))
    }
}

impl TryFrom<Vec<u8>> for EvmAddress {
    type Error = Error;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        <&EvmAddress>::try_from(value.as_slice()).copied()
    }
}

// Note: *requires* 0x prefix.
impl FromStr for EvmAddress {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut buf = [0; 20];

        let address = s
            .strip_prefix("0x")
            .ok_or_else(|| Error::basic_parse("expected `0x` prefix in evm address"))?;

        hex::decode_to_slice(address, &mut buf).map(|()| Self(buf)).map_err(|err| match err {
            FromHexError::InvalidStringLength => error_len(address.len() / 2),
            err => Error::basic_parse(err),
        })
    }
}

impl fmt::Debug for EvmAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self:#x}\"")
    }
}

impl fmt::Display for EvmAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{self:#x}")
    }
}

impl fmt::LowerHex for EvmAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            f.write_str("0x")?;
        }

        let mut output = [0; 40];

        // panic: would either never panic or always panic, it never panics.
        hex::encode_to_slice(self.0, &mut output).unwrap();
        // should never fail. But `unsafe` here when we *aren't* in that crate would be... not great.
        let output = std::str::from_utf8_mut(&mut output).unwrap();
        f.write_str(output)
    }
}

#[cfg(test)]
mod tests {
    use assert_matches::assert_matches;
    use expect_test::expect;

    use super::SolidityAddress;
    use crate::{
        EntityId,
        EvmAddress,
    };

    #[test]
    fn parse_solidity() {
        let addr: SolidityAddress = "131211100f0e0d0c0b0a09080706050403020100".parse().unwrap();

        assert_eq!(
            &addr,
            SolidityAddress::from_ref(&hex_literal::hex!(
                "131211100f0e0d0c0b0a09080706050403020100"
            ))
        );
    }

    #[test]
    fn parse_evm() {
        let addr: EvmAddress = "0x131211100f0e0d0c0b0a09080706050403020100".parse().unwrap();

        assert_eq!(
            &addr,
            EvmAddress::from_ref(&hex_literal::hex!("131211100f0e0d0c0b0a09080706050403020100"))
        );
    }

    #[test]
    fn evm_address_missing_0x_fails() {
        let res: Result<EvmAddress, _> = "131211100f0e0d0c0b0a09080706050403020100".parse();

        assert_matches!(res, Err(crate::Error::BasicParse(_)))
    }

    #[test]
    fn solidity_address_bad_length_fails() {
        let res: Result<EvmAddress, _> = "0x0f0e0d0c0b0a09080706050403020100".parse();

        assert_matches!(res, Err(crate::Error::BasicParse(_)))
    }

    #[test]
    fn evm_address_bad_length_fails() {
        let res: Result<EvmAddress, _> = "0x0f0e0d0c0b0a09080706050403020100".parse();

        assert_matches!(res, Err(crate::Error::BasicParse(_)))
    }

    #[test]
    fn display() {
        expect![[r#"
            "0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c"
        "#]]
        .assert_debug_eq(&EvmAddress([0x0c; 20]));
    }

    #[test]
    fn to_entity_id() {
        let solidity_address = SolidityAddress(EvmAddress([0x0c; 20]));
        assert_eq!(
            EntityId::from(solidity_address),
            EntityId {
                shard: 0x0c0c0c0c,
                realm: 0x0c0c0c0c0c0c0c0c,
                num: 0x0c0c0c0c0c0c0c0c,
                checksum: None
            }
        )
    }
}
// Filename: src/ethereum/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod ethereum_data;
mod ethereum_flow;
mod ethereum_transaction;
mod evm_address;

pub use ethereum_data::{
    Eip1559EthereumData,
    EthereumData,
    LegacyEthereumData,
};
pub use ethereum_flow::EthereumFlow;
pub use ethereum_transaction::EthereumTransaction;
pub(crate) use ethereum_transaction::EthereumTransactionData;
pub use evm_address::EvmAddress;
pub(crate) use evm_address::SolidityAddress;
// Filename: src/exchange_rates.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use time::OffsetDateTime;

use crate::protobuf::FromProtobuf;
use crate::ToProtobuf;

/// The current and next exchange rates between [`Hbar`](crate::HbarUnit::Hbar) and USD-cents.
#[derive(Debug, Clone)]
pub struct ExchangeRates {
    /// The current exchange rate between [`Hbar`](crate::HbarUnit::Hbar) and USD-cents.
    pub current_rate: ExchangeRate,
    /// The next exchange rate between [`Hbar`](crate::HbarUnit::Hbar) and USD-cents.
    pub next_rate: ExchangeRate,
}

impl ExchangeRates {
    /// Create a new `ExchangeRates` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }
}

impl FromProtobuf<services::ExchangeRateSet> for ExchangeRates {
    fn from_protobuf(pb: services::ExchangeRateSet) -> crate::Result<Self> {
        Ok(Self {
            current_rate: ExchangeRate::from_protobuf(pb_getf!(pb, current_rate)?)?,
            next_rate: ExchangeRate::from_protobuf(pb_getf!(pb, next_rate)?)?,
        })
    }
}

impl ToProtobuf for ExchangeRates {
    type Protobuf = services::ExchangeRateSet;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ExchangeRateSet {
            current_rate: Some(self.current_rate.to_protobuf()),
            next_rate: Some(self.next_rate.to_protobuf()),
        }
    }
}

/// Denotes a conversion between Hbars and cents (USD).
#[derive(Debug, Clone)]
pub struct ExchangeRate {
    /// Denotes [`Hbar`](crate::HbarUnit::Hbar) equivalent to cents (USD).
    pub hbars: u32,

    /// Denotes cents (USD) equivalent to [`Hbar`](crate::HbarUnit::Hbar).
    pub cents: u32,

    /// Expiration time of this exchange rate.
    pub expiration_time: OffsetDateTime,

    /// Exchange rate in cents
    pub exchange_rate_in_cents: f64,
}

impl ExchangeRate {
    /// Calculated exchange rate.
    #[must_use]
    pub fn exchange_rate_in_cents(&self) -> f64 {
        f64::from(self.cents) / f64::from(self.hbars)
    }
}

impl FromProtobuf<services::ExchangeRate> for ExchangeRate {
    fn from_protobuf(pb: services::ExchangeRate) -> crate::Result<Self> {
        let hbars = pb.hbar_equiv as u32;
        let cents = pb.cent_equiv as u32;

        let exchange_rate_in_cents = f64::from(cents) / f64::from(hbars);

        Ok(Self {
            hbars,
            cents,
            exchange_rate_in_cents,
            expiration_time: pb_getf!(pb, expiration_time)?.into(),
        })
    }
}

impl ToProtobuf for ExchangeRate {
    type Protobuf = services::ExchangeRate;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ExchangeRate {
            hbar_equiv: self.hbars as i32,
            cent_equiv: self.cents as i32,
            expiration_time: Some(self.expiration_time.into()),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hex_literal::hex;

    use crate::ExchangeRates;

    #[test]
    fn from_protobuf() {
        let exchange_rates = ExchangeRates::from_bytes(&hex!(
            "0a1008b0ea0110b6b4231a0608f0bade9006121008b0ea01108cef231a060880d7de9006"
        ))
        .unwrap();

        expect![[r#"
            ExchangeRates {
                current_rate: ExchangeRate {
                    hbars: 30000,
                    cents: 580150,
                    expiration_time: 2022-02-24 15:00:00.0 +00:00:00,
                    exchange_rate_in_cents: 19.338333333333335,
                },
                next_rate: ExchangeRate {
                    hbars: 30000,
                    cents: 587660,
                    expiration_time: 2022-02-24 16:00:00.0 +00:00:00,
                    exchange_rate_in_cents: 19.588666666666665,
                },
            }
        "#]]
        .assert_debug_eq(&exchange_rates);
    }
}
// Filename: src/execute.rs
// SPDX-License-Identifier: Apache-2.0
mod error;

use std::any::type_name;
use std::borrow::Cow;
use std::ops::ControlFlow;
use std::time::{
    Duration,
    Instant,
};

use backoff::{
    ExponentialBackoff,
    ExponentialBackoffBuilder,
};
use futures_core::future::BoxFuture;
use futures_util::StreamExt;
use prost::Message;
use rand::seq::SliceRandom;
use rand::thread_rng;
use tonic::metadata::AsciiMetadataValue;
use tonic::transport::Channel;
use triomphe::Arc;

use crate::client::NetworkData;
use crate::execute::error::is_tonic_status_transient;
use crate::ping_query::PingQuery;
use crate::{
    client,
    retry,
    AccountId,
    BoxGrpcFuture,
    Client,
    Error,
    Status,
    TransactionId,
    ValidateChecksums,
};

pub(crate) trait Execute: ValidateChecksums {
    type GrpcRequest: Clone + Message;

    type GrpcResponse: Message;

    /// Additional context returned from each call to `make_request`. Upon
    /// a successful request, the associated response context is passed to
    /// `make_response`.
    type Context: Send;

    type Response;

    /// Account ID to be used for generating transaction IDs.
    ///
    /// This is only used `self.requires_transaction` and `self.transaction_id.is_none()`.
    fn operator_account_id(&self) -> Option<&AccountId>;

    /// Get the _explicit_ nodes that this request will be submitted to.
    fn node_account_ids(&self) -> Option<&[AccountId]>;

    /// Get the _explicit_ transaction ID that this request will use.
    fn transaction_id(&self) -> Option<TransactionId>;

    /// Get whether to generate transaction IDs for request creation.
    fn requires_transaction_id(&self) -> bool;

    /// Returns whether to regenerate transaction IDs for request creation.
    ///
    /// Transaction ID regeneration only can happen when `transaction_id` is None and `requires_transaction_id` is true.
    fn regenerate_transaction_id(&self) -> Option<bool> {
        None
    }

    /// Check whether to retry an pre-check status.
    fn should_retry_pre_check(&self, _status: Status) -> bool {
        false
    }

    /// Check whether we should retry an otherwise successful response.
    #[allow(unused_variables)]
    fn should_retry(&self, response: &Self::GrpcResponse) -> bool {
        false
    }

    /// Create a new request for execution.
    ///
    /// A created request is cached per node until any request returns
    /// `TransactionExpired`; in which case, the request cache is cleared.
    fn make_request(
        &self,
        transaction_id: Option<&TransactionId>,
        node_account_id: AccountId,
    ) -> crate::Result<(Self::GrpcRequest, Self::Context)>;

    /// Execute the created GRPC request against the provided GRPC channel.
    fn execute(
        &self,
        channel: Channel,
        request: Self::GrpcRequest,
    ) -> BoxGrpcFuture<Self::GrpcResponse>;

    /// Create a response from the GRPC response and the saved transaction
    /// and node account ID from the successful request.
    fn make_response(
        &self,
        response: Self::GrpcResponse,
        context: Self::Context,
        node_account_id: AccountId,
        transaction_id: Option<&TransactionId>,
    ) -> crate::Result<Self::Response>;

    /// Create an error from the given pre-check status.
    fn make_error_pre_check(
        &self,
        status: Status,
        transaction_id: Option<&TransactionId>,
        response: Self::GrpcResponse,
    ) -> crate::Error;

    /// Extract the pre-check status from the GRPC response.
    fn response_pre_check_status(response: &Self::GrpcResponse) -> crate::Result<i32>;
}

struct ExecuteContext {
    // When `Some` the `transaction_id` will be regenerated when expired.
    operator_account_id: Option<AccountId>,
    network: Arc<NetworkData>,
    backoff_config: ExponentialBackoff,
    max_attempts: usize,
    // timeout for a single grpc request.
    grpc_timeout: Option<Duration>,
}

pub(crate) async fn execute<E>(
    client: &Client,
    executable: &E,
    timeout: Option<Duration>,
) -> crate::Result<E::Response>
where
    E: Execute + Sync,
{
    if client.auto_validate_checksums() {
        let ledger_id = client.ledger_id_internal();
        let ledger_id = ledger_id
            .as_ref()
            .expect("Client had auto_validate_checksums enabled but no ledger ID");

        executable.validate_checksums(ledger_id.as_ref_ledger_id())?;
    }

    let operator_account_id = 'op: {
        if executable.transaction_id().is_some()
            || !executable
                .regenerate_transaction_id()
                .unwrap_or(client.default_regenerate_transaction_id())
        {
            break 'op None;
        }

        executable
            .operator_account_id()
            .copied()
            .or_else(|| client.load_operator().as_ref().map(|it| it.account_id))
    };

    let backoff = client.backoff();
    let mut backoff_builder = ExponentialBackoffBuilder::new();

    backoff_builder
        .with_initial_interval(backoff.initial_backoff)
        .with_max_interval(backoff.max_backoff);

    if let Some(timeout) = timeout.or(backoff.request_timeout) {
        backoff_builder.with_max_elapsed_time(Some(timeout));
    }

    execute_inner(
        &ExecuteContext {
            max_attempts: backoff.max_attempts,
            backoff_config: backoff_builder.build(),
            operator_account_id,
            network: client.net().0.load_full(),
            grpc_timeout: backoff.grpc_timeout,
        },
        executable,
    )
    .await
}

async fn execute_inner<E>(ctx: &ExecuteContext, executable: &E) -> crate::Result<E::Response>
where
    E: Execute + Sync,
{
    fn recurse_ping(ctx: &ExecuteContext, index: usize) -> BoxFuture<'_, bool> {
        Box::pin(async move {
            let ctx = ExecuteContext {
                operator_account_id: None,
                network: Arc::clone(&ctx.network),
                backoff_config: ctx.backoff_config.clone(),
                max_attempts: ctx.max_attempts,
                grpc_timeout: ctx.grpc_timeout,
            };
            let ping_query = PingQuery::new(ctx.network.node_ids()[index]);

            execute_inner(&ctx, &ping_query).await.is_ok()
        })
    }

    // the overall timeout for the backoff starts measuring from here
    let backoff = ctx.backoff_config.clone();

    // TODO: cache requests to avoid signing a new request for every node in a delayed back-off

    // if we need to generate a transaction ID for this request (and one was not provided),
    // generate one now
    let explicit_transaction_id = executable.transaction_id();
    let mut transaction_id = executable
        .requires_transaction_id()
        .then_some(explicit_transaction_id)
        .and_then(|it| it.or_else(|| ctx.operator_account_id.map(TransactionId::generate)));

    // if we were explicitly given a list of nodes to use, we iterate through each
    // of the given nodes (in a random order)
    let explicit_node_indexes = executable
        .node_account_ids()
        .map(|ids| ctx.network.node_indexes_for_ids(ids))
        .transpose()?;

    let explicit_node_indexes = explicit_node_indexes.as_deref();

    let layer = move || async move {
        loop {
            let mut last_error: Option<Error> = None;

            let random_node_indexes = random_node_indexes(&ctx.network, explicit_node_indexes)
                .ok_or(retry::Error::EmptyTransient)?;

            let random_node_indexes = {
                let random_node_indexes = &random_node_indexes;
                let client = ctx;
                let now = Instant::now();
                futures_util::stream::iter(random_node_indexes.iter().copied()).filter(
                    move |&node_index| async move {
                        // NOTE: For pings we're relying on the fact that they have an explict node index.
                        explicit_node_indexes.is_some()
                            || client.network.node_recently_pinged(node_index, now)
                            || recurse_ping(client, node_index).await
                    },
                )
            };

            let mut random_node_indexes = std::pin::pin!(random_node_indexes);

            while let Some(node_index) = random_node_indexes.next().await {
                let tmp = execute_single(ctx, executable, node_index, &mut transaction_id).await;

                log::log!(
                    match &tmp {
                        Ok(ControlFlow::Break(_)) => log::Level::Debug,
                        Ok(ControlFlow::Continue(_)) => log::Level::Warn,
                        Err(e) =>
                            if e.is_transient() {
                                log::Level::Warn
                            } else {
                                log::Level::Error
                            },
                    },
                    "Execution of {} on node at index {node_index} / node id {} {}",
                    type_name::<E>(),
                    ctx.network.channel(node_index).0,
                    match &tmp {
                        Ok(ControlFlow::Break(_)) => Cow::Borrowed("succeeded"),
                        Ok(ControlFlow::Continue(err)) =>
                            format!("will continue due to {err:?}").into(),
                        Err(err) => format!("failed due to {err:?}").into(),
                    },
                );

                match tmp? {
                    ControlFlow::Continue(err) => last_error = Some(err),
                    ControlFlow::Break(res) => return Ok(res),
                }
            }

            match last_error {
                Some(it) => return Err(retry::Error::Transient(it)),
                // this can only happen if we skipped every node due to pinging it coming up `false` (unhealthy)... The node will be marked as unhealthy, soo
                None => continue,
            }
        }
    };

    // the outer loop continues until we timeout or reach the maximum number of "attempts"
    // an attempt is counted when we have a successful response from a node that must either
    // be retried immediately (on a new node) or retried after a backoff.
    crate::retry(backoff, Some(ctx.max_attempts), layer).await
}

fn map_tonic_error(
    status: tonic::Status,
    network: &client::NetworkData,
    node_index: usize,
    request_free: bool,
) -> retry::Error {
    const MIME_HTML: &[u8] = b"text/html";

    match status.code() {
        // if the node says it isn't available, then we should just try again with a different node.
        tonic::Code::Unavailable | tonic::Code::ResourceExhausted => {
            // NOTE: this is an "unhealthy" node
            network.mark_node_unhealthy(node_index);

            // try the next node in our allowed list, immediately
            retry::Error::Transient(status.into())
        }

        // todo: find a way to make this less fragile
        // hack:
        // if this happens:
        // the node is completely borked (we're probably seeing the load balancer's response),
        // and we have no clue if the effect went through
        tonic::Code::Internal
            if status.metadata().get("content-type").map(AsciiMetadataValue::as_bytes)
                == Some(MIME_HTML) =>
        {
            network.mark_node_unhealthy(node_index);

            // hack to the hack:
            // if this is a free request let's try retrying it anyway...
            match request_free {
                true => retry::Error::Transient(status.into()),
                false => retry::Error::Permanent(status.into()),
            }
        }

        _ if is_tonic_status_transient(&status) => {
            network.mark_node_unhealthy(node_index);

            retry::Error::Transient(status.into())
        }

        // fail immediately
        _ => retry::Error::Permanent(status.into()),
    }
}

async fn execute_single<E: Execute + Sync>(
    ctx: &ExecuteContext,
    executable: &E,
    node_index: usize,
    transaction_id: &mut Option<TransactionId>,
) -> retry::Result<ControlFlow<E::Response, Error>> {
    let (node_account_id, channel) = ctx.network.channel(node_index);

    log::debug!(
        "Preparing {} on node at index {node_index} / node id {node_account_id}",
        type_name::<E>()
    );

    let (request, context) = executable
        .make_request(transaction_id.as_ref(), node_account_id)
        // Does not represent a network error or error returned by a node
        .map_err(retry::Error::Permanent)?;

    log::debug!(
        "Executing {} on node at index {node_index} / node id {node_account_id}",
        type_name::<E>()
    );

    let fut = executable.execute(channel, request);

    let response = match ctx.grpc_timeout {
        Some(it) => match tokio::time::timeout(it, fut).await {
            Ok(it) => it,
            Err(_) => {
                return Ok(ControlFlow::Continue(crate::Error::GrpcStatus(
                    tonic::Status::deadline_exceeded("explicitly given grpc timeout was exceeded"),
                )))
            }
        },
        None => fut.await,
    };

    let response = response.map(tonic::Response::into_inner).map_err(|status| {
        map_tonic_error(status, &ctx.network, node_index, transaction_id.is_none())
    });

    let response = match response {
        Ok(response) => response,
        Err(retry::Error::Transient(err)) => {
            return Ok(ControlFlow::Continue(err));
        }

        Err(e) => return Err(e),
    };

    // at this point, any failure isn't from the node, it's from the request.
    ctx.network.mark_node_healthy(node_index);

    let status = E::response_pre_check_status(&response)
        .and_then(|status| {
            // not sure how to proceed, fail immediately
            Status::try_from(status).or_else(|_| Err(Error::ResponseStatusUnrecognized(status)))
        })
        .map_err(retry::Error::Permanent)?;

    match status {
        Status::Ok if executable.should_retry(&response) => Err(retry::Error::Transient(
            executable.make_error_pre_check(status, transaction_id.as_ref(), response),
        )),

        Status::Ok => executable
            .make_response(response, context, node_account_id, transaction_id.as_ref())
            .map(ControlFlow::Break)
            .map_err(retry::Error::Permanent),

        Status::Busy | Status::PlatformNotActive => {
            // NOTE: this is a "busy" node
            // try the next node in our allowed list, immediately
            Ok(ControlFlow::Continue(executable.make_error_pre_check(
                status,
                transaction_id.as_ref(),
                response,
            )))
        }

        // would do an `if_let` but, not stable ._.
        Status::TransactionExpired if ctx.operator_account_id.is_some() => {
            // the transaction that was generated has since expired
            // re-generate the transaction ID and try again, immediately

            let new = TransactionId::generate(ctx.operator_account_id.unwrap());

            *transaction_id = Some(new);

            Ok(ControlFlow::Continue(executable.make_error_pre_check(
                status,
                transaction_id.as_ref(),
                response,
            )))
        }

        _ if executable.should_retry_pre_check(status) => {
            // conditional retry on pre-check should back-off and try again
            Err(retry::Error::Transient(executable.make_error_pre_check(
                status,
                transaction_id.as_ref(),
                response,
            )))
        }

        _ => {
            // any other pre-check is an error that the user needs to fix, fail immediately
            Err(retry::Error::Permanent(executable.make_error_pre_check(
                status,
                transaction_id.as_ref(),
                response,
            )))
        }
    }
}

// todo: return an iterator.
fn random_node_indexes(
    network: &client::NetworkData,
    explicit_node_indexes: Option<&[usize]>,
) -> Option<Vec<usize>> {
    // cache the rng impl and "now" because `thread_rng` is TLS (a thread local),
    // and because using the same reference time avoids situations where a node that wasn't available becomes available.
    let mut rng = thread_rng();
    let now = Instant::now();

    if let Some(indexes) = explicit_node_indexes {
        let tmp: Vec<_> =
            indexes.iter().copied().filter(|index| network.is_node_healthy(*index, now)).collect();

        let mut indexes = if tmp.is_empty() { indexes.to_vec() } else { tmp };

        assert!(!indexes.is_empty(), "empty explicitly set nodes");

        indexes.shuffle(&mut rng);

        return Some(indexes);
    }

    {
        let mut indexes: Vec<_> = network.healthy_node_indexes(now).collect();

        if indexes.is_empty() {
            return None;
        }

        // would put this inline, but borrowck wouldn't allow that.
        let amount = (indexes.len() + 2) / 3;

        let (shuffled, _) = indexes.partial_shuffle(&mut rng, amount);

        Some(shuffled.to_vec())
    }
}
// Filename: src/execute/error.rs
// SPDX-License-Identifier: Apache-2.0
use std::error::Error;

use serde::de::StdError;

fn has_transient_io_error<E: StdError>(error: E) -> bool {
    let Some(source) = error.source() else {
        return false;
    };

    if let Some(io_error) = source.downcast_ref::<std::io::Error>() {
        is_io_error_transient(io_error)
    } else {
        false
    }
}

// tonic 0.12
fn is_hyper_error_transient(error: &hyper::Error) -> bool {
    if error.is_canceled() || has_transient_io_error(error) {
        true
    } else if let Some(source) = error.source() {
        if let Some(h2_error) = source.downcast_ref::<h2::Error>() {
            h2_error.is_go_away()
        } else {
            false
        }
    } else {
        false
    }
}

fn is_io_error_transient(error: &std::io::Error) -> bool {
    match error.kind() {
        std::io::ErrorKind::BrokenPipe => true,
        _ => false,
    }
}

pub(super) fn is_tonic_status_transient(status: &tonic::Status) -> bool {
    let source = status
        .source()
        .and_then(|it| it.downcast_ref::<tonic::transport::Error>())
        .and_then(StdError::source);

    let Some(source) = source else {
        return false;
    };

    if let Some(hyper) = source.downcast_ref::<hyper::Error>() {
        is_hyper_error_transient(hyper)
    } else if let Some(hyper) = source.downcast_ref::<hyper::Error>() {
        is_hyper_error_transient(hyper)
    } else {
        false
    }
}

/// Tests some non-detection scenarios.
///
/// Because hyper does not expose constructors for its error variants, there is no
/// reasonable way to construct a test for positive detection of a hyper cancellation.
#[cfg(test)]
mod test_is_tonic_status_transient {
    use tonic::Code;

    use super::is_tonic_status_transient;

    #[test]
    fn ignores_tonic_abort() {
        let input = tonic::Status::new(Code::Aborted, "foo");

        assert!(!is_tonic_status_transient(&input));
    }

    #[test]
    fn ignores_tonic_cancel() {
        let input = tonic::Status::new(Code::Cancelled, "foo");

        assert!(!is_tonic_status_transient(&input));
    }
}
// Filename: src/fee_schedules.rs
use hedera_proto::services;
use time::OffsetDateTime;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};

/// Contains the current and next [`FeeSchedule`]s.
///
/// See the [Hiero documentation]
///
/// [Hiero documentation]: https://docs.hedera.com/guides/docs/hedera-api/basic-types/currentandnextfeeschedule
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct FeeSchedules {
    /// The current fee schedule.
    pub current: Option<FeeSchedule>,

    /// The next fee schedule.
    pub next: Option<FeeSchedule>,
}

impl FeeSchedules {
    /// Create a new `FeeSchedules` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::CurrentAndNextFeeSchedule> for FeeSchedules {
    fn from_protobuf(pb: services::CurrentAndNextFeeSchedule) -> crate::Result<Self> {
        Ok(Self {
            current: Option::from_protobuf(pb.current_fee_schedule)?,
            next: Option::from_protobuf(pb.next_fee_schedule)?,
        })
    }
}

impl ToProtobuf for FeeSchedules {
    type Protobuf = services::CurrentAndNextFeeSchedule;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::CurrentAndNextFeeSchedule {
            current_fee_schedule: self.current.to_protobuf(),
            next_fee_schedule: self.next.to_protobuf(),
        }
    }
}

/// The fee schedules for hedera functionality and the time at which this fee schedule will expire.
///
/// See the [Hiero documentation].
///
/// [Hiero documentation]: https://docs.hedera.com/guides/docs/hedera-api/basic-types/feeschedule
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct FeeSchedule {
    /// The fee schedules per specific piece of functionality.
    pub transaction_fee_schedules: Vec<TransactionFeeSchedule>,

    /// The time this fee schedule will expire at.
    pub expiration_time: OffsetDateTime,
}

impl FeeSchedule {
    /// Create a new `FeeSchedule` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::FeeSchedule> for FeeSchedule {
    fn from_protobuf(pb: services::FeeSchedule) -> crate::Result<Self> {
        Ok(Self {
            transaction_fee_schedules: Vec::from_protobuf(pb.transaction_fee_schedule)?,
            expiration_time: pb_getf!(pb, expiry_time)?.into(),
        })
    }
}

impl ToProtobuf for FeeSchedule {
    type Protobuf = services::FeeSchedule;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::FeeSchedule {
            transaction_fee_schedule: self.transaction_fee_schedules.to_protobuf(),
            expiry_time: Some(self.expiration_time.into()),
        }
    }
}

/// The fees for a specific transaction or query based on the fee data.
///
/// See the [Hiero documentation].
///
/// [Hiero documentation]: https://docs.hedera.com/guides/docs/hedera-api/basic-types/transactionfeeschedule
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionFeeSchedule {
    /// The request type that this fee schedule applies to.
    pub request_type: RequestType,

    /// Resource price coefficients.
    #[deprecated]
    pub fee_data: Option<Box<FeeData>>,

    /// Resource price coefficients.
    ///
    /// Supports subtype definition.
    pub fees: Vec<FeeData>,
}

impl TransactionFeeSchedule {
    /// Create a new `TransactionFeeSchedule` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::TransactionFeeSchedule> for TransactionFeeSchedule {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::TransactionFeeSchedule) -> crate::Result<Self> {
        Ok(Self {
            request_type: RequestType::from_protobuf(pb.hedera_functionality())?,
            fee_data: Option::from_protobuf(pb.fee_data)?.map(Box::new),
            fees: Vec::from_protobuf(pb.fees)?,
        })
    }
}

impl ToProtobuf for TransactionFeeSchedule {
    type Protobuf = services::TransactionFeeSchedule;

    #[allow(deprecated)]
    fn to_protobuf(&self) -> Self::Protobuf {
        services::TransactionFeeSchedule {
            hedera_functionality: self.request_type.to_protobuf() as i32,
            fee_data: self.fee_data.to_protobuf(),
            fees: self.fees.to_protobuf(),
        }
    }
}

/// The functionality provided by Hiero.
#[derive(Debug, Clone, Eq, PartialEq)]
#[non_exhaustive]
pub enum RequestType {
    /// UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and not parsed (0 is ignored by parser)
    None,

    /// Transfer from one account to another.
    ///
    /// [`TransferTransaction`](crate::TransferTransaction).
    CryptoTransfer,

    /// Update an account.
    ///
    /// [`AccountUpdateTransaction`](crate::AccountUpdateTransaction).
    CryptoUpdate,

    /// Delete an account.
    ///
    /// [`AccountDeleteTransaction`](crate::AccountDeleteTransaction).
    CryptoDelete,

    /// Add a live hash to an account (not currently supported).
    CryptoAddLiveHash,

    /// Remove a live hash from an account (not currently supported).
    CryptoDeleteLiveHash,

    /// Execute a contract.
    ///
    /// [`ContractExecuteTransaction`](crate::ContractExecuteTransaction)
    ContractCall,

    /// Create a contract.
    ///
    /// [`ContractCreateTransaction`](crate::ContractCreateTransaction)
    ContractCreate,

    /// Update a contract.
    ///
    /// [`ContractUpdateTransaction`](crate::ContractUpdateTransaction)
    ContractUpdate,

    /// Create a file.
    FileCreate,

    /// Append data to a file.
    FileAppend,

    /// Update a file.
    FileUpdate,

    /// Delete a file.
    FileDelete,

    /// Query the balance for an account.
    CryptoGetAccountBalance,

    /// Query the records for an account.
    CryptoGetAccountRecords,

    /// Query the info for an account.
    CryptoGetInfo,

    /// Execute a contract locally on a node.
    ContractCallLocal,

    /// Query the info for a contract.
    ContractGetInfo,

    /// Query the bytecode for a contract.
    ContractGetBytecode,

    /// Lookup a contract by its solidity ID.
    GetBySolidityId,

    /// Lookup a contract by key.
    GetByKey,

    /// Query the live hashes for a account (not currently supported).
    CryptoGetLiveHash,

    /// Query the stakers for an account.
    CryptoGetStakers,

    /// Query the contents of a file.
    FileGetContents,

    /// Query the info for a file.
    FileGetInfo,

    /// Query the record for a transaction.
    TransactionGetRecord,

    /// Query the records for a contract.
    ContractGetRecords,

    /// Create an account.
    CryptoCreate,

    /// System delete a file or contract.
    SystemDelete,

    /// System undelete a file or contract.
    SystemUndelete,

    /// Delete a contract.
    ContractDelete,

    /// Freeze the network.
    Freeze,

    /// Creation of a transaction record..
    CreateTransactionRecord,

    /// Auto renewal of an account.
    CryptoAccountAutoRenew,

    /// Auto renewal of a contract
    ContractAutoRenew,

    /// Query the version info of the network.
    GetVersionInfo,

    /// Query the receipt for a transaction.
    TransactionGetReceipt,

    /// Create a topic.
    ConsensusCreateTopic,

    /// Update a topic.
    ConsensusUpdateTopic,

    /// Delete a topic.
    ConsensusDeleteTopic,

    /// Query the info for a topic.
    ConsensusGetTopicInfo,

    /// Submit a message to a topic.
    ConsensusSubmitMessage,

    /// Submit a transaction without validation.
    UncheckedSubmit,

    /// Create a topic.
    TokenCreate,

    /// Query the info for a token.
    TokenGetInfo,

    /// Freeze an account's balance of a token.
    TokenFreezeAccount,

    /// Unfreeze an account's balance of a token.
    TokenUnfreezeAccount,

    /// Grant KYC to an account for a token.
    TokenGrantKycToAccount,

    /// Revoke KYC from an account for a token.
    TokenRevokeKycFromAccount,

    /// Delete a token.
    TokenDelete,

    /// Update a token.
    TokenUpdate,

    /// Mint items on a token.
    TokenMint,

    /// Burn items from a token.
    TokenBurn,

    /// Wipe an account's balance of a token.
    TokenAccountWipe,

    /// Associate tokens to an account.
    TokenAssociateToAccount,

    /// Dissociate tokens from an account.
    TokenDissociateFromAccount,

    /// Create a schedule.
    ScheduleCreate,

    /// Delete a schedule.
    ScheduleDelete,

    /// Sign a schedule.
    ScheduleSign,

    /// Query the info for a schedule.
    ScheduleGetInfo,

    /// Query the info of held NFTs for an account.
    TokenGetAccountNftInfos,

    /// Query the info of an NFT for a token.
    TokenGetNftInfo,

    /// Query the info of NFT for a token.
    TokenGetNftInfos,

    /// Update the fee schedule for a token.
    TokenFeeScheduleUpdate,

    /// Query the execution time of a transaction.
    NetworkGetExecutionTime,

    /// Pause usage of a token.
    TokenPause,

    /// Unpause usage of a token.
    TokenUnpause,

    /// Approve an account spending another account's currency.
    CryptoApproveAllowance,

    /// Unapprove an account spending another account's currency.
    CryptoDeleteAllowance,

    /// Query the details for an account.
    GetAccountDetails,

    /// Execute an ethereum style transaction.
    EthereumTransaction,

    /// Update an account/contract's staked node.
    NodeStakeUpdate,

    /// Execute a PRNG transaction.
    UtilPrng,

    /// Get a record for a transaction.
    TransactionGetFastRecord,

    /// Update the metadata of one or more NFT's of a specific token type.
    TokenUpdateNfts,

    /// Create a new node.
    NodeCreate,

    /// Update an existing node.
    NodeUpdate,

    /// Delete a node.
    NodeDelete,

    /// Reject tokens.
    TokenReject,

    /// Airdrop tokens.
    TokenAirdrop,

    /// Claim airdrop tokens.
    TokenClaimAirdrop,

    /// Cancel airdrop tokens.
    TokenCancelAirdrop,
}

impl FromProtobuf<services::HederaFunctionality> for RequestType {
    fn from_protobuf(pb: services::HederaFunctionality) -> crate::Result<Self> {
        use services::HederaFunctionality;
        let value = match pb {
            HederaFunctionality::None => Self::None,
            HederaFunctionality::CryptoTransfer => Self::CryptoTransfer,
            HederaFunctionality::CryptoUpdate => Self::CryptoUpdate,
            HederaFunctionality::CryptoDelete => Self::CryptoDelete,
            HederaFunctionality::CryptoAddLiveHash => Self::CryptoAddLiveHash,
            HederaFunctionality::CryptoDeleteLiveHash => Self::CryptoDeleteLiveHash,
            HederaFunctionality::ContractCall => Self::ContractCall,
            HederaFunctionality::ContractCreate => Self::ContractCreate,
            HederaFunctionality::ContractUpdate => Self::ContractUpdate,
            HederaFunctionality::FileCreate => Self::FileCreate,
            HederaFunctionality::FileAppend => Self::FileAppend,
            HederaFunctionality::FileUpdate => Self::FileUpdate,
            HederaFunctionality::FileDelete => Self::FileDelete,
            HederaFunctionality::CryptoGetAccountBalance => Self::CryptoGetAccountBalance,
            HederaFunctionality::CryptoGetAccountRecords => Self::CryptoGetAccountRecords,
            HederaFunctionality::CryptoGetInfo => Self::CryptoGetInfo,
            HederaFunctionality::ContractCallLocal => Self::ContractCallLocal,
            HederaFunctionality::ContractGetInfo => Self::ContractGetInfo,
            HederaFunctionality::ContractGetBytecode => Self::ContractGetBytecode,
            HederaFunctionality::GetBySolidityId => Self::GetBySolidityId,
            HederaFunctionality::GetByKey => Self::GetByKey,
            HederaFunctionality::CryptoGetLiveHash => Self::CryptoGetLiveHash,
            HederaFunctionality::CryptoGetStakers => Self::CryptoGetStakers,
            HederaFunctionality::FileGetContents => Self::FileGetContents,
            HederaFunctionality::FileGetInfo => Self::FileGetInfo,
            HederaFunctionality::TransactionGetRecord => Self::TransactionGetRecord,
            HederaFunctionality::ContractGetRecords => Self::ContractGetRecords,
            HederaFunctionality::CryptoCreate => Self::CryptoCreate,
            HederaFunctionality::SystemDelete => Self::SystemDelete,
            HederaFunctionality::SystemUndelete => Self::SystemUndelete,
            HederaFunctionality::ContractDelete => Self::ContractDelete,
            HederaFunctionality::Freeze => Self::Freeze,
            HederaFunctionality::CreateTransactionRecord => Self::CreateTransactionRecord,
            HederaFunctionality::CryptoAccountAutoRenew => Self::CryptoAccountAutoRenew,
            HederaFunctionality::ContractAutoRenew => Self::ContractAutoRenew,
            HederaFunctionality::GetVersionInfo => Self::GetVersionInfo,
            HederaFunctionality::TransactionGetReceipt => Self::TransactionGetReceipt,
            HederaFunctionality::ConsensusCreateTopic => Self::ConsensusCreateTopic,
            HederaFunctionality::ConsensusUpdateTopic => Self::ConsensusUpdateTopic,
            HederaFunctionality::ConsensusDeleteTopic => Self::ConsensusDeleteTopic,
            HederaFunctionality::ConsensusGetTopicInfo => Self::ConsensusGetTopicInfo,
            HederaFunctionality::ConsensusSubmitMessage => Self::ConsensusSubmitMessage,
            HederaFunctionality::UncheckedSubmit => Self::UncheckedSubmit,
            HederaFunctionality::TokenCreate => Self::TokenCreate,
            HederaFunctionality::TokenGetInfo => Self::TokenGetInfo,
            HederaFunctionality::TokenFreezeAccount => Self::TokenFreezeAccount,
            HederaFunctionality::TokenUnfreezeAccount => Self::TokenUnfreezeAccount,
            HederaFunctionality::TokenGrantKycToAccount => Self::TokenGrantKycToAccount,
            HederaFunctionality::TokenRevokeKycFromAccount => Self::TokenRevokeKycFromAccount,
            HederaFunctionality::TokenDelete => Self::TokenDelete,
            HederaFunctionality::TokenUpdate => Self::TokenUpdate,
            HederaFunctionality::TokenMint => Self::TokenMint,
            HederaFunctionality::TokenBurn => Self::TokenBurn,
            HederaFunctionality::TokenAccountWipe => Self::TokenAccountWipe,
            HederaFunctionality::TokenAssociateToAccount => Self::TokenAssociateToAccount,
            HederaFunctionality::TokenDissociateFromAccount => Self::TokenDissociateFromAccount,
            HederaFunctionality::ScheduleCreate => Self::ScheduleCreate,
            HederaFunctionality::ScheduleDelete => Self::ScheduleDelete,
            HederaFunctionality::ScheduleSign => Self::ScheduleSign,
            HederaFunctionality::ScheduleGetInfo => Self::ScheduleGetInfo,
            HederaFunctionality::TokenGetAccountNftInfos => Self::TokenGetAccountNftInfos,
            HederaFunctionality::TokenGetNftInfo => Self::TokenGetNftInfo,
            HederaFunctionality::TokenGetNftInfos => Self::TokenGetNftInfos,
            HederaFunctionality::TokenFeeScheduleUpdate => Self::TokenFeeScheduleUpdate,
            HederaFunctionality::NetworkGetExecutionTime => Self::NetworkGetExecutionTime,
            HederaFunctionality::TokenPause => Self::TokenPause,
            HederaFunctionality::TokenUnpause => Self::TokenUnpause,
            HederaFunctionality::CryptoApproveAllowance => Self::CryptoApproveAllowance,
            HederaFunctionality::CryptoDeleteAllowance => Self::CryptoDeleteAllowance,
            HederaFunctionality::GetAccountDetails => Self::GetAccountDetails,
            HederaFunctionality::EthereumTransaction => Self::EthereumTransaction,
            HederaFunctionality::NodeStakeUpdate => Self::NodeStakeUpdate,
            HederaFunctionality::UtilPrng => Self::UtilPrng,
            HederaFunctionality::TransactionGetFastRecord => Self::TransactionGetFastRecord,
            HederaFunctionality::TokenUpdateNfts => Self::TokenUpdateNfts,
            HederaFunctionality::NodeCreate => Self::NodeCreate,
            HederaFunctionality::NodeUpdate => Self::NodeUpdate,
            HederaFunctionality::NodeDelete => Self::NodeDelete,
            HederaFunctionality::TokenReject => Self::TokenReject,
            HederaFunctionality::TokenAirdrop => Self::TokenAirdrop,
            HederaFunctionality::TokenClaimAirdrop => Self::TokenClaimAirdrop,
            HederaFunctionality::TokenCancelAirdrop => Self::TokenCancelAirdrop,
            _ => todo!(),
        };

        Ok(value)
    }
}

impl ToProtobuf for RequestType {
    type Protobuf = services::HederaFunctionality;

    fn to_protobuf(&self) -> Self::Protobuf {
        use services::HederaFunctionality;
        match self {
            Self::None => HederaFunctionality::None,
            Self::CryptoTransfer => HederaFunctionality::CryptoTransfer,
            Self::CryptoUpdate => HederaFunctionality::CryptoUpdate,
            Self::CryptoDelete => HederaFunctionality::CryptoDelete,
            Self::CryptoAddLiveHash => HederaFunctionality::CryptoAddLiveHash,
            Self::CryptoDeleteLiveHash => HederaFunctionality::CryptoDeleteLiveHash,
            Self::ContractCall => HederaFunctionality::ContractCall,
            Self::ContractCreate => HederaFunctionality::ContractCreate,
            Self::ContractUpdate => HederaFunctionality::ContractUpdate,
            Self::FileCreate => HederaFunctionality::FileCreate,
            Self::FileAppend => HederaFunctionality::FileAppend,
            Self::FileUpdate => HederaFunctionality::FileUpdate,
            Self::FileDelete => HederaFunctionality::FileDelete,
            Self::CryptoGetAccountBalance => HederaFunctionality::CryptoGetAccountBalance,
            Self::CryptoGetAccountRecords => HederaFunctionality::CryptoGetAccountRecords,
            Self::CryptoGetInfo => HederaFunctionality::CryptoGetInfo,
            Self::ContractCallLocal => HederaFunctionality::ContractCallLocal,
            Self::ContractGetInfo => HederaFunctionality::ContractGetInfo,
            Self::ContractGetBytecode => HederaFunctionality::ContractGetBytecode,
            Self::GetBySolidityId => HederaFunctionality::GetBySolidityId,
            Self::GetByKey => HederaFunctionality::GetByKey,
            Self::CryptoGetLiveHash => HederaFunctionality::CryptoGetLiveHash,
            Self::CryptoGetStakers => HederaFunctionality::CryptoGetStakers,
            Self::FileGetContents => HederaFunctionality::FileGetContents,
            Self::FileGetInfo => HederaFunctionality::FileGetInfo,
            Self::TransactionGetRecord => HederaFunctionality::TransactionGetRecord,
            Self::ContractGetRecords => HederaFunctionality::ContractGetRecords,
            Self::CryptoCreate => HederaFunctionality::CryptoCreate,
            Self::SystemDelete => HederaFunctionality::SystemDelete,
            Self::SystemUndelete => HederaFunctionality::SystemUndelete,
            Self::ContractDelete => HederaFunctionality::ContractDelete,
            Self::Freeze => HederaFunctionality::Freeze,
            Self::CreateTransactionRecord => HederaFunctionality::CreateTransactionRecord,
            Self::CryptoAccountAutoRenew => HederaFunctionality::CryptoAccountAutoRenew,
            Self::ContractAutoRenew => HederaFunctionality::ContractAutoRenew,
            Self::GetVersionInfo => HederaFunctionality::GetVersionInfo,
            Self::TransactionGetReceipt => HederaFunctionality::TransactionGetReceipt,
            Self::ConsensusCreateTopic => HederaFunctionality::ConsensusCreateTopic,
            Self::ConsensusUpdateTopic => HederaFunctionality::ConsensusUpdateTopic,
            Self::ConsensusDeleteTopic => HederaFunctionality::ConsensusDeleteTopic,
            Self::ConsensusGetTopicInfo => HederaFunctionality::ConsensusGetTopicInfo,
            Self::ConsensusSubmitMessage => HederaFunctionality::ConsensusSubmitMessage,
            Self::UncheckedSubmit => HederaFunctionality::UncheckedSubmit,
            Self::TokenCreate => HederaFunctionality::TokenCreate,
            Self::TokenGetInfo => HederaFunctionality::TokenGetInfo,
            Self::TokenFreezeAccount => HederaFunctionality::TokenFreezeAccount,
            Self::TokenUnfreezeAccount => HederaFunctionality::TokenUnfreezeAccount,
            Self::TokenGrantKycToAccount => HederaFunctionality::TokenGrantKycToAccount,
            Self::TokenRevokeKycFromAccount => HederaFunctionality::TokenRevokeKycFromAccount,
            Self::TokenDelete => HederaFunctionality::TokenDelete,
            Self::TokenUpdate => HederaFunctionality::TokenUpdate,
            Self::TokenMint => HederaFunctionality::TokenMint,
            Self::TokenBurn => HederaFunctionality::TokenBurn,
            Self::TokenAccountWipe => HederaFunctionality::TokenAccountWipe,
            Self::TokenAssociateToAccount => HederaFunctionality::TokenAssociateToAccount,
            Self::TokenDissociateFromAccount => HederaFunctionality::TokenDissociateFromAccount,
            Self::ScheduleCreate => HederaFunctionality::ScheduleCreate,
            Self::ScheduleDelete => HederaFunctionality::ScheduleDelete,
            Self::ScheduleSign => HederaFunctionality::ScheduleSign,
            Self::ScheduleGetInfo => HederaFunctionality::ScheduleGetInfo,
            Self::TokenGetAccountNftInfos => HederaFunctionality::TokenGetAccountNftInfos,
            Self::TokenGetNftInfo => HederaFunctionality::TokenGetNftInfo,
            Self::TokenGetNftInfos => HederaFunctionality::TokenGetNftInfos,
            Self::TokenFeeScheduleUpdate => HederaFunctionality::TokenFeeScheduleUpdate,
            Self::NetworkGetExecutionTime => HederaFunctionality::NetworkGetExecutionTime,
            Self::TokenPause => HederaFunctionality::TokenPause,
            Self::TokenUnpause => HederaFunctionality::TokenUnpause,
            Self::CryptoApproveAllowance => HederaFunctionality::CryptoApproveAllowance,
            Self::CryptoDeleteAllowance => HederaFunctionality::CryptoDeleteAllowance,
            Self::GetAccountDetails => HederaFunctionality::GetAccountDetails,
            Self::EthereumTransaction => HederaFunctionality::EthereumTransaction,
            Self::NodeStakeUpdate => HederaFunctionality::NodeStakeUpdate,
            Self::UtilPrng => HederaFunctionality::UtilPrng,
            Self::TransactionGetFastRecord => HederaFunctionality::TransactionGetFastRecord,
            Self::TokenUpdateNfts => HederaFunctionality::TokenUpdateNfts,
            Self::NodeCreate => HederaFunctionality::NodeCreate,
            Self::NodeUpdate => HederaFunctionality::NodeUpdate,
            Self::NodeDelete => HederaFunctionality::NodeDelete,
            Self::TokenReject => HederaFunctionality::TokenReject,
            Self::TokenAirdrop => HederaFunctionality::TokenAirdrop,
            Self::TokenClaimAirdrop => HederaFunctionality::TokenClaimAirdrop,
            Self::TokenCancelAirdrop => HederaFunctionality::TokenCancelAirdrop,
        }
    }
}

/// The total fees charged for a transaction, consisting of 3 parts:
/// The node fee, the network fee, and the service fee.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct FeeData {
    /// Fee charged by the node for this functionality.
    pub node: FeeComponents,

    /// Fee charged by Hiero for network operations.
    pub network: FeeComponents,

    /// Fee charged by Hiero for providing the service.
    pub service: FeeComponents,

    /// A subtype distinguishing between different types of fee data
    /// correlating to the same hedera functionality.
    pub kind: FeeDataType,
}

impl FeeData {
    /// Create a new `FeeData` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::FeeData> for FeeData {
    fn from_protobuf(pb: services::FeeData) -> crate::Result<Self> {
        Ok(Self {
            node: FeeComponents::from_protobuf(pb_getf!(pb, nodedata)?)?,
            network: FeeComponents::from_protobuf(pb_getf!(pb, networkdata)?)?,
            service: FeeComponents::from_protobuf(pb_getf!(pb, servicedata)?)?,
            kind: FeeDataType::from_protobuf(pb.sub_type())?,
        })
    }
}

impl ToProtobuf for FeeData {
    type Protobuf = services::FeeData;
    fn to_protobuf(&self) -> Self::Protobuf {
        services::FeeData {
            nodedata: Some(self.node.to_protobuf()),
            networkdata: Some(self.network.to_protobuf()),
            servicedata: Some(self.service.to_protobuf()),
            sub_type: self.kind.to_protobuf() as i32,
        }
    }
}

/// The different components used for fee calculation.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct FeeComponents {
    /// The minimum fee that needs to be paid.
    pub min: u64,

    /// The maximum fee that can be submitted.
    pub max: u64,

    /// A constant determined by the business to calculate the fee.
    pub constant: u64,

    /// The cost of each byte in a transaction.
    pub bandwidth_byte: u64,

    /// The cost of each signature in a transaction.
    pub verification: u64,

    /// Cost of storage measured in byte-hours.
    pub storage_byte_hour: u64,

    /// Cost of memory measured in byte-hours.
    pub ram_byte_hour: u64,

    /// Price of gas.
    pub contract_transaction_gas: u64,

    /// Cost per hbar transfered.
    ///
    /// fee = `floor(transfer_value in tinybars / (transfer_volume_hbar / 1000))`
    pub transfer_volume_hbar: u64,

    /// The price per byte of bandwidth spent for data retrieved from memory for a response.
    pub response_memory_byte: u64,

    /// The price per byte of bandwidth spent for data retrieved from disk for a response.
    pub response_disk_byte: u64,
}

impl FeeComponents {
    /// Create a new `FeeComponents` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::FeeComponents> for FeeComponents {
    fn from_protobuf(pb: services::FeeComponents) -> crate::Result<Self> {
        Ok(Self {
            min: pb.min as u64,
            max: pb.max as u64,
            constant: pb.constant as u64,
            bandwidth_byte: pb.bpt as u64,
            verification: pb.vpt as u64,
            storage_byte_hour: pb.sbh as u64,
            ram_byte_hour: pb.rbh as u64,
            contract_transaction_gas: pb.gas as u64,
            transfer_volume_hbar: pb.tv as u64,
            response_memory_byte: pb.bpr as u64,
            response_disk_byte: pb.sbpr as u64,
        })
    }
}

impl ToProtobuf for FeeComponents {
    type Protobuf = services::FeeComponents;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::FeeComponents {
            min: self.min as i64,
            max: self.max as i64,
            constant: self.constant as i64,
            bpt: self.bandwidth_byte as i64,
            vpt: self.verification as i64,
            rbh: self.ram_byte_hour as i64,
            sbh: self.storage_byte_hour as i64,
            gas: self.contract_transaction_gas as i64,
            tv: self.transfer_volume_hbar as i64,
            bpr: self.response_memory_byte as i64,
            sbpr: self.storage_byte_hour as i64,
        }
    }
}

/// Possible [`FeeData`] subtypes.
#[derive(Debug, Clone, Eq, PartialEq)]
#[non_exhaustive]
pub enum FeeDataType {
    /// The resource prices have no special scope.
    Default,

    /// The resource prices are scoped to an operation on a fungible token.
    TokenFungibleCommon,

    /// The resource prices are scoped to an operation on a non-fungible token.
    TokenNonFungibleUnique,

    /// The resource prices are scoped to an operation on a fungible token with a custom fee schedule.
    TokenFungibleCommonWithCustomFees,

    /// The resource prices are scoped to an operation on a non-fungible token with a custom fee schedule.
    TokenNonFungibleUniqueWithCustomFees,

    /// The resource prices are scoped to a [`ScheduleCreateTransaction`](crate::ScheduleCreateTransaction)
    /// containing a [`ContractExecuteTransaction`](crate::ContractExecuteTransaction).
    ScheduleCreateContractCall,

    /// The resource prices are scoped to a [`TopicCreateTransaction`](crate::TopicCreateTransaction)
    /// with a custom fee schedule.
    TopicCreateWithCustomFees,
}

impl FromProtobuf<services::SubType> for FeeDataType {
    fn from_protobuf(pb: services::SubType) -> crate::Result<Self> {
        use services::SubType;
        let value = match pb {
            SubType::Default => Self::Default,
            SubType::TokenFungibleCommon => Self::TokenFungibleCommon,
            SubType::TokenNonFungibleUnique => Self::TokenNonFungibleUnique,
            SubType::TokenFungibleCommonWithCustomFees => Self::TokenFungibleCommonWithCustomFees,
            SubType::TokenNonFungibleUniqueWithCustomFees => {
                Self::TokenNonFungibleUniqueWithCustomFees
            }
            SubType::ScheduleCreateContractCall => Self::ScheduleCreateContractCall,
            SubType::TopicCreateWithCustomFees => Self::TopicCreateWithCustomFees,
        };

        Ok(value)
    }
}

impl ToProtobuf for FeeDataType {
    type Protobuf = services::SubType;

    fn to_protobuf(&self) -> Self::Protobuf {
        use services::SubType;
        match self {
            Self::Default => SubType::Default,
            Self::TokenFungibleCommon => SubType::TokenFungibleCommon,
            Self::TokenNonFungibleUnique => SubType::TokenNonFungibleUnique,
            Self::TokenFungibleCommonWithCustomFees => SubType::TokenFungibleCommonWithCustomFees,
            Self::TokenNonFungibleUniqueWithCustomFees => {
                SubType::TokenNonFungibleUniqueWithCustomFees
            }
            Self::ScheduleCreateContractCall => SubType::ScheduleCreateContractCall,
            Self::TopicCreateWithCustomFees => SubType::TopicCreateWithCustomFees,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use time::OffsetDateTime;

    use crate::protobuf::ToProtobuf;
    use crate::{
        FeeComponents,
        FeeData,
        FeeSchedule,
        FeeSchedules,
        TransactionFeeSchedule,
    };

    const ZERO_FEES: FeeComponents = FeeComponents {
        min: 0,
        max: 0,
        constant: 0,
        bandwidth_byte: 0,
        verification: 0,
        storage_byte_hour: 0,
        ram_byte_hour: 0,
        contract_transaction_gas: 0,
        transfer_volume_hbar: 0,
        response_memory_byte: 0,
        response_disk_byte: 0,
    };

    fn make_fee_schedules() -> FeeSchedules {
        #[allow(deprecated)]
        FeeSchedules {
            current: Some(FeeSchedule {
                transaction_fee_schedules: Vec::from([TransactionFeeSchedule {
                    request_type: crate::RequestType::None,
                    fee_data: None,
                    fees: Vec::from([FeeData {
                        node: ZERO_FEES,
                        network: FeeComponents { min: 2, max: 5, ..ZERO_FEES },
                        service: ZERO_FEES,
                        kind: crate::FeeDataType::Default,
                    }]),
                }]),
                expiration_time: OffsetDateTime::from_unix_timestamp(1554158542).unwrap(),
            }),
            next: Some(FeeSchedule {
                transaction_fee_schedules: Vec::from([TransactionFeeSchedule {
                    request_type: crate::RequestType::None,
                    fee_data: None,
                    fees: Vec::from([FeeData {
                        node: FeeComponents { min: 1, max: 2, ..ZERO_FEES },
                        network: ZERO_FEES,
                        service: ZERO_FEES,
                        kind: crate::FeeDataType::Default,
                    }]),
                }]),
                expiration_time: OffsetDateTime::from_unix_timestamp(1554158222).unwrap(),
            }),
        }
    }

    #[test]
    fn serialize() {
        let schedules = make_fee_schedules();

        expect![[r#"
            CurrentAndNextFeeSchedule {
                current_fee_schedule: Some(
                    FeeSchedule {
                        transaction_fee_schedule: [
                            TransactionFeeSchedule {
                                hedera_functionality: None,
                                fee_data: None,
                                fees: [
                                    FeeData {
                                        nodedata: Some(
                                            FeeComponents {
                                                min: 0,
                                                max: 0,
                                                constant: 0,
                                                bpt: 0,
                                                vpt: 0,
                                                rbh: 0,
                                                sbh: 0,
                                                gas: 0,
                                                tv: 0,
                                                bpr: 0,
                                                sbpr: 0,
                                            },
                                        ),
                                        networkdata: Some(
                                            FeeComponents {
                                                min: 2,
                                                max: 5,
                                                constant: 0,
                                                bpt: 0,
                                                vpt: 0,
                                                rbh: 0,
                                                sbh: 0,
                                                gas: 0,
                                                tv: 0,
                                                bpr: 0,
                                                sbpr: 0,
                                            },
                                        ),
                                        servicedata: Some(
                                            FeeComponents {
                                                min: 0,
                                                max: 0,
                                                constant: 0,
                                                bpt: 0,
                                                vpt: 0,
                                                rbh: 0,
                                                sbh: 0,
                                                gas: 0,
                                                tv: 0,
                                                bpr: 0,
                                                sbpr: 0,
                                            },
                                        ),
                                        sub_type: Default,
                                    },
                                ],
                            },
                        ],
                        expiry_time: Some(
                            TimestampSeconds {
                                seconds: 1554158542,
                            },
                        ),
                    },
                ),
                next_fee_schedule: Some(
                    FeeSchedule {
                        transaction_fee_schedule: [
                            TransactionFeeSchedule {
                                hedera_functionality: None,
                                fee_data: None,
                                fees: [
                                    FeeData {
                                        nodedata: Some(
                                            FeeComponents {
                                                min: 1,
                                                max: 2,
                                                constant: 0,
                                                bpt: 0,
                                                vpt: 0,
                                                rbh: 0,
                                                sbh: 0,
                                                gas: 0,
                                                tv: 0,
                                                bpr: 0,
                                                sbpr: 0,
                                            },
                                        ),
                                        networkdata: Some(
                                            FeeComponents {
                                                min: 0,
                                                max: 0,
                                                constant: 0,
                                                bpt: 0,
                                                vpt: 0,
                                                rbh: 0,
                                                sbh: 0,
                                                gas: 0,
                                                tv: 0,
                                                bpr: 0,
                                                sbpr: 0,
                                            },
                                        ),
                                        servicedata: Some(
                                            FeeComponents {
                                                min: 0,
                                                max: 0,
                                                constant: 0,
                                                bpt: 0,
                                                vpt: 0,
                                                rbh: 0,
                                                sbh: 0,
                                                gas: 0,
                                                tv: 0,
                                                bpr: 0,
                                                sbpr: 0,
                                            },
                                        ),
                                        sub_type: Default,
                                    },
                                ],
                            },
                        ],
                        expiry_time: Some(
                            TimestampSeconds {
                                seconds: 1554158222,
                            },
                        ),
                    },
                ),
            }
        "#]]
        .assert_debug_eq(&schedules.to_protobuf());
    }

    #[test]
    fn to_from_bytes() {
        let a = make_fee_schedules();
        let b = FeeSchedules::from_bytes(&a.to_bytes()).unwrap();

        assert_eq!(a, b);
    }

    #[test]
    fn serialize_default() {
        let schedules = FeeSchedules { current: None, next: None };
        expect![[r#"
            CurrentAndNextFeeSchedule {
                current_fee_schedule: None,
                next_fee_schedule: None,
            }
        "#]]
        .assert_debug_eq(&schedules.to_protobuf());
    }

    #[test]
    fn to_from_bytes_default() {
        let a = FeeSchedules { current: None, next: None };
        let b = FeeSchedules::from_bytes(&a.to_bytes()).unwrap();

        assert_eq!(a, b);
    }
}
// Filename: src/file/file_append_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use std::cmp;
use std::num::NonZeroUsize;

use hedera_proto::services;
use hedera_proto::services::file_service_client::FileServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkData,
    ChunkInfo,
    ChunkedTransactionData,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
    TransactionExecuteChunked,
};
use crate::{
    BoxGrpcFuture,
    Error,
    FileId,
    Transaction,
    ValidateChecksums,
};

/// Append the given contents to the end of the specified file.
///
pub type FileAppendTransaction = Transaction<FileAppendTransactionData>;

#[derive(Debug, Clone)]
pub struct FileAppendTransactionData {
    /// The file to which the bytes will be appended.
    file_id: Option<FileId>,

    chunk_data: ChunkData,
}

impl Default for FileAppendTransactionData {
    fn default() -> Self {
        Self {
            file_id: None,
            chunk_data: ChunkData {
                chunk_size: NonZeroUsize::new(4096).unwrap(),
                ..Default::default()
            },
        }
    }
}
impl FileAppendTransaction {
    /// Returns the file to which the bytes will be appended.
    #[must_use]
    pub fn get_file_id(&self) -> Option<FileId> {
        self.data().file_id
    }

    /// Sets the file to which the bytes will be appended.
    pub fn file_id(&mut self, id: impl Into<FileId>) -> &mut Self {
        self.data_mut().file_id = Some(id.into());
        self
    }

    /// Retuns the bytes that will be appended to the end of the specified file.
    pub fn get_contents(&self) -> Option<&[u8]> {
        Some(self.data().chunk_data.data.as_slice())
    }

    /// Sets the bytes that will be appended to the end of the specified file.
    pub fn contents(&mut self, contents: impl Into<Vec<u8>>) -> &mut Self {
        self.data_mut().chunk_data.data = contents.into();
        self
    }
}

impl TransactionData for FileAppendTransactionData {
    fn default_max_transaction_fee(&self) -> crate::Hbar {
        crate::Hbar::new(5)
    }

    fn maybe_chunk_data(&self) -> Option<&ChunkData> {
        Some(self.chunk_data())
    }

    fn wait_for_receipt(&self) -> bool {
        true
    }
}

impl ChunkedTransactionData for FileAppendTransactionData {
    fn chunk_data(&self) -> &ChunkData {
        &self.chunk_data
    }

    fn chunk_data_mut(&mut self) -> &mut ChunkData {
        &mut self.chunk_data
    }
}

impl TransactionExecute for FileAppendTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { FileServiceClient::new(channel).append_content(request).await })
    }
}

impl TransactionExecuteChunked for FileAppendTransactionData {}

impl ValidateChecksums for FileAppendTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.file_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for FileAppendTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        services::transaction_body::Data::FileAppend(services::FileAppendTransactionBody {
            file_id: self.file_id.to_protobuf(),
            contents: self.chunk_data.message_chunk(chunk_info).to_vec(),
        })
    }
}

impl ToSchedulableTransactionDataProtobuf for FileAppendTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        assert!(self.chunk_data.used_chunks() == 1);

        services::schedulable_transaction_body::Data::FileAppend(
            services::FileAppendTransactionBody {
                file_id: self.file_id.to_protobuf(),
                contents: self.chunk_data.data.clone(),
            },
        )
    }
}

impl From<FileAppendTransactionData> for AnyTransactionData {
    fn from(transaction: FileAppendTransactionData) -> Self {
        Self::FileAppend(transaction)
    }
}

impl FromProtobuf<services::FileAppendTransactionBody> for FileAppendTransactionData {
    fn from_protobuf(pb: services::FileAppendTransactionBody) -> crate::Result<Self> {
        Self::from_protobuf(Vec::from([pb]))
    }
}

impl FromProtobuf<Vec<services::FileAppendTransactionBody>> for FileAppendTransactionData {
    fn from_protobuf(pb: Vec<services::FileAppendTransactionBody>) -> crate::Result<Self> {
        let total_chunks = pb.len();

        let mut iter = pb.into_iter();
        let pb_first = iter.next().expect("Empty transaction (should've been handled earlier)");

        let file_id = Option::from_protobuf(pb_first.file_id)?;

        let mut largest_chunk_size = pb_first.contents.len();
        let mut contents = pb_first.contents;

        // note: no other SDK checks for correctness here... so let's not do it here either?

        for item in iter {
            largest_chunk_size = cmp::max(largest_chunk_size, item.contents.len());
            contents.extend_from_slice(&item.contents);
        }

        Ok(Self {
            file_id,
            chunk_data: ChunkData {
                max_chunks: total_chunks,
                chunk_size: NonZeroUsize::new(largest_chunk_size)
                    .unwrap_or_else(|| NonZeroUsize::new(1).unwrap()),
                data: contents,
            },
        })
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::transaction::test_helpers::{
        check_body,
        transaction_bodies,
    };
    use crate::{
        AnyTransaction,
        FileAppendTransaction,
        FileId,
    };

    const FILE_ID: FileId = FileId::new(0, 0, 10);

    const CONTENTS: &[u8] = br#"{"foo": 231}"#;

    fn make_transaction() -> FileAppendTransaction {
        let mut tx = FileAppendTransaction::new_for_tests();
        tx.file_id(FILE_ID).contents(CONTENTS).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        // unlike most transactions we *do* need to do this like in case it's chunked.
        // granted, trying to do anything with a chunked transaction without a Client is hard.
        let txes = transaction_bodies(tx);

        // this is kinda a mess... But it works.
        let txes: Vec<_> = txes.into_iter().map(check_body).collect();

        expect![[r#"
            [
                FileAppend(
                    FileAppendTransactionBody {
                        file_id: Some(
                            FileId {
                                shard_num: 0,
                                realm_num: 0,
                                file_num: 10,
                            },
                        ),
                        contents: [
                            123,
                            34,
                            102,
                            111,
                            111,
                            34,
                            58,
                            32,
                            50,
                            51,
                            49,
                            125,
                        ],
                    },
                ),
                FileAppend(
                    FileAppendTransactionBody {
                        file_id: Some(
                            FileId {
                                shard_num: 0,
                                realm_num: 0,
                                file_num: 10,
                            },
                        ),
                        contents: [
                            123,
                            34,
                            102,
                            111,
                            111,
                            34,
                            58,
                            32,
                            50,
                            51,
                            49,
                            125,
                        ],
                    },
                ),
            ]
        "#]]
        .assert_debug_eq(&txes);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_bodies(tx);
        let tx2 = transaction_bodies(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn get_set_file_id() {
        let mut tx = FileAppendTransaction::new();
        tx.file_id(FILE_ID);

        assert_eq!(tx.get_file_id(), Some(FILE_ID));
    }

    #[test]
    fn get_set_contents() {
        let mut tx = FileAppendTransaction::new();
        tx.contents(CONTENTS);

        assert_eq!(tx.get_contents(), Some(CONTENTS));
    }

    #[test]
    #[should_panic]
    fn get_set_file_id_frozen_panics() {
        let mut tx = make_transaction();
        tx.file_id(FILE_ID);
    }

    #[test]
    #[should_panic]
    fn get_set_contents_frozen_panics() {
        let mut tx = make_transaction();
        tx.contents(CONTENTS);
    }
}
// Filename: src/file/file_contents_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::file_service_client::FileServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    Query,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    Error,
    FileContentsResponse,
    FileId,
    ToProtobuf,
    ValidateChecksums,
};

/// Get the contents of a file.
pub type FileContentsQuery = Query<FileContentsQueryData>;

#[derive(Clone, Default, Debug)]
pub struct FileContentsQueryData {
    /// The file ID for which contents are requested.
    file_id: Option<FileId>,
}

impl From<FileContentsQueryData> for AnyQueryData {
    #[inline]
    fn from(data: FileContentsQueryData) -> Self {
        Self::FileContents(data)
    }
}

impl FileContentsQuery {
    /// Returns the ID of the file for which contents are requested.
    #[must_use]
    pub fn get_file_id(&self) -> Option<FileId> {
        self.data.file_id
    }

    /// Sets the file ID for which contents are requested.
    pub fn file_id(&mut self, id: impl Into<FileId>) -> &mut Self {
        self.data.file_id = Some(id.into());
        self
    }
}

impl ToQueryProtobuf for FileContentsQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        services::Query {
            query: Some(services::query::Query::FileGetContents(services::FileGetContentsQuery {
                header: Some(header),
                file_id: self.file_id.to_protobuf(),
            })),
        }
    }
}

impl QueryExecute for FileContentsQueryData {
    type Response = FileContentsResponse;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { FileServiceClient::new(channel).get_file_content(request).await })
    }
}

impl ValidateChecksums for FileContentsQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.file_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        FileContentsQuery,
        FileId,
        Hbar,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    FileGetContents(
                        FileGetContentsQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            file_id: Some(
                                FileId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    file_num: 5005,
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &FileContentsQuery::new()
                .file_id(FileId::new(0, 0, 5005))
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        );
    }

    #[test]
    fn get_set_file_id() {
        let mut query = FileContentsQuery::new();
        query.file_id(FileId::new(0, 0, 5005));

        assert_eq!(query.get_file_id(), Some(FileId::new(0, 0, 5005)));
    }
}
// Filename: src/file/file_contents_response.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use crate::{
    FileId,
    FromProtobuf,
};

/// Response from [`FileContentsQuery`][crate::FileContentsQuery].
#[derive(Debug, Clone)]
pub struct FileContentsResponse {
    /// The file ID of the file whose contents are being returned.
    pub file_id: FileId,

    // TODO: .contents vs .bytes (?)
    /// The bytes contained in the file.
    pub contents: Vec<u8>,
}

impl FromProtobuf<services::response::Response> for FileContentsResponse {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let pb = pb_getv!(pb, FileGetContents, services::response::Response);
        let file_contents = pb_getf!(pb, file_contents)?;
        let file_id = pb_getf!(file_contents, file_id)?;

        let contents = file_contents.contents;
        let file_id = FileId::from_protobuf(file_id)?;

        Ok(Self { file_id, contents })
    }
}
// Filename: src/file/file_create_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::file_service_client::FileServiceClient;
use time::{
    Duration,
    OffsetDateTime,
};
use tonic::transport::Channel;

use crate::entity_id::ValidateChecksums;
use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Key,
    KeyList,
    Transaction,
};

/// Create a new file, containing the given contents.
pub type FileCreateTransaction = Transaction<FileCreateTransactionData>;

#[derive(Debug, Clone)]
pub struct FileCreateTransactionData {
    /// The memo associated with the file.
    file_memo: String,

    /// All keys at the top level of a key list must sign to create or
    /// modify the file. Any one of the keys at the top level key list
    /// can sign to delete the file.
    keys: Option<KeyList>,

    /// The bytes that are to be the contents of the file.
    contents: Option<Vec<u8>>,

    auto_renew_period: Option<Duration>,

    auto_renew_account_id: Option<AccountId>,

    /// The time at which this file should expire.
    expiration_time: Option<OffsetDateTime>,
}

impl Default for FileCreateTransactionData {
    fn default() -> Self {
        Self {
            file_memo: String::new(),
            keys: None,
            contents: None,
            auto_renew_period: None,
            auto_renew_account_id: None,
            expiration_time: Some(OffsetDateTime::now_utc() + Duration::days(90)),
        }
    }
}

impl FileCreateTransaction {
    /// Returns the memo to be associated with the file.
    #[must_use]
    pub fn get_file_memo(&self) -> &str {
        &self.data().file_memo
    }

    /// Sets the memo associated with the file.
    pub fn file_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().file_memo = memo.into();
        self
    }

    /// Returns the bytes that are to be the contents of the file.
    #[must_use]
    pub fn get_contents(&self) -> Option<&[u8]> {
        self.data().contents.as_deref()
    }

    /// Sets the bytes that are to be the contents of the file.
    pub fn contents(&mut self, contents: impl Into<Vec<u8>>) -> &mut Self {
        self.data_mut().contents = Some(contents.into());
        self
    }

    /// Returns the keys for this file.
    #[must_use]
    pub fn get_keys(&self) -> Option<&KeyList> {
        self.data().keys.as_ref()
    }

    /// Sets the keys for this file.
    ///
    /// All keys at the top level of a key list must sign to create or
    /// modify the file. Any one of the keys at the top level key list
    /// can sign to delete the file.
    pub fn keys<K: Into<Key>>(&mut self, keys: impl IntoIterator<Item = K>) -> &mut Self {
        self.data_mut().keys = Some(keys.into_iter().map(Into::into).collect());
        self
    }

    /// Returns the auto renew period for this file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.data().auto_renew_period
    }

    /// Sets the auto renew period for this file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    pub fn auto_renew_period(&mut self, duration: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = Some(duration);
        self
    }

    /// Returns the account to be used at the file's expiration time to extend the
    /// life of the file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the account to be used at the files's expiration time to extend the
    /// life of the file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    pub fn auto_renew_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(id);
        self
    }

    /// Returns the time at which this file should expire.
    #[must_use]
    pub fn get_expiration_time(&self) -> Option<OffsetDateTime> {
        self.data().expiration_time
    }

    /// Sets the time at which this file should expire.
    pub fn expiration_time(&mut self, at: OffsetDateTime) -> &mut Self {
        self.require_not_frozen();
        self.data_mut().expiration_time = Some(at);
        self
    }
}

impl TransactionData for FileCreateTransactionData {
    fn default_max_transaction_fee(&self) -> crate::Hbar {
        crate::Hbar::new(5)
    }
}

impl TransactionExecute for FileCreateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { FileServiceClient::new(channel).create_file(request).await })
    }
}

impl ValidateChecksums for FileCreateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> crate::Result<()> {
        self.auto_renew_account_id.validate_checksums(ledger_id)?;

        Ok(())
    }
}

impl ToTransactionDataProtobuf for FileCreateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::FileCreate(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for FileCreateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::FileCreate(self.to_protobuf())
    }
}

impl From<FileCreateTransactionData> for AnyTransactionData {
    fn from(transaction: FileCreateTransactionData) -> Self {
        Self::FileCreate(transaction)
    }
}

impl FromProtobuf<services::FileCreateTransactionBody> for FileCreateTransactionData {
    fn from_protobuf(pb: services::FileCreateTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            file_memo: pb.memo,
            keys: Option::from_protobuf(pb.keys)?,
            contents: Some(pb.contents),
            auto_renew_period: None,
            auto_renew_account_id: None,
            expiration_time: pb.expiration_time.map(Into::into),
        })
    }
}

impl ToProtobuf for FileCreateTransactionData {
    type Protobuf = services::FileCreateTransactionBody;

    #[allow(deprecated)]
    fn to_protobuf(&self) -> Self::Protobuf {
        services::FileCreateTransactionBody {
            expiration_time: self.expiration_time.to_protobuf(),
            keys: self.keys.to_protobuf(),
            contents: self.contents.clone().unwrap_or_default(),
            shard_id: None,
            realm_id: None,
            new_realm_admin_key: None,
            memo: self.file_memo.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use hex_literal::hex;
    use time::OffsetDateTime;

    use crate::file::FileCreateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
    };
    use crate::{
        AnyTransaction,
        FileCreateTransaction,
        Key,
        KeyList,
    };

    const CONTENTS: [u8; 4] = hex!("deadbeef");

    const EXPIRATION_TIME: OffsetDateTime = match OffsetDateTime::from_unix_timestamp(1554158728) {
        Ok(it) => it,
        Err(_) => panic!("Panic in `const` unwrap"),
    };

    fn keys() -> impl IntoIterator<Item = Key> {
        [unused_private_key().public_key().into()]
    }

    const FILE_MEMO: &str = "Hello memo";

    fn make_transaction() -> FileCreateTransaction {
        let mut tx = FileCreateTransaction::new_for_tests();

        tx.contents(CONTENTS)
            .expiration_time(EXPIRATION_TIME)
            .keys(keys())
            .file_memo(FILE_MEMO)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            FileCreate(
                FileCreateTransactionBody {
                    expiration_time: Some(
                        Timestamp {
                            seconds: 1554158728,
                            nanos: 0,
                        },
                    ),
                    keys: Some(
                        KeyList {
                            keys: [
                                Key {
                                    key: Some(
                                        Ed25519(
                                            [
                                                224,
                                                200,
                                                236,
                                                39,
                                                88,
                                                165,
                                                135,
                                                159,
                                                250,
                                                194,
                                                38,
                                                161,
                                                60,
                                                12,
                                                81,
                                                107,
                                                121,
                                                158,
                                                114,
                                                227,
                                                81,
                                                65,
                                                160,
                                                221,
                                                130,
                                                143,
                                                148,
                                                211,
                                                121,
                                                136,
                                                164,
                                                183,
                                            ],
                                        ),
                                    ),
                                },
                            ],
                        },
                    ),
                    contents: [
                        222,
                        173,
                        190,
                        239,
                    ],
                    shard_id: None,
                    realm_id: None,
                    new_realm_admin_key: None,
                    memo: "Hello memo",
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        #[allow(deprecated)]
        let tx = services::FileCreateTransactionBody {
            expiration_time: Some(EXPIRATION_TIME.to_protobuf()),
            keys: Some(KeyList::from_iter(keys()).to_protobuf()),
            contents: CONTENTS.into(),
            memo: FILE_MEMO.to_owned(),
            shard_id: None,
            realm_id: None,
            new_realm_admin_key: None,
        };

        let tx = FileCreateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.contents.as_deref(), Some(CONTENTS.as_slice()));
        assert_eq!(tx.expiration_time, Some(EXPIRATION_TIME));
        assert_eq!(tx.keys, Some(KeyList::from_iter(keys())));
        assert_eq!(tx.file_memo, FILE_MEMO);
    }

    mod get_set {
        use super::*;

        #[test]
        fn contents() {
            let mut tx = FileCreateTransaction::new();
            tx.contents(CONTENTS);

            assert_eq!(tx.get_contents(), Some(CONTENTS.as_slice()));
        }

        #[test]
        #[should_panic]
        fn contents_frozen_panics() {
            make_transaction().contents(CONTENTS);
        }

        #[test]
        fn expiration_time() {
            let mut tx = FileCreateTransaction::new();
            tx.expiration_time(EXPIRATION_TIME);

            assert_eq!(tx.get_expiration_time(), Some(EXPIRATION_TIME));
        }

        #[test]
        #[should_panic]
        fn expiration_time_frozen_panics() {
            make_transaction().expiration_time(EXPIRATION_TIME);
        }

        #[test]
        fn keys() {
            let mut tx = FileCreateTransaction::new();
            tx.keys(super::keys());

            assert_eq!(tx.get_keys(), Some(&KeyList::from_iter(super::keys())));
        }

        #[test]
        #[should_panic]
        fn keys_frozen_panics() {
            make_transaction().keys(super::keys());
        }

        #[test]
        fn file_memo() {
            let mut tx = FileCreateTransaction::new();
            tx.file_memo(FILE_MEMO);

            assert_eq!(tx.get_file_memo(), FILE_MEMO);
        }

        #[test]
        #[should_panic]
        fn file_memo_frozen_panics() {
            make_transaction().file_memo(FILE_MEMO);
        }
    }
}
// Filename: src/file/file_delete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::file_service_client::FileServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    FileId,
    Transaction,
    ValidateChecksums,
};

/// Delete the given file.
///
/// After deletion, it will be marked as deleted and will have no contents.
/// Information about it will continue to exist until it expires.
///
pub type FileDeleteTransaction = Transaction<FileDeleteTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct FileDeleteTransactionData {
    /// The file to delete. It will be marked as deleted until it expires.
    /// Then it will disappear.
    file_id: Option<FileId>,
}

impl FileDeleteTransaction {
    /// Returns the ID of the file to be deleted.
    #[must_use]
    pub fn get_file_id(&self) -> Option<FileId> {
        self.data().file_id
    }

    /// Sets the ID of the file to be deleted.
    pub fn file_id(&mut self, id: impl Into<FileId>) -> &mut Self {
        self.data_mut().file_id = Some(id.into());
        self
    }
}

impl TransactionData for FileDeleteTransactionData {}

impl TransactionExecute for FileDeleteTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { FileServiceClient::new(channel).delete_file(request).await })
    }
}

impl ValidateChecksums for FileDeleteTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.file_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for FileDeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::FileDelete(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for FileDeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::FileDelete(self.to_protobuf())
    }
}

impl From<FileDeleteTransactionData> for AnyTransactionData {
    fn from(transaction: FileDeleteTransactionData) -> Self {
        Self::FileDelete(transaction)
    }
}

impl FromProtobuf<services::FileDeleteTransactionBody> for FileDeleteTransactionData {
    fn from_protobuf(pb: services::FileDeleteTransactionBody) -> crate::Result<Self> {
        Ok(Self { file_id: Option::from_protobuf(pb.file_id)? })
    }
}

impl ToProtobuf for FileDeleteTransactionData {
    type Protobuf = services::FileDeleteTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::FileDeleteTransactionBody { file_id: self.file_id.to_protobuf() }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::file::FileDeleteTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        FileDeleteTransaction,
        FileId,
    };

    const FILE_ID: FileId = FileId::new(0, 0, 6006);

    fn make_transaction() -> FileDeleteTransaction {
        let mut tx = FileDeleteTransaction::new_for_tests();

        tx.file_id(FILE_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            FileDelete(
                FileDeleteTransactionBody {
                    file_id: Some(
                        FileId {
                            shard_num: 0,
                            realm_num: 0,
                            file_num: 6006,
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::FileDeleteTransactionBody { file_id: Some(FILE_ID.to_protobuf()) };

        let tx = FileDeleteTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.file_id, Some(FILE_ID));
    }

    #[test]
    fn get_set_file_id() {
        let mut tx = FileDeleteTransaction::new();
        tx.file_id(FILE_ID);

        assert_eq!(tx.get_file_id(), Some(FILE_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_file_id_frozen_panics() {
        make_transaction().file_id(FILE_ID);
    }
}
// Filename: src/file/file_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use hedera_proto::services;

use crate::entity_id::{
    Checksum,
    ValidateChecksums,
};
use crate::ledger_id::RefLedgerId;
use crate::{
    Client,
    EntityId,
    Error,
    FromProtobuf,
    ToProtobuf,
};

/// The unique identifier for a file on Hiero.
#[derive(Hash, PartialEq, Eq, Clone, Copy)]
pub struct FileId {
    /// The shard number.
    pub shard: u64,

    /// The realm number.
    pub realm: u64,

    /// The file number.
    pub num: u64,

    /// A checksum if the file ID was read from a user inputted string which inclueded a checksum
    pub checksum: Option<Checksum>,
}

impl FileId {
    /// Address of the public [node address book](crate::NodeAddressBook) for the current network.
    pub const ADDRESS_BOOK: Self = Self::new(0, 0, 102);

    /// Address of the current fee schedule for the network.
    pub const FEE_SCHEDULE: Self = Self::new(0, 0, 111);

    /// Address of the [current exchange rate](crate::ExchangeRates) of HBAR to USD.
    pub const EXCHANGE_RATES: Self = Self::new(0, 0, 112);

    /// Create a `FileId` with the given `shard.realm.num`.
    pub const fn new(shard: u64, realm: u64, num: u64) -> Self {
        Self { shard, realm, num, checksum: None }
    }

    /// Create a new `FileId` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Create a `FileId` from a solidity address.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `address` cannot be parsed as a solidity address.
    pub fn from_solidity_address(address: &str) -> crate::Result<Self> {
        let EntityId { shard, realm, num, checksum } = EntityId::from_solidity_address(address)?;

        Ok(Self { shard, realm, num, checksum })
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }

    /// Convert `self` into a solidity `address`
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `self.shard` is larger than `u32::MAX`.
    pub fn to_solidity_address(&self) -> crate::Result<String> {
        EntityId { shard: self.shard, realm: self.realm, num: self.num, checksum: None }
            .to_solidity_address()
    }

    /// Convert `self` to a string with a valid checksum.
    #[must_use]
    pub fn to_string_with_checksum(&self, client: &Client) -> String {
        EntityId::to_string_with_checksum(self.to_string(), client)
    }

    /// Validates `self.checksum` (if it exists) for `client`.
    ///
    /// # Errors
    /// - [`Error::BadEntityId`] if there is a checksum, and the checksum is not valid for the client's `ledger_id`.
    pub fn validate_checksum(&self, client: &Client) -> Result<(), Error> {
        EntityId::validate_checksum(self.shard, self.realm, self.num, self.checksum, client)
    }
}

impl ValidateChecksums for FileId {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        EntityId::validate_checksum_for_ledger_id(
            self.shard,
            self.realm,
            self.num,
            self.checksum,
            ledger_id,
        )
    }
}

impl Debug for FileId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for FileId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}.{}.{}", self.shard, self.realm, self.num)
    }
}

impl FromProtobuf<services::FileId> for FileId {
    fn from_protobuf(pb: services::FileId) -> crate::Result<Self> {
        Ok(Self {
            num: pb.file_num as u64,
            shard: pb.shard_num as u64,
            realm: pb.realm_num as u64,
            checksum: None,
        })
    }
}

impl ToProtobuf for FileId {
    type Protobuf = services::FileId;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::FileId {
            file_num: self.num as i64,
            realm_num: self.realm as i64,
            shard_num: self.shard as i64,
        }
    }
}

impl From<u64> for FileId {
    fn from(num: u64) -> Self {
        Self { num, shard: 0, realm: 0, checksum: None }
    }
}

impl FromStr for FileId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        EntityId::from_str(s).map(Self::from)
    }
}

impl From<EntityId> for FileId {
    fn from(value: EntityId) -> Self {
        let EntityId { shard, realm, num, checksum } = value;
        Self { shard, realm, num, checksum }
    }
}

#[cfg(test)]
mod tests {
    use crate::FileId;

    #[test]
    fn should_serialize_from_string() {
        assert_eq!("0.0.5005", "0.0.5005".parse::<FileId>().unwrap().to_string());
    }

    #[test]
    fn from_bytes() {
        assert_eq!(
            "0.0.5005",
            FileId::from_bytes(&FileId::new(0, 0, 5005).to_bytes()).unwrap().to_string()
        );
    }

    #[test]
    fn from_solidity_address() {
        assert_eq!(
            "0.0.5005",
            FileId::from_solidity_address("000000000000000000000000000000000000138D")
                .unwrap()
                .to_string()
        );
    }

    #[test]
    fn to_solidity_address() {
        assert_eq!(
            "000000000000000000000000000000000000138d",
            FileId::new(0, 0, 5005).to_solidity_address().unwrap()
        );
    }
}
// Filename: src/file/file_info.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use time::{
    Duration,
    OffsetDateTime,
};

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    FileId,
    FromProtobuf,
    KeyList,
    LedgerId,
};

/// Response from [`FileInfoQuery`][crate::FileInfoQuery].
#[derive(Debug, Clone)]
pub struct FileInfo {
    /// The file ID of the file for which information is requested.
    pub file_id: FileId,

    /// Number of bytes in contents.
    pub size: u64,

    /// Current time which this account is set to expire.
    pub expiration_time: Option<OffsetDateTime>,

    /// The auto renew period for this file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    pub auto_renew_period: Option<Duration>,

    /// The account to be used at this file's expiration time to extend the
    /// life of the file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    pub auto_renew_account_id: Option<AccountId>,

    /// True if deleted but not yet expired.
    pub is_deleted: bool,

    /// One of these keys must sign in order to modify or delete the file.
    pub keys: KeyList,

    /// Memo associated with the file.
    pub file_memo: String,

    /// Ledger ID for the network the response was returned from.
    pub ledger_id: LedgerId,
}

impl FileInfo {
    /// Create a new `FileInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::file_get_info_response::FileInfo>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::response::Response> for FileInfo {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let response = pb_getv!(pb, FileGetInfo, services::response::Response);
        let info = pb_getf!(response, file_info)?;
        Self::from_protobuf(info)
    }
}

impl FromProtobuf<services::file_get_info_response::FileInfo> for FileInfo {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::file_get_info_response::FileInfo) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let file_id = pb_getf!(pb, file_id)?;
        let ledger_id = LedgerId::from_bytes(pb.ledger_id);

        Ok(Self {
            file_id: FileId::from_protobuf(file_id)?,
            size: pb.size as u64,
            expiration_time: pb.expiration_time.map(Into::into),
            auto_renew_account_id: None,
            auto_renew_period: None,
            is_deleted: pb.deleted,
            file_memo: pb.memo,
            ledger_id,
            keys: KeyList::from_protobuf(pb.keys.unwrap_or_default())?,
        })
    }
}

impl ToProtobuf for FileInfo {
    type Protobuf = services::file_get_info_response::FileInfo;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::file_get_info_response::FileInfo {
            file_id: Some(self.file_id.to_protobuf()),
            size: self.size as i64,
            expiration_time: self.expiration_time.to_protobuf(),
            deleted: self.is_deleted,
            memo: self.file_memo.clone(),
            ledger_id: self.ledger_id.to_bytes(),
            keys: Some(self.keys.to_protobuf()),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use prost::Message;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::unused_private_key;
    use crate::{
        FileInfo,
        Key,
        LedgerId,
    };

    fn make_info() -> services::file_get_info_response::FileInfo {
        services::file_get_info_response::FileInfo {
            file_id: Some(services::FileId { shard_num: 0, realm_num: 0, file_num: 1 }),
            size: 2,
            expiration_time: Some(services::Timestamp { seconds: 0, nanos: 3_000 }),
            deleted: true,
            keys: Some(services::KeyList {
                keys: Vec::from([Key::from(unused_private_key().public_key()).to_protobuf()]),
            }),
            ledger_id: LedgerId::mainnet().to_bytes(),

            ..Default::default()
        }
    }

    #[test]
    fn from_protobuf() {
        expect![[r#"
            FileInfo {
                file_id: "0.0.1",
                size: 2,
                expiration_time: Some(
                    1970-01-01 0:00:00.000003 +00:00:00,
                ),
                auto_renew_period: None,
                auto_renew_account_id: None,
                is_deleted: true,
                keys: KeyList {
                    keys: [
                        Single(
                            "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
                        ),
                    ],
                    threshold: None,
                },
                file_memo: "",
                ledger_id: "mainnet",
            }
        "#]].assert_debug_eq(&FileInfo::from_protobuf(make_info()).unwrap());
    }

    #[test]
    fn to_protobuf() {
        expect![[r#"
            FileInfo {
                file_id: Some(
                    FileId {
                        shard_num: 0,
                        realm_num: 0,
                        file_num: 1,
                    },
                ),
                size: 2,
                expiration_time: Some(
                    Timestamp {
                        seconds: 0,
                        nanos: 3000,
                    },
                ),
                deleted: true,
                keys: Some(
                    KeyList {
                        keys: [
                            Key {
                                key: Some(
                                    Ed25519(
                                        [
                                            224,
                                            200,
                                            236,
                                            39,
                                            88,
                                            165,
                                            135,
                                            159,
                                            250,
                                            194,
                                            38,
                                            161,
                                            60,
                                            12,
                                            81,
                                            107,
                                            121,
                                            158,
                                            114,
                                            227,
                                            81,
                                            65,
                                            160,
                                            221,
                                            130,
                                            143,
                                            148,
                                            211,
                                            121,
                                            136,
                                            164,
                                            183,
                                        ],
                                    ),
                                ),
                            },
                        ],
                    },
                ),
                memo: "",
                ledger_id: [
                    0,
                ],
            }
        "#]]
        .assert_debug_eq(&FileInfo::from_protobuf(make_info()).unwrap().to_protobuf());
    }

    #[test]
    fn from_bytes() {
        expect![[r#"
            FileInfo {
                file_id: "0.0.1",
                size: 2,
                expiration_time: Some(
                    1970-01-01 0:00:00.000003 +00:00:00,
                ),
                auto_renew_period: None,
                auto_renew_account_id: None,
                is_deleted: true,
                keys: KeyList {
                    keys: [
                        Single(
                            "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
                        ),
                    ],
                    threshold: None,
                },
                file_memo: "",
                ledger_id: "mainnet",
            }
        "#]].assert_debug_eq(&FileInfo::from_bytes(&make_info().encode_to_vec()).unwrap());
    }
}
// Filename: src/file/file_info_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::file_service_client::FileServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    Error,
    FileId,
    FileInfo,
    Query,
    ToProtobuf,
    ValidateChecksums,
};

/// Get all the information about a file.
pub type FileInfoQuery = Query<FileInfoQueryData>;

#[derive(Default, Clone, Debug)]
pub struct FileInfoQueryData {
    file_id: Option<FileId>,
}

impl From<FileInfoQueryData> for AnyQueryData {
    #[inline]
    fn from(data: FileInfoQueryData) -> Self {
        Self::FileInfo(data)
    }
}

impl FileInfoQuery {
    /// Returns the ID of the file for which information is requested.
    #[must_use]
    pub fn get_file_id(&self) -> Option<FileId> {
        self.data.file_id
    }

    /// Sets the ID of the file for which information is requested.
    pub fn file_id(&mut self, id: impl Into<FileId>) -> &mut Self {
        self.data.file_id = Some(id.into());
        self
    }
}

impl ToQueryProtobuf for FileInfoQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let file_id = self.file_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::FileGetInfo(services::FileGetInfoQuery {
                file_id,
                header: Some(header),
            })),
        }
    }
}

impl QueryExecute for FileInfoQueryData {
    type Response = FileInfo;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { FileServiceClient::new(channel).get_file_info(request).await })
    }
}

impl ValidateChecksums for FileInfoQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.file_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        FileContentsQuery,
        FileId,
        FileInfoQuery,
        Hbar,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    FileGetInfo(
                        FileGetInfoQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            file_id: Some(
                                FileId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    file_num: 5005,
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &FileInfoQuery::new()
                .file_id(FileId::new(0, 0, 5005))
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        )
    }

    #[test]
    fn get_set_file_id() {
        let mut query = FileContentsQuery::new();
        query.file_id(FileId::new(0, 0, 5005));

        assert_eq!(query.get_file_id(), Some(FileId::new(0, 0, 5005)));
    }
}
// Filename: src/file/file_update_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::file_service_client::FileServiceClient;
use time::{
    Duration,
    OffsetDateTime,
};
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    FileId,
    Key,
    KeyList,
    Transaction,
    ValidateChecksums,
};

/// Modify the metadata and/or the contents of a file.
///
/// If a field is not set in the transaction body, the
/// corresponding file attribute will be unchanged.
///
pub type FileUpdateTransaction = Transaction<FileUpdateTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct FileUpdateTransactionData {
    /// The file ID which is being updated in this transaction.
    file_id: Option<FileId>,

    /// The memo associated with the file.
    file_memo: Option<String>,

    /// All keys at the top level of a key list must sign to create or
    /// modify the file. Any one of the keys at the top level key list
    /// can sign to delete the file.
    keys: Option<KeyList>,

    /// The bytes that are to be the contents of the file.
    contents: Option<Vec<u8>>,

    /// The time at which this file should expire.
    expiration_time: Option<OffsetDateTime>,

    auto_renew_account_id: Option<AccountId>,

    auto_renew_period: Option<Duration>,
}

impl FileUpdateTransaction {
    /// Returns the ID of the file which is being updated.
    #[must_use]
    pub fn get_file_id(&self) -> Option<FileId> {
        self.data().file_id
    }

    /// Sets the ID of the file which is being updated.
    pub fn file_id(&mut self, id: impl Into<FileId>) -> &mut Self {
        self.data_mut().file_id = Some(id.into());
        self
    }

    /// Returns the new memo for the file.
    #[must_use]
    pub fn get_file_memo(&self) -> Option<&str> {
        self.data().file_memo.as_deref()
    }

    /// Sets the new memo to be associated with the file.
    pub fn file_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().file_memo = Some(memo.into());
        self
    }

    /// Returns the bytes that are to be the contents of the file.
    #[must_use]
    pub fn get_contents(&self) -> Option<&[u8]> {
        self.data().contents.as_deref()
    }

    /// Sets the bytes that are to be the contents of the file.
    pub fn contents(&mut self, contents: Vec<u8>) -> &mut Self {
        self.data_mut().contents = Some(contents);
        self
    }

    /// Returns the keys for this file.
    #[must_use]
    pub fn get_keys(&self) -> Option<&KeyList> {
        self.data().keys.as_ref()
    }

    /// Sets the keys for this file.
    ///
    /// All keys at the top level of a key list must sign to create or
    /// modify the file. Any one of the keys at the top level key list
    /// can sign to delete the file.
    pub fn keys<K: Into<Key>>(&mut self, keys: impl IntoIterator<Item = K>) -> &mut Self {
        self.data_mut().keys = Some(keys.into_iter().map(Into::into).collect());
        self
    }

    /// Returns the time at which this file should expire.
    #[must_use]
    pub fn get_expiration_time(&self) -> Option<OffsetDateTime> {
        self.data().expiration_time
    }

    /// Sets the time at which this file should expire.
    pub fn expiration_time(&mut self, at: OffsetDateTime) -> &mut Self {
        self.data_mut().expiration_time = Some(at);
        self
    }

    /// Returns the account to be used at the file's expiration time to extend the
    /// life of the file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the account to be used at the files's expiration time to extend the
    /// life of the file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    pub fn auto_renew_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(id);
        self
    }

    /// Returns the auto renew period for this file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.data().auto_renew_period
    }

    /// Sets the auto renew period for this file.
    ///
    /// # Network Support
    /// Please note that this not supported on any hedera network at this time.
    pub fn auto_renew_period(&mut self, duration: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = Some(duration);
        self
    }
}

impl TransactionData for FileUpdateTransactionData {}

impl TransactionExecute for FileUpdateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { FileServiceClient::new(channel).update_file(request).await })
    }
}

impl ValidateChecksums for FileUpdateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.file_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for FileUpdateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::FileUpdate(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for FileUpdateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::FileUpdate(self.to_protobuf())
    }
}

impl From<FileUpdateTransactionData> for AnyTransactionData {
    fn from(transaction: FileUpdateTransactionData) -> Self {
        Self::FileUpdate(transaction)
    }
}

impl FromProtobuf<services::FileUpdateTransactionBody> for FileUpdateTransactionData {
    fn from_protobuf(pb: services::FileUpdateTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            file_id: Option::from_protobuf(pb.file_id)?,
            file_memo: pb.memo,
            keys: Option::from_protobuf(pb.keys)?,
            contents: Some(pb.contents),
            expiration_time: pb.expiration_time.map(Into::into),
            auto_renew_account_id: None,
            auto_renew_period: None,
        })
    }
}

impl ToProtobuf for FileUpdateTransactionData {
    type Protobuf = services::FileUpdateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::FileUpdateTransactionBody {
            file_id: self.file_id.to_protobuf(),
            expiration_time: self.expiration_time.to_protobuf(),
            keys: self.keys.to_protobuf(),
            contents: self.contents.clone().unwrap_or_default(),
            memo: self.file_memo.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use time::OffsetDateTime;

    use crate::file::FileUpdateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
    };
    use crate::{
        AnyTransaction,
        FileId,
        FileUpdateTransaction,
        Key,
        KeyList,
    };

    const FILE_ID: FileId = FileId::new(0, 0, 6006);

    const CONTENTS: [u8; 5] = [1, 2, 3, 4, 5];

    const EXPIRATION_TIME: OffsetDateTime = match OffsetDateTime::from_unix_timestamp(1554158728) {
        Ok(it) => it,
        Err(_) => panic!("Panic in `const` unwrap"),
    };

    fn keys() -> impl IntoIterator<Item = Key> {
        [unused_private_key().public_key().into()]
    }

    const FILE_MEMO: &str = "new memo";

    fn make_transaction() -> FileUpdateTransaction {
        let mut tx = FileUpdateTransaction::new_for_tests();

        tx.file_id(FILE_ID)
            .expiration_time(EXPIRATION_TIME)
            .contents(CONTENTS.into())
            .keys(keys())
            .file_memo(FILE_MEMO)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            FileUpdate(
                FileUpdateTransactionBody {
                    file_id: Some(
                        FileId {
                            shard_num: 0,
                            realm_num: 0,
                            file_num: 6006,
                        },
                    ),
                    expiration_time: Some(
                        Timestamp {
                            seconds: 1554158728,
                            nanos: 0,
                        },
                    ),
                    keys: Some(
                        KeyList {
                            keys: [
                                Key {
                                    key: Some(
                                        Ed25519(
                                            [
                                                224,
                                                200,
                                                236,
                                                39,
                                                88,
                                                165,
                                                135,
                                                159,
                                                250,
                                                194,
                                                38,
                                                161,
                                                60,
                                                12,
                                                81,
                                                107,
                                                121,
                                                158,
                                                114,
                                                227,
                                                81,
                                                65,
                                                160,
                                                221,
                                                130,
                                                143,
                                                148,
                                                211,
                                                121,
                                                136,
                                                164,
                                                183,
                                            ],
                                        ),
                                    ),
                                },
                            ],
                        },
                    ),
                    contents: [
                        1,
                        2,
                        3,
                        4,
                        5,
                    ],
                    memo: Some(
                        "new memo",
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::FileUpdateTransactionBody {
            file_id: Some(FILE_ID.to_protobuf()),
            expiration_time: Some(EXPIRATION_TIME.to_protobuf()),
            keys: Some(KeyList::from_iter(keys()).to_protobuf()),
            contents: CONTENTS.into(),
            memo: Some(FILE_MEMO.to_owned()),
        };

        let tx = FileUpdateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.contents.as_deref(), Some(CONTENTS.as_slice()));
        assert_eq!(tx.expiration_time, Some(EXPIRATION_TIME));
        assert_eq!(tx.keys, Some(KeyList::from_iter(keys())));
        assert_eq!(tx.file_memo.as_deref(), Some(FILE_MEMO));
    }

    mod get_set {
        use super::*;

        #[test]
        fn contents() {
            let mut tx = FileUpdateTransaction::new();
            tx.contents(CONTENTS.into());

            assert_eq!(tx.get_contents(), Some(CONTENTS.as_slice()));
        }

        #[test]
        #[should_panic]
        fn contents_frozen_panics() {
            make_transaction().contents(CONTENTS.into());
        }

        #[test]
        fn expiration_time() {
            let mut tx = FileUpdateTransaction::new();
            tx.expiration_time(EXPIRATION_TIME);

            assert_eq!(tx.get_expiration_time(), Some(EXPIRATION_TIME));
        }

        #[test]
        #[should_panic]
        fn expiration_time_frozen_panics() {
            make_transaction().expiration_time(EXPIRATION_TIME);
        }

        #[test]
        fn keys() {
            let mut tx = FileUpdateTransaction::new();
            tx.keys(super::keys());

            assert_eq!(tx.get_keys(), Some(&KeyList::from_iter(super::keys())));
        }

        #[test]
        #[should_panic]
        fn keys_frozen_panics() {
            make_transaction().keys(super::keys());
        }

        #[test]
        fn file_memo() {
            let mut tx = FileUpdateTransaction::new();
            tx.file_memo(FILE_MEMO);

            assert_eq!(tx.get_file_memo(), Some(FILE_MEMO));
        }

        #[test]
        #[should_panic]
        fn file_memo_frozen_panics() {
            make_transaction().file_memo(FILE_MEMO);
        }
    }
}
// Filename: src/file/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod file_append_transaction;
mod file_contents_query;
mod file_contents_response;
mod file_create_transaction;
mod file_delete_transaction;
mod file_id;
mod file_info;
mod file_info_query;
mod file_update_transaction;

pub use file_append_transaction::FileAppendTransaction;
pub(crate) use file_append_transaction::FileAppendTransactionData;
pub use file_contents_query::FileContentsQuery;
pub(crate) use file_contents_query::FileContentsQueryData;
pub use file_contents_response::FileContentsResponse;
pub use file_create_transaction::FileCreateTransaction;
pub(crate) use file_create_transaction::FileCreateTransactionData;
pub use file_delete_transaction::FileDeleteTransaction;
pub(crate) use file_delete_transaction::FileDeleteTransactionData;
pub use file_id::FileId;
pub use file_info::FileInfo;
pub use file_info_query::FileInfoQuery;
pub(crate) use file_info_query::FileInfoQueryData;
pub use file_update_transaction::FileUpdateTransaction;
pub(crate) use file_update_transaction::FileUpdateTransactionData;
// Filename: src/hbar.rs
use std::fmt::{
    Debug,
    Display,
    Formatter,
};
use std::ops;
use std::str::FromStr;

use rust_decimal::prelude::*;

use crate::Error;

/// Type alias for `i64` representing `tinybar`
pub type Tinybar = i64;

/// Common units of hbar; for the most part they follow SI prefix conventions.
///
/// See the [Hiero Documentation](https://docs.hedera.com/guides/docs/sdks/hbars#hbar-units).
#[repr(i64)]
#[derive(Debug, Copy, Hash, PartialEq, Eq, Clone)]
pub enum HbarUnit {
    /// The atomic (smallest) unit of [`Hbar`], used natively by the Hiero network.
    ///
    /// It is equivalent to <sup>1</sup>&frasl;<sub>100,000,000</sub> [`Hbar`](Self::Hbar).
    Tinybar = 1,

    /// Equivalent to 100 [`Tinybar`](Self::Tinybar) or <sup>1</sup>&frasl;<sub>1,000,000</sub> [`Hbar`](Self::Hbar).
    Microbar = 100,

    /// Equivalent to 100,000 [`Tinybar`](Self::Tinybar) or <sup>1</sup>&frasl;<sub>1,000</sub> [`Hbar`](Self::Hbar).
    Millibar = 100_000,

    /// The base unit of [`Hbar`], equivalent to 100 million [`Tinybar`](Self::Tinybar).
    Hbar = 100_000_000,

    /// Equivalent to 1 thousand [`Hbar`](Self::Hbar) or 100 billion [`Tinybar`](Self::Tinybar).
    Kilobar = 1_000 * 100_000_000,

    /// Equivalent to 1 million [`Hbar`](Self::Hbar) or 100 trillion [`Tinybar`](Self::Tinybar).
    Megabar = 1_000_000 * 100_000_000,

    /// Equivalent to 1 billion [`Hbar`](Self::Hbar) or 100 quadrillion [`Tinybar`](Self::Tinybar).
    ///
    /// The maximum hbar amount supported by Hiero in any context is ~92 gigabar
    /// (2<sup>63</sup> tinybar); use this unit sparingly.
    Gigabar = 1_000_000_000 * 100_000_000,
}

impl HbarUnit {
    /// Returns the the value of `self` in `Tinybar`.
    ///
    /// # Examples
    /// ```
    /// use hedera::HbarUnit;
    /// assert_eq!(HbarUnit::Microbar.tinybars(), 100);
    /// ```
    #[must_use]
    pub const fn tinybars(self) -> Tinybar {
        self as Tinybar
    }

    /// Returns a `str` containing the symbol for `self`.
    ///
    /// # Examples
    /// ```
    /// use hedera::HbarUnit;
    /// assert_eq!(HbarUnit::Millibar.symbol(), "m");
    /// ```
    #[must_use]
    pub const fn symbol(self) -> &'static str {
        match self {
            HbarUnit::Tinybar => "t",
            HbarUnit::Microbar => "",
            HbarUnit::Millibar => "m",
            HbarUnit::Hbar => "",
            HbarUnit::Kilobar => "k",
            HbarUnit::Megabar => "M",
            HbarUnit::Gigabar => "G",
        }
    }
}

impl Display for HbarUnit {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str(self.symbol())
    }
}

impl FromStr for HbarUnit {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "t" => Ok(HbarUnit::Tinybar),
            "" => Ok(HbarUnit::Microbar),
            "m" => Ok(HbarUnit::Millibar),
            "" => Ok(HbarUnit::Hbar),
            "k" => Ok(HbarUnit::Kilobar),
            "M" => Ok(HbarUnit::Megabar),
            "G" => Ok(HbarUnit::Gigabar),
            _ => Err(Error::basic_parse(format!(
                "Given string `{s}` was not recognized as an Hbar unit symbol"
            ))),
        }
    }
}

/// A quantity of `hbar`.
#[derive(Default, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]
pub struct Hbar(i64);

impl Hbar {
    /// A constant value of `0 `.
    pub const ZERO: Hbar = Hbar::from_tinybars(0);

    /// The minimum allowable amount of hbar `-50 G`
    pub const MIN: Hbar = Self::from_integer_unit(-50, HbarUnit::Gigabar);

    /// The maximum allowable amount of hbar `50 G`.
    pub const MAX: Self = Self::from_integer_unit(50, HbarUnit::Gigabar);

    /// Create a `Hbar` containing `amount `.
    ///
    /// # Examples
    /// ```
    /// # use hedera::Hbar;
    /// let hbar = Hbar::new(52);
    /// assert_eq!(hbar.to_string(), "52 ");
    #[must_use]
    pub const fn new(amount: i64) -> Self {
        Self::from_integer_unit(amount, HbarUnit::Hbar)
    }

    /// Convert from `tinybars` to `Hbar`.
    ///
    /// # Examples
    /// ```
    /// # use hedera::Hbar;
    /// let hbar = Hbar::from_tinybars(250);
    /// assert_eq!(hbar.to_string(), "250 t");
    /// ```
    #[must_use]
    pub const fn from_tinybars(tinybars: Tinybar) -> Self {
        // todo: `debug_assert!` or `assert!` in range?
        Hbar(tinybars)
    }

    /// Helper for things like `20 G -> Hbar`.
    const fn from_integer_unit(amount: i64, unit: HbarUnit) -> Self {
        Self::from_tinybars(amount * unit.tinybars())
    }

    // fixme(sr): poor wording on `Truncates...`
    /// Convert from `amount` in `unit` to `Hbar`.
    ///
    /// Truncates `amount` to the nearest tinybar if the resulting `Hbar` is not an integer amount of tinybar.
    ///
    /// # Panics
    ///
    /// * if `amount * unit.tinybars()` would overflow a i64.
    ///
    /// # Examples
    ///
    /// ```
    /// use hedera::Hbar;
    /// use hedera::HbarUnit;
    /// let value = Hbar::from_unit(20, HbarUnit::Millibar);
    /// assert_eq!(value.to_string(), "0.02 ");
    /// ```
    #[must_use]
    #[track_caller]
    pub fn from_unit<T>(amount: T, unit: HbarUnit) -> Self
    where
        T: Into<Decimal>,
    {
        let unit_tinybars: Decimal = unit.tinybars().into();
        let amount_tinybars = amount.into().checked_mul(unit_tinybars).unwrap();

        Hbar::from_tinybars(amount_tinybars.to_i64().unwrap())
    }

    /// Returns the value of `self` in `Tinybar`s.
    #[must_use]
    pub const fn to_tinybars(self) -> Tinybar {
        self.0
    }

    /// Returns `self` as `Decimal` `unit`s.
    #[must_use]
    pub fn to(self, unit: HbarUnit) -> Decimal {
        Decimal::from(self.to_tinybars()) / Decimal::from(unit.tinybars())
    }

    /// Returns `self` as `Decimal` hbars.
    ///
    /// # Examples
    /// ```
    /// use rust_decimal::Decimal;
    /// use hedera::Hbar;
    /// # use std::str::FromStr;
    /// let value: Hbar = "20 m".parse().unwrap();
    ///
    /// let value_decimal: Decimal = "0.02".parse().unwrap();
    ///
    /// assert_eq!(value.get_value(), value_decimal);
    /// ```
    #[must_use]
    pub fn get_value(self) -> Decimal {
        self.to(HbarUnit::Hbar)
    }

    /// Returns [`-self`](std::ops::Neg::neg).
    #[must_use]
    pub fn negated(self) -> Self {
        -self
    }
}

impl From<Hbar> for Decimal {
    fn from(hbar: Hbar) -> Self {
        hbar.get_value()
    }
}

impl From<Decimal> for Hbar {
    fn from(hbars: Decimal) -> Self {
        Hbar::from_unit(hbars, HbarUnit::Hbar)
    }
}

impl Display for Hbar {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        if self.to_tinybars() > -10_000 && self.to_tinybars() < 10_000 {
            write!(f, "{} {}", self.to_tinybars(), HbarUnit::Tinybar.symbol())
        } else {
            write!(f, "{} {}", self.to(HbarUnit::Hbar), HbarUnit::Hbar.symbol())
        }
    }
}

impl Debug for Hbar {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl FromStr for Hbar {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (amount, unit) = s.split_once(' ').unwrap_or((s, ""));
        let amount: Decimal = amount.parse().map_err(Error::basic_parse)?;
        let unit = HbarUnit::from_str(unit)?;
        Ok(Hbar::from_unit(amount, unit))
    }
}

impl ops::Neg for Hbar {
    type Output = Self;

    fn neg(self) -> Self::Output {
        Self(-self.0)
    }
}

impl ops::Add for Hbar {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl ops::AddAssign for Hbar {
    fn add_assign(&mut self, rhs: Self) {
        self.0 += rhs.0;
    }
}

impl ops::Sub for Hbar {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl ops::SubAssign for Hbar {
    fn sub_assign(&mut self, rhs: Self) {
        self.0 -= rhs.0;
    }
}

impl<T> ops::Mul<T> for Hbar
where
    i64: ops::Mul<T, Output = i64>,
{
    type Output = Self;

    fn mul(self, rhs: T) -> Self::Output {
        Self(self.0 * rhs)
    }
}

impl<T> ops::MulAssign<T> for Hbar
where
    i64: ops::MulAssign<T>,
{
    fn mul_assign(&mut self, rhs: T) {
        self.0 *= rhs;
    }
}

impl<T> ops::Div<T> for Hbar
where
    i64: ops::Div<T, Output = i64>,
{
    type Output = Self;

    fn div(self, rhs: T) -> Self::Output {
        Self(self.0 / rhs)
    }
}

impl<T> ops::DivAssign<T> for Hbar
where
    i64: ops::DivAssign<T>,
{
    fn div_assign(&mut self, rhs: T) {
        self.0 /= rhs;
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use rust_decimal::Decimal;

    use crate::{
        Hbar,
        HbarUnit,
    };

    #[test]
    fn it_can_parse() {
        assert_eq!(Hbar::from_str("10 t").unwrap(), Hbar::from_tinybars(10));
        assert_eq!(Hbar::from_str("11 ").unwrap(), Hbar::from_unit(11, HbarUnit::Microbar));
        assert_eq!(Hbar::from_str("12 m").unwrap(), Hbar::from_unit(12, HbarUnit::Millibar));
        assert_eq!(Hbar::from_str("13 ").unwrap(), Hbar::from_unit(13, HbarUnit::Hbar));
        assert_eq!(Hbar::from_str("14 k").unwrap(), Hbar::from_unit(14, HbarUnit::Kilobar));
        assert_eq!(Hbar::from_str("15 M").unwrap(), Hbar::from_unit(15, HbarUnit::Megabar));
        assert_eq!(Hbar::from_str("16 G").unwrap(), Hbar::from_unit(16, HbarUnit::Gigabar));
        assert_eq!(Hbar::from_str("17").unwrap(), Hbar::from(Decimal::from(17)));
        assert_eq!(Hbar::from_str("-17 ").unwrap(), Hbar::new(-17));
        assert_eq!(Hbar::from_str("+19 ").unwrap(), Hbar::new(19));
    }

    #[test]
    fn it_can_to_string() {
        assert_eq!(Hbar::from_unit(9_999, HbarUnit::Tinybar).to_string(), "9999 t");
        assert_eq!(Hbar::from_unit(10_000, HbarUnit::Tinybar).to_string(), "0.0001 ");
        assert_eq!(Hbar::from_unit(-9_999, HbarUnit::Tinybar).to_string(), "-9999 t");
        assert_eq!(Hbar::from_unit(-10_000, HbarUnit::Tinybar).to_string(), "-0.0001 ");
    }

    #[test]
    fn it_can_arithmatic() {
        let ten = Hbar::from_tinybars(10);
        let three = Hbar::from_tinybars(3);
        let one = Hbar::from_tinybars(1);

        assert_eq!((ten * 2) - (ten / 2) + three, Hbar::from_tinybars((10 * 2) - (10 / 2) + 3));

        let mut m = three;
        m *= 2;
        assert_eq!(m.to_tinybars(), 6);
        m /= 2;
        assert_eq!(m.to_tinybars(), 3);
        m += one;
        assert_eq!(m.to_tinybars(), 4);
        m -= one;
        assert_eq!(m.to_tinybars(), 3);
        assert_eq!((-m).to_tinybars(), -3);
    }
}
// Filename: src/key/key.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use crate::contract::DelegateContractId;
use crate::{
    ContractId,
    Error,
    FromProtobuf,
    KeyList,
    PublicKey,
    ToProtobuf,
};

/// Any method that can be used to authorize an operation on Hiero.
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
#[non_exhaustive]
pub enum Key {
    // todo(sr): not happy with any of these (fix before merge)
    /// A single public key.
    Single(PublicKey),

    /// A contract ID.
    ContractId(ContractId),

    /// A delegatable contract ID.
    DelegateContractId(DelegateContractId),

    /// A key list.
    KeyList(KeyList),
}

impl Key {
    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl ToProtobuf for Key {
    type Protobuf = services::Key;

    fn to_protobuf(&self) -> Self::Protobuf {
        use services::key::Key::*;

        services::Key {
            key: Some(match self {
                Self::Single(key) => {
                    let bytes = key.to_bytes_raw();

                    match key.kind() {
                        crate::key::KeyKind::Ed25519 => Ed25519(bytes),
                        crate::key::KeyKind::Ecdsa => EcdsaSecp256k1(bytes),
                    }
                }

                Self::ContractId(id) => ContractId(id.to_protobuf()),
                Self::DelegateContractId(id) => DelegatableContractId(id.to_protobuf()),
                // `KeyList`s are special and can be both a key list and a threshold key.
                Self::KeyList(key) => key.to_protobuf_key(),
            }),
        }
    }
}

impl From<PublicKey> for Key {
    fn from(key: PublicKey) -> Self {
        Self::Single(key)
    }
}

impl From<ContractId> for Key {
    fn from(id: ContractId) -> Self {
        Self::ContractId(id)
    }
}

impl From<KeyList> for Key {
    fn from(value: KeyList) -> Self {
        Self::KeyList(value)
    }
}

impl FromProtobuf<services::Key> for Key {
    fn from_protobuf(pb: services::Key) -> crate::Result<Self>
    where
        Self: Sized,
    {
        use services::key::Key::*;

        match pb.key {
            Some(Ed25519(bytes)) => Ok(Self::Single(PublicKey::from_bytes_ed25519(&bytes)?)),
            Some(ContractId(id)) => Ok(Self::ContractId(crate::ContractId::from_protobuf(id)?)),
            Some(DelegatableContractId(id)) => {
                Ok(Self::DelegateContractId(crate::DelegateContractId::from_protobuf(id)?))
            }
            Some(Rsa3072(_)) => {
                Err(Error::from_protobuf("unexpected unsupported RSA-3072 key in Key"))
            }
            Some(Ecdsa384(_)) => {
                Err(Error::from_protobuf("unexpected unsupported ECDSA-384 key in Key"))
            }
            Some(ThresholdKey(it)) => Ok(Self::KeyList(crate::KeyList::from_protobuf(it)?)),
            Some(KeyList(it)) => Ok(Self::KeyList(crate::KeyList::from_protobuf(it)?)),
            Some(EcdsaSecp256k1(bytes)) => Ok(Self::Single(PublicKey::from_bytes_ecdsa(&bytes)?)),
            None => Err(Error::from_protobuf("unexpected empty key in Key")),
        }
    }
}

#[cfg(test)]
mod tests {
    use assert_matches::assert_matches;
    use hedera_proto::services;
    use hex_literal::hex;

    use crate::protobuf::FromProtobuf;
    use crate::{
        Key,
        PublicKey,
    };

    #[test]
    fn from_proto_key_ed25519() {
        const KEY_BYTES: [u8; 32] =
            hex!("0011223344556677889900112233445566778899001122334455667788990011");

        let key = services::Key { key: Some(services::key::Key::Ed25519(KEY_BYTES.to_vec())) };

        let key = PublicKey::from_protobuf(key).unwrap();

        assert_matches!(key.kind(), crate::key::KeyKind::Ed25519);

        assert_eq!(key.to_bytes_raw(), KEY_BYTES);
    }

    #[test]
    fn from_proto_key_ecdsa() {
        const KEY_BYTES: [u8; 35] =
            hex!("3a21034e0441201f2bf9c7d9873c2a9dc3fd451f64b7c05e17e4d781d916e3a11dfd99");

        let key = PublicKey::from_alias_bytes(&KEY_BYTES).unwrap().unwrap();

        assert_matches!(key.kind(), crate::key::KeyKind::Ecdsa);

        assert_eq!(Key::from(key).to_bytes(), KEY_BYTES);
    }

    #[test]
    fn from_proto_key_key_list() {
        const KEY_BYTES: [[u8; 32]; 2] = [
            hex!("0011223344556677889900112233445566778899001122334455667788990011"),
            hex!("aa11223344556677889900112233445566778899001122334455667788990011"),
        ];

        let key_list_pb = services::KeyList {
            keys: KEY_BYTES
                .iter()
                .map(|it| services::Key { key: Some(services::key::Key::Ed25519(it.to_vec())) })
                .collect(),
        };

        let key_pb = services::Key { key: Some(services::key::Key::KeyList(key_list_pb.clone())) };

        let key = Key::from_protobuf(key_pb).unwrap();

        let key_list = assert_matches!(key, Key::KeyList(it) => it);

        assert_eq!(key_list.len(), KEY_BYTES.len());

        let reencoded =
            assert_matches!(key_list.to_protobuf_key(), services::key::Key::KeyList(key) => key);

        assert_eq!(reencoded, key_list_pb);
    }

    #[test]
    fn from_proto_key_threshold_key() {
        const KEY_BYTES: [[u8; 32]; 2] = [
            hex!("0011223344556677889900112233445566778899001122334455667788990011"),
            hex!("aa11223344556677889900112233445566778899001122334455667788990011"),
        ];

        let key_list_pb = services::KeyList {
            keys: KEY_BYTES
                .iter()
                .map(|it| services::Key { key: Some(services::key::Key::Ed25519(it.to_vec())) })
                .collect(),
        };

        let threshold_key_pb = services::ThresholdKey { threshold: 1, keys: Some(key_list_pb) };

        let key_pb =
            services::Key { key: Some(services::key::Key::ThresholdKey(threshold_key_pb.clone())) };

        let key = Key::from_protobuf(key_pb).unwrap();

        let threshold_key = assert_matches!(key, Key::KeyList(it) => it);

        assert_eq!(threshold_key.len(), KEY_BYTES.len());

        let reencoded = assert_matches!(threshold_key.to_protobuf_key(), services::key::Key::ThresholdKey(key) => key);

        assert_eq!(reencoded, threshold_key_pb);
    }

    #[test]
    fn unsupported_key_fails() {
        let key = services::Key { key: Some(services::key::Key::Rsa3072(Vec::from([0, 1, 2]))) };

        assert_matches!(Key::from_protobuf(key), Err(crate::Error::FromProtobuf(_)));
    }
}
// Filename: src/key/key_list.rs
use hedera_proto::services;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::Key;

// note: it appears keylists "just" implement the APIs of arrays in their language, which means, uh...
// todo: Copy over the _entire_ `Vec` API?.
/// A list of keys with an optional threshold.
#[derive(Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct KeyList {
    // todo: better doc comment?
    /// The list of keys.
    pub keys: Vec<Key>,

    /// If [`Some`]: The minimum number of keys that must sign.
    pub threshold: Option<u32>,
}

impl std::ops::Deref for KeyList {
    type Target = Vec<Key>;

    fn deref(&self) -> &Self::Target {
        &self.keys
    }
}

impl std::ops::DerefMut for KeyList {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.keys
    }
}

impl KeyList {
    /// Create a new empty key list.
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns `true` if this keylist is empty.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.keys.is_empty()
    }

    /// Removes and returns the element at position index within the key list, shifting all elements after it to the left.
    ///
    /// # Panics
    /// Panics if index is out of bounds.
    pub fn remove(&mut self, index: usize) -> Key {
        self.keys.remove(index)
    }

    // why not `ToProtobuf`? because `ToProtobuf` should return a `KeyList`.
    pub(crate) fn to_protobuf_key(&self) -> services::key::Key {
        let key_list = services::KeyList { keys: self.keys.to_protobuf() };

        if let Some(threshold) = self.threshold {
            return services::key::Key::ThresholdKey(services::ThresholdKey {
                threshold,
                keys: Some(key_list),
            });
        };

        services::key::Key::KeyList(key_list)
    }
}

impl ToProtobuf for KeyList {
    type Protobuf = services::KeyList;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::KeyList { keys: self.keys.to_protobuf() }
    }
}

impl FromIterator<Key> for KeyList {
    fn from_iter<T: IntoIterator<Item = Key>>(iter: T) -> Self {
        Self { keys: Vec::from_iter(iter), threshold: None }
    }
}

impl From<Vec<Key>> for KeyList {
    fn from(value: Vec<Key>) -> Self {
        Self { keys: value, threshold: None }
    }
}

impl<T: Into<Key>, const N: usize> From<[T; N]> for KeyList {
    fn from(value: [T; N]) -> Self {
        value.into_iter().map(Into::into).collect()
    }
}

impl FromProtobuf<services::KeyList> for KeyList {
    fn from_protobuf(pb: services::KeyList) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Vec::from_protobuf(pb.keys).map(Self::from)
    }
}

impl FromProtobuf<services::ThresholdKey> for KeyList {
    fn from_protobuf(pb: services::ThresholdKey) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let keys = Vec::from_protobuf(pb.keys.unwrap_or_default().keys)?;
        Ok(Self { keys, threshold: Some(pb.threshold) })
    }
}

#[cfg(test)]
mod tests {
    use assert_matches::assert_matches;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::{
        KeyList,
        PrivateKey,
        PublicKey,
    };

    fn keys() -> [PublicKey; 3] {
        let key1 = PrivateKey::from_str_ed25519(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10").unwrap()
    .public_key();

        let key2 = PrivateKey::from_str_ed25519(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11").unwrap()
    .public_key();

        let key3 = PrivateKey::from_str_ed25519(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e12").unwrap()
    .public_key();

        [key1, key2, key3]
    }

    #[test]
    fn from_protobuf() {
        let key_list_pb =
            services::KeyList { keys: keys().iter().map(|it| it.to_protobuf()).collect() };

        let key_list = KeyList::from_protobuf(key_list_pb).unwrap();

        assert!(keys().iter().all(|it| key_list.contains(&crate::Key::Single(*it))));
    }

    #[test]
    fn to_protobuf_key() {
        let key_list = KeyList::from(keys());

        let proto_key = key_list.to_protobuf_key();

        let proto_key_list = assert_matches!(proto_key, services::key::Key::KeyList(it) => it);

        for (actual, expected) in proto_key_list.keys.iter().zip(keys()) {
            assert_eq!(actual, &expected.to_protobuf());
        }
    }

    #[test]
    fn to_protobuf() {
        let key_list = KeyList::from(keys());

        let proto_key_list = key_list.to_protobuf();

        for (actual, expected) in proto_key_list.keys.iter().zip(keys()) {
            assert_eq!(actual, &expected.to_protobuf());
        }
    }

    #[test]
    fn len() {
        let key_list = KeyList::from(keys());
        let empty_key_list = KeyList::new();

        assert_eq!(key_list.len(), 3);
        assert!(!key_list.is_empty());
        assert_eq!(empty_key_list.len(), 0);
        assert!(empty_key_list.is_empty());
    }

    #[test]
    fn contains() {
        // Given / When

        let key_list = KeyList::from(keys());
        let empty_key_list = KeyList::new();

        assert!(keys().iter().all(|it| key_list.contains(&crate::Key::Single(*it))));
        assert!(!keys().iter().any(|it| empty_key_list.contains(&crate::Key::Single(*it))));
    }

    #[test]
    fn push() {
        let [a, b, c] = keys();

        let mut key_list = KeyList::from([a, b]);

        key_list.push(c.into());

        assert_eq!(key_list.len(), 3);

        assert!(key_list.contains(&c.into()));
    }

    #[test]
    fn remove() {
        let keys = keys();
        let mut key_list = KeyList::from(keys);

        let _ = key_list.remove(0);

        assert_eq!(key_list.len(), 2);

        assert!(!key_list.contains(&keys[0].into()));
        assert!(key_list.contains(&keys[1].into()));
        assert!(key_list.contains(&keys[2].into()));
    }

    #[test]
    fn clear() {
        let mut key_list = KeyList::from(keys());

        key_list.clear();

        assert!(key_list.is_empty());
    }
}
// Filename: src/key/mod.rs
// SPDX-License-Identifier: Apache-2.0

#[allow(clippy::module_inception)]
mod key;
mod key_list;
mod private_key;
mod public_key;

pub use key::Key;
pub use key_list::KeyList;
pub use private_key::PrivateKey;
pub use public_key::PublicKey;

#[derive(Copy, Clone, Debug)]
pub(crate) enum KeyKind {
    Ed25519,
    Ecdsa,
}
// Filename: src/key/private_key/mod.rs
// SPDX-License-Identifier: Apache-2.0

#[cfg(test)]
mod tests;

use std::fmt::{
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;
use std::{
    fmt,
    mem,
};

use aes::cipher::generic_array::GenericArray;
use aes::cipher::{
    BlockDecryptMut,
    KeyIvInit,
};
use ed25519_dalek::Signer;
use hmac::{
    Hmac,
    Mac,
};
use k256::ecdsa::signature::DigestSigner;
use pkcs8::der::oid::ObjectIdentifier;
use pkcs8::der::{
    Decode,
    Encode,
};
use sec1::EcPrivateKey;
use sha2::Sha512;
use sha3::Digest;
use triomphe::Arc;

use crate::signer::AnySigner;
use crate::{
    AccountId,
    Error,
    PublicKey,
    Transaction,
};

// replace with `array::split_array_ref` when that's stable.
fn split_key_array(arr: &[u8; 64]) -> (&[u8; 32], &[u8; 32]) {
    let (lhs, rhs) = arr.split_at(32);

    // SAFETY: lhs points to [T; N]? Yes it's [T] of length 64/2 (guaranteed by split_at)
    let lhs = unsafe { &*(lhs.as_ptr().cast::<[u8; 32]>()) };
    // SAFETY: rhs points to [T; N]? Yes it's [T] of length 64/2 (rhs.len() = 64 - lhs.len(), lhs.len() has been proven to be 32 above...)
    let rhs = unsafe { &*(rhs.as_ptr().cast::<[u8; 32]>()) };

    (lhs, rhs)
}

pub(super) const ED25519_OID: ObjectIdentifier = ObjectIdentifier::new_unwrap("1.3.101.112");
pub(super) const K256_OID: ObjectIdentifier = ObjectIdentifier::new_unwrap("1.3.132.0.10");

enum PrivateKeyData {
    Ed25519(ed25519_dalek::SigningKey),
    Ecdsa(k256::ecdsa::SigningKey),
}

impl From<ed25519_dalek::SigningKey> for PrivateKeyData {
    fn from(value: ed25519_dalek::SigningKey) -> Self {
        Self::Ed25519(value)
    }
}

impl From<k256::ecdsa::SigningKey> for PrivateKeyData {
    fn from(value: k256::ecdsa::SigningKey) -> Self {
        Self::Ecdsa(value)
    }
}

/// A private key on the Hiero network.
#[derive(Clone)]
pub struct PrivateKey(Arc<PrivateKeyDataWrapper>);

// find a better name
struct PrivateKeyDataWrapper {
    data: PrivateKeyData,
    chain_code: Option<[u8; 32]>,
}

impl PrivateKeyDataWrapper {
    fn new(inner: PrivateKeyData) -> Self {
        Self { data: inner, chain_code: None }
    }

    fn new_derivable(inner: PrivateKeyData, chain_code: [u8; 32]) -> Self {
        Self { data: inner, chain_code: Some(chain_code) }
    }
}

impl From<ed25519_dalek::SigningKey> for PrivateKeyDataWrapper {
    fn from(value: ed25519_dalek::SigningKey) -> Self {
        Self::new(value.into())
    }
}

impl From<k256::ecdsa::SigningKey> for PrivateKeyDataWrapper {
    fn from(value: k256::ecdsa::SigningKey) -> Self {
        Self::new(value.into())
    }
}

// for usage in tests (provides a way to snapshot test)
impl Debug for PrivateKeyDataWrapper {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        #[derive(Debug)]
        enum Algorithm {
            Ed25519,
            Ecdsa,
        }

        let (algorithm, key) = match &self.data {
            PrivateKeyData::Ed25519(key) => (Algorithm::Ed25519, hex::encode(key.to_bytes())),
            PrivateKeyData::Ecdsa(key) => (Algorithm::Ecdsa, hex::encode(key.to_bytes())),
        };

        f.debug_struct("PrivateKeyData")
            .field("algorithm", &algorithm)
            .field("key", &key)
            .field("chain_code", &self.chain_code.as_ref().map(hex::encode))
            .finish()
    }
}

impl PrivateKey {
    #[cfg(test)]
    pub(crate) fn debug_pretty(&self) -> &impl Debug {
        &*self.0
    }

    fn new(data: PrivateKeyDataWrapper) -> Self {
        Self(Arc::new(data))
    }

    fn new_derivable(key: PrivateKeyData, chain_code: [u8; 32]) -> Self {
        Self::new(PrivateKeyDataWrapper::new_derivable(key, chain_code))
    }

    fn ed25519(key: ed25519_dalek::SigningKey) -> Self {
        Self::new(key.into())
    }

    fn ecdsa(key: k256::ecdsa::SigningKey) -> Self {
        Self::new(key.into())
    }

    /// Generates a new Ed25519 `PrivateKey`.
    #[must_use]
    pub fn generate_ed25519() -> Self {
        use rand::Rng as _;

        let mut csprng = rand::thread_rng();

        let data = ed25519_dalek::SigningKey::generate(&mut csprng);

        Self::new_derivable(data.into(), csprng.gen())
    }

    /// Generates a new ECDSA(secp256k1) `PrivateKey`.
    #[must_use]
    pub fn generate_ecdsa() -> Self {
        let data = k256::ecdsa::SigningKey::random(&mut rand::thread_rng());

        Self::ecdsa(data)
    }

    /// Gets the [`PublicKey`] which corresponds to this `PrivateKey`.
    #[must_use]
    pub fn public_key(&self) -> PublicKey {
        match &self.0.data {
            PrivateKeyData::Ed25519(key) => PublicKey::ed25519(key.verifying_key()),
            PrivateKeyData::Ecdsa(key) => PublicKey::ecdsa(*key.verifying_key()),
        }
    }

    /// Parse a `PrivateKey` from a sequence of bytes.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `bytes` cannot be parsed into a `PrivateKey`.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        if bytes.len() == 32 || bytes.len() == 64 {
            return Self::from_bytes_ed25519(bytes);
        }

        Self::from_bytes_der(bytes)
    }

    /// Parse a Ed25519 `PrivateKey` from a sequence of bytes.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `bytes` cannot be parsed into a ed25519 `PrivateKey`.
    // panic is unreachable.
    #[allow(clippy::missing_panics_doc)]
    pub fn from_bytes_ed25519(bytes: &[u8]) -> crate::Result<Self> {
        match bytes.len() {
            32 | 64 => Ok(Self::ed25519(ed25519_dalek::SigningKey::from_bytes(
                &bytes[..32].try_into().unwrap(),
            ))),
            _ => Self::from_bytes_der(bytes),
        }
    }

    /// Parse a ECDSA(secp256k1) `PrivateKey` from a sequence of bytes.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `bytes` cannot be parsed into a ECDSA(secp256k1) `PrivateKey`.
    pub fn from_bytes_ecdsa(bytes: &[u8]) -> crate::Result<Self> {
        let data = (bytes.len() == 32).then(|| GenericArray::from_slice(bytes));

        let data = if let Some(bytes) = data {
            // not DER encoded, raw bytes for key
            k256::ecdsa::SigningKey::from_bytes(bytes).map_err(Error::key_parse)?
        } else {
            return Self::from_bytes_der(bytes);
        };

        Ok(Self::ecdsa(data))
    }

    /// Parse a `PrivateKey` from a sequence of der encoded bytes.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `bytes` cannot be parsed into a `PrivateKey`.
    pub fn from_bytes_der(bytes: &[u8]) -> crate::Result<Self> {
        let info =
            pkcs8::PrivateKeyInfo::from_der(bytes).map_err(|err| Error::key_parse(err.to_string()));

        let info = match info {
            Ok(info) => info,
            Err(e) => return Self::from_sec1_bytes_der(bytes).ok().ok_or(e),
        };

        // PrivateKey is an `OctetString`, and the `PrivateKey`s we all support are `OctetStrings`.
        // So, we, awkwardly, have an `OctetString` containing an `OctetString` containing our key material.
        let inner = pkcs8::der::asn1::OctetStringRef::from_der(info.private_key)
            .map_err(|err| Error::key_parse(err.to_string()))?;

        let inner = inner.as_bytes();

        match info.algorithm.oid {
            K256_OID => Self::from_bytes_ecdsa(inner),
            ED25519_OID => Self::from_bytes_ed25519(inner),
            id => Err(Error::key_parse(format!("unsupported key algorithm: {id}"))),
        }
    }

    fn from_sec1_bytes_der(bytes: &[u8]) -> crate::Result<Self> {
        let sec1 = EcPrivateKey::try_from(bytes).map_err(Error::key_parse)?;

        match sec1.parameters.and_then(sec1::EcParameters::named_curve) {
            Some(K256_OID) => Self::from_bytes_ecdsa(sec1.private_key),
            Some(oid) => Err(Error::key_parse(format!("unsupported curve OID: {oid}"))),
            None => Err(Error::key_parse("missing curve parameters")),
        }
    }

    /// Parse a `PrivateKey` from a der encoded string.
    ///
    /// Optionally strips a `0x` prefix.
    /// See [`from_bytes_der`](Self::from_bytes_der).
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `s` cannot be parsed into a `PrivateKey`.
    pub fn from_str_der(s: &str) -> crate::Result<Self> {
        Self::from_bytes_der(
            &hex::decode(s.strip_prefix("0x").unwrap_or(s)).map_err(Error::key_parse)?,
        )
    }

    /// Parse a Ed25519 `PrivateKey` from a string containing the raw key material.
    ///
    /// Optionally strips a `0x` prefix.
    /// See: [`from_bytes_ed25519`](Self::from_bytes_ed25519).
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `s` cannot be parsed into a ed25519 `PrivateKey`.
    pub fn from_str_ed25519(s: &str) -> crate::Result<Self> {
        Self::from_bytes_ed25519(
            &hex::decode(s.strip_prefix("0x").unwrap_or(s)).map_err(Error::key_parse)?,
        )
    }

    /// Parse a ECDSA(secp256k1) `PrivateKey` from a string containing the raw key material.
    ///
    /// Optionally strips a `0x` prefix.
    /// See: [`from_str_ecdsa`](Self::from_str_ecdsa).
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `s` cannot be parsed into a ECDSA(secp256k1) `PrivateKey`.
    pub fn from_str_ecdsa(s: &str) -> crate::Result<Self> {
        Self::from_bytes_ecdsa(
            &hex::decode(s.strip_prefix("0x").unwrap_or(s)).map_err(Error::key_parse)?,
        )
    }

    /// Parse a `PrivateKey` from [PEM](https://www.rfc-editor.org/rfc/rfc7468#section-10) encoded bytes.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `pem` is not valid PEM.
    /// - [`Error::KeyParse`] if the type label (BEGIN XYZ) is not `PRIVATE KEY`.
    /// - [`Error::KeyParse`] if the data contained inside the PEM is not a valid `PrivateKey`.
    pub fn from_pem(pem: impl AsRef<[u8]>) -> crate::Result<Self> {
        fn inner(pem: &[u8]) -> crate::Result<PrivateKey> {
            let pem = ::pem::parse(pem).map_err(Error::key_parse)?;

            let type_label = pem.tag();
            let der = pem.contents();

            match type_label {
                "PRIVATE KEY" => PrivateKey::from_bytes_der(der),
                "EC PRIVATE KEY" => PrivateKey::from_sec1_bytes_der(der),
                _ => Err(Error::key_parse(format!(
                    "incorrect PEM type label: expected: `PRIVATE KEY`, got: `{type_label}`"
                ))),
            }
        }

        inner(pem.as_ref())
    }

    /// Parse a `PrivateKey` from encrypted [PEM](https://www.rfc-editor.org/rfc/rfc7468#section-11) encoded bytes.
    /// # Errors
    /// - [`Error::KeyParse`] if `pem` is not valid PEM.
    /// - [`Error::KeyParse`] if the type label (`BEGIN XYZ`) is not `ENCRYPTED PRIVATE KEY`.
    /// - [`Error::KeyParse`] if decrypting the private key fails.
    ///
    /// # Examples
    ///
    /// ```
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// use hedera::PrivateKey;
    /// use hex_literal::hex;
    ///
    /// //  WARNING 
    /// // don't use this private key in your applications, it is compromised by virtue of being here.
    /// let pem = "-----BEGIN ENCRYPTED PRIVATE KEY-----
    /// MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAjeB6TNNQX+1gICCAAw
    /// DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEENfMacg1/Txd/LhKkxZtJe0EQEVL
    /// mez3xb+sfUIF3TKEIDJtw7H0xBNlbAfLxTV11pofiar0z1/WRBHFFUuGIYSiKjlU
    /// V9RQhAnemO84zcZfTYs=
    /// -----END ENCRYPTED PRIVATE KEY-----";
    ///
    /// let password = "test";
    ///
    /// let sk = PrivateKey::from_pem_with_password(pem, password)?;
    ///
    /// let expected_signature = hex!(
    ///     "a0e5f7d1cf06a4334be4f856aeb427f7"
    ///     "fd53ea7e5c66f10eaad083d736a5adfd"
    ///     "0ac7e4fd3fa90f6b6aad8f1df4149ecd"
    ///     "330a91d5ebff832b11bf14d43eaf5600"
    /// );
    /// assert_eq!(sk.sign(b"message").as_slice(), expected_signature.as_slice());
    ///
    /// # Ok(())
    /// # }
    /// ```
    pub fn from_pem_with_password(
        pem: impl AsRef<[u8]>,
        password: impl AsRef<[u8]>,
    ) -> crate::Result<Self> {
        fn inner(pem: &[u8], password: &[u8]) -> crate::Result<PrivateKey> {
            let pem = ::pem::parse(pem).map_err(Error::key_parse)?;

            let type_label = pem.tag();
            let der = pem.contents();

            match type_label {
                "ENCRYPTED PRIVATE KEY" => {
                    // thanks library for not providing a way to check `is_empty`.
                    if let Some(header) = pem.headers().iter().next() {
                        return Err(Error::key_parse(format!("Expected no headers for `ENCRYPTED PRIVATE KEY` but found: `{}: {}`", header.0, header.1)));
                    }

                    let info = pkcs8::EncryptedPrivateKeyInfo::from_der(der)
                        .map_err(|e| Error::key_parse(e.to_string()))?;

                    let decrypted =
                        info.decrypt(password).map_err(|e| Error::key_parse(e.to_string()))?;

                    PrivateKey::from_bytes_der(decrypted.as_bytes())
                }

                "EC PRIVATE KEY" => {
                    let (headers, mut der) = {
                        let mut pem = pem;
                        let headers = mem::take(pem.headers_mut());
                        let  der = pem.into_contents();

                        (headers, der)
                    };

                    let proc_type = headers.get("Proc-Type");
                    let dek_info = headers.get("DEK-Info");

                    if proc_type != Some("4,ENCRYPTED") {
                        return Err(Error::key_parse("Encrypted EC Private Key missing or invalid `Proc-Type` header"));
                    }

                    let Some(dek_info) = dek_info else {
                        return Err(Error::key_parse("Encrypted EC Private Key missing `DEK-Info` header"));
                    };

                    let Some((alg, iv)) = dek_info.split_once(',') else {
                        return Err(Error::key_parse("Invalid `DEK-Info`"));
                    };

                    let iv = hex::decode(iv).map_err(|e| Error::key_parse(format!("invalid IV: {e}")))?;

                    let decrypted = match alg {
                        "AES-128-CBC" => {
                            let iv: [u8; 16] = iv.try_into().map_err(|_| Error::key_parse("invalid IV"))?;


                            let mut md5_sum = md5::Context::new();

                            md5_sum.consume(password);
                            md5_sum.consume(&iv[..8]);

                            let passphrase = md5_sum.compute().0;

                            cbc::Decryptor::<aes::Aes128>::new(&passphrase.into(), &iv.into())
                            .decrypt_padded_mut::<aes::cipher::block_padding::Pkcs7>(&mut der).map_err(|e| Error::key_parse(format!("error decrypting key: {e}")))?
                        }
                        _ => return Err(Error::key_parse(format!("unexpected decryption alg: {alg}")))
                    };

                    PrivateKey::from_sec1_bytes_der(decrypted)
                }

                _ => Err(Error::key_parse(format!(
                    "incorrect PEM type label: expected: `ENCRYPTED PRIVATE KEY`, got: `{type_label}`"
                )))
            }
        }

        inner(pem.as_ref(), password.as_ref())
    }

    /// Return this `PrivateKey`, serialized as der encoded bytes.
    // panic should be impossible (`unreachable`)
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn to_bytes_der(&self) -> Vec<u8> {
        let mut inner = Vec::with_capacity(34);

        pkcs8::der::asn1::OctetStringRef::new(&self.to_bytes_raw_internal())
            .unwrap()
            .encode_to_vec(&mut inner)
            .unwrap();

        let info = pkcs8::PrivateKeyInfo {
            algorithm: self.algorithm(),
            private_key: &inner,
            public_key: None,
        };

        let mut buf = Vec::with_capacity(64);
        info.encode_to_vec(&mut buf).unwrap();

        buf
    }

    /// Return this `PrivateKey`, serialized as bytes.
    ///
    /// If this is an ed25519 private key, this is equivalent to [`to_bytes_raw`](Self::to_bytes_raw)
    /// If this is an ecdsa private key, this is equivalent to [`to_bytes_der`](Self::to_bytes_der)
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        match &self.0.data {
            PrivateKeyData::Ed25519(_) => self.to_bytes_raw(),
            PrivateKeyData::Ecdsa(_) => self.to_bytes_der(),
        }
    }

    /// Return this `PrivateKey`, serialized as bytes.
    #[must_use]
    pub fn to_bytes_raw(&self) -> Vec<u8> {
        self.to_bytes_raw_internal().as_slice().to_vec()
    }

    #[must_use]
    fn to_bytes_raw_internal(&self) -> [u8; 32] {
        match &self.0.data {
            PrivateKeyData::Ed25519(key) => key.to_bytes(),
            PrivateKeyData::Ecdsa(key) => key.to_bytes().into(),
        }
    }

    /// DER encodes self, then hex encodes the result.
    #[must_use]
    pub fn to_string_der(&self) -> String {
        hex::encode(self.to_bytes_der())
    }

    /// Returns the raw bytes of `self` after hex encoding.
    #[must_use]
    pub fn to_string_raw(&self) -> String {
        hex::encode(self.to_bytes_raw_internal())
    }

    /// Creates an [`AccountId`] with the given `shard`, `realm`, and `self.public_key()` as an [`alias`](AccountId::alias).
    ///
    /// # Examples
    ///
    /// ```
    /// use hedera::PrivateKey;
    ///
    /// let key: PrivateKey = "3030020100300706052b8104000a042204208776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048".parse().unwrap();
    ///
    /// let account_id = key.to_account_id(0, 0);
    /// assert_eq!(account_id.to_string(), "0.0.302d300706052b8104000a03220002703a9370b0443be6ae7c507b0aec81a55e94e4a863b9655360bd65358caa6588");
    /// ```
    #[inline(always)]
    #[must_use]
    pub fn to_account_id(&self, shard: u64, realm: u64) -> AccountId {
        self.public_key().to_account_id(shard, realm)
    }

    fn algorithm(&self) -> pkcs8::AlgorithmIdentifierRef<'_> {
        pkcs8::AlgorithmIdentifierRef {
            parameters: None,
            oid: match &self.0.data {
                PrivateKeyData::Ed25519(_) => ED25519_OID,
                PrivateKeyData::Ecdsa(_) => K256_OID,
            },
        }
    }

    /// Returns `true` if `self` is an Ed25519 `PrivateKey`.
    ///
    /// # Examples
    /// ```
    /// use hedera::PrivateKey;
    /// let sk = PrivateKey::generate_ed25519();
    ///
    /// assert!(sk.is_ed25519());
    /// ```
    /// ```
    /// use hedera::PrivateKey;
    /// let sk = PrivateKey::generate_ecdsa();
    ///
    /// assert!(!sk.is_ed25519());
    /// ```
    #[must_use]
    pub fn is_ed25519(&self) -> bool {
        matches!(self.0.data, PrivateKeyData::Ed25519(_))
    }

    /// Returns `true` if this is an ECDSA(secp256k1) `PrivateKey`.
    ///
    /// # Examples
    /// ```
    /// use hedera::PrivateKey;
    /// let sk = PrivateKey::generate_ecdsa();
    ///
    /// assert!(sk.is_ecdsa());
    /// ```
    /// ```
    /// use hedera::PrivateKey;
    /// let sk = PrivateKey::generate_ed25519();
    ///
    /// assert!(!sk.is_ecdsa());
    /// ```
    #[must_use]
    pub fn is_ecdsa(&self) -> bool {
        matches!(self.0.data, PrivateKeyData::Ecdsa(_))
    }

    /// Signs the given `message`.
    #[must_use]
    pub fn sign(&self, message: &[u8]) -> Vec<u8> {
        match &self.0.data {
            PrivateKeyData::Ed25519(key) => key.sign(message).to_bytes().as_slice().to_vec(),
            PrivateKeyData::Ecdsa(key) => {
                let signature: k256::ecdsa::Signature =
                    key.sign_digest(sha3::Keccak256::new_with_prefix(message));

                signature.to_vec()
            }
        }
    }

    // I question the reason for this function existing.
    /// Signs the given transaction.
    ///
    /// # Errors
    /// This function will freeze the transaction if it is not frozen.
    /// As such, any error that can be occur during [`Transaction::freeze`] can also occur here.
    pub fn sign_transaction<D: crate::transaction::TransactionExecute>(
        &self,
        transaction: &mut Transaction<D>,
    ) -> crate::Result<Vec<u8>> {
        transaction.freeze()?;

        let sig = transaction.add_signature_signer(&AnySigner::PrivateKey(self.clone()));

        Ok(sig)
    }

    /// Returns true if calling [`derive`](Self::derive) on `self` would succeed.
    #[must_use]
    pub fn is_derivable(&self) -> bool {
        self.is_ed25519() && self.0.chain_code.is_some()
    }

    /// Derives a child key based on `index`.
    ///
    /// # Errors
    /// - [`Error::KeyDerive`] if this is an Ecdsa key (unsupported operation)
    /// - [`Error::KeyDerive`] if this key has no `chain_code` (key is not derivable)
    // this is specifically for the two `try_into`s which depend on `split_array_ref`.
    // Any panic would indicate a bug in this crate or a dependency of it, not in user code.
    #[allow(clippy::missing_panics_doc)]
    pub fn derive(&self, index: i32) -> crate::Result<Self> {
        const HARDEND_MASK: u32 = 1 << 31;
        let index = index as u32;

        let chain_code =
            self.0.chain_code.as_ref().ok_or_else(|| Error::key_derive("key is underivable"))?;

        match &self.0.data {
            PrivateKeyData::Ed25519(key) => {
                // force hardened.
                let index = index | HARDEND_MASK;

                let output: [u8; 64] = Hmac::<Sha512>::new_from_slice(chain_code)
                    .expect("HMAC can take keys of any size")
                    .chain_update([0])
                    .chain_update(key.to_bytes())
                    .chain_update(index.to_be_bytes())
                    .finalize()
                    .into_bytes()
                    .into();

                // todo: use `split_array_ref` when that's stable.
                let (data, chain_code) = split_key_array(&output);

                let data = ed25519_dalek::SigningKey::from_bytes(data);

                Ok(Self::new_derivable(data.into(), *chain_code))
            }
            PrivateKeyData::Ecdsa(_) => {
                Err(Error::key_derive("Ecdsa private keys don't currently support derivation"))
            }
        }
    }

    // todo: what do we do about i32?
    // It's basically just a cast to support them, but, unlike Java, operator overloading doesn't exist.
    /// Derive a `PrivateKey` based on `index`.
    ///
    /// # Errors
    /// - [`Error::KeyDerive`] if this is an Ecdsa key (unsupported operation)
    //  unaudited cryptography 
    pub fn legacy_derive(&self, index: i64) -> crate::Result<Self> {
        match &self.0.data {
            PrivateKeyData::Ed25519(key) => {
                let entropy = key.to_bytes();
                let mut seed = Vec::with_capacity(entropy.len() + 8);

                seed.extend_from_slice(&entropy);

                let i1: i32 = match index {
                    0x00ff_ffff_ffff => 0xff,
                    0.. => 0,
                    _ => -1,
                };

                let i2 = index as u8;

                seed.extend_from_slice(&i1.to_be_bytes());
                // any better way to do this?
                seed.extend_from_slice(&[i2; 4]);

                let mat = pbkdf2::pbkdf2_hmac_array::<Sha512, 32>(&seed, &[0xff], 2048);

                Ok(Self::ed25519(ed25519_dalek::SigningKey::from_bytes(&mat)))
            }

            PrivateKeyData::Ecdsa(_) => {
                Err(Error::key_derive("Ecdsa private keys don't currently support derivation"))
            }
        }
    }

    #[cfg(feature = "mnemonic")]
    pub(crate) fn from_mnemonic_seed(seed: &[u8]) -> Self {
        let output: [u8; 64] = Hmac::<Sha512>::new_from_slice(b"ed25519 seed")
            .expect("hmac can take a seed of any size")
            .chain_update(seed)
            .finalize()
            .into_bytes()
            .into();

        // todo: use `split_array_ref` when that's stable.
        let (left, right) = {
            let (left, right) = output.split_at(32);
            let left: [u8; 32] = left.try_into().unwrap();
            let right: [u8; 32] = right.try_into().unwrap();
            (left, right)
        };

        let data = ed25519_dalek::SigningKey::from_bytes(&left);

        let mut key = Self::new_derivable(data.into(), right);

        for index in [44, 3030, 0, 0] {
            key = key.derive(index).expect("BUG: we set the chain code earlier in this function");
        }

        key
    }

    /// Recover a `PrivateKey` from a mnemonic phrase and a passphrase.
    // this is specifically for the two `try_into`s which depend on `split_array_ref`.
    // There *is* a 3rd unwrap for a "key is not derivable" error, but we construct a key that _is_ derivable.
    // Any panic would indicate a bug in this crate or a dependency of it, not in user code.
    #[cfg(feature = "mnemonic")]
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn from_mnemonic(mnemonic: &crate::Mnemonic, passphrase: &str) -> Self {
        let seed = mnemonic.to_seed(passphrase);
        Self::from_mnemonic_seed(&seed)
    }

    #[must_use]
    pub(crate) fn _kind(&self) -> super::KeyKind {
        match &self.0.data {
            PrivateKeyData::Ed25519(_) => super::KeyKind::Ed25519,
            PrivateKeyData::Ecdsa(_) => super::KeyKind::Ecdsa,
        }
    }
}

impl Debug for PrivateKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for PrivateKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.pad(&self.to_string_der())
    }
}

impl FromStr for PrivateKey {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::from_bytes(&hex::decode(s.strip_prefix("0x").unwrap_or(s)).map_err(Error::key_parse)?)
    }
}

// TODO: derive (!) - secp256k1
// TODO: legacy_derive (!) - secp256k1
// Filename: src/key/private_key/tests.rs
use std::str::FromStr;

use assert_matches::assert_matches;
use expect_test::expect;
use hex_literal::hex;
use triomphe::Arc;

use super::PrivateKey;
use crate::key::private_key::{
    ED25519_OID,
    K256_OID,
};
use crate::Error;

#[test]
fn ed25519_from_str() {
    const S: &str = "302e020100300506032b65700422042098aa82d6125b5efa04bf8372be7931d05cd77f5ef3330b97d6ee7c006eaaf312";
    let pk = PrivateKey::from_str(S).unwrap();

    assert_eq!(pk.algorithm().oid, ED25519_OID);

    // ensure round-tripping works.
    assert_eq!(pk.to_string(), S);
}

#[test]
fn ecdsa_from_str() {
    const S: &str = "3030020100300706052b8104000a042204208776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048";
    let pk = PrivateKey::from_str(S).unwrap();

    assert_eq!(pk.algorithm().oid, K256_OID);

    assert_eq!(pk.to_string(), S);
}

#[test]
fn ed25519_sign() {
    let private_key = PrivateKey::from_str(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10",
    )
    .unwrap();

    let signature = private_key.sign(b"hello, world");
    expect![[r#"
        "9d04bfed7baa97c80d29a6ae48c0d896ce8463a7ea0c16197d55a563c73996ef062b2adf507f416c108422c0310fc6fb21886e11ce3de3e951d7a56049743f07"
    "#]]
        .assert_debug_eq(&hex::encode(signature));
}

#[test]
fn ecdsa_sign() {
    let private_key = PrivateKey::from_str(
        "3030020100300706052b8104000a042204208776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048"
    )
    .unwrap();

    // notice that this doesn't match other impls
    // this is to avoid signature malleability.
    // see: https://github.com/bitcoin/bips/blob/43da5dec5eaf0d8194baa66ba3dd976f923f9d07/bip-0062.mediawiki
    let signature = private_key.sign(b"hello world");
    expect![[r#"
        "f3a13a555f1f8cd6532716b8f388bd4e9d8ed0b252743e923114c0c6cbfe414c086e3717a6502c3edff6130d34df252fb94b6f662d0cd27e2110903320563851"
    "#]]
    .assert_debug_eq(&hex::encode(signature));
}

#[test]
fn ed25519_legacy_derive() {
    // private key was lifted from a Mnemonic test.
    let private_key = PrivateKey::from_str(
        "302e020100300506032b65700422042098aa82d6125b5efa04bf8372be7931d05cd77f5ef3330b97d6ee7c006eaaf312",
    )
    .unwrap();

    let private_key_0 = private_key.legacy_derive(0).unwrap();

    assert_eq!(private_key_0.to_string(), "302e020100300506032b6570042204202b7345f302a10c2a6d55bf8b7af40f125ec41d780957826006d30776f0c441fb");

    let private_key_neg_1 = private_key.legacy_derive(-1).unwrap();

    assert_eq!(private_key_neg_1.to_string(), "302e020100300506032b657004220420caffc03fdb9853e6a91a5b3c57a5c0031d164ce1c464dea88f3114786b5199e5");
}

#[test]
fn ed25519_legacy_derive_2() {
    let private_key = PrivateKey::from_str(
        "302e020100300506032b65700422042000c2f59212cb3417f0ee0d38e7bd876810d04f2dd2cb5c2d8f26ff406573f2bd",
    )
    .unwrap();

    let private_key_mhw = private_key.legacy_derive(0x00ff_ffff_ffff).unwrap();

    assert_eq!(private_key_mhw.to_string(), "302e020100300506032b6570042204206890dc311754ce9d3fc36bdf83301aa1c8f2556e035a6d0d13c2cccdbbab1242")
}

/// This is for testing purposes only.
///
/// # Panics
/// If `data` and `chain_code` don't make a valid [`PrivateKey`].
fn key_with_chain(data: &str, chain_code: [u8; 32]) -> PrivateKey {
    let mut key = PrivateKey::from_str(data).unwrap();

    // note: we create the key here, so, there shouldn't be any other references to it.
    Arc::get_mut(&mut key.0).unwrap().chain_code = Some(chain_code);

    key
}

// "iosKey"
#[test]
fn ed25519_derive_1() {
    // have to create a private key with a chain code, which means... Hacks!
    // luckily, we're a unit test, so, we can access private fields.
    let key = key_with_chain(
        "302e020100300506032b657004220420a6b9548d7e123ad4c8bc6fee58301e9b96360000df9d03785c07b620569e7728",
        hex!("cde7f535264f1db4e2ded409396f8c72f8075cc43757bd5a205c97699ea40271"),
    );

    let child_key = key.derive(0).unwrap();

    expect![[r#"
            PrivateKeyData {
                algorithm: Ed25519,
                key: "5f66a51931e8c99089472e0d70516b6272b94dd772b967f8221e1077f966dbda",
                chain_code: Some(
                    "0e5c869c1cf9daecd03edb2d49cf2621412578a352578a4bb7ef4eef2942b7c9",
                ),
            }
        "#]]
    .assert_debug_eq(&*child_key.0);
}

// "androidKey"
#[test]
fn ed25519_derive_2() {
    let key = key_with_chain(
        "302e020100300506032b65700422042097dbce1988ef8caf5cf0fd13a5374969e2be5f50650abd19314db6b32f96f18e",
        hex!("b7b406314eb2224f172c1907fe39f807e306655e81f2b3bc4766486f42ef1433")
    );
    let child_key = key.derive(0).unwrap();

    expect![[r#"
            PrivateKeyData {
                algorithm: Ed25519,
                key: "c284c25b3a1458b59423bc289e83703b125c8eefec4d5aa1b393c2beb9f2bae6",
                chain_code: Some(
                    "a7a1c2d115a988e51efc12c23692188a4796b312a4a700d6c703e4de4cf1a7f6",
                ),
            }
        "#]]
    .assert_debug_eq(&child_key.0);
}

#[test]
fn ed25519_from_pem() {
    const PEM: &[u8] = br#"-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEINtIS4KOZLLY8SzjwKDpOguMznrxu485yXcyOUSCU44Q
-----END PRIVATE KEY-----"#;

    let pk = PrivateKey::from_pem(PEM).unwrap();

    assert_eq!(pk.to_string(), "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
}

#[test]
fn ed25519_from_pem_with_password() {
    const PEM: &[u8] = b"-----BEGIN ENCRYPTED PRIVATE KEY-----
MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAjeB6TNNQX+1gICCAAw
DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEENfMacg1/Txd/LhKkxZtJe0EQEVL
mez3xb+sfUIF3TKEIDJtw7H0xBNlbAfLxTV11pofiar0z1/WRBHFFUuGIYSiKjlU
V9RQhAnemO84zcZfTYs=
-----END ENCRYPTED PRIVATE KEY-----";

    let pk = PrivateKey::from_pem_with_password(PEM, "test").unwrap();

    assert_eq!(pk.to_string(), "302e020100300506032b6570042204208d8df406a762e36dfbf6dda2239f38a266db369e09bca6a8569e9e79b4826152");
}

#[test]
fn ecdsa_from_pem() {
    const PEM: &[u8] = br#"-----BEGIN PRIVATE KEY-----
MDACAQAwBwYFK4EEAAoEIgQgh3bGuDGhthrBDawDBKKEPeRxb1SxkZu5GiaF0P4/
MEg=
-----END PRIVATE KEY-----"#;

    let pk = PrivateKey::from_pem(PEM).unwrap();

    assert_eq!(pk.to_string(), "3030020100300706052b8104000a042204208776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048");
}

#[test]
fn ed25519_from_pem_invalid_type_label() {
    // extra `S` in the type label
    const PEM: &[u8] = br#"-----BEGIN PRIVATE KEYS-----
MC4CAQAwBQYDK2VwBCIEINtIS4KOZLLY8SzjwKDpOguMznrxu485yXcyOUSCU44Q
-----END PRIVATE KEYS-----"#;

    assert_matches!(PrivateKey::from_pem(PEM), Err(Error::KeyParse(_)));
}

#[test]
fn ed25519_pkcs8_unencrypted_pem() {
    const S: &str = r"-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEIOgbjaHgEqF7PY0t2dUf2VU0u1MRoKii/fywDlze4lvl
-----END PRIVATE KEY-----";

    let pk = PrivateKey::from_pem(S).unwrap();

    assert_eq!(pk.algorithm().oid, ED25519_OID);
    assert_eq!(
        pk.to_string_raw(),
        "e81b8da1e012a17b3d8d2dd9d51fd95534bb5311a0a8a2fdfcb00e5cdee25be5"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "f7b9aa4a8e4eee94e4277dfe757d8d7cde027e7cd5349b7d8e6ee21c9b9395be"
    );
}

#[test]
fn ecdsa_ec_unencrypted_uncompressed_pem() {
    const S: &str = r"-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIG8I+jKi+iGVa7ttbfnlnML5AdvPugbgBWnseYjrle6qoAcGBSuBBAAK
oUQDQgAEqf5BmMeBzkU1Ra9UAbZJo3tytVOlb7erTc36LRLP20mOLU7+mFY+3Cfe
fAZgBtPXRAmDtRvYGODswAalW85GKA==
-----END EC PRIVATE KEY-----";

    let pk = PrivateKey::from_pem(S).unwrap();

    assert_eq!(pk.algorithm().oid, K256_OID);
    assert_eq!(
        pk.to_string_raw(),
        "6f08fa32a2fa21956bbb6d6df9e59cc2f901dbcfba06e00569ec7988eb95eeaa"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "02a9fe4198c781ce453545af5401b649a37b72b553a56fb7ab4dcdfa2d12cfdb49"
    );
}

#[test]
fn ecdsa_ec_unencrypted_compressed_pem() {
    const S: &str = r"-----BEGIN EC PRIVATE KEY-----
MFQCAQEEIOHyhclwHbha3f281Kvd884rhBzltxGJxCZyaQCagH9joAcGBSuBBAAK
oSQDIgACREr6gFZa4K7hBP+bA25VdgQ+0ABFgM+g5RYw/W6T1Og=
-----END EC PRIVATE KEY-----";
    let pk = PrivateKey::from_pem(S).unwrap();

    assert_eq!(pk.algorithm().oid, K256_OID);
    assert_eq!(
        pk.to_string_raw(),
        "e1f285c9701db85addfdbcd4abddf3ce2b841ce5b71189c4267269009a807f63"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "02444afa80565ae0aee104ff9b036e5576043ed0004580cfa0e51630fd6e93d4e8"
    );
}

#[test]
fn ed25519_pkcs8_encrypted_pem() {
    const S: &str = r"-----BEGIN ENCRYPTED PRIVATE KEY-----
MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAiho4GvPxvL6wICCAAw
DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEIdsubXR0QvxXGSprqDuDXwEQJZl
OBtwm2p2P7WrWE0OnjGxUe24fWwdrvJUuguFtH3FVWc8C5Jbxgbyxsuzbf+utNL6
0ey+WdbGL06Bw0HGqs8=
-----END ENCRYPTED PRIVATE KEY-----";
    let pk = PrivateKey::from_pem_with_password(S, "asdasd123").unwrap();

    assert_eq!(pk.algorithm().oid, ED25519_OID);
    assert_eq!(
        pk.to_string_raw(),
        "fa0857e963946d5f5e035684c40354d3cd3dcc80c0fb77beac2ef7c4b5271599"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "202af61e141465d4bf2c356d37d18bd026c246bde4eb73258722ad11f790be4e"
    );
}

#[test]
fn ecdsa_ec_encrypted_uncompressed_pem() {
    const S: &str = r"-----BEGIN EC PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,0046A9EED8D16F0CAA66A197CE8BE8BD

9VU9gReUmrn4XywjMx0F0A3oGzpHIksEXma72TCSdcxI7zHy0mtzuGq4Wd25O38s
H9c6kvhTPS1N/c6iNhx154B0HUoND8jvAvfxbGR/R87vpZJsOoKCmRxGqrxG8HER
FIHQ1jy16DrAbU95kDyLsiF1dy2vUY/HoqFZwxl/IVc=
-----END EC PRIVATE KEY-----";

    let pk = PrivateKey::from_pem_with_password(S, "asdasd123").unwrap();

    assert_eq!(pk.algorithm().oid, K256_OID);
    assert_eq!(
        pk.to_string_raw(),
        "cf49eb5206c1b0468854d6ea7b370590619625514f71ff93608a18465e4012ad"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "025f0d14a7562d6319e5b8f91620d2ce9ad13d9abf21cfe9bd0a092c0f35bf1701"
    );
}

#[test]
fn ecdsa_ec_encrypted_compressed_pem() {
    const S: &str = r"-----BEGIN EC PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,4A9B3B987EC2EFFA405818327D14FFF7

Wh756RkK5fn1Ke2denR1OYfqE9Kr4BXhgrEMTU/6o0SNhMULUhWGHrCWvmNeEQwp
ZVZYUxgYoTlJBeREzKAZithcvxIcTbQfLABo1NZbjA6YKqAqlGpM6owwL/f9e2ST
-----END EC PRIVATE KEY-----";
    let pk = PrivateKey::from_pem_with_password(S, "asdasd123").unwrap();

    assert_eq!(pk.algorithm().oid, K256_OID);
    assert_eq!(
        pk.to_string_raw(),
        "c0d3e16ba5a1abbeac4cd327a3c3c1cc10438431d0bac019054e573e67768bb5"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "02065f736378134c53c7a2ee46f199fb93b9b32337be4e95660677046476995544"
    );
}

#[test]
fn ed25519_pkcs8_der_private_key() {
    const S: &str = "302e020100300506032b657004220420feb858a4a69600a5eef2d9c76f7fb84fc0b6627f29e0ab17e160f640c267d404";

    let pk = PrivateKey::from_str_der(S).unwrap();

    assert_eq!(pk.algorithm().oid, ED25519_OID);
    assert_eq!(
        pk.to_string_raw(),
        "feb858a4a69600a5eef2d9c76f7fb84fc0b6627f29e0ab17e160f640c267d404"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "8ccd31b53d1835b467aac795dab19b274dd3b37e3daf12fcec6bc02bac87b53d"
    );
}

#[test]
fn ecdsa_pkcs8_private_key_der() {
    const S: &str = "3030020100300706052b8104000a042204208c2cdc9575fe67493443967d74958fd7808a3787fd3337e99cfeebbc7566b586";

    let pk = PrivateKey::from_str_der(S).unwrap();

    assert_eq!(pk.algorithm().oid, K256_OID);
    assert_eq!(
        pk.to_string_raw(),
        "8c2cdc9575fe67493443967d74958fd7808a3787fd3337e99cfeebbc7566b586"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "028173079d2e996ef6b2d064fc82d5fc7094367211e28422bec50a2f75c365f5fd"
    );
}

#[test]
fn ecdsa_ec_private_key_compressed_der() {
    const S: &str = "30540201010420ac318ea8ff8d991ab2f16172b4738e74dc35a56681199cfb1c0cb2e7cb560ffda00706052b8104000aa124032200036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4";

    let pk = PrivateKey::from_str_der(S).unwrap();

    assert_eq!(pk.algorithm().oid, K256_OID);
    assert_eq!(
        pk.to_string_raw(),
        "ac318ea8ff8d991ab2f16172b4738e74dc35a56681199cfb1c0cb2e7cb560ffd"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4"
    );
}

#[test]
fn ecdsa_ec_private_key_uncompressed_der() {
    const S: &str = "307402010104208927647ad12b29646a1d051da8453462937bb2c813c6815cac6c0b720526ffc6a00706052b8104000aa14403420004aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a6597795f855ddcad2377e22259d1fcb4e0f1d35e8f2056300c15070bcbfce3759cc9d";

    let pk = PrivateKey::from_str_der(S).unwrap();

    assert_eq!(pk.algorithm().oid, K256_OID);
    assert_eq!(
        pk.to_string_raw(),
        "8927647ad12b29646a1d051da8453462937bb2c813c6815cac6c0b720526ffc6"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "03aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a65977"
    );
}

#[test]
fn ecdsa_ec_private_key_no_public_key_der() {
    const S: &str = "302e0201010420a6170a6aa6389a5bd3a3a8f9375f57bd91aa7f7d8b8b46ce0b702e000a21a5fea00706052b8104000a";

    let pk = PrivateKey::from_str_der(S).unwrap();

    assert_eq!(pk.algorithm().oid, K256_OID);
    assert_eq!(
        pk.to_string_raw(),
        "a6170a6aa6389a5bd3a3a8f9375f57bd91aa7f7d8b8b46ce0b702e000a21a5fe"
    );
    assert_eq!(
        pk.public_key().to_string_raw(),
        "03b69a75a5ddb1c0747e995d47555019e5d8a28003ab5202bd92f534361fb4ec8a"
    );
}
// Filename: src/key/public_key/mod.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::hash::{
    Hash,
    Hasher,
};
use std::str::FromStr;

use ed25519_dalek::Verifier as _;
use hedera_proto::services;
use hmac::digest::generic_array::sequence::Split;
use hmac::digest::generic_array::GenericArray;
use k256::ecdsa;
use k256::ecdsa::signature::DigestVerifier as _;
use pkcs8::der::asn1::BitStringRef;
use pkcs8::der::{
    Decode,
    Encode,
};
use pkcs8::ObjectIdentifier;
use prost::Message;
use sha2::Digest;

use crate::key::private_key::{
    ED25519_OID,
    K256_OID,
};
use crate::protobuf::ToProtobuf;
use crate::signer::AnySigner;
use crate::transaction::TransactionSources;
use crate::{
    AccountId,
    Error,
    EvmAddress,
    FromProtobuf,
    Transaction,
};

#[cfg(test)]
mod tests;

pub(super) const EC_ALGORITM_OID: ObjectIdentifier =
    ObjectIdentifier::new_unwrap("1.2.840.10045.2.1");

/// A public key on the Hiero network.
#[derive(Clone, Eq, Copy, Hash, PartialEq)]
pub struct PublicKey(PublicKeyData);

#[derive(Clone, Copy)]
enum PublicKeyData {
    Ed25519(ed25519_dalek::VerifyingKey),
    Ecdsa(k256::ecdsa::VerifyingKey),
}

impl Hash for PublicKeyData {
    fn hash<H: Hasher>(&self, state: &mut H) {
        core::mem::discriminant(self).hash(state);
        match &self {
            PublicKeyData::Ed25519(key) => key.to_bytes().hash(state),
            PublicKeyData::Ecdsa(key) => key.to_encoded_point(true).as_bytes().hash(state),
        }
    }
}

impl PartialEq for PublicKeyData {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Ed25519(l0), Self::Ed25519(r0)) => l0 == r0,
            (Self::Ecdsa(l0), Self::Ecdsa(r0)) => l0 == r0,
            _ => false,
        }
    }
}

impl Eq for PublicKeyData {}

impl PublicKey {
    pub(super) fn ed25519(key: ed25519_dalek::VerifyingKey) -> Self {
        Self(PublicKeyData::Ed25519(key))
    }

    pub(super) fn ecdsa(key: k256::ecdsa::VerifyingKey) -> Self {
        Self(PublicKeyData::Ecdsa(key))
    }

    /// Returns `true` if the public key is `Ed25519`.
    #[must_use]
    pub fn is_ed25519(&self) -> bool {
        matches!(&self.0, PublicKeyData::Ed25519(_))
    }

    /// Returns `true` if the public key data is `Ecdsa`.
    #[must_use]
    pub fn is_ecdsa(&self) -> bool {
        matches!(&self.0, PublicKeyData::Ecdsa(_))
    }

    pub(crate) fn from_alias_bytes(bytes: &[u8]) -> crate::Result<Option<Self>> {
        if bytes.is_empty() {
            return Ok(None);
        }
        Ok(Some(PublicKey::from_protobuf(
            services::Key::decode(bytes).map_err(Error::from_protobuf)?,
        )?))
    }

    /// Parse a `PublicKey` from a sequence of bytes.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `bytes` cannot be parsed into a `PublicKey`.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        if bytes.len() == 32 {
            return Self::from_bytes_ed25519(bytes);
        }

        if bytes.len() == 33 {
            return Self::from_bytes_ecdsa(bytes);
        }

        Self::from_bytes_der(bytes)
    }

    /// Parse a Ed25519 `PublicKey` from a sequence of bytes.   
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `bytes` cannot be parsed into a ed25519 `PublicKey`.
    pub fn from_bytes_ed25519(bytes: &[u8]) -> crate::Result<Self> {
        let data = if let Ok(bytes) = bytes.try_into() {
            ed25519_dalek::VerifyingKey::from_bytes(bytes).map_err(Error::key_parse)?
        } else {
            return Self::from_bytes_der(bytes);
        };

        Ok(Self::ed25519(data))
    }

    /// Parse a ECDSA(secp256k1) `PublicKey` from a sequence of bytes.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `bytes` cannot be parsed into a ECDSA(secp256k1) `PublicKey`.
    pub fn from_bytes_ecdsa(bytes: &[u8]) -> crate::Result<Self> {
        let data = if bytes.len() == 32 + 1 || bytes.len() == 32 * 2 + 1 {
            k256::ecdsa::VerifyingKey::from_sec1_bytes(bytes).map_err(Error::key_parse)?
        } else {
            return Self::from_bytes_der(bytes);
        };

        Ok(Self::ecdsa(data))
    }

    /// Parse a `PublicKey` from a sequence of der encoded bytes.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `bytes` cannot be parsed into a `PublicKey`.
    pub fn from_bytes_der(bytes: &[u8]) -> crate::Result<Self> {
        let info = pkcs8::SubjectPublicKeyInfoRef::from_der(bytes)
            .map_err(|err| Error::key_parse(err.to_string()))?;

        let bytes = info
            .subject_public_key
            .as_bytes()
            .ok_or_else(|| Error::key_parse("Unexpected bitstring len"))?;

        match info.algorithm.oid {
            K256_OID => Self::from_bytes_ecdsa(bytes),
            EC_ALGORITM_OID if info.algorithm.parameters_oid().ok() == Some(K256_OID) => {
                Self::from_bytes_ecdsa(bytes)
            }
            ED25519_OID => Self::from_bytes_ed25519(bytes),
            oid => Err(Error::key_parse(format!("unsupported key algorithm: {oid}"))),
        }
    }

    /// Decodes `self` from a der encoded `str`
    ///
    /// Optionally strips a `0x` prefix.
    /// See [`from_bytes_der`](Self::from_bytes_der)
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `s` cannot be parsed into a `PublicKey`.
    pub fn from_str_der(s: &str) -> crate::Result<Self> {
        Self::from_bytes_der(
            &hex::decode(s.strip_prefix("0x").unwrap_or(s)).map_err(Error::key_parse)?,
        )
    }

    /// Parse a Ed25519 `PublicKey` from a string containing the raw key material.
    ///
    /// Optionally strips a `0x` prefix.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `s` cannot be parsed into a ed25519 `PublicKey`.
    pub fn from_str_ed25519(s: &str) -> crate::Result<Self> {
        Self::from_bytes_ed25519(
            &hex::decode(s.strip_prefix("0x").unwrap_or(s)).map_err(Error::key_parse)?,
        )
    }

    /// Parse a ECDSA(secp256k1) `PublicKey` from a string containing the raw key material.
    ///
    /// Optionally strips a `0x` prefix.
    ///
    /// # Errors
    /// - [`Error::KeyParse`] if `s` cannot be parsed into a Ecdsa(secp256k1) `PublicKey`.
    pub fn from_str_ecdsa(s: &str) -> crate::Result<Self> {
        Self::from_bytes_ecdsa(
            &hex::decode(s.strip_prefix("0x").unwrap_or(s)).map_err(Error::key_parse)?,
        )
    }

    /// Return this `PublicKey`, serialized as bytes.
    ///
    /// If this is an ed25519 public key, this is equivalent to [`to_bytes_raw`](Self::to_bytes_raw)
    /// If this is an ecdsa public key, this is equivalent to [`to_bytes_der`](Self::to_bytes_der)
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        match &self.0 {
            PublicKeyData::Ed25519(_) => self.to_bytes_raw(),
            PublicKeyData::Ecdsa(_) => self.to_bytes_der(),
        }
    }

    /// Return this `PublicKey`, serialized as der-encoded bytes.
    // panic should be impossible (`unreachable`)
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn to_bytes_der(&self) -> Vec<u8> {
        let mut buf = Vec::with_capacity(64);

        match &self.0 {
            PublicKeyData::Ed25519(key) => {
                let key = key.to_bytes();
                let info = pkcs8::SubjectPublicKeyInfoRef {
                    algorithm: self.algorithm(),
                    subject_public_key: BitStringRef::from_bytes(&key).unwrap(),
                };

                info.encode_to_vec(&mut buf).unwrap();
            }

            PublicKeyData::Ecdsa(key) => {
                let key = key.to_encoded_point(true);
                let info = pkcs8::SubjectPublicKeyInfoRef {
                    algorithm: self.algorithm(),
                    subject_public_key: BitStringRef::from_bytes(key.as_bytes()).unwrap(),
                };

                info.encode_to_vec(&mut buf).unwrap();
            }
        }

        buf
    }

    fn algorithm(&self) -> pkcs8::AlgorithmIdentifierRef<'_> {
        pkcs8::AlgorithmIdentifierRef {
            parameters: None,
            oid: match self.0 {
                PublicKeyData::Ed25519(_) => ED25519_OID,
                PublicKeyData::Ecdsa(_) => K256_OID,
            },
        }
    }

    /// Return this `PublicKey`, serialized as bytes.
    #[must_use]
    pub fn to_bytes_raw(&self) -> Vec<u8> {
        match &self.0 {
            PublicKeyData::Ed25519(key) => key.to_bytes().as_slice().to_vec(),
            PublicKeyData::Ecdsa(key) => key.to_encoded_point(true).to_bytes().into_vec(),
        }
    }

    /// DER encodes self, then hex encodes the result.
    #[must_use]
    pub fn to_string_der(&self) -> String {
        hex::encode(self.to_bytes_der())
    }

    /// Returns the raw bytes of `self` after hex encoding.
    #[must_use]
    pub fn to_string_raw(&self) -> String {
        hex::encode(self.to_bytes_raw())
    }

    /// Creates an [`AccountId`] with the given `shard`, `realm`, and `self` as an [`alias`](AccountId.alias).
    ///
    /// # Examples
    ///
    /// ```
    /// use hedera::PublicKey;
    ///
    /// let key: PublicKey = "302d300706052b8104000a03220002703a9370b0443be6ae7c507b0aec81a55e94e4a863b9655360bd65358caa6588".parse().unwrap();
    ///
    /// let account_id = key.to_account_id(0, 0);
    /// assert_eq!(account_id.to_string(), "0.0.302d300706052b8104000a03220002703a9370b0443be6ae7c507b0aec81a55e94e4a863b9655360bd65358caa6588");
    /// ```
    #[must_use]
    pub fn to_account_id(&self, shard: u64, realm: u64) -> AccountId {
        AccountId { shard, realm, alias: Some(*self), evm_address: None, num: 0, checksum: None }
    }

    /// Convert this public key into an evm address.
    /// The EVM address is This is the rightmost 20 bytes of the 32 byte Keccak-256 hash of the ECDSA public key.
    ///
    /// Returns `Some(evm_address)` if `self.is_ecdsa`, otherwise `None`.
    #[must_use]
    pub fn to_evm_address(&self) -> Option<EvmAddress> {
        if let PublicKeyData::Ecdsa(ecdsa_key) = &self.0 {
            // we specifically want the uncompressed form ...
            let encoded_point = ecdsa_key.to_encoded_point(false);
            let bytes = encoded_point.as_bytes();
            // ... and without the tag (04):
            let bytes = &bytes[1..];
            let hash = sha3::Keccak256::digest(bytes);

            let (_, sliced): (GenericArray<u8, hmac::digest::typenum::U12>, _) = hash.split();

            let sliced: [u8; 20] = sliced.into();
            Some(EvmAddress::from(sliced))
        } else {
            None
        }
    }

    /// Verify a `signature` on a `msg` with this public key.
    ///
    /// # Errors
    /// - [`Error::SignatureVerify`] if the signature algorithm doesn't match this `PublicKey`.
    /// - [`Error::SignatureVerify`] if the signature is invalid for this `PublicKey`.
    pub fn verify(&self, msg: &[u8], signature: &[u8]) -> crate::Result<()> {
        match &self.0 {
            PublicKeyData::Ed25519(key) => {
                let signature = ed25519_dalek::Signature::try_from(signature)
                    .map_err(Error::signature_verify)?;

                key.verify(msg, &signature).map_err(Error::signature_verify)
            }
            PublicKeyData::Ecdsa(key) => {
                let signature =
                    ecdsa::Signature::try_from(signature).map_err(Error::signature_verify)?;

                key.verify_digest(sha3::Keccak256::new_with_prefix(msg), &signature)
                    .map_err(Error::signature_verify)
            }
        }
    }

    pub(crate) fn verify_transaction_sources(
        &self,
        sources: &TransactionSources,
    ) -> crate::Result<()> {
        use services::signature_pair::Signature;
        let pk_bytes = self.to_bytes_raw();

        for signed_transaction in sources.signed_transactions() {
            let mut found = false;
            for sig_pair in
                signed_transaction.sig_map.as_ref().map_or_else(|| [].as_slice(), |it| &it.sig_pair)
            {
                if !pk_bytes.starts_with(&sig_pair.pub_key_prefix) {
                    continue;
                }

                found = true;
                let Some(Signature::EcdsaSecp256k1(sig) | Signature::Ed25519(sig)) =
                    &sig_pair.signature
                else {
                    return Err(Error::signature_verify("Unsupported transaction signature type"));
                };

                self.verify(&signed_transaction.body_bytes, sig)?;
            }

            if !found {
                return Err(Error::signature_verify("signer not in transaction"));
            }
        }

        Ok(())
    }

    /// Returns `Ok(())` if this public key has signed the given transaction.
    ///
    /// # Errors
    /// - [`Error::SignatureVerify`] if the private key associated with this public key did _not_ sign this transaction,
    ///   or the signature associated was invalid.
    pub fn verify_transaction<D: crate::transaction::TransactionExecute>(
        &self,
        transaction: &mut Transaction<D>,
    ) -> crate::Result<()> {
        if transaction.signers().map(AnySigner::public_key).any(|it| self == &it) {
            return Ok(());
        }

        transaction.freeze()?;

        let Some(sources) = transaction.sources() else {
            return Err(Error::signature_verify("signer not in transaction"));
        };

        self.verify_transaction_sources(sources)
    }

    #[must_use]
    pub(crate) fn kind(&self) -> super::KeyKind {
        match &self.0 {
            PublicKeyData::Ed25519(_) => super::KeyKind::Ed25519,
            PublicKeyData::Ecdsa(_) => super::KeyKind::Ecdsa,
        }
    }
}

impl Debug for PublicKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for PublicKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.pad(&self.to_string_der())
    }
}

impl FromStr for PublicKey {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::from_bytes(&hex::decode(s.strip_prefix("0x").unwrap_or(s)).map_err(Error::key_parse)?)
    }
}

impl FromProtobuf<services::Key> for PublicKey {
    fn from_protobuf(pb: services::Key) -> crate::Result<Self>
    where
        Self: Sized,
    {
        use services::key::Key::*;

        match pb.key {
            Some(Ed25519(bytes)) => PublicKey::from_bytes_ed25519(&bytes),
            Some(ContractId(_)) => {
                Err(Error::from_protobuf("unexpected unsupported Contract ID key in single key"))
            }
            Some(DelegatableContractId(_)) => Err(Error::from_protobuf(
                "unexpected unsupported Delegatable Contract ID key in single key",
            )),
            Some(Rsa3072(_)) => {
                Err(Error::from_protobuf("unexpected unsupported RSA-3072 key in single key"))
            }
            Some(Ecdsa384(_)) => {
                Err(Error::from_protobuf("unexpected unsupported ECDSA-384 key in single key"))
            }
            Some(ThresholdKey(_)) => {
                Err(Error::from_protobuf("unexpected threshold key as single key"))
            }
            Some(KeyList(_)) => Err(Error::from_protobuf("unexpected key list as single key")),
            Some(EcdsaSecp256k1(bytes)) => PublicKey::from_bytes_ecdsa(&bytes),
            None => Err(Error::from_protobuf("unexpected empty key in single key")),
        }
    }
}

impl ToProtobuf for PublicKey {
    type Protobuf = services::Key;

    fn to_protobuf(&self) -> Self::Protobuf {
        let key = match self.kind() {
            super::KeyKind::Ed25519 => services::key::Key::Ed25519(self.to_bytes_raw()),
            super::KeyKind::Ecdsa => services::key::Key::EcdsaSecp256k1(self.to_bytes_raw()),
        };

        Self::Protobuf { key: Some(key) }
    }
}

// TODO: to_protobuf
// TODO: verify_transaction
// Filename: src/key/public_key/tests.rs
// SPDX-License-Identifier: Apache-2.0

use std::str::FromStr;

use assert_matches::assert_matches;
use expect_test::expect;
use hex_literal::hex;

use crate::{
    EvmAddress,
    PrivateKey,
    PublicKey,
};

#[test]
fn ed25519_from_str() {
    const PK: &str =
        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7";

    let pk = PublicKey::from_str(PK).unwrap();

    assert_eq!(PK, &pk.to_string())
}

#[test]
fn ecdsa_from_str() {
    const PK: &str = "302d300706052b8104000a03220002703a9370b0443be6ae7c507b0aec81a55e94e4a863b9655360bd65358caa6588";

    let pk = PublicKey::from_str(PK).unwrap();

    assert_eq!(PK, &pk.to_string());
}

#[track_caller]
fn pk_from_str_variants(key: &str) {
    // a very low tech solution, but it works!
    for case in 0..4 {
        let prefix = case & 1 == 0;
        let uppercase = (case >> 1) & 1 == 1;
        let prefix = if prefix { "0x" } else { "" };
        let pk = if uppercase { key.to_uppercase() } else { key.to_lowercase() };

        let pk = format!("{prefix}{pk}");
        let pk = PublicKey::from_str(&pk).unwrap();

        assert_eq!(key, &pk.to_string())
    }
}

#[test]
fn ed25519_from_str_variants() {
    pk_from_str_variants(
        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
    );
}

#[test]
fn ecdsa_from_str_variants() {
    pk_from_str_variants("302d300706052b8104000a03220002703a9370b0443be6ae7c507b0aec81a55e94e4a863b9655360bd65358caa6588");
}

// copied from Java SDK to ensure conformance.
#[test]
fn to_evm_address() {
    let key = PrivateKey::from_str_ecdsa(
        "debae3ca62ab3157110dba79c8de26540dc320ee9be73a77d70ba175643a3500",
    )
    .unwrap()
    .public_key();

    let evm_address = key.to_evm_address().unwrap();

    assert_eq!(evm_address, EvmAddress(hex!("d8eb8db03c699faa3f47adcdcd2ae91773b10f8b")));
}

#[test]
fn to_evm_address_2() {
    let key = PublicKey::from_str_ecdsa(
        "029469a657510f3bf199a0e29b21e11e7039d8883f3547d59c3568f9c89f704cbc",
    )
    .unwrap();
    let evm_address = key.to_evm_address().unwrap();

    assert_eq!(evm_address, EvmAddress(hex!("bbaa6bdfe888ae1fc8e7c8cee82081fa79ba8834")));
}

#[test]
fn ed25519_verify() {
    let pk = PublicKey::from_str(
        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
    )
    .unwrap();

    let signature = hex!(
        "9d04bfed7baa97c80d29a6ae48c0d896ce8463a7ea0c16197d55a563c73996ef"
        "062b2adf507f416c108422c0310fc6fb21886e11ce3de3e951d7a56049743f07"
    );

    pk.verify(b"hello, world", &signature).unwrap();
}

#[test]
fn ecdsa_verify() {
    let pk = PublicKey::from_str(
  "302d300706052b8104000a03220002703a9370b0443be6ae7c507b0aec81a55e94e4a863b9655360bd65358caa6588"
  )
  .unwrap();

    // notice that this doesn't match other impls
    // this is to avoid signature malleability.
    // see: https://github.com/bitcoin/bips/blob/43da5dec5eaf0d8194baa66ba3dd976f923f9d07/bip-0032.mediawiki
    let signature = hex!(
        "f3a13a555f1f8cd6532716b8f388bd4e9d8ed0b252743e923114c0c6cbfe414c"
        "086e3717a6502c3edff6130d34df252fb94b6f662d0cd27e2110903320563851"
    );

    pk.verify(b"hello world", &signature).unwrap();
}

#[test]
fn ed25519_verify_bad_signature() {
    let pk = PublicKey::from_str(
        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
    )
    .unwrap();

    // panic!("key: {}", pk.to_string_der());

    let signature = hex!(
        "9d04bfed7baa97c80d29a6ae48c0d896ce8463a7ea0c16197d55a563c73996ef"
        "062b2adf507f416c108422c0310fc6fb21886e11ce3de3e951d7a56049743f00"
    );

    let err = assert_matches!(pk.verify(b"hello, world", &signature), Err(e) => e);

    expect![
        "failed to verify a signature: signature error: Verification equation was not satisfied"
    ]
    .assert_eq(&err.to_string());
}

#[test]
fn ecdsa_verify_bad_signature() {
    let pk = PublicKey::from_str(
        "302d300706052b8104000a03220002703a9370b0443be6ae7c507b0aec81a55e94e4a863b9655360bd65358caa6588",
    )
    .unwrap();

    let signature = hex!(
        "f3a13a555f1f8cd6532716b8f388bd4e9d8ed0b252743e923114c0c6cbfe414c"
        "086e3717a6502c3edff6130d34df252fb94b6f662d0cd27e2110903320563850"
    );

    let err = assert_matches!(pk.verify(b"hello world", &signature), Err(e) => e);

    expect!["failed to verify a signature: signature error"].assert_eq(&err.to_string());
}

#[test]
fn ed25519_verify_error_ecdsa() {
    let pk = PublicKey::from_str(
        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
    )
    .unwrap();

    let signature = hex!(
        "f3a13a555f1f8cd6532716b8f388bd4e9d8ed0b252743e923114c0c6cbfe414c"
        "086e3717a6502c3edff6130d34df252fb94b6f662d0cd27e2110903320563851"
    );

    let err = assert_matches!(pk.verify(b"hello, world", &signature), Err(e) => e);

    expect!["failed to verify a signature: signature error: Cannot use scalar with high-bit set"]
        .assert_eq(&err.to_string());
}

#[test]
fn ecdsa_verify_error_ed25519() {
    let pk = PublicKey::from_str(
  "302d300706052b8104000a03220002703a9370b0443be6ae7c507b0aec81a55e94e4a863b9655360bd65358caa6588"
  )
  .unwrap();

    let signature = hex!(
        "9d04bfed7baa97c80d29a6ae48c0d896ce8463a7ea0c16197d55a563c73996ef"
        "062b2adf507f416c108422c0310fc6fb21886e11ce3de3e951d7a56049743f07"
    );

    let err = assert_matches!(pk.verify(b"hello world", &signature), Err(e) => e);

    expect!["failed to verify a signature: signature error"].assert_eq(&err.to_string());
}

#[test]
fn k256_compressed_pkcs8_ec_spki_der() {
    let pk = PublicKey::from_str("3036301006072a8648ce3d020106052b8104000a032200036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4").unwrap();

    assert_eq!(
        pk.to_string_raw(),
        "036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4"
    )
}

#[test]
fn k256_uncompressed_pkcs8_ec_spki_der() {
    let pk = PublicKey::from_str("3056301006072a8648ce3d020106052b8104000a03420004aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a6597795f855ddcad2377e22259d1fcb4e0f1d35e8f2056300c15070bcbfce3759cc9d").unwrap();

    assert_eq!(
        pk.to_string_raw(),
        "03aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a65977"
    )
}
// Filename: src/ledger_id.rs
use std::borrow::Borrow;
use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use crate::Error;

enum KnownKind {
    Mainnet,
    Testnet,
    Previewnet,
}

/// DST that's semantically a [`LedgerId`].
///
/// `&Self` saves a pointer indirection vs `&LedgerId` because `LedgerId` is a `Box<[u8]>`, so `&LedgerId` is a `&Box<[u8]>`.
///
/// It also allows for const constructable `LedgerId`s.
///
/// Internal API, don't publically expose.
#[repr(transparent)]
#[derive(Eq, PartialEq)]
pub struct RefLedgerId([u8]);

impl RefLedgerId {
    pub(crate) const MAINNET: &'static Self = Self::new(&[0]);
    pub(crate) const TESTNET: &'static Self = Self::new(&[1]);
    pub(crate) const PREVIEWNET: &'static Self = Self::new(&[2]);

    pub const fn new(data: &[u8]) -> &Self {
        // safety: blessed by the standard library: see `path.rs`
        // https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/library/std/src/path.rs#L2037-L2039
        unsafe { &*(data as *const [u8] as *const RefLedgerId) }
    }

    pub fn new_boxed(data: Box<[u8]>) -> Box<Self> {
        unsafe { Box::from_raw(Box::into_raw(data) as *mut RefLedgerId) }
    }

    const fn kind(&self) -> Option<KnownKind> {
        const MAINNET_BYTES: &[u8] = RefLedgerId::MAINNET.as_bytes();
        const TESTNET_BYTES: &[u8] = RefLedgerId::TESTNET.as_bytes();
        const PREVIEWNET_BYTES: &[u8] = RefLedgerId::PREVIEWNET.as_bytes();
        match self.as_bytes() {
            MAINNET_BYTES => Some(KnownKind::Mainnet),
            TESTNET_BYTES => Some(KnownKind::Testnet),
            PREVIEWNET_BYTES => Some(KnownKind::Previewnet),
            _ => None,
        }
    }

    pub const fn as_bytes(&self) -> &[u8] {
        &self.0
    }
}

impl<'a> From<&'a [u8]> for &'a RefLedgerId {
    fn from(value: &'a [u8]) -> Self {
        RefLedgerId::new(value)
    }
}

impl ToOwned for RefLedgerId {
    type Owned = LedgerId;

    fn to_owned(&self) -> Self::Owned {
        Self::Owned::from_bytes(self.0.to_vec())
    }
}

/// The ID of a Hiero Ledger.
#[derive(Eq, PartialEq)]
pub struct LedgerId(Box<RefLedgerId>);

impl LedgerId {
    #[must_use]
    const fn kind(&self) -> Option<KnownKind> {
        self.0.kind()
    }

    /// ID for the `mainnet` ledger.
    #[must_use]
    pub fn mainnet() -> Self {
        RefLedgerId::MAINNET.to_owned()
    }

    /// ID for the `testnet` ledger.
    #[must_use]
    pub fn testnet() -> Self {
        RefLedgerId::TESTNET.to_owned()
    }

    /// ID for the `previewnet` ledger.
    #[must_use]
    pub fn previewnet() -> Self {
        RefLedgerId::PREVIEWNET.to_owned()
    }

    /// Create a ledger ID from the given bytes.
    #[must_use]
    pub fn from_bytes(bytes: Vec<u8>) -> Self {
        Self(RefLedgerId::new_boxed(bytes.into_boxed_slice()))
    }

    /// Returns `true` if `self` is `mainnet`.
    #[must_use]
    pub fn is_mainnet(&self) -> bool {
        matches!(self.kind(), Some(KnownKind::Mainnet))
    }

    /// Returns `true` if `self` is `testnet`.
    #[must_use]
    pub fn is_testnet(&self) -> bool {
        matches!(self.kind(), Some(KnownKind::Testnet))
    }

    /// Returns `true` if `self` is `previewnet`.
    #[must_use]
    pub fn is_previewnet(&self) -> bool {
        matches!(self.kind(), Some(KnownKind::Previewnet))
    }

    /// Returns `true` if `self` is `mainnet`, `testnet`, or `previewnet`.
    #[must_use]
    pub fn is_known_network(&self) -> bool {
        self.kind().is_some()
    }

    #[must_use]
    pub(crate) fn as_ref_ledger_id(&self) -> &RefLedgerId {
        &self.0
    }

    // todo: remove so that we can have `LedgerId` be an enum internally?
    // that would make `mainnet`, `testnet`, and `previewnet`, all const constructable.
    // then we could use a
    #[must_use]
    fn as_bytes(&self) -> &[u8] {
        self.0.as_bytes()
    }

    /// Provides a byte representation of `self`.
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        self.0.as_bytes().to_vec()
    }
}

impl Clone for LedgerId {
    fn clone(&self) -> Self {
        Self::from_bytes(self.0.as_bytes().to_vec())
    }
}

impl AsRef<RefLedgerId> for LedgerId {
    fn as_ref(&self) -> &RefLedgerId {
        &self.0
    }
}

impl Borrow<RefLedgerId> for LedgerId {
    fn borrow(&self) -> &RefLedgerId {
        self.as_ref()
    }
}

impl Debug for LedgerId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for LedgerId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self.kind() {
            Some(it) => f.write_str(match it {
                KnownKind::Mainnet => "mainnet",
                KnownKind::Testnet => "testnet",
                KnownKind::Previewnet => "previewnet",
            }),

            None => f.write_str(&hex::encode(self.as_bytes())),
        }
    }
}

impl FromStr for LedgerId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "mainnet" => Ok(Self::mainnet()),
            "testnet" => Ok(Self::testnet()),
            "previewnet" => Ok(Self::previewnet()),
            _ => hex::decode(s).map(Self::from_bytes).map_err(Error::basic_parse),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use crate::LedgerId;

    #[test]
    fn it_can_to_string() {
        assert_eq!(LedgerId::mainnet().to_string(), "mainnet");
        assert_eq!(LedgerId::testnet().to_string(), "testnet");
        assert_eq!(LedgerId::previewnet().to_string(), "previewnet");
        assert_eq!(
            LedgerId::from_bytes(vec![0x00, 0xFF, 0x00, 0xFF]).to_string().to_uppercase(),
            "00FF00FF"
        );
    }

    #[test]
    fn it_can_from_string() {
        assert_eq!(LedgerId::from_str("mainnet").unwrap(), LedgerId::mainnet());
        assert_eq!(LedgerId::from_str("testnet").unwrap(), LedgerId::testnet());
        assert_eq!(LedgerId::from_str("previewnet").unwrap(), LedgerId::previewnet());
        assert_eq!(
            LedgerId::from_str("00ff00ff").unwrap(),
            LedgerId::from_bytes(vec![0x00, 0xFF, 0x00, 0xFF])
        );
        assert_eq!(
            LedgerId::from_str("00FF00FF").unwrap(),
            LedgerId::from_bytes(vec![0x00, 0xFF, 0x00, 0xFF])
        );
    }

    #[test]
    fn it_can_to_bytes() {
        let bytes = vec![0x00, 0xFF, 0x00, 0xFF];
        assert_eq!(LedgerId::from_bytes(bytes.clone()).as_bytes(), &bytes);
    }
}
// Filename: src/lib.rs
// SPDX-License-Identifier: Apache-2.0

// todo: more indepth documentation
//! Hiero Rust SDK.

#![forbid(unsafe_op_in_unsafe_fn)]
#![warn(
    absolute_paths_not_starting_with_crate,
    deprecated_in_future,
    future_incompatible,
    missing_docs,
    clippy::cargo_common_metadata,
    clippy::future_not_send,
    clippy::missing_errors_doc
)]
// useful pedantic clippy lints
// This is an opt-in list instead of opt-out because sometimes clippy has weird lints.
#![warn(
    clippy::bool_to_int_with_if,
    clippy::checked_conversions,
    clippy::cloned_instead_of_copied,
    clippy::copy_iterator,
    clippy::default_trait_access,
    clippy::doc_link_with_quotes,
    clippy::doc_markdown,
    clippy::expl_impl_clone_on_copy,
    clippy::explicit_deref_methods,
    clippy::explicit_into_iter_loop,
    clippy::explicit_iter_loop,
    clippy::filter_map_next,
    clippy::flat_map_option,
    clippy::fn_params_excessive_bools,
    clippy::from_iter_instead_of_collect,
    clippy::if_not_else,
    clippy::implicit_clone,
    clippy::implicit_hasher,
    clippy::inconsistent_struct_constructor,
    clippy::index_refutable_slice,
    clippy::inefficient_to_string,
    clippy::invalid_upcast_comparisons,
    clippy::items_after_statements,
    clippy::iter_not_returning_iterator,
    clippy::large_digit_groups,
    clippy::large_stack_arrays,
    clippy::large_futures,
    clippy::large_types_passed_by_value,
    clippy::linkedlist,
    clippy::macro_use_imports,
    clippy::manual_assert,
    clippy::manual_instant_elapsed,
    clippy::manual_let_else,
    clippy::manual_ok_or,
    clippy::manual_string_new,
    clippy::many_single_char_names,
    clippy::map_unwrap_or,
    clippy::match_same_arms,
    clippy::match_wild_err_arm,
    clippy::match_wildcard_for_single_variants,
    clippy::maybe_infinite_iter,
    clippy::mismatching_type_param_order,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::must_use_candidate,
    clippy::mut_mut,
    clippy::naive_bytecount,
    clippy::needless_bitwise_bool,
    clippy::needless_continue,
    clippy::needless_for_each,
    clippy::needless_pass_by_value,
    clippy::no_effect_underscore_binding,
    clippy::option_option,
    clippy::range_minus_one,
    clippy::range_plus_one,
    clippy::redundant_closure_for_method_calls,
    clippy::redundant_else,
    clippy::ref_binding_to_reference,
    clippy::ref_option_ref,
    clippy::return_self_not_must_use,
    clippy::same_functions_in_if_condition,
    clippy::semicolon_if_nothing_returned,
    clippy::similar_names,
    clippy::stable_sort_primitive,
    clippy::string_add_assign,
    clippy::struct_excessive_bools,
    clippy::trivially_copy_pass_by_ref,
    clippy::unchecked_duration_subtraction,
    clippy::uninlined_format_args,
    clippy::unnecessary_join,
    clippy::unnecessary_wraps,
    clippy::unnested_or_patterns,
    clippy::unreadable_literal,
    clippy::unsafe_derive_deserialize,
    clippy::unused_async,
    clippy::unused_self,
    clippy::used_underscore_binding,
    clippy::zero_sized_map_values
)]
#![allow(clippy::enum_glob_use, clippy::enum_variant_names)]
#[macro_use]
mod protobuf;

mod account;
mod address_book;
mod client;
mod contract;
mod custom_fee_limit;
mod custom_fixed_fee;
mod downcast;
mod entity_id;
mod error;
mod ethereum;
mod exchange_rates;
mod execute;
mod fee_schedules;
mod file;
mod hbar;
mod key;
mod ledger_id;
mod mirror_query;
#[cfg(feature = "mnemonic")]
mod mnemonic;
mod network_version_info;
mod network_version_info_query;
mod node_address;
mod node_address_book;
mod node_address_book_query;
mod pending_airdrop_id;
mod pending_airdrop_record;
mod ping_query;
mod prng_transaction;
mod query;
mod retry;
mod schedule;
mod semantic_version;
mod service_endpoint;
mod signer;
mod staked_id;
mod staking_info;
mod system;
mod token;
mod topic;
mod transaction;
mod transaction_hash;
mod transaction_id;
mod transaction_receipt;
mod transaction_receipt_query;
mod transaction_record;
mod transaction_record_query;
mod transaction_response;
mod transfer;
mod transfer_transaction;

pub use account::{
    account_info_flow,
    AccountAllowanceApproveTransaction,
    AccountAllowanceDeleteTransaction,
    AccountBalance,
    AccountBalanceQuery,
    AccountCreateTransaction,
    AccountDeleteTransaction,
    AccountId,
    AccountInfo,
    AccountInfoQuery,
    AccountRecordsQuery,
    AccountUpdateTransaction,
    AllProxyStakers,
    ProxyStaker,
};
pub use address_book::{
    NodeCreateTransaction,
    NodeDeleteTransaction,
    NodeUpdateTransaction,
};
pub use client::Client;
pub(crate) use client::Operator;
pub use contract::{
    ContractBytecodeQuery,
    ContractCallQuery,
    ContractCreateFlow,
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractExecuteTransaction,
    ContractFunctionParameters,
    ContractFunctionResult,
    ContractId,
    ContractInfo,
    ContractInfoQuery,
    ContractLogInfo,
    ContractNonceInfo,
    ContractUpdateTransaction,
    DelegateContractId,
};
pub use custom_fixed_fee::CustomFixedFee;
pub use entity_id::EntityId;
pub(crate) use entity_id::ValidateChecksums;
pub use error::{
    Error,
    Result,
};
#[cfg(feature = "mnemonic")]
pub use error::{
    MnemonicEntropyError,
    MnemonicParseError,
};
pub use ethereum::{
    Eip1559EthereumData,
    EthereumData,
    EthereumFlow,
    EthereumTransaction,
    EvmAddress,
    LegacyEthereumData,
};
pub use exchange_rates::{
    ExchangeRate,
    ExchangeRates,
};
pub use fee_schedules::{
    FeeComponents,
    FeeData,
    FeeDataType,
    FeeSchedule,
    FeeSchedules,
    RequestType,
    TransactionFeeSchedule,
};
pub use file::{
    FileAppendTransaction,
    FileContentsQuery,
    FileContentsResponse,
    FileCreateTransaction,
    FileDeleteTransaction,
    FileId,
    FileInfo,
    FileInfoQuery,
    FileUpdateTransaction,
};
pub use hbar::{
    Hbar,
    HbarUnit,
    Tinybar,
};
pub use hedera_proto::services::ResponseCodeEnum as Status;
pub use key::{
    Key,
    KeyList,
    PrivateKey,
    PublicKey,
};
pub use ledger_id::LedgerId;
pub use mirror_query::{
    AnyMirrorQuery,
    AnyMirrorQueryResponse,
    MirrorQuery,
};
#[cfg(feature = "mnemonic")]
pub use mnemonic::Mnemonic;
pub use network_version_info::NetworkVersionInfo;
pub use network_version_info_query::NetworkVersionInfoQuery;
pub(crate) use network_version_info_query::NetworkVersionInfoQueryData;
pub use node_address::NodeAddress;
pub use node_address_book::NodeAddressBook;
pub use node_address_book_query::NodeAddressBookQuery;
pub(crate) use node_address_book_query::NodeAddressBookQueryData;
pub use pending_airdrop_record::PendingAirdropRecord;
pub use prng_transaction::PrngTransaction;
pub(crate) use protobuf::{
    FromProtobuf,
    ToProtobuf,
};
pub use query::{
    AnyQuery,
    AnyQueryResponse,
    Query,
};
pub(crate) use retry::retry;
pub use schedule::{
    ScheduleCreateTransaction,
    ScheduleDeleteTransaction,
    ScheduleId,
    ScheduleInfo,
    ScheduleInfoQuery,
    ScheduleSignTransaction,
};
pub use semantic_version::SemanticVersion;
pub use service_endpoint::ServiceEndpoint;
pub use staking_info::StakingInfo;
pub use system::{
    FreezeTransaction,
    FreezeType,
    SystemDeleteTransaction,
    SystemUndeleteTransaction,
};
pub use token::{
    AnyCustomFee,
    AssessedCustomFee,
    CustomFee,
    Fee,
    FeeAssessmentMethod,
    FixedFee,
    FixedFeeData,
    FractionalFee,
    FractionalFeeData,
    NftId,
    RoyaltyFee,
    RoyaltyFeeData,
    TokenAirdropTransaction,
    TokenAssociateTransaction,
    TokenAssociation,
    TokenBurnTransaction,
    TokenCancelAirdropTransaction,
    TokenClaimAirdropTransaction,
    TokenCreateTransaction,
    TokenDeleteTransaction,
    TokenDissociateTransaction,
    TokenFeeScheduleUpdateTransaction,
    TokenFreezeTransaction,
    TokenGrantKycTransaction,
    TokenId,
    TokenInfo,
    TokenInfoQuery,
    TokenKeyValidation,
    TokenMintTransaction,
    TokenNftInfo,
    TokenNftInfoQuery,
    TokenNftTransfer,
    TokenPauseTransaction,
    TokenRejectFlow,
    TokenRejectTransaction,
    TokenRevokeKycTransaction,
    TokenSupplyType,
    TokenType,
    TokenUnfreezeTransaction,
    TokenUnpauseTransaction,
    TokenUpdateNftsTransaction,
    TokenUpdateTransaction,
    TokenWipeTransaction,
};
pub use topic::{
    TopicCreateTransaction,
    TopicDeleteTransaction,
    TopicId,
    TopicInfo,
    TopicInfoQuery,
    TopicMessage,
    TopicMessageQuery,
    TopicMessageSubmitTransaction,
    TopicUpdateTransaction,
};
pub use transaction::{
    AnyTransaction,
    Transaction,
};
pub use transaction_hash::TransactionHash;
pub use transaction_id::TransactionId;
pub use transaction_receipt::TransactionReceipt;
pub use transaction_receipt_query::TransactionReceiptQuery;
pub use transaction_record::TransactionRecord;
pub use transaction_record_query::TransactionRecordQuery;
pub(crate) use transaction_record_query::TransactionRecordQueryData;
pub use transaction_response::TransactionResponse;
pub use transfer::Transfer;
pub use transfer_transaction::TransferTransaction;

/// Like [`arc_swap::ArcSwapOption`] but with a [`triomphe::Arc`].
pub(crate) type ArcSwapOption<T> = arc_swap::ArcSwapAny<Option<triomphe::Arc<T>>>;

/// Like [`arc_swap::ArcSwap`] but with a [`triomphe::Arc`].
pub(crate) type ArcSwap<T> = arc_swap::ArcSwapAny<triomphe::Arc<T>>;

/// Boxed future for GRPC calls.
pub(crate) type BoxGrpcFuture<'a, T> =
    futures_core::future::BoxFuture<'a, tonic::Result<tonic::Response<T>>>;
// Filename: src/mirror_query/any.rs
// SPDX-License-Identifier: Apache-2.0

use futures_core::future::BoxFuture;
use futures_core::stream::BoxStream;
use futures_util::TryStreamExt;

use super::subscribe::MirrorQueryExecute;
use crate::topic::TopicMessageQueryData;
use crate::{
    MirrorQuery,
    NodeAddress,
    NodeAddressBookQueryData,
    TopicMessage,
};

/// Represents any possible query to the mirror network.
pub type AnyMirrorQuery = MirrorQuery<AnyMirrorQueryData>;

#[derive(Debug, Clone)]
pub enum AnyMirrorQueryData {
    NodeAddressBook(NodeAddressBookQueryData),
    TopicMessage(TopicMessageQueryData),
}

#[derive(Debug, Clone)]
pub enum AnyMirrorQueryMessage {
    NodeAddressBook(NodeAddress),
    TopicMessage(TopicMessage),
}

/// Represents the response of any possible query to the mirror network.
pub enum AnyMirrorQueryResponse {
    /// Response for `AnyMirrorQuery::NodeAddressBook`.
    NodeAddressBook(<NodeAddressBookQueryData as MirrorQueryExecute>::Response),
    /// Response for `AnyMirrorQuery::TopicMessage`.
    TopicMessage(<TopicMessageQueryData as MirrorQueryExecute>::Response),
}

impl MirrorQueryExecute for AnyMirrorQueryData {
    type Item = AnyMirrorQueryMessage;

    type Response = AnyMirrorQueryResponse;

    type ItemStream<'a>
        = BoxStream<'a, crate::Result<Self::Item>>
    where
        Self: 'a;

    fn subscribe_with_optional_timeout<'a>(
        &self,
        params: &crate::mirror_query::MirrorQueryCommon,
        client: &'a crate::Client,
        timeout: Option<std::time::Duration>,
    ) -> Self::ItemStream<'a>
    where
        Self: 'a,
    {
        match self {
            AnyMirrorQueryData::NodeAddressBook(it) => Box::pin(
                it.subscribe_with_optional_timeout(params, client, timeout)
                    .map_ok(Self::Item::from),
            ),
            AnyMirrorQueryData::TopicMessage(it) => Box::pin(
                it.subscribe_with_optional_timeout(params, client, timeout)
                    .map_ok(Self::Item::from),
            ),
        }
    }

    fn execute_with_optional_timeout<'a>(
        &'a self,
        params: &'a super::MirrorQueryCommon,
        client: &'a crate::Client,
        timeout: Option<std::time::Duration>,
    ) -> BoxFuture<'a, crate::Result<Self::Response>> {
        match self {
            AnyMirrorQueryData::NodeAddressBook(it) => Box::pin(async move {
                it.execute_with_optional_timeout(params, client, timeout)
                    .await
                    .map(Self::Response::from)
            }),
            AnyMirrorQueryData::TopicMessage(it) => Box::pin(async move {
                it.execute_with_optional_timeout(params, client, timeout)
                    .await
                    .map(Self::Response::from)
            }),
        }
    }
}
// Filename: src/mirror_query/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod any;
mod subscribe;

pub(crate) use any::AnyMirrorQueryData;
pub use any::{
    AnyMirrorQuery,
    AnyMirrorQueryMessage,
    AnyMirrorQueryResponse,
};
pub(crate) use subscribe::{
    subscribe,
    MirrorRequest,
};

use self::subscribe::MirrorQueryExecute;

/// A query that can be executed on the Hiero mirror network.
#[derive(Clone, Debug, Default)]
pub struct MirrorQuery<D> {
    pub(crate) data: D,
    // Field needs to exist even though it currently does nothing
    #[allow(dead_code)]
    pub(crate) common: MirrorQueryCommon,
}

// intentionally inaccessable despite publicity.
#[derive(Clone, Debug, Default)]
pub struct MirrorQueryCommon {
    // empty for now
    // TODO: request_timeout
}

impl<D> MirrorQuery<D>
where
    D: MirrorQueryExecute + Default,
{
    /// Create a new query ready for configuration and execution.
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }
}
// Filename: src/mirror_query/subscribe.rs
// SPDX-License-Identifier: Apache-2.0

use async_stream::stream;
use backoff::backoff::Backoff;
use backoff::ExponentialBackoff;
use futures_core::future::BoxFuture;
use futures_core::Stream;
use futures_util::StreamExt;
use tokio::time::sleep;
use tonic::transport::Channel;
use tonic::Status;

use crate::mirror_query::AnyMirrorQueryData;
use crate::{
    Client,
    Error,
    MirrorQuery,
};

impl<D> MirrorQuery<D>
where
    D: MirrorQueryExecute,
{
    /// Execute this query against the provided client of the Hiero network.
    // todo:
    #[allow(clippy::missing_errors_doc)]
    pub async fn execute(&mut self, client: &Client) -> crate::Result<D::Response> {
        self.execute_with_optional_timeout(client, None).await
    }

    pub(crate) async fn execute_with_optional_timeout(
        &self,
        client: &Client,
        timeout: Option<std::time::Duration>,
    ) -> crate::Result<D::Response> {
        self.data.execute_with_optional_timeout(&self.common, client, timeout).await
    }

    /// Execute this query against the provided client of the Hiero network.
    ///
    /// Note that `timeout` is the connection timeout.
    // todo:
    #[allow(clippy::missing_errors_doc)]
    pub async fn execute_with_timeout(
        &mut self,
        client: &Client,
        timeout: std::time::Duration,
    ) -> crate::Result<D::Response> {
        self.execute_with_optional_timeout(client, Some(timeout)).await
    }

    /// Subscribe to this query with the provided client of the Hiero network.
    pub fn subscribe<'a>(&self, client: &'a Client) -> D::ItemStream<'a> {
        self.subscribe_with_optional_timeout(client, None)
    }

    /// Subscribe to this query with the provided client of the Hiero network.
    ///
    /// Note that `timeout` is the connection timeout.
    pub fn subscribe_with_timeout<'a>(
        &self,
        client: &'a Client,
        timeout: std::time::Duration,
    ) -> D::ItemStream<'a> {
        self.subscribe_with_optional_timeout(client, Some(timeout))
    }

    pub(crate) fn subscribe_with_optional_timeout<'a>(
        &self,
        client: &'a Client,
        timeout: Option<std::time::Duration>,
    ) -> D::ItemStream<'a> {
        self.data.subscribe_with_optional_timeout(&self.common, client, timeout)
    }
}

pub trait MirrorQueryExecute: Sized + Into<AnyMirrorQueryData> + Send + Sync {
    type Item;
    type Response;
    type ItemStream<'a>: Stream<Item = crate::Result<Self::Item>> + 'a
    where
        Self: 'a;

    fn subscribe_with_optional_timeout<'a>(
        &self,
        params: &crate::mirror_query::MirrorQueryCommon,
        client: &'a crate::Client,
        timeout: Option<std::time::Duration>,
    ) -> Self::ItemStream<'a>
    where
        Self: 'a;

    fn execute_with_optional_timeout<'a>(
        &'a self,
        params: &'a super::MirrorQueryCommon,
        client: &'a Client,
        timeout: Option<std::time::Duration>,
    ) -> BoxFuture<'a, crate::Result<Self::Response>>;
}

impl<T> MirrorQueryExecute for T
where
    T: MirrorRequest + Sync + Clone + Into<AnyMirrorQueryData>,
{
    type Item = <Self as MirrorRequest>::Item;

    type Response = <Self as MirrorRequest>::Response;

    type ItemStream<'a>
        = <Self as MirrorRequest>::ItemStream<'a>
    where
        Self: 'a;

    fn subscribe_with_optional_timeout<'a>(
        &self,
        _params: &crate::mirror_query::MirrorQueryCommon,
        client: &'a crate::Client,
        timeout: Option<std::time::Duration>,
    ) -> Self::ItemStream<'a>
    where
        Self: 'a,
    {
        let timeout = timeout.or_else(|| client.request_timeout()).unwrap_or_else(|| {
            std::time::Duration::from_millis(backoff::default::MAX_ELAPSED_TIME_MILLIS)
        });

        // note: we don't care about keeping the mirrornet around, so, we just take the channel (which is arc-like)
        let channel = client.mirrornet().load().channel();

        Self::make_item_stream(crate::mirror_query::subscribe(channel, timeout, self.clone()))
    }

    fn execute_with_optional_timeout<'a>(
        &'a self,
        _params: &'a crate::mirror_query::MirrorQueryCommon,
        client: &crate::Client,
        timeout: Option<std::time::Duration>,
    ) -> BoxFuture<'a, crate::Result<Self::Response>> {
        let timeout = timeout.or_else(|| client.request_timeout()).unwrap_or_else(|| {
            std::time::Duration::from_millis(backoff::default::MAX_ELAPSED_TIME_MILLIS)
        });

        // note: we don't care about keeping the mirrornet around, so, we just take the channel (which is arc-like)
        let channel = client.mirrornet().load().channel();

        Self::try_collect(crate::mirror_query::subscribe(channel, timeout, self.clone()))
    }
}

pub trait MirrorRequest: Send {
    type GrpcItem: Send;
    type ConnectStream: Stream<Item = tonic::Result<Self::GrpcItem>> + Send;

    type Item;
    type Response;
    type Context: Default + Send + Sync;

    type ItemStream<'a>: Stream<Item = crate::Result<Self::Item>> + 'a;

    fn connect(
        &self,
        context: &Self::Context,
        channel: Channel,
    ) -> BoxFuture<'_, tonic::Result<Self::ConnectStream>>;

    /// Return `true` to retry establishing the stream, up to a configurable maximum timeout.
    #[allow(unused_variables)]
    fn should_retry(&self, status_code: tonic::Code) -> bool {
        false
    }

    fn make_item_stream<'a, S>(stream: S) -> Self::ItemStream<'a>
    where
        S: Stream<Item = crate::Result<Self::GrpcItem>> + Send + 'a;

    fn update_context(context: &mut Self::Context, item: &Self::GrpcItem);

    fn try_collect<'a, S>(stream: S) -> BoxFuture<'a, crate::Result<Self::Response>>
    where
        S: Stream<Item = crate::Result<Self::GrpcItem>> + Send + 'a;
}

pub(crate) fn subscribe<I: Send, R: MirrorRequest<GrpcItem = I> + Send + Sync>(
    channel: Channel,
    timeout: std::time::Duration,
    request: R,
) -> impl Stream<Item = crate::Result<I>> + Send {
    stream! {
        let request = request;

        let mut backoff = ExponentialBackoff {
            max_elapsed_time: Some(timeout),
            ..ExponentialBackoff::default()
        };

        let mut backoff_inf = ExponentialBackoff {
            max_elapsed_time: None,
            // remove maximum elapsed time for # of back-offs on inf.
            .. ExponentialBackoff::default()
        };

        let mut context = R::Context::default();

        loop {
            let status: Status = 'request: loop {
                // attempt to establish the stream
                let response = request.connect(&context, channel.clone()).await;

                let stream = match response {
                    // success, we now have a stream and may begin waiting for messages
                    Ok(stream) => stream,

                    Err(status) => {
                        break 'request status;
                    }
                };

                let mut stream = std::pin::pin!(stream);

                backoff.reset();
                backoff_inf.reset();

                #[allow(unused_labels)]
                'message: loop {
                    let message = stream.next().await.transpose();

                    let message = match message {
                        Ok(Some(message)) => message,
                        Ok(None) => {
                            // end of stream
                            // hopefully due to configured limits or expected conditions
                            return;
                        }

                        Err(status) => {
                            break 'request status;
                        }
                    };

                    R::update_context(&mut context, &message);

                    yield Ok(message);
                }
            };

            match status.code() {
                tonic::Code::Unavailable | tonic::Code::ResourceExhausted => {
                    // encountered a temporarily down or overloaded service
                    sleep(backoff_inf.next_backoff().unwrap()).await;
                }

                tonic::Code::Unknown if status.message() == "error reading a body from connection: connection reset" => {
                    // connection was aborted by the server
                    sleep(backoff_inf.next_backoff().unwrap()).await;
                }

                code if request.should_retry(code) => {
                    if let Some(duration) = backoff.next_backoff() {
                        sleep(duration).await;
                    } else {
                        // maximum time allowed has elapsed
                        // NOTE: it should be impossible to reach here without capturing at least one error
                        yield Err(Error::TimedOut(Error::from(status).into()));
                        return;
                    }
                }
                _ => {
                    // encountered an un-recoverable failure when attempting
                    // to establish the stream
                    yield Err(Error::from(status));
                    return;
                }
            }
        }
    }
}
// Filename: src/mnemonic/mod.rs
// SPDX-License-Identifier: Apache-2.0

use std::cmp::Ordering;
use std::fmt;
use std::str::FromStr;

use fraction::{
    Integer,
    ToPrimitive,
};
use num_bigint::BigInt;
use once_cell::sync::Lazy;
use rand::{
    thread_rng,
    RngCore,
};
use sha2::Digest;

use crate::error::{
    MnemonicEntropyError,
    MnemonicParseError,
};
use crate::{
    Error,
    PrivateKey,
};

const BIP39: &str = include_str!("bip39-english.txt");
const LEGACY: &str = include_str!("legacy-english.txt");

// `is_sorted` is unstable.
// this is just lifted from the stdlib impl.
fn is_sorted<T: PartialOrd>(vs: &[T]) -> bool {
    vs.windows(2).all(|w| w[0].partial_cmp(&w[1]).map_or(false, |o| o != Ordering::Greater))
}

// sadly can't do this with a const.
static BIP39_WORD_LIST: Lazy<Vec<&'static str>> = Lazy::new(|| {
    let it: Vec<_> = BIP39.split_whitespace().collect();
    // if the word list is sorted we can use the power of `binary_search` which turns the `O(n)` search into a `O(log n)`
    // n is a constant here, but perf is perf.
    assert!(is_sorted(&it));
    it
});

// the legacy word list isn't sorted.
static LEGACY_WORD_LIST: Lazy<Vec<&'static str>> =
    Lazy::new(|| LEGACY.split_whitespace().collect());

///  `BIP-39` 24-word mnemonic phrase compatible with the Android and iOS mobile wallets.
pub struct Mnemonic(MnemonicData);

// pretend to be the API we want to show
impl fmt::Debug for Mnemonic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Mnemonic")
            .field("words", &self.words())
            .field("is_legacy", &self.is_legacy())
            .finish()
    }
}

impl Mnemonic {
    // todo(sr): before release, try to find a better internal representation
    // lets not expose this until we know what the final signature should be
    pub(crate) fn words(&self) -> &[String] {
        match &self.0 {
            MnemonicData::V1(it) => it.words(),
            MnemonicData::V2V3(it) => it.words(),
        }
    }

    /// Returns `true` if `self` is a legacy mnemonic.
    #[must_use]
    pub fn is_legacy(&self) -> bool {
        matches!(&self.0, MnemonicData::V1(_))
    }

    // todo(sr): Not too happy about requiring a `Vec<String>`
    /// Constructs a `Mnemonic` from a 24-word list.
    ///
    /// # Errors
    /// * if the mnemonic has an invalid length.
    /// * if the mnemonic uses invalid words.
    /// * if the mnemonic has an invalid checksum.
    pub fn from_words(words: Vec<String>) -> crate::Result<Self> {
        let words = match words.try_into() {
            Ok(words) => return Ok(Self(MnemonicData::V1(MnemonicV1 { words: Box::new(words) }))),
            Err(words) => words,
        };

        let mnemonic = Self(MnemonicV2V3 { words }.into());

        if mnemonic.words().len() != 12 && mnemonic.words().len() != 24 {
            return Err(Error::MnemonicParse {
                reason: MnemonicParseError::BadLength(mnemonic.words().len()),
                mnemonic,
            });
        }

        let mut word_indecies = Vec::with_capacity(mnemonic.words().len());
        let mut unknown_words = Vec::new();
        for (word_index, word) in mnemonic.words().iter().enumerate() {
            match BIP39_WORD_LIST.binary_search(&&**word) {
                Ok(i) => {
                    word_indecies.push(i as u16);
                }
                // error (word not in list)
                Err(_) => {
                    unknown_words.push(word_index);
                }
            }
        }

        if !unknown_words.is_empty() {
            return Err(Error::MnemonicParse {
                reason: MnemonicParseError::UnknownWords(unknown_words),
                mnemonic,
            });
        }

        let (entropy, actual_checksum) = incecies_to_entropy_and_checksum(&word_indecies);
        let expected_checksum = checksum(&entropy);
        let expected_checksum =
            if mnemonic.words().len() == 12 { expected_checksum & 0xf0 } else { expected_checksum };

        if expected_checksum != actual_checksum {
            // error: checksum mismatch.
            return Err(Error::MnemonicParse {
                reason: MnemonicParseError::ChecksumMismatch {
                    expected: expected_checksum,
                    actual: actual_checksum,
                },
                mnemonic,
            });
        }

        Ok(mnemonic)
    }

    /// Generate a new 12 word `Mnemonic` from the BIP-39 standard English word list.
    #[must_use]
    pub fn generate_12() -> Self {
        Self(MnemonicV2V3::generate_12().into())
    }

    /// Generate a new 24 word `Mnemonic` from the BIP-39 standard English word list.
    #[must_use]
    pub fn generate_24() -> Self {
        Self(MnemonicV2V3::generate_24().into())
    }

    /// Recover a [`PrivateKey`] from this `Mnemonic`.
    ///
    /// # Errors
    /// Under certain circumstances, this function will return a [`Error::MnemonicEntropy`].
    /// - [`MnemonicEntropyError::ChecksumMismatch`] if the computed checksum doesn't match the actual checksum.
    /// - [`MnemonicEntropyError::BadLength`] if this is a v2 legacy mnemonic and doesn't have `24` words.
    pub fn to_legacy_private_key(&self) -> crate::Result<PrivateKey> {
        let entropy = match &self.0 {
            MnemonicData::V1(it) => it.to_entropy()?,
            MnemonicData::V2V3(it) => it.to_legacy_entropy()?,
        };

        PrivateKey::from_bytes(&entropy)
    }

    /// Recover a [`PrivateKey`] from this `Mnemonic`.
    ///
    /// # Errors
    /// Under certain circumstances, this function will return a [`Error::MnemonicEntropy`].
    /// - [`MnemonicEntropyError::LegacyWithPassphrase`] if this is a legacy private key, and the passphrase isn't empty.
    /// - [`MnemonicEntropyError::ChecksumMismatch`] if this is a legacy private key,
    ///   and the `Mnemonic`'s checksum doesn't match up with the computed one.
    // the only panic here should be unreachable, if it isn't, that's a library bug.
    #[allow(clippy::missing_panics_doc)]
    pub fn to_private_key(&self, passphrase: &str) -> crate::Result<PrivateKey> {
        match &self.0 {
            MnemonicData::V1(_) if !passphrase.is_empty() => {
                Err(Error::from(MnemonicEntropyError::LegacyWithPassphrase))
            }
            MnemonicData::V1(it) => Ok(PrivateKey::from_bytes(&it.to_entropy()?).expect(
                "BUG: invariant broken - V1 mnemonic should always have exactly enough entropy",
            )),
            // known unfixable bug: `PrivateKey::from_mnemonic` can be called with a legacy private key.
            MnemonicData::V2V3(_) => Ok(PrivateKey::from_mnemonic(self, passphrase)),
        }
    }

    pub(crate) fn to_seed(&self, phrase: &str) -> [u8; 64] {
        let mut salt = String::from("mnemonic");
        salt.push_str(phrase);

        pbkdf2::pbkdf2_hmac_array::<sha2::Sha512, 64>(
            self.to_string().as_bytes(),
            salt.as_bytes(),
            2048,
        )
    }
}

impl fmt::Display for Mnemonic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some((first, rest)) = self.words().split_first() {
            f.write_str(first)?;

            for word in rest {
                write!(f, " {word}")?;
            }
        }

        Ok(())
    }
}

impl FromStr for Mnemonic {
    type Err = crate::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::from_words(s.split_whitespace().map(str::to_owned).collect())
    }
}

struct MnemonicV1 {
    words: Box<[String; 22]>,
}

impl MnemonicV1 {
    // clippy bug.
    #[allow(clippy::explicit_auto_deref)]
    fn words(&self) -> &[String] {
        &*self.words
    }

    fn to_entropy(&self) -> crate::Result<Vec<u8>> {
        let indecies = self.words.iter().map(|w| {
            LEGACY_WORD_LIST
                .iter()
                .enumerate()
                .find_map(|(idx, w2)| (w == w2).then_some(idx))
                .map_or(-1, |it| it as i32)
        });

        let data = convert_radix(indecies, 4096, 256, 33);
        let mut data: Vec<_> = data.into_iter().map(|it| it as u8).collect();

        let (crc, data) = data.split_last_mut().unwrap();

        for item in &mut *data {
            *item ^= *crc;
        }

        let crc2 = crc8(data);
        // checksum mismatch
        if *crc != crc2 {
            return Err(Error::from(MnemonicEntropyError::ChecksumMismatch {
                expected: crc2,
                actual: *crc,
            }));
        }

        Ok(data.to_vec())
    }
}

struct MnemonicV2V3 {
    words: Vec<String>,
}

impl MnemonicV2V3 {
    fn words(&self) -> &[String] {
        &self.words
    }

    fn from_entropy(entropy: &[u8]) -> Self {
        assert!(entropy.len() == 16 || entropy.len() == 32);

        let entropy = {
            let mut it = Vec::with_capacity(entropy.len() + 1);
            it.extend_from_slice(entropy);
            let checksum = checksum(entropy);
            it.push(if entropy.len() == 16 { checksum & 0xf0 } else { checksum });
            it
        };

        let mut buffer = 0_u32;
        let mut offset: u8 = 0;

        let mut words = Vec::with_capacity((entropy.len() * 8 + 1) / 11);

        for byte in entropy {
            buffer = (buffer << 8) | u32::from(byte);
            offset += 8;
            if offset >= 11 {
                let index = (buffer >> (offset - 11) & 0x7ff) as usize;
                words.push(BIP39_WORD_LIST[index].to_owned());
                offset -= 11;
            }
        }

        Self { words }
    }

    fn generate_12() -> Self {
        let mut rng = thread_rng();
        let mut entropy = [0; 16];
        rng.fill_bytes(&mut entropy);

        Self::from_entropy(&entropy)
    }

    fn generate_24() -> Self {
        let mut rng = thread_rng();
        let mut entropy = [0; 32];
        rng.fill_bytes(&mut entropy);

        Self::from_entropy(&entropy)
    }

    fn to_legacy_entropy(&self) -> crate::Result<Vec<u8>> {
        // error here where we'll have more context than `PrivateKey::from_bytes`.
        if self.words.len() != 24 {
            return Err(Error::from(MnemonicEntropyError::BadLength {
                expected: 24,
                actual: self.words.len(),
            }));
        }

        // technically, this code all works for 12 words, but I'm going to pretend it doesn't.
        let (entropy, actual_checksum) = words_to_entropy_and_checksum(&self.words);

        let expected_checksum = checksum(&entropy);
        let expected_checksum =
            if self.words.len() == 12 { expected_checksum & 0xf0 } else { expected_checksum };

        if expected_checksum != actual_checksum {
            return Err(Error::from(MnemonicEntropyError::ChecksumMismatch {
                expected: expected_checksum,
                actual: actual_checksum,
            }));
        }

        Ok(entropy)
    }
}

enum MnemonicData {
    V1(MnemonicV1),
    V2V3(MnemonicV2V3),
}

impl From<MnemonicV1> for MnemonicData {
    fn from(v: MnemonicV1) -> Self {
        Self::V1(v)
    }
}

impl From<MnemonicV2V3> for MnemonicData {
    fn from(v: MnemonicV2V3) -> Self {
        Self::V2V3(v)
    }
}

fn crc8(data: &[u8]) -> u8 {
    let mut crc = 0xff;

    for &it in &data[..(data.len() - 1)] {
        crc ^= it;
        for _ in 0..8 {
            crc = (crc >> 1) ^ if (crc & 1) == 0 { 0 } else { 0xb2 };
        }
    }

    crc ^ 0xff
}

// forgive me, universe, for the crimes I'm about to commit.
//
// todo: this is only done with one base pair and it's 4096->256, maybe there's a much nicer way to do this?
fn convert_radix<I: IntoIterator<Item = i32>>(
    nums: I,
    from_radix: i32,
    to_radix: i32,
    to_length: usize,
) -> Vec<i32> {
    let mut buf = BigInt::from(0);
    let from_radix = BigInt::from(i64::from(from_radix));

    for num in nums {
        buf *= &from_radix;
        buf += num;
    }

    let mut out = vec![0; to_length];

    let to_radix = BigInt::from(i64::from(to_radix));

    for out in out.iter_mut().rev() {
        let rem;
        (buf, rem) = buf.div_rem(&to_radix);
        *out = rem.to_i32().unwrap();
    }

    out
}

fn words_to_entropy_and_checksum<T: AsRef<str>>(words: &[T]) -> (Vec<u8>, u8) {
    let indecies: Vec<_> = words
        .iter()
        .map(T::as_ref)
        .map(|it| BIP39_WORD_LIST.binary_search(&it).unwrap() as u16)
        .collect();

    incecies_to_entropy_and_checksum(&indecies)
}

fn incecies_to_entropy_and_checksum(indecies: &[u16]) -> (Vec<u8>, u8) {
    assert!(matches!(indecies.len(), 12 | 24));

    let mut output = Vec::with_capacity(if indecies.len() == 12 { 17 } else { 33 });
    let mut buf = 0_u32;
    let mut offset: u8 = 0;

    for index in indecies {
        assert!(*index <= 0x7ff);

        buf = (buf << 11) | u32::from(*index);
        offset += 11;
        while offset >= 8 {
            // we want to truncate.
            let byte = (buf >> (offset - 8)) as u8;
            output.push(byte);
            offset -= 8;
        }
    }

    if offset != 0 {
        output.push((buf << offset) as u8);
    }

    let checksum = output.pop().unwrap();
    let checksum = if indecies.len() == 12 { checksum & 0xf0 } else { checksum };
    (output, checksum)
}

fn checksum(bytes: &[u8]) -> u8 {
    assert!(bytes.len() <= 32);
    let checksum = sha2::Sha256::digest(bytes);
    checksum[0]
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use assert_matches::assert_matches;
    use expect_test::expect;
    use hex_literal::hex;

    use super::Mnemonic;
    use crate::error::MnemonicParseError;
    use crate::Error;

    const KNOWN_GOOD_MNEMONICS: &[&str] = &[
        "inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home",
        "tiny denial casual grass skull spare awkward indoor ethics dash enough flavor good daughter early hard rug staff capable swallow raise flavor empty angle",
        "ramp april job flavor surround pyramid fish sea good know blame gate village viable include mixed term draft among monitor swear swing novel track",
        "evoke rich bicycle fire promote climb zero squeeze little spoil slight damage"
    ];

    #[test]
    fn from_string() {
        for s in KNOWN_GOOD_MNEMONICS {
            assert_matches!(Mnemonic::from_str(s), Ok(_))
        }
    }

    #[test]
    fn error_invalid_length() {
        // we can't test for up to `usize` length, but we can test several lengths to be modestly sure.
        // it might seem that testing many lengths would be slow.
        // we test:

        // todo: this feels overengineered.
        // every length up to (and including `DENSE_LIMIT`).
        // arbitrarily chosen to be 48.
        const DENSE_LIMIT: usize = 48;

        let dense_lengths = 0..=DENSE_LIMIT;
        let sparse_lengths = (0..=10).map(|it| it * 12).skip_while(|&it| it <= DENSE_LIMIT);

        for length in dense_lengths.chain(sparse_lengths) {
            if matches!(length, 12 | 22 | 24) {
                continue;
            }

            // this is a word that's explicitly in the word list,
            // to ensure we aren't accidentally testing that this error happens before "word(s) not in list"
            let words = std::iter::repeat("apple".to_owned()).take(length).collect();

            let reason = assert_matches!(Mnemonic::from_words(words), Err(Error::MnemonicParse { reason, .. }) => reason);
            let reported_length = assert_matches!(reason, MnemonicParseError::BadLength(reported_length) => reported_length);

            assert_eq!(reported_length, length);
        }
    }

    #[test]
    fn unknown_words_1() {
        // probably fails on checksum, doesn't matter.
        const MNEMONIC: &str = concat!(
            "obvious favorite remain caution ",
            "remove laptop base vacant ",
            "alone fever slush dune"
        );

        // replace words in `MNEMONIC` one at a time.
        for i in 0..12 {
            let mut words: Vec<_> = MNEMONIC.split_whitespace().map(str::to_owned).collect();
            words[i] = "lorum".to_owned();

            let reason = assert_matches!(Mnemonic::from_words(words), Err(Error::MnemonicParse { reason, .. }) => reason);
            let reported_words = assert_matches!(reason, MnemonicParseError::UnknownWords(reported_words) => reported_words);

            assert_eq!(reported_words, vec![i]);
        }
    }

    #[test]
    fn unknown_words_2() {
        // a 24 word mnemonic containing the following typos:
        // absorb -> adsorb
        // account -> acount
        // acquire -> acquired
        const MNEMONIC: &str = concat!(
            "abandon ability able about above absent ",
            "adsorb abstract absurd abuse access accident ",
            "acount accuse achieve acid acoustic acquired ",
            "across act action actor actress actual"
        );

        let reason = assert_matches!(Mnemonic::from_str(MNEMONIC), Err(Error::MnemonicParse { reason, .. }) => reason);
        let reported_words = assert_matches!(reason, MnemonicParseError::UnknownWords(reported_words) => reported_words);

        assert_eq!(reported_words, vec![6, 12, 17]);
    }

    #[test]
    fn checksum_mismatch_1() {
        const MNEMONIC: &str = concat!(
            "abandon ability able about above absent ",
            "absorb abstract absurd abuse access accident ",
            "account accuse achieve acid acoustic acquire ",
            "across act action actor actress actual"
        );

        let reason = assert_matches!(Mnemonic::from_str(MNEMONIC), Err(Error::MnemonicParse { reason, .. }) => reason);
        let (expected, actual) = assert_matches!(reason, MnemonicParseError::ChecksumMismatch { expected, actual } => (expected, actual));

        assert_eq!(expected, 0xba);
        assert_eq!(actual, 0x17);
    }

    #[test]
    fn checksum_mismatch_2() {
        const MNEMONIC: &str =
            "abandon ability able about above absent absorb abstract absurd abuse access accident";

        let reason = assert_matches!(Mnemonic::from_str(MNEMONIC), Err(Error::MnemonicParse { reason, .. }) => reason);
        let (expected, actual) = assert_matches!(reason, MnemonicParseError::ChecksumMismatch { expected, actual } => (expected, actual));

        assert_eq!(expected, 0x10);
        assert_eq!(actual, 0xb0);
    }

    // inverse of the `from_string` test.
    #[test]
    fn from_entropy() {
        const ENTROPY: &[&[u8]] = &[
            &hex!("744b201a7c399733691c2fda5c6f605ceb0c016882cb14f64ea9eb5b6d68298b"),
            &hex!("e2674c8eb2fcada0c433984da6f52bac56466f914b49bd1a8087ed8b12b15248"),
            &hex!("b1615de02c5da95e15ee0f646f7c5cb02f41e69c9c71df683c1fc78db9b825c7"),
            &hex!("4e172857ab9ac2563fee9c829a4b2e9b"),
        ];

        for (entropy, s) in ENTROPY.iter().zip(KNOWN_GOOD_MNEMONICS) {
            let mnemonic = Mnemonic(super::MnemonicV2V3::from_entropy(entropy).into());

            assert_eq!(&mnemonic.to_string(), s);
        }
    }

    #[test]
    fn mnemonic_3() {
        // rustfmt does *not* like long strings.
        const MNEMONIC: &str = concat!(
            "obvious favorite remain caution ",
            "remove laptop base vacant ",
            "increase video erase pass ",
            "sniff sausage knock grid ",
            "argue salt romance way ",
            "alone fever slush dune"
        );

        let mnemonic = Mnemonic::from_str(MNEMONIC).unwrap();
        let key = mnemonic.to_legacy_private_key().unwrap();

        // skip the derives and just test the key.
        // (bugs in `legacy_derive` shouldn't make this function fail.)
        expect![[r#"
            PrivateKeyData {
                algorithm: Ed25519,
                key: "98aa82d6125b5efa04bf8372be7931d05cd77f5ef3330b97d6ee7c006eaaf312",
                chain_code: None,
            }
        "#]]
        .assert_debug_eq(key.debug_pretty())
    }

    #[test]
    fn legacy_mnemonic() {
        const MNEMONIC: &str = concat!(
            "jolly kidnap tom lawn drunk chick optic lust mutter mole bride ",
            "galley dense member sage neural widow decide curb aboard margin manure"
        );

        let mnemonic = Mnemonic::from_str(MNEMONIC).unwrap();

        let key = mnemonic.to_legacy_private_key().unwrap();

        expect![[r#"
            PrivateKeyData {
                algorithm: Ed25519,
                key: "00c2f59212cb3417f0ee0d38e7bd876810d04f2dd2cb5c2d8f26ff406573f2bd",
                chain_code: None,
            }
        "#]]
        .assert_debug_eq(key.debug_pretty());
    }

    #[test]
    fn to_private_key() {
        const MNEMONIC: &str = concat!(
            "inmate flip alley wear offer often ",
            "piece magnet surge toddler submit right ",
            "radio absent pear floor belt raven ",
            "price stove replace reduce plate home"
        );

        let mnemonic = Mnemonic::from_str(MNEMONIC).unwrap();

        let key = mnemonic.to_private_key("").unwrap();

        expect![[r#"
            PrivateKeyData {
                algorithm: Ed25519,
                key: "853f15aecd22706b105da1d709b4ac05b4906170c2b9c7495dff9af49e1391da",
                chain_code: Some(
                    "eb001273d3d54073c42a32c17178d00677e8420631716cd57814cad9db0e64fc",
                ),
            }
        "#]]
        .assert_debug_eq(key.debug_pretty());
    }
}
// Filename: src/network_version_info.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use crate::{
    FromProtobuf,
    SemanticVersion,
    ToProtobuf,
};

/// Versions of Hiero Services, and the protobuf schema.
#[derive(Debug, Clone)]
pub struct NetworkVersionInfo {
    /// Version of the protobuf schema in use by the network.
    pub protobuf_version: SemanticVersion,

    /// Version of the Hiero services in use by the network.
    pub services_version: SemanticVersion,
}

impl NetworkVersionInfo {
    /// Create a new `NetworkVersionInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::NetworkGetVersionInfoResponse>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::response::Response> for NetworkVersionInfo {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let pb = pb_getv!(pb, NetworkGetVersionInfo, services::response::Response);
        Self::from_protobuf(pb)
    }
}

impl FromProtobuf<services::NetworkGetVersionInfoResponse> for NetworkVersionInfo {
    fn from_protobuf(pb: services::NetworkGetVersionInfoResponse) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let protobuf_version = pb_getf!(pb, hapi_proto_version)?;
        let services_version = pb_getf!(pb, hedera_services_version)?;

        Ok(Self {
            protobuf_version: SemanticVersion::from_protobuf(protobuf_version)?,
            services_version: SemanticVersion::from_protobuf(services_version)?,
        })
    }
}

impl ToProtobuf for NetworkVersionInfo {
    type Protobuf = services::NetworkGetVersionInfoResponse;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::NetworkGetVersionInfoResponse {
            header: None,
            hapi_proto_version: Some(self.protobuf_version.to_protobuf()),
            hedera_services_version: Some(self.services_version.to_protobuf()),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::protobuf::ToProtobuf;
    use crate::NetworkVersionInfo;

    const INFO: NetworkVersionInfo = NetworkVersionInfo {
        protobuf_version: crate::SemanticVersion {
            major: 1,
            minor: 2,
            patch: 3,
            prerelease: String::new(),
            build: String::new(),
        },
        services_version: crate::SemanticVersion {
            major: 4,
            minor: 5,
            patch: 6,
            prerelease: String::new(),
            build: String::new(),
        },
    };

    #[test]
    fn serialize() {
        expect![[r#"
            NetworkGetVersionInfoResponse {
                header: None,
                hapi_proto_version: Some(
                    SemanticVersion {
                        major: 1,
                        minor: 2,
                        patch: 3,
                        pre: "",
                        build: "",
                    },
                ),
                hedera_services_version: Some(
                    SemanticVersion {
                        major: 4,
                        minor: 5,
                        patch: 6,
                        pre: "",
                        build: "",
                    },
                ),
            }
        "#]]
        .assert_debug_eq(&INFO.to_protobuf());
    }

    #[test]
    fn to_from_bytes() {
        let a = INFO;
        let b = NetworkVersionInfo::from_bytes(&a.to_bytes()).unwrap();

        assert_eq!(a.protobuf_version.to_string(), b.protobuf_version.to_string());
        assert_eq!(a.services_version.to_string(), b.services_version.to_string());
    }
}
// Filename: src/network_version_info_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::network_service_client::NetworkServiceClient;
use tonic::transport::Channel;

use crate::entity_id::ValidateChecksums;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    Error,
    NetworkVersionInfo,
    Query,
};

/// Get information about the versions of protobuf and hedera.
pub type NetworkVersionInfoQuery = Query<NetworkVersionInfoQueryData>;

#[derive(Default, Clone, Debug)]
#[non_exhaustive]
pub struct NetworkVersionInfoQueryData {}

impl From<NetworkVersionInfoQueryData> for AnyQueryData {
    #[inline]
    fn from(data: NetworkVersionInfoQueryData) -> Self {
        Self::NetworkVersionInfo(data)
    }
}

impl ToQueryProtobuf for NetworkVersionInfoQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        services::Query {
            query: Some(services::query::Query::NetworkGetVersionInfo(
                services::NetworkGetVersionInfoQuery { header: Some(header) },
            )),
        }
    }
}

impl QueryExecute for NetworkVersionInfoQueryData {
    type Response = NetworkVersionInfo;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { NetworkServiceClient::new(channel).get_version_info(request).await })
    }
}

impl ValidateChecksums for NetworkVersionInfoQueryData {
    fn validate_checksums(&self, _ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        Hbar,
        NetworkVersionInfoQuery,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    NetworkGetVersionInfo(
                        NetworkGetVersionInfoQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &NetworkVersionInfoQuery::new()
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        )
    }
}
// Filename: src/node_address.rs
// SPDX-License-Identifier: Apache-2.0

use std::net::SocketAddrV4;

use hedera_proto::services;

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    Error,
    FromProtobuf,
};

fn parse_socket_addr_v4(ip: Vec<u8>, port: i32) -> crate::Result<SocketAddrV4> {
    let octets: Result<[u8; 4], _> = ip.try_into();
    let octets = octets.map_err(|v| {
        Error::from_protobuf(format!("expected 4 byte ip address, got `{}` bytes", v.len()))
    })?;

    let port = u16::try_from(port).map_err(|_| {
        Error::from_protobuf(format!(
            "expected 16 bit non-negative port number, but the port was actually `{port}`",
        ))
    })?;

    Ok(SocketAddrV4::new(octets.into(), port))
}

/// The data about a node, including its service endpoints and the Hiero account to be paid for
/// services provided by the node (that is, queries answered and transactions submitted.).
#[derive(Debug, Clone)]
pub struct NodeAddress {
    /// A non-sequential, unique, static identifier for the node
    pub node_id: u64,

    /// The node's X509 RSA public key used to sign stream files.
    pub rsa_public_key: Vec<u8>,

    /// The account to be paid for queries and transactions sent to this node.
    pub node_account_id: AccountId,

    /// Hash of the node's TLS certificate.
    ///
    /// Precisely, this field is a string of
    /// hexadecimal characters which, translated to binary, are the SHA-384 hash of
    /// the UTF-8 NFKD encoding of the node's TLS cert in PEM format.
    ///
    /// Its value can be used to verify the node's certificate it presents during TLS negotiations.
    pub tls_certificate_hash: Vec<u8>,

    /// A node's service IP addresses and ports.
    pub service_endpoints: Vec<SocketAddrV4>,

    /// A description of the node, up to 100 bytes.
    pub description: String,
}

impl FromProtobuf<services::NodeAddress> for NodeAddress {
    fn from_protobuf(pb: services::NodeAddress) -> crate::Result<Self>
    where
        Self: Sized,
    {
        // sometimes this will be oversized by 1, but that's fine.
        let mut addresses = Vec::with_capacity(pb.service_endpoint.len() + 1);

        // `ip_address`/`portno` are deprecated, but lets handle them anyway.
        #[allow(deprecated)]
        if !pb.ip_address.is_empty() {
            addresses.push(parse_socket_addr_v4(pb.ip_address, pb.portno)?);
        }

        for address in pb.service_endpoint {
            addresses.push(parse_socket_addr_v4(address.ip_address_v4, address.port)?);
        }

        let node_account_id = AccountId::from_protobuf(pb_getf!(pb, node_account_id)?)?;

        Ok(Self {
            description: pb.description,
            rsa_public_key: hex::decode(pb.rsa_pub_key).map_err(Error::from_protobuf)?,
            node_id: pb.node_id as u64,
            service_endpoints: addresses,
            tls_certificate_hash: pb.node_cert_hash,
            node_account_id,
        })
    }
}

impl ToProtobuf for NodeAddress {
    type Protobuf = services::NodeAddress;

    fn to_protobuf(&self) -> Self::Protobuf {
        let service_endpoint = self
            .service_endpoints
            .iter()
            .map(|it| services::ServiceEndpoint {
                ip_address_v4: it.ip().octets().to_vec(),
                port: i32::from(it.port()),
                domain_name: it.to_string(),
            })
            .collect();

        services::NodeAddress {
            rsa_pub_key: hex::encode(&self.rsa_public_key),
            node_id: self.node_id as i64,
            node_account_id: Some(self.node_account_id.to_protobuf()),
            node_cert_hash: self.tls_certificate_hash.clone(),
            service_endpoint,
            description: self.description.clone(),

            // deprecated fields
            ..Default::default()
        }
    }
}
// Filename: src/node_address_book.rs
use hedera_proto::services;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::NodeAddress;

/// A list of nodes and their metadata.
///
/// Response from [`NodeAddressBookQuery`](crate::NodeAddressBookQuery)
#[derive(Clone, Debug)]
pub struct NodeAddressBook {
    /// all the nodes this address book contains.
    pub node_addresses: Vec<NodeAddress>,
}

impl NodeAddressBook {
    /// Create a new `NodeAddressBook` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::NodeAddressBook> for NodeAddressBook {
    fn from_protobuf(pb: services::NodeAddressBook) -> crate::Result<Self> {
        Ok(Self { node_addresses: Vec::from_protobuf(pb.node_address)? })
    }
}

impl ToProtobuf for NodeAddressBook {
    type Protobuf = services::NodeAddressBook;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::NodeAddressBook { node_address: self.node_addresses.to_protobuf() }
    }
}
// Filename: src/node_address_book_query.rs
// SPDX-License-Identifier: Apache-2.0

use std::time::Duration;

use futures_core::future::BoxFuture;
use futures_core::stream::BoxStream;
use futures_core::Stream;
use futures_util::{
    TryFutureExt,
    TryStreamExt,
};
use hedera_proto::{
    mirror,
    services,
};
use mirror::network_service_client::NetworkServiceClient;
use tonic::transport::Channel;
use tonic::Response;

use crate::mirror_query::{
    AnyMirrorQueryData,
    AnyMirrorQueryMessage,
    MirrorRequest,
};
use crate::protobuf::FromProtobuf;
use crate::{
    AnyMirrorQueryResponse,
    FileId,
    MirrorQuery,
    NodeAddress,
    NodeAddressBook,
    ToProtobuf,
};

// TODO: validate checksums after PR is merged

/// Query for an address book and return its nodes.
/// The nodes are returned in ascending order by node ID.
pub type NodeAddressBookQuery = MirrorQuery<NodeAddressBookQueryData>;

#[derive(Debug, Clone)]
pub struct NodeAddressBookQueryData {
    /// The ID of the address book file on the network.
    /// Can either be `0.0.101` or `0.0.102`. Defaults to `0.0.102`.
    file_id: FileId,

    /// The maximum number of node addresses to receive.
    /// Defaults to _all_.
    limit: u32,
}

impl NodeAddressBookQueryData {
    fn map_stream<'a, S>(stream: S) -> impl Stream<Item = crate::Result<NodeAddress>>
    where
        S: Stream<Item = crate::Result<services::NodeAddress>> + Send + 'a,
    {
        stream.and_then(|it| std::future::ready(NodeAddress::from_protobuf(it)))
    }
}

impl Default for NodeAddressBookQueryData {
    fn default() -> Self {
        Self { file_id: FileId::ADDRESS_BOOK, limit: 0 }
    }
}

impl NodeAddressBookQuery {
    /// Returns the file ID of the address book file on the network.
    #[must_use]
    pub fn get_file_id(&self) -> FileId {
        self.data.file_id
    }

    /// Sets the ID of the address book file on the network.
    /// Can either be `0.0.101` or `0.0.102`. Defaults to `0.0.102`.
    pub fn file_id(&mut self, id: impl Into<FileId>) -> &mut Self {
        self.data.file_id = id.into();
        self
    }

    /// Returns the configured limit of node addresses to receive.
    #[must_use]
    pub fn get_limit(&self) -> u32 {
        self.data.limit
    }

    /// Sets the maximum number of node addresses to receive.
    /// Defaults to _all_.
    pub fn limit(&mut self, limit: u32) -> &mut Self {
        self.data.limit = limit;
        self
    }
}

impl From<NodeAddressBookQueryData> for AnyMirrorQueryData {
    fn from(data: NodeAddressBookQueryData) -> Self {
        Self::NodeAddressBook(data)
    }
}

impl MirrorRequest for NodeAddressBookQueryData {
    type GrpcItem = services::NodeAddress;

    type ConnectStream = tonic::Streaming<Self::GrpcItem>;

    type Item = NodeAddress;

    type Context = ();

    type Response = NodeAddressBook;

    type ItemStream<'a> = BoxStream<'a, crate::Result<NodeAddress>>;

    fn connect(
        &self,
        _context: &Self::Context,
        channel: Channel,
    ) -> BoxFuture<'_, tonic::Result<Self::ConnectStream>> {
        Box::pin(async {
            let file_id = self.file_id.to_protobuf();
            let request =
                mirror::AddressBookQuery { file_id: Some(file_id), limit: self.limit as i32 };

            NetworkServiceClient::new(channel).get_nodes(request).await.map(Response::into_inner)
        })
    }

    fn make_item_stream<'a, S>(stream: S) -> Self::ItemStream<'a>
    where
        S: Stream<Item = crate::Result<Self::GrpcItem>> + Send + 'a,
    {
        Box::pin(Self::map_stream(stream))
    }

    fn try_collect<'a, S>(stream: S) -> BoxFuture<'a, crate::Result<Self::Response>>
    where
        S: Stream<Item = crate::Result<Self::GrpcItem>> + Send + 'a,
    {
        // this doesn't reuse the work in `make_item_stream`
        Box::pin(
            Self::map_stream(stream)
                .try_collect()
                .map_ok(|addresses| NodeAddressBook { node_addresses: addresses }),
        )
    }

    fn update_context(_context: &mut Self::Context, _item: &Self::GrpcItem) {}
}

impl From<NodeAddress> for AnyMirrorQueryMessage {
    fn from(value: NodeAddress) -> Self {
        Self::NodeAddressBook(value)
    }
}

impl From<NodeAddressBook> for AnyMirrorQueryResponse {
    fn from(value: NodeAddressBook) -> Self {
        Self::NodeAddressBook(value)
    }
}

impl NodeAddressBookQuery {
    pub(crate) async fn execute_mirrornet(
        &self,
        channel: Channel,
        timeout: Option<Duration>,
    ) -> crate::Result<NodeAddressBook> {
        let timeout = timeout.unwrap_or_else(|| {
            std::time::Duration::from_millis(backoff::default::MAX_ELAPSED_TIME_MILLIS)
        });

        NodeAddressBookQueryData::try_collect(crate::mirror_query::subscribe(
            channel,
            timeout,
            self.data.clone(),
        ))
        .await
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        FileId,
        NodeAddressBookQuery,
    };

    #[test]
    fn get_set_file_id() {
        let mut query = NodeAddressBookQuery::new();
        query.file_id(FileId::new(0, 0, 1111));

        assert_eq!(query.get_file_id(), FileId::new(0, 0, 1111));
    }

    #[test]
    fn get_set_limit() {
        let mut query = NodeAddressBookQuery::new();
        query.limit(231);

        assert_eq!(query.get_limit(), 231);
    }
}
// Filename: src/pending_airdrop_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt;

use hedera_proto::services;

use crate::ledger_id::RefLedgerId;
use crate::{
    AccountId,
    Error,
    FromProtobuf,
    NftId,
    ToProtobuf,
    TokenId,
    ValidateChecksums,
};

/// A unique, composite, identifier for a pending airdrop.
///
/// Each pending airdrop SHALL be uniquely identified by a PendingAirdropId.
/// A PendingAirdropId SHALL be recorded when created and MUST be provided in any transaction
/// that would modify that pending airdrop (such as a `claimAirdrop` or `cancelAirdrop`).
///
#[derive(Clone, Copy, Eq, PartialEq, Hash)]
pub struct PendingAirdropId {
    /// A sending account.
    ///
    /// This is the account that initiated, and SHALL fund, this pending airdrop.
    /// This field is REQUIRED.
    pub sender_id: AccountId,

    /// A receiving account.
    ///
    /// This is the ID of the account that SHALL receive the airdrop.
    /// This field is REQUIRED.
    pub receiver_id: AccountId,

    /// Token Id.
    pub token_id: Option<TokenId>,

    /// Nft Id.
    pub nft_id: Option<NftId>,
}

impl fmt::Debug for PendingAirdropId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PendingAirdropId")
            .field("sender_id", &self.sender_id)
            .field("receiver_id", &self.receiver_id)
            .field("token_id", &self.token_id)
            .field("nft_id", &self.nft_id)
            .finish()
    }
}

impl fmt::Display for PendingAirdropId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "PendingAirdropId {{ sender_id: {}, receiver_id: {}, token_id: {}, nft_id: {} }}",
            self.sender_id,
            self.receiver_id,
            self.token_id.map_or_else(|| "None".to_string(), |v| v.to_string()),
            self.nft_id.map_or_else(|| "None".to_string(), |v| v.to_string()),
        )
    }
}

impl PendingAirdropId {
    pub const fn new_nft_id(sender_id: AccountId, receiver_id: AccountId, nft_id: NftId) -> Self {
        Self { sender_id, receiver_id, token_id: None, nft_id: Some(nft_id) }
    }

    pub const fn new_token_id(
        sender_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
    ) -> Self {
        Self { sender_id, receiver_id, token_id: Some(token_id), nft_id: None }
    }

    /// Create a new `PendingAirdropId` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl ValidateChecksums for PendingAirdropId {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        let _ = self.sender_id.validate_checksums(ledger_id);
        let _ = self.receiver_id.validate_checksums(ledger_id);

        if let Some(token_id) = self.token_id {
            token_id.validate_checksums(ledger_id)?
        };

        if let Some(nft_id) = &self.nft_id {
            nft_id.validate_checksums(ledger_id)?
        }

        Ok(())
    }
}

impl FromProtobuf<services::PendingAirdropId> for PendingAirdropId {
    fn from_protobuf(pb: services::PendingAirdropId) -> crate::Result<Self> {
        let sender_id = AccountId::from_protobuf(pb_getf!(pb, sender_id)?)?;
        let receiver_id = AccountId::from_protobuf(pb_getf!(pb, receiver_id)?)?;

        let nft_id = if let Some(reference) = pb.token_reference.clone() {
            match reference {
                services::pending_airdrop_id::TokenReference::NonFungibleToken(nft_id) => {
                    Some(NftId::from_protobuf(nft_id)?)
                }
                _ => None,
            }
        } else {
            None
        };

        let token_id = if let Some(token) = pb.token_reference {
            match token {
                services::pending_airdrop_id::TokenReference::FungibleTokenType(token_id) => {
                    Some(TokenId::from_protobuf(token_id)?)
                }
                _ => None,
            }
        } else {
            None
        };

        Ok(Self { sender_id, receiver_id, token_id, nft_id })
    }
}

impl ToProtobuf for PendingAirdropId {
    type Protobuf = services::PendingAirdropId;

    fn to_protobuf(&self) -> Self::Protobuf {
        let nft_id = self.nft_id.as_ref().map(|nft_id| nft_id.to_protobuf());
        let token_id = self.token_id.as_ref().map(|token_id| token_id.to_protobuf());

        let token_reference = if let Some(nft_id) = nft_id {
            Some(services::pending_airdrop_id::TokenReference::NonFungibleToken(nft_id))
        } else if let Some(token_id) = token_id {
            Some(services::pending_airdrop_id::TokenReference::FungibleTokenType(token_id))
        } else {
            None
        };

        services::PendingAirdropId {
            sender_id: Some(self.sender_id.to_protobuf()),
            receiver_id: Some(self.receiver_id.to_protobuf()),
            token_reference,
        }
    }
}
// Filename: src/pending_airdrop_record.rs
// SPDX-License-Identifier: Apache-2.0

use core::fmt;

use hedera_proto::services;

use crate::pending_airdrop_id::PendingAirdropId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};

/// A record of a new pending airdrop.
#[derive(Clone)]
pub struct PendingAirdropRecord {
    /// A unique, composite, identifier for a pending airdrop.
    /// This field is REQUIRED.
    pub pending_airdrop_id: PendingAirdropId,

    /// A single pending airdrop amount.
    pub pending_airdrop_value: Option<u64>,
}

impl fmt::Debug for PendingAirdropRecord {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PendingAirdropRecord")
            .field("pending_airdrop_id", &self.pending_airdrop_id)
            .field("pending_airdrop_value", &self.pending_airdrop_value)
            .finish()
    }
}

impl fmt::Display for PendingAirdropRecord {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "PendingAirdropRecord {{ id: {}, value: {} }}",
            self.pending_airdrop_id,
            self.pending_airdrop_value.map_or_else(|| "None".to_string(), |v| v.to_string())
        )
    }
}

impl PendingAirdropRecord {
    /// Create a new `NodeAddressBook` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::PendingAirdropRecord> for PendingAirdropRecord {
    fn from_protobuf(pb: services::PendingAirdropRecord) -> crate::Result<Self> {
        let airdrop_id = PendingAirdropId::from_protobuf(pb_getf!(pb, pending_airdrop_id)?)?;
        Ok(Self {
            pending_airdrop_id: airdrop_id,
            pending_airdrop_value: pb.pending_airdrop_value.map(|v| v.amount),
        })
    }
}

impl ToProtobuf for PendingAirdropRecord {
    type Protobuf = services::PendingAirdropRecord;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::PendingAirdropRecord {
            pending_airdrop_id: Some(self.pending_airdrop_id.to_protobuf()),
            pending_airdrop_value: self
                .pending_airdrop_value
                .map(|v| hedera_proto::services::PendingAirdropValue { amount: v }),
        }
    }
}
// Filename: src/ping_query.rs
use std::time::Duration;

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;

use crate::entity_id::ValidateChecksums;
use crate::execute::{
    execute,
    Execute,
};
use crate::protobuf::ToProtobuf;
use crate::query::response_header;
use crate::{
    AccountId,
    Client,
};

/// Internal "query" to ping a specific node.
///
/// This is *here* so that it can change implementation at will.
/// `PingQuery` is an `AccountBalanceQuery`-ish for now,
/// but it doesn't have to stay that way.
///
/// It's also ideally smaller/faster than any other query, by virtue of just...
pub(crate) struct PingQuery {
    node_account_id: AccountId,
}

impl PingQuery {
    pub(crate) fn new(node_account_id: AccountId) -> Self {
        Self { node_account_id }
    }

    pub(crate) async fn execute(
        &self,
        client: &Client,
        timeout: Option<Duration>,
    ) -> crate::Result<()> {
        execute(client, self, timeout).await
    }
}

impl ValidateChecksums for PingQuery {
    fn validate_checksums(
        &self,
        ledger_id: &crate::ledger_id::RefLedgerId,
    ) -> Result<(), crate::Error> {
        self.node_account_id.validate_checksums(ledger_id)
    }
}

impl Execute for PingQuery {
    type GrpcRequest = services::Query;

    type GrpcResponse = services::Response;

    type Context = ();

    type Response = ();

    fn node_account_ids(&self) -> Option<&[AccountId]> {
        Some(std::slice::from_ref(&self.node_account_id))
    }

    fn transaction_id(&self) -> Option<crate::TransactionId> {
        None
    }

    fn operator_account_id(&self) -> Option<&AccountId> {
        None
    }

    fn requires_transaction_id(&self) -> bool {
        false
    }

    fn make_request(
        &self,
        _transaction_id: Option<&crate::TransactionId>,
        node_account_id: AccountId,
    ) -> crate::Result<(Self::GrpcRequest, Self::Context)> {
        const HEADER: services::QueryHeader = services::QueryHeader {
            payment: None,
            response_type: services::ResponseType::AnswerOnly as i32,
        };

        debug_assert_eq!(node_account_id, self.node_account_id);

        let query = services::Query {
            query: Some(services::query::Query::CryptogetAccountBalance(
                services::CryptoGetAccountBalanceQuery {
                    balance_source: Some(
                        services::crypto_get_account_balance_query::BalanceSource::AccountId(
                            self.node_account_id.to_protobuf(),
                        ),
                    ),
                    header: Some(HEADER),
                },
            )),
        };

        Ok((query, ()))
    }

    fn execute(
        &self,
        channel: tonic::transport::Channel,
        request: Self::GrpcRequest,
    ) -> crate::BoxGrpcFuture<Self::GrpcResponse> {
        Box::pin(async { CryptoServiceClient::new(channel).crypto_get_balance(request).await })
    }

    fn make_response(
        &self,
        _response: Self::GrpcResponse,
        _context: Self::Context,
        _node_account_id: AccountId,
        _transaction_id: Option<&crate::TransactionId>,
    ) -> crate::Result<Self::Response> {
        Ok(())
    }

    fn make_error_pre_check(
        &self,
        status: hedera_proto::services::ResponseCodeEnum,
        _transaction_id: Option<&crate::TransactionId>,
        _response: Self::GrpcResponse,
    ) -> crate::Error {
        crate::Error::QueryNoPaymentPreCheckStatus { status }
    }

    fn response_pre_check_status(response: &Self::GrpcResponse) -> crate::Result<i32> {
        Ok(response_header(&response.response)?.node_transaction_precheck_code)
    }
}
// Filename: src/prng_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::util_service_client::UtilServiceClient;

use crate::entity_id::ValidateChecksums;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::Transaction;

/// Random Number Generator Transaction.
pub type PrngTransaction = Transaction<PrngTransactionData>;

#[derive(Debug, Clone, Default)]
#[cfg_attr(test, derive(Eq, PartialEq))]
pub struct PrngTransactionData {
    range: Option<u32>,
}

impl PrngTransaction {
    /// Returns the upper-bound for the random number.
    pub fn get_range(&self) -> Option<u32> {
        self.data().range
    }

    /// Sets the upper-bound for the random number.
    ///
    /// If the value is zero, instead of returning a 32-bit number, a 384-bit number will be returned.
    pub fn range(&mut self, range: u32) -> &mut Self {
        self.data_mut().range = Some(range);

        self
    }
}

impl FromProtobuf<services::UtilPrngTransactionBody> for PrngTransactionData {
    fn from_protobuf(pb: services::UtilPrngTransactionBody) -> crate::Result<Self> {
        Ok(Self { range: (pb.range != 0).then_some(pb.range as u32) })
    }
}

impl ToProtobuf for PrngTransactionData {
    type Protobuf = services::UtilPrngTransactionBody;
    fn to_protobuf(&self) -> Self::Protobuf {
        services::UtilPrngTransactionBody { range: self.range.unwrap_or_default() as i32 }
    }
}

impl TransactionData for PrngTransactionData {}

impl From<PrngTransactionData> for AnyTransactionData {
    fn from(value: PrngTransactionData) -> Self {
        Self::Prng(value)
    }
}

impl ValidateChecksums for PrngTransactionData {
    fn validate_checksums(&self, _ledger_id: &crate::ledger_id::RefLedgerId) -> crate::Result<()> {
        Ok(())
    }
}

impl ToSchedulableTransactionDataProtobuf for PrngTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::UtilPrng(self.to_protobuf())
    }
}

impl ToTransactionDataProtobuf for PrngTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::UtilPrng(self.to_protobuf())
    }
}

impl TransactionExecute for PrngTransactionData {
    fn execute(
        &self,
        channel: tonic::transport::Channel,
        request: services::Transaction,
    ) -> crate::BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { UtilServiceClient::new(channel).prng(request).await })
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        PrngTransaction,
    };

    fn make_transaction() -> PrngTransaction {
        let mut tx = PrngTransaction::new_for_tests();

        tx.freeze().unwrap();

        tx
    }

    fn make_transaction2() -> PrngTransaction {
        let mut tx = PrngTransaction::new_for_tests();

        tx.range(100).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            UtilPrng(
                UtilPrngTransactionBody {
                    range: 0,
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn serialize2() {
        let tx = make_transaction2();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            UtilPrng(
                UtilPrngTransactionBody {
                    range: 100,
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes2() {
        let tx = make_transaction2();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }
}
// Filename: src/protobuf/convert.rs
// SPDX-License-Identifier: Apache-2.0

use crate::Error;

/// Convert to a `hedera_protobufs` type.
pub trait ToProtobuf: Send + Sync {
    /// The protobuf output.
    type Protobuf;

    /// Convert from [`self`](Self) to [`Self::Protobuf`].
    fn to_protobuf(&self) -> Self::Protobuf;

    /// Convert [`self`](Self) to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    fn to_bytes(&self) -> Vec<u8>
    where
        Self::Protobuf: prost::Message,
    {
        use prost::Message as _;
        self.to_protobuf().encode_to_vec()
    }
}

impl<T: ToProtobuf> ToProtobuf for Option<T> {
    type Protobuf = Option<T::Protobuf>;

    fn to_protobuf(&self) -> Self::Protobuf {
        self.as_ref().map(T::to_protobuf)
    }
}

impl<T: ToProtobuf> ToProtobuf for Box<T> {
    type Protobuf = T::Protobuf;

    fn to_protobuf(&self) -> Self::Protobuf {
        T::to_protobuf(self)
    }
}

impl<T: ToProtobuf> ToProtobuf for Vec<T> {
    type Protobuf = Vec<T::Protobuf>;

    fn to_protobuf(&self) -> Self::Protobuf {
        self.iter().map(T::to_protobuf).collect()
    }
}

/// Convert from a `hedera_protobufs` type.
pub trait FromProtobuf<Protobuf>
where
    Self: Sized,
{
    /// Attempt to convert from `Protobuf` to `Self`.
    // todo: errors
    #[allow(clippy::missing_errors_doc)]
    fn from_protobuf(pb: Protobuf) -> crate::Result<Self>;

    /// Create a new `Self` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`] if `Protobuf` fails to decode from the bytes.
    /// - If [`from_protobuf`](Self::from_protobuf) would fail.
    fn from_bytes(bytes: &[u8]) -> crate::Result<Self>
    where
        Protobuf: prost::Message + Default,
    {
        Protobuf::decode(bytes).map_err(Error::from_protobuf).and_then(Self::from_protobuf)
    }
}

impl<T, P> FromProtobuf<Option<P>> for Option<T>
where
    T: FromProtobuf<P>,
{
    fn from_protobuf(pb: Option<P>) -> crate::Result<Self>
    where
        Self: Sized,
    {
        pb.map(T::from_protobuf).transpose()
    }
}

impl<T, P> FromProtobuf<Vec<P>> for Vec<T>
where
    T: FromProtobuf<P>,
{
    fn from_protobuf(pb: Vec<P>) -> crate::Result<Self>
    where
        Self: Sized,
    {
        pb.into_iter().map(T::from_protobuf).collect()
    }
}
// Filename: src/protobuf/get.rs
// SPDX-License-Identifier: Apache-2.0

/// Get an optional field from a protobuf object, returning an error if the field does not exist.
macro_rules! pb_getf {
    ($expr:expr, $field:ident) => {{
        $expr.$field.ok_or_else(|| {
            $crate::Error::from_protobuf(concat!("unexpected missing `", stringify!($field), "`"))
        })
    }};
}

/// Get a specific variant from a `oneof` field of a protobuf object, returning an error
/// if the variant is not as expected.
macro_rules! pb_getv {
    ($expr:expr, $variant:ident, $ty:ty) => {{
        use $ty::*;

        match $expr {
            $variant(it) => it,

            _ => {
                return Err($crate::Error::from_protobuf(format!(
                    concat!("unexpected {:?} received, expecting `", stringify!($variant), "`"),
                    $expr
                )));
            }
        }
    }};
}
// Filename: src/protobuf/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod convert;
mod time;

#[macro_use]
pub(crate) mod get;

pub(crate) use convert::{
    FromProtobuf,
    ToProtobuf,
};
// Filename: src/protobuf/time.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use time::{
    Duration,
    OffsetDateTime,
};

use crate::ToProtobuf;

impl ToProtobuf for Duration {
    type Protobuf = services::Duration;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::Duration { seconds: self.whole_seconds() }
    }
}

impl ToProtobuf for OffsetDateTime {
    type Protobuf = services::Timestamp;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::Timestamp { seconds: self.unix_timestamp(), nanos: self.nanosecond() as i32 }
    }
}
// Filename: src/query/any.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use tonic::transport::Channel;

use super::ToQueryProtobuf;
use crate::account::{
    AccountBalanceQueryData,
    AccountInfoQueryData,
    AccountRecordsQueryData,
};
use crate::contract::{
    ContractBytecodeQueryData,
    ContractCallQueryData,
    ContractInfoQueryData,
};
use crate::entity_id::ValidateChecksums;
use crate::file::{
    FileContentsQueryData,
    FileInfoQueryData,
};
use crate::ledger_id::RefLedgerId;
use crate::query::QueryExecute;
use crate::schedule::ScheduleInfoQueryData;
use crate::token::{
    TokenInfoQueryData,
    TokenNftInfoQueryData,
};
use crate::topic::TopicInfoQueryData;
use crate::transaction_receipt_query::TransactionReceiptQueryData;
use crate::{
    AccountBalance,
    AccountInfo,
    AllProxyStakers,
    BoxGrpcFuture,
    ContractFunctionResult,
    ContractInfo,
    Error,
    FileContentsResponse,
    FileInfo,
    FromProtobuf,
    Hbar,
    NetworkVersionInfo,
    NetworkVersionInfoQueryData,
    Query,
    ScheduleInfo,
    TokenInfo,
    TokenNftInfo,
    TopicInfo,
    TransactionReceipt,
    TransactionRecord,
    TransactionRecordQueryData,
};

/// Any possible query that may be executed on the Hiero network.
pub type AnyQuery = Query<AnyQueryData>;

#[derive(Debug, Clone)]
pub enum AnyQueryData {
    AccountBalance(AccountBalanceQueryData),
    AccountInfo(AccountInfoQueryData),
    AccountRecords(AccountRecordsQueryData),
    TransactionReceipt(TransactionReceiptQueryData),
    TransactionRecord(TransactionRecordQueryData),
    FileContents(FileContentsQueryData),
    FileInfo(FileInfoQueryData),
    ContractBytecode(ContractBytecodeQueryData),
    ContractCall(ContractCallQueryData),
    TokenInfo(TokenInfoQueryData),
    ContractInfo(ContractInfoQueryData),
    TokenNftInfo(TokenNftInfoQueryData),
    TopicInfo(TopicInfoQueryData),
    ScheduleInfo(ScheduleInfoQueryData),
    NetworkVersionInfo(NetworkVersionInfoQueryData),
}

// todo: strategically box fields of variants, rather than the entire structs.
/// Common response type for *all* queries.
#[derive(Debug, Clone)]
pub enum AnyQueryResponse {
    /// Response from [`AccountBalanceQuery`](crate::AccountBalanceQuery).
    AccountBalance(AccountBalance),

    /// Response from [`AccountInfoQuery`](crate::AccountInfoQuery).
    AccountInfo(AccountInfo),

    /// Response from [`AccountStakersQuery`](crate::AccountStakersQuery).
    AccountStakers(AllProxyStakers),

    /// Response from [`AccountRecordsQuery`](crate::AccountRecordsQuery).
    AccountRecords(Vec<TransactionRecord>),

    /// Response from [`TransactionReceiptQuery`](crate::TransactionReceiptQuery).
    TransactionReceipt(TransactionReceipt),

    /// Response from [`TransactionRecordQuery`](crate::TransactionRecordQuery).
    TransactionRecord(Box<TransactionRecord>),

    /// Response from [`FileContentsQuery`](crate::FileContentsQuery).
    FileContents(FileContentsResponse),

    /// Response from [`FileInfoQuery`](crate::FileInfoQuery).
    FileInfo(FileInfo),

    /// Response from [`ContractBytecodeQuery`](crate::ContractBytecodeQuery).
    ContractBytecode(Vec<u8>),

    /// Response from [`ContractCallQuery`](crate::ContractCallQuery).
    ContractCall(ContractFunctionResult),

    /// Response from [`TokenInfoQuery`](crate::TokenInfoQuery).
    TokenInfo(Box<TokenInfo>),

    /// Response from [`TopicInfoQuery`](crate::TopicInfoQuery).
    TopicInfo(TopicInfo),

    /// Response from [`ContractInfoQuery`](crate::ContractInfoQuery).
    ContractInfo(ContractInfo),

    /// Response from [`TokenNftInfoQuery`](crate::TokenNftInfoQuery).
    TokenNftInfo(TokenNftInfo),

    /// Response from [`ScheduleInfoQuery`](crate::ScheduleInfoQuery).
    ScheduleInfo(ScheduleInfo),

    /// Response from [`NetworkVersionInfoQuery`](crate::NetworkVersionInfoQuery).
    NetworkVersionInfo(NetworkVersionInfo),
}

impl ToQueryProtobuf for AnyQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        match self {
            Self::AccountBalance(data) => data.to_query_protobuf(header),
            Self::AccountInfo(data) => data.to_query_protobuf(header),
            Self::AccountRecords(data) => data.to_query_protobuf(header),
            Self::TransactionReceipt(data) => data.to_query_protobuf(header),
            Self::TransactionRecord(data) => data.to_query_protobuf(header),
            Self::FileContents(data) => data.to_query_protobuf(header),
            Self::FileInfo(data) => data.to_query_protobuf(header),
            Self::ContractBytecode(data) => data.to_query_protobuf(header),
            Self::ContractCall(data) => data.to_query_protobuf(header),
            Self::ContractInfo(data) => data.to_query_protobuf(header),
            Self::TokenNftInfo(data) => data.to_query_protobuf(header),
            Self::TokenInfo(data) => data.to_query_protobuf(header),
            Self::TopicInfo(data) => data.to_query_protobuf(header),
            Self::ScheduleInfo(data) => data.to_query_protobuf(header),
            Self::NetworkVersionInfo(data) => data.to_query_protobuf(header),
        }
    }
}

impl QueryExecute for AnyQueryData {
    type Response = AnyQueryResponse;

    fn is_payment_required(&self) -> bool {
        match self {
            Self::AccountInfo(query) => query.is_payment_required(),
            Self::AccountBalance(query) => query.is_payment_required(),
            Self::AccountRecords(query) => query.is_payment_required(),
            Self::TransactionReceipt(query) => query.is_payment_required(),
            Self::TransactionRecord(query) => query.is_payment_required(),
            Self::FileContents(query) => query.is_payment_required(),
            Self::FileInfo(query) => query.is_payment_required(),
            Self::ContractBytecode(query) => query.is_payment_required(),
            Self::ContractCall(query) => query.is_payment_required(),
            Self::ContractInfo(query) => query.is_payment_required(),
            Self::TokenNftInfo(query) => query.is_payment_required(),
            Self::TokenInfo(query) => query.is_payment_required(),
            Self::TopicInfo(query) => query.is_payment_required(),
            Self::ScheduleInfo(query) => query.is_payment_required(),
            Self::NetworkVersionInfo(query) => query.is_payment_required(),
        }
    }

    fn map_cost(&self, cost: Hbar) -> Hbar {
        match self {
            Self::AccountInfo(query) => query.map_cost(cost),
            Self::AccountBalance(query) => query.map_cost(cost),
            Self::AccountRecords(query) => query.map_cost(cost),
            Self::TransactionReceipt(query) => query.map_cost(cost),
            Self::TransactionRecord(query) => query.map_cost(cost),
            Self::FileContents(query) => query.map_cost(cost),
            Self::FileInfo(query) => query.map_cost(cost),
            Self::ContractBytecode(query) => query.map_cost(cost),
            Self::ContractCall(query) => query.map_cost(cost),
            Self::ContractInfo(query) => query.map_cost(cost),
            Self::TokenNftInfo(query) => query.map_cost(cost),
            Self::TokenInfo(query) => query.map_cost(cost),
            Self::TopicInfo(query) => query.map_cost(cost),
            Self::ScheduleInfo(query) => query.map_cost(cost),
            Self::NetworkVersionInfo(query) => query.map_cost(cost),
        }
    }

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        match self {
            Self::AccountInfo(query) => query.execute(channel, request),
            Self::AccountBalance(query) => query.execute(channel, request),
            Self::AccountRecords(query) => query.execute(channel, request),
            Self::TransactionReceipt(query) => query.execute(channel, request),
            Self::TransactionRecord(query) => query.execute(channel, request),
            Self::FileContents(query) => query.execute(channel, request),
            Self::FileInfo(query) => query.execute(channel, request),
            Self::ContractBytecode(query) => query.execute(channel, request),
            Self::ContractCall(query) => query.execute(channel, request),
            Self::ContractInfo(query) => query.execute(channel, request),
            Self::TokenNftInfo(query) => query.execute(channel, request),
            Self::TokenInfo(query) => query.execute(channel, request),
            Self::TopicInfo(query) => query.execute(channel, request),
            Self::ScheduleInfo(query) => query.execute(channel, request),
            Self::NetworkVersionInfo(query) => query.execute(channel, request),
        }
    }

    fn should_retry_pre_check(&self, status: crate::Status) -> bool {
        match self {
            Self::AccountInfo(query) => query.should_retry_pre_check(status),
            Self::AccountBalance(query) => query.should_retry_pre_check(status),
            Self::AccountRecords(query) => query.should_retry_pre_check(status),
            Self::TransactionReceipt(query) => query.should_retry_pre_check(status),
            Self::TransactionRecord(query) => query.should_retry_pre_check(status),
            Self::FileContents(query) => query.should_retry_pre_check(status),
            Self::FileInfo(query) => query.should_retry_pre_check(status),
            Self::ContractBytecode(query) => query.should_retry_pre_check(status),
            Self::ContractCall(query) => query.should_retry_pre_check(status),
            Self::ContractInfo(query) => query.should_retry_pre_check(status),
            Self::TokenNftInfo(query) => query.should_retry_pre_check(status),
            Self::TokenInfo(query) => query.should_retry_pre_check(status),
            Self::TopicInfo(query) => query.should_retry_pre_check(status),
            Self::ScheduleInfo(query) => query.should_retry_pre_check(status),
            Self::NetworkVersionInfo(query) => query.should_retry_pre_check(status),
        }
    }

    fn should_retry(&self, response: &services::Response) -> bool {
        match self {
            Self::AccountInfo(query) => query.should_retry(response),
            Self::AccountBalance(query) => query.should_retry(response),
            Self::AccountRecords(query) => query.should_retry(response),
            Self::TransactionReceipt(query) => query.should_retry(response),
            Self::TransactionRecord(query) => query.should_retry(response),
            Self::FileContents(query) => query.should_retry(response),
            Self::FileInfo(query) => query.should_retry(response),
            Self::ContractBytecode(query) => query.should_retry(response),
            Self::ContractCall(query) => query.should_retry(response),
            Self::ContractInfo(query) => query.should_retry(response),
            Self::TokenNftInfo(query) => query.should_retry(response),
            Self::TokenInfo(query) => query.should_retry(response),
            Self::TopicInfo(query) => query.should_retry(response),
            Self::ScheduleInfo(query) => query.should_retry(response),
            Self::NetworkVersionInfo(query) => query.should_retry(response),
        }
    }

    fn transaction_id(&self) -> Option<crate::TransactionId> {
        match self {
            Self::AccountBalance(query) => query.transaction_id(),
            Self::AccountInfo(query) => query.transaction_id(),
            Self::AccountRecords(query) => query.transaction_id(),
            Self::TransactionReceipt(query) => query.transaction_id(),
            Self::TransactionRecord(query) => query.transaction_id(),
            Self::FileContents(query) => query.transaction_id(),
            Self::FileInfo(query) => query.transaction_id(),
            Self::ContractBytecode(query) => query.transaction_id(),
            Self::ContractCall(query) => query.transaction_id(),
            Self::TokenInfo(query) => query.transaction_id(),
            Self::ContractInfo(query) => query.transaction_id(),
            Self::TokenNftInfo(query) => query.transaction_id(),
            Self::TopicInfo(query) => query.transaction_id(),
            Self::ScheduleInfo(query) => query.transaction_id(),
            Self::NetworkVersionInfo(query) => query.transaction_id(),
        }
    }

    fn make_response(
        &self,
        response: services::response::Response,
    ) -> crate::Result<Self::Response> {
        match self {
            Self::AccountBalance(query) => {
                query.make_response(response).map(AnyQueryResponse::AccountBalance)
            }
            Self::AccountInfo(query) => {
                query.make_response(response).map(AnyQueryResponse::AccountInfo)
            }
            Self::AccountRecords(query) => {
                query.make_response(response).map(AnyQueryResponse::AccountRecords)
            }
            Self::TransactionReceipt(query) => {
                query.make_response(response).map(AnyQueryResponse::TransactionReceipt)
            }
            Self::TransactionRecord(query) => {
                query.make_response(response).map(Box::new).map(AnyQueryResponse::TransactionRecord)
            }
            Self::FileContents(query) => {
                query.make_response(response).map(AnyQueryResponse::FileContents)
            }
            Self::FileInfo(query) => query.make_response(response).map(AnyQueryResponse::FileInfo),
            Self::ContractBytecode(query) => {
                query.make_response(response).map(AnyQueryResponse::ContractBytecode)
            }
            Self::ContractCall(query) => {
                query.make_response(response).map(AnyQueryResponse::ContractCall)
            }
            Self::TokenInfo(query) => {
                query.make_response(response).map(Box::new).map(AnyQueryResponse::TokenInfo)
            }
            Self::ContractInfo(query) => {
                query.make_response(response).map(AnyQueryResponse::ContractInfo)
            }
            Self::TokenNftInfo(query) => {
                query.make_response(response).map(AnyQueryResponse::TokenNftInfo)
            }
            Self::TopicInfo(query) => {
                query.make_response(response).map(AnyQueryResponse::TopicInfo)
            }
            Self::ScheduleInfo(query) => {
                query.make_response(response).map(AnyQueryResponse::ScheduleInfo)
            }
            Self::NetworkVersionInfo(query) => {
                query.make_response(response).map(AnyQueryResponse::NetworkVersionInfo)
            }
        }
    }
}

impl ValidateChecksums for AnyQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        match self {
            Self::AccountBalance(query) => query.validate_checksums(ledger_id),
            Self::AccountInfo(query) => query.validate_checksums(ledger_id),
            Self::AccountRecords(query) => query.validate_checksums(ledger_id),
            Self::TransactionReceipt(query) => query.validate_checksums(ledger_id),
            Self::TransactionRecord(query) => query.validate_checksums(ledger_id),
            Self::FileContents(query) => query.validate_checksums(ledger_id),
            Self::FileInfo(query) => query.validate_checksums(ledger_id),
            Self::ContractBytecode(query) => query.validate_checksums(ledger_id),
            Self::ContractCall(query) => query.validate_checksums(ledger_id),
            Self::TokenInfo(query) => query.validate_checksums(ledger_id),
            Self::ContractInfo(query) => query.validate_checksums(ledger_id),
            Self::TokenNftInfo(query) => query.validate_checksums(ledger_id),
            Self::TopicInfo(query) => query.validate_checksums(ledger_id),
            Self::ScheduleInfo(query) => query.validate_checksums(ledger_id),
            Self::NetworkVersionInfo(query) => query.validate_checksums(ledger_id),
        }
    }
}

impl FromProtobuf<services::response::Response> for AnyQueryResponse {
    fn from_protobuf(response: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        use services::response::Response::*;

        Ok(match response {
            TransactionGetReceipt(_) => {
                Self::TransactionReceipt(TransactionReceipt::from_protobuf(response)?)
            }
            CryptoGetInfo(_) => Self::AccountInfo(AccountInfo::from_protobuf(response)?),
            CryptogetAccountBalance(_) => {
                Self::AccountBalance(AccountBalance::from_protobuf(response)?)
            }
            FileGetContents(_) => {
                Self::FileContents(FileContentsResponse::from_protobuf(response)?)
            }
            ContractGetBytecodeResponse(_) => {
                Self::ContractBytecode(Vec::<u8>::from_protobuf(response)?)
            }
            ContractCallLocal(_) => {
                Self::ContractCall(ContractFunctionResult::from_protobuf(response)?)
            }
            ContractGetInfo(_) => Self::ContractInfo(ContractInfo::from_protobuf(response)?),
            ConsensusGetTopicInfo(_) => Self::TopicInfo(TopicInfo::from_protobuf(response)?),
            ScheduleGetInfo(_) => Self::ScheduleInfo(ScheduleInfo::from_protobuf(response)?),
            CryptoGetProxyStakers(_) => {
                Self::AccountStakers(AllProxyStakers::from_protobuf(response)?)
            }
            CryptoGetAccountRecords(_) => {
                Self::AccountRecords(Vec::<TransactionRecord>::from_protobuf(response)?)
            }
            TransactionGetRecord(_) => {
                Self::TransactionRecord(Box::new(TransactionRecord::from_protobuf(response)?))
            }
            NetworkGetVersionInfo(_) => {
                Self::NetworkVersionInfo(NetworkVersionInfo::from_protobuf(response)?)
            }
            FileGetInfo(_) => Self::FileInfo(FileInfo::from_protobuf(response)?),
            TokenGetInfo(_) => Self::TokenInfo(Box::new(TokenInfo::from_protobuf(response)?)),
            TokenGetNftInfo(_) | TokenGetNftInfos(_) => {
                Self::TokenNftInfo(TokenNftInfo::from_protobuf(response)?)
            }
            // Unimplemented on hedera services
            TransactionGetFastRecord(_)
            | CryptoGetLiveHash(_)
            | GetBySolidityId(_)
            | TokenGetAccountNftInfos(_)
            | NetworkGetExecutionTime(_)
            | ContractGetRecordsResponse(_)
            | AccountDetails(_)
            | GetByKey(_) => unreachable!(),
        })
    }
}
// Filename: src/query/cost.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use tonic::transport::Channel;

use crate::entity_id::ValidateChecksums;
use crate::execute::{
    execute,
    Execute,
};
use crate::query::execute::response_header;
use crate::query::QueryExecute;
use crate::{
    AccountId,
    BoxGrpcFuture,
    Client,
    Hbar,
    Query,
    Tinybar,
    TransactionId,
};

pub(super) struct QueryCost<'a, D>(&'a Query<D>)
where
    D: QueryExecute;

impl<'a, D> QueryCost<'a, D>
where
    D: QueryExecute,
{
    #[must_use]
    pub(super) fn new(query: &'a Query<D>) -> Self {
        Self(query)
    }
}

impl<D> Execute for QueryCost<'_, D>
where
    Query<D>: Execute,
    D: QueryExecute,
{
    type GrpcRequest = services::Query;

    type GrpcResponse = services::Response;

    type Response = Hbar;

    type Context = ();

    fn node_account_ids(&self) -> Option<&[AccountId]> {
        Execute::node_account_ids(self.0)
    }

    fn transaction_id(&self) -> Option<TransactionId> {
        None
    }

    fn requires_transaction_id(&self) -> bool {
        false
    }

    fn operator_account_id(&self) -> Option<&AccountId> {
        None
    }

    fn make_request(
        &self,
        _transaction_id: Option<&TransactionId>,
        _node_account_id: AccountId,
    ) -> crate::Result<(Self::GrpcRequest, Self::Context)> {
        let header = services::QueryHeader {
            response_type: services::ResponseType::CostAnswer as i32,
            payment: None,
        };

        Ok((self.0.data.to_query_protobuf(header), ()))
    }

    fn execute(
        &self,
        channel: Channel,
        request: Self::GrpcRequest,
    ) -> BoxGrpcFuture<'_, Self::GrpcResponse> {
        <D as QueryExecute>::execute(&self.0.data, channel, request)
    }

    fn make_response(
        &self,
        response: Self::GrpcResponse,
        _context: Self::Context,
        _node_account_id: AccountId,
        _transaction_id: Option<&TransactionId>,
    ) -> crate::Result<Self::Response> {
        let cost = Hbar::from_tinybars(response_header(&response.response)?.cost as Tinybar);

        Ok(self.0.data.map_cost(cost))
    }

    fn make_error_pre_check(
        &self,
        status: crate::Status,
        transaction_id: Option<&TransactionId>,
        _response: Self::GrpcResponse,
    ) -> crate::Error {
        if let Some(transaction_id) = self.0.data.transaction_id() {
            crate::Error::QueryPreCheckStatus { status, transaction_id: Box::new(transaction_id) }
        } else if let Some(transaction_id) = transaction_id {
            crate::Error::QueryPaymentPreCheckStatus {
                status,
                transaction_id: Box::new(*transaction_id),
            }
        } else {
            crate::Error::QueryNoPaymentPreCheckStatus { status }
        }
    }

    fn response_pre_check_status(response: &Self::GrpcResponse) -> crate::Result<i32> {
        Ok(response_header(&response.response)?.node_transaction_precheck_code)
    }
}

impl<'a, D: QueryExecute> ValidateChecksums for QueryCost<'a, D> {
    fn validate_checksums(&self, _ledger_id: &crate::ledger_id::RefLedgerId) -> crate::Result<()> {
        Ok(())
    }
}

impl<D> QueryCost<'_, D>
where
    D: QueryExecute,
{
    /// Execute this query against the provided client of the Hiero network.
    pub(crate) async fn execute(
        &mut self,
        client: &Client,
        timeout: Option<std::time::Duration>,
    ) -> crate::Result<Hbar> {
        execute(client, self, timeout).await
    }
}
// Filename: src/query/execute.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::Debug;

use hedera_proto::services;
use tonic::transport::Channel;

use crate::entity_id::ValidateChecksums;
use crate::execute::Execute;
use crate::query::{
    AnyQueryData,
    ToQueryProtobuf,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    FromProtobuf,
    Hbar,
    Query,
    Status,
    TransactionId,
};

/// Describes a specific query that can be executed on the Hiero network.
pub trait QueryExecute:
    Sync + Send + Into<AnyQueryData> + Clone + Debug + ToQueryProtobuf + ValidateChecksums
{
    type Response: FromProtobuf<services::response::Response>;

    /// Returns `true` if this query requires a payment to be submitted.
    fn is_payment_required(&self) -> bool {
        true
    }

    /// Alter the required payment amount in arbitrary ways after `get_cost` has returned.
    fn map_cost(&self, cost: Hbar) -> Hbar {
        cost
    }

    /// Returns `true` if this query should be retried after a back-off from the result
    /// of a pre-check.
    fn should_retry_pre_check(&self, _status: Status) -> bool {
        false
    }

    /// Check whether we should retry an otherwise successful response.
    #[allow(unused_variables)]
    fn should_retry(&self, response: &services::Response) -> bool {
        false
    }

    /// Returns the transaction ID that this query is for, if this query is about a transaction.
    fn transaction_id(&self) -> Option<TransactionId> {
        None
    }

    fn make_response(
        &self,
        response: services::response::Response,
    ) -> crate::Result<Self::Response> {
        <Self::Response as FromProtobuf<services::response::Response>>::from_protobuf(response)
    }

    /// Execute the prepared query request against the provided GRPC channel.
    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response>;
}

impl<D> Execute for Query<D>
where
    D: QueryExecute,
{
    type GrpcRequest = services::Query;

    type GrpcResponse = services::Response;

    type Response = D::Response;

    type Context = ();

    fn node_account_ids(&self) -> Option<&[AccountId]> {
        self.payment.node_account_ids()
    }

    fn transaction_id(&self) -> Option<TransactionId> {
        self.payment.transaction_id()
    }

    fn requires_transaction_id(&self) -> bool {
        self.data.is_payment_required()
    }

    fn operator_account_id(&self) -> Option<&AccountId> {
        self.payment.operator_account_id()
    }

    fn should_retry_pre_check(&self, status: Status) -> bool {
        self.data.should_retry_pre_check(status)
    }

    fn should_retry(&self, response: &Self::GrpcResponse) -> bool {
        self.data.should_retry(response)
    }

    fn make_request(
        &self,
        transaction_id: Option<&TransactionId>,
        node_account_id: AccountId,
    ) -> crate::Result<(Self::GrpcRequest, Self::Context)> {
        let payment = if self.data.is_payment_required() {
            Some(self.payment.make_request(transaction_id, node_account_id)?.0)
        } else {
            None
        };

        let header = services::QueryHeader { response_type: 0, payment };

        Ok((self.data.to_query_protobuf(header), ()))
    }

    fn execute(
        &self,
        channel: Channel,
        request: Self::GrpcRequest,
    ) -> BoxGrpcFuture<'_, Self::GrpcResponse> {
        self.data.execute(channel, request)
    }

    fn make_response(
        &self,
        response: Self::GrpcResponse,
        _context: Self::Context,
        _node_account_id: AccountId,
        _transaction_id: Option<&TransactionId>,
    ) -> crate::Result<Self::Response> {
        pb_getf!(response, response).and_then(|response| self.data.make_response(response))
    }

    fn make_error_pre_check(
        &self,
        status: crate::Status,
        transaction_id: Option<&TransactionId>,
        _response: Self::GrpcResponse,
    ) -> crate::Error {
        if let Some(transaction_id) = self.data.transaction_id() {
            crate::Error::QueryPreCheckStatus { status, transaction_id: Box::new(transaction_id) }
        } else if let Some(transaction_id) = transaction_id {
            crate::Error::QueryPaymentPreCheckStatus {
                status,
                transaction_id: Box::new(*transaction_id),
            }
        } else {
            crate::Error::QueryNoPaymentPreCheckStatus { status }
        }
    }

    fn response_pre_check_status(response: &Self::GrpcResponse) -> crate::Result<i32> {
        Ok(response_header(&response.response)?.node_transaction_precheck_code)
    }
}

impl<D: QueryExecute + ValidateChecksums> ValidateChecksums for Query<D> {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        self.data.validate_checksums(ledger_id)?;
        self.payment.validate_checksums(ledger_id)
    }
}

pub(crate) fn response_header(
    response: &Option<services::response::Response>,
) -> crate::Result<&services::ResponseHeader> {
    use services::response::Response::*;

    let header = match response {
        Some(CryptogetAccountBalance(response)) => &response.header,
        Some(GetByKey(response)) => &response.header,
        Some(GetBySolidityId(response)) => &response.header,
        Some(ContractCallLocal(response)) => &response.header,
        Some(ContractGetBytecodeResponse(response)) => &response.header,
        Some(ContractGetInfo(response)) => &response.header,
        Some(ContractGetRecordsResponse(response)) => &response.header,
        Some(CryptoGetAccountRecords(response)) => &response.header,
        Some(CryptoGetInfo(response)) => &response.header,
        Some(CryptoGetLiveHash(response)) => &response.header,
        Some(CryptoGetProxyStakers(response)) => &response.header,
        Some(FileGetContents(response)) => &response.header,
        Some(FileGetInfo(response)) => &response.header,
        Some(TransactionGetReceipt(response)) => &response.header,
        Some(TransactionGetRecord(response)) => &response.header,
        Some(TransactionGetFastRecord(response)) => &response.header,
        Some(ConsensusGetTopicInfo(response)) => &response.header,
        Some(NetworkGetVersionInfo(response)) => &response.header,
        Some(TokenGetInfo(response)) => &response.header,
        Some(ScheduleGetInfo(response)) => &response.header,
        Some(TokenGetAccountNftInfos(response)) => &response.header,
        Some(TokenGetNftInfo(response)) => &response.header,
        Some(TokenGetNftInfos(response)) => &response.header,
        Some(NetworkGetExecutionTime(response)) => &response.header,
        Some(AccountDetails(response)) => &response.header,
        None => &None,
    };

    header.as_ref().ok_or_else(|| Error::from_protobuf("unexpected missing `header` in `Response`"))
}
// Filename: src/query/mod.rs
// SPDX-License-Identifier: Apache-2.0

use futures_core::future::BoxFuture;
use time::Duration;

use crate::execute::execute;
use crate::query::cost::QueryCost;
use crate::query::payment_transaction::PaymentTransaction;
use crate::{
    AccountId,
    Client,
    Error,
    Hbar,
    TransactionId,
    TransactionReceiptQuery,
};

mod any;
mod cost;
mod execute;
pub(super) mod payment_transaction;
mod protobuf;

pub(crate) use any::AnyQueryData;
pub use any::{
    AnyQuery,
    AnyQueryResponse,
};
pub(crate) use execute::{
    response_header,
    QueryExecute,
};
pub(crate) use protobuf::ToQueryProtobuf;

/// A query that can be executed on the Hiero network.
#[derive(Debug, Default)]
pub struct Query<D>
where
    D: QueryExecute,
{
    pub(crate) data: D,
    pub(crate) payment: PaymentTransaction,
}

impl<D> Query<D>
where
    D: QueryExecute + Default,
{
    /// Create a new query ready for configuration and execution.
    #[inline]
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }
}

impl<D> Query<D>
where
    D: QueryExecute,
{
    /// Returns the account IDs of the nodes that this query may be submitted to.
    ///
    /// Defaults to the full list of nodes configured on the client; or, the node account IDs
    /// configured on the query payment transaction (if explicitly provided).
    #[must_use]
    pub fn get_node_account_ids(&self) -> Option<&[AccountId]> {
        self.payment.get_node_account_ids()
    }

    /// Sets the account IDs of the nodes that this query may be submitted to.
    ///
    /// Defaults to the full list of nodes configured on the client; or, the node account IDs
    /// configured on the query payment transaction (if explicitly provided).
    pub fn node_account_ids(&mut self, ids: impl IntoIterator<Item = AccountId>) -> &mut Self {
        self.payment.node_account_ids(ids);
        self
    }

    /// Returns the explicit payment amount for this query.
    ///
    /// The client will submit exactly this amount for the payment of this query. Hiero
    /// will not return any remainder (over the actual cost for this query).
    #[must_use]
    pub fn get_payment_amount(&self) -> Option<Hbar> {
        self.payment.get_amount()
    }

    /// Sets the explicit payment amount for this query.
    ///
    /// The client will submit exactly this amount for the payment of this query. Hiero
    /// will not return any remainder (over the actual cost for this query).
    pub fn payment_amount(&mut self, amount: Hbar) -> &mut Self {
        self.payment.amount(amount);
        self
    }

    /// Returns the maximum payment allowable for this query.
    #[must_use]
    pub fn get_max_amount(&self) -> Option<Hbar> {
        self.payment.get_max_amount()
    }

    /// Sets the maximum payment allowable for this query.
    ///
    /// When a query is executed without an explicit payment amount set,
    /// the client will first request the cost of the given query from the node it will be
    /// submitted to and attach a payment for that amount from the operator account on the client.
    ///
    /// If the returned value is greater than this value, a [`MaxQueryPaymentExceeded`](crate::Error::MaxQueryPaymentExceeded) error
    /// will be returned.
    ///
    /// Defaults to the maximum payment amount configured on the client.
    ///
    /// Sets to `None` to allow unlimited payment amounts.
    pub fn max_payment_amount(&mut self, max: impl Into<Option<Hbar>>) -> &mut Self {
        self.payment.max_amount(max);
        self
    }

    /// Returns the duration that the payment transaction is valid for, once finalized and signed.
    #[must_use]
    pub fn get_payment_transaction_valid_duration(&self) -> Option<Duration> {
        self.payment.get_transaction_valid_duration()
    }

    /// Sets the duration that the payment transaction is valid for, once finalized and signed.
    ///
    /// Defaults to 120 seconds (or two minutes).
    pub fn payment_transaction_valid_duration(&mut self, duration: Duration) -> &mut Self {
        self.payment.transaction_valid_duration(duration);
        self
    }

    /// Returns the maximum transaction fee the payer account is willing to pay
    /// for the query payment transaction.
    #[must_use]
    pub fn get_max_payment_transaction_fee(&self) -> Option<Hbar> {
        self.payment.get_max_transaction_fee()
    }

    /// Sets the maximum transaction fee the payer account is willing to pay for the query
    /// payment transaction.
    ///
    /// Defaults to 1 hbar.
    pub fn max_payment_transaction_fee(&mut self, fee: Hbar) -> &mut Self {
        self.payment.max_transaction_fee(fee);
        self
    }

    /// Returns the note / description that should be recorded in the transaction record for the payment transaction.
    #[must_use]
    pub fn get_payment_transaction_memo(&self) -> &str {
        self.payment.get_transaction_memo()
    }

    /// Sets a note / description that should be recorded in the transaction record for the payment transaction.
    ///
    /// Maximum length of 100 characters.
    pub fn payment_transaction_memo(&mut self, memo: impl AsRef<str>) -> &mut Self {
        self.payment.transaction_memo(memo);
        self
    }

    /// Returns the explicit transaction ID used to identify this query's payment transaction, if set
    /// .
    #[must_use]
    pub fn get_payment_transaction_id(&self) -> Option<TransactionId> {
        self.payment.get_transaction_id()
    }

    /// Sets an explicit transaction ID to use to identify the payment transaction
    /// on this query.
    ///
    /// Overrides payer account defined on this query or on the client.
    pub fn payment_transaction_id(&mut self, id: TransactionId) -> &mut Self {
        self.payment.transaction_id(id);
        self
    }

    /// Fetch the cost of this query.
    pub async fn get_cost(&self, client: &Client) -> crate::Result<Hbar> {
        self.get_cost_with_optional_timeout(client, None).await
    }

    pub(crate) async fn get_cost_with_optional_timeout(
        &self,
        client: &Client,
        timeout: Option<std::time::Duration>,
    ) -> crate::Result<Hbar> {
        if !self.data.is_payment_required() {
            return Ok(Hbar::ZERO);
        }

        QueryCost::new(self).execute(client, timeout).await
    }

    /// Fetch the cost of this query.
    pub async fn get_cost_with_timeout(
        &self,
        client: &Client,
        timeout: std::time::Duration,
    ) -> crate::Result<Hbar> {
        self.get_cost_with_optional_timeout(client, Some(timeout)).await
    }
}

impl<D> Query<D>
where
    D: QueryExecute,
{
    /// Execute this query against the provided client of the Hiero network.
    // todo:
    #[allow(clippy::missing_errors_doc)]
    pub async fn execute(&mut self, client: &Client) -> crate::Result<D::Response> {
        self.execute_with_optional_timeout(client, None).await
    }

    // eww long name
    pub(crate) async fn execute_with_optional_timeout(
        &mut self,
        client: &Client,
        timeout: Option<std::time::Duration>,
    ) -> crate::Result<D::Response> {
        fn recurse_receipt(
            transaction_id: &TransactionId,
            client: Client,
            timeout: Option<std::time::Duration>,
        ) -> BoxFuture<'_, ()> {
            Box::pin(async move {
                let _ = TransactionReceiptQuery::new()
                    .transaction_id(*transaction_id)
                    .execute_with_optional_timeout(&client, timeout)
                    .await;
            })
        }

        // hack: this is a TransactionRecordQuery, which means we need to run the receipt first.
        if let Some(transaction_id) = self.data.transaction_id() {
            if self.data.is_payment_required() {
                let client = client.clone();
                recurse_receipt(&transaction_id, client, timeout).await;
            }
        }

        if self.payment.get_amount().is_none() && self.data.is_payment_required() {
            // should this inherit the timeout?
            // payment is required but none was specified, query the cost
            let cost = QueryCost::new(self).execute(client, None).await?;

            if self.payment.get_max_amount().is_none() {
                // N.B. This can still be `None`.
                self.payment.max_amount(client.default_max_query_payment());
            }

            if let Some(max_amount) = self.payment.get_max_amount() {
                if cost > max_amount {
                    return Err(Error::MaxQueryPaymentExceeded {
                        query_cost: cost,
                        max_query_payment: max_amount,
                    });
                }
            }

            self.payment.amount(cost);
        }

        if self.data.is_payment_required() {
            self.payment.freeze_with(client)?;
        }

        execute(client, self, timeout).await
    }

    /// Execute this query against the provided client of the Hiero network.
    // todo:
    #[allow(clippy::missing_errors_doc)]
    pub async fn execute_with_timeout(
        &mut self,
        client: &Client,
        timeout: std::time::Duration,
    ) -> crate::Result<D::Response> {
        self.execute_with_optional_timeout(client, Some(timeout)).await
    }
}
// Filename: src/query/payment_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use tonic::transport::Channel;

use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    Hbar,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

pub type PaymentTransaction = Transaction<PaymentTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct PaymentTransactionData {
    amount: Option<Hbar>,
    max_amount: Option<Hbar>,
}

impl PaymentTransaction {
    pub(super) fn get_amount(&self) -> Option<Hbar> {
        self.data().amount
    }

    pub(super) fn amount(&mut self, amount: Hbar) -> &mut Self {
        self.data_mut().amount = Some(amount);
        self
    }

    pub(super) fn get_max_amount(&self) -> Option<Hbar> {
        self.data().max_amount
    }

    pub(super) fn max_amount(&mut self, amount: impl Into<Option<Hbar>>) -> &mut Self {
        self.data_mut().max_amount = amount.into();
        self
    }
}

impl TransactionData for PaymentTransactionData {}

impl TransactionExecute for PaymentTransactionData {
    // noinspection DuplicatedCode
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { CryptoServiceClient::new(channel).crypto_transfer(request).await })
    }
}

impl ValidateChecksums for PaymentTransactionData {
    fn validate_checksums(&self, _ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        Ok(())
    }
}

impl ToTransactionDataProtobuf for PaymentTransactionData {
    #[allow(clippy::cast_possible_wrap)]
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let (transaction_id, node_account_id) = chunk_info.assert_single_transaction();

        let amount = self.amount.unwrap_or_default();

        services::transaction_body::Data::CryptoTransfer(services::CryptoTransferTransactionBody {
            token_transfers: Vec::new(),
            transfers: Some(services::TransferList {
                account_amounts: vec![
                    services::AccountAmount {
                        account_id: Some(node_account_id.to_protobuf()),
                        amount: amount.to_tinybars(),
                        is_approval: false,
                    },
                    services::AccountAmount {
                        account_id: Some(transaction_id.account_id.to_protobuf()),
                        amount: -(amount.to_tinybars()),
                        is_approval: false,
                    },
                ],
            }),
        })
    }
}

impl From<PaymentTransactionData> for AnyTransactionData {
    fn from(_transaction: PaymentTransactionData) -> Self {
        // NOTE: this should only be reached if we try to serialize a PaymentTransaction
        //  as this is a private type that we have no intention of serializing, we should be good
        unreachable!()
    }
}
// Filename: src/query/protobuf.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

pub trait ToQueryProtobuf: Send + Sync {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query;
}
// Filename: src/retry.rs
use futures_core::Future;
use tokio::time::sleep;

#[derive(Debug)]
pub(crate) enum Error {
    /// An error that may be resolved after backoff is applied (connection issues for example)
    Transient(crate::Error),

    /// An error that *cannot* be resolved.
    Permanent(crate::Error),

    /// A transient error with no associated error (happens when there are no healthy nodes)
    EmptyTransient,
}

impl Error {
    pub(crate) fn is_transient(&self) -> bool {
        match self {
            Error::Transient(_) => true,
            Error::Permanent(_) => false,
            Error::EmptyTransient => true,
        }
    }
}

pub(crate) type Result<T> = std::result::Result<T, Error>;

/// Durably retry some function according to the `backoff` until the backoff expires.
pub(crate) async fn retry<B, Fn, O, Fut>(
    mut backoff: B,
    max_attempts: Option<usize>,
    mut f: Fn,
) -> crate::Result<O>
where
    B: backoff::backoff::Backoff + Send,
    Fn: FnMut() -> Fut + Send,
    Fut: Future<Output = Result<O>> + Send,
{
    let mut last_error: Option<crate::Error> = None;
    let mut attempt_number = 0;

    while max_attempts.map_or(true, |it| attempt_number < it) {
        attempt_number += 1;

        match f().await {
            Ok(it) => return Ok(it),
            Err(Error::Transient(e)) => last_error = Some(e),
            Err(Error::EmptyTransient) => {}
            Err(Error::Permanent(e)) => return Err(e),
        }

        if let Some(duration) = backoff.next_backoff() {
            let duration_ms = duration.as_millis();
            let err_suffix =
                last_error.as_ref().map(|l| format!(" due to {l:?}")).unwrap_or_default();

            log::warn!("Backing off for {duration_ms}ms after failure of attempt {attempt_number}{err_suffix}");
            sleep(duration).await;
            log::warn!("Backed off for {duration_ms}ms after failure of attempt {attempt_number}{err_suffix}");
        } else {
            let last_error = last_error.expect("timeout while network had no healthy nodes");
            return Err(crate::Error::TimedOut(last_error.into()));
        }
    }

    let last_error = last_error.expect("timeout while network had no healthy nodes");
    Err(crate::Error::TimedOut(last_error.into()))
}
// Filename: src/schedule/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod schedulable_transaction_body;
mod schedule_create_transaction;
mod schedule_delete_transaction;
mod schedule_id;
mod schedule_info;
mod schedule_info_query;
mod schedule_sign_transaction;

pub use schedule_create_transaction::ScheduleCreateTransaction;
pub(crate) use schedule_create_transaction::ScheduleCreateTransactionData;
pub use schedule_delete_transaction::ScheduleDeleteTransaction;
pub(crate) use schedule_delete_transaction::ScheduleDeleteTransactionData;
pub use schedule_id::ScheduleId;
pub use schedule_info::ScheduleInfo;
pub use schedule_info_query::ScheduleInfoQuery;
pub(crate) use schedule_info_query::ScheduleInfoQueryData;
pub use schedule_sign_transaction::ScheduleSignTransaction;
pub(crate) use schedule_sign_transaction::ScheduleSignTransactionData;
// Filename: src/schedule/schedulable_transaction_body.rs
use hedera_proto::services;

use crate::protobuf::FromProtobuf;
use crate::transaction::{
    AnyTransactionData,
    ToSchedulableTransactionDataProtobuf,
    TransactionData,
};
use crate::Hbar;

mod data {
    pub(super) use crate::account::{
        AccountAllowanceApproveTransactionData as AccountAllowanceApprove,
        AccountAllowanceDeleteTransactionData as AccountAllowanceDelete,
        AccountCreateTransactionData as AccountCreate,
        AccountDeleteTransactionData as AccountDelete,
        AccountUpdateTransactionData as AccountUpdate,
    };
    pub(super) use crate::address_book::{
        NodeCreateTransactionData as NodeCreate,
        NodeDeleteTransactionData as NodeDelete,
        NodeUpdateTransactionData as NodeUpdate,
    };
    pub(super) use crate::contract::{
        ContractCreateTransactionData as ContractCreate,
        ContractDeleteTransactionData as ContractDelete,
        ContractExecuteTransactionData as ContractExecute,
        ContractUpdateTransactionData as ContractUpdate,
    };
    pub(super) use crate::file::{
        FileAppendTransactionData as FileAppend,
        FileCreateTransactionData as FileCreate,
        FileDeleteTransactionData as FileDelete,
        FileUpdateTransactionData as FileUpdate,
    };
    pub(super) use crate::prng_transaction::PrngTransactionData as Prng;
    pub(super) use crate::schedule::ScheduleDeleteTransactionData as ScheduleDelete;
    pub(super) use crate::system::{
        FreezeTransactionData as Freeze,
        SystemDeleteTransactionData as SystemDelete,
        SystemUndeleteTransactionData as SystemUndelete,
    };
    pub(super) use crate::token::{
        TokenAirdropTransactionData as TokenAirdrop,
        TokenAssociateTransactionData as TokenAssociate,
        TokenBurnTransactionData as TokenBurn,
        TokenCancelAirdropTransactionData as TokenCancelAirdrop,
        TokenClaimAirdropTransactionData as TokenClaimAirdrop,
        TokenCreateTransactionData as TokenCreate,
        TokenDeleteTransactionData as TokenDelete,
        TokenDissociateTransactionData as TokenDissociate,
        TokenFeeScheduleUpdateTransactionData as TokenFeeScheduleUpdate,
        TokenFreezeTransactionData as TokenFreeze,
        TokenGrantKycTransactionData as TokenGrantKyc,
        TokenMintTransactionData as TokenMint,
        TokenPauseTransactionData as TokenPause,
        TokenRejectTransactionData as TokenReject,
        TokenRevokeKycTransactionData as TokenRevokeKyc,
        TokenUnfreezeTransactionData as TokenUnfreeze,
        TokenUnpauseTransactionData as TokenUnpause,
        TokenUpdateNftsTransactionData as TokenUpdateNfts,
        TokenUpdateTransactionData as TokenUpdate,
        TokenWipeTransactionData as TokenWipe,
    };
    pub(super) use crate::topic::{
        TopicCreateTransactionData as TopicCreate,
        TopicDeleteTransactionData as TopicDelete,
        TopicMessageSubmitTransactionData as TopicMessageSubmit,
        TopicUpdateTransactionData as TopicUpdate,
    };
    pub(super) use crate::transfer_transaction::TransferTransactionData as Transfer;
}

// Hack: In rust this is this, but in swift this is just a less densely populatable `AnyTransaction`.
// As a result, the sources stuff doesn't carry over... That can be fixed after SDK level FFI is removed.
#[derive(Debug, Clone)]
pub(super) struct SchedulableTransactionBody {
    pub(super) data: Box<AnySchedulableTransactionData>,

    pub(super) max_transaction_fee: Option<Hbar>,

    pub(super) transaction_memo: String,
}

impl FromProtobuf<services::SchedulableTransactionBody> for SchedulableTransactionBody {
    fn from_protobuf(pb: services::SchedulableTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            data: Box::new(AnySchedulableTransactionData::from_protobuf(pb_getf!(pb, data)?)?),
            max_transaction_fee: Some(Hbar::from_tinybars(pb.transaction_fee as i64)),
            transaction_memo: pb.memo,
        })
    }
}

impl SchedulableTransactionBody {
    pub(super) fn to_scheduled_body_protobuf(&self) -> services::SchedulableTransactionBody {
        services::SchedulableTransactionBody {
            data: Some(self.data.to_schedulable_transaction_data_protobuf()),
            memo: self.transaction_memo.clone(),
            // FIXME: does not use the client to default the max transaction fee
            transaction_fee: self
                .max_transaction_fee
                .unwrap_or_else(|| self.data.default_max_transaction_fee())
                .to_tinybars() as u64,
        }
    }
}

#[derive(Debug, Clone)]
pub(super) enum AnySchedulableTransactionData {
    AccountCreate(data::AccountCreate),
    AccountUpdate(data::AccountUpdate),
    AccountDelete(data::AccountDelete),
    AccountAllowanceApprove(data::AccountAllowanceApprove),
    AccountAllowanceDelete(data::AccountAllowanceDelete),
    ContractCreate(data::ContractCreate),
    ContractUpdate(data::ContractUpdate),
    ContractDelete(data::ContractDelete),
    ContractExecute(data::ContractExecute),
    Transfer(data::Transfer),
    TopicCreate(data::TopicCreate),
    TopicUpdate(data::TopicUpdate),
    TopicDelete(data::TopicDelete),
    TopicMessageSubmit(data::TopicMessageSubmit),
    FileAppend(data::FileAppend),
    FileCreate(data::FileCreate),
    FileUpdate(data::FileUpdate),
    FileDelete(data::FileDelete),
    Prng(data::Prng),
    TokenAssociate(data::TokenAssociate),
    TokenBurn(data::TokenBurn),
    TokenCreate(data::TokenCreate),
    TokenDelete(data::TokenDelete),
    TokenDissociate(data::TokenDissociate),
    TokenFeeScheduleUpdate(data::TokenFeeScheduleUpdate),
    TokenFreeze(data::TokenFreeze),
    TokenGrantKyc(data::TokenGrantKyc),
    TokenMint(data::TokenMint),
    TokenPause(data::TokenPause),
    TokenRevokeKyc(data::TokenRevokeKyc),
    TokenUnfreeze(data::TokenUnfreeze),
    TokenUnpause(data::TokenUnpause),
    TokenUpdate(data::TokenUpdate),
    TokenWipe(data::TokenWipe),
    TokenUpdateNfts(data::TokenUpdateNfts),
    TokenReject(data::TokenReject),
    SystemDelete(data::SystemDelete),
    SystemUndelete(data::SystemUndelete),
    Freeze(data::Freeze),
    ScheduleDelete(data::ScheduleDelete),
    NodeCreate(data::NodeCreate),
    NodeUpdate(data::NodeUpdate),
    NodeDelete(data::NodeDelete),
    TokenAirdrop(data::TokenAirdrop),
    TokenClaimAirdrop(data::TokenClaimAirdrop),
    TokenCancelAirdrop(data::TokenCancelAirdrop),
}

impl AnySchedulableTransactionData {
    pub(super) fn default_max_transaction_fee(&self) -> Hbar {
        match self {
            AnySchedulableTransactionData::AccountCreate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::AccountUpdate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::AccountDelete(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::AccountAllowanceApprove(it) => {
                it.default_max_transaction_fee()
            }
            AnySchedulableTransactionData::AccountAllowanceDelete(it) => {
                it.default_max_transaction_fee()
            }
            AnySchedulableTransactionData::ContractCreate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::ContractUpdate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::ContractDelete(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::ContractExecute(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::Transfer(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TopicCreate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TopicUpdate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TopicDelete(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TopicMessageSubmit(it) => {
                it.default_max_transaction_fee()
            }
            AnySchedulableTransactionData::FileAppend(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::FileCreate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::FileUpdate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::FileDelete(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenAssociate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenBurn(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenCreate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenDelete(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenDissociate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenFeeScheduleUpdate(it) => {
                it.default_max_transaction_fee()
            }
            AnySchedulableTransactionData::TokenFreeze(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenGrantKyc(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenMint(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenUpdateNfts(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenPause(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenRevokeKyc(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenUnfreeze(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenUnpause(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenUpdate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenWipe(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenReject(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::SystemDelete(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::SystemUndelete(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::Freeze(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::ScheduleDelete(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::Prng(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::NodeCreate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::NodeUpdate(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::NodeDelete(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenAirdrop(it) => it.default_max_transaction_fee(),
            AnySchedulableTransactionData::TokenClaimAirdrop(it) => {
                it.default_max_transaction_fee()
            }
            AnySchedulableTransactionData::TokenCancelAirdrop(it) => {
                it.default_max_transaction_fee()
            }
        }
    }
}

impl FromProtobuf<services::schedulable_transaction_body::Data> for AnySchedulableTransactionData {
    // large function that just delegates...
    #[allow(clippy::too_many_lines)]
    fn from_protobuf(pb: services::schedulable_transaction_body::Data) -> crate::Result<Self> {
        use services::schedulable_transaction_body::Data;
        match pb {
            Data::ContractCall(it) => {
                Ok(Self::ContractExecute(data::ContractExecute::from_protobuf(it)?))
            }
            Data::ContractCreateInstance(it) => {
                Ok(Self::ContractCreate(data::ContractCreate::from_protobuf(it)?))
            }
            Data::ContractUpdateInstance(it) => {
                Ok(Self::ContractUpdate(data::ContractUpdate::from_protobuf(it)?))
            }
            Data::ContractDeleteInstance(it) => {
                Ok(Self::ContractDelete(data::ContractDelete::from_protobuf(it)?))
            }
            Data::CryptoApproveAllowance(it) => {
                Ok(Self::AccountAllowanceApprove(data::AccountAllowanceApprove::from_protobuf(it)?))
            }
            Data::CryptoDeleteAllowance(it) => {
                Ok(Self::AccountAllowanceDelete(data::AccountAllowanceDelete::from_protobuf(it)?))
            }
            Data::CryptoCreateAccount(it) => {
                Ok(Self::AccountCreate(data::AccountCreate::from_protobuf(it)?))
            }
            Data::CryptoDelete(it) => {
                Ok(Self::AccountDelete(data::AccountDelete::from_protobuf(it)?))
            }
            Data::CryptoTransfer(it) => Ok(Self::Transfer(data::Transfer::from_protobuf(it)?)),
            Data::CryptoUpdateAccount(it) => {
                Ok(Self::AccountUpdate(data::AccountUpdate::from_protobuf(it)?))
            }
            Data::FileAppend(it) => Ok(Self::FileAppend(data::FileAppend::from_protobuf(it)?)),
            Data::FileCreate(it) => Ok(Self::FileCreate(data::FileCreate::from_protobuf(it)?)),
            Data::FileDelete(it) => Ok(Self::FileDelete(data::FileDelete::from_protobuf(it)?)),
            Data::FileUpdate(it) => Ok(Self::FileUpdate(data::FileUpdate::from_protobuf(it)?)),
            Data::SystemDelete(it) => {
                Ok(Self::SystemDelete(data::SystemDelete::from_protobuf(it)?))
            }
            Data::SystemUndelete(it) => {
                Ok(Self::SystemUndelete(data::SystemUndelete::from_protobuf(it)?))
            }
            Data::Freeze(it) => Ok(Self::Freeze(data::Freeze::from_protobuf(it)?)),
            Data::ConsensusCreateTopic(it) => {
                Ok(Self::TopicCreate(data::TopicCreate::from_protobuf(it)?))
            }
            Data::ConsensusUpdateTopic(it) => {
                Ok(Self::TopicUpdate(data::TopicUpdate::from_protobuf(it)?))
            }
            Data::ConsensusDeleteTopic(it) => {
                Ok(Self::TopicDelete(data::TopicDelete::from_protobuf(it)?))
            }
            Data::ConsensusSubmitMessage(it) => {
                Ok(Self::TopicMessageSubmit(data::TopicMessageSubmit::from_protobuf(it)?))
            }
            Data::TokenCreation(it) => Ok(Self::TokenCreate(data::TokenCreate::from_protobuf(it)?)),
            Data::TokenFreeze(it) => Ok(Self::TokenFreeze(data::TokenFreeze::from_protobuf(it)?)),
            Data::TokenUnfreeze(it) => {
                Ok(Self::TokenUnfreeze(data::TokenUnfreeze::from_protobuf(it)?))
            }
            Data::TokenGrantKyc(it) => {
                Ok(Self::TokenGrantKyc(data::TokenGrantKyc::from_protobuf(it)?))
            }
            Data::TokenRevokeKyc(it) => {
                Ok(Self::TokenRevokeKyc(data::TokenRevokeKyc::from_protobuf(it)?))
            }
            Data::TokenDeletion(it) => Ok(Self::TokenDelete(data::TokenDelete::from_protobuf(it)?)),
            Data::TokenUpdate(it) => Ok(Self::TokenUpdate(data::TokenUpdate::from_protobuf(it)?)),
            Data::TokenMint(it) => Ok(Self::TokenMint(data::TokenMint::from_protobuf(it)?)),
            Data::TokenBurn(it) => Ok(Self::TokenBurn(data::TokenBurn::from_protobuf(it)?)),
            Data::TokenWipe(it) => Ok(Self::TokenWipe(data::TokenWipe::from_protobuf(it)?)),
            Data::TokenAssociate(it) => {
                Ok(Self::TokenAssociate(data::TokenAssociate::from_protobuf(it)?))
            }
            Data::TokenDissociate(it) => {
                Ok(Self::TokenDissociate(data::TokenDissociate::from_protobuf(it)?))
            }
            Data::TokenFeeScheduleUpdate(it) => {
                Ok(Self::TokenFeeScheduleUpdate(data::TokenFeeScheduleUpdate::from_protobuf(it)?))
            }
            Data::TokenPause(it) => Ok(Self::TokenPause(data::TokenPause::from_protobuf(it)?)),
            Data::TokenUnpause(it) => {
                Ok(Self::TokenUnpause(data::TokenUnpause::from_protobuf(it)?))
            }
            Data::TokenReject(it) => Ok(Self::TokenReject(data::TokenReject::from_protobuf(it)?)),
            Data::ScheduleDelete(it) => {
                Ok(Self::ScheduleDelete(data::ScheduleDelete::from_protobuf(it)?))
            }
            Data::UtilPrng(it) => Ok(Self::Prng(data::Prng::from_protobuf(it)?)),
            Data::TokenUpdateNfts(it) => {
                Ok(Self::TokenUpdateNfts(data::TokenUpdateNfts::from_protobuf(it)?))
            }
            Data::NodeCreate(it) => Ok(Self::NodeCreate(data::NodeCreate::from_protobuf(it)?)),
            Data::NodeUpdate(it) => Ok(Self::NodeUpdate(data::NodeUpdate::from_protobuf(it)?)),
            Data::NodeDelete(it) => Ok(Self::NodeDelete(data::NodeDelete::from_protobuf(it)?)),
            Data::TokenAirdrop(it) => {
                Ok(Self::TokenAirdrop(data::TokenAirdrop::from_protobuf(it)?))
            }
            Data::TokenClaimAirdrop(it) => {
                Ok(Self::TokenClaimAirdrop(data::TokenClaimAirdrop::from_protobuf(it)?))
            }
            Data::TokenCancelAirdrop(it) => {
                Ok(Self::TokenCancelAirdrop(data::TokenCancelAirdrop::from_protobuf(it)?))
            }
        }
    }
}

impl ToSchedulableTransactionDataProtobuf for AnySchedulableTransactionData {
    // large function that just delegates...
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        match self {
            AnySchedulableTransactionData::AccountCreate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::AccountUpdate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::AccountDelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::AccountAllowanceApprove(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::AccountAllowanceDelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::ContractCreate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::ContractUpdate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::ContractDelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::ContractExecute(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::Transfer(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TopicCreate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TopicUpdate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TopicDelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TopicMessageSubmit(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::FileAppend(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::FileCreate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::FileUpdate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::FileDelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenAssociate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenBurn(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenCreate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenDelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenDissociate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenFeeScheduleUpdate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenFreeze(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenGrantKyc(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenMint(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenPause(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenRevokeKyc(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenUnfreeze(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenUnpause(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenUpdate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenWipe(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::SystemDelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::SystemUndelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::Freeze(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::ScheduleDelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::Prng(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenUpdateNfts(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenReject(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::NodeCreate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::NodeUpdate(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::NodeDelete(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenAirdrop(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenClaimAirdrop(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
            AnySchedulableTransactionData::TokenCancelAirdrop(it) => {
                it.to_schedulable_transaction_data_protobuf()
            }
        }
    }
}

impl TryFrom<AnyTransactionData> for AnySchedulableTransactionData {
    type Error = crate::Error;

    fn try_from(value: AnyTransactionData) -> Result<Self, Self::Error> {
        match value {
            AnyTransactionData::AccountCreate(it) => Ok(Self::AccountCreate(it)),
            AnyTransactionData::AccountUpdate(it) => Ok(Self::AccountUpdate(it)),
            AnyTransactionData::AccountDelete(it) => Ok(Self::AccountDelete(it)),
            AnyTransactionData::AccountAllowanceApprove(it) => {
                Ok(Self::AccountAllowanceApprove(it))
            }
            AnyTransactionData::AccountAllowanceDelete(it) => Ok(Self::AccountAllowanceDelete(it)),
            AnyTransactionData::ContractCreate(it) => Ok(Self::ContractCreate(it)),
            AnyTransactionData::ContractUpdate(it) => Ok(Self::ContractUpdate(it)),
            AnyTransactionData::ContractDelete(it) => Ok(Self::ContractDelete(it)),
            AnyTransactionData::ContractExecute(it) => Ok(Self::ContractExecute(it)),
            AnyTransactionData::Transfer(it) => Ok(Self::Transfer(it)),
            AnyTransactionData::TopicCreate(it) => Ok(Self::TopicCreate(it)),
            AnyTransactionData::TopicUpdate(it) => Ok(Self::TopicUpdate(it)),
            AnyTransactionData::TopicDelete(it) => Ok(Self::TopicDelete(it)),
            AnyTransactionData::TopicMessageSubmit(it) => Ok(Self::TopicMessageSubmit(it)),
            AnyTransactionData::FileAppend(it) => Ok(Self::FileAppend(it)),
            AnyTransactionData::FileCreate(it) => Ok(Self::FileCreate(it)),
            AnyTransactionData::FileUpdate(it) => Ok(Self::FileUpdate(it)),
            AnyTransactionData::FileDelete(it) => Ok(Self::FileDelete(it)),
            AnyTransactionData::TokenAssociate(it) => Ok(Self::TokenAssociate(it)),
            AnyTransactionData::TokenBurn(it) => Ok(Self::TokenBurn(it)),
            AnyTransactionData::TokenCreate(it) => Ok(Self::TokenCreate(it)),
            AnyTransactionData::TokenDelete(it) => Ok(Self::TokenDelete(it)),
            AnyTransactionData::TokenDissociate(it) => Ok(Self::TokenDissociate(it)),
            AnyTransactionData::TokenFeeScheduleUpdate(it) => Ok(Self::TokenFeeScheduleUpdate(it)),
            AnyTransactionData::TokenFreeze(it) => Ok(Self::TokenFreeze(it)),
            AnyTransactionData::TokenGrantKyc(it) => Ok(Self::TokenGrantKyc(it)),
            AnyTransactionData::TokenMint(it) => Ok(Self::TokenMint(it)),
            AnyTransactionData::TokenPause(it) => Ok(Self::TokenPause(it)),
            AnyTransactionData::TokenRevokeKyc(it) => Ok(Self::TokenRevokeKyc(it)),
            AnyTransactionData::TokenUnfreeze(it) => Ok(Self::TokenUnfreeze(it)),
            AnyTransactionData::TokenUnpause(it) => Ok(Self::TokenUnpause(it)),
            AnyTransactionData::TokenUpdate(it) => Ok(Self::TokenUpdate(it)),
            AnyTransactionData::TokenWipe(it) => Ok(Self::TokenWipe(it)),
            AnyTransactionData::TokenReject(it) => Ok(Self::TokenReject(it)),
            AnyTransactionData::SystemDelete(it) => Ok(Self::SystemDelete(it)),
            AnyTransactionData::SystemUndelete(it) => Ok(Self::SystemUndelete(it)),
            AnyTransactionData::Freeze(it) => Ok(Self::Freeze(it)),
            AnyTransactionData::ScheduleDelete(it) => Ok(Self::ScheduleDelete(it)),
            AnyTransactionData::Prng(it) => Ok(Self::Prng(it)),
            AnyTransactionData::TokenUpdateNfts(it) => Ok(Self::TokenUpdateNfts(it)),
            AnyTransactionData::NodeCreate(it) => Ok(Self::NodeCreate(it)),
            AnyTransactionData::NodeUpdate(it) => Ok(Self::NodeUpdate(it)),
            AnyTransactionData::NodeDelete(it) => Ok(Self::NodeDelete(it)),
            AnyTransactionData::TokenAirdrop(it) => Ok(Self::TokenAirdrop(it)),
            AnyTransactionData::TokenClaimAirdrop(it) => Ok(Self::TokenClaimAirdrop(it)),
            AnyTransactionData::TokenCancelAirdrop(it) => Ok(Self::TokenCancelAirdrop(it)),

            // fixme: basic-parse isn't suitable for this.
            AnyTransactionData::ScheduleCreate(_) => {
                Err(crate::Error::basic_parse("Cannot schedule `ScheduleCreateTransaction`"))
            }
            AnyTransactionData::ScheduleSign(_) => {
                Err(crate::Error::basic_parse("Cannot schedule `ScheduleSignTransaction`"))
            }
            AnyTransactionData::Ethereum(_) => {
                Err(crate::Error::basic_parse("Cannot schedule `EthereumTransaction`"))
            }
        }
    }
}

impl From<AnySchedulableTransactionData> for AnyTransactionData {
    fn from(value: AnySchedulableTransactionData) -> Self {
        match value {
            AnySchedulableTransactionData::AccountCreate(it) => Self::AccountCreate(it),
            AnySchedulableTransactionData::AccountUpdate(it) => Self::AccountUpdate(it),
            AnySchedulableTransactionData::AccountDelete(it) => Self::AccountDelete(it),
            AnySchedulableTransactionData::AccountAllowanceApprove(it) => {
                Self::AccountAllowanceApprove(it)
            }
            AnySchedulableTransactionData::AccountAllowanceDelete(it) => {
                Self::AccountAllowanceDelete(it)
            }
            AnySchedulableTransactionData::ContractCreate(it) => Self::ContractCreate(it),
            AnySchedulableTransactionData::ContractUpdate(it) => Self::ContractUpdate(it),
            AnySchedulableTransactionData::ContractDelete(it) => Self::ContractDelete(it),
            AnySchedulableTransactionData::ContractExecute(it) => Self::ContractExecute(it),
            AnySchedulableTransactionData::Transfer(it) => Self::Transfer(it),
            AnySchedulableTransactionData::TopicCreate(it) => Self::TopicCreate(it),
            AnySchedulableTransactionData::TopicUpdate(it) => Self::TopicUpdate(it),
            AnySchedulableTransactionData::TopicDelete(it) => Self::TopicDelete(it),
            AnySchedulableTransactionData::TopicMessageSubmit(it) => Self::TopicMessageSubmit(it),
            AnySchedulableTransactionData::FileAppend(it) => Self::FileAppend(it),
            AnySchedulableTransactionData::FileCreate(it) => Self::FileCreate(it),
            AnySchedulableTransactionData::FileUpdate(it) => Self::FileUpdate(it),
            AnySchedulableTransactionData::FileDelete(it) => Self::FileDelete(it),
            AnySchedulableTransactionData::TokenAssociate(it) => Self::TokenAssociate(it),
            AnySchedulableTransactionData::TokenBurn(it) => Self::TokenBurn(it),
            AnySchedulableTransactionData::TokenCreate(it) => Self::TokenCreate(it),
            AnySchedulableTransactionData::TokenDelete(it) => Self::TokenDelete(it),
            AnySchedulableTransactionData::TokenDissociate(it) => Self::TokenDissociate(it),
            AnySchedulableTransactionData::TokenFeeScheduleUpdate(it) => {
                Self::TokenFeeScheduleUpdate(it)
            }
            AnySchedulableTransactionData::TokenFreeze(it) => Self::TokenFreeze(it),
            AnySchedulableTransactionData::TokenGrantKyc(it) => Self::TokenGrantKyc(it),
            AnySchedulableTransactionData::TokenMint(it) => Self::TokenMint(it),
            AnySchedulableTransactionData::TokenPause(it) => Self::TokenPause(it),
            AnySchedulableTransactionData::TokenRevokeKyc(it) => Self::TokenRevokeKyc(it),
            AnySchedulableTransactionData::TokenUnfreeze(it) => Self::TokenUnfreeze(it),
            AnySchedulableTransactionData::TokenUnpause(it) => Self::TokenUnpause(it),
            AnySchedulableTransactionData::TokenUpdate(it) => Self::TokenUpdate(it),
            AnySchedulableTransactionData::TokenWipe(it) => Self::TokenWipe(it),
            AnySchedulableTransactionData::SystemDelete(it) => Self::SystemDelete(it),
            AnySchedulableTransactionData::SystemUndelete(it) => Self::SystemUndelete(it),
            AnySchedulableTransactionData::Freeze(it) => Self::Freeze(it),
            AnySchedulableTransactionData::ScheduleDelete(it) => Self::ScheduleDelete(it),
            AnySchedulableTransactionData::Prng(it) => Self::Prng(it),
            AnySchedulableTransactionData::TokenUpdateNfts(it) => Self::TokenUpdateNfts(it),
            AnySchedulableTransactionData::NodeCreate(it) => Self::NodeCreate(it),
            AnySchedulableTransactionData::NodeUpdate(it) => Self::NodeUpdate(it),
            AnySchedulableTransactionData::NodeDelete(it) => Self::NodeDelete(it),
            AnySchedulableTransactionData::TokenReject(it) => Self::TokenReject(it),
            AnySchedulableTransactionData::TokenAirdrop(it) => Self::TokenAirdrop(it),
            AnySchedulableTransactionData::TokenClaimAirdrop(it) => Self::TokenClaimAirdrop(it),
            AnySchedulableTransactionData::TokenCancelAirdrop(it) => Self::TokenCancelAirdrop(it),
        }
    }
}
// Filename: src/schedule/schedule_create_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::schedule_service_client::ScheduleServiceClient;
use time::OffsetDateTime;
use tonic::transport::Channel;

use super::schedulable_transaction_body::SchedulableTransactionBody;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Key,
    Transaction,
    ValidateChecksums,
};

/// Create a new schedule entity (or simply, schedule) in the network's action queue.
///
/// Upon `SUCCESS`, the receipt contains the `ScheduleId` of the created schedule. A schedule
/// entity includes a `scheduled_transaction_body` to be executed.
///
/// When the schedule has collected enough signing keys to satisfy the schedule's signing
/// requirements, the schedule can be executed.
///
pub type ScheduleCreateTransaction = Transaction<ScheduleCreateTransactionData>;

#[derive(Default, Debug, Clone)]
pub struct ScheduleCreateTransactionData {
    scheduled_transaction: Option<SchedulableTransactionBody>,

    schedule_memo: Option<String>,

    admin_key: Option<Key>,

    payer_account_id: Option<AccountId>,

    expiration_time: Option<OffsetDateTime>,

    wait_for_expiry: bool,
}

impl ScheduleCreateTransaction {
    // note(sr): not sure what the right way to go about this is?
    // pub fn get_scheduled_transaction(&self) -> Option<&SchedulableTransactionBody> {
    //     self.data().scheduled_transaction.as_ref()
    // }

    /// Sets the scheduled transaction.
    ///
    /// # Panics
    /// panics if the transaction is not schedulable, a transaction can be non-schedulable due to:
    /// - being a transaction kind that's non-schedulable, IE, `EthereumTransaction`, or
    /// - being a chunked transaction with multiple chunks.
    pub fn scheduled_transaction<D>(&mut self, transaction: Transaction<D>) -> &mut Self
    where
        D: TransactionExecute,
    {
        let body = transaction.into_body();

        // this gets infered right but `foo.into().try_into()` looks really really weird.
        let data: AnyTransactionData = body.data.into();

        self.data_mut().scheduled_transaction = Some(SchedulableTransactionBody {
            max_transaction_fee: body.max_transaction_fee,
            transaction_memo: body.transaction_memo,
            data: Box::new(data.try_into().unwrap()),
        });

        self
    }

    /// Returns the timestamp for when the transaction should be evaluated for execution and then expire.
    #[must_use]
    pub fn get_expiration_time(&self) -> Option<OffsetDateTime> {
        self.data().expiration_time
    }

    /// Sets the timestamp for when the transaction should be evaluated for execution and then expire.
    pub fn expiration_time(&mut self, time: OffsetDateTime) -> &mut Self {
        self.data_mut().expiration_time = Some(time);
        self
    }

    /// Returns `true` if the transaction will be evaluated at `expiration_time` instead
    /// of when all the required signatures are received, `false` otherwise.
    #[must_use]
    pub fn get_wait_for_expiry(&self) -> bool {
        self.data().wait_for_expiry
    }

    /// Sets if the transaction will be evaluated for execution at `expiration_time` instead
    /// of when all required signatures are received.
    pub fn wait_for_expiry(&mut self, wait: bool) -> &mut Self {
        self.data_mut().wait_for_expiry = wait;
        self
    }

    /// Returns the id of the account to be charged the service fee for the scheduled transaction at
    /// the consensus time it executes (if ever).
    #[must_use]
    pub fn get_payer_account_id(&self) -> Option<AccountId> {
        self.data().payer_account_id
    }

    /// Sets the id of the account to be charged the service fee for the scheduled transaction at
    /// the consensus time that it executes (if ever).
    pub fn payer_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().payer_account_id = Some(id);
        self
    }

    /// Returns the memo for the schedule entity.
    #[must_use]
    pub fn get_schedule_memo(&self) -> Option<&str> {
        self.data().schedule_memo.as_deref()
    }

    /// Sets the memo for the schedule entity.
    pub fn schedule_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().schedule_memo = Some(memo.into());
        self
    }

    /// Returns the Hiero key which can be used to sign a `ScheduleDelete` and remove the schedule.
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.data().admin_key.as_ref()
    }

    /// Sets the Hiero key which can be used to sign a `ScheduleDelete` and remove the schedule.
    pub fn admin_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().admin_key = Some(key.into());
        self
    }
}

impl TransactionData for ScheduleCreateTransactionData {}

impl TransactionExecute for ScheduleCreateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { ScheduleServiceClient::new(channel).create_schedule(request).await })
    }
}

impl ValidateChecksums for ScheduleCreateTransactionData {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        self.payer_account_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for ScheduleCreateTransactionData {
    // not really anything I can do about this
    #[allow(clippy::too_many_lines)]
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        let body = self.scheduled_transaction.as_ref().map(|scheduled| {
            let data = scheduled.data.to_schedulable_transaction_data_protobuf();

            services::SchedulableTransactionBody {
                data: Some(data),
                memo: scheduled.transaction_memo.clone(),
                // FIXME: does not use the client to default the max transaction fee
                transaction_fee: scheduled
                    .max_transaction_fee
                    .unwrap_or_else(|| scheduled.data.default_max_transaction_fee())
                    .to_tinybars() as u64,
            }
        });

        let payer_account_id = self.payer_account_id.to_protobuf();
        let admin_key = self.admin_key.to_protobuf();
        let expiration_time = self.expiration_time.map(Into::into);

        services::transaction_body::Data::ScheduleCreate(services::ScheduleCreateTransactionBody {
            scheduled_transaction_body: body,
            memo: self.schedule_memo.clone().unwrap_or_default(),
            admin_key,
            payer_account_id,
            expiration_time,
            wait_for_expiry: self.wait_for_expiry,
        })
    }
}

impl From<ScheduleCreateTransactionData> for AnyTransactionData {
    fn from(transaction: ScheduleCreateTransactionData) -> Self {
        Self::ScheduleCreate(transaction)
    }
}

impl FromProtobuf<services::ScheduleCreateTransactionBody> for ScheduleCreateTransactionData {
    fn from_protobuf(pb: services::ScheduleCreateTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            scheduled_transaction: Option::from_protobuf(pb.scheduled_transaction_body)?,
            schedule_memo: Some(pb.memo),
            admin_key: Option::from_protobuf(pb.admin_key)?,
            payer_account_id: Option::from_protobuf(pb.payer_account_id)?,
            expiration_time: pb.expiration_time.map(Into::into),
            wait_for_expiry: pb.wait_for_expiry,
        })
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use time::OffsetDateTime;

    use super::ScheduleCreateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
        VALID_START,
    };
    use crate::transaction::ToSchedulableTransactionDataProtobuf;
    use crate::{
        AccountId,
        AnyTransaction,
        Hbar,
        PublicKey,
        ScheduleCreateTransaction,
        TransferTransaction,
    };

    fn scheduled_transaction() -> TransferTransaction {
        let mut tx = TransferTransaction::new();
        tx.hbar_transfer("0.0.555".parse().unwrap(), -Hbar::new(10))
            .hbar_transfer("0.0.666".parse().unwrap(), Hbar::new(10));
        tx
    }

    fn admin_key() -> PublicKey {
        unused_private_key().public_key()
    }

    const PAYER_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 222);
    const SCHEDULE_MEMO: &str = "hi";
    const EXPIRATION_TIME: OffsetDateTime = VALID_START;

    fn make_transaction() -> ScheduleCreateTransaction {
        let mut tx = ScheduleCreateTransaction::new_for_tests();

        tx.scheduled_transaction(scheduled_transaction())
            .admin_key(admin_key())
            .payer_account_id(PAYER_ACCOUNT_ID)
            .schedule_memo(SCHEDULE_MEMO)
            .expiration_time(EXPIRATION_TIME)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ScheduleCreate(
                ScheduleCreateTransactionBody {
                    scheduled_transaction_body: Some(
                        SchedulableTransactionBody {
                            transaction_fee: 200000000,
                            memo: "",
                            data: Some(
                                CryptoTransfer(
                                    CryptoTransferTransactionBody {
                                        transfers: Some(
                                            TransferList {
                                                account_amounts: [
                                                    AccountAmount {
                                                        account_id: Some(
                                                            AccountId {
                                                                shard_num: 0,
                                                                realm_num: 0,
                                                                account: Some(
                                                                    AccountNum(
                                                                        555,
                                                                    ),
                                                                ),
                                                            },
                                                        ),
                                                        amount: -1000000000,
                                                        is_approval: false,
                                                    },
                                                    AccountAmount {
                                                        account_id: Some(
                                                            AccountId {
                                                                shard_num: 0,
                                                                realm_num: 0,
                                                                account: Some(
                                                                    AccountNum(
                                                                        666,
                                                                    ),
                                                                ),
                                                            },
                                                        ),
                                                        amount: 1000000000,
                                                        is_approval: false,
                                                    },
                                                ],
                                            },
                                        ),
                                        token_transfers: [],
                                    },
                                ),
                            ),
                        },
                    ),
                    memo: "hi",
                    admin_key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    payer_account_id: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    222,
                                ),
                            ),
                        },
                    ),
                    expiration_time: Some(
                        Timestamp {
                            seconds: 1554158542,
                            nanos: 0,
                        },
                    ),
                    wait_for_expiry: false,
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::ScheduleCreateTransactionBody {
            scheduled_transaction_body: Some(services::SchedulableTransactionBody {
                transaction_fee: Hbar::new(2).to_tinybars() as _,
                memo: String::new(),
                data: Some(
                    scheduled_transaction().data().to_schedulable_transaction_data_protobuf(),
                ),
            }),
            memo: SCHEDULE_MEMO.to_owned(),
            admin_key: Some(admin_key().to_protobuf()),
            payer_account_id: Some(PAYER_ACCOUNT_ID.to_protobuf()),
            expiration_time: Some(EXPIRATION_TIME.to_protobuf()),
            wait_for_expiry: false,
        };

        let tx = ScheduleCreateTransactionData::from_protobuf(tx).unwrap();

        expect![[r#"
            SchedulableTransactionBody {
                data: Transfer(
                    TransferTransactionData {
                        transfers: [
                            Transfer {
                                account_id: "0.0.555",
                                amount: -1000000000,
                                is_approval: false,
                            },
                            Transfer {
                                account_id: "0.0.666",
                                amount: 1000000000,
                                is_approval: false,
                            },
                        ],
                        token_transfers: [],
                    },
                ),
                max_transaction_fee: Some(
                    "2 ",
                ),
                transaction_memo: "",
            }
        "#]]
        .assert_debug_eq(&tx.scheduled_transaction.unwrap());

        assert_eq!(tx.schedule_memo.as_deref(), Some(SCHEDULE_MEMO));
        assert_eq!(tx.admin_key, Some(admin_key().into()));
        assert_eq!(tx.payer_account_id, Some(PAYER_ACCOUNT_ID));
        assert_eq!(tx.expiration_time, Some(EXPIRATION_TIME));
        assert_eq!(tx.wait_for_expiry, false);
    }

    mod get_set {
        use super::*;
        #[test]
        fn admin_key() {
            let mut tx = ScheduleCreateTransaction::new();
            tx.admin_key(super::admin_key());

            assert_eq!(tx.get_admin_key(), Some(&super::admin_key().into()));
        }

        #[test]
        #[should_panic]
        fn admin_key_frozen_panics() {
            make_transaction().admin_key(super::admin_key());
        }

        #[test]
        fn payer_account_id() {
            let mut tx = ScheduleCreateTransaction::new();
            tx.payer_account_id(PAYER_ACCOUNT_ID);

            assert_eq!(tx.get_payer_account_id(), Some(PAYER_ACCOUNT_ID));
        }

        #[test]
        #[should_panic]
        fn payer_account_id_frozen_panics() {
            make_transaction().payer_account_id(PAYER_ACCOUNT_ID);
        }

        #[test]
        fn expiration_time() {
            let mut tx = ScheduleCreateTransaction::new();
            tx.expiration_time(EXPIRATION_TIME);

            assert_eq!(tx.get_expiration_time(), Some(EXPIRATION_TIME));
        }

        #[test]
        #[should_panic]
        fn expiration_time_frozen_panics() {
            make_transaction().expiration_time(EXPIRATION_TIME);
        }

        #[test]
        fn wait_for_expiry() {
            let mut tx = ScheduleCreateTransaction::new();
            tx.wait_for_expiry(true);

            assert_eq!(tx.get_wait_for_expiry(), true);
        }

        #[test]
        #[should_panic]
        fn wait_for_expiry_frozen_panics() {
            make_transaction().wait_for_expiry(true);
        }
    }
}
// Filename: src/schedule/schedule_delete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::schedule_service_client::ScheduleServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    ScheduleId,
    Transaction,
    ValidateChecksums,
};

/// Marks a schedule in the network's action queue as deleted. Must be signed
/// by the admin key of the target schedule. A deleted schedule cannot
/// receive any additional signing keys, nor will it be executed.
pub type ScheduleDeleteTransaction = Transaction<ScheduleDeleteTransactionData>;

#[derive(Debug, Default, Clone)]
pub struct ScheduleDeleteTransactionData {
    schedule_id: Option<ScheduleId>,
}

impl ScheduleDeleteTransaction {
    /// Returns the schedule to delete.
    #[must_use]
    pub fn get_schedule_id(&self) -> Option<ScheduleId> {
        self.data().schedule_id
    }

    /// Sets the schedule to delete.
    pub fn schedule_id(&mut self, id: ScheduleId) -> &mut Self {
        self.data_mut().schedule_id = Some(id);
        self
    }
}
impl TransactionData for ScheduleDeleteTransactionData {}

impl TransactionExecute for ScheduleDeleteTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { ScheduleServiceClient::new(channel).delete_schedule(request).await })
    }
}

impl ValidateChecksums for ScheduleDeleteTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.schedule_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for ScheduleDeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::ScheduleDelete(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for ScheduleDeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::ScheduleDelete(self.to_protobuf())
    }
}

impl From<ScheduleDeleteTransactionData> for AnyTransactionData {
    fn from(transaction: ScheduleDeleteTransactionData) -> Self {
        Self::ScheduleDelete(transaction)
    }
}

impl FromProtobuf<services::ScheduleDeleteTransactionBody> for ScheduleDeleteTransactionData {
    fn from_protobuf(pb: services::ScheduleDeleteTransactionBody) -> crate::Result<Self> {
        Ok(Self { schedule_id: Option::from_protobuf(pb.schedule_id)? })
    }
}

impl ToProtobuf for ScheduleDeleteTransactionData {
    type Protobuf = services::ScheduleDeleteTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ScheduleDeleteTransactionBody { schedule_id: self.schedule_id.to_protobuf() }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use super::ScheduleDeleteTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        ScheduleDeleteTransaction,
        ScheduleId,
    };

    const SCHEDULE_ID: ScheduleId = ScheduleId::new(0, 0, 444);

    fn make_transaction() -> ScheduleDeleteTransaction {
        let mut tx = ScheduleDeleteTransaction::new_for_tests();

        tx.schedule_id(SCHEDULE_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ScheduleDelete(
                ScheduleDeleteTransactionBody {
                    schedule_id: Some(
                        ScheduleId {
                            shard_num: 0,
                            realm_num: 0,
                            schedule_num: 444,
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::ScheduleDeleteTransactionBody {
            schedule_id: Some(SCHEDULE_ID.to_protobuf()),
        };

        let tx = ScheduleDeleteTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.schedule_id, Some(SCHEDULE_ID));
    }

    #[test]
    fn get_set_schedule_id() {
        let mut tx = ScheduleDeleteTransaction::new();
        tx.schedule_id(SCHEDULE_ID);

        assert_eq!(tx.get_schedule_id(), Some(SCHEDULE_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_schedule_id_frozen_panics() {
        make_transaction().schedule_id(SCHEDULE_ID);
    }
}
// Filename: src/schedule/schedule_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use hedera_proto::services;

use crate::entity_id::{
    Checksum,
    ValidateChecksums,
};
use crate::ledger_id::RefLedgerId;
use crate::{
    Client,
    EntityId,
    Error,
    FromProtobuf,
    ToProtobuf,
};

/// The unique identifier for a scheduled transaction on Hiero.
#[derive(Hash, PartialEq, Eq, Clone, Copy)]
#[repr(C)]
pub struct ScheduleId {
    /// A non-negative number identifying the shard containing this scheduled transaction.
    pub shard: u64,

    /// A non-negative number identifying the realm within the shard containing this scheduled transaction.
    pub realm: u64,

    /// A non-negative number identifying the entity within the realm containing this scheduled transaction.
    pub num: u64,

    /// A checksum if the schedule ID was read from a user inputted string which inclueded a checksum
    pub checksum: Option<Checksum>,
}

impl ScheduleId {
    /// Create a `ScheduleId` with the given `shard.realm.num`.
    pub const fn new(shard: u64, realm: u64, num: u64) -> Self {
        Self { shard, realm, num, checksum: None }
    }

    /// Create a new `AccountBalance` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Create a `ScheduleId` from a solidity address.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `address` cannot be parsed as a solidity address.
    pub fn from_solidity_address(address: &str) -> crate::Result<Self> {
        let EntityId { shard, realm, num, checksum } = EntityId::from_solidity_address(address)?;

        Ok(Self { shard, realm, num, checksum })
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }

    /// Convert `self` into a solidity `address`
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `self.shard` is larger than `u32::MAX`.
    pub fn to_solidity_address(&self) -> crate::Result<String> {
        EntityId { shard: self.shard, realm: self.realm, num: self.num, checksum: None }
            .to_solidity_address()
    }

    /// Convert `self` to a string with a valid checksum.
    #[must_use]
    pub fn to_string_with_checksum(&self, client: &Client) -> String {
        EntityId::to_string_with_checksum(self.to_string(), client)
    }

    /// Validates `self.checksum` (if it exists) for `client`.
    ///
    /// # Errors
    /// - [`Error::BadEntityId`] if there is a checksum, and the checksum is not valid for the client's `ledger_id`.
    pub fn validate_checksum(&self, client: &Client) -> Result<(), Error> {
        EntityId::validate_checksum(self.shard, self.realm, self.num, self.checksum, client)
    }
}

impl ValidateChecksums for ScheduleId {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        EntityId::validate_checksum_for_ledger_id(
            self.shard,
            self.realm,
            self.num,
            self.checksum,
            ledger_id,
        )
    }
}

impl Debug for ScheduleId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for ScheduleId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}.{}.{}", self.shard, self.realm, self.num)
    }
}

impl FromProtobuf<services::ScheduleId> for ScheduleId {
    fn from_protobuf(pb: services::ScheduleId) -> crate::Result<Self> {
        Ok(Self {
            num: pb.schedule_num as u64,
            shard: pb.shard_num as u64,
            realm: pb.realm_num as u64,
            checksum: None,
        })
    }
}

impl ToProtobuf for ScheduleId {
    type Protobuf = services::ScheduleId;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ScheduleId {
            schedule_num: self.num as i64,
            realm_num: self.realm as i64,
            shard_num: self.shard as i64,
        }
    }
}

impl From<u64> for ScheduleId {
    fn from(num: u64) -> Self {
        Self { num, shard: 0, realm: 0, checksum: None }
    }
}

impl FromStr for ScheduleId {
    type Err = crate::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        EntityId::from_str(s).map(Self::from)
    }
}

impl From<EntityId> for ScheduleId {
    fn from(value: EntityId) -> Self {
        let EntityId { shard, realm, num, checksum } = value;

        Self { shard, realm, num, checksum }
    }
}

#[cfg(test)]
mod tests {
    use crate::ScheduleId;

    #[test]
    fn should_serialize_from_string() {
        assert_eq!("0.0.5005", "0.0.5005".parse::<ScheduleId>().unwrap().to_string());
    }

    #[test]
    fn from_bytes() {
        assert_eq!(
            "0.0.5005",
            ScheduleId::from_bytes(&ScheduleId::new(0, 0, 5005).to_bytes()).unwrap().to_string()
        );
    }

    #[test]
    fn from_solidity_address() {
        assert_eq!(
            "0.0.5005",
            ScheduleId::from_solidity_address("000000000000000000000000000000000000138D")
                .unwrap()
                .to_string()
        );
    }

    #[test]
    fn to_solidity_address() {
        assert_eq!(
            "000000000000000000000000000000000000138d",
            ScheduleId::new(0, 0, 5005).to_solidity_address().unwrap()
        );
    }
}
// Filename: src/schedule/schedule_info.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use time::OffsetDateTime;

use super::schedulable_transaction_body::SchedulableTransactionBody;
use crate::protobuf::ToProtobuf;
use crate::transaction::TransactionBody;
use crate::{
    AccountId,
    AnyTransaction,
    FromProtobuf,
    Key,
    KeyList,
    LedgerId,
    ScheduleId,
    Transaction,
    TransactionId,
};

// TODO: scheduled_transaction
/// Response from [`ScheduleInfoQuery`][crate::ScheduleInfoQuery].
#[derive(Debug, Clone)]
pub struct ScheduleInfo {
    /// The ID of the schedule for which information is requested.
    pub schedule_id: ScheduleId,

    /// The account that created the scheduled transaction.
    pub creator_account_id: AccountId,

    /// The account paying for the execution of the scheduled transaction.
    pub payer_account_id: Option<AccountId>,

    /// The signatories that have provided signatures so far for the schedule
    /// transaction.
    pub signatories: KeyList,

    /// The key which is able to delete the schedule transaction if set.
    pub admin_key: Option<Key>,

    /// The transaction id that will be used in the record of the scheduled transaction (if
    /// it executes).
    pub scheduled_transaction_id: TransactionId,

    scheduled_transaction: SchedulableTransactionBody,

    /// When set to true, the transaction will be evaluated for execution at `expiration_time`
    /// instead of when all required signatures are received.
    pub wait_for_expiry: bool,

    /// Publicly visible information about the Schedule entity.
    pub memo: String,

    /// The date and time the schedule transaction will expire
    pub expiration_time: Option<OffsetDateTime>,

    /// The time the schedule transaction was executed.
    pub executed_at: Option<OffsetDateTime>,

    /// The time the schedule transaction was deleted.
    pub deleted_at: Option<OffsetDateTime>,

    /// The ledger ID the response was returned from
    pub ledger_id: LedgerId,
}

impl ScheduleInfo {
    /// Create a new `ScheduleInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::ScheduleInfo>::from_bytes(bytes)
    }

    /// Returns the scheduled transaction.
    ///
    /// This is *not* guaranteed to be a constant time operation.
    pub fn scheduled_transaction(&self) -> crate::Result<AnyTransaction> {
        // note: this can't error *right now* but the API *will* be faliable eventually, and as such, returns a result to make the change non-breaking.
        Ok(Transaction::from_parts(
            TransactionBody {
                data: (*self.scheduled_transaction.data).clone().into(),
                node_account_ids: None,
                transaction_valid_duration: None,
                max_transaction_fee: None,
                transaction_memo: self.scheduled_transaction.transaction_memo.clone(),
                transaction_id: Some(self.scheduled_transaction_id),
                operator: None,
                is_frozen: true,
                regenerate_transaction_id: Some(false),
                custom_fee_limits: Vec::new(),
            },
            Vec::new(),
        ))
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::response::Response> for ScheduleInfo {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let response = pb_getv!(pb, ScheduleGetInfo, services::response::Response);
        let info = pb_getf!(response, schedule_info)?;
        Self::from_protobuf(info)
    }
}

impl FromProtobuf<services::ScheduleInfo> for ScheduleInfo {
    fn from_protobuf(pb: services::ScheduleInfo) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let schedule_id = pb_getf!(pb, schedule_id)?;
        let creator_account_id = pb_getf!(pb, creator_account_id)?;
        let payer_account_id = Option::from_protobuf(pb.payer_account_id)?;
        let admin_key = Option::from_protobuf(pb.admin_key)?;
        let ledger_id = LedgerId::from_bytes(pb.ledger_id);

        let scheduled_transaction_id =
            TransactionId::from_protobuf(pb_getf!(pb, scheduled_transaction_id)?)?;

        let transaction_body =
            SchedulableTransactionBody::from_protobuf(pb_getf!(pb, scheduled_transaction_body)?)?;

        let signatories = pb.signers.map(KeyList::from_protobuf).transpose()?.unwrap_or_default();

        let (executed_at, deleted_at) = match pb.data {
            Some(services::schedule_info::Data::DeletionTime(deleted)) => {
                (None, Some(deleted.into()))
            }

            Some(services::schedule_info::Data::ExecutionTime(executed)) => {
                (Some(executed.into()), None)
            }

            None => (None, None),
        };

        Ok(Self {
            schedule_id: ScheduleId::from_protobuf(schedule_id)?,
            executed_at,
            deleted_at,
            memo: pb.memo,
            creator_account_id: AccountId::from_protobuf(creator_account_id)?,
            payer_account_id,
            expiration_time: pb.expiration_time.map(Into::into),
            admin_key,
            scheduled_transaction_id,
            signatories,
            wait_for_expiry: pb.wait_for_expiry,
            ledger_id,
            scheduled_transaction: transaction_body,
        })
    }
}

impl ToProtobuf for ScheduleInfo {
    type Protobuf = services::ScheduleInfo;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ScheduleInfo {
            schedule_id: Some(self.schedule_id.to_protobuf()),
            expiration_time: self.expiration_time.to_protobuf(),
            memo: self.memo.clone(),
            admin_key: self.admin_key.to_protobuf(),
            signers: (!self.signatories.is_empty())
                .then(|| services::KeyList { keys: self.signatories.keys.to_protobuf() }),
            creator_account_id: Some(self.creator_account_id.to_protobuf()),
            payer_account_id: self.payer_account_id.to_protobuf(),
            scheduled_transaction_id: Some(self.scheduled_transaction_id.to_protobuf()),
            ledger_id: self.ledger_id.to_bytes(),
            wait_for_expiry: self.wait_for_expiry,

            // unimplemented fields
            scheduled_transaction_body: Some(
                self.scheduled_transaction.to_scheduled_body_protobuf(),
            ),
            data: None,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::schedule::schedulable_transaction_body::{
        AnySchedulableTransactionData,
        SchedulableTransactionBody,
    };
    use crate::transaction::test_helpers::{
        unused_private_key,
        VALID_START,
    };
    use crate::transaction::ToSchedulableTransactionDataProtobuf;
    use crate::{
        AccountDeleteTransaction,
        LedgerId,
        ScheduleInfo,
        TransactionId,
    };

    fn make_info() -> ScheduleInfo {
        let schedueld = AnySchedulableTransactionData::from_protobuf(
            AccountDeleteTransaction::new()
                .account_id("6.6.6".parse().unwrap())
                .data()
                .to_schedulable_transaction_data_protobuf(),
        )
        .unwrap();

        ScheduleInfo {
            schedule_id: "1.2.3".parse().unwrap(),
            creator_account_id: "4.5.6".parse().unwrap(),
            payer_account_id: Some("2.3.4".parse().unwrap()),
            signatories: crate::KeyList::from([unused_private_key().public_key()]),
            admin_key: Some(unused_private_key().public_key().into()),
            scheduled_transaction_id: TransactionId {
                account_id: "5006".parse().unwrap(),
                valid_start: VALID_START,
                nonce: None,
                scheduled: false,
            },
            scheduled_transaction: SchedulableTransactionBody {
                data: Box::new(schedueld),
                max_transaction_fee: None,
                transaction_memo: Default::default(),
            },
            wait_for_expiry: true,
            memo: "memo".to_owned(),
            expiration_time: Some(VALID_START),
            executed_at: Some(VALID_START),
            deleted_at: None,
            ledger_id: LedgerId::testnet(),
        }
    }

    fn make_deleted_info() -> ScheduleInfo {
        ScheduleInfo { executed_at: None, deleted_at: Some(VALID_START), ..make_info() }
    }

    #[test]
    fn serialize() {
        expect![[r#"
            ScheduleInfo {
                schedule_id: Some(
                    ScheduleId {
                        shard_num: 1,
                        realm_num: 2,
                        schedule_num: 3,
                    },
                ),
                expiration_time: Some(
                    Timestamp {
                        seconds: 1554158542,
                        nanos: 0,
                    },
                ),
                scheduled_transaction_body: Some(
                    SchedulableTransactionBody {
                        transaction_fee: 200000000,
                        memo: "",
                        data: Some(
                            CryptoDelete(
                                CryptoDeleteTransactionBody {
                                    transfer_account_id: None,
                                    delete_account_id: Some(
                                        AccountId {
                                            shard_num: 6,
                                            realm_num: 6,
                                            account: Some(
                                                AccountNum(
                                                    6,
                                                ),
                                            ),
                                        },
                                    ),
                                },
                            ),
                        ),
                    },
                ),
                memo: "memo",
                admin_key: Some(
                    Key {
                        key: Some(
                            Ed25519(
                                [
                                    224,
                                    200,
                                    236,
                                    39,
                                    88,
                                    165,
                                    135,
                                    159,
                                    250,
                                    194,
                                    38,
                                    161,
                                    60,
                                    12,
                                    81,
                                    107,
                                    121,
                                    158,
                                    114,
                                    227,
                                    81,
                                    65,
                                    160,
                                    221,
                                    130,
                                    143,
                                    148,
                                    211,
                                    121,
                                    136,
                                    164,
                                    183,
                                ],
                            ),
                        ),
                    },
                ),
                signers: Some(
                    KeyList {
                        keys: [
                            Key {
                                key: Some(
                                    Ed25519(
                                        [
                                            224,
                                            200,
                                            236,
                                            39,
                                            88,
                                            165,
                                            135,
                                            159,
                                            250,
                                            194,
                                            38,
                                            161,
                                            60,
                                            12,
                                            81,
                                            107,
                                            121,
                                            158,
                                            114,
                                            227,
                                            81,
                                            65,
                                            160,
                                            221,
                                            130,
                                            143,
                                            148,
                                            211,
                                            121,
                                            136,
                                            164,
                                            183,
                                        ],
                                    ),
                                ),
                            },
                        ],
                    },
                ),
                creator_account_id: Some(
                    AccountId {
                        shard_num: 4,
                        realm_num: 5,
                        account: Some(
                            AccountNum(
                                6,
                            ),
                        ),
                    },
                ),
                payer_account_id: Some(
                    AccountId {
                        shard_num: 2,
                        realm_num: 3,
                        account: Some(
                            AccountNum(
                                4,
                            ),
                        ),
                    },
                ),
                scheduled_transaction_id: Some(
                    TransactionId {
                        transaction_valid_start: Some(
                            Timestamp {
                                seconds: 1554158542,
                                nanos: 0,
                            },
                        ),
                        account_id: Some(
                            AccountId {
                                shard_num: 0,
                                realm_num: 0,
                                account: Some(
                                    AccountNum(
                                        5006,
                                    ),
                                ),
                            },
                        ),
                        scheduled: false,
                        nonce: 0,
                    },
                ),
                ledger_id: [
                    1,
                ],
                wait_for_expiry: true,
                data: None,
            }
        "#]]
        .assert_debug_eq(&make_info().to_protobuf());
    }

    #[test]
    fn serialize_deleted() {
        expect![[r#"
            ScheduleInfo {
                schedule_id: Some(
                    ScheduleId {
                        shard_num: 1,
                        realm_num: 2,
                        schedule_num: 3,
                    },
                ),
                expiration_time: Some(
                    Timestamp {
                        seconds: 1554158542,
                        nanos: 0,
                    },
                ),
                scheduled_transaction_body: Some(
                    SchedulableTransactionBody {
                        transaction_fee: 200000000,
                        memo: "",
                        data: Some(
                            CryptoDelete(
                                CryptoDeleteTransactionBody {
                                    transfer_account_id: None,
                                    delete_account_id: Some(
                                        AccountId {
                                            shard_num: 6,
                                            realm_num: 6,
                                            account: Some(
                                                AccountNum(
                                                    6,
                                                ),
                                            ),
                                        },
                                    ),
                                },
                            ),
                        ),
                    },
                ),
                memo: "memo",
                admin_key: Some(
                    Key {
                        key: Some(
                            Ed25519(
                                [
                                    224,
                                    200,
                                    236,
                                    39,
                                    88,
                                    165,
                                    135,
                                    159,
                                    250,
                                    194,
                                    38,
                                    161,
                                    60,
                                    12,
                                    81,
                                    107,
                                    121,
                                    158,
                                    114,
                                    227,
                                    81,
                                    65,
                                    160,
                                    221,
                                    130,
                                    143,
                                    148,
                                    211,
                                    121,
                                    136,
                                    164,
                                    183,
                                ],
                            ),
                        ),
                    },
                ),
                signers: Some(
                    KeyList {
                        keys: [
                            Key {
                                key: Some(
                                    Ed25519(
                                        [
                                            224,
                                            200,
                                            236,
                                            39,
                                            88,
                                            165,
                                            135,
                                            159,
                                            250,
                                            194,
                                            38,
                                            161,
                                            60,
                                            12,
                                            81,
                                            107,
                                            121,
                                            158,
                                            114,
                                            227,
                                            81,
                                            65,
                                            160,
                                            221,
                                            130,
                                            143,
                                            148,
                                            211,
                                            121,
                                            136,
                                            164,
                                            183,
                                        ],
                                    ),
                                ),
                            },
                        ],
                    },
                ),
                creator_account_id: Some(
                    AccountId {
                        shard_num: 4,
                        realm_num: 5,
                        account: Some(
                            AccountNum(
                                6,
                            ),
                        ),
                    },
                ),
                payer_account_id: Some(
                    AccountId {
                        shard_num: 2,
                        realm_num: 3,
                        account: Some(
                            AccountNum(
                                4,
                            ),
                        ),
                    },
                ),
                scheduled_transaction_id: Some(
                    TransactionId {
                        transaction_valid_start: Some(
                            Timestamp {
                                seconds: 1554158542,
                                nanos: 0,
                            },
                        ),
                        account_id: Some(
                            AccountId {
                                shard_num: 0,
                                realm_num: 0,
                                account: Some(
                                    AccountNum(
                                        5006,
                                    ),
                                ),
                            },
                        ),
                        scheduled: false,
                        nonce: 0,
                    },
                ),
                ledger_id: [
                    1,
                ],
                wait_for_expiry: true,
                data: None,
            }
        "#]]
        .assert_debug_eq(&make_deleted_info().to_protobuf());
    }
}
// Filename: src/schedule/schedule_info_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::schedule_service_client::ScheduleServiceClient;
use tonic::transport::Channel;

use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    Error,
    Query,
    ScheduleId,
    ScheduleInfo,
    ToProtobuf,
    ValidateChecksums,
};

/// Get all the information about a schedule.
pub type ScheduleInfoQuery = Query<ScheduleInfoQueryData>;

#[derive(Default, Clone, Debug)]
pub struct ScheduleInfoQueryData {
    schedule_id: Option<ScheduleId>,
}

impl From<ScheduleInfoQueryData> for AnyQueryData {
    #[inline]
    fn from(data: ScheduleInfoQueryData) -> Self {
        Self::ScheduleInfo(data)
    }
}

impl ScheduleInfoQuery {
    /// Returns the schedule ID for which information is requested.
    #[must_use]
    pub fn get_schedule_id(&self) -> Option<ScheduleId> {
        self.data.schedule_id
    }

    /// Sets the schedule ID for which information is requested.
    pub fn schedule_id(&mut self, id: impl Into<ScheduleId>) -> &mut Self {
        self.data.schedule_id = Some(id.into());
        self
    }
}

impl ToQueryProtobuf for ScheduleInfoQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let schedule_id = self.schedule_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::ScheduleGetInfo(services::ScheduleGetInfoQuery {
                schedule_id,
                header: Some(header),
            })),
        }
    }
}

impl QueryExecute for ScheduleInfoQueryData {
    type Response = ScheduleInfo;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { ScheduleServiceClient::new(channel).get_schedule_info(request).await })
    }
}

impl ValidateChecksums for ScheduleInfoQueryData {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        self.schedule_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        Hbar,
        ScheduleId,
        ScheduleInfoQuery,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    ScheduleGetInfo(
                        ScheduleGetInfoQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            schedule_id: Some(
                                ScheduleId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    schedule_num: 5005,
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &ScheduleInfoQuery::new()
                .schedule_id(ScheduleId::new(0, 0, 5005))
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        )
    }

    #[test]
    fn get_set_schedule_id() {
        let mut query = ScheduleInfoQuery::new();
        query.schedule_id(ScheduleId::new(0, 0, 5005));

        assert_eq!(query.get_schedule_id(), Some(ScheduleId::new(0, 0, 5005)));
    }
}
// Filename: src/schedule/schedule_sign_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::schedule_service_client::ScheduleServiceClient;
use tonic::transport::Channel;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    ScheduleId,
    Transaction,
    ValidateChecksums,
};

/// Adds zero or more signing keys to a schedule.
pub type ScheduleSignTransaction = Transaction<ScheduleSignTransactionData>;

#[derive(Debug, Default, Clone)]
pub struct ScheduleSignTransactionData {
    schedule_id: Option<ScheduleId>,
}

impl ScheduleSignTransaction {
    /// Returns the schedule to add signing keys to.
    #[must_use]
    pub fn get_schedule_id(&self) -> Option<ScheduleId> {
        self.data().schedule_id
    }

    /// Sets the schedule to add signing keys to.
    pub fn schedule_id(&mut self, id: ScheduleId) -> &mut Self {
        self.data_mut().schedule_id = Some(id);
        self
    }
}

impl TransactionData for ScheduleSignTransactionData {}

impl TransactionExecute for ScheduleSignTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { ScheduleServiceClient::new(channel).delete_schedule(request).await })
    }
}

impl ValidateChecksums for ScheduleSignTransactionData {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        self.schedule_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for ScheduleSignTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        let schedule_id = self.schedule_id.to_protobuf();

        services::transaction_body::Data::ScheduleSign(services::ScheduleSignTransactionBody {
            schedule_id,
        })
    }
}

impl From<ScheduleSignTransactionData> for AnyTransactionData {
    fn from(transaction: ScheduleSignTransactionData) -> Self {
        Self::ScheduleSign(transaction)
    }
}

impl FromProtobuf<services::ScheduleSignTransactionBody> for ScheduleSignTransactionData {
    fn from_protobuf(pb: services::ScheduleSignTransactionBody) -> crate::Result<Self> {
        Ok(Self { schedule_id: Option::from_protobuf(pb.schedule_id)? })
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::schedule::ScheduleSignTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        ScheduleId,
        ScheduleSignTransaction,
    };

    const SCHEDULE_ID: ScheduleId = ScheduleId::new(0, 0, 444);

    fn make_transaction() -> ScheduleSignTransaction {
        let mut tx = ScheduleSignTransaction::new_for_tests();

        tx.schedule_id(SCHEDULE_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ScheduleSign(
                ScheduleSignTransactionBody {
                    schedule_id: Some(
                        ScheduleId {
                            shard_num: 0,
                            realm_num: 0,
                            schedule_num: 444,
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx =
            services::ScheduleSignTransactionBody { schedule_id: Some(SCHEDULE_ID.to_protobuf()) };

        let tx = ScheduleSignTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.schedule_id, Some(SCHEDULE_ID));
    }

    #[test]
    fn get_set_schedule_id() {
        let mut tx = ScheduleSignTransaction::new();
        tx.schedule_id(SCHEDULE_ID);

        assert_eq!(tx.get_schedule_id(), Some(SCHEDULE_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_schedule_id_frozen_panics() {
        make_transaction().schedule_id(SCHEDULE_ID);
    }
}
// Filename: src/semantic_version/mod.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt;
use std::str::FromStr;

use hedera_proto::services;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::Error;

#[cfg(test)]
mod tests;

/// Hiero follows [semantic versioning](https://semver.org) for both the HAPI protobufs and
/// the Services software.
#[derive(Debug, Clone)]
pub struct SemanticVersion {
    /// Increases with incompatible API changes
    pub major: u32,

    /// Increases with backwards-compatible new functionality
    pub minor: u32,

    /// Increases with backwards-compatible bug fixes]
    pub patch: u32,

    /// A pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers (<https://semver.org/#spec-item-9>);
    /// so given a semver 0.14.0-alpha.1+21AF26D3, this field would contain alpha.1
    pub prerelease: String,

    /// Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers
    /// immediately following the patch or pre-release version (<https://semver.org/#spec-item-10>);
    /// so given a semver 0.14.0-alpha.1+21AF26D3, this field would contain 21AF26D3
    pub build: String,
}

impl fmt::Display for SemanticVersion {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}.{}.{}", self.major, self.minor, self.patch)?;
        if !self.prerelease.is_empty() {
            write!(f, "-{}", &self.prerelease)?;
        }

        if !self.build.is_empty() {
            write!(f, "+{}", &self.build)?;
        }

        Ok(())
    }
}

fn is_valid_ident_char(ch: char) -> bool {
    ch.is_ascii_alphanumeric() || ch == '-'
}

/// Returns true if this is a numeric string, and it starts with `"0"`, and isn't exactly `"0"`
fn is_numeric_with_leading_zero(s: &str) -> bool {
    s.strip_prefix('0')
        .map_or(false, |rest| !rest.is_empty() && rest.chars().all(|it| it.is_ascii_digit()))
}

fn parse_version(s: &str, name: &str) -> crate::Result<u32> {
    if is_numeric_with_leading_zero(s) {
        return Err(Error::basic_parse(format!(
            "semver section `{name}` starts with leading 0: `{s}`"
        )));
    }

    s.parse().map_err(Error::basic_parse)
}

fn parse_prerelease(s: &str) -> crate::Result<String> {
    if s.is_empty() {
        return Err(Error::basic_parse("semver with empty rerelease"));
    }

    for identifier in s.split('.') {
        if identifier.is_empty() {
            return Err(Error::basic_parse("semver with empty -pre identifier"));
        }

        if !identifier.chars().all(is_valid_ident_char) {
            return Err(Error::basic_parse(
                "semver with invalid identifier for the -pre section: `{identifier}`",
            ));
        }

        if is_numeric_with_leading_zero(identifier) {
            return Err(Error::basic_parse(
                "numeric pre-release identifier has leading zero: `{identifier}`",
            ));
        }
    }

    Ok(s.to_owned())
}

fn parse_build(s: &str) -> crate::Result<String> {
    if s.is_empty() {
        return Err(Error::basic_parse("semver with empty build"));
    }

    for identifier in s.split('.') {
        if identifier.is_empty() {
            return Err(Error::basic_parse("semver with empty build-section identifier"));
        }

        if !identifier.chars().all(is_valid_ident_char) {
            return Err(Error::basic_parse(
                "semver with invalid identifier for the build section: `{identifier}",
            ));
        }
    }

    Ok(s.to_owned())
}

impl FromStr for SemanticVersion {
    type Err = Error;

    // its probably useless doing strict parsing when Hiero probably accepts loose parsing anyway, but lets at least *try* not to make it worse.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.splitn(3, '.').collect();

        match &*parts {
            [major, minor, rest] => {
                let (patch, pre, build) = {
                    // while it seems like this is a weird order,
                    // it actually makes more sense than `pre` first,
                    // because `pre` is in the middle of the string.
                    let (rest, build) = match rest.split_once('+') {
                        Some((rest, build)) => (rest, Some(build)),
                        None => (*rest, None),
                    };

                    let (patch, pre) = match rest.split_once('-') {
                        Some((patch, pre)) => (patch, Some(pre)),
                        None => (rest, None),
                    };

                    (patch, pre, build)
                };

                let major = parse_version(major, "major")?;
                let minor = parse_version(minor, "minor")?;
                let patch = parse_version(patch, "patch")?;

                let prerelease = match pre {
                    Some(it) => parse_prerelease(it)?,
                    None => String::new(),
                };

                let build = match build {
                    Some(it) => parse_build(it)?,
                    None => String::new(),
                };

                Ok(Self { major, minor, patch, prerelease, build })
            }
            _ => Err(Error::basic_parse("expected major.minor.patch for semver")),
        }
    }
}

impl SemanticVersion {
    /// Create a new `SemanticVersion` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::SemanticVersion> for SemanticVersion {
    fn from_protobuf(pb: services::SemanticVersion) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Ok(Self {
            major: pb.major as u32,
            minor: pb.minor as u32,
            patch: pb.patch as u32,
            prerelease: pb.pre,
            build: pb.build,
        })
    }
}

impl ToProtobuf for SemanticVersion {
    type Protobuf = services::SemanticVersion;
    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            major: self.major as i32,
            minor: self.minor as i32,
            patch: self.patch as i32,
            pre: self.prerelease.clone(),
            build: self.build.clone(),
        }
    }
}
// Filename: src/semantic_version/tests.rs
// SPDX-License-Identifier: Apache-2.0

mod parse {
    use std::str::FromStr;

    use expect_test::{
        expect,
        Expect,
    };

    use crate::SemanticVersion;

    /// this is just a fancy way to do
    /// ```no_run
    /// fn tests() {
    ///     let cases = [("0.1.2", expect![]), ("21.0.0-alpha", expect![])];
    ///     for (semver, expect) in cases {
    ///         test(semver, expect)
    ///     }
    /// }
    /// ```
    ///
    /// The advantage this has over that approach is that every test is its own function still,
    /// which allows you to actually know what the _name_ of a failing testcase is.
    ///
    /// # Usage
    /// Mirroring the above situation
    /// ```no_run
    /// tests![
    ///     fn basic("0.1.2") = expect![],
    ///     fn with_prerelease("21.0.0-alpha", expect![]),
    /// ]
    /// ```
    /// which is equivalent to writing:
    /// ```no_run
    /// #[test]
    /// fn basic() {
    ///     test("0.1.2", expect![])
    /// }
    ///
    /// #[test]
    /// fn with_prerelease() {
    ///     test("21.0.0-alpha", expect![])
    /// }
    macro_rules! tests {
        ( $( fn $name:ident ($lit:literal) = $e:expr ),* $(,)?) => {
            $(
                #[test]
                fn $name() {
                    test($lit, $e)
                }
            )*
        };
    }

    #[track_caller]
    fn test(s: &str, expect: Expect) {
        let semver: SemanticVersion = s.parse().unwrap();

        expect.assert_debug_eq(&semver)
    }

    #[track_caller]
    fn err(s: &str, expect: Expect) {
        match SemanticVersion::from_str(s) {
            Ok(semver) => panic!("invalid semver `{s}` parsed as valid ({semver:?})"),
            Err(e) => expect.assert_eq(&e.to_string()),
        }
    }

    tests![
        fn basic("32.10.53") = expect![[r#"
            SemanticVersion {
                major: 32,
                minor: 10,
                patch: 53,
                prerelease: "",
                build: "",
            }
        "#]],

        fn with_prerelease("31.9.52-1") = expect![[r#"
            SemanticVersion {
                major: 31,
                minor: 9,
                patch: 52,
                prerelease: "1",
                build: "",
            }
        "#]],

        fn with_build("314.159.65+35") = expect![[r#"
            SemanticVersion {
                major: 314,
                minor: 159,
                patch: 65,
                prerelease: "",
                build: "35",
            }
        "#]],

        fn with_prerelease_and_build("2.4.8-16+32") = expect![[r#"
            SemanticVersion {
                major: 2,
                minor: 4,
                patch: 8,
                prerelease: "16",
                build: "32",
            }
        "#]],

        fn spec_prerelease_example1("1.0.0-alpha") = expect![[r#"
            SemanticVersion {
                major: 1,
                minor: 0,
                patch: 0,
                prerelease: "alpha",
                build: "",
            }
        "#]],

        fn spec_prerelease_example2("1.0.0-alpha.1") = expect![[r#"
            SemanticVersion {
                major: 1,
                minor: 0,
                patch: 0,
                prerelease: "alpha.1",
                build: "",
            }
        "#]],

        fn spec_prerelease_example3("1.0.0-0.3.7") = expect![[r#"
            SemanticVersion {
                major: 1,
                minor: 0,
                patch: 0,
                prerelease: "0.3.7",
                build: "",
            }
        "#]],

        fn spec_prerelease_example4("1.0.0-x.7.z.92") = expect![[r#"
            SemanticVersion {
                major: 1,
                minor: 0,
                patch: 0,
                prerelease: "x.7.z.92",
                build: "",
            }
        "#]],

        fn spec_prerelease_example5("1.0.0-x-y-z.--") = expect![[r#"
            SemanticVersion {
                major: 1,
                minor: 0,
                patch: 0,
                prerelease: "x-y-z.--",
                build: "",
            }
        "#]],

        fn spec_build_example1("1.0.0-alpha+001") = expect![[r#"
            SemanticVersion {
                major: 1,
                minor: 0,
                patch: 0,
                prerelease: "alpha",
                build: "001",
            }
        "#]],

        fn spec_build_example2("1.0.0+20130313144700") = expect![[r#"
            SemanticVersion {
                major: 1,
                minor: 0,
                patch: 0,
                prerelease: "",
                build: "20130313144700",
            }
        "#]],

        fn spec_build_example3("1.0.0-beta+exp.sha.5114f85") = expect![[r#"
            SemanticVersion {
                major: 1,
                minor: 0,
                patch: 0,
                prerelease: "beta",
                build: "exp.sha.5114f85",
            }
        "#]],

        fn spec_build_example4("1.0.0+21AF26D3---117B344092BD") = expect![[r#"
            SemanticVersion {
                major: 1,
                minor: 0,
                patch: 0,
                prerelease: "",
                build: "21AF26D3---117B344092BD",
            }
        "#]],
    ];

    #[test]
    fn err_major_leading_zero() {
        err(
            "00.1.2",
            expect!["failed to parse: semver section `major` starts with leading 0: `00`"],
        )
    }

    #[test]
    fn err_minor_leading_zero() {
        err(
            "0.01.2",
            expect!["failed to parse: semver section `minor` starts with leading 0: `01`"],
        )
    }

    #[test]
    fn err_patch_leading_zero() {
        err(
            "0.1.0002",
            expect!["failed to parse: semver section `patch` starts with leading 0: `0002`"],
        )
    }
}

mod display {
    use expect_test::{
        expect,
        Expect,
    };

    use crate::SemanticVersion;

    #[track_caller]
    fn test(semver: SemanticVersion, expect: Expect) {
        expect.assert_eq(&semver.to_string())
    }

    // there aren't enough of these to get the macro treatment

    #[test]
    fn basic() {
        test(
            SemanticVersion {
                major: 1,
                minor: 2,
                patch: 3,
                prerelease: String::new(),
                build: String::new(),
            },
            expect!["1.2.3"],
        )
    }

    #[test]
    fn with_prerelease() {
        test(
            SemanticVersion {
                major: 3,
                minor: 1,
                patch: 4,
                prerelease: "15.92".to_owned(),
                build: String::new(),
            },
            expect!["3.1.4-15.92"],
        )
    }

    #[test]
    fn with_build() {
        test(
            SemanticVersion {
                major: 1,
                minor: 41,
                patch: 1,
                prerelease: String::new(),
                build: "6535asd".to_owned(),
            },
            expect!["1.41.1+6535asd"],
        )
    }

    #[test]
    fn with_prerelease_and_build() {
        test(
            SemanticVersion {
                major: 0,
                minor: 1,
                patch: 4,
                prerelease: "0.9a2".to_owned(),
                build: "sha.25531c".to_owned(),
            },
            expect!["0.1.4-0.9a2+sha.25531c"],
        )
    }
}
// Filename: src/service_endpoint.rs
// SPDX-License-Identifier: Apache-2.0

use std::net::{
    Ipv4Addr,
    SocketAddrV4,
};

use hedera_proto::services;

use crate::protobuf::ToProtobuf;
use crate::{
    Error,
    FromProtobuf,
};

fn parse_socket_addr_v4(ip: Vec<u8>, port: i32) -> crate::Result<SocketAddrV4> {
    let octets: Result<[u8; 4], _> = ip.try_into();
    let octets = octets.map_err(|v| {
        Error::from_protobuf(format!("expected 4 byte ip address, got `{}` bytes", v.len()))
    })?;

    let port = u16::try_from(port).map_err(|_| {
        Error::from_protobuf(format!(
            "expected 16 bit non-negative port number, but the port was actually `{port}`",
        ))
    })?;

    Ok(SocketAddrV4::new(octets.into(), port))
}

fn validate_domain_name(domain_name: String) -> crate::Result<()> {
    if domain_name.len() > 253 {
        return Err(Error::from_protobuf("Domain name exceeds 253 characters"));
    }

    // Check for valid characters and format
    if !domain_name.chars().all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '.') {
        return Err(Error::from_protobuf("Invalid characters in domain name"));
    }

    // Check for valid domain name format (simplified)
    if !domain_name.contains('.') || domain_name.starts_with('.') || domain_name.ends_with('.') {
        return Err(Error::from_protobuf("Invalid domain name format"));
    }

    Ok(())
}

/// Contains the IP address, the port, and the domain name representing a service endpoint of
/// a Node in a network. Used to reach the Hiero API and submit transactions
/// to the network.
#[derive(Debug, Clone, PartialEq)]
pub struct ServiceEndpoint {
    /// The 4-byte IPv4 address of the endpoint encoded in left to right order
    pub ip_address_v4: Option<Ipv4Addr>,

    /// The port of the service endpoint
    pub port: i32,

    /// A node domain name.<br/>
    /// This MUST be the fully qualified domain(DNS) name of the node.<br/>
    /// This value MUST NOT be more than 253 characters.
    /// domain_name and ipAddressV4 are mutually exclusive.
    /// When the `domain_name` field is set, the `ipAddressV4` field MUST NOT be set.<br/>
    /// When the `ipAddressV4` field is set, the `domain_name` field MUST NOT be set.
    pub domain_name: String,
}

impl FromProtobuf<services::ServiceEndpoint> for ServiceEndpoint {
    fn from_protobuf(pb: services::ServiceEndpoint) -> crate::Result<Self> {
        let mut port = pb.port;
        if pb.port == 0 || pb.port == 50111 {
            port = 50211;
        }

        let socket_addr_v4 = parse_socket_addr_v4(pb.ip_address_v4, port)?;

        if !pb.domain_name.is_empty() {
            validate_domain_name(pb.domain_name.clone())?;
        }

        Ok(Self {
            ip_address_v4: Some(socket_addr_v4.ip().to_owned()),
            port: socket_addr_v4.port() as i32,
            domain_name: pb.domain_name,
        })
    }
}

impl ToProtobuf for ServiceEndpoint {
    type Protobuf = services::ServiceEndpoint;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ServiceEndpoint {
            ip_address_v4: self.ip_address_v4.unwrap().octets().to_vec(),
            port: self.port,
            domain_name: self.domain_name.clone(),
        }
    }
}
// Filename: src/signer.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt;

use triomphe::Arc;
use unsize::{
    CoerceUnsize,
    Coercion,
};

use crate::{
    PrivateKey,
    PublicKey,
};

#[derive(Clone)]
pub(crate) enum AnySigner {
    PrivateKey(PrivateKey),
    // public key is 216 bytes.
    // Here be a story of dragons.
    // Once an engineer attempted to downgrade this `Arc` to a mere `Box`, alas it was not meant to be.
    // For the Fn must be cloned, and `dyn Fn` must not.
    // The plan to not pay the price of Arc was doomed from the very beginning.
    // Attempts to avoid the arc, the cloning of the `Fn`, all end in misery,
    // for the `Client` must have `AnySigner`, not a `PrivateKey`, and the `ContractCreateFlow`...
    // Well, it must be executable multiple times, for ownership reasons.
    // lint note: can't reasonably resolve this because putting the `type` on anything but the `Fn(..)` part is useless
    // but we can't do that because trait aliases don't exist.
    #[allow(clippy::type_complexity)]
    Arbitrary(Box<PublicKey>, Arc<dyn Fn(&[u8]) -> Vec<u8> + Send + Sync>),
}

impl AnySigner {
    pub(crate) fn arbitrary<F: Fn(&[u8]) -> Vec<u8> + Send + Sync + 'static>(
        public_key: Box<PublicKey>,
        signer: F,
    ) -> Self {
        Self::Arbitrary(
            public_key,
            Arc::new(signer).unsize(Coercion!(to dyn Fn(&[u8]) -> Vec<u8> + Send + Sync)),
        )
    }
}

impl fmt::Debug for AnySigner {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::PrivateKey(_) => f.debug_tuple("PrivateKey").field(&"..").finish(),
            Self::Arbitrary(arg0, _) => {
                f.debug_tuple("Arbitrary").field(arg0).field(&"Fn").finish()
            }
        }
    }
}

impl AnySigner {
    // *Cheap* Accessor to get the public key without signing the message first.
    pub(crate) fn public_key(&self) -> PublicKey {
        match self {
            AnySigner::PrivateKey(it) => it.public_key(),
            AnySigner::Arbitrary(it, _) => **it,
        }
    }

    pub(crate) fn sign(&self, message: &[u8]) -> (PublicKey, Vec<u8>) {
        match self {
            AnySigner::PrivateKey(it) => (it.public_key(), it.sign(message)),
            AnySigner::Arbitrary(public, signer) => {
                let bytes = signer(message);

                (**public, bytes)
            }
        }
    }
}
// Filename: src/staked_id.rs
use crate::{
    AccountId,
    ValidateChecksums,
};

// no rename all, because each field is renamed.
// can't do boxing because `Copy`.
#[allow(clippy::large_enum_variant)]
#[derive(Clone, Debug, Copy, PartialEq, Eq)]
pub(crate) enum StakedId {
    AccountId(AccountId),
    NodeId(u64),
}

impl StakedId {
    pub(crate) fn to_account_id(self) -> Option<AccountId> {
        match self {
            StakedId::AccountId(it) => Some(it),
            StakedId::NodeId(_) => None,
        }
    }

    pub(crate) fn to_node_id(self) -> Option<u64> {
        match self {
            StakedId::NodeId(it) => Some(it),
            StakedId::AccountId(_) => None,
        }
    }
}

impl ValidateChecksums for StakedId {
    fn validate_checksums(
        &self,
        ledger_id: &crate::ledger_id::RefLedgerId,
    ) -> Result<(), crate::Error> {
        self.to_account_id().validate_checksums(ledger_id)
    }
}

impl From<AccountId> for StakedId {
    fn from(v: AccountId) -> Self {
        Self::AccountId(v)
    }
}

impl From<u64> for StakedId {
    fn from(v: u64) -> Self {
        Self::NodeId(v)
    }
}

mod proto {
    use hedera_proto::services;

    use super::StakedId;
    use crate::FromProtobuf;

    macro_rules! impl_from_pb {
        ($ty:ty) => {
            impl FromProtobuf<$ty> for StakedId {
                fn from_protobuf(value: $ty) -> crate::Result<Self> {
                    type PbStakedId = $ty;
                    match value {
                        PbStakedId::StakedAccountId(value) => {
                            Ok(Self::AccountId(FromProtobuf::from_protobuf(value)?))
                        }
                        PbStakedId::StakedNodeId(value) => Ok(Self::NodeId(value as u64)),
                    }
                }
            }
        };
    }

    impl_from_pb!(services::contract_create_transaction_body::StakedId);
    impl_from_pb!(services::contract_update_transaction_body::StakedId);
    impl_from_pb!(services::crypto_create_transaction_body::StakedId);
    impl_from_pb!(services::crypto_update_transaction_body::StakedId);
}
// Filename: src/staking_info.rs
use hedera_proto::services;
use time::OffsetDateTime;

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    FromProtobuf,
    Hbar,
};

// todo(sr): is this right?
/// Info related to account/contract staking settings.
#[derive(Debug, Clone)]
pub struct StakingInfo {
    /// If `true`, the contract declines receiving a staking reward. The default value is `false`.
    pub decline_staking_reward: bool,

    /// The staking period during which either the staking settings for this account or contract changed (such as starting
    /// staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
    /// is not currently staked to a node, then this field is not set.
    pub stake_period_start: Option<OffsetDateTime>,

    /// The amount in `Hbar` that will be received in the next reward situation.
    pub pending_reward: Hbar,

    /// The total of balance of all accounts staked to this account or contract.
    pub staked_to_me: Hbar,

    /// The account to which this account or contract is staking.
    pub staked_account_id: Option<AccountId>,

    /// The ID of the node this account or contract is staked to.
    pub staked_node_id: Option<u64>,
}

impl StakingInfo {
    /// Create a new `StakingInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::StakingInfo> for StakingInfo {
    fn from_protobuf(pb: services::StakingInfo) -> crate::Result<Self> {
        let (staked_account_id, staked_node_id) = match pb.staked_id {
            Some(services::staking_info::StakedId::StakedAccountId(id)) => {
                (Some(AccountId::from_protobuf(id)?), None)
            }

            Some(services::staking_info::StakedId::StakedNodeId(id)) => (None, Some(id as u64)),

            None => (None, None),
        };

        Ok(Self {
            decline_staking_reward: pb.decline_reward,
            stake_period_start: pb.stake_period_start.map(Into::into),
            pending_reward: Hbar::from_tinybars(pb.pending_reward),
            staked_to_me: Hbar::from_tinybars(pb.staked_to_me),
            staked_account_id,
            staked_node_id,
        })
    }
}

impl ToProtobuf for StakingInfo {
    type Protobuf = services::StakingInfo;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::StakingInfo {
            decline_reward: self.decline_staking_reward,
            stake_period_start: self.stake_period_start.map(Into::into),
            pending_reward: self.pending_reward.to_tinybars(),
            staked_to_me: self.staked_to_me.to_tinybars(),
            staked_id: self
                .staked_node_id
                .map(|it| it as i64)
                .map(services::staking_info::StakedId::StakedNodeId)
                .or_else(|| {
                    self.staked_account_id
                        .to_protobuf()
                        .map(services::staking_info::StakedId::StakedAccountId)
                }),
        }
    }
}
// Filename: src/system/freeze_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::freeze_service_client::FreezeServiceClient;
use time::OffsetDateTime;
use tonic::transport::Channel;

use crate::protobuf::FromProtobuf;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    FileId,
    FreezeType,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

/// Sets the freezing period in which the platform will stop creating
/// events and accepting transactions.
///
/// This is used before safely shut down the platform for maintenance.
///
pub type FreezeTransaction = Transaction<FreezeTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct FreezeTransactionData {
    start_time: Option<OffsetDateTime>,
    file_id: Option<FileId>,
    file_hash: Option<Vec<u8>>,
    freeze_type: FreezeType,
}

impl FreezeTransaction {
    /// Returns the start time.
    #[must_use]
    pub fn get_start_time(&self) -> Option<OffsetDateTime> {
        self.data().start_time
    }

    /// Sets the start time.
    pub fn start_time(&mut self, time: OffsetDateTime) -> &mut Self {
        self.data_mut().start_time = Some(time);
        self
    }

    /// Returns the freeze type.
    #[must_use]
    pub fn get_freeze_type(&self) -> FreezeType {
        self.data().freeze_type
    }

    /// Sets the freeze type.
    pub fn freeze_type(&mut self, ty: FreezeType) -> &mut Self {
        self.data_mut().freeze_type = ty;
        self
    }

    /// Returns the file ID.
    #[must_use]
    pub fn get_file_id(&self) -> Option<FileId> {
        self.data().file_id
    }

    /// Sets the file ID.
    pub fn file_id(&mut self, id: FileId) -> &mut Self {
        self.data_mut().file_id = Some(id);
        self
    }

    /// Returns the file hash.
    #[must_use]
    pub fn get_file_hash(&self) -> Option<&[u8]> {
        self.data().file_hash.as_deref()
    }

    /// Sets the file hash.
    pub fn file_hash(&mut self, hash: Vec<u8>) -> &mut Self {
        self.data_mut().file_hash = Some(hash);
        self
    }
}

impl TransactionData for FreezeTransactionData {}

impl TransactionExecute for FreezeTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { FreezeServiceClient::new(channel).freeze(request).await })
    }
}

impl ValidateChecksums for FreezeTransactionData {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        self.file_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for FreezeTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::Freeze(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for FreezeTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::Freeze(self.to_protobuf())
    }
}

impl From<FreezeTransactionData> for AnyTransactionData {
    fn from(transaction: FreezeTransactionData) -> Self {
        Self::Freeze(transaction)
    }
}

impl FromProtobuf<services::FreezeTransactionBody> for FreezeTransactionData {
    fn from_protobuf(pb: services::FreezeTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            start_time: pb.start_time.map(Into::into),
            file_id: Option::from_protobuf(pb.update_file)?,
            file_hash: Some(pb.file_hash),
            freeze_type: FreezeType::from(pb.freeze_type),
        })
    }
}

impl ToProtobuf for FreezeTransactionData {
    type Protobuf = services::FreezeTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::FreezeTransactionBody {
            update_file: self.file_id.to_protobuf(),
            file_hash: self.file_hash.clone().unwrap_or_default(),
            start_time: self.start_time.map(Into::into),
            freeze_type: self.freeze_type as _,
            ..Default::default()
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use hex_literal::hex;
    use time::OffsetDateTime;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::system::FreezeTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        VALID_START,
    };
    use crate::{
        AnyTransaction,
        FileId,
        FreezeTransaction,
        FreezeType,
    };

    const FILE_ID: FileId = FileId::new(4, 5, 6);
    const FILE_HASH: [u8; 14] = hex!("1723904587120938954702349857");
    const START_TIME: OffsetDateTime = VALID_START;
    const FREEZE_TYPE: FreezeType = FreezeType::FreezeAbort;

    fn make_transaction() -> FreezeTransaction {
        let mut tx = FreezeTransaction::new_for_tests();

        tx.file_id(FILE_ID)
            .file_hash(FILE_HASH.to_vec())
            .start_time(START_TIME)
            .freeze_type(FREEZE_TYPE)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            Freeze(
                FreezeTransactionBody {
                    start_hour: 0,
                    start_min: 0,
                    end_hour: 0,
                    end_min: 0,
                    update_file: Some(
                        FileId {
                            shard_num: 4,
                            realm_num: 5,
                            file_num: 6,
                        },
                    ),
                    file_hash: [
                        23,
                        35,
                        144,
                        69,
                        135,
                        18,
                        9,
                        56,
                        149,
                        71,
                        2,
                        52,
                        152,
                        87,
                    ],
                    start_time: Some(
                        Timestamp {
                            seconds: 1554158542,
                            nanos: 0,
                        },
                    ),
                    freeze_type: FreezeAbort,
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::FreezeTransactionBody {
            update_file: Some(FILE_ID.to_protobuf()),
            file_hash: FILE_HASH.to_vec(),
            start_time: Some(START_TIME.to_protobuf()),
            freeze_type: FREEZE_TYPE as i32,
            ..Default::default()
        };

        let tx = FreezeTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.file_id, Some(FILE_ID));
        assert_eq!(tx.file_hash.as_deref(), Some(FILE_HASH.as_slice()));
        assert_eq!(tx.start_time, Some(START_TIME));
        assert_eq!(tx.freeze_type, FREEZE_TYPE);
    }

    mod get_set {
        use super::*;

        #[test]
        fn file_id() {
            let mut tx = FreezeTransaction::new();
            tx.file_id(FILE_ID);

            assert_eq!(tx.get_file_id(), Some(FILE_ID));
        }

        #[test]
        #[should_panic]
        fn file_id_frozen_panics() {
            make_transaction().file_id(FILE_ID);
        }

        #[test]
        fn file_hash() {
            let mut tx = FreezeTransaction::new();
            tx.file_hash(FILE_HASH.to_vec());

            assert_eq!(tx.get_file_hash(), Some(FILE_HASH.as_slice()));
        }

        #[test]
        #[should_panic]
        fn file_hash_frozen_panics() {
            make_transaction().file_hash(FILE_HASH.to_vec());
        }

        #[test]
        fn start_time() {
            let mut tx = FreezeTransaction::new();
            tx.start_time(START_TIME);

            assert_eq!(tx.get_start_time(), Some(START_TIME));
        }

        #[test]
        #[should_panic]
        fn start_time_frozen_panics() {
            make_transaction().start_time(START_TIME);
        }

        #[test]
        fn freeze_type() {
            let mut tx = FreezeTransaction::new();
            tx.freeze_type(FREEZE_TYPE);

            assert_eq!(tx.get_freeze_type(), FREEZE_TYPE);
        }

        #[test]
        #[should_panic]
        fn freeze_type_frozen_panics() {
            make_transaction().freeze_type(FREEZE_TYPE);
        }
    }
}
// Filename: src/system/freeze_type.rs
// SPDX-License-Identifier: Apache-2.0

// todo(sr): Not happy with this doc.
/// What type of freeze should be executed?
#[derive(Default, Debug, Hash, PartialEq, Eq, Clone, Copy)]
pub enum FreezeType {
    /// An (invalid) default value for this enum, to ensure the client explicitly sets
    /// the intended type of freeze transaction.
    #[default]
    Unknown = 0,

    /// Freezes the network at the specified time. The start_time field must be provided and
    /// must reference a future time. Any values specified for the update_file and file_hash
    /// fields will be ignored. This transaction does not perform any network changes or
    /// upgrades and requires manual intervention to restart the network.
    FreezeOnly = 1,

    /// A non-freezing operation that initiates network wide preparation in advance of a
    /// scheduled freeze upgrade. The update_file and file_hash fields must be provided and
    /// valid. The start_time field may be omitted and any value present will be ignored.
    PrepareUpgrade = 2,

    /// Freezes the network at the specified time and performs the previously prepared
    /// automatic upgrade across the entire network.
    FreezeUpgrade = 3,

    /// Aborts a pending network freeze operation.
    FreezeAbort = 4,

    /// Performs an immediate upgrade on auxilary services and containers providing
    /// telemetry/metrics. Does not impact network operations.
    TelemetryUpgrade = 5,
}

impl From<i32> for FreezeType {
    fn from(value: i32) -> Self {
        match value {
            1 => Self::FreezeOnly,
            2 => Self::PrepareUpgrade,
            3 => Self::FreezeUpgrade,
            4 => Self::FreezeAbort,
            5 => Self::TelemetryUpgrade,
            ..=0 | 6.. => Self::Unknown,
        }
    }
}
// Filename: src/system/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod freeze_transaction;
mod freeze_type;
mod system_delete_transaction;
mod system_undelete_transaction;

pub use freeze_transaction::FreezeTransaction;
pub(crate) use freeze_transaction::FreezeTransactionData;
pub use freeze_type::FreezeType;
pub use system_delete_transaction::SystemDeleteTransaction;
pub(crate) use system_delete_transaction::SystemDeleteTransactionData;
pub use system_undelete_transaction::SystemUndeleteTransaction;
pub(crate) use system_undelete_transaction::SystemUndeleteTransactionData;
// Filename: src/system/system_delete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::file_service_client::FileServiceClient;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use time::OffsetDateTime;
use tonic::transport::Channel;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    ContractId,
    Error,
    FileId,
    Transaction,
    ValidateChecksums,
};

/// Delete a file or smart contract - can only be done by a Hiero admin.
pub type SystemDeleteTransaction = Transaction<SystemDeleteTransactionData>;

/// Delete a file or smart contract - can only be done by a Hiero admin.
///
/// When it is deleted, it immediately disappears from the system as seen by the user,
/// but is still stored internally until the expiration time, at which time it
/// is truly and permanently deleted.
///
/// Until that time, it can be undeleted by the Hiero admin.
/// When a smart contract is deleted, the cryptocurrency account within it continues
/// to exist, and is not affected by the expiration time here.
///

#[derive(Debug, Clone, Default)]
pub struct SystemDeleteTransactionData {
    expiration_time: Option<OffsetDateTime>,
    file_id: Option<FileId>,
    contract_id: Option<ContractId>,
}

impl SystemDeleteTransaction {
    /// Returns the contract ID which should be deleted.
    #[must_use]
    pub fn get_contract_id(&self) -> Option<ContractId> {
        self.data().contract_id
    }

    /// Sets the contract ID which should be deleted.
    pub fn contract_id(&mut self, id: impl Into<ContractId>) -> &mut Self {
        let data = self.data_mut();
        data.file_id = None;
        data.contract_id = Some(id.into());
        self
    }

    /// Returns the file ID which should be deleted.
    #[must_use]
    pub fn get_file_id(&self) -> Option<FileId> {
        self.data().file_id
    }

    /// Sets the file ID which should be deleted.
    pub fn file_id(&mut self, id: impl Into<FileId>) -> &mut Self {
        let data = self.data_mut();
        data.contract_id = None;
        data.file_id = Some(id.into());
        self
    }

    /// Returns the timestamp at which the "deleted" entity should
    /// truly be permanently deleted.
    #[must_use]
    pub fn get_expiration_time(&self) -> Option<OffsetDateTime> {
        self.data().expiration_time
    }

    /// Sets the timestamp at which the "deleted" file should
    /// truly be permanently deleted.
    pub fn expiration_time(&mut self, expiration_time: OffsetDateTime) -> &mut Self {
        self.data_mut().expiration_time = Some(expiration_time);
        self
    }
}

impl TransactionData for SystemDeleteTransactionData {}

impl TransactionExecute for SystemDeleteTransactionData {
    #[allow(deprecated)]
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async move {
            if self.file_id.is_some() {
                FileServiceClient::new(channel).system_delete(request).await
            } else {
                SmartContractServiceClient::new(channel).system_delete(request).await
            }
        })
    }
}

impl ValidateChecksums for SystemDeleteTransactionData {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        self.file_id.validate_checksums(ledger_id)?;
        self.contract_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for SystemDeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::SystemDelete(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for SystemDeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::SystemDelete(self.to_protobuf())
    }
}

impl From<SystemDeleteTransactionData> for AnyTransactionData {
    fn from(transaction: SystemDeleteTransactionData) -> Self {
        Self::SystemDelete(transaction)
    }
}

impl FromProtobuf<services::SystemDeleteTransactionBody> for SystemDeleteTransactionData {
    fn from_protobuf(pb: services::SystemDeleteTransactionBody) -> crate::Result<Self> {
        use services::system_delete_transaction_body::Id;
        let (file_id, contract_id) = match pb.id {
            Some(Id::FileId(it)) => (Some(FileId::from_protobuf(it)?), None),
            Some(Id::ContractId(it)) => (None, Some(ContractId::from_protobuf(it)?)),
            None => (None, None),
        };

        Ok(Self { file_id, contract_id, expiration_time: pb.expiration_time.map(Into::into) })
    }
}

impl ToProtobuf for SystemDeleteTransactionData {
    type Protobuf = services::SystemDeleteTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let expiration_time = self.expiration_time.map(Into::into);
        let contract_id = self.contract_id.to_protobuf();
        let file_id = self.file_id.to_protobuf();

        let id = match (contract_id, file_id) {
            (Some(contract_id), _) => {
                Some(services::system_delete_transaction_body::Id::ContractId(contract_id))
            }

            (_, Some(file_id)) => {
                Some(services::system_delete_transaction_body::Id::FileId(file_id))
            }

            _ => None,
        };

        services::SystemDeleteTransactionBody { expiration_time, id }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::system::SystemDeleteTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        VALID_START,
    };
    use crate::{
        AnyTransaction,
        ContractId,
        FileId,
        SystemDeleteTransaction,
    };

    const FILE_ID: FileId = FileId::new(0, 0, 444);
    const CONTRACT_ID: ContractId = ContractId::new(0, 0, 444);

    fn make_transaction_file() -> SystemDeleteTransaction {
        let mut tx = SystemDeleteTransaction::new_for_tests();

        tx.file_id(FILE_ID).expiration_time(VALID_START).freeze().unwrap();
        tx
    }

    fn make_transaction_contract() -> SystemDeleteTransaction {
        let mut tx = SystemDeleteTransaction::new_for_tests();

        tx.contract_id(CONTRACT_ID).expiration_time(VALID_START).freeze().unwrap();
        tx
    }

    #[test]
    fn serialize_file() {
        let tx = make_transaction_file();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            SystemDelete(
                SystemDeleteTransactionBody {
                    expiration_time: Some(
                        TimestampSeconds {
                            seconds: 1554158542,
                        },
                    ),
                    id: Some(
                        FileId(
                            FileId {
                                shard_num: 0,
                                realm_num: 0,
                                file_num: 444,
                            },
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn serialize_contract() {
        let tx = make_transaction_contract();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            SystemDelete(
                SystemDeleteTransactionBody {
                    expiration_time: Some(
                        TimestampSeconds {
                            seconds: 1554158542,
                        },
                    ),
                    id: Some(
                        ContractId(
                            ContractId {
                                shard_num: 0,
                                realm_num: 0,
                                contract: Some(
                                    ContractNum(
                                        444,
                                    ),
                                ),
                            },
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes_file() {
        let tx = make_transaction_file();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn to_from_bytes_contract() {
        let tx = make_transaction_contract();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::SystemDeleteTransactionBody {
            expiration_time: Some(services::TimestampSeconds {
                seconds: VALID_START.unix_timestamp(),
            }),
            id: Some(services::system_delete_transaction_body::Id::FileId(FILE_ID.to_protobuf())),
        };

        let tx = SystemDeleteTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.file_id, Some(FILE_ID));
        assert_eq!(tx.contract_id, None);
        assert_eq!(tx.expiration_time, Some(VALID_START));
    }

    #[test]
    fn get_set_file_id() {
        let mut tx = SystemDeleteTransaction::new();
        tx.file_id(FILE_ID);

        assert_eq!(tx.get_file_id(), Some(FILE_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_file_id_frozen_panics() {
        make_transaction_file().file_id(FILE_ID);
    }

    #[test]
    fn get_set_contract_id() {
        let mut tx = SystemDeleteTransaction::new();
        tx.contract_id(CONTRACT_ID);

        assert_eq!(tx.get_contract_id(), Some(CONTRACT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_contract_id_frozen_panics() {
        make_transaction_file().contract_id(CONTRACT_ID);
    }

    #[test]
    fn get_set_expiration_time() {
        let mut tx = SystemDeleteTransaction::new();
        tx.expiration_time(VALID_START);

        assert_eq!(tx.get_expiration_time(), Some(VALID_START));
    }

    #[test]
    #[should_panic]
    fn get_set_expiration_time_frozen_panics() {
        make_transaction_file().expiration_time(VALID_START);
    }
}
// Filename: src/system/system_undelete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::file_service_client::FileServiceClient;
use hedera_proto::services::smart_contract_service_client::SmartContractServiceClient;
use tonic::transport::Channel;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    ContractId,
    Error,
    FileId,
    Transaction,
    ValidateChecksums,
};

/// Undelete a file or smart contract that was deleted by a [`SystemUndeleteTransaction`](crate::SystemUndeleteTransaction).
pub type SystemUndeleteTransaction = Transaction<SystemUndeleteTransactionData>;

/// Undelete a file or smart contract that was deleted by  [`SystemUndeleteTransaction`](crate::SystemUndeleteTransaction).
#[derive(Debug, Clone, Default)]
pub struct SystemUndeleteTransactionData {
    file_id: Option<FileId>,
    contract_id: Option<ContractId>,
}

impl SystemUndeleteTransaction {
    /// Returns the contract ID to undelete.
    #[must_use]
    pub fn get_contract_id(&self) -> Option<ContractId> {
        self.data().contract_id
    }

    /// Sets the contract ID to undelete.
    pub fn contract_id(&mut self, id: impl Into<ContractId>) -> &mut Self {
        let data = self.data_mut();
        data.file_id = None;
        data.contract_id = Some(id.into());
        self
    }

    /// Returns the file ID to undelete.
    #[must_use]
    pub fn get_file_id(&self) -> Option<FileId> {
        self.data().file_id
    }

    /// Sets the file ID to undelete.
    pub fn file_id(&mut self, id: impl Into<FileId>) -> &mut Self {
        let data = self.data_mut();
        data.contract_id = None;
        data.file_id = Some(id.into());
        self
    }
}

impl TransactionData for SystemUndeleteTransactionData {}

impl TransactionExecute for SystemUndeleteTransactionData {
    #[allow(deprecated)]
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async move {
            if self.file_id.is_some() {
                FileServiceClient::new(channel).system_undelete(request).await
            } else {
                SmartContractServiceClient::new(channel).system_undelete(request).await
            }
        })
    }
}

impl ValidateChecksums for SystemUndeleteTransactionData {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        self.contract_id.validate_checksums(ledger_id)?;
        self.file_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for SystemUndeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::SystemUndelete(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for SystemUndeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::SystemUndelete(self.to_protobuf())
    }
}

impl From<SystemUndeleteTransactionData> for AnyTransactionData {
    fn from(transaction: SystemUndeleteTransactionData) -> Self {
        Self::SystemUndelete(transaction)
    }
}

impl FromProtobuf<services::SystemUndeleteTransactionBody> for SystemUndeleteTransactionData {
    fn from_protobuf(pb: services::SystemUndeleteTransactionBody) -> crate::Result<Self> {
        use services::system_undelete_transaction_body::Id;
        let (file_id, contract_id) = match pb.id {
            Some(Id::FileId(it)) => (Some(FileId::from_protobuf(it)?), None),
            Some(Id::ContractId(it)) => (None, Some(ContractId::from_protobuf(it)?)),
            None => (None, None),
        };

        Ok(Self { file_id, contract_id })
    }
}

impl ToProtobuf for SystemUndeleteTransactionData {
    type Protobuf = services::SystemUndeleteTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let contract_id = self.contract_id.to_protobuf();
        let file_id = self.file_id.to_protobuf();

        let id = match (contract_id, file_id) {
            (Some(contract_id), _) => {
                Some(services::system_undelete_transaction_body::Id::ContractId(contract_id))
            }

            (_, Some(file_id)) => {
                Some(services::system_undelete_transaction_body::Id::FileId(file_id))
            }

            _ => None,
        };
        services::SystemUndeleteTransactionBody { id }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::system::SystemUndeleteTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        ContractId,
        FileId,
        SystemUndeleteTransaction,
    };

    const FILE_ID: FileId = FileId::new(0, 0, 444);
    const CONTRACT_ID: ContractId = ContractId::new(0, 0, 444);

    fn make_transaction_file() -> SystemUndeleteTransaction {
        let mut tx = SystemUndeleteTransaction::new_for_tests();

        tx.file_id(FILE_ID).freeze().unwrap();
        tx
    }

    fn make_transaction_contract() -> SystemUndeleteTransaction {
        let mut tx = SystemUndeleteTransaction::new_for_tests();

        tx.contract_id(CONTRACT_ID).freeze().unwrap();
        tx
    }

    #[test]
    fn serialize_file() {
        let tx = make_transaction_file();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            SystemUndelete(
                SystemUndeleteTransactionBody {
                    id: Some(
                        FileId(
                            FileId {
                                shard_num: 0,
                                realm_num: 0,
                                file_num: 444,
                            },
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn serialize_contract() {
        let tx = make_transaction_contract();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            SystemUndelete(
                SystemUndeleteTransactionBody {
                    id: Some(
                        ContractId(
                            ContractId {
                                shard_num: 0,
                                realm_num: 0,
                                contract: Some(
                                    ContractNum(
                                        444,
                                    ),
                                ),
                            },
                        ),
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes_file() {
        let tx = make_transaction_file();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn to_from_bytes_contract() {
        let tx = make_transaction_contract();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::SystemUndeleteTransactionBody {
            id: Some(services::system_undelete_transaction_body::Id::FileId(FILE_ID.to_protobuf())),
        };

        let tx = SystemUndeleteTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.file_id, Some(FILE_ID));
        assert_eq!(tx.contract_id, None);
    }

    #[test]
    fn get_set_file_id() {
        let mut tx = SystemUndeleteTransaction::new();
        tx.file_id(FILE_ID);

        assert_eq!(tx.get_file_id(), Some(FILE_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_file_id_frozen_panics() {
        make_transaction_file().file_id(FILE_ID);
    }

    #[test]
    fn get_set_contract_id() {
        let mut tx = SystemUndeleteTransaction::new();
        tx.contract_id(CONTRACT_ID);

        assert_eq!(tx.get_contract_id(), Some(CONTRACT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_contract_id_frozen_panics() {
        make_transaction_file().contract_id(CONTRACT_ID);
    }
}
// Filename: src/token/assessed_custom_fee.rs
use hedera_proto::services;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::{
    AccountId,
    TokenId,
};

/// A custom transfer fee that was assessed during the handling of a `CryptoTransfer`.
#[derive(Debug, Eq, PartialEq, Clone)]
pub struct AssessedCustomFee {
    /// The amount of currency charged to each payer.
    pub amount: i64,

    /// The currency `amount` is charged in, if `None` the fee is in HBar.
    pub token_id: Option<TokenId>,

    /// The account that receives the fees that were charged.
    pub fee_collector_account_id: Option<AccountId>,

    /// A list of all accounts that were charged this fee.
    pub payer_account_id_list: Vec<AccountId>,
}

impl AssessedCustomFee {
    /// Create a new `AssessedCustomFee` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::AssessedCustomFee> for AssessedCustomFee {
    fn from_protobuf(pb: services::AssessedCustomFee) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Ok(Self {
            amount: pb.amount,
            token_id: Option::from_protobuf(pb.token_id)?,
            fee_collector_account_id: Option::from_protobuf(pb.fee_collector_account_id)?,
            payer_account_id_list: Vec::from_protobuf(pb.effective_payer_account_id)?,
        })
    }
}

impl ToProtobuf for AssessedCustomFee {
    type Protobuf = services::AssessedCustomFee;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::AssessedCustomFee {
            amount: self.amount,
            token_id: self.token_id.to_protobuf(),
            fee_collector_account_id: self.fee_collector_account_id.to_protobuf(),
            effective_payer_account_id: self.payer_account_id_list.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::{
        AccountId,
        AssessedCustomFee,
        TokenId,
    };

    const AMOUNT: i64 = 1;
    const TOKEN_ID: TokenId = TokenId { shard: 2, realm: 3, num: 4, checksum: None };
    const FEE_COLLECTOR: AccountId =
        AccountId { shard: 5, realm: 6, num: 7, alias: None, evm_address: None, checksum: None };

    const PAYER_ACCOUNT_IDS: [AccountId; 3] = [
        AccountId { shard: 8, realm: 9, num: 10, alias: None, evm_address: None, checksum: None },
        AccountId { shard: 11, realm: 12, num: 13, alias: None, evm_address: None, checksum: None },
        AccountId { shard: 14, realm: 15, num: 16, alias: None, evm_address: None, checksum: None },
    ];

    fn make_fee_proto() -> services::AssessedCustomFee {
        services::AssessedCustomFee {
            amount: AMOUNT,
            token_id: Some(TOKEN_ID.to_protobuf()),
            fee_collector_account_id: Some(FEE_COLLECTOR.to_protobuf()),
            effective_payer_account_id: PAYER_ACCOUNT_IDS
                .iter()
                .map(AccountId::to_protobuf)
                .collect(),
        }
    }

    fn make_fee() -> AssessedCustomFee {
        AssessedCustomFee {
            amount: 201,
            token_id: Some(TokenId::new(1, 2, 3)),
            fee_collector_account_id: Some(AccountId {
                shard: 4,
                realm: 5,
                num: 6,
                alias: None,
                evm_address: None,
                checksum: None,
            }),
            payer_account_id_list: Vec::from([
                AccountId {
                    shard: 0,
                    realm: 0,
                    num: 1,
                    alias: None,
                    evm_address: None,
                    checksum: None,
                },
                AccountId {
                    shard: 0,
                    realm: 0,
                    num: 2,
                    alias: None,
                    evm_address: None,
                    checksum: None,
                },
                AccountId {
                    shard: 0,
                    realm: 0,
                    num: 3,
                    alias: None,
                    evm_address: None,
                    checksum: None,
                },
            ]),
        }
    }

    #[test]
    fn should_serialize() {
        let original_assessed_custom_fee = make_fee();
        let assessed_custom_fee_bytes = original_assessed_custom_fee.to_bytes();
        let copy_assessed_custom_fee =
            AssessedCustomFee::from_bytes(&assessed_custom_fee_bytes).unwrap();

        assert_eq!(original_assessed_custom_fee, copy_assessed_custom_fee);

        expect![[r#"
            AssessedCustomFee {
                amount: 201,
                token_id: Some(
                    "1.2.3",
                ),
                fee_collector_account_id: Some(
                    "4.5.6",
                ),
                payer_account_id_list: [
                    "0.0.1",
                    "0.0.2",
                    "0.0.3",
                ],
            }
        "#]]
        .assert_debug_eq(&original_assessed_custom_fee);
    }

    #[test]
    fn from_protobuf() {
        expect![[r#"
            AssessedCustomFee {
                amount: 1,
                token_id: Some(
                    "2.3.4",
                ),
                fee_collector_account_id: Some(
                    "5.6.7",
                ),
                payer_account_id_list: [
                    "8.9.10",
                    "11.12.13",
                    "14.15.16",
                ],
            }
        "#]]
        .assert_debug_eq(&AssessedCustomFee::from_protobuf(make_fee_proto()).unwrap());
    }

    #[test]
    fn to_protobuf() {
        expect![[r#"
            AssessedCustomFee {
                amount: 1,
                token_id: Some(
                    TokenId {
                        shard_num: 2,
                        realm_num: 3,
                        token_num: 4,
                    },
                ),
                fee_collector_account_id: Some(
                    AccountId {
                        shard_num: 5,
                        realm_num: 6,
                        account: Some(
                            AccountNum(
                                7,
                            ),
                        ),
                    },
                ),
                effective_payer_account_id: [
                    AccountId {
                        shard_num: 8,
                        realm_num: 9,
                        account: Some(
                            AccountNum(
                                10,
                            ),
                        ),
                    },
                    AccountId {
                        shard_num: 11,
                        realm_num: 12,
                        account: Some(
                            AccountNum(
                                13,
                            ),
                        ),
                    },
                    AccountId {
                        shard_num: 14,
                        realm_num: 15,
                        account: Some(
                            AccountNum(
                                16,
                            ),
                        ),
                    },
                ],
            }
        "#]]
        .assert_debug_eq(
            &AssessedCustomFee::from_protobuf(make_fee_proto()).unwrap().to_protobuf(),
        );
    }

    #[test]
    fn should_bytes() {
        let assessed_custom_fee = make_fee();
        assert_eq!(
            assessed_custom_fee,
            AssessedCustomFee::from_bytes(&assessed_custom_fee.to_bytes()).unwrap()
        );
    }
}
// Filename: src/token/custom_fees/mod.rs
// SPDX-License-Identifier: Apache-2.0

use fraction::Fraction;
use hedera_proto::services;

use crate::{
    AccountId,
    FromProtobuf,
    Hbar,
    ToProtobuf,
    TokenId,
};

#[cfg(test)]
mod tests;

/// Any `CustomFee`.
///
/// See the documentation for [`CustomFee`] and [`Fee`].
pub type AnyCustomFee = CustomFee<Fee>;

/// A `FixedCustomFee`.
///
/// See the documentation for [`CustomFee`] and [`FixedFeeData`].
pub type FixedFee = CustomFee<FixedFeeData>;

/// A fractional `CustomFee`.
///
/// See the documentation for [`CustomFee`] and [`FractionalFeeData`].
pub type FractionalFee = CustomFee<FractionalFeeData>;

/// A royalty `CustomFee`.
///
/// See the documentation for [`CustomFee`] and [`RoyaltyFeeData`].
pub type RoyaltyFee = CustomFee<RoyaltyFeeData>;

/// A transfer fee to assess during a `CryptoTransfer` that transfers units of the token to which the
/// fee is attached. A custom fee may be either fixed or fractional, and must specify a fee collector
/// account to receive the assessed fees. Only positive fees may be assessed.
#[derive(Debug, Hash, PartialEq, Eq, Clone)]
pub struct CustomFee<Fee> {
    /// The fee to be charged
    pub fee: Fee,

    /// The account to receive the custom fee.
    pub fee_collector_account_id: Option<AccountId>,

    /// If true, fee fcollectors are not charged this fee for transfers.
    pub all_collectors_are_exempt: bool,
}

impl AnyCustomFee {
    /// Create `AnyCustomFee` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::CustomFee> for AnyCustomFee {
    fn from_protobuf(pb: services::CustomFee) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let fee_collector_account_id = Option::from_protobuf(pb.fee_collector_account_id)?;
        let fee = pb_getf!(pb, fee)?;

        let fee: Fee = match fee {
            services::custom_fee::Fee::FixedFee(pb) => FixedFeeData::from_protobuf(pb)?.into(),
            services::custom_fee::Fee::FractionalFee(pb) => {
                FractionalFeeData::from_protobuf(pb)?.into()
            }

            services::custom_fee::Fee::RoyaltyFee(pb) => RoyaltyFeeData::from_protobuf(pb)?.into(),
        };

        Ok(Self {
            fee,
            fee_collector_account_id,
            all_collectors_are_exempt: pb.all_collectors_are_exempt,
        })
    }
}

impl ToProtobuf for AnyCustomFee {
    type Protobuf = services::CustomFee;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::CustomFee {
            fee_collector_account_id: self.fee_collector_account_id.to_protobuf(),
            fee: Some(self.fee.to_protobuf()),
            all_collectors_are_exempt: self.all_collectors_are_exempt,
        }
    }
}

impl From<FixedFee> for AnyCustomFee {
    fn from(v: FixedFee) -> Self {
        Self {
            fee: v.fee.into(),
            fee_collector_account_id: v.fee_collector_account_id,
            all_collectors_are_exempt: v.all_collectors_are_exempt,
        }
    }
}

impl From<FractionalFee> for AnyCustomFee {
    fn from(v: FractionalFee) -> Self {
        Self {
            fee: v.fee.into(),
            fee_collector_account_id: v.fee_collector_account_id,
            all_collectors_are_exempt: v.all_collectors_are_exempt,
        }
    }
}

impl From<RoyaltyFee> for AnyCustomFee {
    fn from(v: RoyaltyFee) -> Self {
        Self {
            fee: v.fee.into(),
            fee_collector_account_id: v.fee_collector_account_id,
            all_collectors_are_exempt: v.all_collectors_are_exempt,
        }
    }
}

/// Represents the possible fee types.
#[derive(Debug, Hash, PartialEq, Eq, Clone)]
pub enum Fee {
    /// A fee using a fixed amount.
    Fixed(FixedFeeData),

    /// A fee using a fraction of the amount sent.
    Fractional(FractionalFeeData),

    /// A royalty fee for NFT transfers.
    Royalty(RoyaltyFeeData),
}

impl FromProtobuf<services::custom_fee::Fee> for Fee {
    fn from_protobuf(pb: services::custom_fee::Fee) -> crate::Result<Self>
    where
        Self: Sized,
    {
        use services::custom_fee::Fee as ProtoFee;

        match pb {
            ProtoFee::FixedFee(it) => Ok(FixedFeeData::from_protobuf(it)?.into()),
            ProtoFee::FractionalFee(it) => Ok(FractionalFeeData::from_protobuf(it)?.into()),
            ProtoFee::RoyaltyFee(it) => Ok(RoyaltyFeeData::from_protobuf(it)?.into()),
        }
    }
}

impl ToProtobuf for Fee {
    type Protobuf = services::custom_fee::Fee;

    fn to_protobuf(&self) -> Self::Protobuf {
        use services::custom_fee::Fee as ProtoFee;
        match self {
            Self::Fixed(it) => ProtoFee::FixedFee(it.to_protobuf()),
            Self::Fractional(it) => ProtoFee::FractionalFee(it.to_protobuf()),
            Self::Royalty(it) => ProtoFee::RoyaltyFee(it.to_protobuf()),
        }
    }
}

impl From<FixedFeeData> for Fee {
    fn from(v: FixedFeeData) -> Self {
        Self::Fixed(v)
    }
}

impl From<FractionalFeeData> for Fee {
    fn from(v: FractionalFeeData) -> Self {
        Self::Fractional(v)
    }
}

impl From<RoyaltyFeeData> for Fee {
    fn from(v: RoyaltyFeeData) -> Self {
        Self::Royalty(v)
    }
}

/// A fixed number of units (hbar or token) to assess as a fee during a `CryptoTransfer` that transfers
/// units of the token to which this fixed fee is attached.
#[derive(Debug, Hash, PartialEq, Eq, Clone)]
pub struct FixedFeeData {
    /// The number of units to assess as a fee
    pub amount: i64,

    /// The denomination of the fee; taken as hbar if left unset and, in a TokenCreate, taken as the id
    /// of the newly created token if set to the sentinel value of 0.0.0
    pub denominating_token_id: Option<TokenId>,
}

impl FixedFeeData {
    /// Create a fixed fee of `amount` hbar.
    #[must_use]
    pub fn from_hbar(amount: Hbar) -> Self {
        Self { amount: amount.to_tinybars(), denominating_token_id: None }
    }

    /// Returns the cost of the fee, if the fee is in denominated in hbar.
    #[must_use]
    pub fn get_hbar(&self) -> Option<Hbar> {
        self.denominating_token_id.is_none().then(|| Hbar::from_tinybars(self.amount))
    }
}

impl FromProtobuf<services::FixedFee> for FixedFeeData {
    fn from_protobuf(pb: services::FixedFee) -> crate::Result<Self> {
        Ok(Self {
            amount: pb.amount,
            denominating_token_id: Option::from_protobuf(pb.denominating_token_id)?,
        })
    }
}

impl ToProtobuf for FixedFeeData {
    type Protobuf = services::FixedFee;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            amount: self.amount,
            denominating_token_id: self.denominating_token_id.to_protobuf(),
        }
    }
}

/// A fraction of the transferred units of a token to assess as a fee. The amount assessed will never
/// be less than the given `minimum_amount`, and never greater than the given `maximum_amount`.  The
/// denomination is always units of the token to which this fractional fee is attached.
#[derive(Debug, Hash, PartialEq, Eq, Clone)]
pub struct FractionalFeeData {
    /// The denominator of the fraction of transferred units to assess as a fee
    pub denominator: u64,

    /// The numerator of the fraction of transferred units to assess as a fee
    pub numerator: u64,

    /// The minimum amount to assess
    pub minimum_amount: i64,

    /// The maximum amount to assess (zero implies no maximum)
    pub maximum_amount: i64,

    /// If [`Exclusive`](FeeAssessmentMethod::Exclusive),
    /// assesses the fee to the sender,
    /// so the receiver gets the full amount from the token transfer list,
    /// and the sender is charged an additional fee;
    /// if [`Inclusive`](FeeAssessmentMethod::Inclusive), the receiver does NOT get
    /// the full amount,
    /// but only what is left over after paying the fractional fee.
    pub assessment_method: FeeAssessmentMethod,
}

impl FromProtobuf<services::FractionalFee> for FractionalFeeData {
    fn from_protobuf(pb: services::FractionalFee) -> crate::Result<Self> {
        let amount = pb.fractional_amount.map(Fraction::from).unwrap_or_default();
        Ok(Self {
            denominator: *amount.denom().unwrap(),
            numerator: *amount.numer().unwrap(),
            assessment_method: match pb.net_of_transfers {
                true => FeeAssessmentMethod::Exclusive,
                false => FeeAssessmentMethod::Inclusive,
            },
            maximum_amount: pb.maximum_amount,
            minimum_amount: pb.minimum_amount,
        })
    }
}

impl ToProtobuf for FractionalFeeData {
    type Protobuf = services::FractionalFee;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            fractional_amount: Some(Fraction::new(self.numerator, self.denominator).into()),
            minimum_amount: self.minimum_amount,
            maximum_amount: self.maximum_amount,
            net_of_transfers: matches!(self.assessment_method, FeeAssessmentMethod::Exclusive),
        }
    }
}

/// A fee to assess during a `CryptoTransfer` that changes ownership of an NFT. Defines the fraction of
/// the fungible value exchanged for an NFT that the ledger should collect as a royalty. ("Fungible
/// value" includes both  and units of fungible HTS tokens.) When the NFT sender does not receive
/// any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.
/// Royalty fees can only be added to tokens of type type `NON_FUNGIBLE_UNIQUE`.
#[derive(Debug, Hash, PartialEq, Eq, Clone)]
pub struct RoyaltyFeeData {
    /// The denominator of the fraction of fungible value exchanged for an NFT to collect as royalty
    pub denominator: u64,

    /// The numerator of the fraction of fungible value exchanged for an NFT to collect as royalty
    pub numerator: u64,

    /// If present, the fixed fee to assess to the NFT receiver when no fungible value is exchanged
    /// with the sender
    pub fallback_fee: Option<FixedFeeData>,
}

impl FromProtobuf<services::RoyaltyFee> for RoyaltyFeeData {
    fn from_protobuf(pb: services::RoyaltyFee) -> crate::Result<Self> {
        let amount = pb.exchange_value_fraction.unwrap_or_default();

        Ok(Self {
            denominator: amount.denominator as u64,
            numerator: amount.numerator as u64,
            fallback_fee: Option::from_protobuf(pb.fallback_fee)?,
        })
    }
}

impl ToProtobuf for RoyaltyFeeData {
    type Protobuf = services::RoyaltyFee;

    fn to_protobuf(&self) -> Self::Protobuf {
        Self::Protobuf {
            fallback_fee: self.fallback_fee.to_protobuf(),
            exchange_value_fraction: Some(services::Fraction {
                numerator: self.numerator as i64,
                denominator: self.denominator as i64,
            }),
        }
    }
}

/// Enum for the fee assessment method.
///
/// The terminology here (exclusive vs inclusive) is borrowed from tax assessment.
#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash)]
pub enum FeeAssessmentMethod {
    /// The recipient recieves the transfer amount, minus the fee.
    ///
    /// If Alice is paying Bob, and an `Inclusive` fractional fee is collected to be sent to Charlie,
    /// the amount Alice declares she will pay in the transfer transaction *includes* the fee amount.
    Inclusive,

    /// The recipient recieves the whole transfer amount, and an extra fee is charged to the sender.
    ///
    /// If Alice is paying Bob, and an `Exclusive` fractional fee is collected to be sent to Charlie,
    /// the amount Alice declares she will pay in the transfer transaction *does not include* the fee amount.
    Exclusive,
}
// Filename: src/token/custom_fees/tests.rs
use fraction::Fraction;
use hedera_proto::services;

use crate::token::custom_fees::{
    AnyCustomFee,
    CustomFee,
    Fee,
    FixedFeeData,
    FractionalFeeData,
    RoyaltyFeeData,
};
use crate::{
    AccountId,
    FromProtobuf,
    ToProtobuf,
    TokenId,
};

#[test]
fn custom_fee_can_convert_to_protobuf() -> anyhow::Result<()> {
    let custom_fee = AnyCustomFee {
        fee_collector_account_id: Some(AccountId::from(1)),
        fee: FixedFeeData { denominating_token_id: Some(TokenId::from(2)), amount: 1000 }.into(),
        all_collectors_are_exempt: true,
    };

    let custom_fee_proto = custom_fee.to_protobuf();

    assert_eq!(Some(custom_fee.fee.to_protobuf()), custom_fee_proto.fee);
    assert_eq!(
        custom_fee.fee_collector_account_id.to_protobuf(),
        custom_fee_proto.fee_collector_account_id
    );
    assert_eq!(custom_fee.all_collectors_are_exempt, custom_fee_proto.all_collectors_are_exempt);

    Ok(())
}

#[test]
fn custom_fixed_fee_can_be_created_from_protobuf() -> anyhow::Result<()> {
    let custom_fee_proto = services::CustomFee {
        fee: Some(services::custom_fee::Fee::FixedFee(services::FixedFee {
            denominating_token_id: Some(TokenId::from(2).to_protobuf()),
            amount: 1000,
        })),
        fee_collector_account_id: Some(AccountId::from(1).to_protobuf()),
        all_collectors_are_exempt: true,
    };

    let custom_fee = CustomFee::from_protobuf(custom_fee_proto.clone()).unwrap();

    assert_eq!(Some(custom_fee.fee.to_protobuf()), custom_fee_proto.fee);
    assert_eq!(
        custom_fee.fee_collector_account_id.to_protobuf(),
        custom_fee_proto.fee_collector_account_id
    );

    Ok(())
}

#[test]
fn fee_can_convert_to_protobuf() -> anyhow::Result<()> {
    let amount = 1000;
    let fee = Fee::Fixed(FixedFeeData { amount, denominating_token_id: Some(TokenId::from(1)) });

    let fee_proto = fee.to_protobuf();

    let fixed_fee_proto = match fee_proto {
        services::custom_fee::Fee::FixedFee(fixed_fee) => Some(fixed_fee),
        _ => None,
    };

    assert_eq!(fixed_fee_proto.unwrap().amount, amount);

    Ok(())
}

#[test]
fn fee_can_be_created_from_protobuf() -> anyhow::Result<()> {
    let amount = 1000;
    let fee_proto = services::custom_fee::Fee::FixedFee(services::FixedFee {
        denominating_token_id: Some(TokenId::from(2).to_protobuf()),
        amount,
    });

    let custom_fee = Fee::from_protobuf(fee_proto).unwrap();

    let fixed_fee = match custom_fee {
        Fee::Fixed(fixed_fee) => Some(fixed_fee),
        _ => None,
    };

    assert_eq!(fixed_fee.unwrap().amount, amount);

    Ok(())
}

#[test]
fn fixed_fee_can_convert_to_protobuf() -> anyhow::Result<()> {
    let amount = 1000;
    let fixed_fee = FixedFeeData { amount, denominating_token_id: Some(TokenId::from(2)) };

    let fixed_fee_proto = fixed_fee.to_protobuf();

    assert_eq!(fixed_fee_proto.amount, amount);

    Ok(())
}

#[test]
fn fixed_fee_can_be_created_from_protobuf() -> anyhow::Result<()> {
    let amount = 1000;
    let fixed_fee_proto =
        services::FixedFee { amount, denominating_token_id: Some(TokenId::from(2).to_protobuf()) };

    let fixed_fee = FixedFeeData::from_protobuf(fixed_fee_proto).unwrap();

    assert_eq!(fixed_fee.amount, amount);

    Ok(())
}

#[test]
fn fractional_fee_can_convert_to_protobuf() -> anyhow::Result<()> {
    let minimum_amount = 500;
    let maximum_amount = 1000;
    let net_of_transfers = true;
    let assessment_method = super::FeeAssessmentMethod::Exclusive;

    let fractional_fee = FractionalFeeData {
        denominator: 1,
        numerator: 2,
        minimum_amount,
        maximum_amount,
        assessment_method,
    };

    let fractional_fee_proto = fractional_fee.to_protobuf();

    assert_eq!(fractional_fee_proto.minimum_amount, minimum_amount);
    assert_eq!(fractional_fee_proto.maximum_amount, maximum_amount);
    assert_eq!(fractional_fee_proto.net_of_transfers, net_of_transfers);

    Ok(())
}

#[test]
fn fractional_fee_can_be_created_from_protobuf() -> anyhow::Result<()> {
    let minimum_amount = 500;
    let maximum_amount = 1000;
    let net_of_transfers = true;
    let assessment_method = super::FeeAssessmentMethod::Exclusive;

    let fractional_fee_protobuf = services::FractionalFee {
        fractional_amount: Some(services::Fraction { numerator: 1, denominator: 2 }),
        minimum_amount,
        maximum_amount,
        net_of_transfers,
    };

    let fractional_fee = FractionalFeeData::from_protobuf(fractional_fee_protobuf).unwrap();

    assert_eq!(fractional_fee.minimum_amount, minimum_amount);
    assert_eq!(fractional_fee.maximum_amount, maximum_amount);
    assert_eq!(fractional_fee.assessment_method, assessment_method);

    Ok(())
}

#[test]
fn royalty_fee_can_convert_to_protobuf() -> anyhow::Result<()> {
    let fallback_fee = FixedFeeData { denominating_token_id: Some(TokenId::from(1)), amount: 1000 };
    let exchange_value_fraction: Fraction = (1, 2).into();

    let royalty_fee =
        RoyaltyFeeData { fallback_fee: Some(fallback_fee.clone()), numerator: 1, denominator: 2 };

    let royalty_fee_proto = royalty_fee.to_protobuf();

    assert_eq!(royalty_fee_proto.fallback_fee, Some(fallback_fee.to_protobuf()));
    assert_eq!(royalty_fee_proto.exchange_value_fraction, Some(exchange_value_fraction.into()));

    Ok(())
}

#[test]
fn royalty_fee_can_be_created_from_protobuf() -> anyhow::Result<()> {
    let amount = 1000;
    let numerator = 1;
    let denominator = 2;

    let fallback_fee =
        services::FixedFee { denominating_token_id: Some(TokenId::from(1).to_protobuf()), amount };
    let exchange_value_fraction = services::Fraction { numerator, denominator };

    let royalty_fee_proto = services::RoyaltyFee {
        fallback_fee: Some(fallback_fee),
        exchange_value_fraction: Some(exchange_value_fraction),
    };

    let royalty_fee = RoyaltyFeeData::from_protobuf(royalty_fee_proto).unwrap();

    assert_eq!(royalty_fee.fallback_fee.map(|it| it.amount), Some(amount));
    assert_eq!(royalty_fee.denominator, denominator as u64);
    assert_eq!(royalty_fee.numerator, numerator as u64);

    Ok(())
}
// Filename: src/token/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod assessed_custom_fee;
mod custom_fees;
mod nft_id;
mod token_airdrop_transaction;
mod token_associate_transaction;
mod token_association;
mod token_burn_transaction;
mod token_cancel_airdrop_transaction;
mod token_claim_airdrop_transaction;
mod token_create_transaction;
mod token_delete_transaction;
mod token_dissociate_transaction;
mod token_fee_schedule_update_transaction;
mod token_freeze_transaction;
mod token_grant_kyc_transaction;
mod token_id;
mod token_info;
mod token_info_query;
mod token_key_validation_type;
mod token_mint_transaction;
mod token_nft_info;
mod token_nft_info_query;
mod token_nft_transfer;
mod token_pause_transaction;
mod token_reject_flow;
mod token_reject_transaction;
mod token_revoke_kyc_transaction;
mod token_supply_type;
mod token_type;
mod token_unfreeze_transaction;
mod token_unpause_transaction;
mod token_update_nfts_transaction;
mod token_update_transaction;
mod token_wipe_transaction;

pub use assessed_custom_fee::AssessedCustomFee;
pub use custom_fees::{
    AnyCustomFee,
    CustomFee,
    Fee,
    FeeAssessmentMethod,
    FixedFee,
    FixedFeeData,
    FractionalFee,
    FractionalFeeData,
    RoyaltyFee,
    RoyaltyFeeData,
};
pub use nft_id::NftId;
pub use token_airdrop_transaction::{
    TokenAirdropTransaction,
    TokenAirdropTransactionData,
};
pub use token_associate_transaction::{
    TokenAssociateTransaction,
    TokenAssociateTransactionData,
};
pub use token_association::TokenAssociation;
pub use token_burn_transaction::{
    TokenBurnTransaction,
    TokenBurnTransactionData,
};
pub use token_cancel_airdrop_transaction::{
    TokenCancelAirdropTransaction,
    TokenCancelAirdropTransactionData,
};
pub use token_claim_airdrop_transaction::{
    TokenClaimAirdropTransaction,
    TokenClaimAirdropTransactionData,
};
pub use token_create_transaction::{
    TokenCreateTransaction,
    TokenCreateTransactionData,
};
pub use token_delete_transaction::{
    TokenDeleteTransaction,
    TokenDeleteTransactionData,
};
pub use token_dissociate_transaction::{
    TokenDissociateTransaction,
    TokenDissociateTransactionData,
};
pub use token_fee_schedule_update_transaction::{
    TokenFeeScheduleUpdateTransaction,
    TokenFeeScheduleUpdateTransactionData,
};
pub use token_freeze_transaction::{
    TokenFreezeTransaction,
    TokenFreezeTransactionData,
};
pub use token_grant_kyc_transaction::{
    TokenGrantKycTransaction,
    TokenGrantKycTransactionData,
};
pub use token_id::TokenId;
pub use token_info::TokenInfo;
pub use token_info_query::{
    TokenInfoQuery,
    TokenInfoQueryData,
};
pub use token_key_validation_type::TokenKeyValidation;
pub use token_mint_transaction::{
    TokenMintTransaction,
    TokenMintTransactionData,
};
pub use token_nft_info::TokenNftInfo;
pub use token_nft_info_query::{
    TokenNftInfoQuery,
    TokenNftInfoQueryData,
};
pub use token_nft_transfer::TokenNftTransfer;
pub use token_pause_transaction::{
    TokenPauseTransaction,
    TokenPauseTransactionData,
};
pub use token_reject_flow::TokenRejectFlow;
pub use token_reject_transaction::{
    TokenRejectTransaction,
    TokenRejectTransactionData,
};
pub use token_revoke_kyc_transaction::{
    TokenRevokeKycTransaction,
    TokenRevokeKycTransactionData,
};
pub use token_supply_type::TokenSupplyType;
pub use token_type::TokenType;
pub use token_unfreeze_transaction::{
    TokenUnfreezeTransaction,
    TokenUnfreezeTransactionData,
};
pub use token_unpause_transaction::{
    TokenUnpauseTransaction,
    TokenUnpauseTransactionData,
};
pub use token_update_nfts_transaction::{
    TokenUpdateNftsTransaction,
    TokenUpdateNftsTransactionData,
};
pub use token_update_transaction::{
    TokenUpdateTransaction,
    TokenUpdateTransactionData,
};
pub use token_wipe_transaction::{
    TokenWipeTransaction,
    TokenWipeTransactionData,
};
// Filename: src/token/nft_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use hedera_proto::services;

use crate::entity_id::ValidateChecksums;
use crate::ledger_id::RefLedgerId;
use crate::{
    Client,
    Error,
    FromProtobuf,
    ToProtobuf,
    TokenId,
};

/// The unique identifier for a token on Hiero.
#[derive(Hash, PartialEq, Eq, Clone, Copy)]
pub struct NftId {
    /// The (non-fungible) token of which this NFT is an instance.
    pub token_id: TokenId,

    /// The unique identifier for this instance.
    pub serial: u64,
}

impl NftId {
    /// Create a new `NftId` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`] if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`] if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }

    /// Convert `self` to a string with a valid checksum.
    #[must_use]
    pub fn to_string_with_checksum(&self, client: &Client) -> String {
        format!("{}/{}", self.token_id.to_string_with_checksum(client), self.serial)
    }
}

impl Debug for NftId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for NftId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}/{}", self.token_id, self.serial)
    }
}

impl FromProtobuf<services::NftId> for NftId {
    fn from_protobuf(pb: services::NftId) -> crate::Result<Self> {
        Ok(Self {
            token_id: TokenId::from_protobuf(pb_getf!(pb, token_id)?)?,
            serial: pb.serial_number as u64,
        })
    }
}

impl ToProtobuf for NftId {
    type Protobuf = services::NftId;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::NftId {
            token_id: Some(self.token_id.to_protobuf()),
            serial_number: self.serial as i64,
        }
    }
}

impl FromStr for NftId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (token_id, serial) = s
            .rsplit_once('/')
            .or_else(|| s.rsplit_once('@'))
            .ok_or_else(|| Error::basic_parse("unexpected NftId format - expected [token_id]/[serial_number] or [token_id]@[serial_number]"))?;

        let serial = serial.parse().map_err(|_| Error::basic_parse("invalid serial number"))?;

        Ok(Self { token_id: TokenId::from_str(token_id)?, serial })
    }
}

impl From<(TokenId, u64)> for NftId {
    fn from(tuple: (TokenId, u64)) -> Self {
        Self { token_id: tuple.0, serial: tuple.1 }
    }
}

impl ValidateChecksums for NftId {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.token_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use hedera_proto::services;

    use crate::ledger_id::RefLedgerId;
    use crate::token::nft_id::NftId;
    use crate::{
        FromProtobuf,
        ToProtobuf,
        TokenId,
        ValidateChecksums,
    };

    #[test]
    fn it_can_convert_to_protobuf() -> anyhow::Result<()> {
        let nft_id = NftId { token_id: TokenId::from(1), serial: 1 };

        let nft_id_proto = nft_id.to_protobuf();

        assert_eq!(nft_id.serial, nft_id_proto.serial_number as u64);
        assert_eq!(nft_id.token_id.to_protobuf(), nft_id_proto.token_id.unwrap());

        Ok(())
    }

    #[test]
    fn it_can_create_from_protobuf() -> anyhow::Result<()> {
        let nft_id_proto =
            services::NftId { token_id: Some(TokenId::from(1).to_protobuf()), serial_number: 1 };

        let nft_id = NftId::from_protobuf(nft_id_proto.clone())?;

        assert_eq!(nft_id.serial, nft_id_proto.serial_number as u64);
        assert_eq!(nft_id.token_id, TokenId::from_protobuf(nft_id_proto.token_id.unwrap())?);

        Ok(())
    }

    #[test]
    fn from_str() -> anyhow::Result<()> {
        // Test '/' format parsing
        let nft_id_slash_str = "0.0.123/456";

        let nft_id_from_slash_str = NftId::from_str(nft_id_slash_str)?;

        assert_eq!(nft_id_from_slash_str.serial, 456);
        assert_eq!(nft_id_from_slash_str.token_id.num, 123);

        // Test '@' format parsing
        let nft_id_at_str = "0.0.123@456";

        let nft_id_from_at_str = NftId::from_str(nft_id_at_str)?;

        assert_eq!(nft_id_from_at_str.serial, 456);
        assert_eq!(nft_id_from_at_str.token_id.num, 123);

        Ok(())
    }

    #[test]
    fn to_string() {
        assert_eq!(TokenId::new(0, 0, 123).nft(456).to_string(), "0.0.123/456");
    }

    #[test]
    fn parse_with_checksum_on_mainnet() {
        let nft_id = NftId::from_str("0.0.123-vfmkw/7584").unwrap();

        nft_id.validate_checksums(RefLedgerId::MAINNET).unwrap();

        assert_eq!(nft_id.to_string(), TokenId::new(0, 0, 123).nft(7584).to_string());
    }

    #[test]
    fn parse_with_checksum_on_testnet() {
        let nft_id = NftId::from_str("0.0.123-esxsf@584903").unwrap();

        nft_id.validate_checksums(RefLedgerId::TESTNET).unwrap();

        assert_eq!(nft_id.to_string(), TokenId::new(0, 0, 123).nft(584903).to_string());
    }

    #[test]
    fn parse_with_checksum_on_previewnet() {
        let nft_id = NftId::from_str("0.0.123-ogizo/487302").unwrap();

        nft_id.validate_checksums(RefLedgerId::PREVIEWNET).unwrap();

        assert_eq!(nft_id.to_string(), TokenId::new(0, 0, 123).nft(487302).to_string());
    }

    #[test]
    fn it_can_create_from_a_tuple() -> anyhow::Result<()> {
        let tuple = (TokenId::from(1), 123);

        let nft_id_from_tuple = NftId::from(tuple);

        assert_eq!(tuple.0, nft_id_from_tuple.token_id);
        assert_eq!(tuple.1, nft_id_from_tuple.serial);

        Ok(())
    }

    #[test]
    fn it_can_create_by_using_into_on_tuple() -> anyhow::Result<()> {
        let tuple = (TokenId::from(1), 123);

        let nft_id_from_tuple: NftId = tuple.into();

        assert_eq!(tuple.0, nft_id_from_tuple.token_id);
        assert_eq!(tuple.1, nft_id_from_tuple.serial);

        Ok(())
    }
}
// Filename: src/token/token_airdrop_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashMap;

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use super::{
    NftId,
    TokenId,
    TokenNftTransfer,
};
use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::transfer_transaction::{
    TokenTransfer,
    Transfer,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Transaction,
    ValidateChecksums,
};

///
/// Airdrop one or more tokens to one or more accounts.
///
///  ### Effects
///  This distributes tokens from the balance of one or more sending account(s) to the balance
///  of one or more recipient accounts. Accounts MAY receive the tokens in one of four ways.
///
///   - An account already associated to the token to be distributed SHALL receive the
///     airdropped tokens immediately to the recipient account balance.<br/>
///     The fee for this transfer SHALL include the transfer, the airdrop fee, and any custom fees.
///   - An account with available automatic association slots SHALL be automatically
///     associated to the token, and SHALL immediately receive the airdropped tokens to the
///     recipient account balance.<br/>
///     The fee for this transfer SHALL include the transfer, the association, the cost to renew
///     that association once, the airdrop fee, and any custom fees.
///   - An account with "receiver signature required" set SHALL have a "Pending Airdrop" created
///     and must claim that airdrop with a `claimAirdrop` transaction.<br/>
///     The fee for this transfer SHALL include the transfer, the association, the cost to renew
///     that association once, the airdrop fee, and any custom fees. If the pending airdrop is not
///     claimed immediately, the `sender` SHALL pay the cost to renew the token association, and
///     the cost to maintain the pending airdrop, until the pending airdrop is claimed or cancelled.
///   - An account with no available automatic association slots SHALL have a "Pending Airdrop"
///     created and must claim that airdrop with a `claimAirdrop` transaction.<br/>
///     The fee for this transfer SHALL include the transfer, the association, the cost to renew
///     that association once, the airdrop fee, and any custom fees. If the pending airdrop is not
///     claimed immediately, the `sender` SHALL pay the cost to renew the token association, and
///     the cost to maintain the pending airdrop, until the pending airdrop is claimed or cancelled.
///
///  If an airdrop would create a pending airdrop for a fungible/common token, and a pending airdrop
///  for the same sender, receiver, and token already exists, the existing pending airdrop
///  SHALL be updated to add the new amount to the existing airdrop, rather than creating a new
///  pending airdrop.
///
///  Any airdrop that completes immediately SHALL be irreversible. Any airdrop that results in a
///  "Pending Airdrop" MAY be canceled via a `cancelAirdrop` transaction.
///
///  All transfer fees (including custom fees and royalties), as well as the rent cost for the
///  first auto-renewal period for any automatic-association slot occupied by the airdropped
///  tokens, SHALL be charged to the account paying for this transaction.
///
///  ### Record Stream Effects
///  - Each successful transfer SHALL be recorded in `token_transfer_list` for the transaction record.
///  - Each successful transfer that consumes an automatic association slot SHALL populate the
///    `automatic_association` field for the record.
///  - Each pending transfer _created_ SHALL be added to the `pending_airdrops` field for the record.
///  - Each pending transfer _updated_ SHALL be added to the `pending_airdrops` field for the record.
///
pub type TokenAirdropTransaction = Transaction<TokenAirdropTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenAirdropTransactionData {
    /// A list of token transfers representing one or more airdrops.
    token_transfers: Vec<TokenTransfer>,
}

impl TokenAirdropTransaction {
    /// Add a non-approved token transfer.
    pub fn token_transfer(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        value: i64,
    ) -> &mut Self {
        self._token_transfer(token_id, account_id, value, false)
    }

    /// Return a non-approved token transfer.
    pub fn get_token_transfers(&self) -> HashMap<TokenId, HashMap<AccountId, i64>> {
        use std::collections::hash_map::Entry;

        // note: using fold instead of nested collects on the off chance a token is in here twice.
        self.data().token_transfers.iter().fold(
            HashMap::with_capacity(self.data().token_transfers.len()),
            |mut map, transfer| {
                let iter = transfer.transfers.iter().map(|it| (it.account_id, it.amount));
                match map.entry(transfer.token_id) {
                    Entry::Occupied(mut it) => it.get_mut().extend(iter),
                    Entry::Vacant(it) => {
                        it.insert(iter.collect());
                    }
                }

                map
            },
        )
    }

    /// Add a non-approved nft transfer.
    pub fn nft_transfer(
        &mut self,
        nft_id: NftId,
        sender: AccountId,
        receiver: AccountId,
    ) -> &mut Self {
        self._nft_transfer(nft_id, sender, receiver, false);
        self
    }

    /// Extract the of token nft transfers.
    pub fn get_nft_transfers(&self) -> HashMap<TokenId, Vec<TokenNftTransfer>> {
        self.data().token_transfers.iter().map(|t| (t.token_id, t.nft_transfers.clone())).collect()
    }

    /// Add a non-approved token transfer with decimals.
    pub fn token_transfer_with_decimals(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
        decimals: u32,
    ) -> &mut Self {
        self._token_transfer_with_decimals(token_id, account_id, amount, false, Some(decimals));
        self
    }

    /// Extract the list of token id decimals.
    pub fn get_token_ids_with_decimals(&self) -> HashMap<TokenId, Option<u32>> {
        self.data().token_transfers.iter().map(|t| (t.token_id, t.expected_decimals)).collect()
    }

    /// Add an approved token transfer to the transaction.
    pub fn approved_token_transfer(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
    ) -> &mut Self {
        self._token_transfer(token_id, account_id, amount, true);
        self
    }

    /// Add an approved nft transfer.
    pub fn approved_nft_transfer(
        &mut self,
        nft_id: NftId,
        sender: AccountId,
        receiver: AccountId,
    ) -> &mut Self {
        self._nft_transfer(nft_id, sender, receiver, true);
        self
    }

    /// Add an approved token transfer with decimals.
    pub fn approved_token_transfer_with_decimals(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
        decimals: u32,
    ) -> &mut Self {
        self._token_transfer_with_decimals(token_id, account_id, amount, true, Some(decimals));
        self
    }

    fn _token_transfer(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
        is_approved: bool,
    ) -> &mut Self {
        let transfer = Transfer { account_id, amount, is_approval: is_approved };
        let data = self.data_mut();

        if let Some(tt) = data.token_transfers.iter_mut().find(|tt| tt.token_id == token_id) {
            if let Some(tt) = tt
                .transfers
                .iter_mut()
                .find(|t| t.account_id == account_id && t.is_approval == is_approved)
            {
                tt.amount += amount;
            } else {
                tt.transfers.push(transfer);
            }
        } else {
            data.token_transfers.push(TokenTransfer {
                token_id,
                expected_decimals: None,
                nft_transfers: Vec::new(),
                transfers: vec![transfer],
            });
        }
        self
    }

    fn _token_transfer_with_decimals(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
        approved: bool,
        expected_decimals: Option<u32>,
    ) -> &mut Self {
        let transfer = Transfer { account_id, amount, is_approval: approved };
        let data = self.data_mut();

        if let Some(tt) = data.token_transfers.iter_mut().find(|tt| tt.token_id == token_id) {
            if tt.expected_decimals.is_some() && tt.expected_decimals != expected_decimals {
                panic!("expected decimals mismatch");
            }

            tt.expected_decimals = expected_decimals;

            if let Some(tt) = tt
                .transfers
                .iter_mut()
                .find(|t| t.account_id == account_id && t.is_approval == approved)
            {
                tt.amount += amount;
            } else {
                tt.transfers.push(transfer);
            }
        } else {
            data.token_transfers.push(TokenTransfer {
                token_id,
                expected_decimals,
                nft_transfers: Vec::new(),
                transfers: vec![transfer],
            });
        }
        self
    }

    fn _nft_transfer(
        &mut self,
        nft_id: NftId,
        sender: AccountId,
        receiver: AccountId,
        is_approved: bool,
    ) -> &mut Self {
        let NftId { token_id, serial } = nft_id;
        let transfer = TokenNftTransfer { token_id, serial, sender, receiver, is_approved };

        let data = self.data_mut();

        if let Some(tt) = data.token_transfers.iter_mut().find(|tt| tt.token_id == token_id) {
            tt.nft_transfers.push(transfer);
        } else {
            data.token_transfers.push(TokenTransfer {
                token_id,
                expected_decimals: None,
                transfers: Vec::new(),
                nft_transfers: vec![transfer],
            });
        }

        self
    }
}

impl TransactionData for TokenAirdropTransactionData {}

impl TransactionExecute for TokenAirdropTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).airdrop_tokens(request).await })
    }
}

impl ValidateChecksums for TokenAirdropTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        for token_transfer in &self.token_transfers {
            token_transfer.token_id.validate_checksums(ledger_id)?;
            for transfer in &token_transfer.transfers {
                transfer.account_id.validate_checksums(ledger_id)?;
            }
            for nft_transfer in &token_transfer.nft_transfers {
                nft_transfer.sender.validate_checksums(ledger_id)?;
                nft_transfer.receiver.validate_checksums(ledger_id)?;
            }
        }
        Ok(())
    }
}

impl ToTransactionDataProtobuf for TokenAirdropTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenAirdrop(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenAirdropTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenAirdrop(self.to_protobuf())
    }
}

impl From<TokenAirdropTransactionData> for AnyTransactionData {
    fn from(transaction: TokenAirdropTransactionData) -> Self {
        Self::TokenAirdrop(transaction)
    }
}

impl ToProtobuf for TokenAirdropTransactionData {
    type Protobuf = services::TokenAirdropTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let mut token_transfers = self.token_transfers.clone();

        // Sort token transfers by token ID
        token_transfers.sort_by(|a, b| {
            a.token_id
                .shard
                .cmp(&b.token_id.shard)
                .then(a.token_id.realm.cmp(&b.token_id.realm))
                .then(a.token_id.num.cmp(&b.token_id.num))
        });

        // Sort transfers within each TokenTransfer
        for tt in &mut token_transfers {
            tt.transfers.sort_by(|a, b| {
                a.account_id
                    .shard
                    .cmp(&b.account_id.shard)
                    .then_with(|| a.account_id.realm.cmp(&b.account_id.realm))
                    .then_with(|| a.account_id.num.cmp(&b.account_id.num))
                    .then_with(|| a.is_approval.cmp(&b.is_approval))
            });

            tt.nft_transfers.sort_by(|a, b| a.serial.cmp(&b.serial));
        }

        services::TokenAirdropTransactionBody {
            token_transfers: token_transfers
                .into_iter()
                .map(|tt| services::TokenTransferList {
                    token: Some(tt.token_id.to_protobuf()),
                    transfers: tt.transfers.into_iter().map(|t| t.to_protobuf()).collect(),
                    nft_transfers: tt
                        .nft_transfers
                        .into_iter()
                        .map(|nt| nt.to_protobuf())
                        .collect(),
                    expected_decimals: tt.expected_decimals.map(|d| d as u32),
                })
                .collect(),
        }
    }
}

impl FromProtobuf<services::TokenAirdropTransactionBody> for TokenAirdropTransactionData {
    fn from_protobuf(pb: services::TokenAirdropTransactionBody) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Ok(Self {
            token_transfers: pb
                .token_transfers
                .into_iter()
                .map(|t| TokenTransfer::from_protobuf(t))
                .collect::<crate::Result<_>>()?,
        })
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use expect_test::expect_file;
    use hedera_proto::services::{
        self,
        AccountAmount,
        NftTransfer,
        TokenTransferList,
    };

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenAirdropTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
        TEST_ACCOUNT_ID,
        TEST_TOKEN_ID,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        TokenAirdropTransaction,
        TokenId,
    };

    fn make_transaction() -> TokenAirdropTransaction {
        let mut tx = TokenAirdropTransaction::new_for_tests();

        tx.token_transfer(TokenId::new(0, 0, 5005), AccountId::new(0, 0, 5006), 400)
            .token_transfer_with_decimals(
                TokenId::new(0, 0, 5),
                AccountId::new(0, 0, 5005),
                -800,
                3,
            )
            .token_transfer_with_decimals(
                TokenId::new(0, 0, 5),
                AccountId::new(0, 0, 5007),
                -400,
                3,
            )
            .token_transfer(TokenId::new(0, 0, 4), AccountId::new(0, 0, 5008), 1)
            .token_transfer(TokenId::new(0, 0, 4), AccountId::new(0, 0, 5006), -1)
            .nft_transfer(
                TokenId::new(0, 0, 3).nft(2),
                AccountId::new(0, 0, 5008),
                AccountId::new(0, 0, 5007),
            )
            .nft_transfer(
                TokenId::new(0, 0, 3).nft(1),
                AccountId::new(0, 0, 5008),
                AccountId::new(0, 0, 5007),
            )
            .nft_transfer(
                TokenId::new(0, 0, 3).nft(3),
                AccountId::new(0, 0, 5008),
                AccountId::new(0, 0, 5006),
            )
            .nft_transfer(
                TokenId::new(0, 0, 3).nft(4),
                AccountId::new(0, 0, 5007),
                AccountId::new(0, 0, 5006),
            )
            .nft_transfer(
                TokenId::new(0, 0, 2).nft(4),
                AccountId::new(0, 0, 5007),
                AccountId::new(0, 0, 5006),
            )
            .approved_token_transfer(TokenId::new(0, 0, 4), AccountId::new(0, 0, 5006), 123)
            .approved_nft_transfer(
                TokenId::new(0, 0, 4).nft(4),
                AccountId::new(0, 0, 5005),
                AccountId::new(0, 0, 5006),
            )
            .freeze()
            .unwrap()
            .sign(unused_private_key());
        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_airdrop_transaction/serialize.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        println!("tx: {:?}", tx);
        println!("tx2: {:?}", tx2);

        assert_eq!(tx, tx2)
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenAirdropTransactionBody {
            token_transfers: vec![TokenTransferList {
                token: Some(TEST_TOKEN_ID.to_protobuf()),
                transfers: vec![
                    AccountAmount {
                        account_id: Some(AccountId::from_str("0.0.5008").unwrap().to_protobuf()),
                        amount: 200,
                        is_approval: false,
                    },
                    AccountAmount {
                        account_id: Some(AccountId::from_str("0.0.5009").unwrap().to_protobuf()),
                        amount: -100,
                        is_approval: false,
                    },
                    AccountAmount {
                        account_id: Some(AccountId::from_str("0.0.5010").unwrap().to_protobuf()),
                        amount: 40,
                        is_approval: false,
                    },
                    AccountAmount {
                        account_id: Some(AccountId::from_str("0.0.5011").unwrap().to_protobuf()),
                        amount: 20,
                        is_approval: false,
                    },
                ],
                nft_transfers: vec![NftTransfer {
                    sender_account_id: Some(AccountId::from_str("0.0.5010").unwrap().to_protobuf()),
                    receiver_account_id: Some(
                        AccountId::from_str("0.0.5011").unwrap().to_protobuf(),
                    ),
                    serial_number: 1,
                    is_approval: true,
                }],
                expected_decimals: Some(3),
            }],
        };

        let data = TokenAirdropTransactionData::from_protobuf(tx).unwrap();

        let ft_transfers =
            data.token_transfers.iter().flat_map(|t| &t.transfers).collect::<Vec<_>>();
        let nft_transfers =
            data.token_transfers.iter().flat_map(|t| &t.nft_transfers).collect::<Vec<_>>();

        assert_eq!(ft_transfers.len(), 4);
        assert_eq!(nft_transfers.len(), 1);
    }

    #[test]
    fn get_set_token_transfers() {
        let token_id = TokenId::new(0, 0, 123);
        let account_id = AccountId::new(0, 0, 456);
        let value = 1000;
        let mut tx = TokenAirdropTransaction::new();
        tx.token_transfer(token_id, account_id, value);

        let token_transfers = tx.get_token_transfers();

        assert!(token_transfers.contains_key(&token_id));
        assert_eq!(token_transfers.len(), 1);
        assert_eq!(value, *token_transfers.get(&token_id).unwrap().get(&account_id).unwrap());
    }

    #[test]
    #[should_panic]
    fn get_set_token_transfers_frozen_panic() {
        make_transaction().token_transfer(TEST_TOKEN_ID, TEST_ACCOUNT_ID, 142);
    }

    #[test]
    fn get_set_nft_transfer() {
        let (nft_id, sender, receiver) =
            (TEST_TOKEN_ID.nft(1), TEST_ACCOUNT_ID, AccountId::new(0, 0, 5011));
        let mut tx = TokenAirdropTransaction::new();
        tx.nft_transfer(nft_id, sender, receiver);
        let nft_transfers = tx.get_nft_transfers();

        assert!(nft_transfers.contains_key(&nft_id.token_id));
        assert_eq!(1, nft_transfers.get(&nft_id.token_id).unwrap().len());
        assert_eq!(sender, nft_transfers.get(&nft_id.token_id).unwrap()[0].sender);
        assert_eq!(receiver, nft_transfers.get(&nft_id.token_id).unwrap()[0].receiver);
    }

    #[test]
    #[should_panic]
    fn get_set_nft_transfer_frozen_panic() {
        make_transaction().nft_transfer(
            TEST_TOKEN_ID.nft(1),
            TEST_ACCOUNT_ID,
            AccountId::new(0, 0, 156),
        );
    }

    #[test]
    fn get_set_approved_nft_transfer() {
        let (nft_id, sender, receiver) =
            (TEST_TOKEN_ID.nft(1), TEST_ACCOUNT_ID, AccountId::new(0, 0, 123));
        let mut tx = TokenAirdropTransaction::new();
        tx.approved_nft_transfer(nft_id, sender, receiver);
        let nft_transfers = tx.get_nft_transfers();

        assert!(nft_transfers.contains_key(&nft_id.token_id));
        assert_eq!(nft_transfers.get(&nft_id.token_id).unwrap().len(), 1);
        assert_eq!(sender, nft_transfers.get(&nft_id.token_id).unwrap()[0].sender);
        assert_eq!(receiver, nft_transfers.get(&nft_id.token_id).unwrap()[0].receiver);
    }

    #[test]
    fn get_set_approved_token_transfer() {
        let (token_id, account_id, value) =
            (TokenId::new(0, 0, 1420), AccountId::new(0, 0, 415), 1000);
        let mut tx = TokenAirdropTransaction::new();
        tx.approved_token_transfer(token_id, account_id, value);

        let token_transfers = tx.get_token_transfers();

        assert!(token_transfers.contains_key(&token_id));
        assert_eq!(token_transfers.len(), 1);
        assert_eq!(value, *token_transfers.get(&token_id).unwrap().get(&account_id).unwrap());
    }

    #[test]
    fn get_set_token_id_decimals() {
        let (nft_id, sender, receiver) =
            (TEST_TOKEN_ID.nft(1), TEST_ACCOUNT_ID, AccountId::new(0, 0, 123));
        let mut tx = TokenAirdropTransaction::new();
        tx.approved_nft_transfer(nft_id, sender, receiver);
        let nft_transfers = tx.get_nft_transfers();

        assert!(nft_transfers.contains_key(&nft_id.token_id));
        assert_eq!(nft_transfers.get(&nft_id.token_id).unwrap().len(), 1);
        assert_eq!(sender, nft_transfers.get(&nft_id.token_id).unwrap()[0].sender);
        assert_eq!(receiver, nft_transfers.get(&nft_id.token_id).unwrap()[0].receiver);
    }
}
// Filename: src/token/token_associate_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    ToProtobuf,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Associates the provided account with the provided tokens. Must be signed by the provided Account's key.
///
/// - If the provided account is not found, the transaction will resolve to `INVALID_ACCOUNT_ID`.
/// - If the provided account has been deleted, the transaction will resolve to `ACCOUNT_DELETED`.
/// - If any of the provided tokens are not found, the transaction will resolve to `INVALID_TOKEN_REF`.
/// - If any of the provided tokens have been deleted, the transaction will resolve to
/// `TOKEN_WAS_DELETED`.
/// - If an association between the provided account and any of the tokens already exists, the
/// transaction will resolve to `TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT`.
/// - If the provided account's associations count exceed the constraint of maximum token associations
/// per account, the transaction will resolve to `TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED`.
/// - On success, associations between the provided account and tokens are made and the account is
/// ready to interact with the tokens.
pub type TokenAssociateTransaction = Transaction<TokenAssociateTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenAssociateTransactionData {
    /// The account to be associated with the provided tokens.
    account_id: Option<AccountId>,

    /// The tokens to be associated with the provided account.
    token_ids: Vec<TokenId>,
}

impl TokenAssociateTransaction {
    /// Returns the account to be associated with the provided tokens.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the account to be associated with the provided tokens.
    pub fn account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(account_id);
        self
    }

    /// Returns the tokens to be associated with the provided account.
    #[must_use]
    pub fn get_token_ids(&self) -> &[TokenId] {
        &self.data().token_ids
    }

    /// Sets the tokens to be associated with the provided account.
    pub fn token_ids(&mut self, token_ids: impl IntoIterator<Item = TokenId>) -> &mut Self {
        self.data_mut().token_ids = token_ids.into_iter().collect();
        self
    }
}

impl TransactionData for TokenAssociateTransactionData {}

impl TransactionExecute for TokenAssociateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).associate_tokens(request).await })
    }
}

impl ValidateChecksums for TokenAssociateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)?;
        for token_id in &self.token_ids {
            token_id.validate_checksums(ledger_id)?;
        }
        Ok(())
    }
}

impl ToTransactionDataProtobuf for TokenAssociateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenAssociate(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenAssociateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenAssociate(self.to_protobuf())
    }
}

impl From<TokenAssociateTransactionData> for AnyTransactionData {
    fn from(transaction: TokenAssociateTransactionData) -> Self {
        Self::TokenAssociate(transaction)
    }
}

impl FromProtobuf<services::TokenAssociateTransactionBody> for TokenAssociateTransactionData {
    fn from_protobuf(pb: services::TokenAssociateTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            account_id: Option::from_protobuf(pb.account)?,
            token_ids: Vec::from_protobuf(pb.tokens)?,
        })
    }
}

impl ToProtobuf for TokenAssociateTransactionData {
    type Protobuf = services::TokenAssociateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let account = self.account_id.to_protobuf();
        let tokens = self.token_ids.to_protobuf();

        services::TokenAssociateTransactionBody { account, tokens }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect_file;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenAssociateTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        TEST_ACCOUNT_ID,
        TEST_TOKEN_ID,
    };
    use crate::{
        AnyTransaction,
        TokenAssociateTransaction,
    };

    fn make_transaction() -> TokenAssociateTransaction {
        let mut tx = TokenAssociateTransaction::new_for_tests();

        tx.account_id(TEST_ACCOUNT_ID).token_ids([TEST_TOKEN_ID]).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_associate_transaction/serialize.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2)
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenAssociateTransactionBody {
            account: Some(TEST_ACCOUNT_ID.to_protobuf()),
            tokens: Vec::from([TEST_TOKEN_ID.to_protobuf()]),
        };

        let data = TokenAssociateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.account_id, Some(TEST_ACCOUNT_ID));
        assert_eq!(data.token_ids, &[TEST_TOKEN_ID]);
    }

    #[test]
    fn get_set_token_ids() {
        let token_ids = [TEST_TOKEN_ID];
        let mut tx = TokenAssociateTransaction::new();
        tx.token_ids(token_ids.to_owned());

        assert_eq!(tx.get_token_ids(), &token_ids[..]);
    }

    #[test]
    #[should_panic]
    fn get_set_token_ids_frozen_panic() {
        make_transaction().token_ids([TEST_TOKEN_ID]);
    }

    #[test]
    fn get_set_account_id() {
        let mut tx = TokenAssociateTransaction::new();
        tx.account_id(TEST_ACCOUNT_ID);

        assert_eq!(tx.get_account_id(), Some(TEST_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panic() {
        make_transaction().account_id(TEST_ACCOUNT_ID);
    }
}
// Filename: src/token/token_association.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    FromProtobuf,
    TokenId,
};

/// A token <-> account association.
#[derive(Debug, Clone)]
pub struct TokenAssociation {
    /// The token involved in the association.
    pub token_id: TokenId,

    /// The account involved in the association.
    pub account_id: AccountId,
}

impl TokenAssociation {
    /// Create a new `TokenAssociation` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::TokenAssociation> for TokenAssociation {
    fn from_protobuf(pb: services::TokenAssociation) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let token_id = pb_getf!(pb, token_id)?;
        let account_id = pb_getf!(pb, account_id)?;

        Ok(Self {
            token_id: TokenId::from_protobuf(token_id)?,
            account_id: AccountId::from_protobuf(account_id)?,
        })
    }
}

impl ToProtobuf for TokenAssociation {
    type Protobuf = services::TokenAssociation;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenAssociation {
            token_id: Some(self.token_id.to_protobuf()),
            account_id: Some(self.account_id.to_protobuf()),
        }
    }
}

#[cfg(test)]
mod tests {

    use expect_test::expect;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        TEST_ACCOUNT_ID,
        TEST_TOKEN_ID,
    };
    use crate::{
        AccountId,
        TokenAssociation,
    };

    fn make_association() -> TokenAssociation {
        TokenAssociation { token_id: TEST_TOKEN_ID, account_id: AccountId::new(1, 2, 3) }
    }

    #[test]
    fn serialize_account() {
        let tx = make_association();

        let tx_bytes = tx.to_bytes();

        let tx = TokenAssociation::from_bytes(&tx_bytes).unwrap();

        expect![[r#"
            TokenAssociation {
                token_id: "1.2.3",
                account_id: "1.2.3",
            }
        "#]]
        .assert_debug_eq(&tx);
    }

    #[test]
    fn from_protobuf() {
        let token_proto =
            TokenAssociation { token_id: TEST_TOKEN_ID, account_id: TEST_ACCOUNT_ID }.to_protobuf();

        let token = TokenAssociation::from_protobuf(token_proto).unwrap();

        assert_eq!(token.account_id, TEST_ACCOUNT_ID);
        assert_eq!(token.token_id, TEST_TOKEN_ID);
    }

    #[test]
    fn to_protobuf() {
        let proto =
            TokenAssociation { token_id: TEST_TOKEN_ID, account_id: TEST_ACCOUNT_ID }.to_protobuf();

        assert_eq!(proto.account_id, Some(TEST_ACCOUNT_ID.to_protobuf()));
        assert_eq!(proto.token_id, Some(TEST_TOKEN_ID.to_protobuf()));
    }

    #[test]
    fn from_bytes() {
        let token = TokenAssociation { token_id: TEST_TOKEN_ID, account_id: TEST_ACCOUNT_ID };

        let token = TokenAssociation::from_bytes(&token.to_bytes()).unwrap();

        assert_eq!(token.account_id, TEST_ACCOUNT_ID);
        assert_eq!(token.token_id, TEST_TOKEN_ID);
    }

    #[test]
    fn to_bytes() {
        let token = TokenAssociation { token_id: TEST_TOKEN_ID, account_id: TEST_ACCOUNT_ID };

        let token_bytes = token.to_bytes();

        assert_eq!(token_bytes, token.to_bytes());
    }
}
// Filename: src/token/token_burn_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Burns tokens from the Token's treasury Account.
///
/// The operation decreases the Total Supply of the Token. Total supply cannot go below zero.
///
/// The amount provided must be in the lowest denomination possible. Example:
/// Token A has 2 decimals. In order to burn 100 tokens, one must provide amount of 10000. In order
/// to burn 100.55 tokens, one must provide amount of 10055.
///
/// For non-fungible tokens the transaction body accepts a `serials` list of integers as a parameter.
///
/// - If no Supply Key is defined, the transaction will resolve to `TOKEN_HAS_NO_SUPPLY_KEY`.
///
/// - If neither the amount nor the `serials` get filled, a `INVALID_TOKEN_BURN_AMOUNT` response code
/// will be returned.
///
/// - If both amount and `serials` get filled, a `INVALID_TRANSACTION_BODY` response code will be
/// returned.
///
/// - If the `serials` list count is greater than the batch size limit global dynamic property, a
/// `BATCH_SIZE_LIMIT_EXCEEDED` response code will be returned.
///
/// - If the `serials` list contains a non-positive integer as a serial number, a `INVALID_NFT_ID`
/// response code will be returned.
pub type TokenBurnTransaction = Transaction<TokenBurnTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenBurnTransactionData {
    /// The token for which to burn tokens.
    token_id: Option<TokenId>,

    /// The amount of a fungible token to burn from the treasury account.
    amount: u64,

    /// The serial numbers of a non-fungible token to burn from the treasury account.
    serials: Vec<i64>,
}

impl TokenBurnTransaction {
    /// Returns the token for which to burn tokens.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token for which to burn tokens.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }

    /// Returns the amount of a fungible token to burn from the treasury account.
    #[must_use]
    pub fn get_amount(&self) -> u64 {
        self.data().amount
    }

    /// Sets the amount of a fungible token to burn from the treasury account.
    pub fn amount(&mut self, amount: impl Into<u64>) -> &mut Self {
        self.data_mut().amount = amount.into();
        self
    }

    /// Returns the serial numbers of a non-fungible token to burn from the treasury account.
    #[must_use]
    pub fn get_serials(&self) -> &[i64] {
        &self.data().serials
    }

    /// Sets the serial numbers of a non-fungible token to burn from the treasury account.
    pub fn serials(&mut self, serials: impl IntoIterator<Item = i64>) -> &mut Self {
        self.data_mut().serials = serials.into_iter().collect();
        self
    }
}

impl TransactionData for TokenBurnTransactionData {}

impl TransactionExecute for TokenBurnTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).burn_token(request).await })
    }
}

impl ValidateChecksums for TokenBurnTransactionData {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenBurnTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenBurn(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenBurnTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenBurn(self.to_protobuf())
    }
}

impl From<TokenBurnTransactionData> for AnyTransactionData {
    fn from(transaction: TokenBurnTransactionData) -> Self {
        Self::TokenBurn(transaction)
    }
}

impl FromProtobuf<services::TokenBurnTransactionBody> for TokenBurnTransactionData {
    fn from_protobuf(pb: services::TokenBurnTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            token_id: Option::from_protobuf(pb.token)?,
            amount: pb.amount,
            serials: pb.serial_numbers,
        })
    }
}

impl ToProtobuf for TokenBurnTransactionData {
    type Protobuf = services::TokenBurnTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let token = self.token_id.to_protobuf();
        let amount = self.amount;
        let serial_numbers = self.serials.clone();

        services::TokenBurnTransactionBody { token, amount, serial_numbers }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect_file;
    use hedera_proto::services;

    use super::TokenBurnTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        TEST_TOKEN_ID,
    };
    use crate::{
        AnyTransaction,
        TokenBurnTransaction,
    };

    fn make_transaction() -> TokenBurnTransaction {
        let mut tx = TokenBurnTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID).amount(6 as u64).freeze().unwrap();

        tx
    }

    fn make_transaction_nft() -> TokenBurnTransaction {
        let mut tx = TokenBurnTransaction::new_for_tests();

        let vec1 = vec![1, 2, 64];

        tx.token_id(TEST_TOKEN_ID).serials(vec1).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize_fungible() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_burn_transaction/serialize_fungible.txt"]
            .assert_debug_eq(&tx);
    }

    #[test]
    fn serialize_nft() {
        let tx = make_transaction_nft();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_burn_transaction/serialize_nft.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();
        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();
        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn to_from_bytes_nft() {
        let tx = make_transaction_nft();
        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();
        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenBurnTransactionBody {
            token: Some(TEST_TOKEN_ID.to_protobuf()),
            amount: 6,
            serial_numbers: Vec::new(),
        };

        let tx = TokenBurnTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.token_id, Some(TEST_TOKEN_ID));
        assert_eq!(tx.amount, 6);
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenBurnTransaction::new();
        tx.token_id(TEST_TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    fn get_set_amount() {
        let mut tx = TokenBurnTransaction::new();
        tx.amount(23_u64);

        assert_eq!(tx.get_amount(), 23);
    }

    #[test]
    fn get_set_serial() {
        let serials = [1, 2, 64];

        let mut tx = TokenBurnTransaction::new();
        tx.serials(Vec::from(serials));

        assert_eq!(tx.get_serials(), serials);
    }
}
// Filename: src/token/token_cancel_airdrop_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::pending_airdrop_id::PendingAirdropId;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    FromProtobuf,
    ToProtobuf,
    Transaction,
    ValidateChecksums,
};

/// Token cancel airdrop
/// Remove one or more pending airdrops from state on behalf of the sender(s)
/// for each airdrop.
///
/// Each pending airdrop canceled SHALL be removed from state and SHALL NOT be available to claim.
/// Each cancellation SHALL be represented in the transaction body and SHALL NOT be restated
/// in the record file.
/// All cancellations MUST succeed for this transaction to succeed.
pub type TokenCancelAirdropTransaction = Transaction<TokenCancelAirdropTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenCancelAirdropTransactionData {
    /// The ID of the pending airdrop to cancel
    pending_airdrop_ids: Vec<PendingAirdropId>,
}

impl TokenCancelAirdropTransaction {
    /// Adds the list of pending airdrop identifiers to cancel.
    pub fn pending_airdrop_ids(
        &mut self,
        pending_airdrop_ids: impl IntoIterator<Item = PendingAirdropId>,
    ) -> &mut Self {
        self.data_mut().pending_airdrop_ids = pending_airdrop_ids.into_iter().collect();
        self
    }

    /// Returns the list of pending airdrop identifiers to cancel.
    pub fn get_pending_airdrop_ids(&self) -> Vec<PendingAirdropId> {
        self.data().pending_airdrop_ids.clone()
    }

    /// Adds a pending airdrop identifier to the list of pending airdrop identifiers to cancel.
    pub fn add_pending_airdrop_id(&mut self, pending_airdrop_id: PendingAirdropId) -> &mut Self {
        self.data_mut().pending_airdrop_ids.push(pending_airdrop_id);
        self
    }
}

impl TransactionData for TokenCancelAirdropTransactionData {}

impl TransactionExecute for TokenCancelAirdropTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).cancel_airdrop(request).await })
    }
}

impl ValidateChecksums for TokenCancelAirdropTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.pending_airdrop_ids
            .iter()
            .try_for_each(|pending_airdrop_id| pending_airdrop_id.validate_checksums(ledger_id))?;
        Ok(())
    }
}

impl ToTransactionDataProtobuf for TokenCancelAirdropTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenCancelAirdrop(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenCancelAirdropTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenCancelAirdrop(self.to_protobuf())
    }
}

impl From<TokenCancelAirdropTransactionData> for AnyTransactionData {
    fn from(transaction: TokenCancelAirdropTransactionData) -> Self {
        Self::TokenCancelAirdrop(transaction)
    }
}

impl ToProtobuf for TokenCancelAirdropTransactionData {
    type Protobuf = services::TokenCancelAirdropTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenCancelAirdropTransactionBody {
            pending_airdrops: self.pending_airdrop_ids.iter().map(|id| id.to_protobuf()).collect(),
        }
    }
}

impl FromProtobuf<services::TokenCancelAirdropTransactionBody>
    for TokenCancelAirdropTransactionData
{
    fn from_protobuf(pb: services::TokenCancelAirdropTransactionBody) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let pending_airdrop_ids = pb
            .pending_airdrops
            .into_iter()
            .map(|id: services::PendingAirdropId| PendingAirdropId::from_protobuf(id))
            .collect::<Result<Vec<_>, _>>()?;
        Ok(Self { pending_airdrop_ids })
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect_file;
    use hedera_proto::services;

    use crate::pending_airdrop_id::PendingAirdropId;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenCancelAirdropTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        TokenCancelAirdropTransaction,
        TokenId,
    };

    fn make_transaction() -> TokenCancelAirdropTransaction {
        let pending_airdrop_ids: Vec<PendingAirdropId> = vec![
            PendingAirdropId::new_token_id(
                AccountId::new(0, 2, 134),
                AccountId::new(0, 2, 6),
                TokenId::new(0, 0, 312),
            ),
            PendingAirdropId::new_nft_id(
                AccountId::new(0, 2, 134),
                AccountId::new(0, 2, 6),
                TokenId::new(1, 3, 5).nft(2),
            ),
        ]
        .into_iter()
        .collect();
        let mut tx = TokenCancelAirdropTransaction::new_for_tests();

        tx.pending_airdrop_ids(pending_airdrop_ids).freeze().unwrap().sign(unused_private_key());
        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_cancel_airdrop_transaction/serialize.txt"]
            .assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2)
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenCancelAirdropTransactionBody {
            pending_airdrops: vec![
                PendingAirdropId::new_token_id(
                    AccountId::new(0, 0, 415),
                    AccountId::new(0, 0, 6),
                    TokenId::new(0, 0, 312),
                )
                .to_protobuf(),
                PendingAirdropId::new_nft_id(
                    AccountId::new(0, 2, 134),
                    AccountId::new(0, 2, 6),
                    TokenId::new(0, 0, 123).nft(1),
                )
                .to_protobuf(),
            ],
        };

        let data = TokenCancelAirdropTransactionData::from_protobuf(tx).unwrap();

        let nft_ids: Vec<_> =
            data.pending_airdrop_ids.clone().into_iter().filter_map(|id| id.nft_id).collect();
        let token_ids: Vec<_> =
            data.pending_airdrop_ids.into_iter().filter_map(|id| id.token_id).collect();

        assert_eq!(nft_ids.len(), 1);
        assert_eq!(token_ids.len(), 1);
        assert!(token_ids.contains(&TokenId::new(0, 0, 312)));
        assert!(nft_ids.contains(&TokenId::new(0, 0, 123).nft(1)));
    }

    #[test]
    fn get_set_pending_airdrop_ids() {
        let pending_airdrop_ids = [
            PendingAirdropId::new_token_id(
                AccountId::new(0, 0, 134),
                AccountId::new(0, 0, 6),
                TokenId::new(0, 0, 420),
            ),
            PendingAirdropId::new_nft_id(
                AccountId::new(0, 2, 134),
                AccountId::new(0, 2, 6),
                TokenId::new(0, 0, 112).nft(1),
            ),
        ];
        let mut tx = TokenCancelAirdropTransaction::new();
        tx.pending_airdrop_ids(pending_airdrop_ids);

        let pending_airdrop_ids = tx.get_pending_airdrop_ids();

        let nft_ids: Vec<_> =
            pending_airdrop_ids.clone().into_iter().filter_map(|id| id.nft_id).collect();
        let token_ids: Vec<_> =
            pending_airdrop_ids.into_iter().filter_map(|id| id.token_id).collect();

        assert_eq!(nft_ids.len(), 1);
        assert_eq!(token_ids.len(), 1);

        assert!(token_ids.contains(&TokenId::new(0, 0, 420)));
        assert!(nft_ids.contains(&TokenId::new(0, 0, 112).nft(1)));
    }

    #[test]
    #[should_panic]
    fn set_pending_airdrop_ids_frozen_panic() {
        make_transaction().pending_airdrop_ids([PendingAirdropId::new_token_id(
            AccountId::new(0, 0, 134),
            AccountId::new(0, 0, 6),
            TokenId::new(0, 0, 420),
        )]);
    }

    #[test]
    fn get_set_add_pending_airdrop_id() {
        let mut tx = TokenCancelAirdropTransaction::new();
        tx.add_pending_airdrop_id(PendingAirdropId::new_token_id(
            AccountId::new(0, 0, 134),
            AccountId::new(0, 0, 6),
            TokenId::new(0, 0, 420),
        ));

        let pending_airdrop_ids = tx.get_pending_airdrop_ids();

        let token_ids: Vec<_> =
            pending_airdrop_ids.into_iter().filter_map(|id| id.token_id).collect();

        assert!(token_ids.contains(&TokenId::new(0, 0, 420)));
    }
}
// Filename: src/token/token_claim_airdrop_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::pending_airdrop_id::PendingAirdropId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    Transaction,
    ValidateChecksums,
};

/// Token claim airdrop
/// Complete one or more pending transfers on behalf of the
/// recipient(s) for an airdrop.
///
/// The sender MUST have sufficient balance to fulfill the airdrop at the
/// time of claim. If the sender does not have sufficient balance, the
/// claim SHALL fail.
/// Each pending airdrop successfully claimed SHALL be removed from state and
/// SHALL NOT be available to claim again.
/// Each claim SHALL be represented in the transaction body and
/// SHALL NOT be restated in the record file.
/// All claims MUST succeed for this transaction to succeed.
///
/// ### Record Stream Effects
/// The completed transfers SHALL be present in the transfer list.
///
pub type TokenClaimAirdropTransaction = Transaction<TokenClaimAirdropTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenClaimAirdropTransactionData {
    /// A list of one or more pending airdrop identifiers.
    ///
    /// This transaction MUST be signed by the account identified by
    /// the `receiver_id` for each entry in this list.
    /// This list MUST contain between 1 and 10 entries, inclusive.
    /// This list MUST NOT have any duplicate entries.
    pending_airdrop_ids: Vec<PendingAirdropId>,
}

impl TokenClaimAirdropTransaction {
    /// Adds the list of pending airdrop identifiers to claim.
    pub fn pending_airdrop_ids(
        &mut self,
        pending_airdrop_ids: impl IntoIterator<Item = PendingAirdropId>,
    ) -> &mut Self {
        self.data_mut().pending_airdrop_ids = pending_airdrop_ids.into_iter().collect();
        self
    }

    /// Returns the list of pending airdrop identifiers to claim.
    #[must_use]
    pub fn get_pending_airdrop_ids(&self) -> Vec<PendingAirdropId> {
        self.data().pending_airdrop_ids.clone()
    }

    /// Adds a pending airdrop identifier to the list of pending airdrop identifiers.
    pub fn add_pending_airdrop_id(&mut self, pending_airdrop_id: PendingAirdropId) -> &mut Self {
        self.data_mut().pending_airdrop_ids.push(pending_airdrop_id);
        self
    }
}

impl TransactionData for TokenClaimAirdropTransactionData {}

impl TransactionExecute for TokenClaimAirdropTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).claim_airdrop(request).await })
    }
}

impl ValidateChecksums for TokenClaimAirdropTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.pending_airdrop_ids
            .iter()
            .try_for_each(|pending_airdrop_id| pending_airdrop_id.validate_checksums(ledger_id))?;
        Ok(())
    }
}

impl ToTransactionDataProtobuf for TokenClaimAirdropTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenClaimAirdrop(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenClaimAirdropTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenClaimAirdrop(self.to_protobuf())
    }
}

impl From<TokenClaimAirdropTransactionData> for AnyTransactionData {
    fn from(transaction: TokenClaimAirdropTransactionData) -> Self {
        Self::TokenClaimAirdrop(transaction)
    }
}

impl ToProtobuf for TokenClaimAirdropTransactionData {
    type Protobuf = services::TokenClaimAirdropTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenClaimAirdropTransactionBody {
            pending_airdrops: self.pending_airdrop_ids.iter().map(|id| id.to_protobuf()).collect(),
        }
    }
}

impl FromProtobuf<services::TokenClaimAirdropTransactionBody> for TokenClaimAirdropTransactionData {
    fn from_protobuf(pb: services::TokenClaimAirdropTransactionBody) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let pending_airdrop_ids = pb
            .pending_airdrops
            .into_iter()
            .map(|id: services::PendingAirdropId| PendingAirdropId::from_protobuf(id))
            .collect::<Result<Vec<_>, _>>()?;
        Ok(Self { pending_airdrop_ids })
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect_file;
    use hedera_proto::services;

    use crate::pending_airdrop_id::PendingAirdropId;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenClaimAirdropTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        TokenClaimAirdropTransaction,
        TokenId,
    };

    fn make_transaction() -> TokenClaimAirdropTransaction {
        let pending_airdrop_ids: Vec<PendingAirdropId> = vec![
            PendingAirdropId::new_token_id(
                AccountId::new(0, 2, 134),
                AccountId::new(0, 2, 6),
                TokenId::new(0, 0, 312),
            ),
            PendingAirdropId::new_nft_id(
                AccountId::new(0, 2, 134),
                AccountId::new(0, 2, 6),
                TokenId::new(1, 3, 5).nft(2),
            ),
        ]
        .into_iter()
        .collect();
        let mut tx = TokenClaimAirdropTransaction::new_for_tests();

        tx.pending_airdrop_ids(pending_airdrop_ids).freeze().unwrap().sign(unused_private_key());
        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_claim_airdrop_transaction/serialize.txt"]
            .assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2)
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenClaimAirdropTransactionBody {
            pending_airdrops: vec![
                PendingAirdropId::new_token_id(
                    AccountId::new(0, 0, 415),
                    AccountId::new(0, 0, 6),
                    TokenId::new(0, 0, 312),
                )
                .to_protobuf(),
                PendingAirdropId::new_nft_id(
                    AccountId::new(0, 2, 134),
                    AccountId::new(0, 2, 6),
                    TokenId::new(0, 0, 123).nft(1),
                )
                .to_protobuf(),
            ],
        };

        let data = TokenClaimAirdropTransactionData::from_protobuf(tx).unwrap();

        let nft_ids: Vec<_> =
            data.pending_airdrop_ids.clone().into_iter().filter_map(|id| id.nft_id).collect();
        let token_ids: Vec<_> =
            data.pending_airdrop_ids.into_iter().filter_map(|id| id.token_id).collect();

        assert_eq!(nft_ids.len(), 1);
        assert_eq!(token_ids.len(), 1);
        assert!(token_ids.contains(&TokenId::new(0, 0, 312)));
        assert!(nft_ids.contains(&TokenId::new(0, 0, 123).nft(1)));
    }

    #[test]
    fn get_set_pending_airdrop_ids() {
        let pending_airdrop_ids = [
            PendingAirdropId::new_token_id(
                AccountId::new(0, 0, 134),
                AccountId::new(0, 0, 6),
                TokenId::new(0, 0, 420),
            ),
            PendingAirdropId::new_nft_id(
                AccountId::new(0, 2, 134),
                AccountId::new(0, 2, 6),
                TokenId::new(0, 0, 112).nft(1),
            ),
        ];
        let mut tx = TokenClaimAirdropTransaction::new();
        tx.pending_airdrop_ids(pending_airdrop_ids);

        let pending_airdrop_ids = tx.get_pending_airdrop_ids();

        let nft_ids: Vec<_> =
            pending_airdrop_ids.clone().into_iter().filter_map(|id| id.nft_id).collect();
        let token_ids: Vec<_> =
            pending_airdrop_ids.into_iter().filter_map(|id| id.token_id).collect();

        assert_eq!(nft_ids.len(), 1);
        assert_eq!(token_ids.len(), 1);

        assert!(token_ids.contains(&TokenId::new(0, 0, 420)));
        assert!(nft_ids.contains(&TokenId::new(0, 0, 112).nft(1)));
    }

    #[test]
    #[should_panic]
    fn set_pending_airdrop_ids_frozen_panic() {
        make_transaction().pending_airdrop_ids([PendingAirdropId::new_token_id(
            AccountId::new(0, 0, 134),
            AccountId::new(0, 0, 6),
            TokenId::new(0, 0, 420),
        )]);
    }

    #[test]
    fn get_set_add_pending_airdrop_id() {
        let mut tx = TokenClaimAirdropTransaction::new();
        tx.add_pending_airdrop_id(PendingAirdropId::new_token_id(
            AccountId::new(0, 0, 134),
            AccountId::new(0, 0, 6),
            TokenId::new(0, 0, 420),
        ));

        let pending_airdrop_ids = tx.get_pending_airdrop_ids();

        let token_ids: Vec<_> =
            pending_airdrop_ids.into_iter().filter_map(|id| id.token_id).collect();

        assert!(token_ids.contains(&TokenId::new(0, 0, 420)));
    }
}
// Filename: src/token/token_create_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use time::{
    Duration,
    OffsetDateTime,
};
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::token::custom_fees::AnyCustomFee;
use crate::token::token_supply_type::TokenSupplyType;
use crate::token::token_type::TokenType;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Key,
    Transaction,
    ValidateChecksums,
};

/// Create a new token.
///
/// After the token is created, the [`TokenId`](crate::TokenId) for it is in the receipt.
///
/// The specified treasury account receives the initial supply of tokens, as well as the tokens
/// from a [`TokenMintTransaction`](crate::TokenMintTransaction) once executed.
/// The balance of the treasury account is decreased when a [`TokenBurnTransaction`](crate::TokenBurnTransaction) is executed.
///
/// The `initial_supply` is in the lowest denomination of the token (like a tinybar, not an hbar).
///
/// Note that a created token is __immutable__ if the `admin_key` is omitted. No property of
/// an immutable token can ever change, with the sole exception of its expiry. Anyone can pay to
/// extend the expiry time of an immutable token.
///
/// - If [`NonFungibleUnique`][TokenType::NonFungibleUnique] is used, the `initial_supply` should
/// explicitly be set to 0 (which is the default). If not, the transaction will
/// resolve to `InvalidTokenInitialSupply`.
///
/// - If [`Infinite`][TokenSupplyType::Infinite] is used, the `max_supply` should
/// explicitly be set to 0 (which is the default). If it is not 0,
/// the transaction will resolve to `InvalidTokenMaxSupply`.
///
pub type TokenCreateTransaction = Transaction<TokenCreateTransactionData>;

#[derive(Debug, Clone)]
pub struct TokenCreateTransactionData {
    /// The publicly visible name of the token.
    name: String,

    /// The publicly visible token symbol.
    symbol: String,

    /// The number of decimal places a fungible token is divisible by.
    decimals: u32,

    /// The initial supply of fungible tokens to to mint to the treasury account.
    initial_supply: u64,

    /// The account which will act as a treasury for the token.
    treasury_account_id: Option<AccountId>,

    /// The key which can perform update/delete operations on the token.
    admin_key: Option<Key>,

    /// The key which can grant or revoke KYC of an account for the token's transactions.
    kyc_key: Option<Key>,

    /// The key which can sign to freeze or unfreeze an account for token transactions.
    freeze_key: Option<Key>,

    /// The key which can wipe the token balance of an account.
    wipe_key: Option<Key>,

    /// The key which can change the supply of a token.
    supply_key: Option<Key>,

    /// The default freeze status (frozen or unfrozen) of Hiero accounts relative to this token. If
    /// true, an account must be unfrozen before it can receive the token
    freeze_default: bool,

    /// The time at which the token should expire.
    expiration_time: Option<OffsetDateTime>,

    /// An account which will be automatically charged to renew the token's expiration, at
    /// `auto_renew_period` interval.
    auto_renew_account_id: Option<AccountId>,

    /// The interval at which the auto-renew account will be charged to extend the token's expiry
    auto_renew_period: Option<Duration>,

    /// The memo associated with the token.
    token_memo: String,

    /// The token type. Defaults to FungibleCommon.
    token_type: TokenType,

    /// The token supply type. Defaults to Infinite.
    token_supply_type: TokenSupplyType,

    /// Sets the maximum number of tokens that can be in circulation.
    max_supply: u64,

    /// The key which can change the token's custom fee schedule.
    fee_schedule_key: Option<Key>,

    /// The custom fees to be assessed during a transfer.
    custom_fees: Vec<AnyCustomFee>,

    /// The key which can pause and unpause the token.
    pause_key: Option<Key>,

    /// Metadata of the created token definition.
    metadata: Vec<u8>,

    /// The key which can change the metadata of a token
    /// (token definition, partition definition, and individual NFTs).
    metadata_key: Option<Key>,
}

impl Default for TokenCreateTransactionData {
    fn default() -> Self {
        Self {
            name: String::new(),
            symbol: String::new(),
            decimals: 0,
            initial_supply: 0,
            treasury_account_id: None,
            admin_key: None,
            kyc_key: None,
            freeze_key: None,
            wipe_key: None,
            supply_key: None,
            freeze_default: false,
            expiration_time: None,
            auto_renew_account_id: None,
            auto_renew_period: Some(Duration::days(90)),
            token_memo: String::new(),
            token_type: TokenType::FungibleCommon,
            token_supply_type: TokenSupplyType::Infinite,
            max_supply: 0,
            fee_schedule_key: None,
            custom_fees: vec![],
            pause_key: None,
            metadata: vec![],
            metadata_key: None,
        }
    }
}

impl TokenCreateTransaction {
    /// Returns the publicly visible name of the token.
    #[must_use]
    pub fn get_name(&self) -> &str {
        &self.data().name
    }

    /// Sets the publicly visible name of the token.
    ///
    /// Maximum 100 characters.
    pub fn name(&mut self, name: impl Into<String>) -> &mut Self {
        self.data_mut().name = name.into();
        self
    }

    /// Returns the publicly visible token symbol.
    #[must_use]
    pub fn get_symbol(&self) -> &str {
        &self.data().symbol
    }

    /// Sets the publicly visible token symbol.
    ///
    /// Maximum 100 characters.
    pub fn symbol(&mut self, symbol: impl Into<String>) -> &mut Self {
        self.data_mut().symbol = symbol.into();
        self
    }

    /// Returns the number of decimal places the token is divisble by.
    #[must_use]
    pub fn get_decimals(&self) -> u32 {
        self.data().decimals
    }

    /// Sets the number of decimal places a token is divisible by.
    pub fn decimals(&mut self, decimals: u32) -> &mut Self {
        self.data_mut().decimals = decimals;
        self
    }

    /// Returns the initial supply of tokens to be put into circulation.
    #[must_use]
    pub fn get_initial_supply(&self) -> u64 {
        self.data().initial_supply
    }

    /// Sets the initial supply of tokens to be put in circulation.
    pub fn initial_supply(&mut self, initial_supply: u64) -> &mut Self {
        self.data_mut().initial_supply = initial_supply;
        self
    }

    /// Returns the account which will act as a treasury for the token.
    #[must_use]
    pub fn get_treasury_account_id(&self) -> Option<AccountId> {
        self.data().treasury_account_id
    }

    /// Sets the account which will act as a treasury for the token.
    pub fn treasury_account_id(&mut self, treasury_account_id: AccountId) -> &mut Self {
        self.data_mut().treasury_account_id = Some(treasury_account_id);
        self
    }

    /// Returns the key whcih can perform update/delete operations on the token.
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.data().admin_key.as_ref()
    }

    /// Sets the key which can perform update/delete operations on the token.
    pub fn admin_key(&mut self, admin_key: impl Into<Key>) -> &mut Self {
        self.data_mut().admin_key = Some(admin_key.into());
        self
    }

    /// Returns the key which can grant or revoke KYC of an account for the token's transactions.
    #[must_use]
    pub fn get_kyc_key(&self) -> Option<&Key> {
        self.data().kyc_key.as_ref()
    }

    /// Sets the key which can grant or revoke KYC of an account for the token's transactions.
    pub fn kyc_key(&mut self, kyc_key: impl Into<Key>) -> &mut Self {
        self.data_mut().kyc_key = Some(kyc_key.into());
        self
    }

    /// Returns the key which can sign to freeze or unfreeze an account for token transactions.
    #[must_use]
    pub fn get_freeze_key(&self) -> Option<&Key> {
        self.data().freeze_key.as_ref()
    }

    /// Sets the key which can sign to freeze or unfreeze an account for token transactions.
    pub fn freeze_key(&mut self, freeze_key: impl Into<Key>) -> &mut Self {
        self.data_mut().freeze_key = Some(freeze_key.into());
        self
    }

    /// Returns the key which can wipe the token balance of an account.
    #[must_use]
    pub fn get_wipe_key(&self) -> Option<&Key> {
        self.data().wipe_key.as_ref()
    }

    /// Sets the key which can wipe the token balance of an account.
    pub fn wipe_key(&mut self, wipe_key: impl Into<Key>) -> &mut Self {
        self.data_mut().wipe_key = Some(wipe_key.into());
        self
    }

    /// Returns the key which can change the supply of the token.
    #[must_use]
    pub fn get_supply_key(&self) -> Option<&Key> {
        self.data().supply_key.as_ref()
    }

    /// Sets the key which can change the supply of the token.
    pub fn supply_key(&mut self, supply_key: impl Into<Key>) -> &mut Self {
        self.data_mut().supply_key = Some(supply_key.into());
        self
    }

    /// Returnsthe default freeze status (frozen or unfrozen) of hedera accounts
    /// relative to this token. If true, an account must be unfrozen before it can receive the token.
    #[must_use]
    pub fn get_freeze_default(&self) -> bool {
        self.data().freeze_default
    }

    /// Sets the default freeze status (frozen or unfrozen) of hedera accounts
    /// relative to this token. If true, an account must be unfrozen before it can receive the token.
    pub fn freeze_default(&mut self, freeze_default: bool) -> &mut Self {
        self.data_mut().freeze_default = freeze_default;
        self
    }

    /// Returns the time at which the token should expire.
    #[must_use]
    pub fn get_expiration_time(&self) -> Option<OffsetDateTime> {
        self.data().expiration_time
    }

    /// Sets the time at which the token should expire.
    pub fn expiration_time(&mut self, expiration_time: OffsetDateTime) -> &mut Self {
        let data = self.data_mut();
        data.expiration_time = Some(expiration_time);
        data.auto_renew_period = None;

        self
    }

    /// Returns the account which will be automatically charged to renew the token's expiration.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the account which will be automatically charged to renew the token's expiration.
    pub fn auto_renew_account_id(&mut self, auto_renew_account_id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(auto_renew_account_id);
        self
    }

    /// Returns the interval at which the auto renew account will be charged to extend the token's expiry.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.data().auto_renew_period
    }

    /// Sets the interval at which the auto renew account will be charged to extend
    /// the token's expiry.
    pub fn auto_renew_period(&mut self, auto_renew_period: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = Some(auto_renew_period);
        self
    }

    /// Returns the memo associated with the token.
    #[must_use]
    pub fn get_token_memo(&self) -> &str {
        &self.data().token_memo
    }

    // note(sr): I got rid of the comment stating UTF-8, since this is a Rust string, which implies UTF-8.
    /// Sets the memo associated with the token.
    ///
    /// Maximum 100 bytes.
    pub fn token_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().token_memo = memo.into();
        self
    }

    /// Returns the token type.
    #[must_use]
    pub fn get_token_type(&self) -> TokenType {
        self.data().token_type
    }

    /// Sets the token type. Defaults to `FungibleCommon`.
    pub fn token_type(&mut self, token_type: TokenType) -> &mut Self {
        self.data_mut().token_type = token_type;
        self
    }

    /// Returns the token supply type.
    #[must_use]
    pub fn get_token_supply_type(&self) -> TokenSupplyType {
        self.data().token_supply_type
    }

    /// Sets the token supply type. Defaults to `Infinite`.
    pub fn token_supply_type(&mut self, token_supply_type: TokenSupplyType) -> &mut Self {
        self.data_mut().token_supply_type = token_supply_type;
        self
    }

    /// Returns the maximum number of tokens that can be in circulation.
    #[must_use]
    pub fn get_max_supply(&self) -> u64 {
        self.data().max_supply
    }

    /// Sets the maximum number of tokens that can be in circulation.
    pub fn max_supply(&mut self, max_supply: u64) -> &mut Self {
        self.data_mut().max_supply = max_supply;
        self
    }

    /// Returns the key which can change the token's custom fee schedule.
    #[must_use]
    pub fn get_fee_schedule_key(&self) -> Option<&Key> {
        self.data().fee_schedule_key.as_ref()
    }

    /// Sets the key which can change the token's custom fee schedule.
    pub fn fee_schedule_key(&mut self, fee_schedule_key: impl Into<Key>) -> &mut Self {
        self.data_mut().fee_schedule_key = Some(fee_schedule_key.into());
        self
    }

    /// Returns the custom fees to be assessed during a transfer.
    #[must_use]
    pub fn get_custom_fees(&self) -> &[AnyCustomFee] {
        &self.data().custom_fees
    }

    /// Sets the custom fees to be assessed during a transfer.
    pub fn custom_fees(
        &mut self,
        custom_fees: impl IntoIterator<Item = AnyCustomFee>,
    ) -> &mut Self {
        self.data_mut().custom_fees = custom_fees.into_iter().collect();
        self
    }

    /// Returns the key which can pause and unpause the token.
    #[must_use]
    pub fn get_pause_key(&self) -> Option<&Key> {
        self.data().pause_key.as_ref()
    }

    /// Sets the key which can pause and unpause the token.
    pub fn pause_key(&mut self, pause_key: impl Into<Key>) -> &mut Self {
        self.data_mut().pause_key = Some(pause_key.into());
        self
    }

    /// Returns the metadata of the created token definition.
    #[must_use]
    pub fn get_metadata(&self) -> Vec<u8> {
        self.data().metadata.clone()
    }

    /// Sets metadata of the created token definition.
    pub fn metadata(&mut self, metadata: Vec<u8>) -> &mut Self {
        self.data_mut().metadata = metadata;
        self
    }

    /// Returns the key which can change the metadata of a token.
    #[must_use]
    pub fn get_metadata_key(&self) -> Option<&Key> {
        self.data().metadata_key.as_ref()
    }

    /// Sets the key which can change the metadata of a token.
    pub fn metadata_key(&mut self, metadata_key: impl Into<Key>) -> &mut Self {
        self.data_mut().metadata_key = Some(metadata_key.into());
        self
    }
}

impl TransactionData for TokenCreateTransactionData {
    fn default_max_transaction_fee(&self) -> crate::Hbar {
        crate::Hbar::from_unit(40, crate::HbarUnit::Hbar)
    }
}

impl TransactionExecute for TokenCreateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).create_token(request).await })
    }
}

impl ValidateChecksums for TokenCreateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        // TODO: validate custom fees.
        self.treasury_account_id.validate_checksums(ledger_id)?;
        self.auto_renew_account_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenCreateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        // Generate the protobuf data
        let mut protobuf_data = self.to_protobuf();

        // Manually assign the auto_renew_account with operator_id if none is set
        if protobuf_data.auto_renew_account.is_none() {
            let operator_id = chunk_info.current_transaction_id.account_id;
            protobuf_data.auto_renew_account = Some(operator_id.to_protobuf());
        }
        services::transaction_body::Data::TokenCreation(protobuf_data)
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenCreateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenCreation(self.to_protobuf())
    }
}

impl From<TokenCreateTransactionData> for AnyTransactionData {
    fn from(transaction: TokenCreateTransactionData) -> Self {
        Self::TokenCreate(transaction)
    }
}

impl FromProtobuf<services::TokenCreateTransactionBody> for TokenCreateTransactionData {
    fn from_protobuf(pb: services::TokenCreateTransactionBody) -> crate::Result<Self> {
        let services::TokenCreateTransactionBody {
            name,
            symbol,
            decimals,
            initial_supply,
            treasury,
            admin_key,
            kyc_key,
            freeze_key,
            wipe_key,
            supply_key,
            freeze_default,
            expiry,
            auto_renew_account,
            auto_renew_period,
            memo,
            token_type,
            supply_type,
            max_supply,
            fee_schedule_key,
            custom_fees,
            pause_key,
            metadata,
            metadata_key,
        } = pb;

        let token_type = services::TokenType::try_from(token_type).unwrap_or_default();
        let token_supply_type =
            services::TokenSupplyType::try_from(supply_type).unwrap_or_default();

        Ok(Self {
            name,
            symbol,
            decimals,
            initial_supply,
            treasury_account_id: Option::from_protobuf(treasury)?,
            admin_key: Option::from_protobuf(admin_key)?,
            kyc_key: Option::from_protobuf(kyc_key)?,
            freeze_key: Option::from_protobuf(freeze_key)?,
            wipe_key: Option::from_protobuf(wipe_key)?,
            supply_key: Option::from_protobuf(supply_key)?,
            freeze_default,
            expiration_time: expiry.map(Into::into),
            auto_renew_account_id: Option::from_protobuf(auto_renew_account)?,
            auto_renew_period: auto_renew_period.map(Into::into),
            token_memo: memo,
            token_type: TokenType::from_protobuf(token_type)?,
            token_supply_type: TokenSupplyType::from_protobuf(token_supply_type)?,
            max_supply: max_supply as u64,
            fee_schedule_key: Option::from_protobuf(fee_schedule_key)?,
            custom_fees: Vec::from_protobuf(custom_fees)?,
            pause_key: Option::from_protobuf(pause_key)?,
            metadata,
            metadata_key: Option::from_protobuf(metadata_key)?,
        })
    }
}

impl ToProtobuf for TokenCreateTransactionData {
    type Protobuf = services::TokenCreateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenCreateTransactionBody {
            name: self.name.clone(),
            symbol: self.symbol.clone(),
            decimals: self.decimals,
            initial_supply: self.initial_supply,
            treasury: self.treasury_account_id.to_protobuf(),
            admin_key: self.admin_key.to_protobuf(),
            kyc_key: self.kyc_key.to_protobuf(),
            freeze_key: self.freeze_key.to_protobuf(),
            wipe_key: self.wipe_key.to_protobuf(),
            supply_key: self.supply_key.to_protobuf(),
            freeze_default: self.freeze_default,
            expiry: self.expiration_time.map(Into::into),
            auto_renew_account: self.auto_renew_account_id.to_protobuf(),
            auto_renew_period: self.auto_renew_period.map(Into::into),
            memo: self.token_memo.clone(),
            token_type: self.token_type.to_protobuf().into(),
            supply_type: self.token_supply_type.to_protobuf().into(),
            max_supply: self.max_supply as i64,
            fee_schedule_key: self.fee_schedule_key.to_protobuf(),
            custom_fees: self.custom_fees.to_protobuf(),
            pause_key: self.pause_key.to_protobuf(),
            metadata: self.metadata.clone(),
            metadata_key: self.metadata_key.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use expect_test::expect_file;
    use hedera_proto::services;
    use time::OffsetDateTime;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenCreateTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
        VALID_START,
    };
    use crate::{
        AccountId,
        AnyCustomFee,
        AnyTransaction,
        FixedFee,
        FixedFeeData,
        Key,
        PublicKey,
        TokenCreateTransaction,
        TokenId,
        TokenSupplyType,
        TokenType,
    };

    const INITIAL_SUPPLY: u64 = 30;

    fn key() -> PublicKey {
        unused_private_key().public_key()
    }

    const AUTO_RENEW_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 123);
    const MAX_SUPPLY: u64 = 500;
    const AUTO_RENEW_PERIOD: time::Duration = time::Duration::seconds(100);
    const DECIMALS: u32 = 3;
    const FREEZE_DEFAULT: bool = true;
    const SYMBOL: &str = "K";
    const EXPIRATION_TIME: OffsetDateTime = VALID_START;
    const TREASURY_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 456);
    const NAME: &str = "Flook";
    const TOKEN_MEMO: &str = "Flook memo";
    const METADATA: &str = "Token Metadata";

    fn custom_fees() -> impl IntoIterator<Item = AnyCustomFee> {
        let fee = FixedFee {
            fee: FixedFeeData {
                amount: 3,
                denominating_token_id: Some(TokenId::from_str("0.0.543").unwrap()),
            },
            fee_collector_account_id: Some(AccountId::from_str("4.3.2").unwrap()),
            all_collectors_are_exempt: false,
        };

        std::iter::once(fee.into())
    }

    fn make_transaction() -> TokenCreateTransaction {
        let mut tx = TokenCreateTransaction::new_for_tests();

        tx.initial_supply(INITIAL_SUPPLY)
            .fee_schedule_key(key())
            .supply_key(key())
            .admin_key(key())
            .auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .decimals(3)
            .freeze_default(FREEZE_DEFAULT)
            .freeze_key(key())
            .wipe_key(key())
            .symbol(SYMBOL)
            .kyc_key(key())
            .pause_key(key())
            .expiration_time(EXPIRATION_TIME)
            .treasury_account_id(TREASURY_ACCOUNT_ID)
            .name(NAME)
            .token_memo(TOKEN_MEMO)
            .custom_fees(custom_fees())
            .metadata(METADATA.as_bytes().to_vec())
            .metadata_key(key())
            .freeze()
            .unwrap();

        tx
    }

    fn make_transaction_nft() -> TokenCreateTransaction {
        let mut tx = TokenCreateTransaction::new_for_tests();

        tx.fee_schedule_key(key())
            .supply_key(key())
            .max_supply(MAX_SUPPLY)
            .admin_key(key())
            .auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .token_type(TokenType::NonFungibleUnique)
            .token_supply_type(TokenSupplyType::Finite)
            .freeze_key(key())
            .wipe_key(key())
            .symbol(SYMBOL)
            .kyc_key(key())
            .pause_key(key())
            .expiration_time(EXPIRATION_TIME)
            .treasury_account_id(TREASURY_ACCOUNT_ID)
            .name(NAME)
            .token_memo(TOKEN_MEMO)
            .metadata(METADATA.as_bytes().to_vec())
            .metadata_key(key())
            .freeze()
            .unwrap();
        tx
    }

    #[test]
    fn serialize_fungible() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_create_transaction/serialize_fungible.txt"]
            .assert_debug_eq(&tx);
    }

    #[test]
    fn serialize_nft() {
        let tx = make_transaction_nft();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_create_transaction/serialize_nft.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes_nft() {
        let tx = make_transaction_nft();
        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();
        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);
        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenCreateTransactionBody {
            name: NAME.to_owned(),
            symbol: SYMBOL.to_owned(),
            decimals: DECIMALS as _,
            initial_supply: INITIAL_SUPPLY as _,
            treasury: Some(TREASURY_ACCOUNT_ID.to_protobuf()),
            admin_key: Some(key().to_protobuf()),
            kyc_key: Some(key().to_protobuf()),
            freeze_key: Some(key().to_protobuf()),
            wipe_key: Some(key().to_protobuf()),
            supply_key: Some(key().to_protobuf()),
            freeze_default: FREEZE_DEFAULT,
            expiry: Some(EXPIRATION_TIME.to_protobuf()),
            auto_renew_account: Some(AUTO_RENEW_ACCOUNT_ID.to_protobuf()),
            auto_renew_period: Some(AUTO_RENEW_PERIOD.to_protobuf()),
            memo: TOKEN_MEMO.to_owned(),
            token_type: services::TokenType::FungibleCommon as _,
            supply_type: services::TokenSupplyType::Infinite as _,
            max_supply: 0,
            fee_schedule_key: Some(key().to_protobuf()),
            custom_fees: custom_fees().into_iter().map(|it| it.to_protobuf()).collect(),
            pause_key: Some(key().to_protobuf()),
            metadata: METADATA.to_owned().into(),
            metadata_key: Some(key().to_protobuf()),
        };

        let data = TokenCreateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.name, NAME);
        assert_eq!(data.symbol, SYMBOL);
        assert_eq!(data.decimals, DECIMALS);
        assert_eq!(data.initial_supply, INITIAL_SUPPLY);
        assert_eq!(data.treasury_account_id, Some(TREASURY_ACCOUNT_ID));
        assert_eq!(data.admin_key, Some(key().into()));
        assert_eq!(data.kyc_key, Some(key().into()));
        assert_eq!(data.freeze_key, Some(key().into()));
        assert_eq!(data.wipe_key, Some(key().into()));
        assert_eq!(data.supply_key, Some(key().into()));
        assert_eq!(data.freeze_default, FREEZE_DEFAULT);
        assert_eq!(data.expiration_time, Some(EXPIRATION_TIME));
        assert_eq!(data.auto_renew_account_id, Some(AUTO_RENEW_ACCOUNT_ID));
        assert_eq!(data.auto_renew_period, Some(AUTO_RENEW_PERIOD));
        assert_eq!(data.token_memo, TOKEN_MEMO);
        assert_eq!(data.token_type, TokenType::FungibleCommon);
        assert_eq!(data.token_supply_type, TokenSupplyType::Infinite);
        assert_eq!(data.max_supply, 0);
        assert_eq!(data.fee_schedule_key, Some(key().into()));
        assert_eq!(data.custom_fees, Vec::from_iter(custom_fees()));
        assert_eq!(data.pause_key, Some(key().into()));
    }

    #[test]
    fn properties() {
        let tx = make_transaction();
        let key = &Key::Single(key());

        assert_eq!(tx.get_name(), NAME);
        assert_eq!(tx.get_symbol(), SYMBOL);
        assert_eq!(tx.get_token_memo(), TOKEN_MEMO);
        assert_eq!(tx.get_decimals(), DECIMALS);
        assert_eq!(tx.get_initial_supply(), INITIAL_SUPPLY);
        assert_eq!(tx.get_treasury_account_id(), Some(TREASURY_ACCOUNT_ID));
        assert_eq!(tx.get_admin_key(), Some(key));
        assert_eq!(tx.get_kyc_key(), Some(key));
        assert_eq!(tx.get_freeze_key(), Some(key));
        assert_eq!(tx.get_wipe_key(), Some(key));
        assert_eq!(tx.get_supply_key(), Some(key));
        assert_eq!(tx.get_fee_schedule_key(), Some(key));
        assert_eq!(tx.get_pause_key(), Some(key));
        assert_eq!(tx.get_freeze_default(), true);
        assert_eq!(tx.get_expiration_time(), Some(EXPIRATION_TIME));
        assert_eq!(tx.get_auto_renew_account_id(), Some(AUTO_RENEW_ACCOUNT_ID));
        assert_eq!(tx.get_auto_renew_period(), None);
        assert_eq!(tx.get_token_type(), TokenType::FungibleCommon);
        assert_eq!(tx.get_token_supply_type(), TokenSupplyType::Infinite);
        assert_eq!(tx.get_max_supply(), 0);
    }

    #[test]
    fn get_set_name() {
        let mut tx = TokenCreateTransaction::new();
        tx.name(NAME);

        assert_eq!(tx.get_name(), NAME);
    }
    #[test]
    #[should_panic]
    fn get_set_name_frozen_panics() {
        let mut tx = make_transaction();
        tx.name(NAME);
    }

    #[test]
    fn get_set_symbol() {
        let mut tx = TokenCreateTransaction::new();
        tx.symbol(SYMBOL);

        assert_eq!(tx.get_symbol(), SYMBOL);
    }
    #[test]
    #[should_panic]
    fn get_set_symbol_frozen_panics() {
        let mut tx = make_transaction();
        tx.symbol(SYMBOL);
    }

    #[test]
    fn get_set_decimals() {
        let mut tx = TokenCreateTransaction::new();
        tx.decimals(DECIMALS);

        assert_eq!(tx.get_decimals(), DECIMALS);
    }
    #[test]
    #[should_panic]
    fn get_set_decimals_frozen_panics() {
        let mut tx = make_transaction();
        tx.decimals(DECIMALS);
    }

    #[test]
    fn get_set_initial_supply() {
        let mut tx = TokenCreateTransaction::new();
        tx.initial_supply(INITIAL_SUPPLY);

        assert_eq!(tx.get_initial_supply(), INITIAL_SUPPLY);
    }

    #[test]
    #[should_panic]
    fn get_set_initial_supply_frozen_panics() {
        let mut tx = make_transaction();
        tx.initial_supply(INITIAL_SUPPLY);
    }

    #[test]
    fn get_set_treasury_account_id() {
        let mut tx = TokenCreateTransaction::new();
        tx.treasury_account_id(TREASURY_ACCOUNT_ID);

        assert_eq!(tx.get_treasury_account_id(), Some(TREASURY_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_treasury_account_id_frozen_panics() {
        let mut tx = make_transaction();
        tx.treasury_account_id(TREASURY_ACCOUNT_ID);
    }

    #[test]
    fn get_set_admin_key() {
        let mut tx = TokenCreateTransaction::new();
        tx.admin_key(key());

        assert_eq!(tx.get_admin_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_admin_key_frozen_panics() {
        let mut tx = make_transaction();
        tx.admin_key(key());
    }

    #[test]
    fn get_set_kyc_key() {
        let mut tx = TokenCreateTransaction::new();
        tx.kyc_key(key());

        assert_eq!(tx.get_kyc_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_kyc_key_frozen_panics() {
        let mut tx = make_transaction();
        tx.kyc_key(key());
    }

    #[test]
    fn get_set_freeze_key() {
        let mut tx = TokenCreateTransaction::new();
        tx.freeze_key(key());

        assert_eq!(tx.get_freeze_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_freeze_key_frozen_panics() {
        let mut tx = make_transaction();
        tx.freeze_key(key());
    }

    #[test]
    fn get_set_wipe_key() {
        let mut tx = TokenCreateTransaction::new();
        tx.wipe_key(key());

        assert_eq!(tx.get_wipe_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_wipe_key_frozen_panics() {
        let mut tx = make_transaction();
        tx.wipe_key(key());
    }

    #[test]
    fn get_set_supply_key() {
        let mut tx = TokenCreateTransaction::new();
        tx.supply_key(key());

        assert_eq!(tx.get_supply_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_supply_key_frozen_panics() {
        let mut tx = make_transaction();
        tx.supply_key(key());
    }

    #[test]
    fn get_set_freeze_default() {
        let mut tx = TokenCreateTransaction::new();
        tx.freeze_default(FREEZE_DEFAULT);

        assert_eq!(tx.get_freeze_default(), FREEZE_DEFAULT);
    }

    #[test]
    #[should_panic]
    fn get_set_freeze_default_frozen_panics() {
        let mut tx = make_transaction();
        tx.freeze_default(FREEZE_DEFAULT);
    }

    #[test]
    fn get_set_expiration_time() {
        let mut tx = TokenCreateTransaction::new();
        tx.expiration_time(EXPIRATION_TIME);

        assert_eq!(tx.get_expiration_time(), Some(EXPIRATION_TIME));
    }

    #[test]
    #[should_panic]
    fn get_set_expiration_time_frozen_panics() {
        let mut tx = make_transaction();
        tx.expiration_time(EXPIRATION_TIME);
    }

    #[test]
    fn get_set_auto_renew_account_id() {
        let mut tx = TokenCreateTransaction::new();
        tx.auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID);

        assert_eq!(tx.get_auto_renew_account_id(), Some(AUTO_RENEW_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_account_id_frozen_panics() {
        let mut tx = make_transaction();
        tx.auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID);
    }

    #[test]
    fn get_set_auto_renew_period() {
        let mut tx = TokenCreateTransaction::new();
        tx.auto_renew_period(AUTO_RENEW_PERIOD);

        assert_eq!(tx.get_auto_renew_period(), Some(AUTO_RENEW_PERIOD));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_period_frozen_panics() {
        let mut tx = make_transaction();
        tx.auto_renew_period(AUTO_RENEW_PERIOD);
    }

    #[test]
    fn get_set_token_memo() {
        let mut tx = TokenCreateTransaction::new();
        tx.token_memo(TOKEN_MEMO);

        assert_eq!(tx.get_token_memo(), TOKEN_MEMO);
    }

    #[test]
    #[should_panic]
    fn get_set_token_memo_frozen_panics() {
        let mut tx = make_transaction();
        tx.token_memo(TOKEN_MEMO);
    }

    #[test]
    fn get_set_token_type() {
        let mut tx = TokenCreateTransaction::new();
        tx.token_type(TokenType::NonFungibleUnique);

        assert_eq!(tx.get_token_type(), TokenType::NonFungibleUnique);
    }
    #[test]
    #[should_panic]
    fn get_set_token_type_frozen_panics() {
        let mut tx = make_transaction();
        tx.token_type(TokenType::NonFungibleUnique);
    }

    #[test]
    fn get_set_token_supply_type() {
        let mut tx = TokenCreateTransaction::new();
        tx.token_supply_type(TokenSupplyType::Finite);

        assert_eq!(tx.get_token_supply_type(), TokenSupplyType::Finite);
    }

    #[test]
    #[should_panic]
    fn get_set_token_supply_type_frozen_panics() {
        let mut tx = make_transaction();
        tx.token_supply_type(TokenSupplyType::Finite);
    }

    #[test]
    fn get_set_max_supply() {
        let mut tx = TokenCreateTransaction::new();
        tx.max_supply(MAX_SUPPLY);

        assert_eq!(tx.get_max_supply(), MAX_SUPPLY);
    }

    #[test]
    #[should_panic]
    fn get_set_max_supply_frozen_panics() {
        let mut tx = make_transaction();
        tx.max_supply(MAX_SUPPLY);
    }

    #[test]
    fn get_set_fee_schedule_key() {
        let mut tx = TokenCreateTransaction::new();
        tx.fee_schedule_key(key());

        assert_eq!(tx.get_fee_schedule_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_fee_schedule_key_frozen_panics() {
        let mut tx = make_transaction();
        tx.fee_schedule_key(key());
    }

    #[test]
    fn get_set_custom_fees() {
        let mut tx = TokenCreateTransaction::new();
        tx.custom_fees(custom_fees());

        assert_eq!(tx.get_custom_fees(), Vec::from_iter(custom_fees()));
    }

    #[test]
    #[should_panic]
    fn get_set_custom_fees_frozen_panics() {
        let mut tx = make_transaction();
        tx.custom_fees(custom_fees());
    }

    #[test]
    fn get_set_pause_key() {
        let mut tx = TokenCreateTransaction::new();
        tx.pause_key(key());

        assert_eq!(tx.get_pause_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_pause_key_frozen_panics() {
        let mut tx = make_transaction();
        tx.pause_key(key());
    }

    #[test]
    fn get_set_metadata() {
        let mut tx = TokenCreateTransaction::new();
        tx.metadata(METADATA.as_bytes().to_vec());
        assert_eq!(tx.get_metadata(), METADATA.as_bytes().to_vec());
    }

    #[test]
    #[should_panic]
    fn get_set_metadata_frozen_panic() {
        let mut tx = make_transaction();
        tx.metadata(METADATA.as_bytes().to_vec());
    }

    #[test]
    fn get_set_metadata_key() {
        let mut tx = TokenCreateTransaction::new();
        tx.metadata_key(key());
        assert_eq!(tx.get_metadata_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_metadata_key_frozen_panic() {
        let mut tx = make_transaction();
        tx.metadata_key(key());
    }
}
// Filename: src/token/token_delete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Marks a token as deleted, though it will remain in the ledger.
///
/// The operation must be signed by the specified Admin Key of the Token.
///
/// Once deleted update, mint, burn, wipe, freeze, unfreeze, grant kyc, revoke
/// kyc and token transfer transactions will resolve to `TOKEN_WAS_DELETED`.
///
/// - If admin key is not set, Transaction will result in `TOKEN_IS_IMMUTABlE`.
/// - If invalid token is specified, transaction will result in `INVALID_TOKEN_ID`
pub type TokenDeleteTransaction = Transaction<TokenDeleteTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenDeleteTransactionData {
    /// The token to be deleted.
    token_id: Option<TokenId>,
}

impl TokenDeleteTransaction {
    /// Returns the token to be deleted.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token to be deleted.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }
}

impl TransactionData for TokenDeleteTransactionData {}

impl TransactionExecute for TokenDeleteTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).delete_token(request).await })
    }
}

impl ValidateChecksums for TokenDeleteTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenDeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenDeletion(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenDeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenDeletion(self.to_protobuf())
    }
}

impl From<TokenDeleteTransactionData> for AnyTransactionData {
    fn from(transaction: TokenDeleteTransactionData) -> Self {
        Self::TokenDelete(transaction)
    }
}

impl FromProtobuf<services::TokenDeleteTransactionBody> for TokenDeleteTransactionData {
    fn from_protobuf(pb: services::TokenDeleteTransactionBody) -> crate::Result<Self> {
        Ok(Self { token_id: Option::from_protobuf(pb.token)? })
    }
}

impl ToProtobuf for TokenDeleteTransactionData {
    type Protobuf = services::TokenDeleteTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenDeleteTransactionBody { token: self.token_id.to_protobuf() }
    }
}

#[cfg(test)]
mod tests {

    use expect_test::expect_file;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenDeleteTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        TEST_TOKEN_ID,
    };
    use crate::{
        AnyTransaction,
        TokenDeleteTransaction,
    };

    fn make_transaction() -> TokenDeleteTransaction {
        let mut tx = TokenDeleteTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn seriralize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_delete_transaction/serialize.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenDeleteTransactionBody { token: Some(TEST_TOKEN_ID.to_protobuf()) };

        let data = TokenDeleteTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.token_id, Some(TEST_TOKEN_ID));
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenDeleteTransaction::new();

        let tx2 = tx.token_id(TEST_TOKEN_ID);

        assert_eq!(tx2.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        let mut tx = make_transaction();

        tx.token_id(TEST_TOKEN_ID);
    }
}
// Filename: src/token/token_dissociate_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Dissociates the provided account with the provided tokens. Must be signed by the provided
/// Account's key.
///
/// On success, associations between the provided account and tokens are removed.
///
/// - If the provided account is not found, the transaction will resolve to `INVALID_ACCOUNT_ID`.
/// - If the provided account has been deleted, the transaction will resolve to `ACCOUNT_DELETED`.
/// - If any of the provided tokens is not found, the transaction will resolve to `INVALID_TOKEN_REF`.
/// - If any of the provided tokens has been deleted, the transaction will resolve to `TOKEN_WAS_DELETED`.
/// - If an association between the provided account and any of the tokens does not exist, the
/// transaction will resolve to `TOKEN_NOT_ASSOCIATED_TO_ACCOUNT`.
/// - If a token has not been deleted and has not expired, and the user has a nonzero balance, the
/// transaction will resolve to `TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES`.
/// - If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is
/// not zero.
/// - If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token
/// balance is not zero. The transaction will resolve to `TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES`.
pub type TokenDissociateTransaction = Transaction<TokenDissociateTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenDissociateTransactionData {
    /// The account to be dissociated with the provided tokens.
    account_id: Option<AccountId>,

    /// The tokens to be dissociated with the provided account.
    token_ids: Vec<TokenId>,
}

impl TokenDissociateTransaction {
    /// Returns the account to be dissociated with the provided tokens.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the account to be dissociated with the provided tokens.
    pub fn account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(account_id);
        self
    }

    /// Returns the tokens to be dissociated with the provided account.
    #[must_use]
    pub fn get_token_ids(&self) -> &[TokenId] {
        &self.data().token_ids
    }

    /// Sets the tokens to be dissociated with the provided account.
    pub fn token_ids(&mut self, token_ids: impl IntoIterator<Item = TokenId>) -> &mut Self {
        self.data_mut().token_ids = token_ids.into_iter().collect();
        self
    }
}

impl TransactionData for TokenDissociateTransactionData {}

impl TransactionExecute for TokenDissociateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).dissociate_tokens(request).await })
    }
}

impl ValidateChecksums for TokenDissociateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)?;
        for token_id in &self.token_ids {
            token_id.validate_checksums(ledger_id)?;
        }
        Ok(())
    }
}

impl ToTransactionDataProtobuf for TokenDissociateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenDissociate(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenDissociateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenDissociate(self.to_protobuf())
    }
}

impl From<TokenDissociateTransactionData> for AnyTransactionData {
    fn from(transaction: TokenDissociateTransactionData) -> Self {
        Self::TokenDissociate(transaction)
    }
}

impl FromProtobuf<services::TokenDissociateTransactionBody> for TokenDissociateTransactionData {
    fn from_protobuf(pb: services::TokenDissociateTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            account_id: Option::from_protobuf(pb.account)?,
            token_ids: Vec::from_protobuf(pb.tokens)?,
        })
    }
}

impl ToProtobuf for TokenDissociateTransactionData {
    type Protobuf = services::TokenDissociateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let account = self.account_id.to_protobuf();
        let tokens = self.token_ids.to_protobuf();

        services::TokenDissociateTransactionBody { account, tokens }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenDissociateTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        TokenDissociateTransaction,
        TokenId,
    };

    const TEST_ACCOUNT_ID: AccountId =
        AccountId { shard: 6, realm: 9, num: 0, alias: None, evm_address: None, checksum: None };

    const TEST_TOKEN_IDS: [TokenId; 3] =
        [TokenId::new(4, 2, 0), TokenId::new(4, 2, 1), TokenId::new(4, 2, 2)];

    fn make_transaction() -> TokenDissociateTransaction {
        let mut tx = TokenDissociateTransaction::new_for_tests();

        tx.account_id(TEST_ACCOUNT_ID).token_ids(TEST_TOKEN_IDS).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenDissociate(
                TokenDissociateTransactionBody {
                    account: Some(
                        AccountId {
                            shard_num: 6,
                            realm_num: 9,
                            account: Some(
                                AccountNum(
                                    0,
                                ),
                            ),
                        },
                    ),
                    tokens: [
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 0,
                        },
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 1,
                        },
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 2,
                        },
                    ],
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenDissociateTransactionBody {
            account: Some(TEST_ACCOUNT_ID.to_protobuf()),
            tokens: TEST_TOKEN_IDS.iter().map(TokenId::to_protobuf).collect(),
        };

        let data = TokenDissociateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.account_id, Some(TEST_ACCOUNT_ID));
        assert_eq!(data.token_ids, TEST_TOKEN_IDS);
    }

    #[test]
    fn get_set_account_id() {
        let mut tx = TokenDissociateTransaction::new();
        tx.account_id(TEST_ACCOUNT_ID);

        assert_eq!(tx.get_account_id(), Some(TEST_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panic() {
        make_transaction().account_id(TEST_ACCOUNT_ID);
    }

    #[test]
    fn get_set_token_ids() {
        let mut tx = TokenDissociateTransaction::new();
        tx.token_ids(TEST_TOKEN_IDS);

        assert_eq!(tx.get_token_ids(), &TEST_TOKEN_IDS);
    }

    #[test]
    #[should_panic]
    fn get_set_token_ids_frozen_panic() {
        make_transaction().token_ids(TEST_TOKEN_IDS);
    }
}
// Filename: src/token/token_fee_schedule_update_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::token::custom_fees::AnyCustomFee;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// At consensus, updates a token type's fee schedule to the given list of custom fees.
///
/// If the target token type has no `fee_schedule_key`, resolves to `TokenHasNoFeeScheduleKey`.
/// Otherwise this transaction must be signed to the `fee_schedule_key`, or the transaction will
/// resolve to `InvalidSignature`.
///
/// If the `custom_fees` list is empty, clears the fee schedule or resolves to
/// `CustomScheduleAlreadyHasNoFees` if the fee schedule was already empty.
pub type TokenFeeScheduleUpdateTransaction = Transaction<TokenFeeScheduleUpdateTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenFeeScheduleUpdateTransactionData {
    /// The token whose fee schedule is to be updated.
    token_id: Option<TokenId>,

    /// The new custom fees to be assessed during a transfer.
    custom_fees: Vec<AnyCustomFee>,
}

impl TokenFeeScheduleUpdateTransaction {
    /// Returns the ID of the token that's being updated.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    // note(sr): what is being updated is implicit.
    /// Sets the ID of the token that's being updated.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }

    /// Returns the new custom fees to be assessed during a transfer.
    #[must_use]
    pub fn get_custom_fees(&self) -> &[AnyCustomFee] {
        &self.data().custom_fees
    }

    /// Sets the new custom fees to be assessed during a transfer.
    pub fn custom_fees(
        &mut self,
        custom_fees: impl IntoIterator<Item = AnyCustomFee>,
    ) -> &mut Self {
        self.data_mut().custom_fees = custom_fees.into_iter().collect();
        self
    }
}

impl TransactionData for TokenFeeScheduleUpdateTransactionData {}

impl TransactionExecute for TokenFeeScheduleUpdateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async {
            TokenServiceClient::new(channel).update_token_fee_schedule(request).await
        })
    }
}

impl ValidateChecksums for TokenFeeScheduleUpdateTransactionData {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        // TODO: validate custom fees (they need an impl)
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenFeeScheduleUpdateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenFeeScheduleUpdate(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenFeeScheduleUpdateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenFeeScheduleUpdate(self.to_protobuf())
    }
}

impl From<TokenFeeScheduleUpdateTransactionData> for AnyTransactionData {
    fn from(transaction: TokenFeeScheduleUpdateTransactionData) -> Self {
        Self::TokenFeeScheduleUpdate(transaction)
    }
}

impl FromProtobuf<services::TokenFeeScheduleUpdateTransactionBody>
    for TokenFeeScheduleUpdateTransactionData
{
    fn from_protobuf(pb: services::TokenFeeScheduleUpdateTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            token_id: Option::from_protobuf(pb.token_id)?,
            custom_fees: Vec::from_protobuf(pb.custom_fees)?,
        })
    }
}

impl ToProtobuf for TokenFeeScheduleUpdateTransactionData {
    type Protobuf = services::TokenFeeScheduleUpdateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenFeeScheduleUpdateTransactionBody {
            token_id: self.token_id.to_protobuf(),
            custom_fees: self.custom_fees.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenFeeScheduleUpdateTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyCustomFee,
        AnyTransaction,
        FixedFee,
        FractionalFee,
        TokenFeeScheduleUpdateTransaction,
        TokenId,
    };

    const TOKEN_ID: TokenId = TokenId::new(0, 0, 8798);

    fn custom_fees() -> [AnyCustomFee; 2] {
        [
            FixedFee {
                fee: crate::FixedFeeData {
                    amount: 10,
                    denominating_token_id: Some(TokenId::new(0, 0, 483902)),
                },
                fee_collector_account_id: Some("4322".parse().unwrap()),
                all_collectors_are_exempt: false,
            }
            .into(),
            FractionalFee {
                fee: crate::FractionalFeeData {
                    denominator: 7,
                    numerator: 3,
                    minimum_amount: 3,
                    maximum_amount: 100,
                    assessment_method: crate::FeeAssessmentMethod::Exclusive,
                },
                fee_collector_account_id: Some("389042".parse().unwrap()),
                all_collectors_are_exempt: false,
            }
            .into(),
        ]
    }

    fn make_transaction() -> TokenFeeScheduleUpdateTransaction {
        let mut tx = TokenFeeScheduleUpdateTransaction::new_for_tests();

        tx.token_id(TOKEN_ID).custom_fees(custom_fees()).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenFeeScheduleUpdate(
                TokenFeeScheduleUpdateTransactionBody {
                    token_id: Some(
                        TokenId {
                            shard_num: 0,
                            realm_num: 0,
                            token_num: 8798,
                        },
                    ),
                    custom_fees: [
                        CustomFee {
                            fee_collector_account_id: Some(
                                AccountId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    account: Some(
                                        AccountNum(
                                            4322,
                                        ),
                                    ),
                                },
                            ),
                            all_collectors_are_exempt: false,
                            fee: Some(
                                FixedFee(
                                    FixedFee {
                                        amount: 10,
                                        denominating_token_id: Some(
                                            TokenId {
                                                shard_num: 0,
                                                realm_num: 0,
                                                token_num: 483902,
                                            },
                                        ),
                                    },
                                ),
                            ),
                        },
                        CustomFee {
                            fee_collector_account_id: Some(
                                AccountId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    account: Some(
                                        AccountNum(
                                            389042,
                                        ),
                                    ),
                                },
                            ),
                            all_collectors_are_exempt: false,
                            fee: Some(
                                FractionalFee(
                                    FractionalFee {
                                        fractional_amount: Some(
                                            Fraction {
                                                numerator: 3,
                                                denominator: 7,
                                            },
                                        ),
                                        minimum_amount: 3,
                                        maximum_amount: 100,
                                        net_of_transfers: true,
                                    },
                                ),
                            ),
                        },
                    ],
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenFeeScheduleUpdateTransactionBody {
            token_id: Some(TOKEN_ID.to_protobuf()),
            custom_fees: custom_fees().to_vec().to_protobuf(),
        };

        let data = TokenFeeScheduleUpdateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.token_id, Some(TOKEN_ID));
        assert_eq!(data.custom_fees, custom_fees());
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenFeeScheduleUpdateTransaction::new();
        tx.token_id(TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        make_transaction().token_id(TOKEN_ID);
    }

    #[test]
    fn get_set_custom_fees() {
        let mut tx = TokenFeeScheduleUpdateTransaction::new();
        tx.custom_fees(custom_fees());

        assert_eq!(tx.get_custom_fees(), custom_fees());
    }

    #[test]
    #[should_panic]
    fn get_set_custom_fees_frozen_panic() {
        make_transaction().custom_fees(custom_fees());
    }
}
// Filename: src/token/token_freeze_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Freezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.
///
/// Once executed the Account is marked as Frozen and will not be able to receive or send tokens
/// unless unfrozen. The operation is idempotent.
///
/// - If the provided account is not found, the transaction will resolve to `INVALID_ACCOUNT_ID`.
/// - If the provided account has been deleted, the transaction will resolve to `ACCOUNT_DELETED`.
/// - If the provided token is not found, the transaction will resolve to `INVALID_TOKEN_ID`.
/// - If the provided token has been deleted, the transaction will resolve to `TOKEN_WAS_DELETED`.
/// - If an Association between the provided token and account is not found, the transaction will
/// resolve to `TOKEN_NOT_ASSOCIATED_TO_ACCOUNT`.
/// - If no Freeze Key is defined, the transaction will resolve to `TOKEN_HAS_NO_FREEZE_KEY`.
pub type TokenFreezeTransaction = Transaction<TokenFreezeTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenFreezeTransactionData {
    /// The account to be frozen.
    account_id: Option<AccountId>,

    /// The token for which this account will be frozen.
    token_id: Option<TokenId>,
}

impl TokenFreezeTransaction {
    /// Returns the account to be frozen.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the account to be frozen.
    pub fn account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(account_id);
        self
    }

    /// Returns the toke nfor which the account will be frozen.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token for which the account will be frozen.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }
}

impl TransactionData for TokenFreezeTransactionData {}

impl TransactionExecute for TokenFreezeTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).freeze_token_account(request).await })
    }
}

impl ValidateChecksums for TokenFreezeTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)?;
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenFreezeTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenFreeze(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenFreezeTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenFreeze(self.to_protobuf())
    }
}

impl From<TokenFreezeTransactionData> for AnyTransactionData {
    fn from(transaction: TokenFreezeTransactionData) -> Self {
        Self::TokenFreeze(transaction)
    }
}

impl FromProtobuf<services::TokenFreezeAccountTransactionBody> for TokenFreezeTransactionData {
    fn from_protobuf(pb: services::TokenFreezeAccountTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            account_id: Option::from_protobuf(pb.account)?,
            token_id: Option::from_protobuf(pb.token)?,
        })
    }
}

impl ToProtobuf for TokenFreezeTransactionData {
    type Protobuf = services::TokenFreezeAccountTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let account = self.account_id.to_protobuf();
        let token = self.token_id.to_protobuf();

        services::TokenFreezeAccountTransactionBody { token, account }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenFreezeTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        TokenFreezeTransaction,
        TokenId,
    };

    const ACCOUNT_ID: AccountId = AccountId::new(0, 0, 222);

    const TOKEN_ID: TokenId = TokenId::new(5, 3, 3);

    fn make_transaction() -> TokenFreezeTransaction {
        let mut tx = TokenFreezeTransaction::new_for_tests();

        tx.account_id(ACCOUNT_ID).token_id(TOKEN_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenFreeze(
                TokenFreezeAccountTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 5,
                            realm_num: 3,
                            token_num: 3,
                        },
                    ),
                    account: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    222,
                                ),
                            ),
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenFreezeAccountTransactionBody {
            account: Some(ACCOUNT_ID.to_protobuf()),
            token: Some(TOKEN_ID.to_protobuf()),
        };

        let data = TokenFreezeTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.account_id, Some(ACCOUNT_ID));
        assert_eq!(data.token_id, Some(TOKEN_ID));
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenFreezeTransaction::new();
        tx.token_id(TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        make_transaction().token_id(TOKEN_ID);
    }

    #[test]
    fn get_set_account_id() {
        let mut tx = TokenFreezeTransaction::new();
        tx.account_id(ACCOUNT_ID);

        assert_eq!(tx.get_account_id(), Some(ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panic() {
        make_transaction().account_id(ACCOUNT_ID);
    }
}
// Filename: src/token/token_grant_kyc_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Grants KYC to the account for the given token. Must be signed by the Token's kycKey.
///
/// Once executed the Account is marked as KYC Granted.
///
/// - If the provided account is not found, the transaction will resolve to `INVALID_ACCOUNT_ID`.
/// - If the provided account has been deleted, the transaction will resolve to `ACCOUNT_DELETED`.
/// - If the provided token is not found, the transaction will resolve to `INVALID_TOKEN_ID`.
/// - If the provided token has been deleted, the transaction will resolve to `TOKEN_WAS_DELETED`.
/// - If an Association between the provided token and account is not found, the transaction will
/// resolve to `TOKEN_NOT_ASSOCIATED_TO_ACCOUNT`.
/// - If no KYC Key is defined, the transaction will resolve to `TOKEN_HAS_NO_KYC_KEY`.
pub type TokenGrantKycTransaction = Transaction<TokenGrantKycTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenGrantKycTransactionData {
    /// The account to be granted KYC.
    account_id: Option<AccountId>,

    /// The token for which this account will be granted KYC.
    token_id: Option<TokenId>,
}

impl TokenGrantKycTransaction {
    /// Returns the account to be granted KYC.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the account to be granted KYC.
    pub fn account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(account_id);
        self
    }

    /// Returns the token for which the account will be granted KYC.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token for which the account will be granted KYC.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }
}

impl TransactionData for TokenGrantKycTransactionData {}

impl TransactionExecute for TokenGrantKycTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async {
            TokenServiceClient::new(channel).grant_kyc_to_token_account(request).await
        })
    }
}

impl ValidateChecksums for TokenGrantKycTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)?;
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenGrantKycTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenGrantKyc(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenGrantKycTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenGrantKyc(self.to_protobuf())
    }
}

impl From<TokenGrantKycTransactionData> for AnyTransactionData {
    fn from(transaction: TokenGrantKycTransactionData) -> Self {
        Self::TokenGrantKyc(transaction)
    }
}

impl FromProtobuf<services::TokenGrantKycTransactionBody> for TokenGrantKycTransactionData {
    fn from_protobuf(pb: services::TokenGrantKycTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            account_id: Option::from_protobuf(pb.account)?,
            token_id: Option::from_protobuf(pb.token)?,
        })
    }
}

impl ToProtobuf for TokenGrantKycTransactionData {
    type Protobuf = services::TokenGrantKycTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenGrantKycTransactionBody {
            token: self.token_id.to_protobuf(),
            account: self.account_id.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenGrantKycTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        TokenGrantKycTransaction,
        TokenId,
    };

    const TEST_TOKEN_ID: TokenId = TokenId::new(4, 2, 0);
    const TEST_ACCOUNT_ID: AccountId =
        AccountId { shard: 6, realm: 9, num: 0, alias: None, evm_address: None, checksum: None };

    fn make_transaction() -> TokenGrantKycTransaction {
        let mut tx = TokenGrantKycTransaction::new_for_tests();

        tx.account_id(TEST_ACCOUNT_ID).token_id(TEST_TOKEN_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenGrantKyc(
                TokenGrantKycTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 0,
                        },
                    ),
                    account: Some(
                        AccountId {
                            shard_num: 6,
                            realm_num: 9,
                            account: Some(
                                AccountNum(
                                    0,
                                ),
                            ),
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenGrantKycTransactionBody {
            account: Some(TEST_ACCOUNT_ID.to_protobuf()),
            token: Some(TEST_TOKEN_ID.to_protobuf()),
        };

        let data = TokenGrantKycTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.account_id, Some(TEST_ACCOUNT_ID));
        assert_eq!(data.token_id, Some(TEST_TOKEN_ID));
    }

    #[test]
    fn get_set_account_id() {
        let mut tx = TokenGrantKycTransaction::new();

        tx.account_id(TEST_ACCOUNT_ID);

        assert_eq!(tx.get_account_id(), Some(TEST_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panic() {
        let mut tx = make_transaction();

        tx.account_id(TEST_ACCOUNT_ID);
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenGrantKycTransaction::new();

        tx.token_id(TEST_TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        let mut tx = make_transaction();

        tx.token_id(TEST_TOKEN_ID);
    }
}
// Filename: src/token/token_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use hedera_proto::services;

use crate::entity_id::{
    Checksum,
    ValidateChecksums,
};
use crate::{
    Client,
    EntityId,
    Error,
    FromProtobuf,
    NftId,
    ToProtobuf,
};

/// The unique identifier for a token on Hiero.
#[derive(Hash, PartialEq, Eq, Clone, Copy)]
pub struct TokenId {
    /// A non-negative number identifying the shard containing this token.
    pub shard: u64,

    /// A non-negative number identifying the realm within the shard containing this token.
    pub realm: u64,

    /// A non-negative number identifying the entity within the realm containing this token.
    pub num: u64,

    /// A checksum if the token ID was read from a user inputted string which inclueded a checksum
    pub checksum: Option<Checksum>,
}

impl TokenId {
    /// Create a `TokenId` from the given `shard`, `realm`, and `num`.
    #[must_use]
    pub const fn new(shard: u64, realm: u64, num: u64) -> Self {
        Self { shard, realm, num, checksum: None }
    }

    /// Create a new `TokenId` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Create a `TokenId` from a solidity address.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `address` cannot be parsed as a solidity address.
    pub fn from_solidity_address(address: &str) -> crate::Result<Self> {
        let EntityId { shard, realm, num, checksum } = EntityId::from_solidity_address(address)?;

        Ok(Self { shard, realm, num, checksum })
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }

    /// Convert `self` into a solidity `address`.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `self.shard` is larger than `u32::MAX`.
    pub fn to_solidity_address(&self) -> crate::Result<String> {
        EntityId { shard: self.shard, realm: self.realm, num: self.num, checksum: None }
            .to_solidity_address()
    }

    /// Convert `self` to a string with a valid checksum.
    #[must_use]
    pub fn to_string_with_checksum(&self, client: &Client) -> String {
        EntityId::to_string_with_checksum(self.to_string(), client)
    }

    /// Validates `self.checksum` (if it exists) for `client`.
    ///
    /// # Errors
    /// - [`Error::BadEntityId`] if there is a checksum, and the checksum is not valid for the client's `ledger_id`.
    pub fn validate_checksum(&self, client: &Client) -> crate::Result<()> {
        EntityId::validate_checksum(self.shard, self.realm, self.num, self.checksum, client)
    }

    /// Create an NFT ID
    #[must_use]
    pub fn nft(&self, serial: u64) -> NftId {
        NftId { token_id: *self, serial }
    }
}

impl ValidateChecksums for TokenId {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        EntityId::validate_checksum_for_ledger_id(
            self.shard,
            self.realm,
            self.num,
            self.checksum,
            ledger_id,
        )
    }
}

impl Debug for TokenId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for TokenId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}.{}.{}", self.shard, self.realm, self.num)
    }
}

impl FromProtobuf<services::TokenId> for TokenId {
    fn from_protobuf(pb: services::TokenId) -> crate::Result<Self> {
        Ok(Self {
            num: pb.token_num as u64,
            shard: pb.shard_num as u64,
            realm: pb.realm_num as u64,
            checksum: None,
        })
    }
}

impl ToProtobuf for TokenId {
    type Protobuf = services::TokenId;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenId {
            token_num: self.num as i64,
            realm_num: self.realm as i64,
            shard_num: self.shard as i64,
        }
    }
}

impl From<u64> for TokenId {
    fn from(num: u64) -> Self {
        Self { num, shard: 0, realm: 0, checksum: None }
    }
}

impl FromStr for TokenId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        EntityId::from_str(s).map(Self::from)
    }
}

impl From<EntityId> for TokenId {
    fn from(value: EntityId) -> Self {
        let EntityId { shard, realm, num, checksum } = value;

        Self { shard, realm, num, checksum }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use expect_test::expect;

    use crate::TokenId;

    #[test]
    fn parse() {
        expect!["0.0.5005"].assert_eq(&TokenId::from_str("0.0.5005").unwrap().to_string());
    }

    #[test]
    fn from_bytes() {
        expect!["0.0.5005"].assert_eq(
            &TokenId::from_bytes(&TokenId::new(0, 0, 5005).to_bytes()).unwrap().to_string(),
        );
    }

    #[test]
    fn from_solidity_address() {
        expect!["0.0.5005"].assert_eq(
            &TokenId::from_solidity_address("000000000000000000000000000000000000138D")
                .unwrap()
                .to_string(),
        );
    }

    #[test]
    fn to_solidity_address() {
        expect!["000000000000000000000000000000000000138d"]
            .assert_eq(&TokenId::new(0, 0, 5005).to_solidity_address().unwrap());
    }
}
// Filename: src/token/token_info.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::{
    TokenFreezeStatus,
    TokenKycStatus,
    TokenPauseStatus,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::protobuf::ToProtobuf;
use crate::token::custom_fees::AnyCustomFee;
use crate::{
    AccountId,
    FromProtobuf,
    Key,
    LedgerId,
    TokenId,
    TokenSupplyType,
    TokenType,
};

/// Response from [`TokenInfoQuery`][crate::TokenInfoQuery].
#[derive(Debug, Clone)]
pub struct TokenInfo {
    /// The ID of the token for which information is requested.
    pub token_id: TokenId,

    /// Name of token.
    pub name: String,

    /// Symbol of token.
    pub symbol: String,

    /// The amount of decimal places that this token supports.
    pub decimals: u32,

    /// Total Supply of token.
    pub total_supply: u64,

    /// The ID of the account which is set as Treasury.
    pub treasury_account_id: AccountId,

    /// The key which can perform update/delete operations on the token.
    pub admin_key: Option<Key>,

    /// The key which can grant or revoke KYC of an account for the token's transactions.
    pub kyc_key: Option<Key>,

    /// The key which can freeze or unfreeze an account for token transactions.
    pub freeze_key: Option<Key>,

    /// The key which can wipe token balance of an account.
    pub wipe_key: Option<Key>,

    /// The key which can change the supply of a token.
    pub supply_key: Option<Key>,

    /// The key which can change the custom fees of the token.
    pub fee_schedule_key: Option<Key>,

    /// The default Freeze status (not applicable, frozen or unfrozen)
    pub default_freeze_status: Option<bool>,

    /// The default KYC status (KycNotApplicable or Revoked) of Hiero accounts relative to this token.
    pub default_kyc_status: Option<bool>,

    /// Specifies whether the token was deleted or not.
    pub is_deleted: bool,

    /// An account which will be automatically charged to renew the token's expiration,
    /// at autoRenewPeriod interval.
    pub auto_renew_account: Option<AccountId>,

    /// The interval at which the auto-renew account will be charged to extend the token's expiry
    pub auto_renew_period: Option<Duration>,

    /// The epoch second at which the token will expire
    pub expiration_time: Option<OffsetDateTime>,

    /// The memo associated with the token
    pub token_memo: String,

    /// The token type.
    pub token_type: TokenType,

    /// The token supply type
    pub supply_type: TokenSupplyType,

    /// The Maximum number of tokens that can be in circulation.
    pub max_supply: u64,

    /// The custom fees to be assessed during a transfer that transfers units of this token.
    pub custom_fees: Vec<AnyCustomFee>,

    /// The Key which can pause and unpause the Token.
    pub pause_key: Option<Key>,

    /// Specifies whether the token is paused or not.
    pub pause_status: Option<bool>,

    /// The ledger ID the response was returned from.
    pub ledger_id: LedgerId,

    /// Represents the metadata of the token definition.
    pub metadata: Vec<u8>,

    /// The key which can change the metadata of a token
    /// (token definition and individual NFTs).
    pub metadata_key: Option<Key>,
}

impl TokenInfo {
    /// Create a new `TokenInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::TokenInfo>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::response::Response> for TokenInfo {
    #[allow(deprecated)]
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let response = pb_getv!(pb, TokenGetInfo, services::response::Response);
        let info = pb_getf!(response, token_info)?;
        Self::from_protobuf(info)
    }
}

impl FromProtobuf<services::TokenInfo> for TokenInfo {
    fn from_protobuf(pb: services::TokenInfo) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let token_type = TokenType::from_protobuf(pb.token_type())?;
        let token_supply_type = TokenSupplyType::from_protobuf(pb.supply_type())?;
        let token_id = pb_getf!(pb, token_id)?;

        let default_kyc_status = match pb.default_kyc_status() {
            TokenKycStatus::KycNotApplicable => None,
            TokenKycStatus::Granted => Some(true),
            TokenKycStatus::Revoked => Some(false),
        };

        let default_freeze_status = match pb.default_freeze_status() {
            TokenFreezeStatus::FreezeNotApplicable => None,
            TokenFreezeStatus::Frozen => Some(true),
            TokenFreezeStatus::Unfrozen => Some(false),
        };

        let pause_status = match pb.pause_status() {
            TokenPauseStatus::PauseNotApplicable => None,
            TokenPauseStatus::Paused => Some(true),
            TokenPauseStatus::Unpaused => Some(false),
        };

        let auto_renew_account_id = Option::from_protobuf(pb.auto_renew_account)?;

        let treasury_account_id = pb_getf!(pb, treasury)?;
        let ledger_id = LedgerId::from_bytes(pb.ledger_id);

        let expiry = if let Some(expiry) = pb.expiry {
            // Hack to handle the case where None expiry is -9223372036854775808
            if expiry.seconds == -9223372036854775808 {
                None
            } else {
                expiry.into()
            }
        } else {
            None
        };

        Ok(Self {
            token_id: TokenId::from_protobuf(token_id)?,
            name: pb.name,
            symbol: pb.symbol,
            decimals: pb.decimals,
            total_supply: pb.total_supply,
            treasury_account_id: AccountId::from_protobuf(treasury_account_id)?,
            admin_key: Option::from_protobuf(pb.admin_key)?,
            kyc_key: Option::from_protobuf(pb.kyc_key)?,
            freeze_key: Option::from_protobuf(pb.freeze_key)?,
            wipe_key: Option::from_protobuf(pb.wipe_key)?,
            supply_key: Option::from_protobuf(pb.supply_key)?,
            default_freeze_status,
            default_kyc_status,
            is_deleted: pb.deleted,
            auto_renew_account: auto_renew_account_id,
            auto_renew_period: pb.auto_renew_period.map(Into::into),
            expiration_time: expiry.map(Into::into),
            token_memo: pb.memo,
            token_type,
            supply_type: token_supply_type,
            max_supply: pb.max_supply as u64,
            fee_schedule_key: Option::from_protobuf(pb.fee_schedule_key)?,
            custom_fees: Vec::from_protobuf(pb.custom_fees)?, //test this
            pause_key: Option::from_protobuf(pb.pause_key)?,
            pause_status,
            ledger_id,
            metadata: pb.metadata,
            metadata_key: Option::from_protobuf(pb.metadata_key)?,
        })
    }
}

impl ToProtobuf for TokenInfo {
    type Protobuf = services::TokenInfo;

    fn to_protobuf(&self) -> Self::Protobuf {
        let default_freeze_status = match self.default_freeze_status {
            Some(true) => TokenFreezeStatus::Frozen as i32,
            Some(false) => TokenFreezeStatus::Unfrozen as i32,
            None => TokenFreezeStatus::FreezeNotApplicable as i32,
        };

        let default_kyc_status = match self.default_kyc_status {
            Some(true) => TokenKycStatus::Granted as i32,
            Some(false) => TokenKycStatus::Revoked as i32,
            None => TokenKycStatus::KycNotApplicable as i32,
        };

        services::TokenInfo {
            token_id: Some(self.token_id.to_protobuf()),
            name: self.name.clone(),
            symbol: self.symbol.clone(),
            decimals: self.decimals,
            total_supply: self.total_supply,
            treasury: Some(self.treasury_account_id.to_protobuf()),
            admin_key: self.admin_key.to_protobuf(),
            kyc_key: self.kyc_key.to_protobuf(),
            freeze_key: self.freeze_key.to_protobuf(),
            wipe_key: self.wipe_key.to_protobuf(),
            supply_key: self.supply_key.to_protobuf(),
            default_freeze_status,
            default_kyc_status,
            deleted: self.is_deleted,
            auto_renew_account: self.auto_renew_account.to_protobuf(),
            auto_renew_period: self.auto_renew_period.to_protobuf(),
            expiry: self.expiration_time.to_protobuf(),
            memo: self.token_memo.clone(),
            token_type: self.token_type.to_protobuf() as i32,
            supply_type: self.supply_type.to_protobuf() as i32,
            max_supply: self.max_supply as i64,
            fee_schedule_key: self.fee_schedule_key.to_protobuf(),
            custom_fees: self.custom_fees.to_protobuf(),
            pause_key: self.pause_key.to_protobuf(),
            pause_status: match self.pause_status {
                Some(true) => TokenPauseStatus::Paused as i32,
                Some(false) => TokenPauseStatus::Unpaused as i32,
                None => TokenPauseStatus::PauseNotApplicable as i32,
            },
            ledger_id: self.ledger_id.to_bytes(),
            metadata: self.metadata.clone(),
            metadata_key: self.metadata_key.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use expect_test::expect_file;
    use time::{
        Duration,
        OffsetDateTime,
    };

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::{
        FixedFee,
        FractionalFee,
        LedgerId,
        PrivateKey,
        TokenId,
        TokenInfo,
        TokenSupplyType,
        TokenType,
    };

    fn metadata() -> Vec<u8> {
        [1, 2, 3, 4, 5].to_vec()
    }

    fn make_token_info() -> TokenInfo {
        let custom_fees = [
            FixedFee {
                fee_collector_account_id: Some("4322".parse().unwrap()),
                all_collectors_are_exempt: false,
                fee: crate::FixedFeeData {
                    amount: 10,
                    denominating_token_id: Some(TokenId::new(0, 0, 483902)),
                },
            }
            .into(),
            FractionalFee {
                fee_collector_account_id: Some("389042".parse().unwrap()),
                all_collectors_are_exempt: false,
                fee: crate::FractionalFeeData {
                    denominator: 7,
                    numerator: 3,
                    minimum_amount: 3,
                    maximum_amount: 100,
                    assessment_method: crate::FeeAssessmentMethod::Inclusive,
                },
            }
            .into(),
        ]
        .into();

        TokenInfo {
            token_id: "0.6.9".parse().unwrap(),
            name: "test token name".to_owned(),
            symbol: "TTN".to_owned(),
            decimals: 3,
            total_supply: 1000,
            treasury_account_id: "7.7.7".parse().unwrap(),
            admin_key: Some(PrivateKey::from_str("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11").unwrap().public_key().into()),
            kyc_key: Some(PrivateKey::from_str("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e12").unwrap().public_key().into()),
            freeze_key: Some(PrivateKey::from_str("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e13").unwrap().public_key().into()),
            wipe_key: Some(PrivateKey::from_str("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e14").unwrap().public_key().into()),
            supply_key: Some(PrivateKey::from_str("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e15").unwrap().public_key().into()),
            fee_schedule_key: Some(PrivateKey::from_str("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e16").unwrap().public_key().into()),
            default_freeze_status: Some(true),
            default_kyc_status: Some(true),
            is_deleted: false,
            auto_renew_account: Some(("8.9.0").parse().unwrap()),
            auto_renew_period: Some(Duration::hours(10)),
            expiration_time: Some(OffsetDateTime::from_unix_timestamp(1554158542).unwrap()),
            token_memo: "memo".to_owned(),
            token_type: TokenType::FungibleCommon,
            supply_type: TokenSupplyType::Finite,
            max_supply: 1000000,
            custom_fees,
            pause_key: Some(PrivateKey::from_str("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e17").unwrap().public_key().into()),
            pause_status:Some(true),
            ledger_id: LedgerId::mainnet(),
            metadata: metadata(),
            metadata_key: Some(PrivateKey::from_str("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e18").unwrap().public_key().into())
        }
    }

    #[test]
    fn serialize() {
        let info = TokenInfo::from_bytes(&make_token_info().to_bytes()).unwrap();
        expect_file!["./snapshots/token_info/serialize.txt"].assert_debug_eq(&info);
    }

    #[test]
    fn from_protobuf() {
        let pb = make_token_info().to_protobuf();

        let token_info = TokenInfo::from_protobuf(pb).unwrap();

        expect_file!["./snapshots/token_info/from_protobuf.txt"].assert_debug_eq(&token_info)
    }

    #[test]
    fn to_protobuf() {
        let pb = make_token_info().to_protobuf();

        let token_info = TokenInfo::from_protobuf(pb).unwrap();

        expect_file!["./snapshots/token_info/to_protobuf.txt"].assert_debug_eq(&token_info)
    }
}
// Filename: src/token/token_info_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::token::token_info::TokenInfo;
use crate::{
    BoxGrpcFuture,
    Error,
    Query,
    ToProtobuf,
    TokenId,
    ValidateChecksums,
};

/// Gets information about Token instance.
///
pub type TokenInfoQuery = Query<TokenInfoQueryData>;

#[derive(Default, Clone, Debug)]
pub struct TokenInfoQueryData {
    token_id: Option<TokenId>,
}

impl From<TokenInfoQueryData> for AnyQueryData {
    #[inline]
    fn from(data: TokenInfoQueryData) -> Self {
        Self::TokenInfo(data)
    }
}

impl TokenInfoQuery {
    /// Returns the token ID for which information is requested.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data.token_id
    }

    /// Sets the token ID for which information is requested.
    pub fn token_id(&mut self, id: impl Into<TokenId>) -> &mut Self {
        self.data.token_id = Some(id.into());
        self
    }
}

impl ToQueryProtobuf for TokenInfoQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let token_id = self.token_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::TokenGetInfo(services::TokenGetInfoQuery {
                header: Some(header),
                token: token_id,
            })),
        }
    }
}

impl QueryExecute for TokenInfoQueryData {
    type Response = TokenInfo;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { TokenServiceClient::new(channel).get_token_info(request).await })
    }
}

impl ValidateChecksums for TokenInfoQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.token_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        Hbar,
        TokenId,
        TokenInfoQuery,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    TokenGetInfo(
                        TokenGetInfoQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            token: Some(
                                TokenId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    token_num: 5005,
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &TokenInfoQuery::new()
                .token_id(TokenId::new(0, 0, 5005))
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        )
    }

    #[test]
    fn get_set_token_id() {
        let mut query = TokenInfoQuery::new();
        query.token_id(TokenId::new(0, 0, 5005));

        assert_eq!(query.get_token_id(), Some(TokenId::new(0, 0, 5005)));
    }
}
// Filename: src/token/token_key_validation_type.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};

use hedera_proto::services;

use crate::{
    FromProtobuf,
    ToProtobuf,
};

/// Types of validation strategies for token keys.
/// Defaults to [`FullValidation`](Self::FullValidation).
#[derive(Debug, Hash, PartialEq, Eq, Clone, Copy, Default)]
#[repr(C)]
pub enum TokenKeyValidation {
    /// Currently the default behaviour. It will perform all token key validations.
    #[default]
    FullValidation = 0,

    /// Perform no validations at all for all passed token keys.
    NoValidation = 1,
}

impl Display for TokenKeyValidation {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Self::FullValidation => write!(f, "FULL_VALIDATION"),
            Self::NoValidation => write!(f, "NO_VALIDATION"),
        }
    }
}

impl FromProtobuf<services::TokenKeyValidation> for TokenKeyValidation {
    fn from_protobuf(pb: services::TokenKeyValidation) -> crate::Result<Self> {
        Ok(match pb {
            services::TokenKeyValidation::FullValidation => Self::FullValidation,
            services::TokenKeyValidation::NoValidation => Self::NoValidation,
        })
    }
}

impl ToProtobuf for TokenKeyValidation {
    type Protobuf = services::TokenKeyValidation;

    fn to_protobuf(&self) -> Self::Protobuf {
        match self {
            Self::FullValidation => Self::Protobuf::FullValidation,
            Self::NoValidation => Self::Protobuf::NoValidation,
        }
    }
}
// Filename: src/token/token_mint_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Mints tokens to the Token's treasury Account.
///
/// The operation increases the Total Supply of the Token. The maximum total supply a token can have
/// is 2^63-1.
///
/// The amount provided must be in the lowest denomination possible. Example: Token A has 2 decimals.
/// In order to mint 100 tokens, one must provide amount of 10000. In order to mint 100.55 tokens,
/// one must provide amount of 10055.
///
/// - If no Supply Key is defined, the transaction will resolve to `TokenHasNoSupplyKey`.
/// - If both amount and metadata list get filled, a `InvalidTransactionBody` response code will be
/// returned.
/// - If the metadata list contains metadata which is too large, a `MetadataTooLong` response code will
/// be returned.
/// - If neither the amount nor the metadata list get filled, a `InvalidTokenMintAmount` response code
/// will be returned.
/// - If the metadata list count is greater than the batch size limit global dynamic property, a
/// `BatchSizeLimitExceeded` response code will be returned.
pub type TokenMintTransaction = Transaction<TokenMintTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenMintTransactionData {
    /// The token for which to mint tokens.
    token_id: Option<TokenId>,

    /// The amount of a fungible token to mint to the treasury account.
    amount: u64,

    /// The list of metadata for a non-fungible token to mint to the treasury account.
    metadata: Vec<Vec<u8>>,
}

impl TokenMintTransaction {
    /// Returns the token for which to mint tokens.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token for which to mint tokens.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }

    /// Returns the amount of a fungible token to mint to the treasury account.
    #[must_use]
    pub fn get_amount(&self) -> u64 {
        self.data().amount
    }

    /// Sets the amount of a fungible token to mint to the treasury account.
    pub fn amount(&mut self, amount: u64) -> &mut Self {
        self.data_mut().amount = amount;
        self
    }

    /// Returns the list of metadata for a non-fungible token to mint to the treasury account.
    #[must_use]
    pub fn get_metadata(&self) -> &[Vec<u8>] {
        &self.data().metadata
    }

    /// Sets the list of metadata for a non-fungible token to mint to the treasury account.
    pub fn metadata<Bytes>(&mut self, metadata: impl IntoIterator<Item = Bytes>) -> &mut Self
    where
        Bytes: AsRef<[u8]>,
    {
        self.data_mut().metadata =
            metadata.into_iter().map(|bytes| bytes.as_ref().to_vec()).collect();

        self
    }
}

impl TransactionData for TokenMintTransactionData {}

impl TransactionExecute for TokenMintTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).mint_token(request).await })
    }
}

impl ValidateChecksums for TokenMintTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenMintTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenMint(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenMintTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenMint(self.to_protobuf())
    }
}

impl From<TokenMintTransactionData> for AnyTransactionData {
    fn from(transaction: TokenMintTransactionData) -> Self {
        Self::TokenMint(transaction)
    }
}

impl FromProtobuf<services::TokenMintTransactionBody> for TokenMintTransactionData {
    fn from_protobuf(pb: services::TokenMintTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            token_id: Option::from_protobuf(pb.token)?,
            amount: pb.amount,
            metadata: pb.metadata,
        })
    }
}

impl ToProtobuf for TokenMintTransactionData {
    type Protobuf = services::TokenMintTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenMintTransactionBody {
            token: self.token_id.to_protobuf(),
            amount: self.amount,
            metadata: self.metadata.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services::TokenMintTransactionBody;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenMintTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        TokenId,
        TokenMintTransaction,
    };

    const TEST_TOKEN_ID: TokenId = TokenId::new(4, 2, 0);
    const TEST_AMOUNT: u64 = 10;

    fn metadata() -> Vec<Vec<u8>> {
        [[1, 2, 3, 4, 5].into()].into()
    }

    fn make_transaction() -> TokenMintTransaction {
        let mut tx = TokenMintTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID).amount(TEST_AMOUNT).freeze().unwrap();

        tx
    }

    fn make_metadata_transaction() -> TokenMintTransaction {
        let mut tx = TokenMintTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID).metadata(metadata()).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenMint(
                TokenMintTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 0,
                        },
                    ),
                    amount: 10,
                    metadata: [],
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn serialize_metadata() {
        let tx = make_metadata_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenMint(
                TokenMintTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 0,
                        },
                    ),
                    amount: 0,
                    metadata: [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                        ],
                    ],
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes_metadata() {
        let tx = make_metadata_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = TokenMintTransactionBody {
            token: Some(TEST_TOKEN_ID.to_protobuf()),
            amount: TEST_AMOUNT,
            metadata: metadata(),
        };

        let data = TokenMintTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.token_id, Some(TEST_TOKEN_ID));
        assert_eq!(data.amount, TEST_AMOUNT);
        assert_eq!(data.metadata, metadata());
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenMintTransaction::new();
        tx.token_id(TEST_TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        let mut tx = make_transaction();

        tx.token_id(TEST_TOKEN_ID);
    }

    #[test]
    fn get_set_amount() {
        let mut tx = TokenMintTransaction::new();
        tx.amount(TEST_AMOUNT);

        assert_eq!(tx.get_amount(), TEST_AMOUNT);
    }

    #[test]
    #[should_panic]
    fn get_set_amount_frozen_panic() {
        let mut tx = make_transaction();
        tx.amount(TEST_AMOUNT);
    }

    #[test]
    fn get_set_metadata() {
        let mut tx = TokenMintTransaction::new();
        tx.metadata(metadata());

        assert_eq!(tx.get_metadata(), &metadata());
    }

    #[test]
    #[should_panic]
    fn get_set_metadata_frozen_panic() {
        let mut tx = make_transaction();
        tx.metadata(metadata());
    }
}
// Filename: src/token/token_nft_info.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use prost::Message;
use time::OffsetDateTime;

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    FromProtobuf,
    LedgerId,
    NftId,
};

/// Response from [`TokenNftInfoQuery`][crate::TokenNftInfoQuery].

#[derive(Debug, Clone)]
pub struct TokenNftInfo {
    /// The ID of the NFT.
    pub nft_id: NftId,

    /// The current owner of the NFT.
    pub account_id: AccountId,

    /// Effective consensus timestamp at which the NFT was minted.
    pub creation_time: OffsetDateTime,

    /// The unique metadata of the NFT.
    pub metadata: Vec<u8>,

    /// If an allowance is granted for the NFT, its corresponding spender account.
    pub spender_id: Option<AccountId>,

    /// The ledger ID the response was returned from.
    pub ledger_id: LedgerId,
}

impl TokenNftInfo {
    /// Create a new `TokenInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::TokenNftInfo>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        services::TokenNftInfo {
            nft_id: Some(self.nft_id.to_protobuf()),
            account_id: Some(self.account_id.to_protobuf()),
            creation_time: Some(self.creation_time.to_protobuf()),
            metadata: self.metadata.clone(),
            ledger_id: self.ledger_id.to_bytes(),
            spender_id: self.spender_id.to_protobuf(),
        }
        .encode_to_vec()
    }
}

impl FromProtobuf<services::response::Response> for TokenNftInfo {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let pb = pb_getv!(pb, TokenGetNftInfo, services::response::Response);
        let nft = pb_getf!(pb, nft)?;
        Self::from_protobuf(nft)
    }
}

impl FromProtobuf<services::TokenNftInfo> for TokenNftInfo {
    fn from_protobuf(pb: services::TokenNftInfo) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let nft_id = pb_getf!(pb, nft_id)?;
        let account_id = pb_getf!(pb, account_id)?;
        let creation_time = pb.creation_time.unwrap();
        let metadata = pb.metadata;
        let spender_account_id = Option::from_protobuf(pb.spender_id)?;

        Ok(Self {
            nft_id: NftId::from_protobuf(nft_id)?,
            account_id: AccountId::from_protobuf(account_id)?,
            creation_time: OffsetDateTime::from(creation_time),
            metadata,
            spender_id: spender_account_id,
            ledger_id: LedgerId::from_bytes(pb.ledger_id),
        })
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hex_literal::hex;

    use crate::transaction::test_helpers::VALID_START;
    use crate::{
        AccountId,
        LedgerId,
        TokenId,
        TokenNftInfo,
    };

    fn make_info(spender_account_id: Option<AccountId>) -> TokenNftInfo {
        TokenNftInfo {
            nft_id: TokenId::new(1, 2, 3).nft(4),
            account_id: "5.6.7".parse().unwrap(),
            creation_time: VALID_START,
            metadata: hex!("deadbeef").into(),
            spender_id: spender_account_id,
            ledger_id: LedgerId::mainnet(),
        }
    }

    #[test]
    fn serialize() {
        let info = make_info(Some("8.9.10".parse().unwrap()));
        expect![[r#"
            Ok(
                TokenNftInfo {
                    nft_id: "1.2.3/4",
                    account_id: "5.6.7",
                    creation_time: 2019-04-01 22:42:22.0 +00:00:00,
                    metadata: [
                        222,
                        173,
                        190,
                        239,
                    ],
                    spender_id: Some(
                        "8.9.10",
                    ),
                    ledger_id: "mainnet",
                },
            )
        "#]]
        .assert_debug_eq(&TokenNftInfo::from_bytes(&info.to_bytes()));
    }

    #[test]
    fn serialize_no_spender() {
        let info = make_info(None);
        expect![[r#"
            Ok(
                TokenNftInfo {
                    nft_id: "1.2.3/4",
                    account_id: "5.6.7",
                    creation_time: 2019-04-01 22:42:22.0 +00:00:00,
                    metadata: [
                        222,
                        173,
                        190,
                        239,
                    ],
                    spender_id: None,
                    ledger_id: "mainnet",
                },
            )
        "#]]
        .assert_debug_eq(&TokenNftInfo::from_bytes(&info.to_bytes()));
    }
}
// Filename: src/token/token_nft_info_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    Query,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    Error,
    NftId,
    ToProtobuf,
    TokenNftInfo,
    ValidateChecksums,
};

/// Gets info on an NFT for a given `TokenID` and serial number.
pub type TokenNftInfoQuery = Query<TokenNftInfoQueryData>;

#[derive(Clone, Default, Debug)]
pub struct TokenNftInfoQueryData {
    /// The ID of the NFT
    nft_id: Option<NftId>,
}

impl From<TokenNftInfoQueryData> for AnyQueryData {
    #[inline]
    fn from(data: TokenNftInfoQueryData) -> Self {
        Self::TokenNftInfo(data)
    }
}

impl TokenNftInfoQuery {
    /// Returns the ID of the NFT for which information is requested.
    #[must_use]
    pub fn get_nft_id(&self) -> Option<NftId> {
        self.data.nft_id
    }

    /// Sets the ID of the NFT for which information is requested.
    pub fn nft_id(&mut self, nft_id: impl Into<NftId>) -> &mut Self {
        self.data.nft_id = Some(nft_id.into());
        self
    }
}

impl ToQueryProtobuf for TokenNftInfoQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let nft_id = self.nft_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::TokenGetNftInfo(services::TokenGetNftInfoQuery {
                header: Some(header),
                nft_id,
            })),
        }
    }
}

impl QueryExecute for TokenNftInfoQueryData {
    type Response = TokenNftInfo;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { TokenServiceClient::new(channel).get_token_nft_info(request).await })
    }
}

impl ValidateChecksums for TokenNftInfoQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.nft_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        Hbar,
        TokenId,
        TokenNftInfoQuery,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    TokenGetNftInfo(
                        TokenGetNftInfoQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            nft_id: Some(
                                NftId {
                                    token_id: Some(
                                        TokenId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            token_num: 5005,
                                        },
                                    ),
                                    serial_number: 101,
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &TokenNftInfoQuery::new()
                .nft_id(TokenId::new(0, 0, 5005).nft(101))
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        )
    }

    #[test]
    fn properties() {
        let mut query = TokenNftInfoQuery::new();
        query
            .nft_id(TokenId::new(0, 0, 5005).nft(101))
            .max_payment_amount(Hbar::from_tinybars(100_000));

        assert_eq!(query.get_nft_id().unwrap().to_string(), "0.0.5005/101");
    }
}
// Filename: src/token/token_nft_transfer.rs
use hedera_proto::services;

use crate::protobuf::FromProtobuf;
use crate::{
    AccountId,
    TokenId,
};

/// Represents a transfer of an NFT from one account to another.
#[derive(Debug, Clone, Eq, PartialEq)]
#[non_exhaustive]
pub struct TokenNftTransfer {
    /// The ID of the NFT's token.
    pub token_id: TokenId,

    /// The account that the NFT is being transferred from.
    pub sender: AccountId,

    /// The account that the NFT is being transferred to.
    pub receiver: AccountId,

    /// The serial number for the NFT being transferred.
    pub serial: u64,

    /// If true then the transfer is expected to be an approved allowance and the
    /// `sender` is expected to be the owner. The default is false.
    pub is_approved: bool,
}

impl TokenNftTransfer {
    pub(crate) fn from_protobuf(
        pb: services::NftTransfer,
        token_id: TokenId,
    ) -> crate::Result<Self> {
        Ok(Self {
            token_id,
            sender: AccountId::from_protobuf(pb_getf!(pb, sender_account_id)?)?,
            receiver: AccountId::from_protobuf(pb_getf!(pb, receiver_account_id)?)?,
            serial: pb.serial_number as u64,
            is_approved: pb.is_approval,
        })
    }
}
// Filename: src/token/token_pause_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Pauses the Token from being involved in any kind of Transaction until it is unpaused.
///
/// Must be signed with the Token's pause key.
///
/// Once executed the Token is marked as paused and will be not able to be a part of any transaction.
/// The operation is idempotent - becomes a no-op if the Token is already Paused.
///
/// - If the provided token is not found, the transaction will resolve to `INVALID_TOKEN_ID`.
/// - If the provided token has been deleted, the transaction will resolve to `TOKEN_WAS_DELETED`.
/// - If no Pause Key is defined, the transaction will resolve to `TOKEN_HAS_NO_PAUSE_KEY`.
pub type TokenPauseTransaction = Transaction<TokenPauseTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenPauseTransactionData {
    /// The token to be paused.
    token_id: Option<TokenId>,
}

impl TokenPauseTransaction {
    /// Returns the token to be paused.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token to be paused.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }
}

impl TransactionData for TokenPauseTransactionData {}

impl TransactionExecute for TokenPauseTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).pause_token(request).await })
    }
}

impl ValidateChecksums for TokenPauseTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> crate::Result<()> {
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenPauseTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenPause(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenPauseTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenPause(self.to_protobuf())
    }
}

impl From<TokenPauseTransactionData> for AnyTransactionData {
    fn from(transaction: TokenPauseTransactionData) -> Self {
        Self::TokenPause(transaction)
    }
}

impl FromProtobuf<services::TokenPauseTransactionBody> for TokenPauseTransactionData {
    fn from_protobuf(pb: services::TokenPauseTransactionBody) -> crate::Result<Self> {
        Ok(Self { token_id: Option::from_protobuf(pb.token)? })
    }
}

impl ToProtobuf for TokenPauseTransactionData {
    type Protobuf = services::TokenPauseTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenPauseTransactionBody { token: self.token_id.to_protobuf() }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services::TokenPauseTransactionBody;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenPauseTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        TokenId,
        TokenPauseTransaction,
    };

    const TEST_TOKEN_ID: TokenId = TokenId::new(4, 2, 0);

    fn make_transaction() -> TokenPauseTransaction {
        let mut tx = TokenPauseTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenPause(
                TokenPauseTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 0,
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = TokenPauseTransactionBody { token: Some(TEST_TOKEN_ID.to_protobuf()) };

        let data = TokenPauseTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.token_id, Some(TEST_TOKEN_ID));
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenPauseTransaction::new();
        tx.token_id(TEST_TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        let mut tx = make_transaction();

        tx.token_id(TEST_TOKEN_ID);
    }
}
// Filename: src/token/token_reject_flow.rs
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashSet;
use std::ops::Deref;

use super::{
    NftId,
    TokenDissociateTransaction,
    TokenId,
    TokenRejectTransaction,
};
use crate::signer::AnySigner;
use crate::{
    AccountId,
    Client,
    PrivateKey,
    PublicKey,
    TransactionResponse,
};

///  Reject undesired token(s) and dissociate in a single flow.
///
/// The operation of this flow is as follows:
/// 1. Execute a [`TokenRejectTransaction`] using the provided NFT IDs and the Token IDs
/// 2. Dissociate the rejected tokens from the owner account
#[derive(Default, Debug)]
pub struct TokenRejectFlow {
    node_account_ids: Option<Vec<AccountId>>,
    token_reject_data: TokenRejectData,
}

#[derive(Default, Debug)]
struct TokenRejectData {
    owner: Option<AccountId>,
    token_ids: Vec<TokenId>,
    nft_ids: Vec<NftId>,
    freeze_with_client: Option<Client>,
    signer: Option<AnySigner>,
}

impl TokenRejectFlow {
    /// Create a new `TokenRejectFlow`.
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns the owner id of the token to be rejected.
    #[must_use]
    pub fn get_owner(&self) -> Option<AccountId> {
        self.token_reject_data.owner
    }

    /// Sets the owner id of the token to be rejected.
    pub fn owner(&mut self, owner: impl Into<AccountId>) -> &mut Self {
        self.token_reject_data.owner = Some(owner.into());
        self
    }

    /// Returns the account IDs of the nodes the transactions may be submitted to.
    #[must_use]
    pub fn get_node_account_ids(&self) -> Option<&[AccountId]> {
        self.node_account_ids.as_deref()
    }

    /// Sets the account IDs of the nodes the transactions may be submitted to.
    pub fn node_account_ids(
        &mut self,
        node_account_ids: impl IntoIterator<Item = AccountId>,
    ) -> &mut Self {
        self.node_account_ids = Some(node_account_ids.into_iter().collect());

        self
    }

    /// Returns the list of token IDs.
    #[must_use]
    pub fn get_token_ids(&self) -> &[TokenId] {
        self.token_reject_data.token_ids.deref()
    }

    /// Sets the list of token IDs.
    pub fn token_ids(&mut self, token_ids: impl IntoIterator<Item = TokenId>) -> &mut Self {
        self.token_reject_data.token_ids = token_ids.into_iter().collect();

        self
    }

    /// Adds a token ID to the list of token IDs.
    pub fn add_token_id(&mut self, token_id: TokenId) -> &mut Self {
        self.token_reject_data.token_ids.push(token_id);

        self
    }

    /// Returns the list of NFT IDs.
    #[must_use]
    pub fn get_nft_ids(&self) -> &[NftId] {
        self.token_reject_data.nft_ids.deref()
    }

    /// Sets the list of NFT IDs.
    pub fn nft_ids(&mut self, nft_ids: impl IntoIterator<Item = NftId>) -> &mut Self {
        self.token_reject_data.nft_ids = nft_ids.into_iter().collect();

        self
    }

    /// Adds an NFT ID to the list of NFT IDs.
    pub fn add_nft_id(&mut self, nft_id: NftId) -> &mut Self {
        self.token_reject_data.nft_ids.push(nft_id);

        self
    }

    /// Sets the client to use for freezing the generated *``TokenRejectTransaction``*.
    ///
    /// By default freezing will use the client provided to ``execute``.
    pub fn freeze_with(&mut self, client: Client) -> &mut Self {
        self.token_reject_data.freeze_with_client = Some(client);

        self
    }

    /// Sets the signer for use in the ``TokenRejectTransaction``
    ///
    /// Important: Only *one* signer is allowed.
    pub fn sign(&mut self, key: PrivateKey) -> &mut Self {
        self.token_reject_data.signer = Some(AnySigner::PrivateKey(key));

        self
    }

    /// Sets the signer for use in the ``TokenRejectTransaction``
    ///
    /// Important: Only *one* signer is allowed.
    pub fn sign_with<F: Fn(&[u8]) -> Vec<u8> + Send + Sync + 'static>(
        &mut self,
        public_key: PublicKey,
        signer: F,
    ) -> &mut Self {
        self.token_reject_data.signer = Some(AnySigner::arbitrary(Box::new(public_key), signer));

        self
    }

    /// Set the operator that this transaction will be signed with.
    pub fn sign_with_operator(&mut self, client: &Client) -> &mut Self {
        // todo: proper error
        let operator_key = client
            .load_operator()
            .as_deref()
            .map(|it| it.signer.clone())
            .expect("Must call `Client.set_operator` to use token reject flow");

        self.token_reject_data.signer = Some(operator_key);

        self
    }

    /// Generates the required transactions and executes them all.
    pub async fn execute(&self, client: &Client) -> crate::Result<TransactionResponse> {
        self.execute_with_optional_timeout(client, None).await
    }

    /// Generates the required transactions and executes them all.
    pub async fn execute_with_timeout(
        &self,
        client: &Client,
        timeout_per_transaction: std::time::Duration,
    ) -> crate::Result<TransactionResponse> {
        self.execute_with_optional_timeout(client, Some(timeout_per_transaction)).await
    }

    async fn execute_with_optional_timeout(
        &self,
        client: &Client,
        timeout_per_transaction: Option<std::time::Duration>,
    ) -> crate::Result<TransactionResponse> {
        let reject_response =
            make_token_reject_transaction(&self.token_reject_data, self.node_account_ids.clone())?
                .execute_with_optional_timeout(client, timeout_per_transaction)
                .await?;

        reject_response
            .get_receipt_query()
            .execute_with_optional_timeout(client, timeout_per_transaction)
            .await?;

        let dissociate_response = make_token_dissociate_transaction(
            &self.token_reject_data,
            self.node_account_ids.clone(),
        )?
        .execute_with_optional_timeout(client, timeout_per_transaction)
        .await?;

        dissociate_response
            .get_receipt_query()
            .execute_with_optional_timeout(client, timeout_per_transaction)
            .await?;

        Ok(reject_response)
    }
}

fn make_token_reject_transaction(
    data: &TokenRejectData,
    node_account_ids: Option<Vec<AccountId>>,
) -> crate::Result<TokenRejectTransaction> {
    let mut tmp = TokenRejectTransaction::new();

    if let Some(owner) = &data.owner {
        tmp.owner(owner.clone());
    }

    tmp.token_ids(data.token_ids.clone());

    tmp.nft_ids(data.nft_ids.clone());

    if let Some(node_account_ids) = node_account_ids {
        tmp.node_account_ids(node_account_ids);
    }

    if let Some(client) = &data.freeze_with_client {
        tmp.freeze_with(client)?;
    }

    if let Some(signer) = &data.signer {
        tmp.sign_signer(signer.clone());
    }

    Ok(tmp)
}

fn make_token_dissociate_transaction(
    data: &TokenRejectData,
    node_account_ids: Option<Vec<AccountId>>,
) -> crate::Result<TokenDissociateTransaction> {
    let mut token_ids = data.token_ids.clone();
    token_ids.extend(data.nft_ids.iter().map(|it| it.token_id));

    let unique_token_ids: Vec<_> =
        token_ids.into_iter().collect::<HashSet<_>>().into_iter().collect();

    let mut tmp = TokenDissociateTransaction::new();

    if let Some(owner) = data.owner {
        tmp.account_id(owner);
    }

    tmp.token_ids(unique_token_ids);

    if let Some(node_account_ids) = node_account_ids {
        tmp.node_account_ids(node_account_ids);
    }

    if let Some(client) = &data.freeze_with_client {
        tmp.freeze_with(client)?;
    }

    if let Some(signer) = &data.signer {
        tmp.sign_signer(signer.clone());
    }

    Ok(tmp)
}
// Filename: src/token/token_reject_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use super::NftId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Reject undesired token(s)
/// Transfer one or more token balances held by the requesting account to the treasury for each
/// token type.
/// Each transfer SHALL be one of the following
/// - A single non-fungible/unique token.
/// - The full balance held for a fungible/common token type.
///
/// A single tokenReject transaction SHALL support a maximum of 10 transfers.
///
/// ### Transaction Record Effects
/// - Each successful transfer from `payer` to `treasury` SHALL be recorded in `token_transfer_list` for the transaction record.
pub type TokenRejectTransaction = Transaction<TokenRejectTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenRejectTransactionData {
    /// An account holding the tokens to be rejected.
    owner: Option<AccountId>,

    /// The list of rejected Fungible tokens.
    token_ids: Vec<TokenId>,

    /// The list of rejected Non-fungible tokens.
    nft_ids: Vec<NftId>,
}

impl TokenRejectTransaction {
    /// Returns the owner id of the token to be rejected.
    #[must_use]
    pub fn get_owner(&self) -> Option<AccountId> {
        self.data().owner
    }

    /// Sets the owner id of the token to be rejected.
    pub fn owner(&mut self, owner: impl Into<AccountId>) -> &mut Self {
        self.data_mut().owner = Some(owner.into());
        self
    }

    /// Returns the list of Fungible tokens to be rejected.
    #[must_use]
    pub fn get_token_ids(&self) -> Vec<TokenId> {
        self.data().token_ids.clone()
    }

    /// Sets the list of Fungible tokens to be rejected.
    pub fn token_ids(&mut self, token_ids: impl IntoIterator<Item = TokenId>) -> &mut Self {
        self.data_mut().token_ids = token_ids.into_iter().collect();
        self
    }

    /// Appends a Fungible token to the list of rejected tokens.
    pub fn add_token_id(&mut self, token_id: TokenId) -> &mut Self {
        self.data_mut().token_ids.push(token_id);
        self
    }

    /// Returns the list of Non-fungible tokens to be rejected.
    #[must_use]
    pub fn get_nft_ids(&self) -> Vec<NftId> {
        self.data().nft_ids.clone()
    }

    /// Sets the list of Non-fungible tokens to be rejected.
    pub fn nft_ids(&mut self, nft_ids: impl IntoIterator<Item = NftId>) -> &mut Self {
        self.data_mut().nft_ids = nft_ids.into_iter().collect();
        self
    }

    /// Appends a Non-Fungible token to the list of rejected nfts.
    pub fn add_nft_id(&mut self, nft_id: NftId) -> &mut Self {
        self.data_mut().nft_ids.push(nft_id);
        self
    }
}

impl TransactionData for TokenRejectTransactionData {}

impl TransactionExecute for TokenRejectTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).reject_token(request).await })
    }
}

impl ValidateChecksums for TokenRejectTransactionData {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        self.owner.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenRejectTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenReject(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenRejectTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenReject(self.to_protobuf())
    }
}

impl From<TokenRejectTransactionData> for AnyTransactionData {
    fn from(transaction: TokenRejectTransactionData) -> Self {
        Self::TokenReject(transaction)
    }
}

impl FromProtobuf<services::TokenRejectTransactionBody> for TokenRejectTransactionData {
    fn from_protobuf(pb: services::TokenRejectTransactionBody) -> crate::Result<Self> {
        let mut token_ids = Vec::new();
        let mut nft_ids = Vec::new();

        for reference in pb.rejections {
            match reference.token_identifier {
                Some(it) => match it {
                    services::token_reference::TokenIdentifier::FungibleToken(it) => {
                        token_ids.push(TokenId::from_protobuf(it)?);
                    }
                    services::token_reference::TokenIdentifier::Nft(it) => {
                        nft_ids.push(NftId::from_protobuf(it)?);
                    }
                },
                None => {
                    return Err(Error::from_protobuf("Invalid token identifier"));
                }
            }
        }

        Ok(Self { owner: Option::from_protobuf(pb.owner)?, token_ids, nft_ids })
    }
}

impl ToProtobuf for TokenRejectTransactionData {
    type Protobuf = services::TokenRejectTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let owner = self.owner.to_protobuf();

        let rejections = self
            .token_ids
            .iter()
            .map(|token_id| services::TokenReference {
                token_identifier: Some(services::token_reference::TokenIdentifier::FungibleToken(
                    token_id.to_protobuf(),
                )),
            })
            .chain(self.nft_ids.iter().map(|nft_id| services::TokenReference {
                token_identifier: Some(services::token_reference::TokenIdentifier::Nft(
                    nft_id.to_protobuf(),
                )),
            }))
            .collect::<Vec<_>>();

        services::TokenRejectTransactionBody { owner, rejections }
    }
}

#[cfg(test)]
mod tests {

    use expect_test::expect_file;
    use hedera_proto::services::{
        token_reference,
        TokenReference,
        TokenRejectTransactionBody,
    };

    use super::TokenRejectTransaction;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenRejectTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        TEST_ACCOUNT_ID,
        TEST_NFT_IDS,
        TEST_TOKEN_IDS,
    };
    use crate::AnyTransaction;

    fn make_transaction() -> TokenRejectTransaction {
        let mut tx = TokenRejectTransaction::new_for_tests();
        tx.owner(TEST_ACCOUNT_ID).token_ids(TEST_TOKEN_IDS).nft_ids(TEST_NFT_IDS).freeze().unwrap();

        tx
    }

    #[test]
    fn seriralize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_reject_transaction/serialize.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let mut references = Vec::new();

        for token_id in TEST_TOKEN_IDS {
            references.push(TokenReference {
                token_identifier: Some(token_reference::TokenIdentifier::FungibleToken(
                    token_id.to_protobuf(),
                )),
            });
        }

        for nft_id in TEST_NFT_IDS {
            references.push(TokenReference {
                token_identifier: Some(token_reference::TokenIdentifier::Nft(nft_id.to_protobuf())),
            });
        }

        let tx = TokenRejectTransactionBody {
            owner: Some(TEST_ACCOUNT_ID.to_protobuf()),
            rejections: references,
        };

        let data = TokenRejectTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.owner, Some(TEST_ACCOUNT_ID));
        assert_eq!(data.token_ids, TEST_TOKEN_IDS);
        assert_eq!(data.nft_ids, TEST_NFT_IDS);
    }

    #[test]
    fn get_set_owner() {
        let mut tx = TokenRejectTransaction::new();

        let tx2 = tx.owner(TEST_ACCOUNT_ID);

        assert_eq!(tx2.get_owner(), Some(TEST_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_owner_frozen_panic() {
        let mut tx = make_transaction();

        tx.owner(TEST_ACCOUNT_ID);
    }

    #[test]
    fn get_set_token_ids() {
        let mut tx = TokenRejectTransaction::new();

        let tx2 = tx.token_ids(TEST_TOKEN_IDS);

        assert_eq!(tx2.get_token_ids(), TEST_TOKEN_IDS);
    }

    #[test]
    #[should_panic]
    fn get_set_token_ids_frozen_panic() {
        let mut tx = make_transaction();

        tx.token_ids(TEST_TOKEN_IDS);
    }

    #[test]
    fn get_set_nft_ids() {
        let mut tx = TokenRejectTransaction::new();

        let tx2 = tx.nft_ids(TEST_NFT_IDS);

        assert_eq!(tx2.get_nft_ids(), TEST_NFT_IDS);
    }

    #[test]
    #[should_panic]
    fn get_set_nft_ids_frozen_panic() {
        let mut tx = make_transaction();

        tx.nft_ids(TEST_NFT_IDS);
    }

    #[test]
    fn get_set_add_token_ids() {
        let mut tx = TokenRejectTransaction::new();

        tx.add_token_id(TEST_TOKEN_IDS[0]);
        tx.add_token_id(TEST_TOKEN_IDS[2]);

        assert_eq!(tx.get_token_ids()[0], TEST_TOKEN_IDS[0]);
        assert_eq!(tx.get_token_ids()[1], TEST_TOKEN_IDS[2]);
    }

    #[test]
    fn get_set_add_nft_ids() {
        let mut tx = TokenRejectTransaction::new();

        tx.add_nft_id(TEST_NFT_IDS[0]);
        tx.add_nft_id(TEST_NFT_IDS[2]);

        assert_eq!(tx.get_nft_ids()[0], TEST_NFT_IDS[0]);
        assert_eq!(tx.get_nft_ids()[1], TEST_NFT_IDS[2]);
    }
}
// Filename: src/token/token_revoke_kyc_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Revokes KYC from the account for the given token.
///
/// Must be signed by the Token's kycKey.
///
/// Once executed the Account is marked as KYC Revoked.
///
/// - If the provided account is not found, the transaction will resolve to `INVALID_ACCOUNT_ID`.
/// - If the provided account has been deleted, the transaction will resolve to `ACCOUNT_DELETED`.
/// - If the provided token is not found, the transaction will resolve to `INVALID_TOKEN_ID`.
/// - If the provided token has been deleted, the transaction will resolve to `TOKEN_WAS_DELETED`.
/// - If an Association between the provided token and account is not found, the transaction will
/// resolve to `TOKEN_NOT_ASSOCIATED_TO_ACCOUNT`.
/// - If no KYC Key is defined, the transaction will resolve to `TOKEN_HAS_NO_KYC_KEY`.
pub type TokenRevokeKycTransaction = Transaction<TokenRevokeKycTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenRevokeKycTransactionData {
    /// The account to have their KYC revoked.
    account_id: Option<AccountId>,

    /// The token for which this account will have their KYC revoked.
    token_id: Option<TokenId>,
}

impl TokenRevokeKycTransaction {
    /// Returns the account to have their KYC revoked.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }
    /// Sets the account to have their KYC revoked.
    pub fn account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(account_id);
        self
    }

    /// Returns the token for which the account will have their KYC revoked.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token for which this account will have their KYC revoked.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }
}

impl TransactionData for TokenRevokeKycTransactionData {}

impl TransactionExecute for TokenRevokeKycTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async {
            TokenServiceClient::new(channel).revoke_kyc_from_token_account(request).await
        })
    }
}

impl ValidateChecksums for TokenRevokeKycTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> crate::Result<()> {
        self.token_id.validate_checksums(ledger_id)?;
        self.account_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenRevokeKycTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenRevokeKyc(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenRevokeKycTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenRevokeKyc(self.to_protobuf())
    }
}

impl From<TokenRevokeKycTransactionData> for AnyTransactionData {
    fn from(transaction: TokenRevokeKycTransactionData) -> Self {
        Self::TokenRevokeKyc(transaction)
    }
}

impl FromProtobuf<services::TokenRevokeKycTransactionBody> for TokenRevokeKycTransactionData {
    fn from_protobuf(pb: services::TokenRevokeKycTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            account_id: Option::from_protobuf(pb.account)?,
            token_id: Option::from_protobuf(pb.token)?,
        })
    }
}

impl ToProtobuf for TokenRevokeKycTransactionData {
    type Protobuf = services::TokenRevokeKycTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenRevokeKycTransactionBody {
            token: self.token_id.to_protobuf(),
            account: self.account_id.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use super::TokenRevokeKycTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        TokenId,
        TokenRevokeKycTransaction,
    };

    const TEST_TOKEN_ID: TokenId = TokenId::new(4, 2, 0);
    const TEST_ACCOUNT_ID: AccountId =
        AccountId { shard: 6, realm: 9, num: 0, alias: None, evm_address: None, checksum: None };

    fn make_transaction() -> TokenRevokeKycTransaction {
        let mut tx = TokenRevokeKycTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID).account_id(TEST_ACCOUNT_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn seriralize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenRevokeKyc(
                TokenRevokeKycTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 0,
                        },
                    ),
                    account: Some(
                        AccountId {
                            shard_num: 6,
                            realm_num: 9,
                            account: Some(
                                AccountNum(
                                    0,
                                ),
                            ),
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenRevokeKycTransactionBody {
            token: Some(TEST_TOKEN_ID.to_protobuf()),
            account: Some(TEST_ACCOUNT_ID.to_protobuf()),
        };

        let tx = TokenRevokeKycTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.account_id, Some(TEST_ACCOUNT_ID));
        assert_eq!(tx.token_id, Some(TEST_TOKEN_ID));
    }

    #[test]
    fn get_set_account_id() {
        let mut tx = TokenRevokeKycTransaction::new();
        tx.account_id(TEST_ACCOUNT_ID);

        assert_eq!(tx.get_account_id(), Some(TEST_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panic() {
        let mut tx = make_transaction();
        tx.account_id(TEST_ACCOUNT_ID);
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenRevokeKycTransaction::new();
        tx.token_id(TEST_TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        let mut tx = make_transaction();
        tx.token_id(TEST_TOKEN_ID);
    }
}
// Filename: src/token/token_supply_type.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use crate::{
    FromProtobuf,
    ToProtobuf,
};

/// Possible token supply types.
/// Can be used to restrict supply to a set maximum.
/// Defaults to [`Infinite`](Self::Infinite).
#[derive(Debug, Hash, PartialEq, Eq, Clone, Copy)]
#[repr(C)]
pub enum TokenSupplyType {
    /// Indicates the token has a maximum supply of [`u64::MAX`].
    Infinite = 0,

    /// Indicates the token has a configurable maximum supply, provided on token creation.
    Finite = 1,
}

impl FromProtobuf<services::TokenSupplyType> for TokenSupplyType {
    fn from_protobuf(pb: services::TokenSupplyType) -> crate::Result<Self> {
        Ok(match pb {
            services::TokenSupplyType::Infinite => Self::Infinite,
            services::TokenSupplyType::Finite => Self::Finite,
        })
    }
}

impl ToProtobuf for TokenSupplyType {
    type Protobuf = services::TokenSupplyType;

    fn to_protobuf(&self) -> Self::Protobuf {
        match self {
            Self::Infinite => Self::Protobuf::Infinite,
            Self::Finite => Self::Protobuf::Finite,
        }
    }
}

#[cfg(test)]
mod tests {
    use hedera_proto::services;

    use crate::token::token_supply_type::TokenSupplyType;
    use crate::{
        FromProtobuf,
        ToProtobuf,
    };

    #[test]
    fn it_can_convert_to_protobuf() -> anyhow::Result<()> {
        let infinite_supply_type = TokenSupplyType::Infinite;
        let finite_supply_type = TokenSupplyType::Finite;

        let infinite_protobuf = infinite_supply_type.to_protobuf();
        let finite_protobuf = finite_supply_type.to_protobuf();

        assert_eq!(infinite_protobuf, services::TokenSupplyType::Infinite);
        assert_eq!(finite_protobuf, services::TokenSupplyType::Finite);

        Ok(())
    }

    #[test]
    fn it_can_be_created_from_protobuf() -> anyhow::Result<()> {
        let infinite_protobuf = services::TokenSupplyType::Infinite;
        let finite_protobuf = services::TokenSupplyType::Finite;

        let infinite_supply_type = TokenSupplyType::from_protobuf(infinite_protobuf)?;
        let finite_supply_type = TokenSupplyType::from_protobuf(finite_protobuf)?;

        assert_eq!(infinite_supply_type, TokenSupplyType::Infinite);
        assert_eq!(finite_supply_type, TokenSupplyType::Finite);

        Ok(())
    }
}
// Filename: src/token/token_type.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use crate::{
    FromProtobuf,
    ToProtobuf,
};

/// Possible token types.
///
/// Apart from fungible and non-fungible, tokens can have either a common or
/// unique representation.
///
/// Only `FungibleCommon` and `NonFungibleUnique` are supported right now. More
/// may be added in the future.
///
#[derive(Debug, Hash, PartialEq, Eq, Clone, Copy)]
#[repr(C)]
pub enum TokenType {
    /// Interchangeable value with one another, where any quantity of them has the same value as
    /// another equal quantity if they are in the same class.  Share a single set of properties, not
    /// distinct from one another. Simply represented as a balance or quantity to a given Hiero
    /// account.
    FungibleCommon = 0,

    /// Unique, not interchangeable with other tokens of the same type as they typically have
    /// different values.  Individually traced and can carry unique properties (e.g. serial number).
    NonFungibleUnique = 1,
}

impl FromProtobuf<services::TokenType> for TokenType {
    fn from_protobuf(pb: services::TokenType) -> crate::Result<Self> {
        Ok(match pb {
            services::TokenType::FungibleCommon => Self::FungibleCommon,
            services::TokenType::NonFungibleUnique => Self::NonFungibleUnique,
        })
    }
}

impl ToProtobuf for TokenType {
    type Protobuf = services::TokenType;

    fn to_protobuf(&self) -> Self::Protobuf {
        match self {
            Self::FungibleCommon => Self::Protobuf::FungibleCommon,
            Self::NonFungibleUnique => Self::Protobuf::NonFungibleUnique,
        }
    }
}

#[cfg(test)]
mod tests {
    use hedera_proto::services;

    use crate::token::token_type::TokenType;
    use crate::{
        FromProtobuf,
        ToProtobuf,
    };

    #[test]
    fn it_can_convert_to_protobuf() -> anyhow::Result<()> {
        let nft_token_type = TokenType::NonFungibleUnique;
        let fungible_token_type = TokenType::FungibleCommon;

        let nft_protobuf = nft_token_type.to_protobuf();
        let fungible_protobuf = fungible_token_type.to_protobuf();

        assert_eq!(nft_protobuf, services::TokenType::NonFungibleUnique);
        assert_eq!(fungible_protobuf, services::TokenType::FungibleCommon);

        Ok(())
    }

    #[test]
    fn it_can_be_created_from_protobuf() -> anyhow::Result<()> {
        let nft_protobuf = services::TokenType::NonFungibleUnique;
        let fungible_protobuf = services::TokenType::FungibleCommon;

        let nft_token_type = TokenType::from_protobuf(nft_protobuf)?;
        let fungible_token_type = TokenType::from_protobuf(fungible_protobuf)?;

        assert_eq!(nft_token_type, TokenType::NonFungibleUnique);
        assert_eq!(fungible_token_type, TokenType::FungibleCommon);

        Ok(())
    }
}
// Filename: src/token/token_unfreeze_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Unfreezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.
///
/// Once executed the Account is marked as Unfrozen and will be able to receive or send tokens.
/// The operation is idempotent.
///
/// - If the provided account is not found, the transaction will resolve to `INVALID_ACCOUNT_ID`.
/// - If the provided account has been deleted, the transaction will resolve to `ACCOUNT_DELETED`.
/// - If the provided token is not found, the transaction will resolve to `INVALID_TOKEN_ID`.
/// - If the provided token has been deleted, the transaction will resolve to `TOKEN_WAS_DELETED`.
/// - If an Association between the provided token and account is not found, the transaction will
/// resolve to `TOKEN_NOT_ASSOCIATED_TO_ACCOUNT`.
/// - If no Freeze Key is defined, the transaction will resolve to `TOKEN_HAS_NO_FREEZE_KEY`.
pub type TokenUnfreezeTransaction = Transaction<TokenUnfreezeTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenUnfreezeTransactionData {
    /// The account to be unfrozen.
    account_id: Option<AccountId>,

    /// The token for which this account will be unfrozen.
    token_id: Option<TokenId>,
}

impl TokenUnfreezeTransaction {
    /// Returns the account to be unfrozen.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the account to be unfrozen.
    pub fn account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(account_id);
        self
    }

    /// Returns the token for which the account will be unfrozen.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token for which this account will be unfrozen.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }
}

impl TransactionData for TokenUnfreezeTransactionData {}

impl TransactionExecute for TokenUnfreezeTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).unfreeze_token_account(request).await })
    }
}

impl ValidateChecksums for TokenUnfreezeTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> crate::Result<()> {
        self.token_id.validate_checksums(ledger_id)?;
        self.account_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenUnfreezeTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenUnfreeze(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenUnfreezeTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenUnfreeze(self.to_protobuf())
    }
}

impl From<TokenUnfreezeTransactionData> for AnyTransactionData {
    fn from(transaction: TokenUnfreezeTransactionData) -> Self {
        Self::TokenUnfreeze(transaction)
    }
}

impl FromProtobuf<services::TokenUnfreezeAccountTransactionBody> for TokenUnfreezeTransactionData {
    fn from_protobuf(pb: services::TokenUnfreezeAccountTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            account_id: Option::from_protobuf(pb.account)?,
            token_id: Option::from_protobuf(pb.token)?,
        })
    }
}

impl ToProtobuf for TokenUnfreezeTransactionData {
    type Protobuf = services::TokenUnfreezeAccountTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let account = self.account_id.to_protobuf();
        let token = self.token_id.to_protobuf();

        services::TokenUnfreezeAccountTransactionBody { token, account }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenUnfreezeTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        TokenId,
        TokenUnfreezeTransaction,
    };

    const TOKEN_ID: TokenId = TokenId::new(6, 5, 4);
    const ACCOUNT_ID: AccountId = AccountId::new(0, 0, 222);

    fn make_transaction() -> TokenUnfreezeTransaction {
        let mut tx = TokenUnfreezeTransaction::new_for_tests();

        tx.token_id(TOKEN_ID).account_id(ACCOUNT_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn seriralize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenUnfreeze(
                TokenUnfreezeAccountTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 6,
                            realm_num: 5,
                            token_num: 4,
                        },
                    ),
                    account: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    222,
                                ),
                            ),
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenUnfreezeAccountTransactionBody {
            account: Some(ACCOUNT_ID.to_protobuf()),
            token: Some(TOKEN_ID.to_protobuf()),
        };

        let data = TokenUnfreezeTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(data.account_id, Some(ACCOUNT_ID));
        assert_eq!(data.token_id, Some(TOKEN_ID));
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenUnfreezeTransaction::new();
        tx.token_id(TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        make_transaction().token_id(TOKEN_ID);
    }

    #[test]
    fn get_set_account_id() {
        let mut tx = TokenUnfreezeTransaction::new();
        tx.account_id(ACCOUNT_ID);

        assert_eq!(tx.get_account_id(), Some(ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panic() {
        make_transaction().account_id(ACCOUNT_ID);
    }
}
// Filename: src/token/token_unpause_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Unpauses the Token. Must be signed with the Token's pause key.
///
/// Once executed the Token is marked as Unpaused and can be used in Transactions.
///
/// The operation is idempotent - becomes a no-op if the Token is already unpaused.
///
/// - If the provided token is not found, the transaction will resolve to `INVALID_TOKEN_ID`.
/// - If the provided token has been deleted, the transaction will resolve to `TOKEN_WAS_DELETED`.
/// - If no Pause Key is defined, the transaction will resolve to `TOKEN_HAS_NO_PAUSE_KEY`.
pub type TokenUnpauseTransaction = Transaction<TokenUnpauseTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenUnpauseTransactionData {
    /// The token to be unpaused.
    token_id: Option<TokenId>,
}

impl TokenUnpauseTransaction {
    /// Returns the token to be unpaused.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token to be unpaused.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }
}

impl TransactionData for TokenUnpauseTransactionData {}

impl TransactionExecute for TokenUnpauseTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).unpause_token(request).await })
    }
}

impl ValidateChecksums for TokenUnpauseTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> crate::Result<()> {
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenUnpauseTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenUnpause(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenUnpauseTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenUnpause(self.to_protobuf())
    }
}

impl From<TokenUnpauseTransactionData> for AnyTransactionData {
    fn from(transaction: TokenUnpauseTransactionData) -> Self {
        Self::TokenUnpause(transaction)
    }
}

impl FromProtobuf<services::TokenUnpauseTransactionBody> for TokenUnpauseTransactionData {
    fn from_protobuf(pb: services::TokenUnpauseTransactionBody) -> crate::Result<Self> {
        Ok(Self { token_id: Option::from_protobuf(pb.token)? })
    }
}

impl ToProtobuf for TokenUnpauseTransactionData {
    type Protobuf = services::TokenUnpauseTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenUnpauseTransactionBody { token: self.token_id.to_protobuf() }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::TokenUnpauseTransactionData;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        TokenId,
        TokenUnpauseTransaction,
    };

    const TEST_TOKEN_ID: TokenId = TokenId::new(4, 2, 0);

    fn make_transaction() -> TokenUnpauseTransaction {
        let mut tx = TokenUnpauseTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID).freeze().unwrap();

        tx
    }

    #[test]
    fn seriralize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenUnpause(
                TokenUnpauseTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 0,
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenUnpauseTransactionBody { token: Some(TEST_TOKEN_ID.to_protobuf()) };

        let tx = TokenUnpauseTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.token_id, Some(TEST_TOKEN_ID));
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenUnpauseTransaction::new();
        tx.token_id(TEST_TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        let mut tx = make_transaction();
        tx.token_id(TEST_TOKEN_ID);
    }
}
// Filename: src/token/token_update_nfts_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// At consensus, updates an already created Non Fungible Token to the given values.
///
/// If no value is given for a field, that field is left unchanged.
/// Only certain fields such as metadata can be updated.
/// Updating the metadata of an NFT does not affect its ownership or transferability.
/// This operation is intended for updating attributes of individual NFTs in a collection./
/// --- Signing Requirements ---
/// 1. To update metadata of an NFT, the metadata_key of the token should sign the transaction.
pub type TokenUpdateNftsTransaction = Transaction<TokenUpdateNftsTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenUpdateNftsTransactionData {
    /// The token to be updated.
    token_id: Option<TokenId>,

    /// The list of serial numbers to be updated.
    serials: Vec<i64>,

    /// Metadata of the created token definition.
    metadata: Vec<u8>,
}

impl TokenUpdateNftsTransaction {
    /// Returns the token for which to update NFTs.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token for which to update NFTs.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }

    /// Returns the list of serial numbers to be updated.
    #[must_use]
    pub fn get_serials(&self) -> Vec<i64> {
        self.data().serials.clone()
    }

    /// Sets the list of serial numbers to be updated.
    pub fn serials(&mut self, serials: Vec<i64>) -> &mut Self {
        self.data_mut().serials = serials;
        self
    }

    /// Returns the new metadata of the NFT(s).
    #[must_use]
    pub fn get_metadata(&self) -> Vec<u8> {
        self.data().metadata.clone()
    }

    /// Sets the new metadata of the NFT(s).
    pub fn metadata(&mut self, metadata: Vec<u8>) -> &mut Self {
        self.data_mut().metadata = metadata;
        self
    }
}

impl TransactionData for TokenUpdateNftsTransactionData {}

impl TransactionExecute for TokenUpdateNftsTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).update_token(request).await })
    }
}

impl ValidateChecksums for TokenUpdateNftsTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenUpdateNftsTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenUpdateNfts(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenUpdateNftsTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenUpdateNfts(self.to_protobuf())
    }
}

impl From<TokenUpdateNftsTransactionData> for AnyTransactionData {
    fn from(transaction: TokenUpdateNftsTransactionData) -> Self {
        Self::TokenUpdateNfts(transaction)
    }
}

impl FromProtobuf<services::TokenUpdateNftsTransactionBody> for TokenUpdateNftsTransactionData {
    fn from_protobuf(pb: services::TokenUpdateNftsTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            token_id: Option::from_protobuf(pb.token)?,
            serials: pb.serial_numbers,
            metadata: pb.metadata.unwrap_or_default(),
        })
    }
}

impl ToProtobuf for TokenUpdateNftsTransactionData {
    type Protobuf = services::TokenUpdateNftsTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenUpdateNftsTransactionBody {
            token: self.token_id.to_protobuf(),
            serial_numbers: self.serials.clone(),
            metadata: Some(self.metadata.clone()),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect_file;
    use hedera_proto::services;

    use super::TokenUpdateNftsTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        TokenId,
        TokenUpdateNftsTransaction,
    };

    const TEST_TOKEN_ID: TokenId = TokenId::new(0, 0, 12);
    const TEST_METADATA: &str = "Token Metadata";

    fn test_serials() -> Vec<i64> {
        vec![1, 2, 3]
    }

    fn make_transaction() -> TokenUpdateNftsTransaction {
        let mut tx = TokenUpdateNftsTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID)
            .serials(test_serials())
            .metadata(TEST_METADATA.as_bytes().to_vec())
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_update_nfts_transaction/serialize.txt"]
            .assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenUpdateNftsTransactionBody {
            token: Some(TEST_TOKEN_ID.to_protobuf()),
            serial_numbers: test_serials(),
            metadata: Some(TEST_METADATA.to_owned().into()),
        };

        let tx = TokenUpdateNftsTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.token_id, Some(TEST_TOKEN_ID));
        assert_eq!(tx.metadata, TEST_METADATA.as_bytes().to_vec());
        assert_eq!(tx.serials, test_serials())
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenUpdateNftsTransaction::new();
        tx.token_id(TEST_TOKEN_ID);
        assert_eq!(tx.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        let mut tx = make_transaction();
        tx.token_id(TEST_TOKEN_ID);
    }

    #[test]
    fn get_set_metadata() {
        let mut tx = TokenUpdateNftsTransaction::new();
        tx.metadata(TEST_METADATA.as_bytes().to_vec());
        assert_eq!(tx.get_metadata(), TEST_METADATA.as_bytes().to_vec());
    }

    #[test]
    #[should_panic]
    fn get_set_metadata_frozen_panic() {
        let mut tx = make_transaction();
        tx.metadata(TEST_METADATA.as_bytes().to_vec());
    }

    #[test]
    fn get_set_serials() {
        let mut tx = TokenUpdateNftsTransaction::new();
        tx.serials(test_serials());
        assert_eq!(tx.get_serials(), test_serials());
    }

    #[test]
    #[should_panic]
    fn get_set_serials_frozen_panic() {
        let mut tx = make_transaction();
        tx.serials(test_serials());
    }
}
// Filename: src/token/token_update_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use time::{
    Duration,
    OffsetDateTime,
};
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::token::token_key_validation_type::TokenKeyValidation;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Key,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// At consensus, updates an already created token to the given values.
///
/// If no value is given for a field, that field is left unchanged. For an immutable token (that is,
/// a token without an admin key), only the expiry may be updated. Setting any other field in that
/// case will cause the transaction status to resolve to `TokenIsImmutable`.
///
/// ### --- Signing Requirements ---
/// 1. Whether or not a token has an admin key, its expiry can be extended with only the transaction
///    payer's signature.
/// 2. Updating any other field of a mutable token requires the admin key's signature.
/// 3. If a new admin key is set, this new key must sign **unless** it is exactly an empty
///    `KeyList`. This special sentinel key removes the existing admin key and causes the
///    token to become immutable. (Other [`Key`][Key] structures without a constituent
///    `Ed25519` key will be rejected with `InvalidAdminKey`.
/// 4. If a new treasury is set, the new treasury account's key must sign the transaction.
///
/// ### --- Nft Requirements ---
/// 1. If a non fungible token has a positive treasury balance, the operation will abort with
///    `CurrentTreasuryStillOwnsNfts`.
pub type TokenUpdateTransaction = Transaction<TokenUpdateTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenUpdateTransactionData {
    /// The token to be updated.
    token_id: Option<TokenId>,

    /// The publicly visible name of the token.
    token_name: String,

    /// The publicly visible token symbol.
    token_symbol: String,

    /// The account which will act as a treasury for the token.
    treasury_account_id: Option<AccountId>,

    /// The key which can perform update/delete operations on the token.
    admin_key: Option<Key>,

    /// The key which can grant or revoke KYC of an account for the token's transactions.
    kyc_key: Option<Key>,

    /// The key which can sign to freeze or unfreeze an account for token transactions.
    freeze_key: Option<Key>,

    /// The key which can wipe the token balance of an account.
    wipe_key: Option<Key>,

    /// The key which can change the supply of a token.
    supply_key: Option<Key>,

    /// An account which will be automatically charged to renew the token's expiration, at
    /// autoRenewPeriod interval
    auto_renew_account_id: Option<AccountId>,

    /// The interval at which the auto-renew account will be charged to extend the token's expiry
    auto_renew_period: Option<Duration>,

    /// Sets the time at which the token should expire.
    expiration_time: Option<OffsetDateTime>,

    /// The memo associated with the token (UTF-8 encoding max 100 bytes)
    token_memo: Option<String>,

    /// The key which can change the token's custom fee schedule; must sign a TokenFeeScheduleUpdate
    /// transaction
    fee_schedule_key: Option<Key>,

    /// The Key which can pause and unpause the Token.
    /// If Empty the token pause status defaults to PauseNotApplicable, otherwise Unpaused.
    pause_key: Option<Key>,

    /// Metadata of the created token definition.
    metadata: Option<Vec<u8>>,

    /// The key which can change the metadata of a token
    /// (token definition, partition definition, and individual NFTs).
    metadata_key: Option<Key>,

    /// Determines whether the system should check the validity of the passed keys for update.
    key_verification_mode: TokenKeyValidation,
}

impl TokenUpdateTransaction {
    /// Returns the token to be updated.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token to be updated.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }

    /// Returns the new publicly visible name of the token.
    #[must_use]
    pub fn get_token_name(&self) -> &str {
        &self.data().token_name
    }

    /// Sets the new publicly visible name of the token.
    ///
    /// Maximum 100 characters.
    pub fn token_name(&mut self, token_name: impl Into<String>) -> &mut Self {
        self.data_mut().token_name = token_name.into();
        self
    }

    ///Returns the new publicly visible token symbol.
    #[must_use]
    pub fn get_token_symbol(&self) -> &str {
        &self.data().token_symbol
    }

    /// Sets the new publicly visible token symbol.
    ///
    /// Maximum 100 characters.
    pub fn token_symbol(&mut self, token_symbol: impl Into<String>) -> &mut Self {
        self.data_mut().token_symbol = token_symbol.into();
        self
    }

    /// Returns the new account which will act as a treasury for the token.
    #[must_use]
    pub fn get_treasury_account_id(&self) -> Option<AccountId> {
        self.data().treasury_account_id
    }

    /// Sets the new account which will act as a treasury for the token.
    ///
    /// If the provided `treasury_account_id` does not exist or has been deleted, the response
    /// will be `InvalidTreasuryAccountForToken`.
    ///
    /// If successful, the token balance held in the previous treasury account is transferred to the
    /// new one.
    pub fn treasury_account_id(&mut self, treasury_account_id: AccountId) -> &mut Self {
        self.data_mut().treasury_account_id = Some(treasury_account_id);
        self
    }

    /// Returns the new key which can perform update/delete operations on the token.
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.data().admin_key.as_ref()
    }

    /// Sets the new key which can perform update/delete operations on the token.
    ///
    /// If the token is immutable, transaction will resolve to `TokenIsImmutable`.
    pub fn admin_key(&mut self, admin_key: impl Into<Key>) -> &mut Self {
        self.data_mut().admin_key = Some(admin_key.into());
        self
    }

    /// Returns the new key which can grant or revoke KYC of an account for the token's transactions.
    #[must_use]
    pub fn get_kyc_key(&self) -> Option<&Key> {
        self.data().kyc_key.as_ref()
    }

    /// Sets the new key which can grant or revoke KYC of an account for the token's transactions.
    ///
    /// If the token does not currently have a KYC key, transaction will resolve to `TokenHasNoKycKey`.
    pub fn kyc_key(&mut self, kyc_key: impl Into<Key>) -> &mut Self {
        self.data_mut().kyc_key = Some(kyc_key.into());
        self
    }

    /// Returns the new key which can sign to freeze or unfreeze an account for token transactions.
    #[must_use]
    pub fn get_freeze_key(&self) -> Option<&Key> {
        self.data().freeze_key.as_ref()
    }

    /// Sets the new key which can sign to freeze or unfreeze an account for token transactions.
    ///
    /// If the token does not currently have a Freeze key, transaction will resolve to `TokenHasNoFreezeKey`.
    pub fn freeze_key(&mut self, freeze_key: impl Into<Key>) -> &mut Self {
        self.data_mut().freeze_key = Some(freeze_key.into());
        self
    }

    /// Returns the new key which can wipe the token balance of an account.
    #[must_use]
    pub fn get_wipe_key(&self) -> Option<&Key> {
        self.data().wipe_key.as_ref()
    }

    /// Sets the new key which can wipe the token balance of an account.
    ///
    /// If the token does not currently have a Wipe key, transaction will resolve to `TokenHasNoWipeKey`.
    pub fn wipe_key(&mut self, wipe_key: impl Into<Key>) -> &mut Self {
        self.data_mut().wipe_key = Some(wipe_key.into());
        self
    }

    /// Returns the new key which can change the supply of a token.
    #[must_use]
    pub fn get_supply_key(&self) -> Option<&Key> {
        self.data().supply_key.as_ref()
    }

    /// Sets the new key which can change the supply of a token.
    ///
    /// If the token does not currently have a Supply key, transaction will resolve to `TokenHasNoSupplyKey`.
    pub fn supply_key(&mut self, supply_key: impl Into<Key>) -> &mut Self {
        self.data_mut().supply_key = Some(supply_key.into());
        self
    }

    /// Returns the new account which will be automatically charged to renew the token's expiration.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the new account which will be automatically charged to renew the token's expiration.
    pub fn auto_renew_account_id(&mut self, auto_renew_account_id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(auto_renew_account_id);
        self
    }

    /// Returns the new interval at which the auto renew account will be charged to extend the token's expiry.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.data().auto_renew_period
    }

    /// Sets the new interval at which the auto renew account will be charged to extend
    /// the token's expiry.
    pub fn auto_renew_period(&mut self, auto_renew_period: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = Some(auto_renew_period);
        self
    }

    /// Returns the new time at which the token should expire.
    #[must_use]
    pub fn get_expiration_time(&self) -> Option<OffsetDateTime> {
        self.data().expiration_time
    }

    /// Sets the new time at which the token should expire.
    ///
    /// If the new expiration time is earlier than the current expiration time, transaction
    /// will resolve to `InvalidExpirationTime`.
    pub fn expiration_time(&mut self, expiration_time: OffsetDateTime) -> &mut Self {
        let data = self.data_mut();
        data.expiration_time = Some(expiration_time);
        data.auto_renew_period = None;

        self
    }

    /// Returns the new memo associated with the token.
    #[must_use]
    pub fn get_token_memo(&self) -> Option<&str> {
        self.data().token_memo.as_deref()
    }

    /// Sets the new memo associated with the token.
    ///
    /// Maximum of 100 bytes.
    pub fn token_memo(&mut self, memo: Option<impl Into<String>>) -> &mut Self {
        self.data_mut().token_memo = memo.map(|m| m.into());
        self
    }

    /// Returns the new key which can change the token's custom fee schedule.
    #[must_use]
    pub fn get_fee_schedule_key(&self) -> Option<&Key> {
        self.data().fee_schedule_key.as_ref()
    }

    /// Sets the new key which can change the token's custom fee schedule.
    ///
    /// If the token does not currently have a fee schedule key, transaction will resolve to
    /// `TokenHasNoFeeScheduleKey`.
    pub fn fee_schedule_key(&mut self, fee_schedule_key: impl Into<Key>) -> &mut Self {
        self.data_mut().fee_schedule_key = Some(fee_schedule_key.into());
        self
    }

    /// Returns the new key which can pause and unpause the token.
    #[must_use]
    pub fn get_pause_key(&self) -> Option<&Key> {
        self.data().pause_key.as_ref()
    }

    /// Sets the new key which can pause and unpause the Token.
    ///
    /// If the token does not currently have a pause key, transaction will resolve to `TokenHasNoPauseKey`.
    pub fn pause_key(&mut self, pause_key: impl Into<Key>) -> &mut Self {
        self.data_mut().pause_key = Some(pause_key.into());
        self
    }

    /// Returns the new metadata of the created token definition.
    #[must_use]
    pub fn get_metadata(&self) -> Option<Vec<u8>> {
        self.data().metadata.clone()
    }

    /// Sets the new metadata of the token definition.
    pub fn metadata(&mut self, metadata: Vec<u8>) -> &mut Self {
        self.data_mut().metadata = Some(metadata);
        self
    }

    /// Returns the new key which can change the metadata of a token.
    #[must_use]
    pub fn get_metadata_key(&self) -> Option<&Key> {
        self.data().metadata_key.as_ref()
    }

    /// Sets the new key which can change the metadata of a token.
    pub fn metadata_key(&mut self, metadata_key: impl Into<Key>) -> &mut Self {
        self.data_mut().metadata_key = Some(metadata_key.into());
        self
    }

    /// Returns key verification mode.
    #[must_use]
    pub fn get_key_verification_mode(&self) -> TokenKeyValidation {
        self.data().key_verification_mode
    }

    /// Assignss key verification mode.
    pub fn key_verification_mode(
        &mut self,
        key_verification_mode: TokenKeyValidation,
    ) -> &mut Self {
        self.data_mut().key_verification_mode = key_verification_mode;
        self
    }
}

impl TransactionData for TokenUpdateTransactionData {}

impl TransactionExecute for TokenUpdateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).update_token(request).await })
    }
}

impl ValidateChecksums for TokenUpdateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.token_id.validate_checksums(ledger_id)?;
        self.auto_renew_account_id.validate_checksums(ledger_id)?;
        self.treasury_account_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenUpdateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenUpdate(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenUpdateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenUpdate(self.to_protobuf())
    }
}

impl From<TokenUpdateTransactionData> for AnyTransactionData {
    fn from(transaction: TokenUpdateTransactionData) -> Self {
        Self::TokenUpdate(transaction)
    }
}

impl FromProtobuf<services::TokenUpdateTransactionBody> for TokenUpdateTransactionData {
    fn from_protobuf(pb: services::TokenUpdateTransactionBody) -> crate::Result<Self> {
        let key_verification_mode =
            services::TokenKeyValidation::try_from(pb.key_verification_mode as i32)
                .unwrap_or_default();

        Ok(Self {
            token_id: Option::from_protobuf(pb.token)?,
            token_name: pb.name,
            token_symbol: pb.symbol,
            treasury_account_id: Option::from_protobuf(pb.treasury)?,
            admin_key: Option::from_protobuf(pb.admin_key)?,
            kyc_key: Option::from_protobuf(pb.kyc_key)?,
            freeze_key: Option::from_protobuf(pb.freeze_key)?,
            wipe_key: Option::from_protobuf(pb.wipe_key)?,
            supply_key: Option::from_protobuf(pb.supply_key)?,
            auto_renew_account_id: Option::from_protobuf(pb.auto_renew_account)?,
            auto_renew_period: pb.auto_renew_period.map(Into::into),
            expiration_time: pb.expiry.map(Into::into),
            token_memo: pb.memo,
            fee_schedule_key: Option::from_protobuf(pb.fee_schedule_key)?,
            pause_key: Option::from_protobuf(pb.pause_key)?,
            metadata: pb.metadata,
            metadata_key: Option::from_protobuf(pb.metadata_key)?,
            key_verification_mode: TokenKeyValidation::from_protobuf(key_verification_mode)?,
        })
    }
}

impl ToProtobuf for TokenUpdateTransactionData {
    type Protobuf = services::TokenUpdateTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenUpdateTransactionBody {
            token: self.token_id.to_protobuf(),
            name: self.token_name.clone(),
            symbol: self.token_symbol.clone(),
            treasury: self.treasury_account_id.to_protobuf(),
            admin_key: self.admin_key.to_protobuf(),
            kyc_key: self.kyc_key.to_protobuf(),
            freeze_key: self.freeze_key.to_protobuf(),
            wipe_key: self.wipe_key.to_protobuf(),
            supply_key: self.supply_key.to_protobuf(),
            expiry: self.expiration_time.map(Into::into),
            auto_renew_account: self.auto_renew_account_id.to_protobuf(),
            auto_renew_period: self.auto_renew_period.map(Into::into),
            memo: self.token_memo.clone(),
            fee_schedule_key: self.fee_schedule_key.to_protobuf(),
            pause_key: self.pause_key.to_protobuf(),
            metadata: self.metadata.clone(),
            metadata_key: self.metadata_key.to_protobuf(),
            key_verification_mode: self.key_verification_mode.to_protobuf().into(),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use expect_test::expect_file;
    use hedera_proto::services;
    use time::{
        Duration,
        OffsetDateTime,
    };

    use super::TokenUpdateTransactionData;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::token::token_key_validation_type::TokenKeyValidation;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        VALID_START,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        PrivateKey,
        PublicKey,
        TokenId,
        TokenUpdateTransaction,
    };

    fn test_admin_key() -> PublicKey {
        PrivateKey::from_str(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11").unwrap().public_key()
    }

    fn test_kyc_key() -> PublicKey {
        PrivateKey::from_str(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e12").unwrap().public_key()
    }

    fn test_freeze_key() -> PublicKey {
        PrivateKey::from_str(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e13").unwrap().public_key()
    }

    fn test_wipe_key() -> PublicKey {
        PrivateKey::from_str(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e14").unwrap().public_key()
    }

    fn test_supply_key() -> PublicKey {
        PrivateKey::from_str(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e15").unwrap().public_key()
    }

    fn test_fee_schedule_key() -> PublicKey {
        PrivateKey::from_str(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e16").unwrap().public_key()
    }

    fn test_pause_key() -> PublicKey {
        PrivateKey::from_str(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e17").unwrap().public_key()
    }

    fn test_metadata_key() -> PublicKey {
        PrivateKey::from_str(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e18").unwrap().public_key()
    }

    const TEST_TREASURY_ACCOUNT_ID: AccountId = AccountId::new(7, 7, 7);
    const TEST_AUTO_RENEW_ACCOUNT_ID: AccountId = AccountId::new(8, 8, 8);
    const TEST_TOKEN_NAME: &str = "test name";
    const TEST_TOKEN_SYMBOL: &str = "test symbol";
    const TEST_TOKEN_MEMO: &str = "test memo";
    const TEST_TOKEN_ID: TokenId = TokenId::new(4, 2, 0);
    const TEST_AUTO_RENEW_PERIOD: Duration = Duration::hours(10);
    const TEST_EXPIRATION_TIME: OffsetDateTime = VALID_START;
    const TEST_METADATA: &str = "Token Metadata";
    const TEST_KEY_VERIFICATION_MODE: TokenKeyValidation = TokenKeyValidation::FullValidation;

    fn make_transaction() -> TokenUpdateTransaction {
        let mut tx = TokenUpdateTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID)
            .fee_schedule_key(test_fee_schedule_key())
            .supply_key(test_supply_key())
            .admin_key(test_admin_key())
            .auto_renew_account_id(TEST_AUTO_RENEW_ACCOUNT_ID)
            .auto_renew_period(TEST_AUTO_RENEW_PERIOD)
            .freeze_key(test_freeze_key())
            .wipe_key(test_wipe_key())
            .token_symbol(TEST_TOKEN_SYMBOL)
            .kyc_key(test_kyc_key())
            .pause_key(test_pause_key())
            .expiration_time(TEST_EXPIRATION_TIME)
            .treasury_account_id(TEST_TREASURY_ACCOUNT_ID)
            .token_name(TEST_TOKEN_NAME)
            .token_memo(Some(TEST_TOKEN_MEMO))
            .metadata(TEST_METADATA.as_bytes().to_vec())
            .metadata_key(test_metadata_key())
            .key_verification_mode(TokenKeyValidation::NoValidation)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect_file!["./snapshots/token_update_transaction/serialize.txt"].assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenUpdateTransactionBody {
            token: Some(TEST_TOKEN_ID.to_protobuf()),
            symbol: TEST_TOKEN_SYMBOL.to_owned(),
            name: TEST_TOKEN_NAME.to_owned(),
            treasury: Some(TEST_TREASURY_ACCOUNT_ID.to_protobuf()),
            admin_key: Some(test_admin_key().to_protobuf()),
            kyc_key: Some(test_kyc_key().to_protobuf()),
            freeze_key: Some(test_freeze_key().to_protobuf()),
            wipe_key: Some(test_wipe_key().to_protobuf()),
            supply_key: Some(test_supply_key().to_protobuf()),
            auto_renew_account: Some(TEST_AUTO_RENEW_ACCOUNT_ID.to_protobuf()),
            auto_renew_period: Some(TEST_AUTO_RENEW_PERIOD.to_protobuf()),
            expiry: Some(TEST_EXPIRATION_TIME.to_protobuf()),
            memo: Some(TEST_TOKEN_MEMO.to_owned()),
            fee_schedule_key: Some(test_fee_schedule_key().to_protobuf()),
            pause_key: Some(test_pause_key().to_protobuf()),
            metadata: Some(TEST_METADATA.to_owned().into()),
            metadata_key: Some(test_metadata_key().to_protobuf()),
            key_verification_mode: TEST_KEY_VERIFICATION_MODE.to_protobuf().into(),
        };

        let tx = TokenUpdateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.token_id, Some(TEST_TOKEN_ID));
        assert_eq!(tx.token_name, TEST_TOKEN_NAME);
        assert_eq!(tx.token_symbol, TEST_TOKEN_SYMBOL);
        assert_eq!(tx.treasury_account_id, Some(TEST_TREASURY_ACCOUNT_ID));
        assert_eq!(tx.admin_key, Some(test_admin_key().into()));
        assert_eq!(tx.kyc_key, Some(test_kyc_key().into()));
        assert_eq!(tx.freeze_key, Some(test_freeze_key().into()));
        assert_eq!(tx.wipe_key, Some(test_wipe_key().into()));
        assert_eq!(tx.supply_key, Some(test_supply_key().into()));
        assert_eq!(tx.auto_renew_account_id, Some(TEST_AUTO_RENEW_ACCOUNT_ID));
        assert_eq!(tx.auto_renew_period, Some(TEST_AUTO_RENEW_PERIOD));
        assert_eq!(tx.expiration_time, Some(TEST_EXPIRATION_TIME));
        assert_eq!(tx.token_memo, Some(TEST_TOKEN_MEMO.into()));
        assert_eq!(tx.fee_schedule_key, Some(test_fee_schedule_key().into()));
        assert_eq!(tx.pause_key, Some(test_pause_key().into()));
        assert_eq!(tx.metadata, Some(TEST_METADATA.as_bytes().into()));
        assert_eq!(tx.metadata_key, Some(test_metadata_key().into()));
        assert_eq!(tx.key_verification_mode, TEST_KEY_VERIFICATION_MODE);
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenUpdateTransaction::new();
        tx.token_id(TEST_TOKEN_ID);
        assert_eq!(tx.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        let mut tx = make_transaction();
        tx.token_id(TEST_TOKEN_ID);
    }

    #[test]
    fn get_set_name() {
        let mut tx = TokenUpdateTransaction::new();
        tx.token_name(TEST_TOKEN_NAME);
        assert_eq!(tx.get_token_name(), TEST_TOKEN_NAME);
    }

    #[test]
    #[should_panic]
    fn get_set_name_frozen_panic() {
        let mut tx = make_transaction();
        tx.token_name(TEST_TOKEN_NAME);
    }

    #[test]
    fn get_set_symbol() {
        let mut tx = TokenUpdateTransaction::new();
        tx.token_symbol(TEST_TOKEN_SYMBOL);
        assert_eq!(tx.get_token_symbol(), TEST_TOKEN_SYMBOL);
    }

    #[test]
    #[should_panic]
    fn get_set_symbol_frozen_panic() {
        let mut tx = make_transaction();
        tx.token_symbol(TEST_TOKEN_SYMBOL);
    }

    #[test]
    fn get_set_treasury_account_id() {
        let mut tx = TokenUpdateTransaction::new();
        tx.treasury_account_id(TEST_TREASURY_ACCOUNT_ID);
        assert_eq!(tx.get_treasury_account_id(), Some(TEST_TREASURY_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_treasury_account_id_frozen_panic() {
        let mut tx = make_transaction();
        tx.treasury_account_id(TEST_TREASURY_ACCOUNT_ID);
    }

    #[test]
    fn get_set_admin_key() {
        let mut tx = TokenUpdateTransaction::new();
        tx.admin_key(test_admin_key());
        assert_eq!(tx.get_admin_key(), Some(&test_admin_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_admin_key_frozen_panic() {
        let mut tx = make_transaction();
        tx.admin_key(test_admin_key());
    }

    #[test]
    fn get_set_kyc_key() {
        let mut tx = TokenUpdateTransaction::new();
        tx.kyc_key(test_kyc_key());
        assert_eq!(tx.get_kyc_key(), Some(&test_kyc_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_kyc_key_frozen_panic() {
        let mut tx = make_transaction();
        tx.kyc_key(test_kyc_key());
    }

    #[test]
    fn get_set_freeze_key() {
        let mut tx = TokenUpdateTransaction::new();
        tx.freeze_key(test_freeze_key());
        assert_eq!(tx.get_freeze_key(), Some(&test_freeze_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_freeze_key_frozen_panic() {
        let mut tx = make_transaction();
        tx.freeze_key(test_freeze_key());
    }

    #[test]
    fn get_set_wipe_key() {
        let mut tx = TokenUpdateTransaction::new();
        tx.wipe_key(test_wipe_key());
        assert_eq!(tx.get_wipe_key(), Some(&test_wipe_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_wipe_key_frozen_panic() {
        let mut tx = make_transaction();
        tx.wipe_key(test_wipe_key());
    }

    #[test]
    fn get_set_supply_key() {
        let mut tx = TokenUpdateTransaction::new();
        tx.supply_key(test_supply_key());
        assert_eq!(tx.get_supply_key(), Some(&test_supply_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_supply_key_frozen_panic() {
        let mut tx = make_transaction();
        tx.supply_key(test_supply_key());
    }

    #[test]
    fn get_set_auto_renew_account_id() {
        let mut tx = TokenUpdateTransaction::new();
        tx.auto_renew_account_id(TEST_AUTO_RENEW_ACCOUNT_ID);
        assert_eq!(tx.get_auto_renew_account_id(), Some(TEST_AUTO_RENEW_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_account_id_frozen_panic() {
        let mut tx = make_transaction();
        tx.auto_renew_account_id(TEST_AUTO_RENEW_ACCOUNT_ID);
    }

    #[test]
    fn get_set_auto_renew_period() {
        let mut tx = TokenUpdateTransaction::new();
        tx.auto_renew_period(TEST_AUTO_RENEW_PERIOD);
        assert_eq!(tx.get_auto_renew_period(), Some(TEST_AUTO_RENEW_PERIOD));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_period_frozen_panic() {
        let mut tx = make_transaction();
        tx.auto_renew_period(TEST_AUTO_RENEW_PERIOD);
    }

    #[test]
    fn get_set_expiration_time() {
        let mut tx = TokenUpdateTransaction::new();
        tx.expiration_time(TEST_EXPIRATION_TIME);
        assert_eq!(tx.get_expiration_time(), Some(TEST_EXPIRATION_TIME));
    }

    #[test]
    #[should_panic]
    fn get_set_expiration_time_frozen_panic() {
        let mut tx = make_transaction();
        tx.expiration_time(TEST_EXPIRATION_TIME);
    }

    #[test]
    fn get_set_token_memo() {
        let mut tx = TokenUpdateTransaction::new();
        tx.token_memo(Some(TEST_TOKEN_MEMO));
        assert_eq!(tx.get_token_memo(), Some(TEST_TOKEN_MEMO));
    }

    #[test]
    #[should_panic]
    fn get_set_token_memo_frozen_panic() {
        let mut tx = make_transaction();
        tx.token_memo(Some(TEST_TOKEN_MEMO));
    }

    #[test]
    fn get_set_fee_schedule_key() {
        let mut tx = TokenUpdateTransaction::new();
        tx.fee_schedule_key(test_fee_schedule_key());
        assert_eq!(tx.get_fee_schedule_key(), Some(&test_fee_schedule_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_fee_schedule_key_frozen_panic() {
        let mut tx = make_transaction();
        tx.fee_schedule_key(test_fee_schedule_key());
    }

    #[test]
    fn get_set_pause_key() {
        let mut tx = TokenUpdateTransaction::new();
        tx.pause_key(test_pause_key());
        assert_eq!(tx.get_pause_key(), Some(&test_pause_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_pause_key_frozen_panic() {
        let mut tx = make_transaction();
        tx.pause_key(test_pause_key());
    }

    #[test]
    fn get_set_metadata() {
        let mut tx = TokenUpdateTransaction::new();
        tx.metadata(TEST_METADATA.as_bytes().to_vec());
        assert_eq!(tx.get_metadata(), Some(TEST_METADATA.as_bytes().to_vec()));
    }

    #[test]
    #[should_panic]
    fn get_set_metadata_frozen_panic() {
        let mut tx = make_transaction();
        tx.metadata(TEST_METADATA.as_bytes().to_vec());
    }

    #[test]
    fn get_set_metadata_key() {
        let mut tx = TokenUpdateTransaction::new();
        tx.metadata_key(test_metadata_key());
        assert_eq!(tx.get_metadata_key(), Some(&test_metadata_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_metadata_key_frozen_panic() {
        let mut tx = make_transaction();
        tx.metadata_key(test_metadata_key());
    }

    #[test]
    fn get_set_key_verification_mode() {
        let mut tx = TokenUpdateTransaction::new();
        tx.key_verification_mode(TokenKeyValidation::NoValidation);
        assert_eq!(tx.get_key_verification_mode(), TokenKeyValidation::NoValidation);
    }

    #[test]
    #[should_panic]
    fn get_set_key_verification_mode_frozen_panic() {
        let mut tx = make_transaction();
        tx.key_verification_mode(TokenKeyValidation::NoValidation);
    }
}
// Filename: src/token/token_wipe_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::token_service_client::TokenServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    TokenId,
    Transaction,
    ValidateChecksums,
};

/// Wipes the provided amount of tokens from the specified Account. Must be signed by the Token's
/// Wipe key.
///
/// On success, tokens are removed from the account and the total supply of the token is decreased by
/// the wiped amount.
///
/// The amount provided is in the lowest denomination possible. Example:
/// Token A has 2 decimals. In order to wipe 100 tokens from account, one must provide amount of 10000.
/// In order to wipe 100.55 tokens, one must provide amount of 10055.
///
/// - If the provided account is not found, the transaction will resolve to `INVALID_ACCOUNT_ID`.
/// - If the provided account has been deleted, the transaction will resolve to `ACCOUNT_DELETED`.
/// - If the provided token is not found, the transaction will resolve to `INVALID_TOKEN_ID`.
/// - If the provided token has been deleted, the transaction will resolve to `TOKEN_WAS_DELETED`.
/// - If an Association between the provided token and account is not found, the transaction will
/// resolve to `TOKEN_NOT_ASSOCIATED_TO_ACCOUNT`.
/// - If Wipe Key is not present in the Token, transaction results in `TOKEN_HAS_NO_WIPE_KEY`.
/// - If the provided account is the Token's Treasury Account, transaction results in
/// `CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT`
/// - If both amount and serialNumbers get filled, a `INVALID_TRANSACTION_BODY` response code will be
/// returned.
/// - If neither the amount nor the serialNumbers get filled, a `INVALID_WIPING_AMOUNT` response code
/// will be returned.
/// - If the serialNumbers list contains a non-positive integer as a serial number, a `INVALID_NFT_ID`
/// response code will be returned.
/// - If the serialNumbers' list count is greater than the batch size limit global dynamic property, a
/// `BATCH_SIZE_LIMIT_EXCEEDED` response code will be returned.
///
pub type TokenWipeTransaction = Transaction<TokenWipeTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TokenWipeTransactionData {
    /// The account to be wiped.
    account_id: Option<AccountId>,

    /// The token for which the account will be wiped.
    token_id: Option<TokenId>,

    // TODO change type of `amount` from `Option<u64>` to `u64`
    /// The amount of a fungible token to wipe from the specified account.
    amount: Option<u64>,

    /// The serial numbers of a non-fungible token to wipe from the specified account.
    serials: Vec<u64>,
}

impl TokenWipeTransaction {
    /// Returns the account to be wiped.
    #[must_use]
    pub fn get_account_id(&self) -> Option<AccountId> {
        self.data().account_id
    }

    /// Sets the account to be wiped.
    pub fn account_id(&mut self, account_id: AccountId) -> &mut Self {
        self.data_mut().account_id = Some(account_id);
        self
    }

    /// Returns the token for which the account will be wiped.
    #[must_use]
    pub fn get_token_id(&self) -> Option<TokenId> {
        self.data().token_id
    }

    /// Sets the token for which the account will be wiped.
    pub fn token_id(&mut self, token_id: impl Into<TokenId>) -> &mut Self {
        self.data_mut().token_id = Some(token_id.into());
        self
    }

    /// Returns the amount of a fungible token to wipe from the specified account.
    #[must_use]
    pub fn get_amount(&self) -> Option<u64> {
        self.data().amount
    }

    // TODO remove `impl Into<_>`
    /// Sets the amount of a fungible token to wipe from the specified account.
    pub fn amount(&mut self, amount: impl Into<u64>) -> &mut Self {
        self.data_mut().amount = Some(amount.into());
        self
    }

    /// Returns the serial numbers of a non-fungible token to wipe from the specified account.
    #[must_use]
    pub fn get_serials(&self) -> &[u64] {
        &self.data().serials
    }

    /// Sets the serial numbers of a non-fungible token to wipe from the specified account.
    pub fn serials(&mut self, serials: impl IntoIterator<Item = u64>) -> &mut Self {
        self.data_mut().serials = serials.into_iter().collect();
        self
    }
}

impl TransactionData for TokenWipeTransactionData {}

impl TransactionExecute for TokenWipeTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { TokenServiceClient::new(channel).wipe_token_account(request).await })
    }
}

impl ValidateChecksums for TokenWipeTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)?;
        self.token_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TokenWipeTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::TokenWipe(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TokenWipeTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::TokenWipe(self.to_protobuf())
    }
}

impl From<TokenWipeTransactionData> for AnyTransactionData {
    fn from(transaction: TokenWipeTransactionData) -> Self {
        Self::TokenWipe(transaction)
    }
}

impl FromProtobuf<services::TokenWipeAccountTransactionBody> for TokenWipeTransactionData {
    fn from_protobuf(pb: services::TokenWipeAccountTransactionBody) -> crate::Result<Self> {
        Ok(Self {
            account_id: Option::from_protobuf(pb.account)?,
            token_id: Option::from_protobuf(pb.token)?,
            amount: Some(pb.amount),
            serials: pb.serial_numbers.into_iter().map(|it| it as u64).collect(),
        })
    }
}
impl ToProtobuf for TokenWipeTransactionData {
    type Protobuf = services::TokenWipeAccountTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TokenWipeAccountTransactionBody {
            token: self.token_id.to_protobuf(),
            account: self.account_id.to_protobuf(),
            amount: self.amount.unwrap_or_default(),
            serial_numbers: self.serials.iter().map(|num| *num as i64).collect(),
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        TokenId,
        TokenWipeTransaction,
    };

    const TEST_ACCOUNT_ID: AccountId = AccountId::new(0, 6, 9);
    const TEST_TOKEN_ID: TokenId = TokenId::new(4, 2, 0);
    const TEST_AMOUNT: u64 = 4;
    const TEST_SERIALS: [u64; 3] = [8, 9, 10];
    fn make_transaction() -> TokenWipeTransaction {
        let mut tx = TokenWipeTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID)
            .account_id(TEST_ACCOUNT_ID)
            .amount(TEST_AMOUNT)
            .freeze()
            .unwrap();

        tx
    }

    fn make_transaction_nft() -> TokenWipeTransaction {
        let mut tx = TokenWipeTransaction::new_for_tests();

        tx.token_id(TEST_TOKEN_ID)
            .account_id(TEST_ACCOUNT_ID)
            .serials(TEST_SERIALS)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize_fungible() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenWipe(
                TokenWipeAccountTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 0,
                        },
                    ),
                    account: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 6,
                            account: Some(
                                AccountNum(
                                    9,
                                ),
                            ),
                        },
                    ),
                    amount: 4,
                    serial_numbers: [],
                },
            )
        "#]]
        .assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes_fungible() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn serialize_nft() {
        let tx = make_transaction_nft();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            TokenWipe(
                TokenWipeAccountTransactionBody {
                    token: Some(
                        TokenId {
                            shard_num: 4,
                            realm_num: 2,
                            token_num: 0,
                        },
                    ),
                    account: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 6,
                            account: Some(
                                AccountNum(
                                    9,
                                ),
                            ),
                        },
                    ),
                    amount: 0,
                    serial_numbers: [
                        8,
                        9,
                        10,
                    ],
                },
            )
        "#]]
        .assert_debug_eq(&tx);
    }

    #[test]
    fn to_from_bytes_nft() {
        let tx = make_transaction_nft();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);
        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::TokenWipeAccountTransactionBody {
            token: Some(TEST_TOKEN_ID.to_protobuf()),
            account: Some(TEST_ACCOUNT_ID.to_protobuf()),
            amount: TEST_AMOUNT,
            serial_numbers: TEST_SERIALS.into_iter().map(|it| it as i64).collect(),
        };

        let tx = super::TokenWipeTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.token_id, Some(TEST_TOKEN_ID));
        assert_eq!(tx.account_id, Some(TEST_ACCOUNT_ID));
        assert_eq!(tx.amount, Some(TEST_AMOUNT));
        assert_eq!(tx.serials, TEST_SERIALS);
    }

    #[test]
    fn get_set_token_id() {
        let mut tx = TokenWipeTransaction::new();
        tx.token_id(TEST_TOKEN_ID);

        assert_eq!(tx.get_token_id(), Some(TEST_TOKEN_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_token_id_frozen_panic() {
        let mut tx = make_transaction();
        tx.token_id(TEST_TOKEN_ID);
    }

    #[test]
    fn get_set_account_id() {
        let mut tx = TokenWipeTransaction::new();
        tx.account_id(TEST_ACCOUNT_ID);

        assert_eq!(tx.get_account_id(), Some(TEST_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_account_id_frozen_panic() {
        let mut tx = make_transaction();
        tx.account_id(TEST_ACCOUNT_ID);
    }

    #[test]
    fn get_set_amount() {
        let mut tx = TokenWipeTransaction::new();
        tx.amount(TEST_AMOUNT);

        assert_eq!(tx.get_amount(), Some(TEST_AMOUNT));
    }

    #[test]
    #[should_panic]
    fn get_set_amount_frozen_panic() {
        let mut tx = make_transaction();
        tx.amount(TEST_AMOUNT);
    }

    #[test]
    fn get_set_serial_numbers() {
        let mut tx = TokenWipeTransaction::new();
        tx.serials(TEST_SERIALS);

        assert_eq!(tx.get_serials(), TEST_SERIALS);
    }

    #[test]
    #[should_panic]
    fn get_set_serial_numbers_frozen_panic() {
        let mut tx = make_transaction_nft();
        tx.serials(TEST_SERIALS);
    }
}
// Filename: src/topic/mod.rs
// SPDX-License-Identifier: Apache-2.0

mod topic_create_transaction;
mod topic_delete_transaction;
mod topic_id;
mod topic_info;
mod topic_info_query;
mod topic_message;
mod topic_message_query;
mod topic_message_submit_transaction;
mod topic_update_transaction;

pub use topic_create_transaction::TopicCreateTransaction;
pub(crate) use topic_create_transaction::TopicCreateTransactionData;
pub use topic_delete_transaction::TopicDeleteTransaction;
pub(crate) use topic_delete_transaction::TopicDeleteTransactionData;
pub use topic_id::TopicId;
pub use topic_info::TopicInfo;
pub use topic_info_query::TopicInfoQuery;
pub(crate) use topic_info_query::TopicInfoQueryData;
pub use topic_message::TopicMessage;
pub use topic_message_query::TopicMessageQuery;
pub(crate) use topic_message_query::TopicMessageQueryData;
pub use topic_message_submit_transaction::TopicMessageSubmitTransaction;
pub(crate) use topic_message_submit_transaction::TopicMessageSubmitTransactionData;
pub use topic_update_transaction::TopicUpdateTransaction;
pub(crate) use topic_update_transaction::TopicUpdateTransactionData;
// Filename: src/topic/topic_create_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::consensus_service_client::ConsensusServiceClient;
use time::Duration;
use tonic::transport::Channel;

use crate::custom_fixed_fee::CustomFixedFee;
use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Hbar,
    Key,
    Transaction,
    ValidateChecksums,
};

/// Create a topic to be used for consensus.
///
/// If an `auto_renew_account_id` is specified, that account must also sign this transaction.
///
/// If an `admin_key` is specified, the adminKey must sign the transaction.
///
/// On success, the resulting `TransactionReceipt` contains the newly created `TopicId`.
///
pub type TopicCreateTransaction = Transaction<TopicCreateTransactionData>;

#[derive(Debug, Clone)]
pub struct TopicCreateTransactionData {
    /// Short publicly visible memo about the topic. No guarantee of uniqueness.
    topic_memo: String,

    /// Access control for `TopicUpdateTransaction` and `TopicDeleteTransaction`.
    admin_key: Option<Key>,

    /// Access control for `TopicMessageSubmitTransaction`.
    submit_key: Option<Key>,

    /// The initial lifetime of the topic and the amount of time to attempt to
    /// extend the topic's lifetime by automatically at the topic's expiration time, if
    /// the `auto_renew_account_id` is configured.
    auto_renew_period: Option<Duration>,

    /// Account to be used at the topic's expiration time to extend the life of the topic.
    auto_renew_account_id: Option<AccountId>,

    /// The key that can be used to update the custom fees for this topic.
    fee_schedule_key: Option<Key>,

    /// If the transaction contains a signer from this list, no custom fees are applied.
    fee_exempt_keys: Vec<Key>,

    /// The custom fee to be assessed during a message submission to this topic. Empty if no custom fees are applied.
    custom_fees: Vec<CustomFixedFee>,
}

impl Default for TopicCreateTransactionData {
    fn default() -> Self {
        Self {
            topic_memo: String::new(),
            admin_key: None,
            submit_key: None,
            auto_renew_period: Some(Duration::days(90)),
            auto_renew_account_id: None,
            fee_schedule_key: None,
            fee_exempt_keys: vec![],
            custom_fees: vec![],
        }
    }
}

impl TopicCreateTransaction {
    /// Returns the short, publicly visible, memo about the topic.
    #[must_use]
    pub fn get_topic_memo(&self) -> &str {
        &self.data().topic_memo
    }

    /// Sets the short publicly visible memo about the topic.
    ///
    /// No guarantee of uniqueness.
    pub fn topic_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().topic_memo = memo.into();
        self
    }

    /// Returns the access control for [`TopicUpdateTransaction`](crate::TopicUpdateTransaction)
    /// and [`TopicDeleteTransaction`](crate::TopicDeleteTransaction).
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.data().admin_key.as_ref()
    }

    /// Sets the access control for [`TopicUpdateTransaction`](crate::TopicUpdateTransaction)
    /// and [`TopicDeleteTransaction`](crate::TopicDeleteTransaction).
    pub fn admin_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().admin_key = Some(key.into());
        self
    }

    /// Returns the access control for [`TopicMessageSubmitTransaction`](crate::TopicMessageSubmitTransaction)
    #[must_use]
    pub fn get_submit_key(&self) -> Option<&Key> {
        self.data().submit_key.as_ref()
    }

    /// Sets the access control for [`TopicMessageSubmitTransaction`](crate::TopicMessageSubmitTransaction).
    pub fn submit_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().submit_key = Some(key.into());
        self
    }

    /// Returns the initial lifetime of the topic and the amount of time to attempt to
    /// extend the topic's lifetime by automatically at the topic's expiration time.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.data().auto_renew_period
    }

    /// Sets the initial lifetime of the topic and the amount of time to attempt to
    /// extend the topic's lifetime by automatically at the topic's expiration time.
    pub fn auto_renew_period(&mut self, period: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = Some(period);
        self
    }

    /// Returns the account to be used at the topic's expiration time to extend the life of the topic.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the account to be used at the topic's expiration time to extend the life of the topic.
    pub fn auto_renew_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(id);
        self
    }

    /// Sets the key that can be used to update the fee schedule for the topic.
    pub fn fee_schedule_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().fee_schedule_key = Some(key.into());
        self
    }

    /// The keys that can be used to update the fee schedule for the topic.
    #[must_use]
    pub fn get_fee_schedule_key(&self) -> Option<&Key> {
        self.data().fee_schedule_key.as_ref()
    }

    /// Sets the keys that can be used to update the fee schedule for the topic.
    pub fn fee_exempt_keys(&mut self, keys: Vec<Key>) -> &mut Self {
        self.data_mut().fee_exempt_keys = keys;
        self
    }

    /// The keys exempt from custom fees for this topic.
    #[must_use]
    pub fn get_fee_exempt_keys(&self) -> &Vec<Key> {
        &self.data().fee_exempt_keys
    }

    /// Clears the keys exempt from custom fees for this topic.
    pub fn clear_fee_exempt_keys(&mut self) -> &mut Self {
        self.data_mut().fee_exempt_keys.clear();
        self
    }

    /// Adds a key to the list of keys exempt from custom fees for this topic.
    pub fn add_fee_exempt_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().fee_exempt_keys.push(key.into());
        self
    }

    /// The custom fees to be assessed during a message submission to this topic.
    #[must_use]
    pub fn get_custom_fees(&self) -> &Vec<CustomFixedFee> {
        &self.data().custom_fees
    }

    /// Sets the custom fees to be assessed during a message submission to this topic.
    pub fn custom_fees(&mut self, fees: Vec<CustomFixedFee>) -> &mut Self {
        self.data_mut().custom_fees = fees;
        self
    }

    /// Clears the custom fees for this topic.
    pub fn clear_custom_fees(&mut self) -> &mut Self {
        self.data_mut().custom_fees.clear();
        self
    }

    /// Adds a custom fee to the list of custom fees for this topic.
    pub fn add_custom_fee(&mut self, fee: CustomFixedFee) -> &mut Self {
        self.data_mut().custom_fees.push(fee);
        self
    }
}

impl TransactionData for TopicCreateTransactionData {
    fn default_max_transaction_fee(&self) -> Hbar {
        Hbar::new(25)
    }
}

impl TransactionExecute for TopicCreateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { ConsensusServiceClient::new(channel).create_topic(request).await })
    }
}

impl ValidateChecksums for TopicCreateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.auto_renew_account_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TopicCreateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        // Generate the protobuf data
        let mut protobuf_data = self.to_protobuf();

        // Manually assign the auto_renew_account with operator_id if none is set
        if protobuf_data.auto_renew_account.is_none() {
            let operator_id = chunk_info.current_transaction_id.account_id;
            protobuf_data.auto_renew_account = Some(operator_id.to_protobuf());
        }
        services::transaction_body::Data::ConsensusCreateTopic(protobuf_data)
    }
}

impl ToSchedulableTransactionDataProtobuf for TopicCreateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::ConsensusCreateTopic(self.to_protobuf())
    }
}

impl From<TopicCreateTransactionData> for AnyTransactionData {
    fn from(transaction: TopicCreateTransactionData) -> Self {
        Self::TopicCreate(transaction)
    }
}

impl FromProtobuf<services::ConsensusCreateTopicTransactionBody> for TopicCreateTransactionData {
    fn from_protobuf(pb: services::ConsensusCreateTopicTransactionBody) -> crate::Result<Self> {
        let custom_fees = pb
            .custom_fees
            .into_iter()
            .map(CustomFixedFee::from_protobuf)
            .collect::<Result<Vec<_>, _>>()?;

        let fee_exempt_keys = pb
            .fee_exempt_key_list
            .into_iter()
            .map(Key::from_protobuf)
            .collect::<Result<Vec<_>, _>>()?;

        Ok(Self {
            topic_memo: pb.memo,
            admin_key: Option::from_protobuf(pb.admin_key)?,
            submit_key: Option::from_protobuf(pb.submit_key)?,
            auto_renew_period: pb.auto_renew_period.map(Into::into),
            auto_renew_account_id: Option::from_protobuf(pb.auto_renew_account)?,
            fee_schedule_key: Option::from_protobuf(pb.fee_schedule_key)?,
            fee_exempt_keys,
            custom_fees,
        })
    }
}

impl ToProtobuf for TopicCreateTransactionData {
    type Protobuf = services::ConsensusCreateTopicTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let custom_fees = self.custom_fees.iter().map(|fee| fee.to_protobuf()).collect::<Vec<_>>();
        let fee_exempt_key_list =
            self.fee_exempt_keys.iter().map(|key| key.to_protobuf()).collect::<Vec<_>>();
        let fee_schedule_key = self.fee_schedule_key.as_ref().map(|key| key.to_protobuf());

        services::ConsensusCreateTopicTransactionBody {
            auto_renew_account: self.auto_renew_account_id.to_protobuf(),
            memo: self.topic_memo.clone(),
            admin_key: self.admin_key.to_protobuf(),
            submit_key: self.submit_key.to_protobuf(),
            auto_renew_period: self.auto_renew_period.to_protobuf(),
            custom_fees,
            fee_exempt_key_list,
            fee_schedule_key,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use time::Duration;

    use super::TopicCreateTransactionData;
    use crate::custom_fixed_fee::CustomFixedFee;
    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        PrivateKey,
        PublicKey,
        TokenId,
        TopicCreateTransaction,
    };

    fn key() -> PublicKey {
        unused_private_key().public_key()
    }

    const AUTO_RENEW_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 5007);
    const AUTO_RENEW_PERIOD: Duration = Duration::days(1);

    fn make_transaction() -> TopicCreateTransaction {
        let mut tx = TopicCreateTransaction::new_for_tests();

        tx.submit_key(key())
            .admin_key(key())
            .auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID)
            .auto_renew_period(AUTO_RENEW_PERIOD)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ConsensusCreateTopic(
                ConsensusCreateTopicTransactionBody {
                    memo: "",
                    admin_key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    submit_key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    auto_renew_period: Some(
                        Duration {
                            seconds: 86400,
                        },
                    ),
                    auto_renew_account: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    5007,
                                ),
                            ),
                        },
                    ),
                    fee_schedule_key: None,
                    fee_exempt_key_list: [],
                    custom_fees: [],
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn from_proto_body() {
        let tx = services::ConsensusCreateTopicTransactionBody {
            memo: String::new(),
            admin_key: Some(key().to_protobuf()),
            submit_key: Some(key().to_protobuf()),
            auto_renew_period: Some(AUTO_RENEW_PERIOD.to_protobuf()),
            auto_renew_account: Some(AUTO_RENEW_ACCOUNT_ID.to_protobuf()),
            custom_fees: vec![],
            fee_exempt_key_list: vec![],
            fee_schedule_key: None,
        };

        let tx = TopicCreateTransactionData::from_protobuf(tx).unwrap();

        assert_eq!(tx.admin_key, Some(key().into()));
        assert_eq!(tx.submit_key, Some(key().into()));
        assert_eq!(tx.auto_renew_period, Some(AUTO_RENEW_PERIOD));
        assert_eq!(tx.auto_renew_account_id, Some(AUTO_RENEW_ACCOUNT_ID));
    }

    #[test]
    fn get_set_admin_key() {
        let mut tx = TopicCreateTransaction::new();
        tx.admin_key(key());

        assert_eq!(tx.get_admin_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_admin_key_frozen_panics() {
        make_transaction().admin_key(key());
    }

    #[test]
    fn get_set_submit_key() {
        let mut tx = TopicCreateTransaction::new();
        tx.submit_key(key());

        assert_eq!(tx.get_submit_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_submit_key_frozen_panics() {
        make_transaction().submit_key(key());
    }

    #[test]
    fn get_set_auto_renew_period() {
        let mut tx = TopicCreateTransaction::new();
        tx.auto_renew_period(AUTO_RENEW_PERIOD);

        assert_eq!(tx.get_auto_renew_period(), Some(AUTO_RENEW_PERIOD));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_period_frozen_panics() {
        make_transaction().auto_renew_period(AUTO_RENEW_PERIOD);
    }

    #[test]
    fn get_set_auto_renew_account_id() {
        let mut tx = TopicCreateTransaction::new();
        tx.auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID);

        assert_eq!(tx.get_auto_renew_account_id(), Some(AUTO_RENEW_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_account_id_frozen_panics() {
        make_transaction().auto_renew_account_id(AUTO_RENEW_ACCOUNT_ID);
    }

    #[test]
    fn get_set_fee_schedule_key() {
        let mut tx = TopicCreateTransaction::new();
        tx.fee_schedule_key(key());

        assert_eq!(tx.get_fee_schedule_key(), Some(&key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_fee_schedule_key_frozen_panics() {
        make_transaction().fee_schedule_key(key());
    }

    #[test]
    fn get_set_fee_exempt_keys() {
        let keys = vec![PrivateKey::generate_ecdsa(), PrivateKey::generate_ecdsa()];
        let mut tx = TopicCreateTransaction::new();
        tx.fee_exempt_keys(keys.iter().map(|key| key.public_key().into()).collect());

        assert_eq!(
            tx.get_fee_exempt_keys(),
            &keys.iter().map(|key| key.public_key().into()).collect::<Vec<_>>()
        );
    }

    #[test]
    fn get_set_custom_fees() {
        let mut tx = TopicCreateTransaction::new();
        tx.custom_fees(vec![
            CustomFixedFee::new(100, Some(TokenId::new(1, 2, 3)), Some(AccountId::new(4, 5, 6))),
            CustomFixedFee::new(200, None, None),
        ]);

        assert_eq!(
            tx.get_custom_fees(),
            &vec![
                CustomFixedFee::new(
                    100,
                    Some(TokenId::new(1, 2, 3)),
                    Some(AccountId::new(4, 5, 6))
                ),
                CustomFixedFee::new(200, None, None)
            ]
        );
    }

    #[test]
    fn add_topic_custom_fee_to_list() {
        let custom_fixed_fees = vec![
            CustomFixedFee::new(1, Some(TokenId::new(0, 0, 0)), None),
            CustomFixedFee::new(2, Some(TokenId::new(0, 0, 1)), None),
            CustomFixedFee::new(3, Some(TokenId::new(0, 0, 2)), None),
        ];

        let custom_fee_to_add = CustomFixedFee::new(4, Some(TokenId::new(0, 0, 3)), None);

        let mut expected_custom_fees = custom_fixed_fees.clone();
        expected_custom_fees.push(custom_fee_to_add.clone());

        let mut tx = TopicCreateTransaction::new();
        tx.custom_fees(custom_fixed_fees);
        tx.add_custom_fee(custom_fee_to_add);

        assert_eq!(tx.get_custom_fees().len(), expected_custom_fees.len());
        assert_eq!(tx.get_custom_fees(), &expected_custom_fees);
    }

    #[test]
    fn add_topic_custom_fee_to_empty_list() {
        let custom_fee_to_add = CustomFixedFee::new(4, Some(TokenId::new(0, 0, 3)), None);

        let mut tx = TopicCreateTransaction::new();
        tx.add_custom_fee(custom_fee_to_add.clone());

        assert_eq!(tx.get_custom_fees().len(), 1);
        assert_eq!(tx.get_custom_fees(), &vec![custom_fee_to_add]);
    }

    #[test]
    fn add_fee_exempt_key_to_empty_list() {
        let mut tx = TopicCreateTransaction::new();

        let fee_exempt_key = PrivateKey::generate_ecdsa();
        tx.add_fee_exempt_key(fee_exempt_key.public_key());

        assert_eq!(tx.get_fee_exempt_keys().len(), 1);
        assert_eq!(tx.get_fee_exempt_keys(), &vec![fee_exempt_key.public_key().into()]);
    }

    #[test]
    fn add_fee_exempt_key_to_list() {
        let fee_exempt_key = PrivateKey::generate_ecdsa();
        let mut tx = TopicCreateTransaction::new();
        tx.fee_exempt_keys(vec![fee_exempt_key.public_key().into()]);

        let fee_exempt_key_to_add = PrivateKey::generate_ecdsa();
        tx.add_fee_exempt_key(fee_exempt_key_to_add.public_key());

        let expected_keys =
            vec![fee_exempt_key.public_key().into(), fee_exempt_key_to_add.public_key().into()];

        assert_eq!(tx.get_fee_exempt_keys().len(), 2);
        assert_eq!(tx.get_fee_exempt_keys(), &expected_keys);
    }
}
// Filename: src/topic/topic_delete_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::consensus_service_client::ConsensusServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    TopicId,
    Transaction,
    ValidateChecksums,
};

/// Delete a topic.
///
/// No more transactions or queries on the topic will succeed.
///
/// If an `admin_key` is set, this transaction must be signed by that key.
/// If there is no `admin_key`, this transaction will fail `UNAUTHORIZED`.
///
pub type TopicDeleteTransaction = Transaction<TopicDeleteTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TopicDeleteTransactionData {
    /// The topic ID which is being deleted in this transaction.
    topic_id: Option<TopicId>,
}

impl TopicDeleteTransaction {
    /// Returns the ID of the topic which is being deleted in this transaction.
    #[must_use]
    pub fn get_topic_id(&self) -> Option<TopicId> {
        self.data().topic_id
    }

    /// Sets the topic ID which is being deleted in this transaction.
    pub fn topic_id(&mut self, id: impl Into<TopicId>) -> &mut Self {
        self.data_mut().topic_id = Some(id.into());
        self
    }
}

impl TransactionData for TopicDeleteTransactionData {}

impl TransactionExecute for TopicDeleteTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { ConsensusServiceClient::new(channel).delete_topic(request).await })
    }
}

impl ValidateChecksums for TopicDeleteTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.topic_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TopicDeleteTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::ConsensusDeleteTopic(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TopicDeleteTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::ConsensusDeleteTopic(self.to_protobuf())
    }
}

impl From<TopicDeleteTransactionData> for AnyTransactionData {
    fn from(transaction: TopicDeleteTransactionData) -> Self {
        Self::TopicDelete(transaction)
    }
}

impl FromProtobuf<services::ConsensusDeleteTopicTransactionBody> for TopicDeleteTransactionData {
    fn from_protobuf(pb: services::ConsensusDeleteTopicTransactionBody) -> crate::Result<Self> {
        Ok(Self { topic_id: Option::from_protobuf(pb.topic_id)? })
    }
}

impl ToProtobuf for TopicDeleteTransactionData {
    type Protobuf = services::ConsensusDeleteTopicTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ConsensusDeleteTopicTransactionBody { topic_id: self.topic_id.to_protobuf() }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AnyTransaction,
        TopicDeleteTransaction,
        TopicId,
    };

    fn make_transaction() -> TopicDeleteTransaction {
        let mut tx = TopicDeleteTransaction::new_for_tests();

        tx.topic_id("0.0.5007".parse::<TopicId>().unwrap()).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ConsensusDeleteTopic(
                ConsensusDeleteTopicTransactionBody {
                    topic_id: Some(
                        TopicId {
                            shard_num: 0,
                            realm_num: 0,
                            topic_num: 5007,
                        },
                    ),
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }
}
// Filename: src/topic/topic_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use hedera_proto::services;

use crate::entity_id::{
    Checksum,
    ValidateChecksums,
};
use crate::{
    Client,
    EntityId,
    Error,
    FromProtobuf,
    ToProtobuf,
};

/// The unique identifier for a topic on Hiero.
#[derive(Hash, PartialEq, Eq, Clone, Copy)]
#[repr(C)]
pub struct TopicId {
    /// A non-negative number identifying the shard containing this topic.
    pub shard: u64,

    /// A non-negative number identifying the realm within the shard containing this topic.
    pub realm: u64,

    /// A non-negative number identifying the entity within the realm containing this topic.
    pub num: u64,

    /// A checksum if the topic ID was read from a user inputted string which inclueded a checksum
    pub checksum: Option<Checksum>,
}

impl TopicId {
    /// Create a `TopicId` with the given `shard.realm.num`.
    pub const fn new(shard: u64, realm: u64, num: u64) -> Self {
        Self { shard, realm, num, checksum: None }
    }

    /// Create a new `TopicId` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Create a `TopicId` from a solidity address.
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `address` cannot be parsed as a solidity address.
    pub fn from_solidity_address(address: &str) -> crate::Result<Self> {
        let EntityId { shard, realm, num, checksum } = EntityId::from_solidity_address(address)?;

        Ok(Self { shard, realm, num, checksum })
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }

    /// Convert `self` into a solidity `address`
    ///
    /// # Errors
    /// - [`Error::BasicParse`] if `self.shard` is larger than `u32::MAX`.
    pub fn to_solidity_address(&self) -> crate::Result<String> {
        EntityId { shard: self.shard, realm: self.realm, num: self.num, checksum: None }
            .to_solidity_address()
    }

    /// Convert `self` to a string with a valid checksum.
    #[must_use]
    pub fn to_string_with_checksum(&self, client: &Client) -> String {
        EntityId::to_string_with_checksum(self.to_string(), client)
    }

    /// Validates `self.checksum` (if it exists) for `client`.
    ///
    /// # Errors
    /// - [`Error::BadEntityId`] if there is a checksum, and the checksum is not valid for the client's `ledger_id`.
    pub fn validate_checksum(&self, client: &Client) -> crate::Result<()> {
        EntityId::validate_checksum(self.shard, self.realm, self.num, self.checksum, client)
    }
}

impl ValidateChecksums for TopicId {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> Result<(), Error> {
        EntityId::validate_checksum_for_ledger_id(
            self.shard,
            self.realm,
            self.num,
            self.checksum,
            ledger_id,
        )
    }
}

impl Debug for TopicId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for TopicId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}.{}.{}", self.shard, self.realm, self.num)
    }
}

impl FromProtobuf<services::TopicId> for TopicId {
    fn from_protobuf(pb: services::TopicId) -> crate::Result<Self> {
        Ok(Self {
            num: pb.topic_num as u64,
            shard: pb.shard_num as u64,
            realm: pb.realm_num as u64,
            checksum: None,
        })
    }
}

impl ToProtobuf for TopicId {
    type Protobuf = services::TopicId;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TopicId {
            topic_num: self.num as i64,
            realm_num: self.realm as i64,
            shard_num: self.shard as i64,
        }
    }
}

impl From<u64> for TopicId {
    fn from(num: u64) -> Self {
        Self { num, shard: 0, realm: 0, checksum: None }
    }
}

impl FromStr for TopicId {
    type Err = crate::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        EntityId::from_str(s).map(Self::from)
    }
}

impl From<EntityId> for TopicId {
    fn from(value: EntityId) -> Self {
        let EntityId { shard, realm, num, checksum } = value;

        Self { shard, realm, num, checksum }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use expect_test::expect;

    use crate::TopicId;

    #[test]
    fn parse() {
        expect!["0.0.5005"].assert_eq(&TopicId::from_str("0.0.5005").unwrap().to_string());
    }

    #[test]
    fn from_bytes() {
        expect!["0.0.5005"].assert_eq(
            &TopicId::from_bytes(&TopicId::new(0, 0, 5005).to_bytes()).unwrap().to_string(),
        );
    }

    #[test]
    fn from_solidity_address() {
        expect!["0.0.5005"].assert_eq(
            &TopicId::from_solidity_address("000000000000000000000000000000000000138D")
                .unwrap()
                .to_string(),
        );
    }

    #[test]
    fn to_solidity_address() {
        expect!["000000000000000000000000000000000000138d"]
            .assert_eq(&TopicId::new(0, 0, 5005).to_solidity_address().unwrap());
    }
}
// Filename: src/topic/topic_info.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use time::{
    Duration,
    OffsetDateTime,
};

use crate::custom_fixed_fee::CustomFixedFee;
use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    FromProtobuf,
    Key,
    LedgerId,
    TopicId,
};

/// Response from [`TopicInfoQuery`][crate::TopicInfoQuery].

#[derive(Debug, Clone)]
pub struct TopicInfo {
    /// The ID of the topic for which information is requested.
    pub topic_id: TopicId,

    /// Short publicly visible memo about the topic. No guarantee of uniqueness
    pub topic_memo: String,

    /// SHA-384 running hash of (previousRunningHash, topicId, consensusTimestamp, sequenceNumber, message).
    pub running_hash: Vec<u8>,

    /// Sequence number (starting at 1 for the first submitMessage) of messages on the topic.
    pub sequence_number: u64,

    /// Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic.
    pub expiration_time: Option<OffsetDateTime>,

    /// Access control for update/delete of the topic.
    pub admin_key: Option<Key>,

    /// Access control for submit message.
    pub submit_key: Option<Key>,

    /// An account which will be automatically charged to renew the topic's expiration, at
    /// `auto_renew_period` interval.
    pub auto_renew_account_id: Option<AccountId>,

    /// The interval at which the auto-renew account will be charged to extend the topic's expiry.
    pub auto_renew_period: Option<Duration>,

    /// The ledger ID the response was returned from
    pub ledger_id: LedgerId,

    /// Access control for update/delete of custom fees.
    pub fee_schedule_key: Option<Key>,

    /// If the transaction contains a signer from this list, no custom fees are applied.
    pub fee_exempt_keys: Vec<Key>,

    /// List of custom fees.
    pub custom_fees: Vec<CustomFixedFee>,
}

impl TopicInfo {
    /// Create a new `TopicInfo` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::ConsensusGetTopicInfoResponse>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl FromProtobuf<services::response::Response> for TopicInfo {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let response = pb_getv!(pb, ConsensusGetTopicInfo, services::response::Response);
        Self::from_protobuf(response)
    }
}

impl FromProtobuf<services::ConsensusGetTopicInfoResponse> for TopicInfo {
    fn from_protobuf(pb: services::ConsensusGetTopicInfoResponse) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let topic_id = pb_getf!(pb, topic_id)?;
        let info = pb_getf!(pb, topic_info)?;
        let admin_key = Option::from_protobuf(info.admin_key)?;
        let submit_key = Option::from_protobuf(info.submit_key)?;
        let expiration_time = info.expiration_time.map(Into::into);
        let auto_renew_period = info.auto_renew_period.map(Into::into);
        let auto_renew_account_id = Option::from_protobuf(info.auto_renew_account)?;
        let ledger_id = LedgerId::from_bytes(info.ledger_id);
        let fee_schedule_key = Option::from_protobuf(info.fee_schedule_key)?;

        let mut fee_exempt_keys = Vec::new();
        for pb_key in info.fee_exempt_key_list {
            fee_exempt_keys.push(Key::from_protobuf(pb_key)?);
        }

        let mut custom_fees = Vec::new();
        for pb_fee in info.custom_fees {
            custom_fees.push(CustomFixedFee::from_protobuf(pb_fee)?);
        }

        Ok(Self {
            topic_id: TopicId::from_protobuf(topic_id)?,
            admin_key,
            submit_key,
            auto_renew_period,
            auto_renew_account_id,
            running_hash: info.running_hash,
            sequence_number: info.sequence_number,
            expiration_time,
            topic_memo: info.memo,
            ledger_id,
            fee_schedule_key,
            fee_exempt_keys,
            custom_fees,
        })
    }
}

impl ToProtobuf for TopicInfo {
    type Protobuf = services::ConsensusGetTopicInfoResponse;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::ConsensusGetTopicInfoResponse {
            topic_id: Some(self.topic_id.to_protobuf()),
            topic_info: Some(services::ConsensusTopicInfo {
                memo: self.topic_memo.clone(),
                running_hash: self.running_hash.clone(),
                sequence_number: self.sequence_number,
                expiration_time: self.expiration_time.to_protobuf(),
                admin_key: self.admin_key.to_protobuf(),
                submit_key: self.submit_key.to_protobuf(),
                auto_renew_period: self.auto_renew_period.to_protobuf(),
                auto_renew_account: self.auto_renew_account_id.to_protobuf(),
                ledger_id: self.ledger_id.to_bytes(),
                custom_fees: vec![],
                fee_exempt_key_list: vec![],
                fee_schedule_key: None,
            }),
            header: None,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use hedera_proto::services;
    use prost::Message;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::transaction::test_helpers::unused_private_key;
    use crate::{
        LedgerId,
        TopicInfo,
    };

    fn make_info() -> services::ConsensusGetTopicInfoResponse {
        services::ConsensusGetTopicInfoResponse {
            header: None,
            topic_id: Some(services::TopicId { shard_num: 1, realm_num: 2, topic_num: 3 }),
            topic_info: Some(services::ConsensusTopicInfo {
                memo: "1".to_owned(),
                running_hash: Vec::from([2]),
                sequence_number: 3,
                expiration_time: Some(services::Timestamp { seconds: 0, nanos: 4_000_000 }),
                admin_key: Some(unused_private_key().public_key().to_protobuf()),
                submit_key: Some(unused_private_key().public_key().to_protobuf()),
                auto_renew_period: Some(services::Duration { seconds: 5 * 24 * 60 * 60 }),
                auto_renew_account: Some(services::AccountId {
                    shard_num: 0,
                    realm_num: 0,
                    account: Some(services::account_id::Account::AccountNum(4)),
                }),
                ledger_id: LedgerId::testnet().to_bytes(),
                custom_fees: vec![],
                fee_exempt_key_list: vec![],
                fee_schedule_key: None,
            }),
        }
    }

    #[test]
    fn from_protobuf() {
        expect![[r#"
            TopicInfo {
                topic_id: "1.2.3",
                topic_memo: "1",
                running_hash: [
                    2,
                ],
                sequence_number: 3,
                expiration_time: Some(
                    1970-01-01 0:00:00.004 +00:00:00,
                ),
                admin_key: Some(
                    Single(
                        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
                    ),
                ),
                submit_key: Some(
                    Single(
                        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
                    ),
                ),
                auto_renew_account_id: Some(
                    "0.0.4",
                ),
                auto_renew_period: Some(
                    Duration {
                        seconds: 432000,
                        nanoseconds: 0,
                    },
                ),
                ledger_id: "testnet",
                fee_schedule_key: None,
                fee_exempt_keys: [],
                custom_fees: [],
            }
        "#]]
        .assert_debug_eq(&TopicInfo::from_protobuf(make_info()).unwrap())
    }

    #[test]
    fn to_protobuf() {
        expect![[r#"
            ConsensusGetTopicInfoResponse {
                header: None,
                topic_id: Some(
                    TopicId {
                        shard_num: 1,
                        realm_num: 2,
                        topic_num: 3,
                    },
                ),
                topic_info: Some(
                    ConsensusTopicInfo {
                        memo: "1",
                        running_hash: [
                            2,
                        ],
                        sequence_number: 3,
                        expiration_time: Some(
                            Timestamp {
                                seconds: 0,
                                nanos: 4000000,
                            },
                        ),
                        admin_key: Some(
                            Key {
                                key: Some(
                                    Ed25519(
                                        [
                                            224,
                                            200,
                                            236,
                                            39,
                                            88,
                                            165,
                                            135,
                                            159,
                                            250,
                                            194,
                                            38,
                                            161,
                                            60,
                                            12,
                                            81,
                                            107,
                                            121,
                                            158,
                                            114,
                                            227,
                                            81,
                                            65,
                                            160,
                                            221,
                                            130,
                                            143,
                                            148,
                                            211,
                                            121,
                                            136,
                                            164,
                                            183,
                                        ],
                                    ),
                                ),
                            },
                        ),
                        submit_key: Some(
                            Key {
                                key: Some(
                                    Ed25519(
                                        [
                                            224,
                                            200,
                                            236,
                                            39,
                                            88,
                                            165,
                                            135,
                                            159,
                                            250,
                                            194,
                                            38,
                                            161,
                                            60,
                                            12,
                                            81,
                                            107,
                                            121,
                                            158,
                                            114,
                                            227,
                                            81,
                                            65,
                                            160,
                                            221,
                                            130,
                                            143,
                                            148,
                                            211,
                                            121,
                                            136,
                                            164,
                                            183,
                                        ],
                                    ),
                                ),
                            },
                        ),
                        auto_renew_period: Some(
                            Duration {
                                seconds: 432000,
                            },
                        ),
                        auto_renew_account: Some(
                            AccountId {
                                shard_num: 0,
                                realm_num: 0,
                                account: Some(
                                    AccountNum(
                                        4,
                                    ),
                                ),
                            },
                        ),
                        ledger_id: [
                            1,
                        ],
                        fee_schedule_key: None,
                        fee_exempt_key_list: [],
                        custom_fees: [],
                    },
                ),
            }
        "#]]
        .assert_debug_eq(&TopicInfo::from_protobuf(make_info()).unwrap().to_protobuf())
    }

    #[test]
    fn from_bytes() {
        expect![[r#"
            TopicInfo {
                topic_id: "1.2.3",
                topic_memo: "1",
                running_hash: [
                    2,
                ],
                sequence_number: 3,
                expiration_time: Some(
                    1970-01-01 0:00:00.004 +00:00:00,
                ),
                admin_key: Some(
                    Single(
                        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
                    ),
                ),
                submit_key: Some(
                    Single(
                        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
                    ),
                ),
                auto_renew_account_id: Some(
                    "0.0.4",
                ),
                auto_renew_period: Some(
                    Duration {
                        seconds: 432000,
                        nanoseconds: 0,
                    },
                ),
                ledger_id: "testnet",
                fee_schedule_key: None,
                fee_exempt_keys: [],
                custom_fees: [],
            }
        "#]]
        .assert_debug_eq(&TopicInfo::from_bytes(&make_info().encode_to_vec()).unwrap())
    }
}
// Filename: src/topic/topic_info_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::consensus_service_client::ConsensusServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    Error,
    Query,
    ToProtobuf,
    TopicId,
    TopicInfo,
    ValidateChecksums,
};

/// Retrieve the latest state of a topic.
pub type TopicInfoQuery = Query<TopicInfoQueryData>;

#[derive(Default, Clone, Debug)]
pub struct TopicInfoQueryData {
    topic_id: Option<TopicId>,
}

impl From<TopicInfoQueryData> for AnyQueryData {
    #[inline]
    fn from(data: TopicInfoQueryData) -> Self {
        Self::TopicInfo(data)
    }
}

impl TopicInfoQuery {
    /// Returns the topic to retrieve info about.
    #[must_use]
    pub fn get_topic_id(&self) -> Option<TopicId> {
        self.data.topic_id
    }

    /// Sets the topic to retrieve info about.
    pub fn topic_id(&mut self, id: impl Into<TopicId>) -> &mut Self {
        self.data.topic_id = Some(id.into());
        self
    }
}

impl ToQueryProtobuf for TopicInfoQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let topic_id = self.topic_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::ConsensusGetTopicInfo(
                services::ConsensusGetTopicInfoQuery { topic_id, header: Some(header) },
            )),
        }
    }
}

impl QueryExecute for TopicInfoQueryData {
    type Response = TopicInfo;

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { ConsensusServiceClient::new(channel).get_topic_info(request).await })
    }
}

impl ValidateChecksums for TopicInfoQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.topic_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::{
        Hbar,
        TopicId,
        TopicInfoQuery,
    };

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    ConsensusGetTopicInfo(
                        ConsensusGetTopicInfoQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            topic_id: Some(
                                TopicId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    topic_num: 5005,
                                },
                            ),
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &TopicInfoQuery::new()
                .topic_id(TopicId::new(0, 0, 5005))
                .max_payment_amount(Hbar::from_tinybars(100_000))
                .data
                .to_query_protobuf(Default::default()),
        )
    }

    #[test]
    fn get_set_topic_id() {
        let mut query = TopicInfoQuery::new();
        query.topic_id(TopicId::new(0, 0, 5005));

        assert_eq!(query.get_topic_id(), Some(TopicId::new(0, 0, 5005)));
    }
}
// Filename: src/topic/topic_message.rs
// SPDX-License-Identifier: Apache-2.0

use std::iter;

use time::OffsetDateTime;

use crate::TransactionId;

/// Metadata for an individual chunk
#[non_exhaustive]
#[derive(Clone, Debug)]
pub struct TopicMessageChunk {
    /// The consensus timestamp for this chunk.
    pub consensus_timestamp: OffsetDateTime,

    /// How large the content of this specific chunk was.
    pub content_size: usize,

    /// The new running hash of the topic that received the message.
    pub running_hash: Vec<u8>,

    /// Sequence number for this chunk.
    pub sequence_number: u64,
}

/// Topic message records.
#[non_exhaustive]
#[derive(Clone, Debug)]
pub struct TopicMessage {
    /// The consensus timestamp of the message.
    ///
    /// If there are multiple chunks, this is taken from the *last* chunk.
    pub consensus_timestamp: OffsetDateTime,

    /// The content of the message.
    pub contents: Vec<u8>,

    /// The new running hash of the topic that received the message.
    ///
    /// If there are multiple chunks, this is taken from the *last* chunk.
    pub running_hash: Vec<u8>,

    /// Version of the SHA-384 digest used to update the running hash.
    ///
    /// If there are multiple chunks, this is taken from the *last* chunk.
    pub running_hash_version: u64,

    /// The sequence number of the message relative to all other messages
    /// for the same topic.
    ///
    /// If there are multiple chunks, this is taken from the *last* chunk.
    pub sequence_number: u64,

    /// The chunks that make up this message.
    pub chunks: Option<Vec<TopicMessageChunk>>,

    /// The [`TransactionId`] of the first chunk, gets copied to every subsequent chunk in the message.
    pub transaction: Option<TransactionId>,
}

impl TopicMessage {
    pub(crate) fn from_single(pb: PbTopicMessageHeader) -> Self {
        Self {
            consensus_timestamp: pb.consensus_timestamp,
            contents: pb.message,
            running_hash: pb.running_hash,
            running_hash_version: pb.running_hash_version,
            sequence_number: pb.sequence_number,
            chunks: None,
            transaction: None,
        }
    }

    pub(crate) fn from_chunks(pb: Vec<PbTopicMessageChunk>) -> Self {
        assert!(!pb.is_empty(), "no chunks provided to `TopicMessage::from_chunks`");

        if log::log_enabled!(log::Level::Warn) {
            let (first, rest) = pb.split_first().unwrap();

            if !rest.iter().all(|it| first.total == it.total) {
                log::warn!("`TopicMessageChunk` mismatched totals (ignoring)");
            }

            let all_ascending_no_gaps = pb.iter().all({
                let mut current = 1;
                move |it| {
                    let res = it.number == current;
                    current += 1;

                    res
                }
            });

            if !all_ascending_no_gaps {
                log::warn!("`TopicMessageChunk` mismatched numbers (ignoring)");
                // return Err(Error::from_protobuf("`TopicMessageChunk` mismatched numbers"));
            }
        }

        let contents = pb.iter().fold(Vec::new(), |mut acc, it| {
            acc.extend_from_slice(&it.header.message);
            acc
        });

        let mut pb = pb;

        let last = pb.pop().unwrap();

        let chunks = pb
            .into_iter()
            .map(|it| TopicMessageChunk {
                consensus_timestamp: it.header.consensus_timestamp,
                content_size: it.header.message.len(),
                running_hash: it.header.running_hash,
                sequence_number: it.header.sequence_number,
            })
            .chain(iter::once(TopicMessageChunk {
                consensus_timestamp: last.header.consensus_timestamp,
                content_size: last.header.message.len(),
                running_hash: last.header.running_hash.clone(),
                sequence_number: last.header.sequence_number,
            }))
            .collect();

        Self {
            consensus_timestamp: last.header.consensus_timestamp,
            contents,
            running_hash: last.header.running_hash,
            running_hash_version: last.header.running_hash_version,
            sequence_number: last.header.sequence_number,
            chunks: Some(chunks),
            transaction: Some(last.initial_transaction_id),
        }
    }
}

pub(crate) struct PbTopicMessageHeader {
    pub(crate) consensus_timestamp: OffsetDateTime,
    pub(crate) sequence_number: u64,
    pub(crate) running_hash: Vec<u8>,
    pub(crate) running_hash_version: u64,
    pub(crate) message: Vec<u8>,
}

pub(crate) struct PbTopicMessageChunk {
    pub(crate) header: PbTopicMessageHeader,
    pub(crate) initial_transaction_id: TransactionId,
    pub(crate) number: i32,
    pub(crate) total: i32,
}
// Filename: src/topic/topic_message_query.rs
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashMap;
use std::{
    mem,
    task,
};

use futures_core::future::BoxFuture;
use futures_core::stream::BoxStream;
use futures_core::Stream;
use futures_util::TryStreamExt;
use hedera_proto::mirror;
use hedera_proto::mirror::consensus_service_client::ConsensusServiceClient;
use hedera_proto::mirror::ConsensusTopicQuery;
use time::{
    Duration,
    OffsetDateTime,
};
use tonic::transport::Channel;
use tonic::Response;

use super::topic_message::{
    PbTopicMessageChunk,
    PbTopicMessageHeader,
};
use crate::mirror_query::{
    AnyMirrorQueryData,
    AnyMirrorQueryMessage,
    MirrorRequest,
};
use crate::protobuf::FromProtobuf;
use crate::{
    AnyMirrorQueryResponse,
    MirrorQuery,
    ToProtobuf,
    TopicId,
    TopicMessage,
    TransactionId,
};

// TODO: test, test, and test
// TODO: investigate failure scenarios

// TODO: validate checksums after PR is merged

#[derive(Default)]
pub struct TopicMessageQueryContext {
    start_time: Option<OffsetDateTime>,
}

/// Query a stream of Hiero Consensus Service (HCS)
/// messages for an HCS Topic via a specific (possibly open-ended) time range.
pub type TopicMessageQuery = MirrorQuery<TopicMessageQueryData>;

#[derive(Debug, Default, Clone)]
pub struct TopicMessageQueryData {
    /// The topic ID to retrieve messages for.
    topic_id: Option<TopicId>,

    /// Include messages which reached consensus on or after this time.
    /// Defaults to the current time.
    start_time: Option<OffsetDateTime>,

    /// Include messages which reached consensus before this time.
    end_time: Option<OffsetDateTime>,

    /// The maximum number of messages to receive before stopping.
    limit: u64,
}

impl TopicMessageQueryData {
    fn map_stream<'a, S>(stream: S) -> impl Stream<Item = crate::Result<TopicMessage>>
    where
        S: Stream<Item = crate::Result<mirror::ConsensusTopicResponse>> + Send + 'a,
    {
        MessagesMapStream { inner: stream, incomplete_messages: HashMap::new() }
    }
}

impl TopicMessageQuery {
    /// Returns the ID of the topic to retrieve messages for.
    #[must_use]
    pub fn get_topic_id(&self) -> Option<TopicId> {
        self.data.topic_id
    }

    /// Sets the topic ID to retrieve messages for.
    pub fn topic_id(&mut self, id: impl Into<TopicId>) -> &mut Self {
        self.data.topic_id = Some(id.into());
        self
    }

    /// Returns the minimum `consensus_timestamp` of the messages to return.
    #[must_use]
    pub fn get_start_time(&self) -> Option<OffsetDateTime> {
        self.data.start_time
    }

    /// Sets to include messages which reached consensus on or after this time.
    /// Defaults to the current time.
    pub fn start_time(&mut self, time: OffsetDateTime) -> &mut Self {
        self.data.start_time = Some(time);
        self
    }

    /// Returns the maximum `consensus_timestamp` of the messages to return.
    #[must_use]
    pub fn get_end_time(&self) -> Option<OffsetDateTime> {
        self.data.end_time
    }

    /// Sets to include messages which reached consensus before this time.
    pub fn end_time(&mut self, time: OffsetDateTime) -> &mut Self {
        self.data.end_time = Some(time);
        self
    }

    /// Returns maximum number of messages to be returned.
    #[must_use]
    pub fn get_limit(&self) -> u64 {
        self.data.limit
    }

    /// Sets the maximum number of messages to be returned, before closing the subscription.
    /// Defaults to _unlimited_.
    pub fn limit(&mut self, limit: u64) -> &mut Self {
        self.data.limit = limit;
        self
    }
}

impl From<TopicMessageQueryData> for AnyMirrorQueryData {
    fn from(data: TopicMessageQueryData) -> Self {
        Self::TopicMessage(data)
    }
}

impl MirrorRequest for TopicMessageQueryData {
    type GrpcItem = mirror::ConsensusTopicResponse;

    type ConnectStream = tonic::Streaming<Self::GrpcItem>;

    type Context = TopicMessageQueryContext;

    type Item = TopicMessage;

    type Response = Vec<TopicMessage>;

    type ItemStream<'a> = BoxStream<'a, crate::Result<TopicMessage>>;

    fn connect(
        &self,
        context: &Self::Context,
        channel: Channel,
    ) -> BoxFuture<'_, tonic::Result<Self::ConnectStream>> {
        let topic_id = self.topic_id.to_protobuf();

        let consensus_end_time = self.end_time.map(Into::into);

        // If we had to reconnect, we want to start 1ns after the last message we recieved.
        // We don't want to start *at* the last message we recieved because that'd give us that message again.
        let consensus_start_time = context
            .start_time
            .map(|it| it.checked_add(Duration::nanoseconds(1)).unwrap())
            .or(self.start_time)
            .map(Into::into);

        let request = ConsensusTopicQuery {
            consensus_end_time,
            consensus_start_time,
            topic_id,
            limit: self.limit,
        };

        Box::pin(async move {
            ConsensusServiceClient::new(channel)
                .subscribe_topic(request)
                .await
                .map(Response::into_inner)
        })
    }

    fn make_item_stream<'a, S>(stream: S) -> Self::ItemStream<'a>
    where
        S: Stream<Item = crate::Result<Self::GrpcItem>> + Send + 'a,
    {
        Box::pin(Self::map_stream(stream))
    }

    fn try_collect<'a, S>(stream: S) -> BoxFuture<'a, crate::Result<Self::Response>>
    where
        S: Stream<Item = crate::Result<Self::GrpcItem>> + Send + 'a,
    {
        // this doesn't reuse the work in `make_item_stream`
        Box::pin(Self::map_stream(stream).try_collect())
    }

    fn update_context(context: &mut Self::Context, item: &Self::GrpcItem) {
        context.start_time =
            item.consensus_timestamp.map(OffsetDateTime::from).or(context.start_time);
    }
}

impl From<TopicMessage> for AnyMirrorQueryMessage {
    fn from(value: TopicMessage) -> Self {
        Self::TopicMessage(value)
    }
}

impl From<Vec<TopicMessage>> for AnyMirrorQueryResponse {
    fn from(value: Vec<TopicMessage>) -> Self {
        Self::TopicMessage(value)
    }
}

enum IncompleteMessage {
    Partial(OffsetDateTime, Vec<PbTopicMessageChunk>),
    Expired,
    Complete,
}

impl IncompleteMessage {
    fn handle_expiry(&mut self) -> &mut Self {
        match self {
            IncompleteMessage::Partial(expiry, _) if *expiry < OffsetDateTime::now_utc() => {
                *self = Self::Expired;
            }
            _ => {}
        }

        self
    }
}

pin_project_lite::pin_project! {
    struct MessagesMapStream<S> {
        #[pin]
        inner: S,
        incomplete_messages: HashMap<TransactionId, IncompleteMessage>,
    }
}

impl<S> Stream for MessagesMapStream<S>
where
    S: Stream<Item = crate::Result<mirror::ConsensusTopicResponse>> + Send,
{
    type Item = crate::Result<TopicMessage>;

    fn poll_next(
        self: std::pin::Pin<&mut Self>,
        cx: &mut task::Context<'_>,
    ) -> task::Poll<Option<Self::Item>> {
        use task::Poll;

        let mut this = self.project();

        loop {
            let item = match task::ready!(this.inner.as_mut().poll_next(cx)) {
                Some(Ok(item)) => item,
                Some(Err(e)) => return Poll::Ready(Some(Err(e))),
                None => return Poll::Ready(None),
            };

            match filter_map(item, this.incomplete_messages) {
                Ok(Some(item)) => return Poll::Ready(Some(Ok(item))),
                Ok(None) => {}
                Err(e) => return Poll::Ready(Some(Err(e))),
            }
        }
    }
}

fn filter_map(
    mut item: mirror::ConsensusTopicResponse,
    incomplete_messages: &mut HashMap<TransactionId, IncompleteMessage>,
) -> crate::Result<Option<TopicMessage>> {
    let header = PbTopicMessageHeader {
        consensus_timestamp: pb_getf!(item, consensus_timestamp)?.into(),
        sequence_number: item.sequence_number,
        running_hash: item.running_hash,
        running_hash_version: item.running_hash_version,
        message: item.message,
    };

    let item = match item.chunk_info.take() {
        Some(chunk_info) if chunk_info.total > 1 => PbTopicMessageChunk {
            header,
            initial_transaction_id: TransactionId::from_protobuf(pb_getf!(
                chunk_info,
                initial_transaction_id
            )?)?,
            number: chunk_info.number,
            total: chunk_info.total,
        },
        _ => return Ok(Some(TopicMessage::from_single(header))),
    };

    let tx_id = item.initial_transaction_id;

    let entry = incomplete_messages.entry(tx_id).or_insert_with(|| {
        IncompleteMessage::Partial(
            // todo: configurable?
            OffsetDateTime::now_utc() + time::Duration::minutes(15),
            Vec::new(),
        )
    });

    let IncompleteMessage::Partial(_, messages) = entry.handle_expiry() else { return Ok(None) };

    match messages.binary_search_by_key(&item.number, |it| it.number) {
        // We have a duplicate `number`, so, we'll just ignore it (this is unspecified behavior)
        Ok(_) => {}
        Err(index) => messages.insert(index, item),
    };

    // find the smallest `total` so that we aren't susceptable to stuff like total changing (and getting bigger)
    // later on there's a check that ensures that they all have the same total.
    let total = messages.iter().map(|it| it.total).min().unwrap();

    // note: because of the way we handle `total`, `total` can get *smaller*.

    match messages.len() >= total as usize {
        true => {
            let messages = mem::take(messages);
            *entry = IncompleteMessage::Complete;
            Ok(Some(TopicMessage::from_chunks(messages)))
        }

        false => Ok(None),
    }
}

#[cfg(test)]
mod tests {
    use time::OffsetDateTime;

    use crate::{
        TopicId,
        TopicMessageQuery,
    };

    #[test]
    fn get_set_topic_id() {
        let mut query = TopicMessageQuery::new();
        query.topic_id(TopicId::new(31, 41, 59));

        assert_eq!(query.get_topic_id(), Some(TopicId::new(31, 41, 59)));
    }
    #[test]
    fn get_set_start_time() {
        let start_time = OffsetDateTime::now_utc();

        let mut query = TopicMessageQuery::new();
        query.start_time(start_time);

        assert_eq!(query.get_start_time(), Some(start_time));
    }
    #[test]
    fn get_set_end_time() {
        let end_time = OffsetDateTime::now_utc();

        let mut query = TopicMessageQuery::new();
        query.end_time(end_time);

        assert_eq!(query.get_end_time(), Some(end_time));
    }
    #[test]
    fn get_set_limit() {
        let mut query = TopicMessageQuery::new();
        query.limit(1415);

        assert_eq!(query.get_limit(), 1415);
    }
}
// Filename: src/topic/topic_message_submit_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use std::cmp;
use std::num::NonZeroUsize;

use hedera_proto::services;
use hedera_proto::services::consensus_service_client::ConsensusServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkData,
    ChunkInfo,
    ChunkedTransactionData,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
    TransactionExecuteChunked,
};
use crate::{
    BoxGrpcFuture,
    Error,
    TopicId,
    Transaction,
    ValidateChecksums,
};

/// Submit a message for consensus.
///
/// Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
/// mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
///
/// The `submit_key` (if any) must sign this transaction.
///
/// On success, the resulting `TransactionReceipt` contains the topic's updated `topic_sequence_number` and
/// `topic_running_hash`.
///
pub type TopicMessageSubmitTransaction = Transaction<TopicMessageSubmitTransactionData>;

#[derive(Debug, Default, Clone)]
pub struct TopicMessageSubmitTransactionData {
    /// The topic ID to submit this message to.
    topic_id: Option<TopicId>,

    chunk_data: ChunkData,
}

impl TopicMessageSubmitTransaction {
    /// Returns the ID of the topic this message will be submitted to.
    #[must_use]
    pub fn get_topic_id(&self) -> Option<TopicId> {
        self.data().topic_id
    }

    /// Sets the topic ID to submit this message to.
    pub fn topic_id(&mut self, id: impl Into<TopicId>) -> &mut Self {
        self.data_mut().topic_id = Some(id.into());
        self
    }

    /// Returns the message to be submitted.
    pub fn get_message(&self) -> Option<&[u8]> {
        Some(self.data().chunk_data.data.as_slice())
    }

    /// Sets the message to be submitted.
    pub fn message(&mut self, bytes: impl Into<Vec<u8>>) -> &mut Self {
        self.data_mut().chunk_data_mut().data = bytes.into();
        self
    }
}

impl TransactionData for TopicMessageSubmitTransactionData {
    fn maybe_chunk_data(&self) -> Option<&ChunkData> {
        Some(self.chunk_data())
    }

    fn wait_for_receipt(&self) -> bool {
        false
    }
}

impl ChunkedTransactionData for TopicMessageSubmitTransactionData {
    fn chunk_data(&self) -> &ChunkData {
        &self.chunk_data
    }

    fn chunk_data_mut(&mut self) -> &mut ChunkData {
        &mut self.chunk_data
    }
}

impl TransactionExecute for TopicMessageSubmitTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { ConsensusServiceClient::new(channel).submit_message(request).await })
    }
}

impl TransactionExecuteChunked for TopicMessageSubmitTransactionData {}

impl ValidateChecksums for TopicMessageSubmitTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.topic_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TopicMessageSubmitTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        services::transaction_body::Data::ConsensusSubmitMessage(
            services::ConsensusSubmitMessageTransactionBody {
                topic_id: self.topic_id.to_protobuf(),
                message: self.chunk_data.message_chunk(chunk_info).to_vec(),
                chunk_info: (chunk_info.total > 1).then(|| services::ConsensusMessageChunkInfo {
                    initial_transaction_id: Some(chunk_info.initial_transaction_id.to_protobuf()),
                    number: (chunk_info.current + 1) as i32,
                    total: chunk_info.total as i32,
                }),
            },
        )
    }
}

impl ToSchedulableTransactionDataProtobuf for TopicMessageSubmitTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        assert!(
            self.chunk_data.used_chunks() == 1,
            "Cannot schedule a `TopicMessageSubmitTransaction` with multiple chunks"
        );

        let data = services::ConsensusSubmitMessageTransactionBody {
            topic_id: self.topic_id.to_protobuf(),
            message: self.chunk_data.data.clone(),
            chunk_info: None,
        };

        services::schedulable_transaction_body::Data::ConsensusSubmitMessage(data)
    }
}

impl From<TopicMessageSubmitTransactionData> for AnyTransactionData {
    fn from(transaction: TopicMessageSubmitTransactionData) -> Self {
        Self::TopicMessageSubmit(transaction)
    }
}

impl FromProtobuf<services::ConsensusSubmitMessageTransactionBody>
    for TopicMessageSubmitTransactionData
{
    fn from_protobuf(pb: services::ConsensusSubmitMessageTransactionBody) -> crate::Result<Self> {
        Self::from_protobuf(Vec::from([pb]))
    }
}

impl FromProtobuf<Vec<services::ConsensusSubmitMessageTransactionBody>>
    for TopicMessageSubmitTransactionData
{
    fn from_protobuf(
        pb: Vec<services::ConsensusSubmitMessageTransactionBody>,
    ) -> crate::Result<Self> {
        let total_chunks = pb.len();

        let mut iter = pb.into_iter();
        let pb_first = iter.next().expect("Empty transaction (should've been handled earlier)");

        let topic_id = Option::from_protobuf(pb_first.topic_id)?;

        let mut largest_chunk_size = pb_first.message.len();
        let mut message = pb_first.message;

        // note: no other SDK checks for correctness here... so let's not do it here either?

        for item in iter {
            largest_chunk_size = cmp::max(largest_chunk_size, item.message.len());
            message.extend_from_slice(&item.message);
        }

        Ok(Self {
            topic_id,
            chunk_data: ChunkData {
                max_chunks: total_chunks,
                chunk_size: NonZeroUsize::new(largest_chunk_size)
                    .unwrap_or_else(|| NonZeroUsize::new(1).unwrap()),
                data: message,
            },
        })
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::transaction::test_helpers::{
        check_body,
        transaction_bodies,
    };
    use crate::{
        AnyTransaction,
        TopicId,
        TopicMessageSubmitTransaction,
    };

    const TOPIC_ID: TopicId = TopicId::new(0, 0, 10);

    const MESSAGE: &[u8] = br#"{"foo": 231}"#;

    fn make_transaction() -> TopicMessageSubmitTransaction {
        let mut tx = TopicMessageSubmitTransaction::new_for_tests();
        tx.topic_id(TOPIC_ID).message(MESSAGE).freeze().unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        // unlike most transactions we *do* need to do this like in case it's chunked.
        // granted, trying to do anything with a chunked transaction without a Client is hard.
        let txes = transaction_bodies(tx);

        // this is kinda a mess... But it works.
        let txes: Vec<_> = txes.into_iter().map(check_body).collect();

        expect![[r#"
            [
                ConsensusSubmitMessage(
                    ConsensusSubmitMessageTransactionBody {
                        topic_id: Some(
                            TopicId {
                                shard_num: 0,
                                realm_num: 0,
                                topic_num: 10,
                            },
                        ),
                        message: [
                            123,
                            34,
                            102,
                            111,
                            111,
                            34,
                            58,
                            32,
                            50,
                            51,
                            49,
                            125,
                        ],
                        chunk_info: None,
                    },
                ),
                ConsensusSubmitMessage(
                    ConsensusSubmitMessageTransactionBody {
                        topic_id: Some(
                            TopicId {
                                shard_num: 0,
                                realm_num: 0,
                                topic_num: 10,
                            },
                        ),
                        message: [
                            123,
                            34,
                            102,
                            111,
                            111,
                            34,
                            58,
                            32,
                            50,
                            51,
                            49,
                            125,
                        ],
                        chunk_info: None,
                    },
                ),
            ]
        "#]]
        .assert_debug_eq(&txes);
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_bodies(tx);
        let tx2 = transaction_bodies(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn get_set_topic_id() {
        let mut tx = TopicMessageSubmitTransaction::new();
        tx.topic_id(TOPIC_ID);

        assert_eq!(tx.get_topic_id(), Some(TOPIC_ID));
    }

    #[test]
    fn get_set_message() {
        let mut tx = TopicMessageSubmitTransaction::new();
        tx.message(MESSAGE);

        assert_eq!(tx.get_message(), Some(MESSAGE));
    }

    #[test]
    #[should_panic]
    fn get_set_topic_id_frozen_panics() {
        let mut tx = make_transaction();
        tx.topic_id(TOPIC_ID);
    }

    #[test]
    #[should_panic]
    fn get_set_message_frozen_panics() {
        let mut tx = make_transaction();
        tx.message(MESSAGE);
    }
}
// Filename: src/topic/topic_update_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::consensus_service_client::ConsensusServiceClient;
use time::{
    Duration,
    OffsetDateTime,
};
use tonic::transport::Channel;

use crate::custom_fixed_fee::CustomFixedFee;
use crate::ledger_id::RefLedgerId;
use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Key,
    TopicId,
    Transaction,
    ValidateChecksums,
};

/// Change properties for the given topic.
///
/// Any null field is ignored (left unchanged).
///
pub type TopicUpdateTransaction = Transaction<TopicUpdateTransactionData>;

#[derive(Debug, Clone, Default)]
pub struct TopicUpdateTransactionData {
    /// The topic ID which is being updated in this transaction.
    topic_id: Option<TopicId>,

    /// The new expiration time to extend to (ignored if equal to or before the current one).
    expiration_time: Option<OffsetDateTime>,

    /// Short publicly visible memo about the topic. No guarantee of uniqueness.
    topic_memo: Option<String>,

    /// Access control for `TopicUpdateTransaction` and `TopicDeleteTransaction`.
    admin_key: Option<Key>,

    /// Access control for `TopicMessageSubmitTransaction`.
    submit_key: Option<Key>,

    /// The initial lifetime of the topic and the amount of time to attempt to
    /// extend the topic's lifetime by automatically at the topic's expiration time, if
    /// the `auto_renew_account_id` is configured.
    auto_renew_period: Option<Duration>,

    /// Optional account to be used at the topic's expiration time to extend the life of the topic.
    auto_renew_account_id: Option<AccountId>,

    /// Access control for update/delete of custom fees.
    /// None if the key should not be updated.
    fee_schedule_key: Option<Key>,

    /// If the transaction contains a signer from this list, no custom fees are applied.
    fee_exempt_keys: Vec<Key>,

    /// The custom fee to be assessed during a message submission to this topic.
    custom_fees: Option<Vec<CustomFixedFee>>,
}

impl TopicUpdateTransaction {
    /// Returns the topic ID which is being updated.
    #[must_use]
    pub fn get_topic_id(&self) -> Option<TopicId> {
        self.data().topic_id
    }

    /// Sets the topic ID which is being updated.
    pub fn topic_id(&mut self, id: impl Into<TopicId>) -> &mut Self {
        self.data_mut().topic_id = Some(id.into());
        self
    }

    /// Returns the new expiration time to extend to (ignored if equal to or before the current one).
    #[must_use]
    pub fn get_expiration_time(&self) -> Option<OffsetDateTime> {
        self.data().expiration_time
    }

    /// Sets the new expiration time to extend to (ignored if equal to or before the current one).
    pub fn expiration_time(&mut self, at: OffsetDateTime) -> &mut Self {
        self.data_mut().expiration_time = Some(at);
        self
    }

    /// Returns the new topic memo for the topic.
    #[must_use]
    pub fn get_topic_memo(&self) -> Option<&str> {
        self.data().topic_memo.as_deref()
    }

    /// Sets the short publicly visible memo about the topic.
    ///
    /// No guarantee of uniqueness.
    pub fn topic_memo(&mut self, memo: impl Into<String>) -> &mut Self {
        self.data_mut().topic_memo = Some(memo.into());
        self
    }

    /// Returns the access control for [`TopicUpdateTransaction`] and [`TopicDeleteTransaction`](crate::TopicDeleteTransaction).
    #[must_use]
    pub fn get_admin_key(&self) -> Option<&Key> {
        self.data().admin_key.as_ref()
    }

    /// Sets the access control for [`TopicUpdateTransaction`] and [`TopicDeleteTransaction`](crate::TopicDeleteTransaction).
    pub fn admin_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().admin_key = Some(key.into());
        self
    }

    /// Clears the access control for [`TopicUpdateTransaction`] and [`TopicDeleteTransaction`](crate::TopicDeleteTransaction).
    pub fn clear_admin_key(&mut self) -> &mut Self {
        self.data_mut().admin_key = Some(Key::KeyList(crate::KeyList::new()));
        self
    }

    /// Returns the access control for [`TopicMessageSubmitTransaction`](crate::TopicMessageSubmitTransaction).
    #[must_use]
    pub fn get_submit_key(&self) -> Option<&Key> {
        self.data().submit_key.as_ref()
    }

    /// Sets the access control for [`TopicMessageSubmitTransaction`](crate::TopicMessageSubmitTransaction).
    pub fn submit_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().submit_key = Some(key.into());
        self
    }
    /// Clears the access control for [`TopicUpdateTransaction`] and [`TopicDeleteTransaction`](crate::TopicDeleteTransaction).
    pub fn clear_submit_key(&mut self) -> &mut Self {
        self.data_mut().submit_key = Some(Key::KeyList(crate::KeyList::new()));
        self
    }

    /// Returns the initial lifetime of the topic and the amount of time to attempt to
    /// extend the topic's lifetime by automatically at the topic's expiration time.
    #[must_use]
    pub fn get_auto_renew_period(&self) -> Option<Duration> {
        self.data().auto_renew_period
    }

    /// Sets the initial lifetime of the topic and the amount of time to attempt to
    /// extend the topic's lifetime by automatically at the topic's expiration time.
    pub fn auto_renew_period(&mut self, period: Duration) -> &mut Self {
        self.data_mut().auto_renew_period = Some(period);
        self
    }

    /// Returns the account to be used at the topic's expiration time to extend the life of the topic.
    #[must_use]
    pub fn get_auto_renew_account_id(&self) -> Option<AccountId> {
        self.data().auto_renew_account_id
    }

    /// Sets the account to be used at the topic's expiration time to extend the life of the topic.
    pub fn auto_renew_account_id(&mut self, id: AccountId) -> &mut Self {
        self.data_mut().auto_renew_account_id = Some(id);
        self
    }

    /// Clear the auto renew account ID for this topic.
    pub fn clear_auto_renew_account_id(&mut self) -> &mut Self {
        self.auto_renew_account_id(AccountId {
            shard: 0,
            realm: 0,
            num: 0,
            alias: None,
            evm_address: None,
            checksum: None,
        })
    }

    /// The key that can be used to update the fee schedule for the topic.
    pub fn fee_schedule_key(&mut self, key: impl Into<Key>) -> &mut Self {
        self.data_mut().fee_schedule_key = Some(key.into());
        self
    }

    /// The key that can be used to update the fee schedule for the topic.
    #[must_use]
    pub fn get_fee_schedule_key(&self) -> Option<&Key> {
        self.data().fee_schedule_key.as_ref()
    }

    /// The keys that can be used to update the fee schedule for the topic.
    pub fn fee_exempt_keys(&mut self, keys: Vec<Key>) -> &mut Self {
        self.data_mut().fee_exempt_keys = keys;
        self
    }

    /// The keys that can be used to update the fee schedule for the topic.
    #[must_use]
    pub fn get_fee_exempt_keys(&self) -> &Vec<Key> {
        &self.data().fee_exempt_keys
    }

    /// Clears the keys that can be used to update the fee schedule for the topic.
    pub fn clear_fee_exempt_keys(&mut self) -> &mut Self {
        self.data_mut().fee_exempt_keys = vec![];
        self
    }

    /// Adds a key to the list of keys that can be used to update the fee schedule for the topic.
    pub fn add_fee_exempt_key(&mut self, key: Key) -> &mut Self {
        self.data_mut().fee_exempt_keys.push(key);
        self
    }

    /// The custom fees to be assessed during a message submission to this topic.
    pub fn custom_fees(&mut self, fees: Vec<CustomFixedFee>) -> &mut Self {
        self.data_mut().custom_fees = Some(fees);
        self
    }

    /// Clears the custom fees for this topic.
    pub fn clear_custom_fees(&mut self) -> &mut Self {
        self.data_mut().custom_fees = None;
        self
    }

    /// The custom fees to be assessed during a message submission to this topic.
    #[must_use]
    pub fn get_custom_fees(&self) -> Option<&Vec<CustomFixedFee>> {
        self.data().custom_fees.as_ref()
    }

    /// Adds a custom fee to the list of custom fees for this topic.
    pub fn add_custom_fee(&mut self, fee: CustomFixedFee) -> &mut Self {
        self.data_mut().custom_fees = Some(vec![fee]);
        self
    }
}

impl TransactionData for TopicUpdateTransactionData {}

impl TransactionExecute for TopicUpdateTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { ConsensusServiceClient::new(channel).update_topic(request).await })
    }
}

impl ValidateChecksums for TopicUpdateTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.topic_id.validate_checksums(ledger_id)?;
        self.auto_renew_account_id.validate_checksums(ledger_id)
    }
}

impl ToTransactionDataProtobuf for TopicUpdateTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::ConsensusUpdateTopic(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TopicUpdateTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::ConsensusUpdateTopic(self.to_protobuf())
    }
}

impl From<TopicUpdateTransactionData> for AnyTransactionData {
    fn from(transaction: TopicUpdateTransactionData) -> Self {
        Self::TopicUpdate(transaction)
    }
}

impl FromProtobuf<services::ConsensusUpdateTopicTransactionBody> for TopicUpdateTransactionData {
    fn from_protobuf(pb: services::ConsensusUpdateTopicTransactionBody) -> crate::Result<Self> {
        let custom_fees = if let Some(custom_fees) = pb.custom_fees {
            Some(
                custom_fees
                    .fees
                    .into_iter()
                    .map(CustomFixedFee::from_protobuf)
                    .collect::<Result<Vec<_>, _>>()?,
            )
        } else {
            None
        };

        let fee_exempt_keys = if let Some(fee_exempt_keys) = pb.fee_exempt_key_list {
            fee_exempt_keys
                .keys
                .into_iter()
                .map(|pb_key| Key::from_protobuf(pb_key))
                .collect::<Result<Vec<_>, _>>()?
        } else {
            Vec::new()
        };

        Ok(Self {
            topic_id: Option::from_protobuf(pb.topic_id)?,
            expiration_time: pb.expiration_time.map(Into::into),
            topic_memo: pb.memo,
            admin_key: Option::from_protobuf(pb.admin_key)?,
            submit_key: Option::from_protobuf(pb.submit_key)?,
            auto_renew_period: pb.auto_renew_period.map(Into::into),
            auto_renew_account_id: Option::from_protobuf(pb.auto_renew_account)?,
            fee_schedule_key: Option::from_protobuf(pb.fee_schedule_key)?,
            fee_exempt_keys,
            custom_fees,
        })
    }
}

impl ToProtobuf for TopicUpdateTransactionData {
    type Protobuf = services::ConsensusUpdateTopicTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let topic_id = self.topic_id.to_protobuf();
        let expiration_time = self.expiration_time.map(Into::into);
        let admin_key = self.admin_key.to_protobuf();
        let submit_key = self.submit_key.to_protobuf();
        let fee_schedule_key = self.fee_schedule_key.to_protobuf();

        let auto_renew_period = self.auto_renew_period.map(Into::into);
        let auto_renew_account_id = self.auto_renew_account_id.to_protobuf();
        let custom_fees = self.custom_fees.as_ref().map(|fees| services::FixedCustomFeeList {
            fees: fees.iter().map(|fee| fee.to_protobuf()).collect(),
        });

        let fee_exempt_key_list = if self.fee_exempt_keys.is_empty() {
            None
        } else {
            Some(services::FeeExemptKeyList {
                keys: self.fee_exempt_keys.iter().map(|key| key.to_protobuf()).collect(),
            })
        };

        services::ConsensusUpdateTopicTransactionBody {
            auto_renew_account: auto_renew_account_id,
            memo: self.topic_memo.clone(),
            expiration_time,
            topic_id,
            admin_key,
            submit_key,
            auto_renew_period,
            fee_exempt_key_list,
            fee_schedule_key,
            custom_fees,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use time::{
        Duration,
        OffsetDateTime,
    };

    use crate::custom_fixed_fee::CustomFixedFee;
    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
        unused_private_key,
        VALID_START,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        Key,
        PrivateKey,
        TokenId,
        TopicId,
        TopicUpdateTransaction,
    };

    const TEST_TOPIC_ID: TopicId = TopicId::new(0, 0, 5007);
    const TEST_TOPIC_MEMO: &str = "test memo";
    const TEST_AUTO_RENEW_PERIOD: Duration = Duration::days(1);
    const TEST_AUTO_RENEW_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 5007);
    const TEST_EXPIRATION_TIME: OffsetDateTime = VALID_START;

    fn make_transaction() -> TopicUpdateTransaction {
        let mut tx = TopicUpdateTransaction::new_for_tests();

        tx.topic_id("0.0.5007".parse::<TopicId>().unwrap())
            .clear_admin_key()
            .clear_auto_renew_account_id()
            .clear_submit_key()
            .topic_memo("")
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ConsensusUpdateTopic(
                ConsensusUpdateTopicTransactionBody {
                    topic_id: Some(
                        TopicId {
                            shard_num: 0,
                            realm_num: 0,
                            topic_num: 5007,
                        },
                    ),
                    memo: Some(
                        "",
                    ),
                    expiration_time: None,
                    admin_key: Some(
                        Key {
                            key: Some(
                                KeyList(
                                    KeyList {
                                        keys: [],
                                    },
                                ),
                            ),
                        },
                    ),
                    submit_key: Some(
                        Key {
                            key: Some(
                                KeyList(
                                    KeyList {
                                        keys: [],
                                    },
                                ),
                            ),
                        },
                    ),
                    auto_renew_period: None,
                    auto_renew_account: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    0,
                                ),
                            ),
                        },
                    ),
                    fee_schedule_key: None,
                    fee_exempt_key_list: None,
                    custom_fees: None,
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    fn make_transaction2() -> TopicUpdateTransaction {
        let mut tx = TopicUpdateTransaction::new_for_tests();

        tx.topic_id("0.0.5007".parse::<TopicId>().unwrap())
            .admin_key(unused_private_key().public_key())
            .auto_renew_account_id("0.0.5009".parse().unwrap())
            .auto_renew_period(Duration::days(1))
            .submit_key(unused_private_key().public_key())
            .topic_memo("Hello memo")
            .expiration_time(VALID_START)
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize2() {
        let tx = make_transaction2();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            ConsensusUpdateTopic(
                ConsensusUpdateTopicTransactionBody {
                    topic_id: Some(
                        TopicId {
                            shard_num: 0,
                            realm_num: 0,
                            topic_num: 5007,
                        },
                    ),
                    memo: Some(
                        "Hello memo",
                    ),
                    expiration_time: Some(
                        Timestamp {
                            seconds: 1554158542,
                            nanos: 0,
                        },
                    ),
                    admin_key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    submit_key: Some(
                        Key {
                            key: Some(
                                Ed25519(
                                    [
                                        224,
                                        200,
                                        236,
                                        39,
                                        88,
                                        165,
                                        135,
                                        159,
                                        250,
                                        194,
                                        38,
                                        161,
                                        60,
                                        12,
                                        81,
                                        107,
                                        121,
                                        158,
                                        114,
                                        227,
                                        81,
                                        65,
                                        160,
                                        221,
                                        130,
                                        143,
                                        148,
                                        211,
                                        121,
                                        136,
                                        164,
                                        183,
                                    ],
                                ),
                            ),
                        },
                    ),
                    auto_renew_period: Some(
                        Duration {
                            seconds: 86400,
                        },
                    ),
                    auto_renew_account: Some(
                        AccountId {
                            shard_num: 0,
                            realm_num: 0,
                            account: Some(
                                AccountNum(
                                    5009,
                                ),
                            ),
                        },
                    ),
                    fee_schedule_key: None,
                    fee_exempt_key_list: None,
                    custom_fees: None,
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes2() {
        let tx = make_transaction2();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn get_set_topic_id() {
        let mut tx = TopicUpdateTransaction::new();
        tx.topic_id(TEST_TOPIC_ID);

        assert_eq!(tx.get_topic_id(), Some(TEST_TOPIC_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_topic_id_frozen_panics() {
        make_transaction().topic_id(TEST_TOPIC_ID);
    }

    #[test]
    fn get_set_topic_memo() {
        let mut tx = TopicUpdateTransaction::new();
        tx.topic_memo(TEST_TOPIC_MEMO);

        assert_eq!(tx.get_topic_memo(), Some(TEST_TOPIC_MEMO));
    }

    #[test]
    #[should_panic]
    fn get_set_topic_memo_frozen_panics() {
        make_transaction().topic_memo(TEST_TOPIC_MEMO);
    }

    #[test]
    fn get_set_expiration_time() {
        let mut tx = TopicUpdateTransaction::new();
        tx.expiration_time(TEST_EXPIRATION_TIME);

        assert_eq!(tx.get_expiration_time(), Some(TEST_EXPIRATION_TIME));
    }

    #[test]
    #[should_panic]
    fn get_set_expiration_time_frozen_panics() {
        make_transaction().expiration_time(TEST_EXPIRATION_TIME);
    }

    #[test]
    fn get_set_admin_key() {
        let mut tx = TopicUpdateTransaction::new();
        tx.admin_key(unused_private_key().public_key());

        assert_eq!(tx.get_admin_key(), Some(&unused_private_key().public_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_admin_key_frozen_panics() {
        make_transaction().admin_key(unused_private_key().public_key());
    }

    #[test]
    fn clear_admin_key() {
        let mut tx = TopicUpdateTransaction::new();
        tx.admin_key(unused_private_key().public_key());
        tx.clear_admin_key();

        assert_eq!(tx.get_admin_key(), Some(&Key::KeyList(crate::KeyList::new())));
    }

    #[test]
    #[should_panic]
    fn clear_admin_key_frozen_panics() {
        make_transaction().clear_admin_key();
    }

    #[test]
    fn get_set_submit_key() {
        let mut tx = TopicUpdateTransaction::new();
        tx.submit_key(unused_private_key().public_key());

        assert_eq!(tx.get_submit_key(), Some(&unused_private_key().public_key().into()));
    }

    #[test]
    #[should_panic]
    fn get_set_submit_key_frozen_panics() {
        make_transaction().submit_key(unused_private_key().public_key());
    }

    #[test]
    fn clear_submit_key() {
        let mut tx = TopicUpdateTransaction::new();
        tx.submit_key(unused_private_key().public_key());
        tx.clear_submit_key();

        assert_eq!(tx.get_submit_key(), Some(&Key::KeyList(crate::KeyList::new())));
    }

    #[test]
    #[should_panic]
    fn clear_submit_key_frozen_panics() {
        make_transaction().clear_submit_key();
    }

    #[test]
    fn get_set_auto_renew_period() {
        let mut tx = TopicUpdateTransaction::new();
        tx.auto_renew_period(TEST_AUTO_RENEW_PERIOD);

        assert_eq!(tx.get_auto_renew_period(), Some(TEST_AUTO_RENEW_PERIOD));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_period_frozen_panics() {
        make_transaction().auto_renew_period(TEST_AUTO_RENEW_PERIOD);
    }

    #[test]
    fn get_set_auto_renew_account_id() {
        let mut tx = TopicUpdateTransaction::new();
        tx.auto_renew_account_id(TEST_AUTO_RENEW_ACCOUNT_ID);

        assert_eq!(tx.get_auto_renew_account_id(), Some(TEST_AUTO_RENEW_ACCOUNT_ID));
    }

    #[test]
    #[should_panic]
    fn get_set_auto_renew_account_id_frozen_panics() {
        make_transaction().auto_renew_account_id(TEST_AUTO_RENEW_ACCOUNT_ID);
    }

    #[test]
    fn clear_auto_renew_account_id() {
        let mut tx = TopicUpdateTransaction::new();
        tx.auto_renew_account_id(TEST_AUTO_RENEW_ACCOUNT_ID);
        tx.clear_auto_renew_account_id();

        assert_eq!(tx.get_auto_renew_account_id(), Some(AccountId::new(0, 0, 0)));
    }

    #[test]
    #[should_panic]
    fn clear_auto_renew_account_id_frozen_panics() {
        make_transaction().clear_auto_renew_account_id();
    }

    #[test]
    fn get_set_fee_schedule_key() {
        let fee_schedule_key = PrivateKey::generate_ecdsa();
        let mut tx = TopicUpdateTransaction::new();
        tx.fee_schedule_key(fee_schedule_key.public_key());

        assert_eq!(tx.get_fee_schedule_key(), Some(&fee_schedule_key.public_key().into()));
    }

    #[test]
    fn get_set_fee_exempt_keys() {
        let fee_exempt_keys = vec![PrivateKey::generate_ecdsa(), PrivateKey::generate_ecdsa()];
        let mut tx = TopicUpdateTransaction::new();
        tx.fee_exempt_keys(fee_exempt_keys.iter().map(|key| key.public_key().into()).collect());

        let expected_keys =
            fee_exempt_keys.iter().map(|key| key.public_key().into()).collect::<Vec<_>>();

        assert_eq!(tx.get_fee_exempt_keys(), &expected_keys);
    }

    #[test]
    fn add_fee_exempt_key_to_empty_list() {
        let mut tx = TopicUpdateTransaction::new();
        let fee_exempt_key = PrivateKey::generate_ecdsa();
        tx.add_fee_exempt_key(fee_exempt_key.public_key().into());

        assert_eq!(tx.get_fee_exempt_keys(), &vec![fee_exempt_key.public_key().into()]);
    }

    #[test]
    fn add_fee_exempt_key_to_list() {
        let fee_exempt_key = PrivateKey::generate_ecdsa();
        let mut tx = TopicUpdateTransaction::new();
        tx.fee_exempt_keys(vec![fee_exempt_key.public_key().into()]);

        let fee_exempt_key_to_add = PrivateKey::generate_ecdsa();
        tx.add_fee_exempt_key(fee_exempt_key_to_add.public_key().into());

        let expected_keys =
            vec![fee_exempt_key.public_key().into(), fee_exempt_key_to_add.public_key().into()];

        assert_eq!(tx.get_fee_exempt_keys(), &expected_keys);
    }

    #[test]
    fn clear_fee_exempt_keys() {
        let fee_exempt_key = PrivateKey::generate_ecdsa();
        let mut tx = TopicUpdateTransaction::new();
        tx.fee_exempt_keys(vec![fee_exempt_key.public_key().into()]);
        tx.clear_fee_exempt_keys();

        assert_eq!(tx.get_fee_exempt_keys(), &vec![]);
    }

    #[test]
    fn get_set_custom_fees() {
        let custom_fees = vec![
            CustomFixedFee::new(1, Some(TokenId::new(0, 0, 0)), None),
            CustomFixedFee::new(2, Some(TokenId::new(0, 0, 1)), None),
            CustomFixedFee::new(3, Some(TokenId::new(0, 0, 2)), None),
        ];

        let mut tx = TopicUpdateTransaction::new();
        tx.custom_fees(custom_fees.clone());

        assert_eq!(tx.get_custom_fees(), Some(&custom_fees));
    }

    #[test]
    fn add_custom_fee_to_list() {
        let custom_fees = vec![
            CustomFixedFee::new(1, Some(TokenId::new(0, 0, 0)), None),
            CustomFixedFee::new(2, Some(TokenId::new(0, 0, 1)), None),
            CustomFixedFee::new(3, Some(TokenId::new(0, 0, 2)), None),
        ];

        let custom_fee_to_add = CustomFixedFee::new(4, Some(TokenId::new(0, 0, 3)), None);

        let mut tx = TopicUpdateTransaction::new();
        tx.custom_fees(custom_fees);
        tx.add_custom_fee(custom_fee_to_add.clone());

        assert_eq!(tx.get_custom_fees(), Some(&vec![custom_fee_to_add]));
    }

    #[test]
    fn add_custom_fee_to_empty_list() {
        let custom_fee_to_add = CustomFixedFee::new(4, Some(TokenId::new(0, 0, 3)), None);

        let mut tx = TopicUpdateTransaction::new();
        tx.add_custom_fee(custom_fee_to_add.clone());

        assert_eq!(tx.get_custom_fees(), Some(&vec![custom_fee_to_add]));
    }

    #[test]
    fn clear_custom_fees() {
        let custom_fees = vec![
            CustomFixedFee::new(1, Some(TokenId::new(0, 0, 0)), None),
            CustomFixedFee::new(2, Some(TokenId::new(0, 0, 1)), None),
            CustomFixedFee::new(3, Some(TokenId::new(0, 0, 2)), None),
        ];

        let mut tx = TopicUpdateTransaction::new();
        tx.custom_fees(custom_fees);
        tx.clear_custom_fees();

        assert_eq!(tx.get_custom_fees(), None);
    }
}
// Filename: src/transaction/any.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use tonic::transport::Channel;

use super::chunked::ChunkInfo;
use super::{
    TransactionData,
    TransactionExecuteChunked,
};
use crate::custom_fee_limit::CustomFeeLimit;
use crate::downcast::DowncastOwned;
use crate::entity_id::ValidateChecksums;
use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::transaction::{
    ToTransactionDataProtobuf,
    TransactionBody,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Error,
    Hbar,
    Transaction,
    TransactionId,
};

mod data {
    pub(super) use crate::account::{
        AccountAllowanceApproveTransactionData as AccountAllowanceApprove,
        AccountAllowanceDeleteTransactionData as AccountAllowanceDelete,
        AccountCreateTransactionData as AccountCreate,
        AccountDeleteTransactionData as AccountDelete,
        AccountUpdateTransactionData as AccountUpdate,
    };
    pub(super) use crate::address_book::{
        NodeCreateTransactionData as NodeCreate,
        NodeDeleteTransactionData as NodeDelete,
        NodeUpdateTransactionData as NodeUpdate,
    };
    pub(super) use crate::contract::{
        ContractCreateTransactionData as ContractCreate,
        ContractDeleteTransactionData as ContractDelete,
        ContractExecuteTransactionData as ContractExecute,
        ContractUpdateTransactionData as ContractUpdate,
    };
    pub(super) use crate::ethereum::EthereumTransactionData as Ethereum;
    pub(super) use crate::file::{
        FileAppendTransactionData as FileAppend,
        FileCreateTransactionData as FileCreate,
        FileDeleteTransactionData as FileDelete,
        FileUpdateTransactionData as FileUpdate,
    };
    pub(super) use crate::prng_transaction::PrngTransactionData as Prng;
    pub(super) use crate::schedule::{
        ScheduleCreateTransactionData as ScheduleCreate,
        ScheduleDeleteTransactionData as ScheduleDelete,
        ScheduleSignTransactionData as ScheduleSign,
    };
    pub(super) use crate::system::{
        FreezeTransactionData as Freeze,
        SystemDeleteTransactionData as SystemDelete,
        SystemUndeleteTransactionData as SystemUndelete,
    };
    pub(super) use crate::token::{
        TokenAirdropTransactionData as TokenAirdrop,
        TokenAssociateTransactionData as TokenAssociate,
        TokenBurnTransactionData as TokenBurn,
        TokenCancelAirdropTransactionData as TokenCancelAirdrop,
        TokenClaimAirdropTransactionData as TokenClaimAirdrop,
        TokenCreateTransactionData as TokenCreate,
        TokenDeleteTransactionData as TokenDelete,
        TokenDissociateTransactionData as TokenDissociate,
        TokenFeeScheduleUpdateTransactionData as TokenFeeScheduleUpdate,
        TokenFreezeTransactionData as TokenFreeze,
        TokenGrantKycTransactionData as TokenGrantKyc,
        TokenMintTransactionData as TokenMint,
        TokenPauseTransactionData as TokenPause,
        TokenRejectTransactionData as TokenReject,
        TokenRevokeKycTransactionData as TokenRevokeKyc,
        TokenUnfreezeTransactionData as TokenUnfreeze,
        TokenUnpauseTransactionData as TokenUnpause,
        TokenUpdateNftsTransactionData as TokenUpdateNfts,
        TokenUpdateTransactionData as TokenUpdate,
        TokenWipeTransactionData as TokenWipe,
    };
    pub(super) use crate::topic::{
        TopicCreateTransactionData as TopicCreate,
        TopicDeleteTransactionData as TopicDelete,
        TopicMessageSubmitTransactionData as TopicMessageSubmit,
        TopicUpdateTransactionData as TopicUpdate,
    };
    pub(super) use crate::transfer_transaction::TransferTransactionData as Transfer;
}

/// Any possible transaction that may be executed on the Hiero network.
pub type AnyTransaction = Transaction<AnyTransactionData>;

#[derive(Debug, Clone)]
#[non_exhaustive]
pub enum AnyTransactionData {
    AccountCreate(data::AccountCreate),
    AccountUpdate(data::AccountUpdate),
    AccountDelete(data::AccountDelete),
    AccountAllowanceApprove(data::AccountAllowanceApprove),
    AccountAllowanceDelete(data::AccountAllowanceDelete),
    ContractCreate(data::ContractCreate),
    ContractUpdate(data::ContractUpdate),
    ContractDelete(data::ContractDelete),
    ContractExecute(data::ContractExecute),
    Transfer(data::Transfer),
    TopicCreate(data::TopicCreate),
    TopicUpdate(data::TopicUpdate),
    TopicDelete(data::TopicDelete),
    TopicMessageSubmit(data::TopicMessageSubmit),
    FileAppend(data::FileAppend),
    FileCreate(data::FileCreate),
    FileUpdate(data::FileUpdate),
    FileDelete(data::FileDelete),
    Prng(data::Prng),
    ScheduleCreate(data::ScheduleCreate),
    ScheduleSign(data::ScheduleSign),
    ScheduleDelete(data::ScheduleDelete),
    TokenAssociate(data::TokenAssociate),
    TokenBurn(data::TokenBurn),
    TokenCreate(data::TokenCreate),
    TokenDelete(data::TokenDelete),
    TokenDissociate(data::TokenDissociate),
    TokenFeeScheduleUpdate(data::TokenFeeScheduleUpdate),
    TokenFreeze(data::TokenFreeze),
    TokenGrantKyc(data::TokenGrantKyc),
    TokenMint(data::TokenMint),
    TokenPause(data::TokenPause),
    TokenRevokeKyc(data::TokenRevokeKyc),
    TokenUnfreeze(data::TokenUnfreeze),
    TokenUnpause(data::TokenUnpause),
    TokenUpdate(data::TokenUpdate),
    TokenWipe(data::TokenWipe),
    SystemDelete(data::SystemDelete),
    SystemUndelete(data::SystemUndelete),
    Freeze(data::Freeze),
    Ethereum(data::Ethereum),
    TokenUpdateNfts(data::TokenUpdateNfts),
    NodeCreate(data::NodeCreate),
    NodeUpdate(data::NodeUpdate),
    NodeDelete(data::NodeDelete),
    TokenReject(data::TokenReject),
    TokenAirdrop(data::TokenAirdrop),
    TokenClaimAirdrop(data::TokenClaimAirdrop),
    TokenCancelAirdrop(data::TokenCancelAirdrop),
}

impl ToTransactionDataProtobuf for AnyTransactionData {
    // not really anything I can do about this
    #[allow(clippy::too_many_lines)]
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        match self {
            Self::Transfer(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::AccountCreate(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::AccountUpdate(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::AccountDelete(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::AccountAllowanceApprove(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::AccountAllowanceDelete(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::ContractCreate(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::ContractUpdate(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::ContractDelete(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::ContractExecute(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::FileAppend(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::FileCreate(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::FileUpdate(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::FileDelete(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::Prng(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenAssociate(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::TokenBurn(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenCreate(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenDelete(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenDissociate(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::TokenFeeScheduleUpdate(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::TokenFreeze(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenGrantKyc(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::TokenMint(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenPause(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenRevokeKyc(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::TokenUnfreeze(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::TokenUnpause(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenUpdate(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenWipe(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TopicCreate(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TopicUpdate(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TopicDelete(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenReject(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TopicMessageSubmit(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::SystemDelete(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::SystemUndelete(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::Freeze(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::ScheduleCreate(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::ScheduleSign(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::ScheduleDelete(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::Ethereum(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenUpdateNfts(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }

            Self::NodeCreate(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::NodeUpdate(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::NodeDelete(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenAirdrop(transaction) => transaction.to_transaction_data_protobuf(chunk_info),

            Self::TokenClaimAirdrop(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }
            Self::TokenCancelAirdrop(transaction) => {
                transaction.to_transaction_data_protobuf(chunk_info)
            }
        }
    }
}

impl TransactionData for AnyTransactionData {
    fn default_max_transaction_fee(&self) -> Hbar {
        match self {
            Self::Transfer(transaction) => transaction.default_max_transaction_fee(),
            Self::AccountCreate(transaction) => transaction.default_max_transaction_fee(),
            Self::AccountUpdate(transaction) => transaction.default_max_transaction_fee(),
            Self::AccountDelete(transaction) => transaction.default_max_transaction_fee(),
            Self::AccountAllowanceApprove(transaction) => transaction.default_max_transaction_fee(),
            Self::AccountAllowanceDelete(transaction) => transaction.default_max_transaction_fee(),
            Self::ContractCreate(transaction) => transaction.default_max_transaction_fee(),
            Self::ContractUpdate(transaction) => transaction.default_max_transaction_fee(),
            Self::ContractDelete(transaction) => transaction.default_max_transaction_fee(),
            Self::ContractExecute(transaction) => transaction.default_max_transaction_fee(),
            Self::FileAppend(transaction) => transaction.default_max_transaction_fee(),
            Self::FileCreate(transaction) => transaction.default_max_transaction_fee(),
            Self::FileUpdate(transaction) => transaction.default_max_transaction_fee(),
            Self::FileDelete(transaction) => transaction.default_max_transaction_fee(),
            Self::Prng(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenAssociate(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenBurn(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenCreate(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenDelete(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenDissociate(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenFeeScheduleUpdate(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenFreeze(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenGrantKyc(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenMint(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenPause(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenRevokeKyc(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenUnfreeze(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenUnpause(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenUpdate(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenWipe(transaction) => transaction.default_max_transaction_fee(),
            Self::TopicCreate(transaction) => transaction.default_max_transaction_fee(),
            Self::TopicUpdate(transaction) => transaction.default_max_transaction_fee(),
            Self::TopicDelete(transaction) => transaction.default_max_transaction_fee(),
            Self::TopicMessageSubmit(transaction) => transaction.default_max_transaction_fee(),
            Self::SystemDelete(transaction) => transaction.default_max_transaction_fee(),
            Self::SystemUndelete(transaction) => transaction.default_max_transaction_fee(),
            Self::Freeze(transaction) => transaction.default_max_transaction_fee(),
            Self::ScheduleCreate(transaction) => transaction.default_max_transaction_fee(),
            Self::ScheduleSign(transaction) => transaction.default_max_transaction_fee(),
            Self::ScheduleDelete(transaction) => transaction.default_max_transaction_fee(),
            Self::Ethereum(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenUpdateNfts(transaction) => transaction.default_max_transaction_fee(),
            Self::NodeCreate(transaction) => transaction.default_max_transaction_fee(),
            Self::NodeUpdate(transaction) => transaction.default_max_transaction_fee(),
            Self::NodeDelete(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenReject(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenAirdrop(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenClaimAirdrop(transaction) => transaction.default_max_transaction_fee(),
            Self::TokenCancelAirdrop(transaction) => transaction.default_max_transaction_fee(),
        }
    }

    fn maybe_chunk_data(&self) -> Option<&super::ChunkData> {
        match self {
            Self::AccountCreate(it) => it.maybe_chunk_data(),
            Self::AccountUpdate(it) => it.maybe_chunk_data(),
            Self::AccountDelete(it) => it.maybe_chunk_data(),
            Self::AccountAllowanceApprove(it) => it.maybe_chunk_data(),
            Self::AccountAllowanceDelete(it) => it.maybe_chunk_data(),
            Self::ContractCreate(it) => it.maybe_chunk_data(),
            Self::ContractUpdate(it) => it.maybe_chunk_data(),
            Self::ContractDelete(it) => it.maybe_chunk_data(),
            Self::ContractExecute(it) => it.maybe_chunk_data(),
            Self::Transfer(it) => it.maybe_chunk_data(),
            Self::TopicCreate(it) => it.maybe_chunk_data(),
            Self::TopicUpdate(it) => it.maybe_chunk_data(),
            Self::TopicDelete(it) => it.maybe_chunk_data(),
            Self::TopicMessageSubmit(it) => it.maybe_chunk_data(),
            Self::FileAppend(it) => it.maybe_chunk_data(),
            Self::FileCreate(it) => it.maybe_chunk_data(),
            Self::FileUpdate(it) => it.maybe_chunk_data(),
            Self::FileDelete(it) => it.maybe_chunk_data(),
            Self::Prng(it) => it.maybe_chunk_data(),
            Self::TokenAssociate(it) => it.maybe_chunk_data(),
            Self::TokenBurn(it) => it.maybe_chunk_data(),
            Self::TokenCreate(it) => it.maybe_chunk_data(),
            Self::TokenDelete(it) => it.maybe_chunk_data(),
            Self::TokenDissociate(it) => it.maybe_chunk_data(),
            Self::TokenFeeScheduleUpdate(it) => it.maybe_chunk_data(),
            Self::TokenFreeze(it) => it.maybe_chunk_data(),
            Self::TokenGrantKyc(it) => it.maybe_chunk_data(),
            Self::TokenMint(it) => it.maybe_chunk_data(),
            Self::TokenPause(it) => it.maybe_chunk_data(),
            Self::TokenRevokeKyc(it) => it.maybe_chunk_data(),
            Self::TokenUnfreeze(it) => it.maybe_chunk_data(),
            Self::TokenUnpause(it) => it.maybe_chunk_data(),
            Self::TokenUpdate(it) => it.maybe_chunk_data(),
            Self::TokenWipe(it) => it.maybe_chunk_data(),
            Self::SystemDelete(it) => it.maybe_chunk_data(),
            Self::SystemUndelete(it) => it.maybe_chunk_data(),
            Self::Freeze(it) => it.maybe_chunk_data(),
            Self::ScheduleCreate(it) => it.maybe_chunk_data(),
            Self::ScheduleSign(it) => it.maybe_chunk_data(),
            Self::ScheduleDelete(it) => it.maybe_chunk_data(),
            Self::Ethereum(it) => it.maybe_chunk_data(),
            Self::TokenUpdateNfts(it) => it.maybe_chunk_data(),
            Self::NodeCreate(it) => it.maybe_chunk_data(),
            Self::NodeUpdate(it) => it.maybe_chunk_data(),
            Self::NodeDelete(it) => it.maybe_chunk_data(),
            Self::TokenReject(it) => it.maybe_chunk_data(),
            Self::TokenAirdrop(it) => it.maybe_chunk_data(),
            Self::TokenClaimAirdrop(it) => it.maybe_chunk_data(),
            Self::TokenCancelAirdrop(it) => it.maybe_chunk_data(),
        }
    }

    fn wait_for_receipt(&self) -> bool {
        match self {
            Self::AccountCreate(it) => it.wait_for_receipt(),
            Self::AccountUpdate(it) => it.wait_for_receipt(),
            Self::AccountDelete(it) => it.wait_for_receipt(),
            Self::AccountAllowanceApprove(it) => it.wait_for_receipt(),
            Self::AccountAllowanceDelete(it) => it.wait_for_receipt(),
            Self::ContractCreate(it) => it.wait_for_receipt(),
            Self::ContractUpdate(it) => it.wait_for_receipt(),
            Self::ContractDelete(it) => it.wait_for_receipt(),
            Self::ContractExecute(it) => it.wait_for_receipt(),
            Self::Transfer(it) => it.wait_for_receipt(),
            Self::TopicCreate(it) => it.wait_for_receipt(),
            Self::TopicUpdate(it) => it.wait_for_receipt(),
            Self::TopicDelete(it) => it.wait_for_receipt(),
            Self::TopicMessageSubmit(it) => it.wait_for_receipt(),
            Self::FileAppend(it) => it.wait_for_receipt(),
            Self::FileCreate(it) => it.wait_for_receipt(),
            Self::FileUpdate(it) => it.wait_for_receipt(),
            Self::FileDelete(it) => it.wait_for_receipt(),
            Self::Prng(it) => it.wait_for_receipt(),
            Self::TokenAssociate(it) => it.wait_for_receipt(),
            Self::TokenBurn(it) => it.wait_for_receipt(),
            Self::TokenCreate(it) => it.wait_for_receipt(),
            Self::TokenDelete(it) => it.wait_for_receipt(),
            Self::TokenDissociate(it) => it.wait_for_receipt(),
            Self::TokenFeeScheduleUpdate(it) => it.wait_for_receipt(),
            Self::TokenFreeze(it) => it.wait_for_receipt(),
            Self::TokenGrantKyc(it) => it.wait_for_receipt(),
            Self::TokenMint(it) => it.wait_for_receipt(),
            Self::TokenPause(it) => it.wait_for_receipt(),
            Self::TokenRevokeKyc(it) => it.wait_for_receipt(),
            Self::TokenUnfreeze(it) => it.wait_for_receipt(),
            Self::TokenUnpause(it) => it.wait_for_receipt(),
            Self::TokenUpdate(it) => it.wait_for_receipt(),
            Self::TokenWipe(it) => it.wait_for_receipt(),
            Self::SystemDelete(it) => it.wait_for_receipt(),
            Self::SystemUndelete(it) => it.wait_for_receipt(),
            Self::Freeze(it) => it.wait_for_receipt(),
            Self::ScheduleCreate(it) => it.wait_for_receipt(),
            Self::ScheduleSign(it) => it.wait_for_receipt(),
            Self::ScheduleDelete(it) => it.wait_for_receipt(),
            Self::Ethereum(it) => it.wait_for_receipt(),
            Self::TokenUpdateNfts(it) => it.wait_for_receipt(),
            Self::NodeCreate(it) => it.wait_for_receipt(),
            Self::NodeUpdate(it) => it.wait_for_receipt(),
            Self::NodeDelete(it) => it.wait_for_receipt(),
            Self::TokenReject(it) => it.wait_for_receipt(),
            Self::TokenAirdrop(it) => it.wait_for_receipt(),
            Self::TokenClaimAirdrop(it) => it.wait_for_receipt(),
            Self::TokenCancelAirdrop(it) => it.wait_for_receipt(),
        }
    }
}

impl TransactionExecute for AnyTransactionData {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        match self {
            Self::Transfer(transaction) => transaction.execute(channel, request),
            Self::AccountCreate(transaction) => transaction.execute(channel, request),
            Self::AccountUpdate(transaction) => transaction.execute(channel, request),
            Self::AccountDelete(transaction) => transaction.execute(channel, request),
            Self::AccountAllowanceApprove(transaction) => transaction.execute(channel, request),
            Self::AccountAllowanceDelete(transaction) => transaction.execute(channel, request),
            Self::ContractCreate(transaction) => transaction.execute(channel, request),
            Self::ContractUpdate(transaction) => transaction.execute(channel, request),
            Self::ContractDelete(transaction) => transaction.execute(channel, request),
            Self::ContractExecute(transaction) => transaction.execute(channel, request),
            Self::FileAppend(transaction) => transaction.execute(channel, request),
            Self::FileCreate(transaction) => transaction.execute(channel, request),
            Self::FileUpdate(transaction) => transaction.execute(channel, request),
            Self::FileDelete(transaction) => transaction.execute(channel, request),
            Self::Prng(transaction) => transaction.execute(channel, request),
            Self::TokenAssociate(transaction) => transaction.execute(channel, request),
            Self::TokenBurn(transaction) => transaction.execute(channel, request),
            Self::TokenCreate(transaction) => transaction.execute(channel, request),
            Self::TokenDelete(transaction) => transaction.execute(channel, request),
            Self::TokenDissociate(transaction) => transaction.execute(channel, request),
            Self::TokenFeeScheduleUpdate(transaction) => transaction.execute(channel, request),
            Self::TokenFreeze(transaction) => transaction.execute(channel, request),
            Self::TokenGrantKyc(transaction) => transaction.execute(channel, request),
            Self::TokenMint(transaction) => transaction.execute(channel, request),
            Self::TokenPause(transaction) => transaction.execute(channel, request),
            Self::TokenRevokeKyc(transaction) => transaction.execute(channel, request),
            Self::TokenUnfreeze(transaction) => transaction.execute(channel, request),
            Self::TokenUnpause(transaction) => transaction.execute(channel, request),
            Self::TokenUpdate(transaction) => transaction.execute(channel, request),
            Self::TokenWipe(transaction) => transaction.execute(channel, request),
            Self::TopicCreate(transaction) => transaction.execute(channel, request),
            Self::TopicUpdate(transaction) => transaction.execute(channel, request),
            Self::TopicDelete(transaction) => transaction.execute(channel, request),
            Self::TopicMessageSubmit(transaction) => transaction.execute(channel, request),
            Self::SystemDelete(transaction) => transaction.execute(channel, request),
            Self::SystemUndelete(transaction) => transaction.execute(channel, request),
            Self::Freeze(transaction) => transaction.execute(channel, request),
            Self::ScheduleCreate(transaction) => transaction.execute(channel, request),
            Self::ScheduleSign(transaction) => transaction.execute(channel, request),
            Self::ScheduleDelete(transaction) => transaction.execute(channel, request),
            Self::Ethereum(transaction) => transaction.execute(channel, request),
            Self::TokenUpdateNfts(transaction) => transaction.execute(channel, request),
            Self::NodeCreate(transaction) => transaction.execute(channel, request),
            Self::NodeUpdate(transaction) => transaction.execute(channel, request),
            Self::NodeDelete(transaction) => transaction.execute(channel, request),
            Self::TokenReject(transaction) => transaction.execute(channel, request),
            Self::TokenAirdrop(transaction) => transaction.execute(channel, request),
            Self::TokenClaimAirdrop(transaction) => transaction.execute(channel, request),
            Self::TokenCancelAirdrop(transaction) => transaction.execute(channel, request),
        }
    }
}

impl TransactionExecuteChunked for AnyTransactionData {}

impl ValidateChecksums for AnyTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        match self {
            Self::AccountCreate(transaction) => transaction.validate_checksums(ledger_id),
            Self::AccountUpdate(transaction) => transaction.validate_checksums(ledger_id),
            Self::AccountDelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::AccountAllowanceApprove(transaction) => transaction.validate_checksums(ledger_id),
            Self::AccountAllowanceDelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::ContractCreate(transaction) => transaction.validate_checksums(ledger_id),
            Self::ContractUpdate(transaction) => transaction.validate_checksums(ledger_id),
            Self::ContractDelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::ContractExecute(transaction) => transaction.validate_checksums(ledger_id),
            Self::Transfer(transaction) => transaction.validate_checksums(ledger_id),
            Self::TopicCreate(transaction) => transaction.validate_checksums(ledger_id),
            Self::TopicUpdate(transaction) => transaction.validate_checksums(ledger_id),
            Self::TopicDelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::TopicMessageSubmit(transaction) => transaction.validate_checksums(ledger_id),
            Self::FileAppend(transaction) => transaction.validate_checksums(ledger_id),
            Self::FileCreate(transaction) => transaction.validate_checksums(ledger_id),
            Self::FileUpdate(transaction) => transaction.validate_checksums(ledger_id),
            Self::FileDelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::Prng(transaction) => transaction.validate_checksums(ledger_id),
            Self::ScheduleCreate(transaction) => transaction.validate_checksums(ledger_id),
            Self::ScheduleSign(transaction) => transaction.validate_checksums(ledger_id),
            Self::ScheduleDelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenAssociate(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenBurn(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenCreate(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenDelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenDissociate(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenFeeScheduleUpdate(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenFreeze(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenGrantKyc(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenMint(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenPause(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenRevokeKyc(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenUnfreeze(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenUnpause(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenUpdate(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenWipe(transaction) => transaction.validate_checksums(ledger_id),
            Self::SystemDelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::SystemUndelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::Freeze(transaction) => transaction.validate_checksums(ledger_id),
            Self::Ethereum(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenUpdateNfts(transaction) => transaction.validate_checksums(ledger_id),
            Self::NodeCreate(transaction) => transaction.validate_checksums(ledger_id),
            Self::NodeUpdate(transaction) => transaction.validate_checksums(ledger_id),
            Self::NodeDelete(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenReject(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenAirdrop(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenClaimAirdrop(transaction) => transaction.validate_checksums(ledger_id),
            Self::TokenCancelAirdrop(transaction) => transaction.validate_checksums(ledger_id),
        }
    }
}

impl FromProtobuf<services::transaction_body::Data> for AnyTransactionData {
    fn from_protobuf(pb: services::transaction_body::Data) -> crate::Result<Self>
    where
        Self: Sized,
    {
        use services::transaction_body::Data;
        let data = match pb {
            Data::ContractCall(pb) => data::ContractExecute::from_protobuf(pb)?.into(),
            Data::ContractCreateInstance(pb) => data::ContractCreate::from_protobuf(pb)?.into(),
            Data::ContractUpdateInstance(pb) => data::ContractUpdate::from_protobuf(pb)?.into(),
            Data::ContractDeleteInstance(pb) => data::ContractDelete::from_protobuf(pb)?.into(),
            Data::EthereumTransaction(pb) => data::Ethereum::from_protobuf(pb)?.into(),
            Data::CryptoApproveAllowance(pb) => {
                data::AccountAllowanceApprove::from_protobuf(pb)?.into()
            }
            Data::CryptoDeleteAllowance(pb) => {
                data::AccountAllowanceDelete::from_protobuf(pb)?.into()
            }
            Data::CryptoCreateAccount(pb) => data::AccountCreate::from_protobuf(pb)?.into(),
            Data::CryptoDelete(pb) => data::AccountDelete::from_protobuf(pb)?.into(),
            Data::CryptoTransfer(pb) => data::Transfer::from_protobuf(pb)?.into(),
            Data::CryptoUpdateAccount(pb) => data::AccountUpdate::from_protobuf(pb)?.into(),
            Data::FileAppend(pb) => data::FileAppend::from_protobuf(pb)?.into(),
            Data::FileCreate(pb) => data::FileCreate::from_protobuf(pb)?.into(),
            Data::FileDelete(pb) => data::FileDelete::from_protobuf(pb)?.into(),
            Data::FileUpdate(pb) => data::FileUpdate::from_protobuf(pb)?.into(),
            Data::UtilPrng(pb) => data::Prng::from_protobuf(pb)?.into(),
            Data::SystemDelete(pb) => data::SystemDelete::from_protobuf(pb)?.into(),
            Data::SystemUndelete(pb) => data::SystemUndelete::from_protobuf(pb)?.into(),
            Data::Freeze(pb) => data::Freeze::from_protobuf(pb)?.into(),
            Data::ConsensusCreateTopic(pb) => data::TopicCreate::from_protobuf(pb)?.into(),
            Data::ConsensusUpdateTopic(pb) => data::TopicUpdate::from_protobuf(pb)?.into(),
            Data::ConsensusDeleteTopic(pb) => data::TopicDelete::from_protobuf(pb)?.into(),
            Data::ConsensusSubmitMessage(pb) => data::TopicMessageSubmit::from_protobuf(pb)?.into(),
            Data::TokenCreation(pb) => data::TokenCreate::from_protobuf(pb)?.into(),
            Data::TokenFreeze(pb) => data::TokenFreeze::from_protobuf(pb)?.into(),
            Data::TokenUnfreeze(pb) => data::TokenUnfreeze::from_protobuf(pb)?.into(),
            Data::TokenGrantKyc(pb) => data::TokenGrantKyc::from_protobuf(pb)?.into(),
            Data::TokenRevokeKyc(pb) => data::TokenRevokeKyc::from_protobuf(pb)?.into(),
            Data::TokenDeletion(pb) => data::TokenDelete::from_protobuf(pb)?.into(),
            Data::TokenUpdate(pb) => data::TokenUpdate::from_protobuf(pb)?.into(),
            Data::TokenMint(pb) => data::TokenMint::from_protobuf(pb)?.into(),
            Data::TokenBurn(pb) => data::TokenBurn::from_protobuf(pb)?.into(),
            Data::TokenWipe(pb) => data::TokenWipe::from_protobuf(pb)?.into(),
            Data::TokenAssociate(pb) => data::TokenAssociate::from_protobuf(pb)?.into(),
            Data::TokenDissociate(pb) => data::TokenDissociate::from_protobuf(pb)?.into(),
            Data::TokenFeeScheduleUpdate(pb) => {
                data::TokenFeeScheduleUpdate::from_protobuf(pb)?.into()
            }
            Data::TokenPause(pb) => data::TokenPause::from_protobuf(pb)?.into(),
            Data::TokenUnpause(pb) => data::TokenUnpause::from_protobuf(pb)?.into(),
            Data::TokenReject(pb) => data::TokenReject::from_protobuf(pb)?.into(),
            Data::ScheduleCreate(pb) => data::ScheduleCreate::from_protobuf(pb)?.into(),
            Data::ScheduleDelete(pb) => data::ScheduleDelete::from_protobuf(pb)?.into(),
            Data::ScheduleSign(pb) => data::ScheduleSign::from_protobuf(pb)?.into(),
            Data::TokenUpdateNfts(pb) => data::TokenUpdateNfts::from_protobuf(pb)?.into(),
            Data::NodeCreate(pb) => data::NodeCreate::from_protobuf(pb)?.into(),
            Data::NodeUpdate(pb) => data::NodeUpdate::from_protobuf(pb)?.into(),
            Data::NodeDelete(pb) => data::NodeDelete::from_protobuf(pb)?.into(),
            Data::TokenAirdrop(pb) => data::TokenAirdrop::from_protobuf(pb)?.into(),
            Data::TokenClaimAirdrop(pb) => data::TokenClaimAirdrop::from_protobuf(pb)?.into(),
            Data::TokenCancelAirdrop(pb) => data::TokenCancelAirdrop::from_protobuf(pb)?.into(),
            Data::CryptoAddLiveHash(_) => {
                return Err(Error::from_protobuf(
                    "unsupported transaction `AddLiveHashTransaction`",
                ))
            }
            Data::CryptoDeleteLiveHash(_) => {
                return Err(Error::from_protobuf(
                    "unsupported transaction `DeleteLiveHashTransaction`",
                ))
            }
            Data::UncheckedSubmit(_) => {
                return Err(Error::from_protobuf(
                    "unsupported transaction `UncheckedSubmitTransaction`",
                ))
            }
            Data::NodeStakeUpdate(_) => {
                return Err(Error::from_protobuf(
                    "unsupported transaction `NodeStakeUpdateTransaction`",
                ))
            }
        };

        Ok(data)
    }
}

impl AnyTransactionData {
    // can't do anything about the # of lines, since this function just delegates to `data::_::from_protobuf`.
    #[allow(clippy::too_many_lines)]
    fn from_protobuf(data_chunks: ServicesTransactionDataList) -> crate::Result<Self> {
        fn try_into_only_element<T>(v: Vec<T>) -> crate::Result<T> {
            match <[T; 1]>::try_from(v) {
                Ok([element]) => Ok(element),
                _ => Err(Error::from_protobuf("chunks in non chunkable transaction")),
            }
        }

        let data = match data_chunks {
            ServicesTransactionDataList::AccountCreate(v) => {
                data::AccountCreate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::AccountUpdate(v) => {
                data::AccountUpdate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::AccountDelete(v) => {
                data::AccountDelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::AccountAllowanceApprove(v) => {
                data::AccountAllowanceApprove::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::AccountAllowanceDelete(v) => {
                data::AccountAllowanceDelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::ContractCreate(v) => {
                data::ContractCreate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::ContractUpdate(v) => {
                data::ContractUpdate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::ContractDelete(v) => {
                data::ContractDelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::ContractExecute(v) => {
                data::ContractExecute::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::Transfer(v) => {
                data::Transfer::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TopicCreate(v) => {
                data::TopicCreate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TopicUpdate(v) => {
                data::TopicUpdate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TopicDelete(v) => {
                data::TopicDelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TopicMessageSubmit(v) => {
                data::TopicMessageSubmit::from_protobuf(v)?.into()
            }
            ServicesTransactionDataList::FileAppend(v) => {
                data::FileAppend::from_protobuf(v)?.into()
            }
            ServicesTransactionDataList::FileCreate(v) => {
                data::FileCreate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::FileUpdate(v) => {
                data::FileUpdate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::FileDelete(v) => {
                data::FileDelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenAssociate(v) => {
                data::TokenAssociate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenBurn(v) => {
                data::TokenBurn::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenCreate(v) => {
                data::TokenCreate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenDelete(v) => {
                data::TokenDelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenDissociate(v) => {
                data::TokenDissociate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenFeeScheduleUpdate(v) => {
                data::TokenFeeScheduleUpdate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenFreeze(v) => {
                data::TokenFreeze::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenGrantKyc(v) => {
                data::TokenGrantKyc::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenMint(v) => {
                data::TokenMint::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenPause(v) => {
                data::TokenPause::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenRevokeKyc(v) => {
                data::TokenRevokeKyc::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenUnfreeze(v) => {
                data::TokenUnfreeze::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenUnpause(v) => {
                data::TokenUnpause::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenUpdate(v) => {
                data::TokenUpdate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenWipe(v) => {
                data::TokenWipe::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::SystemDelete(v) => {
                data::SystemDelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::SystemUndelete(v) => {
                data::SystemUndelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::Freeze(v) => {
                data::Freeze::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::ScheduleCreate(v) => {
                data::ScheduleCreate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::ScheduleSign(v) => {
                data::ScheduleSign::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::ScheduleDelete(v) => {
                data::ScheduleDelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::Ethereum(v) => {
                data::Ethereum::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::UtilPrng(v) => {
                data::Prng::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenUpdateNfts(v) => {
                data::TokenUpdateNfts::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenReject(v) => {
                data::TokenReject::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::NodeCreate(v) => {
                data::NodeCreate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::NodeUpdate(v) => {
                data::NodeUpdate::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::NodeDelete(v) => {
                data::NodeDelete::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenAirdrop(v) => {
                data::TokenAirdrop::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenClaimAirdrop(v) => {
                data::TokenClaimAirdrop::from_protobuf(try_into_only_element(v)?)?.into()
            }
            ServicesTransactionDataList::TokenCancelAirdrop(v) => {
                data::TokenCancelAirdrop::from_protobuf(try_into_only_element(v)?)?.into()
            }
        };

        Ok(data)
    }
}

impl AnyTransaction {
    pub(super) fn from_protobuf(
        first_body: services::TransactionBody,
        data_chunks: Vec<services::transaction_body::Data>,
    ) -> crate::Result<Self> {
        Ok(Transaction {
            body: TransactionBody {
                data: AnyTransactionData::from_protobuf(
                    ServicesTransactionDataList::from_protobuf(data_chunks)?,
                )?,
                node_account_ids: None,
                transaction_valid_duration: first_body.transaction_valid_duration.map(Into::into),
                max_transaction_fee: Some(Hbar::from_tinybars(first_body.transaction_fee as i64)),
                transaction_memo: first_body.memo,
                transaction_id: Some(TransactionId::from_protobuf(pb_getf!(
                    first_body,
                    transaction_id
                )?)?),
                operator: None,
                is_frozen: true,
                regenerate_transaction_id: Some(false),
                custom_fee_limits: first_body
                    .max_custom_fees
                    .into_iter()
                    .map(CustomFeeLimit::from_protobuf)
                    .collect::<Result<Vec<_>, _>>()?,
            },
            signers: Vec::new(),
            sources: None,
        })
    }
}

// sigh.
#[derive(Debug)]
enum ServicesTransactionDataList {
    AccountCreate(Vec<services::CryptoCreateTransactionBody>),
    AccountUpdate(Vec<services::CryptoUpdateTransactionBody>),
    AccountDelete(Vec<services::CryptoDeleteTransactionBody>),
    AccountAllowanceApprove(Vec<services::CryptoApproveAllowanceTransactionBody>),
    AccountAllowanceDelete(Vec<services::CryptoDeleteAllowanceTransactionBody>),
    ContractCreate(Vec<services::ContractCreateTransactionBody>),
    ContractUpdate(Vec<services::ContractUpdateTransactionBody>),
    ContractDelete(Vec<services::ContractDeleteTransactionBody>),
    ContractExecute(Vec<services::ContractCallTransactionBody>),
    Transfer(Vec<services::CryptoTransferTransactionBody>),
    TopicCreate(Vec<services::ConsensusCreateTopicTransactionBody>),
    TopicUpdate(Vec<services::ConsensusUpdateTopicTransactionBody>),
    TopicDelete(Vec<services::ConsensusDeleteTopicTransactionBody>),
    TopicMessageSubmit(Vec<services::ConsensusSubmitMessageTransactionBody>),
    FileAppend(Vec<services::FileAppendTransactionBody>),
    FileCreate(Vec<services::FileCreateTransactionBody>),
    FileUpdate(Vec<services::FileUpdateTransactionBody>),
    FileDelete(Vec<services::FileDeleteTransactionBody>),
    TokenAssociate(Vec<services::TokenAssociateTransactionBody>),
    TokenBurn(Vec<services::TokenBurnTransactionBody>),
    TokenCreate(Vec<services::TokenCreateTransactionBody>),
    TokenDelete(Vec<services::TokenDeleteTransactionBody>),
    TokenDissociate(Vec<services::TokenDissociateTransactionBody>),
    TokenFeeScheduleUpdate(Vec<services::TokenFeeScheduleUpdateTransactionBody>),
    TokenFreeze(Vec<services::TokenFreezeAccountTransactionBody>),
    TokenGrantKyc(Vec<services::TokenGrantKycTransactionBody>),
    TokenMint(Vec<services::TokenMintTransactionBody>),
    TokenPause(Vec<services::TokenPauseTransactionBody>),
    TokenRevokeKyc(Vec<services::TokenRevokeKycTransactionBody>),
    TokenUnfreeze(Vec<services::TokenUnfreezeAccountTransactionBody>),
    TokenUnpause(Vec<services::TokenUnpauseTransactionBody>),
    TokenUpdate(Vec<services::TokenUpdateTransactionBody>),
    TokenWipe(Vec<services::TokenWipeAccountTransactionBody>),
    TokenUpdateNfts(Vec<services::TokenUpdateNftsTransactionBody>),
    TokenReject(Vec<services::TokenRejectTransactionBody>),
    SystemDelete(Vec<services::SystemDeleteTransactionBody>),
    SystemUndelete(Vec<services::SystemUndeleteTransactionBody>),
    Freeze(Vec<services::FreezeTransactionBody>),
    ScheduleCreate(Vec<services::ScheduleCreateTransactionBody>),
    ScheduleSign(Vec<services::ScheduleSignTransactionBody>),
    ScheduleDelete(Vec<services::ScheduleDeleteTransactionBody>),
    Ethereum(Vec<services::EthereumTransactionBody>),
    UtilPrng(Vec<services::UtilPrngTransactionBody>),
    NodeCreate(Vec<services::NodeCreateTransactionBody>),
    NodeUpdate(Vec<services::NodeUpdateTransactionBody>),
    NodeDelete(Vec<services::NodeDeleteTransactionBody>),
    TokenAirdrop(Vec<services::TokenAirdropTransactionBody>),
    TokenClaimAirdrop(Vec<services::TokenClaimAirdropTransactionBody>),
    TokenCancelAirdrop(Vec<services::TokenCancelAirdropTransactionBody>),
}

impl FromProtobuf<Vec<services::transaction_body::Data>> for ServicesTransactionDataList {
    fn from_protobuf(pb: Vec<services::transaction_body::Data>) -> crate::Result<Self> {
        use services::transaction_body::Data;

        fn make_vec<T>(first: T, cap: usize) -> Vec<T> {
            let mut v = Vec::with_capacity(cap);
            v.push(first);
            v
        }

        let len = pb.len();

        let mut iter = pb.into_iter();

        let first = iter
            .next()
            .expect("empty transaction data list (should be handled earlier up the pipeline)");

        // note: this impl is what I (srr) believe to be the "best" impl
        let mut value = match first {
            Data::ContractCall(it) => Self::ContractExecute(make_vec(it, len)),
            Data::ContractCreateInstance(it) => Self::ContractCreate(make_vec(it, len)),
            Data::ContractUpdateInstance(it) => Self::ContractUpdate(make_vec(it, len)),
            Data::ContractDeleteInstance(it) => Self::ContractDelete(make_vec(it, len)),
            Data::EthereumTransaction(it) => Self::Ethereum(make_vec(it, len)),
            Data::CryptoApproveAllowance(it) => Self::AccountAllowanceApprove(make_vec(it, len)),
            Data::CryptoDeleteAllowance(it) => Self::AccountAllowanceDelete(make_vec(it, len)),
            Data::CryptoCreateAccount(it) => Self::AccountCreate(make_vec(it, len)),
            Data::CryptoDelete(it) => Self::AccountDelete(make_vec(it, len)),
            Data::CryptoTransfer(it) => Self::Transfer(make_vec(it, len)),
            Data::CryptoUpdateAccount(it) => Self::AccountUpdate(make_vec(it, len)),
            Data::FileAppend(it) => Self::FileAppend(make_vec(it, len)),
            Data::FileCreate(it) => Self::FileCreate(make_vec(it, len)),
            Data::FileDelete(it) => Self::FileDelete(make_vec(it, len)),
            Data::FileUpdate(it) => Self::FileUpdate(make_vec(it, len)),
            Data::SystemDelete(it) => Self::SystemDelete(make_vec(it, len)),
            Data::SystemUndelete(it) => Self::SystemUndelete(make_vec(it, len)),
            Data::Freeze(it) => Self::Freeze(make_vec(it, len)),
            Data::ConsensusCreateTopic(it) => Self::TopicCreate(make_vec(it, len)),
            Data::ConsensusUpdateTopic(it) => Self::TopicUpdate(make_vec(it, len)),
            Data::ConsensusDeleteTopic(it) => Self::TopicDelete(make_vec(it, len)),
            Data::ConsensusSubmitMessage(it) => Self::TopicMessageSubmit(make_vec(it, len)),
            Data::TokenCreation(it) => Self::TokenCreate(make_vec(it, len)),
            Data::TokenFreeze(it) => Self::TokenFreeze(make_vec(it, len)),
            Data::TokenUnfreeze(it) => Self::TokenUnfreeze(make_vec(it, len)),
            Data::TokenGrantKyc(it) => Self::TokenGrantKyc(make_vec(it, len)),
            Data::TokenRevokeKyc(it) => Self::TokenRevokeKyc(make_vec(it, len)),
            Data::TokenDeletion(it) => Self::TokenDelete(make_vec(it, len)),
            Data::TokenUpdate(it) => Self::TokenUpdate(make_vec(it, len)),
            Data::TokenMint(it) => Self::TokenMint(make_vec(it, len)),
            Data::TokenBurn(it) => Self::TokenBurn(make_vec(it, len)),
            Data::TokenWipe(it) => Self::TokenWipe(make_vec(it, len)),
            Data::TokenAssociate(it) => Self::TokenAssociate(make_vec(it, len)),
            Data::TokenDissociate(it) => Self::TokenDissociate(make_vec(it, len)),
            Data::TokenFeeScheduleUpdate(it) => Self::TokenFeeScheduleUpdate(make_vec(it, len)),
            Data::TokenPause(it) => Self::TokenPause(make_vec(it, len)),
            Data::TokenUnpause(it) => Self::TokenUnpause(make_vec(it, len)),
            Data::TokenReject(it) => Self::TokenReject(make_vec(it, len)),
            Data::ScheduleCreate(it) => Self::ScheduleCreate(make_vec(it, len)),
            Data::ScheduleDelete(it) => Self::ScheduleDelete(make_vec(it, len)),
            Data::ScheduleSign(it) => Self::ScheduleSign(make_vec(it, len)),
            Data::UtilPrng(it) => Self::UtilPrng(make_vec(it, len)),
            Data::TokenUpdateNfts(it) => Self::TokenUpdateNfts(make_vec(it, len)),
            Data::NodeCreate(it) => Self::NodeCreate(make_vec(it, len)),
            Data::NodeUpdate(it) => Self::NodeUpdate(make_vec(it, len)),
            Data::NodeDelete(it) => Self::NodeDelete(make_vec(it, len)),
            Data::TokenAirdrop(it) => Self::TokenAirdrop(make_vec(it, len)),
            Data::TokenClaimAirdrop(it) => Self::TokenClaimAirdrop(make_vec(it, len)),
            Data::TokenCancelAirdrop(it) => Self::TokenCancelAirdrop(make_vec(it, len)),
            Data::CryptoAddLiveHash(_) => {
                return Err(Error::from_protobuf(
                    "unsupported transaction `AddLiveHashTransaction`",
                ))
            }
            Data::CryptoDeleteLiveHash(_) => {
                return Err(Error::from_protobuf(
                    "unsupported transaction `DeleteLiveHashTransaction`",
                ))
            }

            Data::UncheckedSubmit(_) => {
                return Err(Error::from_protobuf(
                    "unsupported transaction `UncheckedSubmitTransaction`",
                ))
            }
            Data::NodeStakeUpdate(_) => {
                return Err(Error::from_protobuf(
                    "unsupported transaction `NodeStakeUpdateTransaction`",
                ))
            }
        };

        for transaction in iter {
            match (&mut value, transaction) {
                (Self::AccountCreate(v), Data::CryptoCreateAccount(element)) => v.push(element),
                (Self::AccountUpdate(v), Data::CryptoUpdateAccount(element)) => v.push(element),
                (Self::AccountDelete(v), Data::CryptoDelete(element)) => v.push(element),
                (Self::AccountAllowanceApprove(v), Data::CryptoApproveAllowance(element)) => {
                    v.push(element);
                }
                (Self::AccountAllowanceDelete(v), Data::CryptoDeleteAllowance(element)) => {
                    v.push(element);
                }
                (Self::ContractCreate(v), Data::ContractCreateInstance(element)) => v.push(element),
                (Self::ContractUpdate(v), Data::ContractUpdateInstance(element)) => v.push(element),
                (Self::ContractDelete(v), Data::ContractDeleteInstance(element)) => v.push(element),
                (Self::ContractExecute(v), Data::ContractCall(element)) => v.push(element),
                (Self::Transfer(v), Data::CryptoTransfer(element)) => v.push(element),
                (Self::TopicCreate(v), Data::ConsensusCreateTopic(element)) => v.push(element),
                (Self::TopicUpdate(v), Data::ConsensusUpdateTopic(element)) => v.push(element),
                (Self::TopicDelete(v), Data::ConsensusDeleteTopic(element)) => v.push(element),
                (Self::TopicMessageSubmit(v), Data::ConsensusSubmitMessage(element)) => {
                    v.push(element);
                }
                (Self::FileAppend(v), Data::FileAppend(element)) => v.push(element),
                (Self::FileCreate(v), Data::FileCreate(element)) => v.push(element),
                (Self::FileUpdate(v), Data::FileUpdate(element)) => v.push(element),
                (Self::FileDelete(v), Data::FileDelete(element)) => v.push(element),
                (Self::TokenAssociate(v), Data::TokenAssociate(element)) => v.push(element),
                (Self::TokenBurn(v), Data::TokenBurn(element)) => v.push(element),
                (Self::TokenCreate(v), Data::TokenCreation(element)) => v.push(element),
                (Self::TokenDelete(v), Data::TokenDeletion(element)) => v.push(element),
                (Self::TokenDissociate(v), Data::TokenDissociate(element)) => v.push(element),
                (Self::TokenFeeScheduleUpdate(v), Data::TokenFeeScheduleUpdate(element)) => {
                    v.push(element);
                }
                (Self::TokenFreeze(v), Data::TokenFreeze(element)) => v.push(element),
                (Self::TokenGrantKyc(v), Data::TokenGrantKyc(element)) => v.push(element),
                (Self::TokenMint(v), Data::TokenMint(element)) => v.push(element),
                (Self::TokenPause(v), Data::TokenPause(element)) => v.push(element),
                (Self::TokenRevokeKyc(v), Data::TokenRevokeKyc(element)) => v.push(element),
                (Self::TokenUnfreeze(v), Data::TokenUnfreeze(element)) => v.push(element),
                (Self::TokenUnpause(v), Data::TokenUnpause(element)) => v.push(element),
                (Self::TokenUpdate(v), Data::TokenUpdate(element)) => v.push(element),
                (Self::TokenWipe(v), Data::TokenWipe(element)) => v.push(element),
                (Self::SystemDelete(v), Data::SystemDelete(element)) => v.push(element),
                (Self::SystemUndelete(v), Data::SystemUndelete(element)) => v.push(element),
                (Self::Freeze(v), Data::Freeze(element)) => v.push(element),
                (Self::ScheduleCreate(v), Data::ScheduleCreate(element)) => v.push(element),
                (Self::ScheduleSign(v), Data::ScheduleSign(element)) => v.push(element),
                (Self::ScheduleDelete(v), Data::ScheduleDelete(element)) => v.push(element),
                (Self::Ethereum(v), Data::EthereumTransaction(element)) => v.push(element),
                (Self::UtilPrng(v), Data::UtilPrng(element)) => v.push(element),
                (Self::TokenAirdrop(v), Data::TokenAirdrop(element)) => v.push(element),
                (Self::TokenClaimAirdrop(v), Data::TokenClaimAirdrop(element)) => v.push(element),
                (Self::TokenCancelAirdrop(v), Data::TokenCancelAirdrop(element)) => v.push(element),

                _ => return Err(Error::from_protobuf("mismatched transaction types")),
            }
        }

        Ok(value)
    }
}

impl AnyTransaction {
    /// Attempt to downcast from any transaction to the given transaction kind.
    ///
    /// # Errors
    /// - If self doesn't match the given transaction type, the transaction is returned as-is.
    pub fn downcast<D>(self) -> Result<D, Self>
    where
        Self: DowncastOwned<D>,
    {
        self.downcast_owned()
    }
}

// this is macro worthy (there's like 40 transactions that all do this the exact same way)
/// Impl `DowncastOwned` for `AnyTransactionData`.
///
/// This macro will ensure you get all variants via a pattern match, if something changes (say, another transaction type is added), you'll get a `Missing match arm` compiler error.
macro_rules! impl_cast_any {
    ($($id:ident),+$(,)?) => {
        $(
            impl $crate::downcast::DowncastOwned<data::$id> for AnyTransactionData {
                fn downcast_owned(self) -> Result<data::$id, Self> {
                    let Self::$id(data) = self else {
                        return Err(self)
                    };

                    Ok(data)
                }
            }

            impl From<Transaction<data::$id>> for AnyTransaction {
                fn from(transaction: Transaction<data::$id>) -> Self {
                    Self {
                        body: TransactionBody {
                            data: transaction.body.data.into(),
                            node_account_ids: transaction.body.node_account_ids,
                            transaction_valid_duration: transaction.body.transaction_valid_duration,
                            max_transaction_fee: transaction.body.max_transaction_fee,
                            transaction_memo: transaction.body.transaction_memo,
                            transaction_id: transaction.body.transaction_id,
                            operator: transaction.body.operator,
                            is_frozen: transaction.body.is_frozen,
                            regenerate_transaction_id: transaction.body.regenerate_transaction_id,
                            custom_fee_limits: transaction.body.custom_fee_limits,
                        },
                        signers: transaction.signers,
                        sources: transaction.sources,
                    }
                }
            }
        )*

        #[allow(non_snake_case)]
        mod ___private_impl_cast_any {
            use super::AnyTransactionData;
            // ensure the what we were given is actually everything.
            fn _assert_exhaustive(d: AnyTransactionData)
            {
                match d {
                    $(AnyTransactionData::$id(_) => {},)+
                }
            }
        }
    };
}

impl_cast_any! {
    AccountCreate,
    AccountUpdate,
    AccountDelete,
    AccountAllowanceApprove,
    AccountAllowanceDelete,
    ContractCreate,
    ContractUpdate,
    ContractDelete,
    ContractExecute,
    Transfer,
    TopicCreate,
    TopicUpdate,
    TopicDelete,
    TopicMessageSubmit,
    FileAppend,
    FileCreate,
    FileUpdate,
    FileDelete,
    Prng,
    ScheduleCreate,
    ScheduleSign,
    ScheduleDelete,
    TokenAssociate,
    TokenBurn,
    TokenCreate,
    TokenDelete,
    TokenDissociate,
    TokenFeeScheduleUpdate,
    TokenFreeze,
    TokenGrantKyc,
    TokenMint,
    TokenPause,
    TokenRevokeKyc,
    TokenUnfreeze,
    TokenUnpause,
    TokenUpdate,
    TokenWipe,
    SystemDelete,
    SystemUndelete,
    Freeze,
    Ethereum,
    TokenUpdateNfts,
    NodeCreate,
    NodeUpdate,
    NodeDelete,
    TokenReject,
    TokenAirdrop,
    TokenClaimAirdrop,
    TokenCancelAirdrop
}
// Filename: src/transaction/chunked.rs
use std::cmp;
use std::num::NonZeroUsize;

use hedera_proto::services;
use tonic::transport::Channel;

use super::{
    TransactionData,
    TransactionExecute,
};
use crate::entity_id::ValidateChecksums;
use crate::execute::Execute;
use crate::ledger_id::RefLedgerId;
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Hbar,
    Transaction,
    TransactionHash,
    TransactionId,
    TransactionResponse,
};

/// Per transaction chunk data (you'd add this to any chunked transaction)
#[derive(Clone, Debug, PartialEq)]
pub struct ChunkData {
    pub(crate) max_chunks: usize,
    pub(crate) chunk_size: NonZeroUsize,
    pub(crate) data: Vec<u8>,
}

impl Default for ChunkData {
    fn default() -> Self {
        Self {
            max_chunks: Self::DEFAULT_MAX_CHUNKS,
            chunk_size: Self::DEFAULT_CHUNK_SIZE,
            data: Vec::new(),
        }
    }
}

impl ChunkData {
    const DEFAULT_MAX_CHUNKS: usize = 20;
    // safety: 1024 is not zero.
    // note: Use `NonZeroUsize::new().unwrap()` once that's const stable.
    const DEFAULT_CHUNK_SIZE: NonZeroUsize = match NonZeroUsize::new(1024) {
        Some(it) => it,
        None => unreachable!(),
    };

    pub(crate) fn used_chunks(&self) -> usize {
        if self.data.is_empty() {
            return 1;
        }

        // div ceil algorithm, fun fact: the intrinsic `div_ceil` can't get rid of the panic (it's unstable anyway)
        (self.data.len() + self.chunk_size.get()) / self.chunk_size
    }

    pub(crate) fn message_chunk(&self, chunk_info: &ChunkInfo) -> &[u8] {
        debug_assert!(chunk_info.current < self.used_chunks());

        let start = self.chunk_size.get() * chunk_info.current;
        let end = cmp::min(self.chunk_size.get() * (chunk_info.current + 1), self.data.len());

        &self.data[start..end]
    }

    pub(crate) fn max_message_len(&self) -> usize {
        self.max_chunks * self.chunk_size.get()
    }
}

pub struct ChunkInfo {
    /// Current chunk # out of [`max_chunks`](ChunkData.max_chunks) total.
    pub(crate) current: usize,

    /// How many chunks there will be.
    /// if `chunks` was a `[ChunkInfo]` this would be the length.
    pub(crate) total: usize,

    /// transaction ID for transaction 0 (if `current` is 0 this is that one).
    pub(crate) initial_transaction_id: TransactionId,

    /// transaction ID for the current transaction.
    pub(crate) current_transaction_id: TransactionId,

    /// ID for the account this transaction will be submitted to.
    pub(crate) node_account_id: AccountId,
}

impl ChunkInfo {
    #[must_use]
    pub(crate) fn assert_single_transaction(&self) -> (TransactionId, AccountId) {
        assert!(self.current == 0 && self.total == 1);
        (self.current_transaction_id, self.node_account_id)
    }

    #[must_use]
    // taking `transaction_id` by reference and then dereferencing it to copy it unconditionally... Feels weird.
    #[allow(clippy::large_types_passed_by_value)]
    pub(crate) const fn single(transaction_id: TransactionId, node_account_id: AccountId) -> Self {
        Self::initial(1, transaction_id, node_account_id)
    }

    #[must_use]
    // taking `transaction_id` by reference and then dereferencing it to copy it unconditionally... Feels weird.
    #[allow(clippy::large_types_passed_by_value)]
    pub(crate) const fn initial(
        total: usize,
        transaction_id: TransactionId,
        node_account_id: AccountId,
    ) -> Self {
        Self {
            current: 0,
            total,
            initial_transaction_id: transaction_id,
            current_transaction_id: transaction_id,
            node_account_id,
        }
    }
}

pub(super) struct FirstChunkView<'a, D> {
    pub(super) transaction: &'a Transaction<D>,
    pub(super) total_chunks: usize,
}

impl<'a, D> Execute for FirstChunkView<'a, D>
where
    D: TransactionExecute,
{
    type GrpcRequest = services::Transaction;

    type GrpcResponse = services::TransactionResponse;

    type Context = TransactionHash;

    type Response = TransactionResponse;

    fn node_account_ids(&self) -> Option<&[AccountId]> {
        self.transaction.body.node_account_ids.as_deref()
    }

    fn transaction_id(&self) -> Option<TransactionId> {
        self.transaction.get_transaction_id()
    }

    fn requires_transaction_id(&self) -> bool {
        true
    }

    fn regenerate_transaction_id(&self) -> Option<bool> {
        self.transaction.regenerate_transaction_id()
    }

    fn operator_account_id(&self) -> Option<&AccountId> {
        self.transaction.operator_account_id()
    }

    fn make_request(
        &self,
        transaction_id: Option<&TransactionId>,
        node_account_id: AccountId,
    ) -> crate::Result<(Self::GrpcRequest, Self::Context)> {
        assert!(self.transaction.is_frozen());

        Ok(self.transaction.make_request_inner(&ChunkInfo::initial(
            self.total_chunks,
            *transaction_id.ok_or(Error::NoPayerAccountOrTransactionId)?,
            node_account_id,
        )))
    }

    fn execute(
        &self,
        channel: Channel,
        request: Self::GrpcRequest,
    ) -> BoxGrpcFuture<'_, Self::GrpcResponse> {
        self.transaction.body.data.execute(channel, request)
    }

    fn make_response(
        &self,
        _response: Self::GrpcResponse,
        context: Self::Context,
        node_account_id: AccountId,
        transaction_id: Option<&TransactionId>,
    ) -> crate::Result<Self::Response> {
        Ok(TransactionResponse {
            node_account_id,
            transaction_id: *transaction_id.unwrap(),
            transaction_hash: context,
            validate_status: true,
        })
    }

    fn make_error_pre_check(
        &self,
        status: services::ResponseCodeEnum,
        transaction_id: Option<&TransactionId>,
        response: Self::GrpcResponse,
    ) -> crate::Error {
        crate::Error::TransactionPreCheckStatus {
            status,
            cost: (response.cost != 0).then(|| Hbar::from_tinybars(response.cost as i64)),
            transaction_id: Box::new(
                *transaction_id.expect("transactions must have transaction IDs"),
            ),
        }
    }

    fn response_pre_check_status(response: &Self::GrpcResponse) -> crate::Result<i32> {
        Ok(response.node_transaction_precheck_code)
    }
}

impl<'a, D: ValidateChecksums> ValidateChecksums for FirstChunkView<'a, D> {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.transaction.validate_checksums(ledger_id)
    }
}

pub(super) struct ChunkView<'a, D> {
    pub(super) transaction: &'a Transaction<D>,
    pub(super) initial_transaction_id: TransactionId,
    pub(super) current_chunk: usize,
    pub(super) total_chunks: usize,
}

impl<'a, D> Execute for ChunkView<'a, D>
where
    D: TransactionExecute,
{
    type GrpcRequest = services::Transaction;

    type GrpcResponse = services::TransactionResponse;

    type Context = TransactionHash;

    type Response = TransactionResponse;

    fn node_account_ids(&self) -> Option<&[AccountId]> {
        self.transaction.body.node_account_ids.as_deref()
    }

    fn transaction_id(&self) -> Option<TransactionId> {
        None
    }

    fn operator_account_id(&self) -> Option<&AccountId> {
        self.transaction.operator_account_id()
    }

    fn requires_transaction_id(&self) -> bool {
        true
    }

    fn regenerate_transaction_id(&self) -> Option<bool> {
        self.transaction.regenerate_transaction_id()
    }

    fn make_request(
        &self,
        transaction_id: Option<&TransactionId>,
        node_account_id: AccountId,
    ) -> crate::Result<(Self::GrpcRequest, Self::Context)> {
        assert!(self.transaction.is_frozen());

        Ok(self.transaction.make_request_inner(&ChunkInfo {
            total: self.total_chunks,
            current: self.current_chunk,
            initial_transaction_id: self.initial_transaction_id,
            node_account_id,
            current_transaction_id: *transaction_id.ok_or(Error::NoPayerAccountOrTransactionId)?,
        }))
    }

    fn execute(
        &self,
        channel: Channel,
        request: Self::GrpcRequest,
    ) -> BoxGrpcFuture<'_, Self::GrpcResponse> {
        self.transaction.body.data.execute(channel, request)
    }

    fn make_response(
        &self,
        _response: Self::GrpcResponse,
        context: Self::Context,
        node_account_id: AccountId,
        transaction_id: Option<&TransactionId>,
    ) -> crate::Result<Self::Response> {
        Ok(TransactionResponse {
            node_account_id,
            transaction_id: *transaction_id.unwrap(),
            transaction_hash: context,
            validate_status: true,
        })
    }

    fn make_error_pre_check(
        &self,
        status: services::ResponseCodeEnum,
        transaction_id: Option<&TransactionId>,
        response: Self::GrpcResponse,
    ) -> crate::Error {
        crate::Error::TransactionPreCheckStatus {
            status,
            cost: (response.cost != 0).then(|| Hbar::from_tinybars(response.cost as i64)),
            transaction_id: Box::new(
                *transaction_id.expect("transactions must have transaction IDs"),
            ),
        }
    }

    fn response_pre_check_status(response: &Self::GrpcResponse) -> crate::Result<i32> {
        Ok(response.node_transaction_precheck_code)
    }
}

impl<'a, D: ValidateChecksums> ValidateChecksums for ChunkView<'a, D> {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.transaction.validate_checksums(ledger_id)?;
        self.initial_transaction_id.validate_checksums(ledger_id)?;

        Ok(())
    }
}

// Note: this is completely optional to implement, just makes more methods available on `Transaction`.
pub trait ChunkedTransactionData: TransactionData {
    fn chunk_data(&self) -> &ChunkData;
    fn chunk_data_mut(&mut self) -> &mut ChunkData;
}
// Filename: src/transaction/cost.rs
use hedera_proto::services;
use tonic::transport::Channel;

use super::{
    AnyTransactionData,
    ChunkInfo,
    ToTransactionDataProtobuf,
    TransactionBody,
    TransactionData,
    TransactionExecute,
};
use crate::{
    BoxGrpcFuture,
    Transaction,
    ValidateChecksums,
};

#[derive(Clone)]
pub(crate) struct CostTransactionData<D> {
    pub(crate) inner: D,
}

pub(crate) type CostTransaction<D> = Transaction<CostTransactionData<D>>;

impl<D: Clone> CostTransaction<D> {
    pub(crate) fn from_transaction(transaction: &Transaction<D>) -> Self {
        let transaction = transaction.clone();

        Self {
            body: TransactionBody {
                data: CostTransactionData { inner: transaction.body.data },
                node_account_ids: transaction.body.node_account_ids,
                transaction_valid_duration: transaction.body.transaction_valid_duration,
                max_transaction_fee: transaction.body.max_transaction_fee,
                transaction_memo: transaction.body.transaction_memo,
                transaction_id: transaction.body.transaction_id,
                operator: transaction.body.operator,
                is_frozen: transaction.body.is_frozen,
                regenerate_transaction_id: transaction.body.regenerate_transaction_id,
                custom_fee_limits: transaction.body.custom_fee_limits,
            },
            // cost transactions have no signers
            signers: Vec::new(),
            sources: transaction.sources,
        }
    }
}

impl<D: Into<AnyTransactionData>> From<CostTransactionData<D>> for AnyTransactionData {
    fn from(transaction: CostTransactionData<D>) -> Self {
        transaction.inner.into()
    }
}

impl<D: TransactionData> TransactionData for CostTransactionData<D> {
    #[doc(hidden)]
    fn for_cost_estimate(&self) -> bool {
        true
    }
}

impl<D: TransactionExecute> TransactionExecute for CostTransactionData<D> {
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        self.inner.execute(channel, request)
    }
}

impl<D: ValidateChecksums> ValidateChecksums for CostTransactionData<D> {
    fn validate_checksums(&self, ledger_id: &crate::ledger_id::RefLedgerId) -> crate::Result<()> {
        self.inner.validate_checksums(ledger_id)
    }
}

impl<D: ToTransactionDataProtobuf> ToTransactionDataProtobuf for CostTransactionData<D> {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        self.inner.to_transaction_data_protobuf(chunk_info)
    }
}
// Filename: src/transaction/execute.rs
// SPDX-License-Identifier: Apache-2.0

use std::borrow::Cow;
use std::collections::HashMap;

use hedera_proto::services;
use prost::Message;
use tonic::transport::Channel;

use super::chunked::ChunkInfo;
use super::source::SourceChunk;
use super::{
    ChunkData,
    TransactionSources,
};
use crate::execute::Execute;
use crate::ledger_id::RefLedgerId;
use crate::transaction::any::AnyTransactionData;
use crate::transaction::protobuf::ToTransactionDataProtobuf;
use crate::transaction::DEFAULT_TRANSACTION_VALID_DURATION;
use crate::{
    AccountId,
    BoxGrpcFuture,
    Client,
    Error,
    Hbar,
    PublicKey,
    ToProtobuf,
    Transaction,
    TransactionHash,
    TransactionId,
    TransactionResponse,
    ValidateChecksums,
};

#[derive(Debug)]
pub(super) struct SignaturePair {
    signature: Vec<u8>,
    public: PublicKey,
}

impl SignaturePair {
    pub fn into_protobuf(self) -> services::SignaturePair {
        let signature = match self.public.kind() {
            crate::key::KeyKind::Ed25519 => {
                services::signature_pair::Signature::Ed25519(self.signature)
            }
            crate::key::KeyKind::Ecdsa => {
                services::signature_pair::Signature::EcdsaSecp256k1(self.signature)
            }
        };
        services::SignaturePair {
            signature: Some(signature),
            // TODO: is there any way to utilize the _prefix_ nature of this field?
            pub_key_prefix: self.public.to_bytes_raw(),
        }
    }
}

impl From<(PublicKey, Vec<u8>)> for SignaturePair {
    fn from((public, signature): (PublicKey, Vec<u8>)) -> Self {
        Self { signature, public }
    }
}

impl<D> Transaction<D>
where
    D: TransactionData + ToTransactionDataProtobuf,
{
    pub(crate) fn make_request_inner(
        &self,
        chunk_info: &ChunkInfo,
    ) -> (services::Transaction, TransactionHash) {
        assert!(self.is_frozen());

        let transaction_body = self.to_transaction_body_protobuf(chunk_info);

        let body_bytes = transaction_body.encode_to_vec();

        let mut signatures = Vec::with_capacity(1 + self.signers.len());

        if let Some(operator) = &self.body.operator {
            let operator_signature = operator.sign(&body_bytes);

            signatures.push(SignaturePair::from(operator_signature).into_protobuf());
        }

        for signer in &self.signers {
            let public_key = signer.public_key().to_bytes();
            if !signatures.iter().any(|it| public_key.starts_with(&it.pub_key_prefix)) {
                let signature = signer.sign(&body_bytes);
                signatures.push(SignaturePair::from(signature).into_protobuf());
            }
        }

        let signed_transaction = services::SignedTransaction {
            body_bytes,
            sig_map: Some(services::SignatureMap { sig_pair: signatures }),
        };

        let signed_transaction_bytes = signed_transaction.encode_to_vec();

        let transaction_hash = TransactionHash::new(&signed_transaction_bytes);

        let transaction =
            services::Transaction { signed_transaction_bytes, ..services::Transaction::default() };

        (transaction, transaction_hash)
    }
}

/// Pre-execute associated fields for transaction data.
pub trait TransactionData: Clone + Into<AnyTransactionData> {
    /// Whether this transaction is intended to be executed to return a cost estimate.
    #[doc(hidden)]
    fn for_cost_estimate(&self) -> bool {
        false
    }

    /// Returns the maximum allowed transaction fee if none is specified.
    ///
    /// Specifically, this default will be used in the following case:
    /// - The transaction itself (direct user input) has no `max_transaction_fee` specified, AND
    /// - The [`Client`](crate::Client) has no `max_transaction_fee` specified.
    fn default_max_transaction_fee(&self) -> Hbar {
        Hbar::new(2)
    }

    /// Returns the chunk data for this transaction if this is a chunked transaction.
    fn maybe_chunk_data(&self) -> Option<&ChunkData> {
        None
    }

    /// Returns `true` if `self` is a chunked transaction *and* it should wait for receipts between each chunk.
    fn wait_for_receipt(&self) -> bool {
        false
    }
}

pub trait TransactionExecute:
    ToTransactionDataProtobuf + TransactionData + ValidateChecksums
{
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse>;
}

impl<D> Execute for Transaction<D>
where
    D: TransactionExecute,
{
    type GrpcRequest = services::Transaction;

    type GrpcResponse = services::TransactionResponse;

    type Context = TransactionHash;

    type Response = TransactionResponse;

    fn node_account_ids(&self) -> Option<&[AccountId]> {
        self.body.node_account_ids.as_deref()
    }

    fn transaction_id(&self) -> Option<TransactionId> {
        self.body.transaction_id
    }

    fn requires_transaction_id(&self) -> bool {
        true
    }

    fn operator_account_id(&self) -> Option<&AccountId> {
        self.body.operator.as_deref().map(|it| &it.account_id)
    }

    fn regenerate_transaction_id(&self) -> Option<bool> {
        self.body.regenerate_transaction_id
    }

    fn make_request(
        &self,
        transaction_id: Option<&TransactionId>,
        node_account_id: AccountId,
    ) -> crate::Result<(Self::GrpcRequest, Self::Context)> {
        assert!(self.is_frozen());

        Ok(self.make_request_inner(&ChunkInfo::single(
            *transaction_id.ok_or(Error::NoPayerAccountOrTransactionId)?,
            node_account_id,
        )))
    }

    fn execute(
        &self,
        channel: Channel,
        request: Self::GrpcRequest,
    ) -> BoxGrpcFuture<'_, Self::GrpcResponse> {
        self.body.data.execute(channel, request)
    }

    fn make_response(
        &self,
        _response: Self::GrpcResponse,
        transaction_hash: Self::Context,
        node_account_id: AccountId,
        transaction_id: Option<&TransactionId>,
    ) -> crate::Result<Self::Response> {
        Ok(TransactionResponse {
            node_account_id,
            transaction_id: *transaction_id.unwrap(),
            transaction_hash,
            validate_status: true,
        })
    }

    fn make_error_pre_check(
        &self,
        status: crate::Status,
        transaction_id: Option<&TransactionId>,
        response: Self::GrpcResponse,
    ) -> crate::Error {
        crate::Error::TransactionPreCheckStatus {
            status,
            cost: (response.cost != 0).then(|| Hbar::from_tinybars(response.cost as i64)),
            transaction_id: Box::new(
                *transaction_id.expect("transactions must have transaction IDs"),
            ),
        }
    }

    fn response_pre_check_status(response: &Self::GrpcResponse) -> crate::Result<i32> {
        Ok(response.node_transaction_precheck_code)
    }
}

/// Marker trait for transactions that support Chunking.
pub trait TransactionExecuteChunked: TransactionExecute {}

impl<D: ValidateChecksums> ValidateChecksums for Transaction<D> {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        if let Some(node_account_ids) = &self.body.node_account_ids {
            for node_account_id in node_account_ids {
                node_account_id.validate_checksums(ledger_id)?;
            }
        }
        self.body.transaction_id.validate_checksums(ledger_id)?;
        self.body.data.validate_checksums(ledger_id)
    }
}

impl<D> Transaction<D>
where
    D: TransactionData + ToTransactionDataProtobuf,
{
    #[allow(deprecated)]
    fn to_transaction_body_protobuf(&self, chunk_info: &ChunkInfo) -> services::TransactionBody {
        assert!(self.is_frozen());
        let data = self.body.data.to_transaction_data_protobuf(chunk_info);

        let transaction_fee = if self.body.data.for_cost_estimate() {
            0
        } else {
            self.body
                .max_transaction_fee
                .unwrap_or_else(|| self.body.data.default_max_transaction_fee())
                .to_tinybars() as u64
        };

        services::TransactionBody {
            data: Some(data),
            transaction_id: Some(chunk_info.current_transaction_id.to_protobuf()),
            transaction_valid_duration: Some(
                self.body
                    .transaction_valid_duration
                    .unwrap_or(DEFAULT_TRANSACTION_VALID_DURATION)
                    .into(),
            ),
            memo: self.body.transaction_memo.clone(),
            node_account_id: Some(chunk_info.node_account_id.to_protobuf()),
            generate_record: false,
            transaction_fee,
            max_custom_fees: vec![],
        }
    }
}

// fixme: find a better name.
pub(crate) struct SourceTransaction<'a, D> {
    inner: &'a Transaction<D>,
    sources: Cow<'a, TransactionSources>,
}

impl<'a, D> SourceTransaction<'a, D> {
    pub(crate) fn new(transaction: &'a Transaction<D>, sources: &'a TransactionSources) -> Self {
        // fixme: be way more lazy.
        let sources = sources.sign_with(&transaction.signers);

        Self { inner: transaction, sources }
    }

    pub(crate) async fn execute(
        &self,
        client: &Client,
        timeout: Option<std::time::Duration>,
    ) -> crate::Result<TransactionResponse>
    where
        D: TransactionExecute,
    {
        Ok(self.execute_all(client, timeout).await?.swap_remove(0))
    }

    pub(crate) async fn execute_all(
        &self,
        client: &Client,
        timeout_per_chunk: Option<std::time::Duration>,
    ) -> crate::Result<Vec<TransactionResponse>>
    where
        D: TransactionExecute,
    {
        let mut responses = Vec::with_capacity(self.sources.chunks_len());
        for chunk in self.sources.chunks() {
            let response = crate::execute::execute(
                client,
                &SourceTransactionExecuteView::new(self.inner, chunk),
                timeout_per_chunk,
            )
            .await?;

            if self.inner.data().wait_for_receipt() {
                response.get_receipt(client).await?;
            }

            responses.push(response);
        }

        Ok(responses)
    }
}

// fixme: better name.
struct SourceTransactionExecuteView<'a, D> {
    transaction: &'a Transaction<D>,
    chunk: SourceChunk<'a>,
    indecies_by_node_id: HashMap<AccountId, usize>,
}

impl<'a, D> SourceTransactionExecuteView<'a, D> {
    fn new(transaction: &'a Transaction<D>, chunk: SourceChunk<'a>) -> Self {
        let indecies_by_node_id =
            chunk.node_ids().iter().copied().enumerate().map(|it| (it.1, it.0)).collect();
        Self { transaction, chunk, indecies_by_node_id }
    }
}

impl<'a, D: ValidateChecksums> ValidateChecksums for SourceTransactionExecuteView<'a, D> {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.transaction.validate_checksums(ledger_id)
    }
}

impl<'a, D: TransactionExecute> Execute for SourceTransactionExecuteView<'a, D> {
    type GrpcRequest = <Transaction<D> as Execute>::GrpcRequest;

    type GrpcResponse = <Transaction<D> as Execute>::GrpcResponse;

    type Context = <Transaction<D> as Execute>::Context;

    type Response = <Transaction<D> as Execute>::Response;

    fn node_account_ids(&self) -> Option<&[AccountId]> {
        Some(self.chunk.node_ids())
    }

    fn transaction_id(&self) -> Option<TransactionId> {
        Some(self.chunk.transaction_id())
    }

    fn requires_transaction_id(&self) -> bool {
        true
    }

    fn operator_account_id(&self) -> Option<&AccountId> {
        None
    }

    fn regenerate_transaction_id(&self) -> Option<bool> {
        Some(false)
    }

    fn make_request(
        &self,
        transaction_id: Option<&TransactionId>,
        node_account_id: AccountId,
    ) -> crate::Result<(Self::GrpcRequest, Self::Context)> {
        debug_assert_eq!(transaction_id, self.transaction_id().as_ref());

        let index = *self.indecies_by_node_id.get(&node_account_id).unwrap();
        Ok((self.chunk.transactions()[index].clone(), self.chunk.transaction_hashes()[index]))
    }

    fn execute(
        &self,
        channel: Channel,
        request: Self::GrpcRequest,
    ) -> BoxGrpcFuture<Self::GrpcResponse> {
        self.transaction.execute(channel, request)
    }

    fn make_response(
        &self,
        response: Self::GrpcResponse,
        context: Self::Context,
        node_account_id: AccountId,
        transaction_id: Option<&TransactionId>,
    ) -> crate::Result<Self::Response> {
        self.transaction.make_response(response, context, node_account_id, transaction_id)
    }

    fn make_error_pre_check(
        &self,
        status: crate::Status,
        transaction_id: Option<&TransactionId>,
        response: Self::GrpcResponse,
    ) -> crate::Error {
        self.transaction.make_error_pre_check(status, transaction_id, response)
    }

    fn response_pre_check_status(response: &Self::GrpcResponse) -> crate::Result<i32> {
        Transaction::<D>::response_pre_check_status(response)
    }
}
// Filename: src/transaction/mod.rs
// SPDX-License-Identifier: Apache-2.0

use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt;
use std::fmt::{
    Debug,
    Formatter,
};
use std::num::NonZeroUsize;

use hedera_proto::services;
use prost::Message;
use time::Duration;
use triomphe::Arc;

use crate::custom_fee_limit::CustomFeeLimit;
use crate::downcast::DowncastOwned;
use crate::execute::execute;
use crate::signer::AnySigner;
use crate::{
    AccountId,
    Client,
    Error,
    Hbar,
    Operator,
    PrivateKey,
    PublicKey,
    ScheduleCreateTransaction,
    TransactionHash,
    TransactionId,
    TransactionResponse,
    ValidateChecksums,
};

mod any;
mod chunked;
mod cost;
mod execute;
mod protobuf;
mod source;
#[cfg(test)]
mod tests;

pub use any::AnyTransaction;
pub(crate) use any::AnyTransactionData;
pub(crate) use chunked::{
    ChunkData,
    ChunkInfo,
    ChunkedTransactionData,
};
pub(crate) use cost::CostTransaction;
pub(crate) use execute::{
    TransactionData,
    TransactionExecute,
    TransactionExecuteChunked,
};
pub(crate) use protobuf::{
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
};
pub(crate) use source::TransactionSources;

const DEFAULT_TRANSACTION_VALID_DURATION: Duration = Duration::seconds(120);

/// A transaction that can be executed on the Hiero network.
#[derive(Clone)]
pub struct Transaction<D> {
    body: TransactionBody<D>,

    signers: Vec<AnySigner>,

    sources: Option<TransactionSources>,
}

#[derive(Debug, Default, Clone)]
pub(crate) struct TransactionBody<D> {
    pub(crate) data: D,

    pub(crate) node_account_ids: Option<Vec<AccountId>>,

    pub(crate) transaction_valid_duration: Option<Duration>,

    pub(crate) max_transaction_fee: Option<Hbar>,

    pub(crate) transaction_memo: String,

    pub(crate) transaction_id: Option<TransactionId>,

    pub(crate) operator: Option<Arc<Operator>>,

    pub(crate) is_frozen: bool,

    pub(crate) regenerate_transaction_id: Option<bool>,

    /// The maximum custom fee that the user is willing to pay for the message.
    /// If left empty, the user is willing to pay any custom fee.
    /// If used with a transaction type that does not support custom fee limits, the transaction will fail.
    pub(crate) custom_fee_limits: Vec<CustomFeeLimit>,
}

impl<D> Default for Transaction<D>
where
    D: Default,
{
    fn default() -> Self {
        Self {
            body: TransactionBody {
                data: D::default(),
                node_account_ids: None,
                transaction_valid_duration: None,
                max_transaction_fee: None,
                transaction_memo: String::new(),
                transaction_id: None,
                operator: None,
                is_frozen: false,
                regenerate_transaction_id: None,
                custom_fee_limits: Vec::new(),
            },
            signers: Vec::new(),
            sources: None,
        }
    }
}

impl<D> Debug for Transaction<D>
where
    D: Debug,
{
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_struct("Transaction").field("body", &self.body).finish()
    }
}

impl<D> Transaction<D>
where
    D: Default,
{
    /// Create a new default transaction.
    ///
    /// Does the same thing as [`default`](Self::default)
    #[inline]
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }
}

impl<D> Transaction<D> {
    pub(crate) fn from_parts(body: TransactionBody<D>, signers: Vec<AnySigner>) -> Self {
        Self { body, signers, sources: None }
    }

    pub(crate) fn is_frozen(&self) -> bool {
        self.body.is_frozen
    }

    pub(crate) fn signers(&self) -> impl Iterator<Item = &AnySigner> {
        self.signers.iter()
    }

    pub(crate) fn sources(&self) -> Option<&TransactionSources> {
        self.sources.as_ref()
    }

    fn signed_sources(&self) -> Option<Cow<'_, TransactionSources>> {
        self.sources().map(|it| it.sign_with(&self.signers))
    }

    /// # Panics
    /// If `self.is_frozen()`.
    #[track_caller]
    pub(crate) fn require_not_frozen(&self) {
        assert!(
            !self.is_frozen(),
            "transaction is immutable; it has at least one signature or has been explicitly frozen"
        );
    }

    /// # Panics
    /// If `self.is_frozen()`.
    pub(crate) fn body_mut(&mut self) -> &mut TransactionBody<D> {
        self.require_not_frozen();
        &mut self.body
    }

    pub(crate) fn into_body(self) -> TransactionBody<D> {
        self.body
    }

    #[inline(always)]
    pub(crate) fn data(&self) -> &D {
        &self.body.data
    }

    /// # Panics
    /// If `self.is_frozen()`.
    pub(crate) fn data_mut(&mut self) -> &mut D {
        self.require_not_frozen();
        &mut self.body.data
    }

    /// Returns the account IDs of the nodes that this transaction may be submitted to.
    ///
    /// `None` means any node configured on the client.
    #[must_use]
    pub fn get_node_account_ids(&self) -> Option<&[AccountId]> {
        self.body.node_account_ids.as_deref()
    }

    /// Sets the account IDs of the nodes that this transaction may be submitted to.
    ///
    /// Defaults to the full list of nodes configured on the client.
    #[track_caller]
    pub fn node_account_ids(&mut self, ids: impl IntoIterator<Item = AccountId>) -> &mut Self {
        let nodes: Vec<_> = ids.into_iter().collect();

        if nodes.is_empty() {
            log::warn!("Nodes list is empty, ignoring setter");
        } else {
            self.body_mut().node_account_ids = Some(nodes);
        }

        self
    }

    /// Returns the duration that this transaction is valid for, once finalized and signed.
    #[must_use]
    pub fn get_transaction_valid_duration(&self) -> Option<Duration> {
        self.body.transaction_valid_duration
    }

    /// Sets the duration that this transaction is valid for, once finalized and signed.
    ///
    /// Defaults to 120 seconds (or two minutes).
    pub fn transaction_valid_duration(&mut self, duration: Duration) -> &mut Self {
        self.body_mut().transaction_valid_duration = Some(duration);
        self
    }

    /// Returns the maximum transaction fee the paying account is willing to pay.
    #[must_use]
    pub fn get_max_transaction_fee(&self) -> Option<Hbar> {
        self.body.max_transaction_fee
    }

    /// Sets the maximum transaction fee the paying account is willing to pay.
    pub fn max_transaction_fee(&mut self, fee: Hbar) -> &mut Self {
        self.body_mut().max_transaction_fee = Some(fee);
        self
    }

    /// Returns the custom fee limits for the transaction.
    #[must_use]
    pub fn get_custom_fee_limits(&self) -> &[CustomFeeLimit] {
        &self.body.custom_fee_limits
    }

    /// Sets the custom fee limits for the transaction.
    pub fn custom_fee_limits(
        &mut self,
        limits: impl IntoIterator<Item = CustomFeeLimit>,
    ) -> &mut Self {
        self.body_mut().custom_fee_limits = limits.into_iter().collect();
        self
    }

    /// Adds a custom fee limit to the transaction.
    pub fn add_custom_fee_limit(&mut self, limit: CustomFeeLimit) -> &mut Self {
        self.body_mut().custom_fee_limits.push(limit);
        self
    }

    /// Removes all custom fee limits for the transaction.
    pub fn clear_custom_fee_limits(&mut self) -> &mut Self {
        self.body_mut().custom_fee_limits.clear();
        self
    }

    /// Sets a note / description that should be recorded in the transaction record.
    ///
    /// Maximum length of 100 characters.
    #[must_use]
    pub fn get_transaction_memo(&self) -> &str {
        &self.body.transaction_memo
    }

    /// Sets a note or description that should be recorded in the transaction record.
    ///
    /// Maximum length of 100 characters.
    pub fn transaction_memo(&mut self, memo: impl AsRef<str>) -> &mut Self {
        self.body_mut().transaction_memo = memo.as_ref().to_owned();
        self
    }

    /// Returns the explicit transaction ID to use to identify this transaction.
    ///
    /// Overrides the payer account defined on this transaction or on the client.
    #[must_use]
    pub fn get_transaction_id(&self) -> Option<TransactionId> {
        self.body.transaction_id
    }

    /// Sets an explicit transaction ID to use to identify this transaction.
    ///
    /// Overrides the payer account defined on this transaction or on the client.
    pub fn transaction_id(&mut self, id: TransactionId) -> &mut Self {
        self.body_mut().transaction_id = Some(id);
        self
    }

    /// Sign the transaction.
    pub fn sign(&mut self, private_key: PrivateKey) -> &mut Self {
        self.sign_signer(AnySigner::PrivateKey(private_key))
    }

    /// Sign the transaction.
    pub fn sign_with<F: Fn(&[u8]) -> Vec<u8> + Send + Sync + 'static>(
        &mut self,
        public_key: PublicKey,
        signer: F,
    ) -> &mut Self {
        self.sign_signer(AnySigner::arbitrary(Box::new(public_key), signer))
    }

    pub(crate) fn sign_signer(&mut self, signer: AnySigner) -> &mut Self {
        // We're _supposed_ to require frozen here, but really there's no reason I can think of to do that.

        // skip the signer if we already have it.
        if self.signers.iter().any(|it| it.public_key() == signer.public_key()) {
            return self;
        }

        self.signers.push(signer);
        self
    }
}

impl<D: ChunkedTransactionData> Transaction<D> {
    /// Returns the maximum number of chunks this transaction will be split into.
    #[must_use]
    pub fn get_max_chunks(&self) -> usize {
        self.data().chunk_data().max_chunks
    }

    /// Sets the maximum number of chunks this transaction will be split into.
    pub fn max_chunks(&mut self, max_chunks: usize) -> &mut Self {
        self.data_mut().chunk_data_mut().max_chunks = max_chunks;

        self
    }

    // todo: just return a `NonZeroUsize` instead? Take something along the lines of a `u32`?
    /// Returns the maximum size of any chunk.
    pub fn get_chunk_size(&self) -> usize {
        self.data().chunk_data().chunk_size.get()
    }

    // todo: just take a `NonZeroUsize` instead? Take something along the lines of a `u32`?
    /// Sets the maximum size of any chunk.
    ///
    /// # Panics
    /// If `size` == 0
    pub fn chunk_size(&mut self, size: usize) -> &mut Self {
        let Some(size) = NonZeroUsize::new(size) else { panic!("Cannot set chunk-size to zero") };

        self.data_mut().chunk_data_mut().chunk_size = size;

        self
    }

    /// Returns whether or not the transaction ID should be refreshed if a [`Status::TransactionExpired`](crate::Status::TransactionExpired) occurs.
    ///
    /// By default, the value on Client will be used.
    ///
    /// Note: Some operations forcibly disable transaction ID regeneration, such as setting the transaction ID explicitly.
    pub fn get_regenerate_transaction_id(&self) -> Option<bool> {
        self.body.regenerate_transaction_id
    }

    /// Sets whether or not the transaction ID should be refreshed if a [`Status::TransactionExpired`](crate::Status::TransactionExpired) occurs.
    ///
    /// Various operations such as [`add_signature`](Self::add_signature) can forcibly disable transaction ID regeneration.
    pub fn regenerate_transaction_id(&mut self, regenerate_transaction_id: bool) -> &mut Self {
        self.body_mut().regenerate_transaction_id = Some(regenerate_transaction_id);

        self
    }
}

impl<D: ValidateChecksums> Transaction<D> {
    /// Freeze the transaction so that no further modifications can be made.
    ///
    /// # Errors
    /// - [`Error::FreezeUnsetNodeAccountIds`] if no [`node_account_ids`](Self::node_account_ids) were set.
    ///
    /// # Panics
    /// - If `node_account_ids` is explicitly set to empty (IE: `tx.node_account_ids([]).freeze_with(None)`).
    pub fn freeze(&mut self) -> crate::Result<&mut Self> {
        self.freeze_with(None)
    }

    /// Freeze the transaction so that no further modifications can be made.
    ///
    /// # Errors
    /// - [`Error::FreezeUnsetNodeAccountIds`] if no [`node_account_ids`](Self::node_account_ids) were set and `client.is_none()`.
    ///
    /// # Panics
    /// - If `node_account_ids` is explicitly set to empty (IE: `tx.node_account_ids([]).freeze_with(None)`).
    pub fn freeze_with<'a>(
        &mut self,
        client: impl Into<Option<&'a Client>>,
    ) -> crate::Result<&mut Self> {
        if self.is_frozen() {
            return Ok(self);
        }
        let client: Option<&Client> = client.into();

        let node_account_ids = match &self.body.node_account_ids {
            // the clone here is the lesser of two evils.
            Some(it) => {
                assert!(!it.is_empty());
                it.clone()
            }
            #[allow(clippy::missing_panics_doc)]
            None => {
                let nodes = client
                    .ok_or(Error::FreezeUnsetNodeAccountIds)?
                    .net()
                    .0
                    .load()
                    .random_node_ids();
                assert!(!nodes.is_empty(), "BUG: Client didn't give any nodes (all unhealthy)");

                nodes
            }
        };

        // note to reviewer: this is intentionally still an option, fallback is used later, swift doesn't *have* default max transaction fee and fixing it is a massive PITA.
        let max_transaction_fee = self.body.max_transaction_fee.or_else(|| {
            // no max has been set on the *transaction*
            // check if there is a global max set on the client
            client.and_then(Client::default_max_transaction_fee)
        });

        let custom_fee_limits = self.body.custom_fee_limits.clone();

        let operator = client.and_then(Client::full_load_operator);

        // note: yes, there's an `Some(opt.unwrap())`, this is INTENTIONAL.
        self.body.node_account_ids = Some(node_account_ids);
        self.body.max_transaction_fee = max_transaction_fee;
        self.body.operator = operator;
        self.body.is_frozen = true;
        self.body.custom_fee_limits = custom_fee_limits;

        if let Some(client) = client {
            if client.auto_validate_checksums() {
                let ledger_id = client.ledger_id_internal();
                let ledger_id = ledger_id
                    .as_ref()
                    .expect("Client had auto_validate_checksums enabled but no ledger ID");

                self.validate_checksums(ledger_id.as_ref_ledger_id())?;
            }
        }

        Ok(self)
    }

    /// Sign the transaction with the `client`'s operator.
    ///
    /// # Errors
    /// - If [`freeze_with`](Self::freeze_with) would error for this transaction.
    ///
    /// # Panics
    /// If `client` has no operator.
    pub fn sign_with_operator(&mut self, client: &Client) -> crate::Result<&mut Self> {
        let Some(op) = client.full_load_operator() else { panic!("Client had no operator") };

        self.freeze_with(client)?;

        self.sign_signer(op.signer.clone());

        self.body.operator = Some(op);

        Ok(self)
    }
}

impl<D: TransactionExecute> Transaction<D> {
    /// # Errors
    /// - If the transaction needs multiple chunks, or has no explicit transaction ID *and* `self.operator` is not set.
    ///
    /// # Panics
    /// - If `!self.is_frozen()`
    fn make_transaction_list(&self) -> crate::Result<Vec<services::Transaction>> {
        assert!(self.is_frozen());

        let operator = || self.body.operator.as_ref().ok_or(Error::NoPayerAccountOrTransactionId);

        // todo: fix this with chunked transactions.
        let initial_transaction_id = match self.get_transaction_id() {
            Some(id) => id,
            None => operator()?.generate_transaction_id(),
        };

        let used_chunks = self.data().maybe_chunk_data().map_or(1, ChunkData::used_chunks);
        let node_account_ids = self.body.node_account_ids.as_deref().unwrap();

        let mut transaction_list = Vec::with_capacity(used_chunks * node_account_ids.len());

        // Note: This ordering is *important*,
        // there's no documentation for it but `TransactionList` is sorted by chunk number,
        // then `node_id` (in the order they were added to the transaction)
        for chunk in 0..used_chunks {
            let current_transaction_id = match chunk {
                0 => initial_transaction_id,
                _ => operator()?.generate_transaction_id(),
            };

            for node_account_id in node_account_ids.iter().copied() {
                let chunk_info = ChunkInfo {
                    current: chunk,
                    total: used_chunks,
                    initial_transaction_id,
                    current_transaction_id,
                    node_account_id,
                };

                transaction_list.push(self.make_request_inner(&chunk_info).0);
            }
        }

        Ok(transaction_list)
    }

    pub(crate) fn make_sources(&self) -> crate::Result<Cow<'_, TransactionSources>> {
        assert!(self.is_frozen());

        if let Some(sources) = self.signed_sources() {
            return Ok(sources);
        }

        return Ok(Cow::Owned(TransactionSources::new(self.make_transaction_list()?).unwrap()));
    }

    /// Convert `self` to protobuf encoded bytes.
    ///
    /// # Errors
    /// - If `freeze_with` wasn't called with an operator.
    ///
    /// # Panics
    /// - If `!self.is_frozen()`.
    pub fn to_bytes(&self) -> crate::Result<Vec<u8>> {
        assert!(self.is_frozen(), "Transaction must be frozen to call `to_bytes`");

        let transaction_list = self
            .signed_sources()
            .map_or_else(|| self.make_transaction_list(), |it| Ok(it.transactions().to_vec()))?;

        Ok(hedera_proto::sdk::TransactionList { transaction_list }.encode_to_vec())
    }

    pub(crate) fn add_signature_signer(&mut self, signer: &AnySigner) -> Vec<u8> {
        assert!(self.is_frozen());

        // note: the following pair of cheecks are for more detailed panic messages
        // IE, they should *hopefully* be tripped first
        assert_eq!(
            self.body.node_account_ids.as_deref().map_or(0, <[AccountId]>::len),
            1,
            "cannot manually add a signature to a transaction with multiple nodes"
        );

        if let Some(chunk_data) = self.data().maybe_chunk_data() {
            assert!(
                chunk_data.used_chunks() <= 1,
                "cannot manually add a signature to a chunked transaction with multiple chunks (message length `{}` > chunk size `{}`)",
                chunk_data.data.len(),
                chunk_data.chunk_size
            );
        }

        let sources = self.make_sources().unwrap();

        // this is the only check that is for correctness rather than debugability.
        assert!(sources.transactions().len() == 1);

        let sources = sources.sign_with(std::slice::from_ref(signer));

        // hack: I don't care about perf here.
        let ret = signer.sign(&sources.signed_transactions()[0].body_bytes);

        // if we have a `Cow::Borrowed` that'd mean there was no modification
        if let Cow::Owned(sources) = sources {
            self.sources = Some(sources);
        }

        ret.1
    }

    // todo: should this return `Result<&mut Self>`?
    /// Adds a signature directly to `self`.
    ///
    /// Only use this as a last resort.
    ///
    /// This forcibly disables transaction ID regeneration.
    pub fn add_signature(&mut self, pk: PublicKey, signature: Vec<u8>) -> &mut Self {
        self.add_signature_signer(&AnySigner::arbitrary(Box::new(pk), move |_| signature.clone()));

        self
    }

    /// # Panics
    /// panics if the transaction is not schedulable, a transaction can be non-schedulable due to:
    /// - if `self.is_frozen`
    /// - being a transaction kind that's non-schedulable, IE, `EthereumTransaction`, or
    /// - being a chunked transaction with multiple chunks.
    pub fn schedule(self) -> ScheduleCreateTransaction {
        self.require_not_frozen();
        assert!(self.get_node_account_ids().is_none(), "The underlying transaction for a scheduled transaction cannot have node account IDs set");

        let mut transaction = ScheduleCreateTransaction::new();

        if let Some(transaction_id) = self.get_transaction_id() {
            transaction.transaction_id(transaction_id);
        }

        transaction.scheduled_transaction(self);

        transaction
    }

    /// Get the hash for this transaction.
    ///
    /// Note: Calling this function _disables_ transaction ID regeneration.
    ///
    /// # Errors
    /// - [`Error::NoPayerAccountOrTransactionId`]
    ///     if `freeze_with` wasn't called with an operator and no transaction ID was set.
    ///
    /// # Panics
    /// - If `!self.is_frozen()`.
    pub fn get_transaction_hash(&mut self) -> crate::Result<TransactionHash> {
        // todo: error not frozen
        assert!(
            self.is_frozen(),
            "Transaction must be frozen before calling `get_transaction_hash`"
        );

        let sources = self.make_sources()?;

        let sources = match sources {
            Cow::Borrowed(it) => it,
            Cow::Owned(it) => &*self.sources.insert(it),
        };

        Ok(TransactionHash::new(&sources.transactions().first().unwrap().signed_transaction_bytes))
    }

    /// Get the hashes for this transaction.
    ///
    /// Note: Calling this function _disables_ transaction ID regeneration.
    ///
    /// # Errors
    /// - [`Error::NoPayerAccountOrTransactionId`]
    ///     if `freeze_with` wasn't called with an operator and no transaction ID was set.
    ///
    /// # Panics
    /// - If `!self.is_frozen()`.
    pub fn get_transaction_hash_per_node(
        &mut self,
    ) -> crate::Result<HashMap<AccountId, TransactionHash>> {
        // todo: error not frozen
        assert!(
            self.is_frozen(),
            "Transaction must be frozen before calling `get_transaction_hash`"
        );

        let sources = self.make_sources()?;

        let chunk = sources.chunks().next().unwrap();

        let iter = chunk
            .node_ids()
            .iter()
            .zip(chunk.transactions())
            .map(|(node, it)| (*node, TransactionHash::new(&it.signed_transaction_bytes)));

        Ok(iter.collect())
    }
}

impl<D> Transaction<D>
where
    D: TransactionData,
{
    /// Returns the maximum allowed transaction fee if none is specified.
    ///
    /// Specifically, this default will be used in the following case:
    /// - The transaction itself (direct user input) has no `max_transaction_fee` specified, AND
    /// - The [`Client`](Client) has no `max_transaction_fee` specified.
    ///
    /// Currently this is (but not guaranteed to be) `2 ` for most transaction types.
    pub fn default_max_transaction_fee(&self) -> Hbar {
        self.data().default_max_transaction_fee()
    }
}

impl<D> Transaction<D>
where
    D: TransactionExecute,
{
    /// Get the estimated transaction cost for this transaction.
    pub async fn get_cost(&self, client: &Client) -> crate::Result<Hbar> {
        let result = CostTransaction::from_transaction(self).execute(client).await;

        match result {
            Ok(response) => {
                // unexpected response from Hiero, expecting to receive an `InsufficientTxFee` but received `Ok`
                return Err(Error::TransactionPreCheckStatus {
                    cost: None,
                    status: services::ResponseCodeEnum::Ok,
                    transaction_id: Box::new(response.transaction_id),
                });
            }

            Err(Error::TransactionPreCheckStatus { status, cost: Some(cost), .. })
                if status == services::ResponseCodeEnum::InsufficientTxFee =>
            {
                return Ok(cost);
            }

            Err(error) => Err(error),
        }
    }

    /// Execute this transaction against the provided client of the Hiero network.
    pub async fn execute(&mut self, client: &Client) -> crate::Result<TransactionResponse> {
        self.execute_with_optional_timeout(client, None).await
    }

    pub(crate) async fn execute_with_optional_timeout(
        &mut self,
        client: &Client,
        timeout: Option<std::time::Duration>,
    ) -> crate::Result<TransactionResponse> {
        // it's fine to call freeze while already frozen, so, let `freeze_with` handle the freeze check.
        self.freeze_with(Some(client))?;

        if let Some(sources) = self.sources() {
            return self::execute::SourceTransaction::new(self, sources)
                .execute(client, timeout)
                .await;
        }

        if let Some(chunk_data) = self.data().maybe_chunk_data() {
            // todo: log a warning: user actually wanted `execute_all`.
            // instead of `panic`king we just pretend we were `execute_all` and
            // return the first result (*after* executing all the transactions).
            return self
                .execute_all_inner(chunk_data, client, timeout)
                .await
                .map(|mut it| it.swap_remove(0));
        }

        execute(client, self, timeout).await
    }

    // this is in *this* impl block rather than the `: TransactionExecuteChunked` impl block
    //because there's the off chance that someone calls `execute` on a Transaction that wants `execute_all`...
    async fn execute_all_inner(
        &self,
        chunk_data: &ChunkData,
        client: &Client,
        timeout_per_chunk: Option<std::time::Duration>,
    ) -> crate::Result<Vec<TransactionResponse>> {
        assert!(self.is_frozen());

        let wait_for_receipts = self.data().wait_for_receipt();

        // fixme: error with an actual error.
        #[allow(clippy::manual_assert)]
        if chunk_data.data.len() > chunk_data.max_message_len() {
            todo!("error: message too big")
        }

        let used_chunks = chunk_data.used_chunks();

        let mut responses = Vec::with_capacity(chunk_data.used_chunks());

        let initial_transaction_id = {
            let resp = execute(
                client,
                &chunked::FirstChunkView { transaction: self, total_chunks: used_chunks },
                timeout_per_chunk,
            )
            .await?;

            if wait_for_receipts {
                resp.get_receipt_query()
                    .execute_with_optional_timeout(client, timeout_per_chunk)
                    .await?;
            }

            let initial_transaction_id = resp.transaction_id;
            responses.push(resp);

            initial_transaction_id
        };

        for chunk in 1..used_chunks {
            let resp = execute(
                client,
                &chunked::ChunkView {
                    transaction: self,
                    initial_transaction_id,
                    current_chunk: chunk,
                    total_chunks: used_chunks,
                },
                timeout_per_chunk,
            )
            .await?;

            if wait_for_receipts {
                resp.get_receipt_query()
                    .execute_with_optional_timeout(client, timeout_per_chunk)
                    .await?;
            }

            responses.push(resp);
        }

        Ok(responses)
    }

    /// Execute this transaction against the provided client of the Hiero network.
    // todo:
    #[allow(clippy::missing_errors_doc)]
    pub async fn execute_with_timeout(
        &mut self,
        client: &Client,
        // fixme: be consistent with `time::Duration`? Except `tokio::time` is `std::time`, and we depend on tokio.
        timeout: std::time::Duration,
    ) -> crate::Result<TransactionResponse> {
        self.execute_with_optional_timeout(client, Some(timeout)).await
    }
}

impl<D> Transaction<D>
where
    D: TransactionExecuteChunked,
{
    /// Execute all transactions against the provided client of the Hiero network.
    pub async fn execute_all(
        &mut self,
        client: &Client,
    ) -> crate::Result<Vec<TransactionResponse>> {
        self.execute_all_with_optional_timeout(client, None).await
    }

    pub(crate) async fn execute_all_with_optional_timeout(
        &mut self,
        client: &Client,
        timeout_per_chunk: Option<std::time::Duration>,
    ) -> crate::Result<Vec<TransactionResponse>> {
        // it's fine to call freeze while already frozen, so, let `freeze_with` handle the freeze check.
        self.freeze_with(Some(client))?;

        // fixme: dedup this with `execute_with_optional_timeout`
        if let Some(sources) = self.sources() {
            return self::execute::SourceTransaction::new(self, sources)
                .execute_all(client, timeout_per_chunk)
                .await;
        }

        // sorry for the mess: this can technically infinite loop
        // (it won't, the loop condition would be dependent on chunk_data somehow being `Some` and `None` at the same time).
        let Some(chunk_data) = self.data().maybe_chunk_data() else {
            return Ok(Vec::from([self
                .execute_with_optional_timeout(client, timeout_per_chunk)
                .await?]));
        };

        self.execute_all_inner(chunk_data, client, timeout_per_chunk).await
    }
}

// these impls are on `AnyTransaction`, but they're here instead of in `any` because actually implementing them is only possible here.
impl AnyTransaction {
    /// # Examples
    /// ```
    /// # fn main() -> hedera::Result<()> {
    /// use hedera::AnyTransaction;
    /// let bytes = hex::decode(concat!(
    ///     "0a522a500a4c0a120a0c0885c8879e0610a8bdd9840312021865120218061880",
    ///     "94ebdc0322020877320c686920686173686772617068721a0a180a0a0a021802",
    ///     "108088debe010a0a0a02186510ff87debe0112000a522a500a4c0a120a0c0885",
    ///     "c8879e0610a8bdd984031202186512021807188094ebdc0322020877320c6869",
    ///     "20686173686772617068721a0a180a0a0a021802108088debe010a0a0a021865",
    ///     "10ff87debe011200"
    /// )).unwrap();
    /// let tx = AnyTransaction::from_bytes(&bytes)?;
    /// # let _ = tx;
    /// # Ok(())
    /// # }
    /// ```
    /// # Errors
    /// - [`Error::FromProtobuf`] if a valid transaction cannot be parsed from the bytes.
    #[allow(deprecated)]
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        let list =
            hedera_proto::sdk::TransactionList::decode(bytes).map_err(Error::from_protobuf)?;

        let list = if list.transaction_list.is_empty() {
            Vec::from([services::Transaction::decode(bytes).map_err(Error::from_protobuf)?])
        } else {
            list.transaction_list
        };

        let sources = TransactionSources::new(list)?;

        let transaction_bodies: Result<Vec<_>, _> = sources
            .signed_transactions()
            .iter()
            .map(|it| {
                services::TransactionBody::decode(&*it.body_bytes).map_err(Error::from_protobuf)
            })
            .collect();

        let transaction_bodies = transaction_bodies?;
        {
            let (first, transaction_bodies) = transaction_bodies
                .split_first()
                .ok_or_else(|| Error::from_protobuf("no transactions found"))?;

            for it in transaction_bodies {
                if !pb_transaction_body_eq(first, it) {
                    return Err(Error::from_protobuf("transaction parts unexpectedly unequal"));
                }
            }
        }

        // todo: reuse work
        let transaction_data = {
            let data: Result<_, _> = sources
                .chunks()
                .filter_map(|it| it.signed_transactions().first())
                .map(|it| {
                    services::TransactionBody::decode(&*it.body_bytes)
                        .map_err(Error::from_protobuf)
                        .and_then(|pb| pb_getf!(pb, data))
                })
                .collect();

            data?
        };

        // note: this creates the transaction in a frozen state.
        let mut res = Self::from_protobuf(transaction_bodies[0].clone(), transaction_data)?;

        // note: this doesn't check freeze for obvious reasons.
        res.body.node_account_ids = Some(sources.node_ids().to_vec());
        res.sources = Some(sources);

        Ok(res)
    }
}

/// Returns `true` if lhs == rhs other than `transaction_id` and `node_account_id`, `false` otherwise.
#[allow(deprecated)]
fn pb_transaction_body_eq(
    lhs: &services::TransactionBody,
    rhs: &services::TransactionBody,
) -> bool {
    // destructure one side to ensure we don't miss any fields.
    let services::TransactionBody {
        transaction_id: _,
        node_account_id: _,
        transaction_fee,
        transaction_valid_duration,
        generate_record,
        memo,
        data,
        max_custom_fees,
    } = rhs;

    if &lhs.transaction_fee != transaction_fee {
        return false;
    }

    if &lhs.transaction_valid_duration != transaction_valid_duration {
        return false;
    }

    if &lhs.generate_record != generate_record {
        return false;
    }

    if &lhs.memo != memo {
        return false;
    }

    if &lhs.max_custom_fees != max_custom_fees {
        return false;
    }

    match (&lhs.data, data) {
        (None, None) => {}
        (Some(lhs), Some(rhs)) => match (lhs, rhs) {
            (
                services::transaction_body::Data::ConsensusSubmitMessage(lhs),
                services::transaction_body::Data::ConsensusSubmitMessage(rhs),
            ) => {
                let services::ConsensusSubmitMessageTransactionBody {
                    topic_id,
                    message: _,
                    chunk_info,
                } = rhs;

                if &lhs.topic_id != topic_id {
                    return false;
                }

                match (lhs.chunk_info.as_ref(), chunk_info.as_ref()) {
                    (None, None) => {}
                    (Some(lhs), Some(rhs)) => {
                        let services::ConsensusMessageChunkInfo {
                            initial_transaction_id,
                            total,
                            number: _,
                        } = rhs;

                        if &lhs.initial_transaction_id != initial_transaction_id {
                            return false;
                        }

                        if &lhs.total != total {
                            return false;
                        }
                    }
                    (Some(_), None) | (None, Some(_)) => return false,
                }
            }
            (
                services::transaction_body::Data::FileAppend(lhs),
                services::transaction_body::Data::FileAppend(rhs),
            ) => {
                let services::FileAppendTransactionBody { file_id, contents: _ } = rhs;

                if &lhs.file_id != file_id {
                    return false;
                }
            }
            (_, _) if lhs != rhs => return false,
            _ => {}
        },
        (Some(_), None) | (None, Some(_)) => return false,
    }

    true
}

// note: This impl is why this has to be a trait (overlapping impls if `D == U` with TryFrom).
impl<D, U> DowncastOwned<Transaction<U>> for Transaction<D>
where
    D: DowncastOwned<U>,
{
    fn downcast_owned(self) -> Result<Transaction<U>, Self> {
        let Self { body, signers, sources } = self;
        let TransactionBody {
            data,
            node_account_ids,
            transaction_valid_duration,
            max_transaction_fee,
            transaction_memo,
            transaction_id,
            operator,
            is_frozen,
            regenerate_transaction_id,
            custom_fee_limits,
        } = body;

        // not a `map().map_err()` because ownership.
        match data.downcast_owned() {
            Ok(data) => Ok(Transaction {
                body: TransactionBody {
                    data,
                    node_account_ids,
                    transaction_valid_duration,
                    max_transaction_fee,
                    transaction_memo,
                    transaction_id,
                    operator,
                    is_frozen,
                    regenerate_transaction_id,
                    custom_fee_limits,
                },
                signers,
                sources,
            }),

            Err(data) => Err(Self {
                body: TransactionBody {
                    data,
                    node_account_ids,
                    transaction_valid_duration,
                    max_transaction_fee,
                    transaction_memo,
                    transaction_id,
                    operator,
                    is_frozen,
                    regenerate_transaction_id,
                    custom_fee_limits,
                },
                signers,
                sources,
            }),
        }
    }
}

#[cfg(test)]
pub(crate) mod test_helpers {
    use hedera_proto::services;
    use prost::Message;
    use time::{
        Duration,
        OffsetDateTime,
    };

    use super::TransactionExecute;
    use crate::protobuf::ToProtobuf;
    use crate::{
        AccountId,
        Hbar,
        NftId,
        PrivateKey,
        TokenId,
        Transaction,
        TransactionId,
    };

    impl<D: Default> Transaction<D> {
        // todo: bikeshed name, idc.
        /// Creates a transaction with some fields set to regular values to make serialization more regular.
        ///
        /// Currently the fields set are `node_account_ids`, `transaction_id`, and `max_transaction_fee`.
        /// Additionally the transaction is signed with 1 key.
        pub(crate) fn new_for_tests() -> Self {
            let mut tx = Self::new();

            tx.node_account_ids(TEST_NODE_ACCOUNT_IDS)
                .transaction_id(TEST_TX_ID)
                .max_transaction_fee(Hbar::new(2))
                .sign(unused_private_key());

            tx
        }
    }

    #[track_caller]
    pub(crate) fn transaction_body<D: TransactionExecute>(
        tx: Transaction<D>,
    ) -> services::TransactionBody {
        // if you're thinking "ghee, that sure is a silly way to get a transaction body" you aren't wrong.
        services::TransactionBody::decode(
            &*tx.make_sources().unwrap().signed_transactions()[0].body_bytes,
        )
        .unwrap()
    }

    #[track_caller]
    pub(crate) fn transaction_bodies<D: TransactionExecute>(
        tx: Transaction<D>,
    ) -> Vec<services::TransactionBody> {
        tx.make_sources()
            .unwrap()
            .signed_transactions()
            .iter()
            .map(|it| services::TransactionBody::decode(&*it.body_bytes).unwrap())
            .collect()
    }

    /// Checks the entire traknsaction body *other than* `data` and returns that.
    ///
    /// This is basically a boilerplate reducer, however, it failing means that [`Transaction::new_for_tests`] is probably buggy.
    pub(crate) fn check_body(body: services::TransactionBody) -> services::transaction_body::Data {
        #[allow(deprecated)]
        let services::TransactionBody {
            transaction_id,
            node_account_id,
            transaction_fee,
            transaction_valid_duration,
            generate_record,
            memo,
            data,
            max_custom_fees,
        } = body;

        let node_account_id = node_account_id.unwrap();

        assert_eq!(transaction_id, Some(TEST_TX_ID.to_protobuf()));

        assert!(TEST_NODE_ACCOUNT_IDS.iter().any(|it| it.to_protobuf() == node_account_id));

        assert_eq!(transaction_fee, Hbar::new(2).to_tinybars() as u64);
        assert_eq!(transaction_valid_duration, Some(services::Duration { seconds: 120 }));
        assert_eq!(generate_record, false);
        assert_eq!(memo, "");
        assert_eq!(max_custom_fees, vec![]);
        data.unwrap()
    }

    pub(crate) fn unused_private_key() -> PrivateKey {
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10".parse().unwrap()
    }

    pub(crate) const TEST_TOKEN_ID: TokenId = TokenId::new(1, 2, 3);

    pub(crate) const TEST_TOKEN_IDS: [TokenId; 3] =
        [TokenId::new(1, 2, 3), TokenId::new(2, 3, 4), TokenId::new(3, 4, 5)];

    pub(crate) const TEST_NFT_IDS: [NftId; 3] = [
        NftId { token_id: TokenId::new(4, 2, 3), serial: 1 },
        NftId { token_id: TokenId::new(4, 2, 4), serial: 2 },
        NftId { token_id: TokenId::new(4, 2, 5), serial: 3 },
    ];

    pub(crate) const TEST_ACCOUNT_ID: AccountId = AccountId::new(0, 0, 5006);

    pub(crate) const TEST_NODE_ACCOUNT_IDS: [AccountId; 2] =
        [AccountId::new(0, 0, 5005), AccountId::new(0, 0, 5006)];

    pub(crate) const TEST_TX_ID: TransactionId = TransactionId {
        account_id: TEST_ACCOUNT_ID,
        valid_start: VALID_START,
        nonce: None,
        scheduled: false,
    };

    pub(crate) const VALID_START: OffsetDateTime =
        OffsetDateTime::UNIX_EPOCH.saturating_add(Duration::seconds(1554158542));
}
// Filename: src/transaction/protobuf.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;

use super::chunked::ChunkInfo;

pub trait ToTransactionDataProtobuf: Send + Sync {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data;
}

pub trait ToSchedulableTransactionDataProtobuf: Send + Sync {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data;
}
// Filename: src/transaction/source.rs
// SPDX-License-Identifier: Apache-2.0

use std::borrow::Cow;
use std::ops::Range;

use hedera_proto::services;
use once_cell::sync::OnceCell;
use prost::Message;

use crate::protobuf::FromProtobuf;
use crate::signer::AnySigner;
use crate::{
    AccountId,
    Error,
    TransactionHash,
    TransactionId,
};

pub(crate) struct SourceChunk<'a> {
    map: &'a TransactionSources,
    index: usize,
}

impl<'a> SourceChunk<'a> {
    fn range(&self) -> Range<usize> {
        self.map.chunks[self.index].clone()
    }

    pub(crate) fn transaction_id(&self) -> TransactionId {
        self.map.transaction_ids[self.index]
    }

    pub(crate) fn transactions(&self) -> &'a [services::Transaction] {
        &self.map.transactions()[self.range()]
    }

    pub(crate) fn signed_transactions(&self) -> &'a [services::SignedTransaction] {
        &self.map.signed_transactions[self.range()]
    }

    /// Returns The node account IDs for this chunk.
    ///
    /// Note: Every chunk has the same node account IDs.
    pub(crate) fn node_ids(&self) -> &'a [AccountId] {
        &self.map.node_ids
    }

    pub(crate) fn transaction_hashes(&self) -> &'a [TransactionHash] {
        &self.map.transaction_hashes()[self.range()]
    }
}

#[derive(Default, Clone)]
pub struct TransactionSources {
    signed_transactions: Box<[services::SignedTransaction]>,

    transactions: OnceCell<Vec<services::Transaction>>,

    /// offset of each chunk into `transactions`/`signed_transactions`
    chunks: Vec<Range<usize>>,

    /// Ordered list of transaction IDs (1 per chunk)
    transaction_ids: Vec<TransactionId>,

    /// Ordered list of node account IDs (all per chunk, same ordering)
    node_ids: Vec<AccountId>,

    transaction_hashes: OnceCell<Vec<TransactionHash>>,
}

impl TransactionSources {
    pub(crate) fn new(transactions: Vec<services::Transaction>) -> crate::Result<Self> {
        if transactions.is_empty() {
            return Err(Error::from_protobuf("`TransactionList` had no transactions"));
        }

        let signed_transactions: Result<Vec<_>, _> = transactions
            .iter()
            .map(|transaction| {
                if !transaction.signed_transaction_bytes.is_empty() {
                    let tx =
                        services::SignedTransaction::decode(&*transaction.signed_transaction_bytes)
                            .map_err(Error::from_protobuf)?;

                    return Ok(tx);
                }

                Err(Error::from_protobuf("Transaction had no signed transaction bytes"))
            })
            .collect();

        let signed_transactions = signed_transactions?;

        // ensure all signers (if any) are consistent for all signed transactions.
        // this doesn't compare or validate the signatures,
        // instead it ensures that all signatures in the first signed transation exist in *all* transactions and none extra exist.
        {
            let mut iter = signed_transactions.iter().map(|it| {
                it.sig_map
                    .as_ref()
                    .map(|it| {
                        let mut tmp = it
                            .sig_pair
                            .iter()
                            .map(|it| it.pub_key_prefix.as_slice())
                            .collect::<Vec<_>>();

                        // sort to be generous about signature ordering.
                        tmp.sort();

                        tmp
                    })
                    .unwrap_or_default()
            });

            // this should always be `Some`, buuuut, we lose nothing by doing it this way.
            if let Some(first) = iter.next() {
                if iter.any(|sigs| first != sigs.as_slice()) {
                    return Err(Error::from_protobuf("Transaction has mismatched signatures"));
                }
            }
        }

        let transaction_info: Result<Vec<_>, _> = signed_transactions
            .iter()
            .map(|it| {
                services::TransactionBody::decode(it.body_bytes.as_slice())
                    .map_err(Error::from_protobuf)
                    .and_then(|body| {
                        Ok((
                            TransactionId::from_protobuf(pb_getf!(body, transaction_id)?)?,
                            AccountId::from_protobuf(pb_getf!(body, node_account_id)?)?,
                        ))
                    })
            })
            .collect();

        let transaction_info = transaction_info?;

        let (chunks, transaction_ids, node_ids) = {
            let mut current: Option<&TransactionId> = None;

            let chunk_starts =
                transaction_info.iter().enumerate().filter_map(move |(index, (id, _))| {
                    if current != Some(id) {
                        current = Some(id);

                        return Some(index);
                    }

                    None
                });

            let mut chunks = Vec::new();

            let mut previous_start = None;

            // the start of one chunk is the end of the previous one.
            for end in chunk_starts {
                let start = previous_start.replace(end);

                if let Some(start) = start {
                    chunks.push(start..end);
                }
            }

            if let Some(start) = previous_start {
                chunks.push(start..transaction_info.len());
            }

            let chunks = chunks;

            let mut transaction_ids = Vec::with_capacity(chunks.len());
            let mut node_ids: Vec<_> = Vec::new();

            for chunk in &chunks {
                if transaction_ids.contains(&transaction_info[chunk.start].0) {
                    return Err(Error::from_protobuf(
                        "duplicate transaction ID between chunked transaction chunks",
                    ));
                }

                transaction_ids.push(transaction_info[chunk.start].0);

                // else ifs acting on different kinds of conditions are
                // personally more confusing than having the extra layer of nesting.
                #[allow(clippy::collapsible_else_if)]
                if node_ids.is_empty() {
                    node_ids = transaction_info[chunk.clone()].iter().map(|it| it.1).collect();
                } else {
                    if node_ids.iter().ne(transaction_info[chunk.clone()].iter().map(|it| &it.1)) {
                        return Err(Error::from_protobuf(
                            "TransactionList has inconsistent node account IDs",
                        ));
                    }
                }
            }

            (chunks, transaction_ids, node_ids)
        };

        Ok(Self {
            signed_transactions: signed_transactions.into_boxed_slice(),
            transactions: OnceCell::with_value(transactions),
            chunks,
            transaction_ids,
            node_ids,
            transaction_hashes: OnceCell::new(),
        })
    }

    pub(crate) fn sign_with(&self, signers: &[AnySigner]) -> Cow<'_, Self> {
        if signers.is_empty() {
            return Cow::Borrowed(self);
        }

        let mut signed_transactions = Cow::Borrowed(&self.signed_transactions);

        for signer in signers {
            let pk = signer.public_key().to_bytes_raw();

            // we need the first signed transaction for its signature list so that we know if we need to skip a given signer.
            if signed_transactions
                .first()
                .as_ref()
                .and_then(|it| it.sig_map.as_ref())
                .map_or(false, |it| it.sig_pair.iter().any(|it| pk.starts_with(&it.pub_key_prefix)))
            {
                continue;
            }

            for tx in signed_transactions.to_mut().iter_mut() {
                let sig_map = tx.sig_map.get_or_insert_with(services::SignatureMap::default);
                // todo: reuse `pk_bytes` instead of re-serializing them.
                let sig_pair = super::execute::SignaturePair::from(signer.sign(&tx.body_bytes));

                sig_map.sig_pair.push(sig_pair.into_protobuf());
            }
        }

        match signed_transactions {
            // if it's still borrowed then no signatures have been added (all signers are duplicates).
            Cow::Borrowed(_) => Cow::Borrowed(self),
            Cow::Owned(signed_transactions) => Cow::Owned(Self {
                signed_transactions,
                transactions: OnceCell::new(),
                chunks: self.chunks.clone(),
                transaction_ids: self.transaction_ids.clone(),
                node_ids: self.node_ids.clone(),
                transaction_hashes: self.transaction_hashes.clone(),
            }),
        }
    }

    pub(crate) fn transactions(&self) -> &[services::Transaction] {
        self.transactions.get_or_init(|| {
            self.signed_transactions
                .iter()
                .map(|it| services::Transaction {
                    signed_transaction_bytes: it.encode_to_vec(),
                    ..Default::default()
                })
                .collect()
        })
    }

    pub(crate) fn signed_transactions(&self) -> &[services::SignedTransaction] {
        &self.signed_transactions
    }

    pub(super) fn chunks_len(&self) -> usize {
        self.chunks.len()
    }

    pub(super) fn chunks(&self) -> impl Iterator<Item = SourceChunk<'_>> {
        (0..self.chunks.len()).map(|index| SourceChunk { map: self, index })
    }

    pub(super) fn _transaction_ids(&self) -> &[TransactionId] {
        &self.transaction_ids
    }

    pub(super) fn node_ids(&self) -> &[AccountId] {
        &self.node_ids
    }

    fn transaction_hashes(&self) -> &[TransactionHash] {
        self.transaction_hashes.get_or_init(|| {
            self.signed_transactions.iter().map(|it| TransactionHash::new(&it.body_bytes)).collect()
        })
    }
}
// Filename: src/transaction/tests.rs
use std::collections::HashSet;

use assert_matches::assert_matches;
use hex_literal::hex;
use time::OffsetDateTime;

use crate::transaction::AnyTransactionData;
use crate::{
    AnyTransaction,
    Client,
    Hbar,
    PrivateKey,
    TopicMessageSubmitTransaction,
    TransactionId,
    TransferTransaction,
};

#[test]
fn to_bytes_from_bytes() -> crate::Result<()> {
    let mut tx = TransferTransaction::new();

    let bytes = tx
        .max_transaction_fee(Hbar::new(10))
        .transaction_valid_duration(time::Duration::seconds(119))
        .transaction_memo("hi hashgraph")
        .hbar_transfer(2.into(), Hbar::new(2))
        .hbar_transfer(101.into(), Hbar::new(-2))
        .transaction_id(TransactionId {
            account_id: 101.into(),
            valid_start: OffsetDateTime::now_utc(),
            nonce: None,
            scheduled: false,
        })
        .node_account_ids([6.into(), 7.into()])
        .freeze()?
        .to_bytes()?;

    let tx = tx;

    let lhs = tx.data();

    let tx2 = AnyTransaction::from_bytes(&bytes)?;

    let rhs = assert_matches!(tx2.data(), AnyTransactionData::Transfer(it) => it);

    assert_eq!(tx.get_max_transaction_fee(), tx2.get_max_transaction_fee());

    // note: they have *no* guaranteed order, so we have to convert to a `HashSet`...
    // `HashSet` makes this hard on us.
    {
        let lhs: Option<HashSet<_>> = tx.get_node_account_ids().map(|it| it.iter().collect());
        let rhs: Option<HashSet<_>> = tx2.get_node_account_ids().map(|it| it.iter().collect());
        assert_eq!(lhs, rhs);
    }

    assert_eq!(tx.get_transaction_id(), tx2.get_transaction_id());
    assert_eq!(tx.get_transaction_memo(), tx2.get_transaction_memo());
    assert_eq!(tx.get_transaction_valid_duration(), tx2.get_transaction_valid_duration());
    assert_eq!(lhs, rhs);
    assert!(tx2.sources.is_some());

    Ok(())
}

#[test]
fn from_bytes_sign_to_bytes() -> crate::Result<()> {
    let mut tx = TransferTransaction::new();

    let bytes = tx
        .max_transaction_fee(Hbar::new(10))
        .transaction_valid_duration(time::Duration::seconds(119))
        .transaction_memo("hi hashgraph")
        .hbar_transfer(2.into(), Hbar::new(2))
        .hbar_transfer(101.into(), Hbar::new(-2))
        .transaction_id(TransactionId {
            account_id: 101.into(),
            valid_start: OffsetDateTime::now_utc(),
            nonce: None,
            scheduled: false,
        })
        .node_account_ids([6.into(), 7.into()])
        .freeze()?
        .to_bytes()?;

    let mut tx2 = AnyTransaction::from_bytes(&bytes)?;

    tx2.sign(PrivateKey::from_bytes(&hex!("302e020100300506032b657004220420e40d4241d093b22910c78135e0501b137cd9205bbb9c0153c5adf2c65e7dc95a")).unwrap());

    let _bytes2 = tx2.to_bytes()?;

    // todo: check properties (but what properties?)

    Ok(())
}

#[tokio::test]
async fn chunked_to_from_bytes() -> crate::Result<()> {
    let client = Client::for_testnet();
    client.set_operator(0.into(), PrivateKey::generate_ed25519());

    let bytes = TopicMessageSubmitTransaction::new()
        .topic_id(314)
        .message(b"Hello, world!".to_vec())
        .chunk_size(8)
        .max_chunks(2)
        .transaction_id(TransactionId {
            account_id: 101.into(),
            valid_start: OffsetDateTime::now_utc(),
            nonce: None,
            scheduled: false,
        })
        .node_account_ids([6.into(), 7.into()])
        .freeze_with(&client)?
        .to_bytes()?;

    let _tx2 = AnyTransaction::from_bytes(&bytes)?;

    // todo: check properties

    Ok(())
}
// Filename: src/transaction_hash.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};

use sha2::{
    Digest,
    Sha384,
};

/// The client-generated SHA-384 hash of a transaction that was submitted.
///
/// This can be used to lookup the transaction in an explorer.
#[derive(Copy, Clone, Hash)]
pub struct TransactionHash(pub [u8; 48]);

impl TransactionHash {
    #[must_use]
    pub(crate) fn new(bytes: &[u8]) -> Self {
        Self(Sha384::digest(bytes).into())
    }
}

impl Debug for TransactionHash {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for TransactionHash {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.pad(&hex::encode(self.0))
    }
}
// Filename: src/transaction_id.rs
// SPDX-License-Identifier: Apache-2.0

use std::fmt::{
    self,
    Debug,
    Display,
    Formatter,
};
use std::str::FromStr;

use hedera_proto::services;
use rand::{
    thread_rng,
    Rng,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::ledger_id::RefLedgerId;
use crate::{
    AccountId,
    Error,
    FromProtobuf,
    ToProtobuf,
    ValidateChecksums,
};

/// The client-generated ID for a transaction.
///
/// This is used for retrieving receipts and records for a transaction, for appending to a file
/// right after creating it, for instantiating a smart contract with bytecode in a file just created,
/// and internally by the network for detecting when duplicate transactions are submitted.
///
#[derive(Clone, Copy, Eq, PartialEq, Hash)]
pub struct TransactionId {
    /// The account that pays for this transaction.
    pub account_id: AccountId,

    /// The time from when this transaction is valid.
    ///
    /// When a transaction is submitted there is additionally a
    /// [`valid_duration`](crate::Transaction::transaction_valid_duration) (defaults to 120s)
    /// and together they define a time window that a transaction may be processed in.
    pub valid_start: OffsetDateTime,

    /// Nonce for this transaction.
    pub nonce: Option<i32>,

    /// `true` if the transaction is `scheduled`.
    pub scheduled: bool,
}

impl TransactionId {
    /// Generates a new transaction ID for the given account ID.
    #[must_use]
    pub fn generate(account_id: AccountId) -> Self {
        let valid_start = OffsetDateTime::now_utc()
            - Duration::nanoseconds(thread_rng().gen_range(5_000_000_000..8_000_000_000));

        Self { account_id, valid_start, scheduled: false, nonce: None }
    }

    /// Create a new `TransactionId` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }
}

impl ValidateChecksums for TransactionId {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.account_id.validate_checksums(ledger_id)
    }
}

impl Debug for TransactionId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "\"{self}\"")
    }
}

impl Display for TransactionId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}@{}.{}{}{}",
            self.account_id,
            self.valid_start.unix_timestamp(),
            self.valid_start.nanosecond(),
            if self.scheduled { "?scheduled" } else { "" },
            // https://github.com/rust-lang/rust/issues/92698
            self.nonce.map(|nonce| format!("/{nonce}")).as_deref().unwrap_or_default()
        )
    }
}

impl FromProtobuf<services::TransactionId> for TransactionId {
    fn from_protobuf(pb: services::TransactionId) -> crate::Result<Self> {
        let account_id = pb_getf!(pb, account_id)?;
        let account_id = AccountId::from_protobuf(account_id)?;

        let valid_start = pb_getf!(pb, transaction_valid_start)?;

        Ok(Self {
            account_id,
            valid_start: valid_start.into(),
            nonce: (pb.nonce != 0).then_some(pb.nonce),
            scheduled: pb.scheduled,
        })
    }
}

impl ToProtobuf for TransactionId {
    type Protobuf = services::TransactionId;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TransactionId {
            account_id: Some(self.account_id.to_protobuf()),
            scheduled: self.scheduled,
            nonce: self.nonce.unwrap_or_default(),
            transaction_valid_start: Some(self.valid_start.into()),
        }
    }
}

// TODO: potentially improve parsing with `nom` or `combine`
impl FromStr for TransactionId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        const EXPECTED: &str = "expecting <accountId>@<validStart>[?scheduled][/<nonce>] or <accountId>-<validStart>[?scheduled][/<nonce>]";
        // parse route:
        // split_once('@') or split_once('-') -> ("<accountId>", "<validStart>[?scheduled][/<nonce>]")
        // rsplit_once('/') -> Either ("<validStart>[?scheduled]", "<nonce>") or ("<validStart>[?scheduled]")
        // .strip_suffix("?scheduled") -> ("<validStart>") and the suffix was either removed or not.
        // (except it's better ux to do a `split_once('?')`... Except it doesn't matter that much)

        let (account_id, seconds, remainder) = s
            .split_once('@')
            .and_then(|(account_id, remainder)| {
                remainder
                    .split_once('.')
                    .map(|(vs_secs, remainder)| (account_id, vs_secs, remainder))
            })
            .or_else(|| {
                s.split_once('-').and_then(|(account_id, remainder)| {
                    remainder
                        .split_once('-')
                        .map(|(vs_secs, remainder)| (account_id, vs_secs, remainder))
                })
            })
            .ok_or_else(|| Error::basic_parse(EXPECTED))?;

        let account_id: AccountId = account_id.parse()?;

        let (s, nonce) = match remainder.rsplit_once('/') {
            Some((s, nonce)) => (s, Some(nonce)),
            None => (remainder, None),
        };

        let nonce = nonce.map(i32::from_str).transpose().map_err(Error::basic_parse)?;

        let (nanos, scheduled) = match s.strip_suffix("?scheduled") {
            Some(rest) => (rest, true),
            None => (s, false),
        };

        let valid_start = {
            let seconds = i64::from_str(seconds).map_err(Error::basic_parse)?;
            let nanos = i64::from_str(nanos).map_err(Error::basic_parse)?;

            OffsetDateTime::from_unix_timestamp(seconds).map_err(Error::basic_parse)?
                + Duration::nanoseconds(nanos)
        };

        Ok(Self { account_id, valid_start, nonce, scheduled })
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use assert_matches::assert_matches;
    use expect_test::expect;
    use time::OffsetDateTime;

    use crate::protobuf::{
        FromProtobuf,
        ToProtobuf,
    };
    use crate::{
        AccountId,
        TransactionId,
    };

    #[test]
    fn from_str_wrong_field() {
        assert_matches!(TransactionId::from_str("0.0.31415?1641088801.2"), Err(_));
    }

    #[test]
    fn from_str_wrong_field2() {
        assert_matches!(TransactionId::from_str("0.0.31415/1641088801.2"), Err(_));
    }

    #[test]
    fn from_str_out_of_order() {
        assert_matches!(TransactionId::from_str("0.0.31415?scheduled/1412@1641088801.2"), Err(_));
    }

    #[test]
    fn from_str_single_digit_nanos() {
        let id = TransactionId {
            account_id: AccountId::from(31415),
            valid_start: time::Date::from_calendar_date(2022, time::Month::January, 2)
                .unwrap()
                .with_hms_nano(2, 0, 1, 2)
                .unwrap()
                .assume_utc(),
            nonce: None,
            scheduled: false,
        };

        assert_eq!(id, "0.0.31415@1641088801.2".parse().unwrap());
    }

    #[test]
    fn display_single_digit_nanos() {
        let id = TransactionId {
            account_id: AccountId::from(31415),
            valid_start: time::Date::from_calendar_date(2022, time::Month::January, 2)
                .unwrap()
                .with_hms_nano(2, 0, 1, 2)
                .unwrap()
                .assume_utc(),
            nonce: None,
            scheduled: false,
        };

        assert_eq!(id.to_string(), "0.0.31415@1641088801.2");
    }

    #[test]
    fn serialize() {
        expect!["0.0.23847@1588539964.632521325"].assert_eq(
            &TransactionId::from_str("0.0.23847@1588539964.632521325").unwrap().to_string(),
        )
    }

    #[test]
    fn serialize2() {
        expect!["0.0.23847@1588539964.632521325?scheduled/3"].assert_eq(
            &TransactionId::from_str("0.0.23847@1588539964.632521325?scheduled/3")
                .unwrap()
                .to_string(),
        )
    }

    #[test]
    fn to_from_pb() {
        let a = TransactionId::from_str("0.0.23847@1588539964.632521325").unwrap();
        let b = TransactionId::from_protobuf(a.to_protobuf()).unwrap();
        assert_eq!(a, b);
    }

    #[test]
    fn to_from_pb2() {
        let a = TransactionId::from_str("0.0.23847@1588539964.632521325?scheduled/2").unwrap();
        let b = TransactionId::from_protobuf(a.to_protobuf()).unwrap();
        assert_eq!(a, b);
    }

    #[test]
    fn to_from_bytes() {
        let a = TransactionId::from_str("0.0.23847@1588539964.632521325").unwrap();
        let b = TransactionId::from_bytes(&a.to_bytes()).unwrap();
        assert_eq!(a, b);
    }

    #[test]
    fn parse() {
        let transaction_id = TransactionId::from_str("0.0.23847@1588539964.632521325").unwrap();

        assert_eq!(
            transaction_id,
            TransactionId {
                account_id: AccountId::new(0, 0, 23847),
                valid_start: OffsetDateTime::from_unix_timestamp_nanos(1588539964632521325)
                    .unwrap(),
                nonce: None,
                scheduled: false
            }
        )
    }

    #[test]
    fn parse_scheduled() {
        let transaction_id: TransactionId =
            TransactionId::from_str("0.0.23847@1588539964.632521325?scheduled").unwrap();

        assert_eq!(
            transaction_id,
            TransactionId {
                account_id: AccountId::new(0, 0, 23847),
                valid_start: OffsetDateTime::from_unix_timestamp_nanos(1588539964632521325)
                    .unwrap(),
                nonce: None,
                scheduled: true
            }
        )
    }

    #[test]
    fn parse_nonce() {
        let transaction_id = TransactionId::from_str("0.0.23847@1588539964.632521325/4").unwrap();

        assert_eq!(
            transaction_id,
            TransactionId {
                account_id: AccountId::new(0, 0, 23847),
                valid_start: OffsetDateTime::from_unix_timestamp_nanos(1588539964632521325)
                    .unwrap(),
                nonce: Some(4),
                scheduled: false
            }
        )
    }

    /// Parse a transaction ID returned by the Hiero mirror api.
    ///
    /// Test case was an output of this mirror request:
    /// curl 'https://mainnet.mirrornode.hedera.com/api/v1/accounts/2?transactionType=cryptotransfer'
    #[test]
    fn parse_from_mirror() {
        let transaction_id = TransactionId::from_str("0.0.2247604-1691870420-078765024").unwrap();

        assert_eq!(
            transaction_id,
            TransactionId {
                account_id: AccountId::new(0, 0, 2247604),
                valid_start: OffsetDateTime::from_unix_timestamp_nanos(1691870420078765024)
                    .unwrap(),
                nonce: None,
                scheduled: false
            }
        )
    }
}
// Filename: src/transaction_receipt.rs
// SPDX-License-Identifier: Apache-2.0

use std::ops::Not;

use hedera_proto::services;
#[cfg(test)]
pub(super) use tests::make_receipt;

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    ContractId,
    Error,
    ExchangeRates,
    FileId,
    FromProtobuf,
    ScheduleId,
    Status,
    TokenId,
    TopicId,
    TransactionId,
};

/// The summary of a transaction's result so far, if the transaction has reached consensus.
/// Response from [`TransactionReceiptQuery`][crate::TransactionReceiptQuery].

#[derive(Debug, Clone)]
pub struct TransactionReceipt {
    // fixme(sr): better doc comment.
    /// The ID of the transaction that this is a receipt for.
    pub transaction_id: Option<TransactionId>,

    /// The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if
    /// the associated transaction did not have a valid payer signature.
    pub status: Status,

    /// In the receipt for an `AccountCreateTransaction`, the id of the newly created account.
    pub account_id: Option<AccountId>,

    /// In the receipt for a `FileCreateTransaction`, the id of the newly created file.
    pub file_id: Option<FileId>,

    /// In the receipt for a `ContractCreateTransaction`, the id of the newly created contract.
    pub contract_id: Option<ContractId>,

    /// The exchange rates in effect when the transaction reached consensus.
    pub exchange_rates: Option<ExchangeRates>,

    /// In the receipt for a `TopicCreateTransaction`, the id of the newly created topic.
    pub topic_id: Option<TopicId>,

    /// In the receipt for a `TopicMessageSubmitTransaction`, the new sequence number of the topic
    /// that received the message.
    pub topic_sequence_number: u64,

    // TODO: use a hash type (for display/debug/serialize purposes)
    /// In the receipt for a `TopicMessageSubmitTransaction`, the new running hash of the
    /// topic that received the message.
    pub topic_running_hash: Option<Vec<u8>>,

    /// In the receipt of a `TopicMessageSubmitTransaction`, the version of the SHA-384
    /// digest used to update the running hash.
    pub topic_running_hash_version: u64,

    /// In the receipt for a `TokenCreateTransaction`, the id of the newly created token.
    pub token_id: Option<TokenId>,

    /// Populated in the receipt of `TokenMint`, `TokenWipe`, and `TokenBurn` transactions.
    ///
    /// For fungible tokens, the current total supply of this token.
    /// For non-fungible tokens, the total number of NFTs issued for a given token id.
    pub total_supply: u64,

    /// In the receipt for a `ScheduleCreateTransaction`, the id of the newly created schedule.
    pub schedule_id: Option<ScheduleId>,

    /// In the receipt of a `ScheduleCreateTransaction` or `ScheduleSignTransaction` that resolves
    /// to `Success`, the `TransactionId` that should be used to query for the receipt or
    /// record of the relevant scheduled transaction.
    pub scheduled_transaction_id: Option<TransactionId>,

    /// In the receipt of a `TokenMintTransaction` for tokens of type `NonFungibleUnique`,
    /// the serial numbers of the newly created NFTs.
    pub serials: Vec<i64>,

    /// The receipts of processing all transactions with the given id, in consensus time order.
    pub duplicates: Vec<TransactionReceipt>,

    /// The receipts (if any) of all child transactions spawned by the transaction with the
    /// given top-level id, in consensus order.
    pub children: Vec<TransactionReceipt>,

    /// In the receipt of a NodeCreate, NodeUpdate, NodeDelete, the id of the newly created node.
    /// An affected node identifier.
    pub node_id: u64,
}

impl TransactionReceipt {
    /// Create a new `TransactionReceipt` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`] if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`] if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::TransactionReceipt>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }

    /// Validate [`status`](Self.status) and return an `Err` if it isn't [`Status::Success`]
    ///
    /// # Errors
    /// - [`Error::ReceiptStatus`] if `validate && self.status != Status::Success`
    pub fn validate_status(&self, validate: bool) -> crate::Result<&Self> {
        if validate && self.status != Status::Success {
            Err(Error::ReceiptStatus {
                status: self.status,
                transaction_id: self.transaction_id.map(Box::new),
            })
        } else {
            Ok(self)
        }
    }

    fn from_protobuf(
        receipt: services::TransactionReceipt,
        duplicates: Vec<Self>,
        children: Vec<Self>,
        transaction_id: Option<&TransactionId>,
    ) -> crate::Result<Self> {
        let status = Status::try_from(receipt.status).unwrap_or_default();

        let account_id = Option::from_protobuf(receipt.account_id)?;
        let file_id = Option::from_protobuf(receipt.file_id)?;
        let contract_id = Option::from_protobuf(receipt.contract_id)?;
        let topic_id = Option::from_protobuf(receipt.topic_id)?;
        let token_id = Option::from_protobuf(receipt.token_id)?;
        let schedule_id = Option::from_protobuf(receipt.schedule_id)?;
        let exchange_rates = Option::from_protobuf(receipt.exchange_rate)?;

        let scheduled_transaction_id = Option::from_protobuf(receipt.scheduled_transaction_id)?;

        Ok(Self {
            status,
            total_supply: receipt.new_total_supply,
            serials: receipt.serial_numbers,
            exchange_rates,
            topic_running_hash_version: receipt.topic_running_hash_version,
            topic_sequence_number: receipt.topic_sequence_number,
            topic_running_hash: receipt
                .topic_running_hash
                .is_empty()
                .not()
                .then_some(receipt.topic_running_hash),
            scheduled_transaction_id,
            account_id,
            file_id,
            contract_id,
            topic_id,
            token_id,
            schedule_id,
            duplicates,
            children,
            transaction_id: transaction_id.copied(),
            node_id: receipt.node_id,
        })
    }

    pub(crate) fn from_response_protobuf(
        pb: services::response::Response,
        transaction_id: Option<&TransactionId>,
    ) -> crate::Result<Self> {
        let pb = pb_getv!(pb, TransactionGetReceipt, services::response::Response);

        let receipt = pb_getf!(pb, receipt)?;

        let duplicates = Vec::from_protobuf(pb.duplicate_transaction_receipts)?;

        let children = Vec::from_protobuf(pb.child_transaction_receipts)?;

        Self::from_protobuf(receipt, duplicates, children, transaction_id)
    }
}

impl FromProtobuf<services::response::Response> for TransactionReceipt {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Self::from_response_protobuf(pb, None)
    }
}

impl FromProtobuf<services::TransactionReceipt> for TransactionReceipt {
    fn from_protobuf(receipt: services::TransactionReceipt) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Self::from_protobuf(receipt, Vec::new(), Vec::new(), None)
    }
}

impl ToProtobuf for TransactionReceipt {
    type Protobuf = services::TransactionReceipt;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::TransactionReceipt {
            status: self.status as i32,
            account_id: self.account_id.to_protobuf(),
            file_id: self.file_id.to_protobuf(),
            contract_id: self.contract_id.to_protobuf(),
            exchange_rate: self.exchange_rates.to_protobuf(),
            topic_id: self.topic_id.to_protobuf(),
            topic_sequence_number: self.topic_sequence_number,
            topic_running_hash: self.topic_running_hash.clone().unwrap_or_default(),
            topic_running_hash_version: self.topic_running_hash_version,
            token_id: self.token_id.to_protobuf(),
            new_total_supply: self.total_supply,
            schedule_id: self.schedule_id.to_protobuf(),
            scheduled_transaction_id: self.scheduled_transaction_id.to_protobuf(),
            serial_numbers: self.serials.clone(),
            node_id: self.node_id,
        }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;
    use time::OffsetDateTime;

    use crate::protobuf::ToProtobuf;
    use crate::transaction::test_helpers::{
        TEST_TX_ID,
        VALID_START,
    };
    use crate::{
        AccountId,
        ContractId,
        ExchangeRate,
        ExchangeRates,
        FileId,
        ScheduleId,
        Status,
        TokenId,
        TopicId,
        TransactionReceipt,
    };

    const EXPIRATION_TIME: OffsetDateTime = VALID_START;

    // needed in `transaction_record`.
    pub(crate) fn make_receipt() -> TransactionReceipt {
        TransactionReceipt {
            transaction_id: None,
            status: Status::ScheduleAlreadyDeleted,
            account_id: Some(AccountId::new(1, 2, 3)),
            file_id: Some(FileId::new(4, 5, 6)),
            exchange_rates: Some(ExchangeRates {
                current_rate: ExchangeRate {
                    hbars: 100,
                    cents: 100,
                    expiration_time: EXPIRATION_TIME,
                    exchange_rate_in_cents: f64::from(100) / f64::from(100),
                },
                next_rate: ExchangeRate {
                    hbars: 200,
                    cents: 200,
                    expiration_time: EXPIRATION_TIME,
                    exchange_rate_in_cents: f64::from(200) / f64::from(200),
                },
            }),
            contract_id: Some(ContractId::new(3, 2, 1)),
            topic_id: Some(TopicId::new(9, 8, 7)),
            topic_sequence_number: 3,
            topic_running_hash: Some(b"how now brown cow".to_vec()),
            topic_running_hash_version: 0,
            token_id: Some(TokenId::new(6, 5, 4)),
            total_supply: 30,
            schedule_id: Some(ScheduleId::new(1, 1, 1)),
            scheduled_transaction_id: Some(TEST_TX_ID),
            serials: Vec::from([1, 2, 3]),
            duplicates: Vec::new(),
            children: Vec::new(),
            node_id: 1,
        }
    }

    #[test]
    fn serialize() {
        expect![[r#"
            TransactionReceipt {
                status: ScheduleAlreadyDeleted,
                account_id: Some(
                    AccountId {
                        shard_num: 1,
                        realm_num: 2,
                        account: Some(
                            AccountNum(
                                3,
                            ),
                        ),
                    },
                ),
                file_id: Some(
                    FileId {
                        shard_num: 4,
                        realm_num: 5,
                        file_num: 6,
                    },
                ),
                contract_id: Some(
                    ContractId {
                        shard_num: 3,
                        realm_num: 2,
                        contract: Some(
                            ContractNum(
                                1,
                            ),
                        ),
                    },
                ),
                exchange_rate: Some(
                    ExchangeRateSet {
                        current_rate: Some(
                            ExchangeRate {
                                hbar_equiv: 100,
                                cent_equiv: 100,
                                expiration_time: Some(
                                    TimestampSeconds {
                                        seconds: 1554158542,
                                    },
                                ),
                            },
                        ),
                        next_rate: Some(
                            ExchangeRate {
                                hbar_equiv: 200,
                                cent_equiv: 200,
                                expiration_time: Some(
                                    TimestampSeconds {
                                        seconds: 1554158542,
                                    },
                                ),
                            },
                        ),
                    },
                ),
                topic_id: Some(
                    TopicId {
                        shard_num: 9,
                        realm_num: 8,
                        topic_num: 7,
                    },
                ),
                topic_sequence_number: 3,
                topic_running_hash: [
                    104,
                    111,
                    119,
                    32,
                    110,
                    111,
                    119,
                    32,
                    98,
                    114,
                    111,
                    119,
                    110,
                    32,
                    99,
                    111,
                    119,
                ],
                topic_running_hash_version: 0,
                token_id: Some(
                    TokenId {
                        shard_num: 6,
                        realm_num: 5,
                        token_num: 4,
                    },
                ),
                new_total_supply: 30,
                schedule_id: Some(
                    ScheduleId {
                        shard_num: 1,
                        realm_num: 1,
                        schedule_num: 1,
                    },
                ),
                scheduled_transaction_id: Some(
                    TransactionId {
                        transaction_valid_start: Some(
                            Timestamp {
                                seconds: 1554158542,
                                nanos: 0,
                            },
                        ),
                        account_id: Some(
                            AccountId {
                                shard_num: 0,
                                realm_num: 0,
                                account: Some(
                                    AccountNum(
                                        5006,
                                    ),
                                ),
                            },
                        ),
                        scheduled: false,
                        nonce: 0,
                    },
                ),
                serial_numbers: [
                    1,
                    2,
                    3,
                ],
                node_id: 1,
            }
        "#]]
        .assert_debug_eq(&make_receipt().to_protobuf())
    }

    #[test]
    fn to_from_bytes() {
        let a = make_receipt();
        let b = TransactionReceipt::from_bytes(&a.to_bytes()).unwrap();

        assert_eq!(a.to_protobuf(), b.to_protobuf());
    }
}
// Filename: src/transaction_receipt_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use hedera_proto::services::response::Response;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    Error,
    Query,
    Status,
    ToProtobuf,
    TransactionId,
    TransactionReceipt,
    ValidateChecksums,
};

/// Get the receipt of a transaction, given its transaction ID.
///
/// Once a transaction reaches consensus, then information about whether it succeeded or failed
/// will be available until the end of the receipt period.
///
pub type TransactionReceiptQuery = Query<TransactionReceiptQueryData>;

#[derive(Default, Clone, Debug)]
pub struct TransactionReceiptQueryData {
    transaction_id: Option<TransactionId>,
    include_children: bool,
    include_duplicates: bool,
    validate_status: bool,
}

impl From<TransactionReceiptQueryData> for AnyQueryData {
    #[inline]
    fn from(data: TransactionReceiptQueryData) -> Self {
        Self::TransactionReceipt(data)
    }
}

impl TransactionReceiptQuery {
    /// Get the ID of the transaction for which the receipt is being requested.
    #[must_use]
    pub fn get_transaction_id(&self) -> Option<TransactionId> {
        self.data.transaction_id
    }

    /// Sets the ID of the transaction for which the receipt is being requested.
    pub fn transaction_id(&mut self, transaction_id: TransactionId) -> &mut Self {
        self.data.transaction_id = Some(transaction_id);
        self
    }

    /// Whether the response should include the receipts of any child transactions spawned by the
    /// top-level transaction with the given transaction.
    #[must_use]
    pub fn get_include_children(&self) -> bool {
        self.data.include_children
    }

    /// Whether the response should include the receipts of any child transactions spawned by the
    /// top-level transaction with the given transaction.
    pub fn include_children(&mut self, include: bool) -> &mut Self {
        self.data.include_children = include;
        self
    }

    /// Whether receipts of processing duplicate transactions should be returned.
    #[must_use]
    pub fn get_include_duplicates(&self) -> bool {
        self.data.include_duplicates
    }

    /// Whether receipts of processing duplicate transactions should be returned.
    pub fn include_duplicates(&mut self, include: bool) -> &mut Self {
        self.data.include_duplicates = include;
        self
    }

    /// Whether the receipt status should be validated.
    #[must_use]
    pub fn get_validate_status(&self) -> bool {
        self.data.validate_status
    }

    /// Whether the receipt status should be validated.
    pub fn validate_status(&mut self, validate: bool) -> &mut Self {
        self.data.validate_status = validate;
        self
    }
}

impl ToQueryProtobuf for TransactionReceiptQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let transaction_id = self.transaction_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::TransactionGetReceipt(
                services::TransactionGetReceiptQuery {
                    header: Some(header),
                    transaction_id,
                    include_child_receipts: self.include_children,
                    include_duplicates: self.include_duplicates,
                },
            )),
        }
    }
}

impl QueryExecute for TransactionReceiptQueryData {
    type Response = TransactionReceipt;

    fn is_payment_required(&self) -> bool {
        false
    }

    fn transaction_id(&self) -> Option<TransactionId> {
        self.transaction_id
    }

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async {
            CryptoServiceClient::new(channel).get_transaction_receipts(request).await
        })
    }

    fn should_retry_pre_check(&self, status: Status) -> bool {
        matches!(status, Status::ReceiptNotFound | Status::RecordNotFound)
    }

    fn should_retry(&self, response: &services::Response) -> bool {
        // extract the receipt status from the receipt
        // without altering or freeing the memory from the response

        let receipt_status = {
            let Some(services::response::Response::TransactionGetReceipt(r)) = &response.response
            else {
                return false;
            };

            match r.receipt.as_ref().and_then(|it| Some(Status::try_from(it.status))) {
                Some(receipt_status) => receipt_status,
                None => return false,
            }
        };

        matches!(receipt_status, Ok(Status::Unknown))
    }

    fn make_response(&self, response: Response) -> crate::Result<Self::Response> {
        let receipt =
            TransactionReceipt::from_response_protobuf(response, self.transaction_id.as_ref())?;

        if self.validate_status && receipt.status != Status::Success {
            return Err(Error::ReceiptStatus {
                transaction_id: self.transaction_id.map(Box::new),
                status: receipt.status,
            });
        }

        Ok(receipt)
    }
}

impl ValidateChecksums for TransactionReceiptQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.transaction_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::transaction::test_helpers::TEST_TX_ID;
    use crate::TransactionReceiptQuery;

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    TransactionGetReceipt(
                        TransactionGetReceiptQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            transaction_id: Some(
                                TransactionId {
                                    transaction_valid_start: Some(
                                        Timestamp {
                                            seconds: 1554158542,
                                            nanos: 0,
                                        },
                                    ),
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5006,
                                                ),
                                            ),
                                        },
                                    ),
                                    scheduled: false,
                                    nonce: 0,
                                },
                            ),
                            include_duplicates: false,
                            include_child_receipts: false,
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &TransactionReceiptQuery::new()
                .transaction_id(TEST_TX_ID)
                .data
                .to_query_protobuf(Default::default()),
        )
    }

    #[test]
    fn get_set_transaction_id() {
        let mut query = TransactionReceiptQuery::new();
        query.transaction_id(TEST_TX_ID);

        assert_eq!(query.get_transaction_id(), Some(TEST_TX_ID));
    }

    // default is false for all of these, so setting it to `true` is the "interesting" state.
    #[test]
    fn get_set_include_children() {
        let mut query = TransactionReceiptQuery::new();
        query.include_children(true);

        assert_eq!(query.get_include_children(), true);
    }

    #[test]
    fn get_set_include_duplicates() {
        let mut query = TransactionReceiptQuery::new();
        query.include_duplicates(true);

        assert_eq!(query.get_include_duplicates(), true);
    }

    #[test]
    fn get_set_validate_status() {
        let mut query = TransactionReceiptQuery::new();
        query.validate_status(true);

        assert_eq!(query.get_validate_status(), true);
    }
}
// Filename: src/transaction_record.rs
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashMap;

use hedera_proto::services;
use time::OffsetDateTime;

use crate::protobuf::ToProtobuf;
use crate::{
    AccountId,
    AssessedCustomFee,
    ContractFunctionResult,
    EvmAddress,
    FromProtobuf,
    Hbar,
    PendingAirdropRecord,
    PublicKey,
    ScheduleId,
    Tinybar,
    TokenAssociation,
    TokenId,
    TokenNftTransfer,
    TransactionId,
    TransactionReceipt,
    Transfer,
};

/// The complete record for a transaction on Hiero that has reached consensus.
/// Response from [`TransactionRecordQuery`][crate::TransactionRecordQuery].
#[derive(Debug, Clone)]
pub struct TransactionRecord {
    /// The status (reach consensus, or failed, or is unknown) and the ID of
    /// any new account/file/instance created.
    pub receipt: TransactionReceipt,

    /// The hash of the Transaction that executed (not the hash of any Transaction that failed for
    /// having a duplicate TransactionID).
    pub transaction_hash: Vec<u8>,

    /// The consensus timestamp.
    pub consensus_timestamp: OffsetDateTime,

    /// Record of the value returned by the smart contract function or constructor.
    pub contract_function_result: Option<ContractFunctionResult>,

    /// All hbar transfers as a result of this transaction, such as fees, or
    /// transfers performed by the transaction, or by a smart contract it calls,
    /// or by the creation of threshold records that it triggers.
    pub transfers: Vec<Transfer>,

    /// All fungible token transfers as a result of this transaction.
    pub token_transfers: HashMap<TokenId, HashMap<AccountId, i64>>,

    /// All NFT Token transfers as a result of this transaction.
    pub token_nft_transfers: HashMap<TokenId, Vec<TokenNftTransfer>>,

    /// The ID of the transaction this record represents.
    pub transaction_id: TransactionId,

    /// The memo that was submitted as part of the transaction.
    pub transaction_memo: String,

    /// The actual transaction fee charged.
    pub transaction_fee: Hbar,

    /// Reference to the scheduled transaction ID that this transaction record represents.
    pub schedule_ref: Option<ScheduleId>,

    /// All custom fees that were assessed during a [`TransferTransaction`](crate::TransferTransaction), and must be paid if the
    /// transaction status resolved to SUCCESS.
    pub assessed_custom_fees: Vec<AssessedCustomFee>,

    /// All token associations implicitly created while handling this transaction
    pub automatic_token_associations: Vec<TokenAssociation>,

    /// In the record of an internal transaction, the consensus timestamp of the user
    /// transaction that spawned it.
    pub parent_consensus_timestamp: Option<OffsetDateTime>,

    /// In the record of an internal CryptoCreate transaction triggered by a user
    /// transaction with a (previously unused) alias, the new account's alias.
    pub alias_key: Option<PublicKey>,

    /// The records of processing all child transaction spawned by the transaction with the given
    /// top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
    pub children: Vec<Self>,

    /// The records of processing all consensus transaction with the same id as the distinguished
    /// record above, in chronological order.
    pub duplicates: Vec<Self>,

    /// The keccak256 hash of the ethereumData. This field will only be populated for
    /// `EthereumTransaction`.
    pub ethereum_hash: Vec<u8>,

    /// In the record of a PRNG transaction with no output range, a pseudorandom 384-bit string.
    pub prng_bytes: Option<Vec<u8>>,

    /// In the record of a PRNG transaction with an output range, the output of a PRNG
    /// whose input was a 384-bit string.
    pub prng_number: Option<u32>,

    /// The last 20 bytes of the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
    pub evm_address: Option<EvmAddress>,

    /// A list of pending token airdrops.
    pub pending_airdrop_records: Vec<PendingAirdropRecord>,
}
// TODO: paid_staking_rewards

impl TransactionRecord {
    /// Create a new `TransactionRecord` from protobuf-encoded `bytes`.
    ///
    /// # Errors
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the bytes fails to produce a valid protobuf.
    /// - [`Error::FromProtobuf`](crate::Error::FromProtobuf) if decoding the protobuf fails.
    pub fn from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        FromProtobuf::<services::TransactionRecord>::from_bytes(bytes)
    }

    /// Convert `self` to a protobuf-encoded [`Vec<u8>`].
    #[must_use]
    pub fn to_bytes(&self) -> Vec<u8> {
        ToProtobuf::to_bytes(self)
    }

    fn from_protobuf(
        record: services::TransactionRecord,
        duplicates: Vec<Self>,
        children: Vec<Self>,
    ) -> crate::Result<Self> {
        use services::transaction_record::Body;
        let receipt = pb_getf!(record, receipt)?;
        let receipt = TransactionReceipt::from_protobuf(receipt)?;

        let consensus_timestamp = pb_getf!(record, consensus_timestamp)?;
        let transaction_id = pb_getf!(record, transaction_id)?;
        let schedule_ref = Option::from_protobuf(record.schedule_ref)?;
        let parent_consensus_timestamp = record.parent_consensus_timestamp.map(Into::into);

        let alias_key = PublicKey::from_alias_bytes(&record.alias)?;

        let automatic_token_associations = Vec::from_protobuf(record.automatic_token_associations)?;

        let contract_function_result = record.body.map(|it| match it {
            Body::ContractCallResult(it) | Body::ContractCreateResult(it) => it,
        });

        let contract_function_result = Option::from_protobuf(contract_function_result)?;

        let transfers = record.transfer_list.map_or_else(Vec::new, |it| it.account_amounts);
        let transfers = Vec::from_protobuf(transfers)?;

        let (token_transfers, token_nft_transfers) = {
            let mut token_transfers = HashMap::with_capacity(record.token_transfer_lists.len());

            let mut token_nft_transfers: HashMap<TokenId, Vec<TokenNftTransfer>> =
                HashMap::with_capacity(record.token_transfer_lists.len());

            for transfer_list in record.token_transfer_lists {
                let token_id = pb_getf!(transfer_list, token)?;
                let token_id = TokenId::from_protobuf(token_id)?;

                // `.insert` would be the most idiomatic way, but this matches behavior with Java.
                let token_transfers = token_transfers
                    .entry(token_id)
                    .or_insert_with(|| HashMap::with_capacity(transfer_list.transfers.len()));

                for it in transfer_list.transfers {
                    let account_id = AccountId::from_protobuf(pb_getf!(it, account_id)?)?;
                    token_transfers.insert(account_id, it.amount);
                }

                let nft_transfers: Result<Vec<_>, _> = transfer_list
                    .nft_transfers
                    .into_iter()
                    .map(|it| TokenNftTransfer::from_protobuf(it, token_id))
                    .collect();
                let nft_transfers = nft_transfers?;

                token_nft_transfers.entry(token_id).or_default().extend_from_slice(&nft_transfers);
            }

            (token_transfers, token_nft_transfers)
        };

        let evm_address = if record.evm_address.is_empty() {
            None
        } else {
            Some(EvmAddress::try_from(record.evm_address)?)
        };

        let (prng_bytes, prng_number) = match record.entropy {
            Some(services::transaction_record::Entropy::PrngBytes(it)) => (Some(it), None),
            Some(services::transaction_record::Entropy::PrngNumber(it)) => (None, Some(it as u32)),
            None => (None, None),
        };

        let pending_airdrop_records = Vec::from_protobuf(record.new_pending_airdrops)?;

        Ok(Self {
            receipt,
            transaction_hash: record.transaction_hash,
            consensus_timestamp: consensus_timestamp.into(),
            contract_function_result,
            transaction_id: TransactionId::from_protobuf(transaction_id)?,
            transaction_memo: record.memo,
            transaction_fee: Hbar::from_tinybars(record.transaction_fee as Tinybar),
            schedule_ref,
            automatic_token_associations,
            parent_consensus_timestamp,
            duplicates,
            ethereum_hash: record.ethereum_hash,
            children,
            alias_key,
            transfers,
            token_transfers,
            token_nft_transfers,
            assessed_custom_fees: Vec::from_protobuf(record.assessed_custom_fees)?,
            evm_address,
            prng_bytes,
            prng_number,
            pending_airdrop_records,
        })
    }
}

impl FromProtobuf<services::response::Response> for TransactionRecord {
    fn from_protobuf(pb: services::response::Response) -> crate::Result<Self>
    where
        Self: Sized,
    {
        let pb = pb_getv!(pb, TransactionGetRecord, services::response::Response);

        let record = pb_getf!(pb, transaction_record)?;

        let duplicates = Vec::from_protobuf(pb.duplicate_transaction_records)?;

        let children = Vec::from_protobuf(pb.child_transaction_records)?;

        Self::from_protobuf(record, duplicates, children)
    }
}

impl FromProtobuf<services::TransactionRecord> for TransactionRecord {
    fn from_protobuf(receipt: services::TransactionRecord) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Self::from_protobuf(receipt, Vec::new(), Vec::new())
    }
}

impl ToProtobuf for TransactionRecord {
    type Protobuf = services::TransactionRecord;

    fn to_protobuf(&self) -> Self::Protobuf {
        let entropy = self
            .prng_number
            .map(|it| services::transaction_record::Entropy::PrngNumber(it as i32))
            .or_else(|| {
                self.prng_bytes.clone().map(services::transaction_record::Entropy::PrngBytes)
            });

        let token_transfer_lists = self
            .token_transfers
            .iter()
            .map(|it| services::TokenTransferList {
                token: Some(it.0.to_protobuf()),
                transfers: it
                    .1
                    .iter()
                    .map(|it| services::AccountAmount {
                        account_id: Some(it.0.to_protobuf()),
                        amount: *it.1,
                        is_approval: false,
                    })
                    .collect(),
                nft_transfers: Vec::new(),
                expected_decimals: None,
            })
            .collect();

        services::TransactionRecord {
            receipt: Some(self.receipt.to_protobuf()),
            transaction_hash: self.transaction_hash.clone(),
            consensus_timestamp: Some(self.consensus_timestamp.to_protobuf()),
            transaction_id: Some(self.transaction_id.to_protobuf()),
            memo: self.transaction_memo.clone(),
            transaction_fee: self.transaction_fee.to_tinybars() as u64,
            transfer_list: Some(services::TransferList {
                account_amounts: self.transfers.iter().map(|it| it.to_protobuf()).collect(),
            }),
            token_transfer_lists: token_transfer_lists,
            schedule_ref: self.schedule_ref.to_protobuf(),
            assessed_custom_fees: self.assessed_custom_fees.to_protobuf(),
            automatic_token_associations: self.automatic_token_associations.to_protobuf(),
            parent_consensus_timestamp: self.parent_consensus_timestamp.to_protobuf(),
            alias: self.alias_key.as_ref().map(ToProtobuf::to_bytes).unwrap_or_default(),
            ethereum_hash: self.ethereum_hash.clone(),
            // TODO:
            paid_staking_rewards: Vec::new(),
            evm_address: self
                .evm_address
                .as_ref()
                .map_or_else(Vec::default, |it| it.to_bytes().to_vec()),
            body: self
                .contract_function_result
                .as_ref()
                .map(|it| services::transaction_record::Body::ContractCallResult(it.to_protobuf())),
            entropy,
            new_pending_airdrops: self.pending_airdrop_records.to_protobuf(),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use expect_test::expect_file;

    use crate::pending_airdrop_id::PendingAirdropId;
    use crate::protobuf::ToProtobuf;
    use crate::transaction::test_helpers::{
        TEST_TX_ID,
        VALID_START,
    };
    use crate::{
        AccountId,
        AssessedCustomFee,
        ContractFunctionResult,
        ContractId,
        Hbar,
        PendingAirdropRecord,
        PrivateKey,
        ScheduleId,
        TokenAssociation,
        TokenId,
        TokenNftTransfer,
        TransactionRecord,
        Transfer,
    };

    fn make_record(prng_bytes: Option<Vec<u8>>, prng_number: Option<u32>) -> TransactionRecord {
        TransactionRecord {
            receipt: crate::transaction_receipt::make_receipt(),
            transaction_hash: b"hello".to_vec(),
            consensus_timestamp: VALID_START,
            contract_function_result: Some(ContractFunctionResult {
                contract_id: ContractId::new(1, 2, 3),
                evm_address: Some(ContractId::new(1, 2, 3)),
                bytes: Vec::new(),
                error_message: None,
                bloom: Vec::new(),
                gas_used: 0,
                gas: 0,
                hbar_amount: 0,
                contract_function_parameters_bytes: Vec::new(),
                sender_account_id: Some(AccountId::new(1, 2, 3)),
                logs: Vec::new(),
                contract_nonces: Vec::new(),
                signer_nonce: None,
            }),
            transfers: Vec::from([Transfer {
                account_id: AccountId::new(4, 4, 4),
                amount: Hbar::new(5),
            }]),
            token_transfers: HashMap::from([(
                TokenId::new(6, 6, 6),
                HashMap::from([(AccountId::new(1, 1, 1), 4)]),
            )]),
            token_nft_transfers: HashMap::from([(
                TokenId::new(4, 4, 4),
                Vec::from([TokenNftTransfer {
                    token_id: TokenId::new(4, 4, 4),
                    sender: AccountId::new(1, 2, 3),
                    receiver: AccountId::new(3, 2, 1),
                    serial: 4,
                    is_approved: true,
                }]),
            )]),
            transaction_id: TEST_TX_ID,
            transaction_memo: "memo".to_owned(),
            transaction_fee: Hbar::from_tinybars(3000),
            schedule_ref: Some(ScheduleId::new(3, 3, 3)),
            assessed_custom_fees: Vec::from([AssessedCustomFee {
                amount: 4,
                token_id: Some(TokenId::new(4, 5, 6)),
                fee_collector_account_id: Some(AccountId::new(8, 6, 5)),
                payer_account_id_list: Vec::from([AccountId::new(3, 3, 3)]),
            }]),
            automatic_token_associations: Vec::from([TokenAssociation {
                token_id: TokenId::new(5, 4, 3),
                account_id: AccountId::new(8, 7, 6),
            }]),
            parent_consensus_timestamp: Some(VALID_START),
            alias_key: Some(
                PrivateKey::from_str_ecdsa(
                    "8776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048",
                )
                .unwrap()
                .public_key()
                .into(),
            ),
            children: Vec::new(),
            duplicates: Vec::new(),
            ethereum_hash: b"Some hash".to_vec(),
            prng_bytes,
            prng_number,
            evm_address: Some(crate::EvmAddress([0; 20])),
            pending_airdrop_records: vec![PendingAirdropRecord {
                pending_airdrop_id: PendingAirdropId::new_token_id(
                    AccountId::new(0, 0, 678),
                    AccountId::new(1, 2, 3),
                    TokenId::new(1, 2, 3),
                ),
                pending_airdrop_value: Some(2),
            }],
        }
    }

    #[test]
    fn serialize() {
        expect_file!["./snapshots/transaction_record/serialize.txt"]
            .assert_debug_eq(&make_record(Some(b"very random bytes".to_vec()), None).to_protobuf())
    }

    #[test]
    fn to_from_bytes() {
        let a = make_record(Some(b"very random bytes".to_vec()), None);
        let b = TransactionRecord::from_bytes(&a.to_bytes()).unwrap();

        assert_eq!(a.to_protobuf(), b.to_protobuf());
    }

    #[test]
    fn serialize2() {
        expect_file!["./snapshots/transaction_record/serialize2.txt"]
            .assert_debug_eq(&make_record(None, Some(4)).to_protobuf())
    }

    #[test]
    fn to_from_bytes2() {
        let a = make_record(None, Some(4));
        let b = TransactionRecord::from_bytes(&a.to_bytes()).unwrap();

        assert_eq!(a.to_protobuf(), b.to_protobuf());
    }
}
// Filename: src/transaction_record_query.rs
// SPDX-License-Identifier: Apache-2.0

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use hedera_proto::services::response::Response;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::query::{
    AnyQueryData,
    QueryExecute,
    ToQueryProtobuf,
};
use crate::{
    BoxGrpcFuture,
    Error,
    FromProtobuf,
    Query,
    Status,
    ToProtobuf,
    TransactionId,
    TransactionRecord,
    ValidateChecksums,
};

/// Get the record of a transaction, given its transaction ID.
///
pub type TransactionRecordQuery = Query<TransactionRecordQueryData>;

#[derive(Default, Clone, Debug)]
pub struct TransactionRecordQueryData {
    transaction_id: Option<TransactionId>,
    include_children: bool,
    include_duplicates: bool,
    validate_status: bool,
}

impl From<TransactionRecordQueryData> for AnyQueryData {
    #[inline]
    fn from(data: TransactionRecordQueryData) -> Self {
        Self::TransactionRecord(data)
    }
}

impl TransactionRecordQuery {
    /// Get the ID of the transaction for which the record is being requested.
    #[must_use]
    pub fn get_transaction_id(&self) -> Option<TransactionId> {
        self.data.transaction_id
    }

    /// Sets the ID of the transaction for which the record is being requested.
    pub fn transaction_id(&mut self, transaction_id: TransactionId) -> &mut Self {
        self.data.transaction_id = Some(transaction_id);
        self
    }

    /// Whether the response should include the records of any child transactions spawned by the
    /// top-level transaction with the given transaction.
    #[must_use]
    pub fn get_include_children(&self) -> bool {
        self.data.include_children
    }

    /// Whether the response should include the records of any child transactions spawned by the
    /// top-level transaction with the given transaction.
    pub fn include_children(&mut self, include: bool) -> &mut Self {
        self.data.include_children = include;
        self
    }

    /// Whether records of processing duplicate transactions should be returned.
    #[must_use]
    pub fn get_include_duplicates(&self) -> bool {
        self.data.include_duplicates
    }

    /// Whether records of processing duplicate transactions should be returned.
    pub fn include_duplicates(&mut self, include: bool) -> &mut Self {
        self.data.include_duplicates = include;
        self
    }

    /// Whether records of processing duplicate transactions should be returned.
    #[must_use]
    pub fn get_validate_status(&self) -> bool {
        self.data.validate_status
    }

    /// Whether the record status should be validated.
    pub fn validate_status(&mut self, validate: bool) -> &mut Self {
        self.data.validate_status = validate;
        self
    }
}

impl ToQueryProtobuf for TransactionRecordQueryData {
    fn to_query_protobuf(&self, header: services::QueryHeader) -> services::Query {
        let transaction_id = self.transaction_id.to_protobuf();

        services::Query {
            query: Some(services::query::Query::TransactionGetRecord(
                services::TransactionGetRecordQuery {
                    header: Some(header),
                    transaction_id,
                    include_child_records: self.include_children,
                    include_duplicates: self.include_duplicates,
                },
            )),
        }
    }
}

impl QueryExecute for TransactionRecordQueryData {
    type Response = TransactionRecord;

    fn transaction_id(&self) -> Option<TransactionId> {
        self.transaction_id
    }

    fn execute(
        &self,
        channel: Channel,
        request: services::Query,
    ) -> BoxGrpcFuture<'_, services::Response> {
        Box::pin(async { CryptoServiceClient::new(channel).get_tx_record_by_tx_id(request).await })
    }

    fn should_retry_pre_check(&self, status: Status) -> bool {
        matches!(status, Status::ReceiptNotFound | Status::RecordNotFound)
    }

    fn make_response(&self, response: Response) -> crate::Result<Self::Response> {
        let record = TransactionRecord::from_protobuf(response)?;

        if self.validate_status && record.receipt.status != Status::Success {
            return Err(Error::ReceiptStatus {
                transaction_id: self.transaction_id.map(Box::new),
                status: record.receipt.status,
            });
        }

        Ok(record)
    }
}

impl ValidateChecksums for TransactionRecordQueryData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        self.transaction_id.validate_checksums(ledger_id)
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::query::ToQueryProtobuf;
    use crate::transaction::test_helpers::TEST_TX_ID;
    use crate::TransactionRecordQuery;

    #[test]
    fn serialize() {
        expect![[r#"
            Query {
                query: Some(
                    TransactionGetRecord(
                        TransactionGetRecordQuery {
                            header: Some(
                                QueryHeader {
                                    payment: None,
                                    response_type: AnswerOnly,
                                },
                            ),
                            transaction_id: Some(
                                TransactionId {
                                    transaction_valid_start: Some(
                                        Timestamp {
                                            seconds: 1554158542,
                                            nanos: 0,
                                        },
                                    ),
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5006,
                                                ),
                                            ),
                                        },
                                    ),
                                    scheduled: false,
                                    nonce: 0,
                                },
                            ),
                            include_duplicates: true,
                            include_child_records: true,
                        },
                    ),
                ),
            }
        "#]]
        .assert_debug_eq(
            &TransactionRecordQuery::new()
                .transaction_id(TEST_TX_ID)
                .include_children(true)
                .include_duplicates(true)
                .data
                .to_query_protobuf(Default::default()),
        )
    }

    #[test]
    fn get_set_transaction_id() {
        let mut query = TransactionRecordQuery::new();
        query.transaction_id(TEST_TX_ID);

        assert_eq!(query.get_transaction_id(), Some(TEST_TX_ID));
    }

    // default is false for all of these, so setting it to `true` is the "interesting" state.
    #[test]
    fn get_set_include_children() {
        let mut query = TransactionRecordQuery::new();
        query.include_children(true);

        assert_eq!(query.get_include_children(), true);
    }

    #[test]
    fn get_set_include_duplicates() {
        let mut query = TransactionRecordQuery::new();
        query.include_duplicates(true);

        assert_eq!(query.get_include_duplicates(), true);
    }

    #[test]
    fn get_set_validate_status() {
        let mut query = TransactionRecordQuery::new();
        query.validate_status(true);

        assert_eq!(query.get_validate_status(), true);
    }
}
// Filename: src/transaction_response.rs
// SPDX-License-Identifier: Apache-2.0

use crate::{
    AccountId,
    Client,
    TransactionHash,
    TransactionId,
    TransactionReceipt,
    TransactionReceiptQuery,
    TransactionRecord,
    TransactionRecordQuery,
};

/// Response from [`Transaction::execute`][crate::Transaction::execute].
///
/// When the client sends a node a transaction of any kind, the node replies with this, which
/// simply says that the transaction passed the pre-check (so the node will submit it to
/// the network).
///
/// To learn the consensus result, the client should later obtain a
/// receipt (free), or can buy a more detailed record (not free).
///
#[derive(Debug)]
pub struct TransactionResponse {
    /// The account ID of the node that the transaction was submitted to.
    pub node_account_id: AccountId,

    /// The client-generated transaction ID of the transaction that was submitted.
    ///
    /// This can be used to lookup the transaction in an explorer.
    pub transaction_id: TransactionId,

    /// The client-generated SHA-384 hash of the transaction that was submitted.
    ///
    /// This can be used to lookup the transaction in an explorer.
    pub transaction_hash: TransactionHash,

    /// Whether the receipt/record status should be validated.
    pub validate_status: bool,
}

impl TransactionResponse {
    /// Whether the receipt/record status should be validated.
    pub fn validate_status(&mut self, validate: bool) -> &mut Self {
        self.validate_status = validate;
        self
    }

    /// Create a query that will get the receipt for this transaction.
    #[must_use]
    pub fn get_receipt_query(&self) -> TransactionReceiptQuery {
        let mut query = TransactionReceiptQuery::new();

        query.transaction_id(self.transaction_id).validate_status(self.validate_status);

        query
    }

    /// Create a query that will get the record for this transaction.
    #[must_use]
    pub fn get_record_query(&self) -> TransactionRecordQuery {
        let mut query = TransactionRecordQuery::new();

        query.transaction_id(self.transaction_id).validate_status(self.validate_status);

        query
    }

    /// Get the receipt for this transaction.
    /// Will wait for consensus.
    ///
    /// # Errors
    /// - if [`validate_status`](Self.validate_status) is `true`:
    ///   [`Error::ReceiptStatus`](crate::Error::ReceiptStatus) for a failing receipt.
    ///
    /// fixme: is that it? Surely there are more situations.
    pub async fn get_receipt(&self, client: &Client) -> crate::Result<TransactionReceipt> {
        self.get_receipt_query().execute(client).await
    }

    /// Get the receipt for this transaction.
    /// Will wait for consensus.
    ///
    /// # Errors
    /// - if [`validate_status`](Self.validate_status) is `true`:
    ///   [`Error::ReceiptStatus`](crate::Error::ReceiptStatus) for a failing receipt.
    pub async fn get_receipt_with_timeout(
        &self,
        client: &Client,
        timeout: std::time::Duration,
    ) -> crate::Result<TransactionReceipt> {
        self.get_receipt_query().execute_with_timeout(client, timeout).await
    }

    /// Get the record for this transaction.
    /// Will wait for consensus.
    ///
    /// # Errors
    /// - if [`validate_status`](Self.validate_status) is `true`:
    ///   [`Error::ReceiptStatus`](crate::Error::ReceiptStatus) for a failing receipt in the record.
    pub async fn get_record(&self, client: &Client) -> crate::Result<TransactionRecord> {
        self.get_record_query().execute(client).await
    }

    /// Get the record for this transaction.
    /// Will wait for consensus.
    ///
    /// # Errors
    /// - if [`validate_status`](Self.validate_status) is `true`:
    ///   [`Error::ReceiptStatus`](crate::Error::ReceiptStatus) for a failing receipt in the record.
    pub async fn get_record_with_timeout(
        &self,
        client: &Client,
        timeout: std::time::Duration,
    ) -> crate::Result<TransactionRecord> {
        self.get_record_query().execute_with_timeout(client, timeout).await
    }
}
// Filename: src/transfer.rs
use hedera_proto::services;

use crate::protobuf::{
    FromProtobuf,
    ToProtobuf,
};
use crate::{
    AccountId,
    Hbar,
};

/// A transfer of [`Hbar`] that occured within a [`Transaction`](crate::Transaction)
///
/// Returned as part of a [`TransactionRecord`](crate::TransactionRecord)
#[derive(Debug, Clone)]
pub struct Transfer {
    /// The account ID that this transfer is to/from.
    pub account_id: AccountId,

    /// The value of this transfer.
    ///
    /// Negative if the account sends/withdraws hbar, positive if it receives hbar.
    pub amount: Hbar,
}

impl FromProtobuf<services::AccountAmount> for Transfer {
    fn from_protobuf(pb: services::AccountAmount) -> crate::Result<Self>
    where
        Self: Sized,
    {
        Ok(Self {
            account_id: AccountId::from_protobuf(pb_getf!(pb, account_id)?)?,
            amount: Hbar::from_tinybars(pb.amount),
        })
    }
}

impl ToProtobuf for Transfer {
    type Protobuf = services::AccountAmount;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::AccountAmount {
            account_id: Some(self.account_id.to_protobuf()),
            amount: self.amount.to_tinybars(),
            is_approval: false,
        }
    }
}
// Filename: src/transfer_transaction.rs
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashMap;
use std::ops::Not;

use hedera_proto::services;
use hedera_proto::services::crypto_service_client::CryptoServiceClient;
use tonic::transport::Channel;

use crate::ledger_id::RefLedgerId;
use crate::protobuf::FromProtobuf;
use crate::transaction::{
    AnyTransactionData,
    ChunkInfo,
    ToSchedulableTransactionDataProtobuf,
    ToTransactionDataProtobuf,
    TransactionData,
    TransactionExecute,
};
use crate::{
    AccountId,
    BoxGrpcFuture,
    Error,
    Hbar,
    NftId,
    ToProtobuf,
    TokenId,
    TokenNftTransfer,
    Transaction,
    ValidateChecksums,
};

/// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their
/// balances.
///
/// Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn
/// from the corresponding account (a sender), and each positive one is added to the corresponding
/// account (a receiver). The amounts list must sum to zero.
///
/// All transfers are in the lowest denomination, for `Hbar` that is tinybars (although `Hbar` handles this itself).
///
/// As an example: for a fungible token with `3` decimals (and let's say the symbol is ``), transferring `1` _always_ transfers `0.001 `.
pub type TransferTransaction = Transaction<TransferTransactionData>;

#[derive(Debug, Clone, Default)]
#[cfg_attr(test, derive(Eq, PartialEq))]
pub struct TransferTransactionData {
    transfers: Vec<Transfer>,
    token_transfers: Vec<TokenTransfer>,
}

#[derive(Debug, Clone)]
#[cfg_attr(test, derive(Eq, PartialEq))]
pub(crate) struct Transfer {
    /// The account involved in the transfer.
    pub account_id: AccountId,

    /// The value of the transfer.
    pub amount: i64,

    /// If this is an approved transfer.
    pub is_approval: bool,
}

#[derive(Debug, Clone)]
#[cfg_attr(test, derive(Eq, PartialEq))]
pub(crate) struct TokenTransfer {
    pub token_id: TokenId,

    pub transfers: Vec<Transfer>,

    pub nft_transfers: Vec<TokenNftTransfer>,

    pub expected_decimals: Option<u32>,
}

impl TransferTransaction {
    fn _hbar_transfer(&mut self, account_id: AccountId, amount: Hbar, approved: bool) -> &mut Self {
        self.data_mut().transfers.push(Transfer {
            account_id,
            amount: amount.to_tinybars(),
            is_approval: approved,
        });

        self
    }

    /// Add a non-approved hbar transfer to the transaction.
    pub fn hbar_transfer(&mut self, account_id: AccountId, amount: Hbar) -> &mut Self {
        self._hbar_transfer(account_id, amount, false)
    }

    /// Add an approved hbar transfer to the transaction.
    pub fn approved_hbar_transfer(&mut self, account_id: AccountId, amount: Hbar) -> &mut Self {
        self._hbar_transfer(account_id, amount, true)
    }

    /// Returns all transfers associated with this transaction.
    pub fn get_hbar_transfers(&self) -> HashMap<AccountId, Hbar> {
        self.data()
            .transfers
            .iter()
            .map(|it| (it.account_id, Hbar::from_tinybars(it.amount)))
            .collect()
    }

    fn _token_transfer(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
        approved: bool,
        expected_decimals: Option<u32>,
    ) -> &mut Self {
        let transfer = Transfer { account_id, amount, is_approval: approved };
        let data = self.data_mut();

        if let Some(tt) = data.token_transfers.iter_mut().find(|tt| tt.token_id == token_id) {
            tt.expected_decimals = expected_decimals;
            tt.transfers.push(transfer);
        } else {
            data.token_transfers.push(TokenTransfer {
                token_id,
                expected_decimals,
                nft_transfers: Vec::new(),
                transfers: vec![transfer],
            });
        }

        self
    }

    /// Add a non-approved token transfer to the transaction.
    ///
    /// `amount` is in the lowest denomination for the token (if the token has `2` decimals this would be `0.01` tokens).
    pub fn token_transfer(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
    ) -> &mut Self {
        self._token_transfer(token_id, account_id, amount, false, None)
    }

    /// Add an approved token transfer to the transaction.
    ///
    /// `amount` is in the lowest denomination for the token (if the token has `2` decimals this would be `0.01` tokens).
    pub fn approved_token_transfer(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
    ) -> &mut Self {
        self._token_transfer(token_id, account_id, amount, true, None)
    }

    // todo: make the examples into code, just not sure how to do that.
    /// Add a non-approved token transfer to the transaction, ensuring that the token has `expected_decimals` decimals.
    ///
    /// `amount` is _still_ in the lowest denomination, however,
    /// you will get an error if the token has a different amount of decimals than `expected_decimals`.
    pub fn token_transfer_with_decimals(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
        expected_decimals: u32,
    ) -> &mut Self {
        self._token_transfer(token_id, account_id, amount, false, Some(expected_decimals))
    }

    /// Add an approved token transfer, ensuring that the token has `expected_decimals` decimals.
    ///
    /// `amount` is _still_ in the lowest denomination, however,
    /// you will get an error if the token has a different amount of decimals than `expected_decimals`.
    pub fn approved_token_transfer_with_decimals(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        amount: i64,
        expected_decimals: u32,
    ) -> &mut Self {
        self._token_transfer(token_id, account_id, amount, true, Some(expected_decimals))
    }

    /// Returns all the token transfers associated associated with this transaction.
    pub fn get_token_transfers(&self) -> HashMap<TokenId, HashMap<AccountId, i64>> {
        use std::collections::hash_map::Entry;

        // note: using fold instead of nested collects on the off chance a token is in here twice.
        self.data().token_transfers.iter().fold(
            HashMap::with_capacity(self.data().token_transfers.len()),
            |mut map, transfer| {
                let iter = transfer.transfers.iter().map(|it| (it.account_id, it.amount));
                match map.entry(transfer.token_id) {
                    Entry::Occupied(mut it) => it.get_mut().extend(iter),
                    Entry::Vacant(it) => {
                        it.insert(iter.collect());
                    }
                }

                map
            },
        )
    }

    /// Returns the decimals associated with each token.
    pub fn get_token_decimals(&self) -> HashMap<TokenId, u32> {
        self.data()
            .token_transfers
            .iter()
            .filter_map(|it| it.expected_decimals.map(|decimals| (it.token_id, decimals)))
            .collect()
    }

    fn _nft_transfer(
        &mut self,
        nft_id: NftId,
        sender_account_id: AccountId,
        receiver_account_id: AccountId,
        approved: bool,
    ) -> &mut Self {
        let NftId { token_id, serial } = nft_id;
        let transfer = TokenNftTransfer {
            token_id,
            serial,
            sender: sender_account_id,
            receiver: receiver_account_id,
            is_approved: approved,
        };

        let data = self.data_mut();

        if let Some(tt) = data.token_transfers.iter_mut().find(|tt| tt.token_id == token_id) {
            tt.nft_transfers.push(transfer);
        } else {
            data.token_transfers.push(TokenTransfer {
                token_id,
                expected_decimals: None,
                transfers: Vec::new(),
                nft_transfers: vec![transfer],
            });
        }

        self
    }

    /// Add an approved nft transfer to the transaction.
    pub fn approved_nft_transfer(
        &mut self,
        nft_id: impl Into<NftId>,
        sender_account_id: AccountId,
        receiver_account_id: AccountId,
    ) -> &mut Self {
        self._nft_transfer(nft_id.into(), sender_account_id, receiver_account_id, true)
    }

    /// Add a non-approved nft transfer to the transaction.
    pub fn nft_transfer(
        &mut self,
        nft_id: impl Into<NftId>,
        sender_account_id: AccountId,
        receiver_account_id: AccountId,
    ) -> &mut Self {
        self._nft_transfer(nft_id.into(), sender_account_id, receiver_account_id, false)
    }

    /// Returns all the NFT transfers associated with this transaction.
    pub fn get_nft_transfers(&self) -> HashMap<TokenId, Vec<TokenNftTransfer>> {
        self.data()
            .token_transfers
            .iter()
            .map(|it| (it.token_id, it.nft_transfers.clone()))
            .collect()
    }
}

impl TransactionExecute for TransferTransactionData {
    // noinspection DuplicatedCode
    fn execute(
        &self,
        channel: Channel,
        request: services::Transaction,
    ) -> BoxGrpcFuture<'_, services::TransactionResponse> {
        Box::pin(async { CryptoServiceClient::new(channel).crypto_transfer(request).await })
    }
}

impl TransactionData for TransferTransactionData {}

impl ValidateChecksums for TransferTransactionData {
    fn validate_checksums(&self, ledger_id: &RefLedgerId) -> Result<(), Error> {
        for transfer in &self.transfers {
            transfer.account_id.validate_checksums(ledger_id)?;
        }
        for token_transfer in &self.token_transfers {
            token_transfer.token_id.validate_checksums(ledger_id)?;
            for transfer in &token_transfer.transfers {
                transfer.account_id.validate_checksums(ledger_id)?;
            }
            for nft_transfer in &token_transfer.nft_transfers {
                nft_transfer.sender.validate_checksums(ledger_id)?;
                nft_transfer.receiver.validate_checksums(ledger_id)?;
            }
        }
        Ok(())
    }
}

impl FromProtobuf<services::AccountAmount> for Transfer {
    fn from_protobuf(pb: services::AccountAmount) -> crate::Result<Self> {
        Ok(Self {
            amount: pb.amount,
            account_id: AccountId::from_protobuf(pb_getf!(pb, account_id)?)?,
            is_approval: pb.is_approval,
        })
    }
}

impl ToProtobuf for Transfer {
    type Protobuf = services::AccountAmount;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::AccountAmount {
            amount: self.amount,
            account_id: Some(self.account_id.to_protobuf()),
            is_approval: self.is_approval,
        }
    }
}

impl FromProtobuf<services::TokenTransferList> for TokenTransfer {
    fn from_protobuf(pb: services::TokenTransferList) -> crate::Result<Self> {
        let token_id = TokenId::from_protobuf(pb_getf!(pb, token)?)?;

        Ok(Self {
            token_id,
            transfers: Vec::from_protobuf(pb.transfers)?,
            nft_transfers: pb
                .nft_transfers
                .into_iter()
                .map(|pb| TokenNftTransfer::from_protobuf(pb, token_id))
                .collect::<Result<Vec<_>, _>>()?,
            expected_decimals: pb.expected_decimals,
        })
    }
}

impl ToProtobuf for TokenTransfer {
    type Protobuf = services::TokenTransferList;

    fn to_protobuf(&self) -> Self::Protobuf {
        let transfers = self.transfers.to_protobuf();
        let nft_transfers = self.nft_transfers.to_protobuf();

        services::TokenTransferList {
            token: Some(self.token_id.to_protobuf()),
            transfers,
            nft_transfers,
            expected_decimals: self.expected_decimals,
        }
    }
}

impl ToProtobuf for TokenNftTransfer {
    type Protobuf = services::NftTransfer;

    fn to_protobuf(&self) -> Self::Protobuf {
        services::NftTransfer {
            sender_account_id: Some(self.sender.to_protobuf()),
            receiver_account_id: Some(self.receiver.to_protobuf()),
            serial_number: self.serial as i64,
            is_approval: self.is_approved,
        }
    }
}

impl ToTransactionDataProtobuf for TransferTransactionData {
    fn to_transaction_data_protobuf(
        &self,
        chunk_info: &ChunkInfo,
    ) -> services::transaction_body::Data {
        let _ = chunk_info.assert_single_transaction();

        services::transaction_body::Data::CryptoTransfer(self.to_protobuf())
    }
}

impl ToSchedulableTransactionDataProtobuf for TransferTransactionData {
    fn to_schedulable_transaction_data_protobuf(
        &self,
    ) -> services::schedulable_transaction_body::Data {
        services::schedulable_transaction_body::Data::CryptoTransfer(self.to_protobuf())
    }
}

impl From<TransferTransactionData> for AnyTransactionData {
    fn from(transaction: TransferTransactionData) -> Self {
        Self::Transfer(transaction)
    }
}

impl FromProtobuf<services::CryptoTransferTransactionBody> for TransferTransactionData {
    fn from_protobuf(pb: services::CryptoTransferTransactionBody) -> crate::Result<Self> {
        let transfers = pb.transfers.map(|it| it.account_amounts);
        let transfers = Option::from_protobuf(transfers)?.unwrap_or_default();

        Ok(Self { transfers, token_transfers: Vec::from_protobuf(pb.token_transfers)? })
    }
}

impl ToProtobuf for TransferTransactionData {
    type Protobuf = services::CryptoTransferTransactionBody;

    fn to_protobuf(&self) -> Self::Protobuf {
        let transfers = self
            .transfers
            .is_empty()
            .not()
            .then(|| services::TransferList { account_amounts: self.transfers.to_protobuf() });

        let token_transfers = self.token_transfers.to_protobuf();

        services::CryptoTransferTransactionBody { transfers, token_transfers }
    }
}

#[cfg(test)]
mod tests {
    use expect_test::expect;

    use crate::transaction::test_helpers::{
        check_body,
        transaction_body,
    };
    use crate::{
        AccountId,
        AnyTransaction,
        Hbar,
        TokenId,
        TransferTransaction,
    };

    fn make_transaction() -> TransferTransaction {
        let mut tx = TransferTransaction::new_for_tests();

        tx.hbar_transfer(AccountId::new(0, 0, 5008), Hbar::from_tinybars(400))
            .hbar_transfer(AccountId::new(0, 0, 5006), Hbar::from_tinybars(800).negated())
            .approved_hbar_transfer(AccountId::new(0, 0, 5007), Hbar::from_tinybars(400))
            .token_transfer(TokenId::new(0, 0, 5), AccountId::new(0, 0, 5008), 400)
            .token_transfer_with_decimals(
                TokenId::new(0, 0, 5),
                AccountId::new(0, 0, 5006),
                -800,
                3,
            )
            .token_transfer_with_decimals(TokenId::new(0, 0, 5), AccountId::new(0, 0, 5007), 400, 3)
            .token_transfer(TokenId::new(0, 0, 4), AccountId::new(0, 0, 5008), 1)
            .approved_token_transfer(TokenId::new(0, 0, 4), AccountId::new(0, 0, 5006), -1)
            .nft_transfer(
                TokenId::new(0, 0, 3).nft(2),
                AccountId::new(0, 0, 5008),
                AccountId::new(0, 0, 5007),
            )
            .approved_nft_transfer(
                TokenId::new(0, 0, 3).nft(1),
                AccountId::new(0, 0, 5008),
                AccountId::new(0, 0, 5007),
            )
            .nft_transfer(
                TokenId::new(0, 0, 3).nft(3),
                AccountId::new(0, 0, 5008),
                AccountId::new(0, 0, 5006),
            )
            .nft_transfer(
                TokenId::new(0, 0, 3).nft(4),
                AccountId::new(0, 0, 5007),
                AccountId::new(0, 0, 5006),
            )
            .nft_transfer(
                TokenId::new(0, 0, 2).nft(4),
                AccountId::new(0, 0, 5007),
                AccountId::new(0, 0, 5006),
            )
            .freeze()
            .unwrap();

        tx
    }

    #[test]
    fn serialize() {
        let tx = make_transaction();

        let tx = transaction_body(tx);

        let tx = check_body(tx);

        expect![[r#"
            CryptoTransfer(
                CryptoTransferTransactionBody {
                    transfers: Some(
                        TransferList {
                            account_amounts: [
                                AccountAmount {
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5008,
                                                ),
                                            ),
                                        },
                                    ),
                                    amount: 400,
                                    is_approval: false,
                                },
                                AccountAmount {
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5006,
                                                ),
                                            ),
                                        },
                                    ),
                                    amount: -800,
                                    is_approval: false,
                                },
                                AccountAmount {
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5007,
                                                ),
                                            ),
                                        },
                                    ),
                                    amount: 400,
                                    is_approval: true,
                                },
                            ],
                        },
                    ),
                    token_transfers: [
                        TokenTransferList {
                            token: Some(
                                TokenId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    token_num: 5,
                                },
                            ),
                            transfers: [
                                AccountAmount {
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5008,
                                                ),
                                            ),
                                        },
                                    ),
                                    amount: 400,
                                    is_approval: false,
                                },
                                AccountAmount {
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5006,
                                                ),
                                            ),
                                        },
                                    ),
                                    amount: -800,
                                    is_approval: false,
                                },
                                AccountAmount {
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5007,
                                                ),
                                            ),
                                        },
                                    ),
                                    amount: 400,
                                    is_approval: false,
                                },
                            ],
                            nft_transfers: [],
                            expected_decimals: Some(
                                3,
                            ),
                        },
                        TokenTransferList {
                            token: Some(
                                TokenId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    token_num: 4,
                                },
                            ),
                            transfers: [
                                AccountAmount {
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5008,
                                                ),
                                            ),
                                        },
                                    ),
                                    amount: 1,
                                    is_approval: false,
                                },
                                AccountAmount {
                                    account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5006,
                                                ),
                                            ),
                                        },
                                    ),
                                    amount: -1,
                                    is_approval: true,
                                },
                            ],
                            nft_transfers: [],
                            expected_decimals: None,
                        },
                        TokenTransferList {
                            token: Some(
                                TokenId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    token_num: 3,
                                },
                            ),
                            transfers: [],
                            nft_transfers: [
                                NftTransfer {
                                    sender_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5008,
                                                ),
                                            ),
                                        },
                                    ),
                                    receiver_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5007,
                                                ),
                                            ),
                                        },
                                    ),
                                    serial_number: 2,
                                    is_approval: false,
                                },
                                NftTransfer {
                                    sender_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5008,
                                                ),
                                            ),
                                        },
                                    ),
                                    receiver_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5007,
                                                ),
                                            ),
                                        },
                                    ),
                                    serial_number: 1,
                                    is_approval: true,
                                },
                                NftTransfer {
                                    sender_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5008,
                                                ),
                                            ),
                                        },
                                    ),
                                    receiver_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5006,
                                                ),
                                            ),
                                        },
                                    ),
                                    serial_number: 3,
                                    is_approval: false,
                                },
                                NftTransfer {
                                    sender_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5007,
                                                ),
                                            ),
                                        },
                                    ),
                                    receiver_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5006,
                                                ),
                                            ),
                                        },
                                    ),
                                    serial_number: 4,
                                    is_approval: false,
                                },
                            ],
                            expected_decimals: None,
                        },
                        TokenTransferList {
                            token: Some(
                                TokenId {
                                    shard_num: 0,
                                    realm_num: 0,
                                    token_num: 2,
                                },
                            ),
                            transfers: [],
                            nft_transfers: [
                                NftTransfer {
                                    sender_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5007,
                                                ),
                                            ),
                                        },
                                    ),
                                    receiver_account_id: Some(
                                        AccountId {
                                            shard_num: 0,
                                            realm_num: 0,
                                            account: Some(
                                                AccountNum(
                                                    5006,
                                                ),
                                            ),
                                        },
                                    ),
                                    serial_number: 4,
                                    is_approval: false,
                                },
                            ],
                            expected_decimals: None,
                        },
                    ],
                },
            )
        "#]]
        .assert_debug_eq(&tx)
    }

    #[test]
    fn to_from_bytes() {
        let tx = make_transaction();

        let tx2 = AnyTransaction::from_bytes(&tx.to_bytes().unwrap()).unwrap();

        let tx = transaction_body(tx);

        let tx2 = transaction_body(tx2);

        assert_eq!(tx, tx2);
    }

    #[test]
    fn get_decimals() {
        let mut tx = TransferTransaction::new();
        const TOKEN: TokenId = TokenId::new(0, 0, 5);

        assert_eq!(tx.get_token_decimals().get(&TOKEN), None);

        tx.token_transfer(TOKEN, AccountId::new(0, 0, 8), 100);
        assert_eq!(tx.get_token_decimals().get(&TOKEN), None);

        tx.token_transfer_with_decimals(TOKEN, AccountId::new(0, 0, 7), -100, 5);
        assert_eq!(tx.get_token_decimals().get(&TOKEN), Some(&5));
    }
}
// Filename: tck/src/errors.rs
use hedera::Error;
use jsonrpsee::types::error::INTERNAL_ERROR_CODE;
use jsonrpsee::types::{
    ErrorObject,
    ErrorObjectOwned,
};
use serde_json::json;

pub(crate) const HEDERA_ERROR: i32 = -32001;

pub fn from_hedera_error(error: Error) -> ErrorObjectOwned {
    match error {
        Error::QueryPreCheckStatus { status, .. }
        | Error::ReceiptStatus { status, .. }
        | Error::TransactionPreCheckStatus { status, .. } => ErrorObject::owned(
            HEDERA_ERROR,
            "Hiero error".to_string(),
            Some(json!({
                "status": status.as_str_name().to_string(),
                "message": error.to_string(),
            })),
        ),
        _ => ErrorObject::owned(INTERNAL_ERROR_CODE, error.to_string(), None::<()>),
    }
}
// Filename: tck/src/helpers.rs
use std::collections::HashMap;
use std::str::FromStr;

use hedera::{
    AccountId,
    Hbar,
    Key,
    KeyList,
    PrivateKey,
    PublicKey,
    Transaction,
    TransactionId,
};
use hex::ToHex;
use jsonrpsee::types::error::INVALID_PARAMS_CODE;
use jsonrpsee::types::{
    ErrorObject,
    ErrorObjectOwned,
};
use serde_json::Value;
use time::Duration;

#[derive(Clone, Debug, Copy, PartialEq, Eq)]
pub enum KeyType {
    Ed25519PrivateKeyType,
    Ed25519PublicKeyType,
    EcdsaSecp256k1PrivateKeyType,
    EcdsaSecp256k1PublicKeyType,
    KeyListType,
    ThresholdKeyType,
    EvmAddressType,
}

impl FromStr for KeyType {
    type Err = ErrorObjectOwned;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "ed25519PrivateKey" => Ok(KeyType::Ed25519PrivateKeyType),
            "ed25519PublicKey" => Ok(KeyType::Ed25519PublicKeyType),
            "ecdsaSecp256k1PrivateKey" => Ok(KeyType::EcdsaSecp256k1PrivateKeyType),
            "ecdsaSecp256k1PublicKey" => Ok(KeyType::EcdsaSecp256k1PublicKeyType),
            "keyList" => Ok(KeyType::KeyListType),
            "thresholdKey" => Ok(KeyType::ThresholdKeyType),
            "evmAddress" => Ok(KeyType::EvmAddressType),
            _ => Err(ErrorObject::borrowed(-32603, "generateKey: type is NOT a valid value", None)),
        }
    }
}

pub(crate) fn fill_common_transaction_params<D>(
    transaction: &mut Transaction<D>,
    common_transaction_params: &HashMap<String, Value>,
) {
    if let Some(transaction_id) = common_transaction_params.get("transactionId") {
        match transaction_id {
            Value::String(transaction_id) => {
                transaction
                    .transaction_id(TransactionId::from_str(transaction_id.as_str()).unwrap());
            }
            _ => {}
        }
    }

    if let Some(node_id) = common_transaction_params.get("nodeId") {
        match node_id {
            Value::String(node_id) => {
                transaction.node_account_ids([AccountId::from_str(&node_id.as_str()).unwrap()]);
            }
            _ => {}
        }
    }

    if let Some(max_fee) = common_transaction_params.get("maxTransactionFee") {
        match max_fee {
            Value::String(max_fee) => {
                transaction.max_transaction_fee(Hbar::from_tinybars(
                    max_fee.as_str().parse::<i64>().unwrap(),
                ));
            }
            _ => {}
        }
    }

    if let Some(transaction_valid_duration) =
        common_transaction_params.get("transactionValidDuration")
    {
        match transaction_valid_duration {
            Value::String(transaction_valid_duration) => {
                transaction.transaction_valid_duration(Duration::seconds(
                    transaction_valid_duration.as_str().parse::<i64>().unwrap(),
                ));
            }
            _ => {}
        }
    }

    if let Some(memo) = common_transaction_params.get("memo") {
        match memo {
            Value::String(memo) => {
                transaction.transaction_memo(memo.as_str());
            }
            _ => {}
        }
    }
}

pub(crate) fn generate_key_helper(
    _type: String,
    from_key: Option<String>,
    threshold: Option<i32>,
    keys: Option<Value>,
    private_keys: &mut Vec<Value>,
    is_list: bool,
) -> Result<String, ErrorObjectOwned> {
    // Check the key type
    let key_type = KeyType::from_str(&_type)?;

    if from_key.is_some()
        && key_type != KeyType::Ed25519PublicKeyType
        && key_type != KeyType::EcdsaSecp256k1PublicKeyType
        && key_type != KeyType::EvmAddressType
    {
        return Err(ErrorObject::borrowed(INVALID_PARAMS_CODE, "generateKey: fromKey MUST NOT be provided for types other than ed25519PublicKey, ecdsaSecp256k1PublicKey, or evmAddress.", None));
    }

    if threshold.is_some() && key_type != KeyType::ThresholdKeyType {
        return Err(ErrorObject::borrowed(
            INVALID_PARAMS_CODE,
            "generateKey: threshold MUST NOT be provided for types other than thresholdKey.",
            None,
        ));
    } else if threshold.is_none() && key_type == KeyType::ThresholdKeyType {
        return Err(ErrorObject::borrowed(
            INVALID_PARAMS_CODE,
            "generateKey: threshold MUST be provided for thresholdKey types.",
            None,
        ));
    };

    if keys.is_some() && key_type != KeyType::ThresholdKeyType && key_type != KeyType::KeyListType {
        return Err(ErrorObject::borrowed(
            INVALID_PARAMS_CODE,
            "generateKey: keys MUST NOT be provided for types other than keyList or thresholdKey.",
            None,
        ));
    } else if keys.is_none()
        && (key_type == KeyType::ThresholdKeyType || key_type == KeyType::KeyListType)
    {
        return Err(ErrorObject::borrowed(
            INVALID_PARAMS_CODE,
            "generateKey: keys MUST be provided for keyList and thresholdKey types.",
            None,
        ));
    };

    match key_type {
        KeyType::Ed25519PrivateKeyType | KeyType::EcdsaSecp256k1PrivateKeyType => {
            let key = if key_type == KeyType::Ed25519PublicKeyType {
                PrivateKey::generate_ed25519().to_string_der()
            } else {
                PrivateKey::generate_ecdsa().to_string_der()
            };

            if is_list {
                private_keys.push(Value::String(key.clone()));
            }

            return Ok(key);
        }
        KeyType::Ed25519PublicKeyType | KeyType::EcdsaSecp256k1PublicKeyType => {
            if let Some(from_key) = from_key {
                return PrivateKey::from_str_der(&from_key)
                    .map(|key| key.public_key().to_string_der())
                    .map_err(|_| {
                        ErrorObject::borrowed(
                            INVALID_PARAMS_CODE,
                            "generateKey: could not produce {key_type:?}",
                            None,
                        )
                    });
            };

            let key = if key_type == KeyType::Ed25519PublicKeyType {
                PrivateKey::generate_ed25519()
            } else {
                PrivateKey::generate_ecdsa()
            };

            if is_list {
                private_keys.push(Value::String(key.to_string_der()));
            }

            return Ok(key.public_key().to_string_der());
        }
        KeyType::KeyListType | KeyType::ThresholdKeyType => {
            let mut key_list = KeyList::new();

            if let Value::Array(key_array) = keys.unwrap() {
                for key in key_array {
                    let generate_key = &generate_key_helper(
                        key["type"].as_str().unwrap().to_string(),
                        None,
                        None,
                        key.get("keys").map(|value| value.clone()),
                        private_keys,
                        true,
                    )?;

                    let get_key = get_hedera_key(&generate_key)?;

                    key_list.keys.push(get_key);
                }
            }

            if KeyType::from_str(&_type)? == KeyType::ThresholdKeyType {
                key_list.threshold = Some(threshold.unwrap() as u32);
            }

            return Ok(Key::KeyList(key_list).to_bytes().encode_hex());
        }
        KeyType::EvmAddressType => {
            if from_key.is_none() {
                return Ok(PrivateKey::generate_ecdsa()
                    .public_key()
                    .to_evm_address()
                    .unwrap()
                    .to_string());
            }

            let private_key = PrivateKey::from_str_ecdsa(&from_key.clone().unwrap());

            match private_key {
                Ok(key) => {
                    return Ok(key.public_key().to_evm_address().unwrap().to_string());
                }
                Err(_) => {
                    let private_key = PublicKey::from_str_ecdsa(&from_key.unwrap());

                    match private_key {
                        Ok(key) => {
                            return Ok(key.to_evm_address().unwrap().to_string());
                        }
                        Err(_) => {
                            return Err(ErrorObject::borrowed(INVALID_PARAMS_CODE, "generateKey: fromKey for evmAddress MUST be an ECDSAsecp256k1 private or public key.", None));
                        }
                    }
                }
            }
        }
    }
}

pub(crate) fn get_hedera_key(key: &str) -> Result<Key, ErrorObjectOwned> {
    match PrivateKey::from_str_der(key).map(|pk| Key::Single(pk.public_key())) {
        Ok(key) => Ok(key),
        Err(_) => match PublicKey::from_str_der(key).map(Key::Single) {
            Ok(key) => Ok(key),
            Err(_) => {
                let public_key = PublicKey::from_str_ed25519(key).map_err(|_| {
                    ErrorObject::borrowed(-32603, "generateKey: fromKey is invalid.", None)
                })?;

                Ok(public_key.into())
            }
        },
    }
}
// Filename: tck/src/main.rs
use std::net::SocketAddr;
use std::sync::atomic::{
    AtomicBool,
    AtomicUsize,
    Ordering,
};
use std::sync::Arc;

use futures_util::future::BoxFuture;
use jsonrpsee::server::middleware::rpc::{
    RpcService,
    RpcServiceT,
};
use jsonrpsee::server::{
    RpcServiceBuilder,
    Server,
};
use jsonrpsee::types::Request;
use jsonrpsee::MethodResponse;
use methods::{
    RpcServer,
    RpcServerImpl,
};
use tokio::signal;

mod errors;
mod helpers;
pub(crate) mod methods;
mod responses;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt().init();

    let server_addr = run_server().await?;
    let url = format!("http://{}", server_addr);

    tracing::info!("Server is running at {}", url);

    let running = Arc::new(AtomicBool::new(true));
    let running_clone = running.clone();

    let ctrl_c_future = async {
        signal::ctrl_c().await.expect("failed to install Ctrl+C handler");
        running_clone.store(false, Ordering::SeqCst);
    };

    tokio::select! {
        _ = ctrl_c_future => {}
        _ = tokio::signal::ctrl_c() => {}
    }

    Ok(())
}

async fn run_server() -> anyhow::Result<SocketAddr> {
    let m = RpcServiceBuilder::new().layer_fn(move |service: RpcService| TckMiddleware {
        service,
        count: Arc::new(AtomicUsize::new(0)),
    });

    let server = Server::builder().set_rpc_middleware(m).build("127.0.0.1:8544").await?;

    let addr = server.local_addr()?;
    let handle = server.start(RpcServerImpl.into_rpc());

    tokio::spawn(handle.stopped());

    Ok(addr)
}

#[derive(Clone)]
struct TckMiddleware<S> {
    service: S,
    count: Arc<AtomicUsize>,
}

impl<'a, S> RpcServiceT<'a> for TckMiddleware<S>
where
    S: RpcServiceT<'a> + Send + Sync + Clone + 'static,
{
    type Future = BoxFuture<'a, MethodResponse>;
    fn call(&self, req: Request<'a>) -> Self::Future {
        let count = self.count.clone();
        let service = self.service.clone();
        Box::pin(async move {
            let rp = service.call(req).await;
            count.fetch_add(1, Ordering::SeqCst);
            rp
        })
    }
}
// Filename: tck/src/methods.rs
use std::collections::HashMap;
use std::str::FromStr;
use std::sync::{
    Arc,
    Mutex,
};

use hedera::{
    AccountCreateTransaction,
    AccountId,
    AccountUpdateTransaction,
    Client,
    EvmAddress,
    Hbar,
    PrivateKey,
};
use jsonrpsee::core::async_trait;
use jsonrpsee::proc_macros::rpc;
use jsonrpsee::types::error::INTERNAL_ERROR_CODE;
use jsonrpsee::types::{
    ErrorObject,
    ErrorObjectOwned,
};
use once_cell::sync::Lazy;
use serde_json::Value;
use time::{
    Duration,
    OffsetDateTime,
};

use crate::errors::from_hedera_error;
use crate::helpers::{
    fill_common_transaction_params,
    generate_key_helper,
    get_hedera_key,
};
use crate::responses::{
    AccountCreateResponse,
    AccountUpdateResponse,
    GenerateKeyResponse,
};

static GLOBAL_SDK_CLIENT: Lazy<Arc<Mutex<Option<Client>>>> =
    Lazy::new(|| Arc::new(Mutex::new(None)));

#[rpc(server, client)]
pub trait Rpc {
    /*
    / Specification:
    / https://github.com/hiero-ledger/hiero-sdk-tck/blob/main/test-specifications/utility.md#generateKey
    */
    #[method(name = "generateKey")]
    fn generate_key(
        &self,
        _type: String,
        from_key: Option<String>,
        threshold: Option<i32>,
        keys: Option<Value>,
    ) -> Result<GenerateKeyResponse, ErrorObjectOwned>;

    /*
    / Specification:
    / https://github.com/hiero-ledger/hiero-sdk-tck/blob/main/test-specifications/utility.md#setup
    */
    #[method(name = "setup")]
    fn setup(
        &self,
        operator_account_id: Option<String>,
        operator_private_key: Option<String>,
        node_ip: Option<String>,
        node_account_id: Option<String>,
        mirror_network_ip: Option<String>,
    ) -> Result<String, ErrorObjectOwned>;

    /*
    / Specification:
    / https://github.com/hiero-ledger/hiero-sdk-tck/blob/main/test-specifications/utility.md#reset
    */
    #[method(name = "reset")]
    fn reset(&self) -> Result<HashMap<String, String>, ErrorObjectOwned>;

    /*
    / Specification:
    / https://github.com/hiero-ledger/hiero-sdk-tck/blob/main/test-specifications/crypto-service/accountCreateTransaction.md#createAccount
    */
    #[method(name = "createAccount")]
    async fn create_account(
        &self,
        key: Option<String>,
        initial_balance: Option<i64>,
        receiver_signature_required: Option<bool>,
        auto_renew_period: Option<i64>,
        memo: Option<String>,
        max_auto_token_associations: Option<i64>,
        staked_account_id: Option<String>,
        staked_node_id: Option<i64>,
        decline_staking_reward: Option<bool>,
        alias: Option<String>,
        common_transaction_params: Option<HashMap<String, Value>>,
    ) -> Result<AccountCreateResponse, ErrorObjectOwned>;

    /*
    / Specification:
    / https://github.com/hiero-ledger/hiero-sdk-tck/blob/main/test-specifications/crypto-service/accountUpdateTransaction.md#updateAccount
    */
    #[method(name = "updateAccount")]
    async fn update_account(
        &self,
        account_id: Option<String>,
        key: Option<String>,
        auto_renew_period: Option<i64>,
        expiration_time: Option<i64>,
        receiver_signature_required: Option<bool>,
        memo: Option<String>,
        max_auto_token_associations: Option<i64>,
        staked_account_id: Option<String>,
        staked_node_id: Option<i64>,
        decline_staking_reward: Option<bool>,
        common_transaction_params: Option<HashMap<String, Value>>,
    ) -> Result<AccountUpdateResponse, ErrorObjectOwned>;
}

pub struct RpcServerImpl;

#[async_trait]
impl RpcServer for RpcServerImpl {
    fn setup(
        &self,
        operator_account_id: Option<String>,
        operator_private_key: Option<String>,
        node_ip: Option<String>,
        node_account_id: Option<String>,
        mirror_network_ip: Option<String>,
    ) -> Result<String, ErrorObjectOwned> {
        let mut network: HashMap<String, AccountId> = HashMap::new();

        // Client setup, if the network is not set, it will be created using testnet.
        // If the network is manually set, the network will be configured using the
        // provided ips and account id.
        let client = match (node_ip, node_account_id, mirror_network_ip) {
            (Some(node_ip), Some(node_account_id), Some(mirror_network_ip)) => {
                let account_id = AccountId::from_str(node_account_id.as_str()).map_err(|e| {
                    ErrorObject::owned(INTERNAL_ERROR_CODE, e.to_string(), None::<()>)
                })?;
                network.insert(node_ip, account_id);

                let client = Client::for_network(network).map_err(|e| {
                    ErrorObject::owned(INTERNAL_ERROR_CODE, e.to_string(), None::<()>)
                })?;
                client.set_mirror_network([mirror_network_ip]);
                client
            }
            (None, None, None) => Client::for_testnet(),
            _ => {
                return Err(ErrorObject::borrowed(
                    INTERNAL_ERROR_CODE,
                    "Failed to setup client",
                    None,
                ))
            }
        };

        let operator_id = if let Some(operator_account_id) = operator_account_id {
            AccountId::from_str(operator_account_id.as_str())
                .map_err(|e| ErrorObject::owned(INTERNAL_ERROR_CODE, e.to_string(), None::<()>))?
        } else {
            return Err(ErrorObject::borrowed(
                INTERNAL_ERROR_CODE,
                "Missing operator account id",
                None,
            ));
        };

        let operator_key = if let Some(operator_private_key) = operator_private_key {
            PrivateKey::from_str(operator_private_key.as_str())
                .map_err(|e| ErrorObject::owned(INTERNAL_ERROR_CODE, e.to_string(), None::<()>))?
        } else {
            return Err(ErrorObject::borrowed(
                INTERNAL_ERROR_CODE,
                "Missing operator private key",
                None,
            ));
        };

        client.set_operator(operator_id, operator_key);

        let mut global_client = GLOBAL_SDK_CLIENT.lock().unwrap();
        *global_client = Some(client);

        Ok("SUCCESS".to_owned())
    }

    fn reset(&self) -> Result<HashMap<String, String>, ErrorObjectOwned> {
        let mut global_client = GLOBAL_SDK_CLIENT.lock().unwrap();
        *global_client = None;
        Ok(HashMap::from([("status".to_string(), "SUCCESS".to_string())].to_owned()))
    }

    fn generate_key(
        &self,
        _type: String,
        from_key: Option<String>,
        threshold: Option<i32>,
        keys: Option<Value>,
    ) -> Result<GenerateKeyResponse, ErrorObjectOwned> {
        let mut private_keys: Vec<Value> = Vec::new();

        let key = generate_key_helper(_type, from_key, threshold, keys, &mut private_keys, false)?;

        Ok(GenerateKeyResponse { key: key, private_keys: private_keys })
    }

    async fn create_account(
        &self,
        key: Option<String>,
        initial_balance: Option<i64>,
        receiver_signature_required: Option<bool>,
        auto_renew_period: Option<i64>,
        memo: Option<String>,
        max_auto_token_associations: Option<i64>,
        staked_account_id: Option<String>,
        staked_node_id: Option<i64>,
        decline_staking_reward: Option<bool>,
        alias: Option<String>,
        common_transaction_params: Option<HashMap<String, Value>>,
    ) -> Result<AccountCreateResponse, ErrorObjectOwned> {
        let client = {
            let guard = GLOBAL_SDK_CLIENT.lock().unwrap();
            guard
                .as_ref()
                .ok_or_else(|| {
                    ErrorObject::owned(
                        INTERNAL_ERROR_CODE,
                        "Client not initialized".to_string(),
                        None::<()>,
                    )
                })?
                .clone()
        };

        let mut account_create_tx = AccountCreateTransaction::new();

        if let Some(key) = key {
            let key = get_hedera_key(&key)?;

            account_create_tx.key(key);
        }

        if let Some(initial_balance) = initial_balance {
            account_create_tx.initial_balance(Hbar::from_tinybars(initial_balance));
        }

        if let Some(receiver_signature_required) = receiver_signature_required {
            account_create_tx.receiver_signature_required(receiver_signature_required);
        }

        if let Some(auto_renew_period) = auto_renew_period {
            account_create_tx.auto_renew_period(Duration::seconds(auto_renew_period));
        }

        if let Some(memo) = memo {
            account_create_tx.account_memo(memo);
        }

        if let Some(max_auto_token_associations) = max_auto_token_associations {
            account_create_tx.max_automatic_token_associations(max_auto_token_associations as i32);
        }

        if let Some(staked_account_id) = staked_account_id {
            account_create_tx.staked_account_id(
                AccountId::from_str(&staked_account_id).map_err(|e| {
                    ErrorObject::owned(INTERNAL_ERROR_CODE, e.to_string(), None::<()>)
                })?,
            );
        }

        if let Some(alias) = alias {
            account_create_tx.alias(
                EvmAddress::from_str(&alias).map_err(|e| {
                    ErrorObject::owned(INTERNAL_ERROR_CODE, e.to_string(), None::<()>)
                })?,
            );
        }

        if let Some(staked_node_id) = staked_node_id {
            account_create_tx.staked_node_id(staked_node_id as u64);
        }

        if let Some(decline_staking_reward) = decline_staking_reward {
            account_create_tx.decline_staking_reward(decline_staking_reward);
        }

        if let Some(common_transaction_params) = common_transaction_params {
            let _ =
                fill_common_transaction_params(&mut account_create_tx, &common_transaction_params);

            account_create_tx.freeze_with(&client).unwrap();

            if let Some(signers) = common_transaction_params.get("signers") {
                if let Value::Array(signers) = signers {
                    for signer in signers {
                        if let Value::String(signer_str) = signer {
                            account_create_tx.sign(PrivateKey::from_str_der(signer_str).unwrap());
                        }
                    }
                }
            }
        }

        let tx_response =
            account_create_tx.execute(&client).await.map_err(|e| from_hedera_error(e))?;

        let tx_receipt =
            tx_response.get_receipt(&client).await.map_err(|e| from_hedera_error(e))?;

        Ok(AccountCreateResponse {
            account_id: tx_receipt.account_id.unwrap().to_string(),
            status: tx_receipt.status.as_str_name().to_string(),
        })
    }

    async fn update_account(
        &self,
        account_id: Option<String>,
        key: Option<String>,
        auto_renew_period: Option<i64>,
        expiration_time: Option<i64>,
        receiver_signature_required: Option<bool>,
        memo: Option<String>,
        max_auto_token_associations: Option<i64>,
        staked_account_id: Option<String>,
        staked_node_id: Option<i64>,
        decline_staking_reward: Option<bool>,
        common_transaction_params: Option<HashMap<String, Value>>,
    ) -> Result<AccountUpdateResponse, ErrorObjectOwned> {
        let client = {
            let guard = GLOBAL_SDK_CLIENT.lock().unwrap();
            guard
                .as_ref()
                .ok_or_else(|| {
                    ErrorObject::owned(
                        INTERNAL_ERROR_CODE,
                        "Client not initialized".to_string(),
                        None::<()>,
                    )
                })?
                .clone()
        };

        let mut account_update_tx = AccountUpdateTransaction::new();

        if let Some(account_id) = account_id {
            account_update_tx.account_id(account_id.parse().unwrap());
        }

        if let Some(key) = key {
            let key = get_hedera_key(&key)?;

            account_update_tx.key(key);
        }

        if let Some(receiver_signature_required) = receiver_signature_required {
            account_update_tx.receiver_signature_required(receiver_signature_required);
        }

        if let Some(auto_renew_period) = auto_renew_period {
            account_update_tx.auto_renew_period(Duration::seconds(auto_renew_period));
        }

        if let Some(expiration_time) = expiration_time {
            account_update_tx.expiration_time(
                OffsetDateTime::from_unix_timestamp(expiration_time).map_err(|e| {
                    ErrorObject::owned(INTERNAL_ERROR_CODE, e.to_string(), None::<()>)
                })?,
            );
        }

        if let Some(memo) = memo {
            account_update_tx.account_memo(memo);
        }

        if let Some(max_auto_token_associations) = max_auto_token_associations {
            account_update_tx.max_automatic_token_associations(max_auto_token_associations as i32);
        }

        if let Some(staked_account_id) = staked_account_id {
            account_update_tx.staked_account_id(
                AccountId::from_str(&staked_account_id).map_err(|e| {
                    ErrorObject::owned(INTERNAL_ERROR_CODE, e.to_string(), None::<()>)
                })?,
            );
        }

        if let Some(staked_node_id) = staked_node_id {
            account_update_tx.staked_node_id(staked_node_id as u64);
        }

        if let Some(decline_staking_reward) = decline_staking_reward {
            account_update_tx.decline_staking_reward(decline_staking_reward);
        }

        if let Some(common_transaction_params) = common_transaction_params {
            let _ =
                fill_common_transaction_params(&mut account_update_tx, &common_transaction_params);

            account_update_tx.freeze_with(&client).unwrap();

            if let Some(signers) = common_transaction_params.get("signers") {
                if let Value::Array(signers) = signers {
                    for signer in signers {
                        if let Value::String(signer_str) = signer {
                            account_update_tx.sign(PrivateKey::from_str_der(signer_str).unwrap());
                        }
                    }
                }
            }
        }

        let tx_response =
            account_update_tx.execute(&client).await.map_err(|e| from_hedera_error(e))?;

        let tx_receipt =
            tx_response.get_receipt(&client).await.map_err(|e| from_hedera_error(e))?;

        Ok(AccountUpdateResponse { status: tx_receipt.status.as_str_name().to_string() })
    }
}
// Filename: tck/src/responses.rs
use serde::{
    Deserialize,
    Serialize,
};
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountCreateResponse {
    pub account_id: String,
    pub status: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountUpdateResponse {
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GenerateKeyResponse {
    pub key: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub private_keys: Vec<Value>,
}
// Filename: tests/e2e/account/allowance_approve.rs
use hedera::{
    AccountAllowanceApproveTransaction,
    Hbar,
    TokenAssociateTransaction,
    TransactionId,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn spend() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(10), &client),
        Account::create(Hbar::new(10), &client)
    )?;

    AccountAllowanceApproveTransaction::new()
        .approve_hbar_allowance(bob.id, alice.id, Hbar::new(10))
        .freeze_with(&client)?
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let transfer_record = TransferTransaction::new()
        .hbar_transfer(client.get_operator_account_id().unwrap(), Hbar::new(5))
        .approved_hbar_transfer(bob.id, Hbar::new(-5))
        .transaction_id(TransactionId::generate(alice.id))
        .freeze_with(&client)?
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    assert!(transfer_record
        .transfers
        .iter()
        .any(|it| it.account_id == client.get_operator_account_id().unwrap()
            && it.amount == Hbar::new(5)));

    let _ = tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn nft_allowance_no_association() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (treasury, spender) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(1), &client),
    )?;

    let receiver = Account::create(Hbar::new(0), &client).await?;

    let nft_collection = crate::token::Nft::create(&client, &treasury).await?;

    let serials = nft_collection.mint(&client, [b"asd"]).await?;

    let nft1 = nft_collection.id.nft(serials[0] as u64);

    AccountAllowanceApproveTransaction::new()
        .approve_token_nft_allowance(nft1, treasury.id, spender.id)
        .sign(treasury.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TokenAssociateTransaction::new()
        .account_id(receiver.id)
        .token_ids([nft_collection.id])
        .sign(receiver.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .approved_nft_transfer(nft1, treasury.id, receiver.id)
        .transaction_id(TransactionId::generate(spender.id))
        .sign(spender.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .nft_transfer(nft1, receiver.id, treasury.id)
        .sign(receiver.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    nft_collection.burn(&client, serials).await?;
    nft_collection.delete(&client).await?;

    let _ = tokio::try_join!(
        treasury.delete(&client),
        spender.delete(&client),
        receiver.delete(&client)
    )?;

    Ok(())
}

#[tokio::test]
async fn missing_nft_allowance_approval_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (treasury, spender) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(1), &client),
    )?;

    let nft_collection = crate::token::Nft::create(&client, &treasury).await?;

    TokenAssociateTransaction::new()
        .account_id(spender.id)
        .token_ids([nft_collection.id])
        .sign(spender.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let serials = nft_collection.mint(&client, [b"asd"]).await?;

    let nft1 = nft_collection.id.nft(serials[0] as u64);

    let res = TransferTransaction::new()
        .approved_nft_transfer(nft1, treasury.id, spender.id)
        .transaction_id(TransactionId::generate(spender.id))
        .sign(spender.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches::assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: hedera::Status::SpenderDoesNotHaveAllowance,
            ..
        })
    );

    nft_collection.burn(&client, serials).await?;
    nft_collection.delete(&client).await?;

    let _ = tokio::try_join!(treasury.delete(&client), spender.delete(&client),)?;

    Ok(())
}
// Filename: tests/e2e/account/allowance_delete.rs
use hedera::{
    AccountAllowanceApproveTransaction,
    AccountAllowanceDeleteTransaction,
    Hbar,
    TokenAssociateTransaction,
    TokenNftInfoQuery,
    TransactionId,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn transfer_after_allowance_remove_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let treasury = Account::create(Hbar::new(0), &client).await?;

    let (spender, receiver) = tokio::try_join!(
        Account::create(Hbar::new(1), &client),
        Account::create(Hbar::new(0), &client),
    )?;

    let nft_collection = crate::token::Nft::create(&client, &treasury).await?;

    TokenAssociateTransaction::new()
        .account_id(receiver.id)
        .token_ids([nft_collection.id])
        .sign(receiver.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let serials = nft_collection.mint(&client, [b"nft1", b"nft2"]).await?;

    let nft1 = nft_collection.id.nft(serials[0] as u64);
    let nft2 = nft_collection.id.nft(serials[1] as u64);

    AccountAllowanceApproveTransaction::new()
        .approve_token_nft_allowance(nft1, treasury.id, spender.id)
        .approve_token_nft_allowance(nft2, treasury.id, spender.id)
        .sign(treasury.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    AccountAllowanceDeleteTransaction::new()
        .delete_all_token_nft_allowances(nft2, treasury.id)
        .sign(treasury.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .approved_nft_transfer(nft1, treasury.id, receiver.id)
        .transaction_id(TransactionId::generate(spender.id))
        .sign(spender.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = TokenNftInfoQuery::new().nft_id(nft1).execute(&client).await?;

    assert_eq!(info.account_id, receiver.id);

    let res = TransferTransaction::new()
        .approved_nft_transfer(nft2, treasury.id, receiver.id)
        .transaction_id(TransactionId::generate(spender.id))
        .sign(spender.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches::assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: hedera::Status::SpenderDoesNotHaveAllowance,
            ..
        })
    );

    TransferTransaction::new()
        .nft_transfer(nft1, receiver.id, treasury.id)
        .sign(receiver.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    nft_collection.burn(&client, serials).await?;
    nft_collection.delete(&client).await?;

    let _ = tokio::try_join!(
        treasury.delete(&client),
        spender.delete(&client),
        receiver.delete(&client),
    )?;

    Ok(())
}

#[tokio::test]
async fn remove_single_serial_when_allowance_is_given_for_all_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let treasury = Account::create(Hbar::new(0), &client).await?;

    let (spender, receiver) = tokio::try_join!(
        Account::create(Hbar::new(1), &client),
        Account::create(Hbar::new(0), &client),
    )?;

    let nft_collection = crate::token::Nft::create(&client, &treasury).await?;

    TokenAssociateTransaction::new()
        .account_id(receiver.id)
        .token_ids([nft_collection.id])
        .sign(receiver.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let serials = nft_collection.mint(&client, [b"nft1", b"nft2"]).await?;

    let nft1 = nft_collection.id.nft(serials[0] as u64);
    let nft2 = nft_collection.id.nft(serials[1] as u64);

    AccountAllowanceApproveTransaction::new()
        .approve_token_nft_allowance_all_serials(nft_collection.id, treasury.id, spender.id)
        .sign(treasury.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .approved_nft_transfer(nft1, treasury.id, receiver.id)
        .transaction_id(TransactionId::generate(spender.id))
        .sign(spender.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // hopefully in the future this should end up with a precheck error provided from services
    AccountAllowanceDeleteTransaction::new()
        .delete_all_token_nft_allowances(nft2, treasury.id)
        .sign(treasury.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .approved_nft_transfer(nft2, treasury.id, receiver.id)
        .transaction_id(TransactionId::generate(spender.id))
        .sign(spender.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info_nft_1 = TokenNftInfoQuery::new().nft_id(nft1).execute(&client).await?;
    let info_nft_2 = TokenNftInfoQuery::new().nft_id(nft2).execute(&client).await?;

    assert_eq!(info_nft_1.account_id, receiver.id);
    assert_eq!(info_nft_2.account_id, receiver.id);

    TransferTransaction::new()
        .nft_transfer(nft1, receiver.id, treasury.id)
        .nft_transfer(nft2, receiver.id, treasury.id)
        .sign(receiver.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    nft_collection.burn(&client, serials).await?;
    nft_collection.delete(&client).await?;

    receiver.delete(&client).await?;
    spender.delete(&client).await?;
    treasury.delete(&client).await?;

    Ok(())
}
// Filename: tests/e2e/account/balance.rs
// todo(network tls):
// - canConnectToPreviewnetWithTLS
// - canConnectToTestnetWithTLS
// - canConnectToMainnetWithTLS
// - cannotConnectToPreviewnetWhenNetworkNameIsNullAndCertificateVerificationIsEnabled

use assert_matches::assert_matches;
use hedera::{
    AccountBalanceQuery,
    AccountId,
    Hbar,
    Status,
    TokenBurnTransaction,
    TokenCreateTransaction,
    TokenDeleteTransaction,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::account::Account;
use crate::common::{
    setup_global,
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn query() -> anyhow::Result<()> {
    let TestEnvironment { config, client } = setup_global();

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");

        return Ok(());
    };

    let balance = AccountBalanceQuery::new().account_id(op.account_id).execute(&client).await?;

    log::trace!("successfully queried balance: {balance:?}");

    anyhow::ensure!(balance.account_id == op.account_id);
    anyhow::ensure!(balance.hbars.to_tinybars() > 0);

    Ok(())
}

#[tokio::test]
async fn query_cost() -> anyhow::Result<()> {
    let TestEnvironment { config, client } = setup_global();

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");
        return Ok(());
    };

    let mut query = AccountBalanceQuery::new();

    query.account_id(op.account_id).max_payment_amount(Hbar::new(1));

    let cost = query.get_cost(&client).await?;

    assert_eq!(cost, Hbar::ZERO);

    let balance = query.payment_amount(cost).execute(&client).await?;

    anyhow::ensure!(balance.account_id == op.account_id);
    anyhow::ensure!(balance.hbars.to_tinybars() > 0);

    Ok(())
}

#[tokio::test]
async fn query_cost_big_max() -> anyhow::Result<()> {
    let TestEnvironment { config, client } = setup_global();

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");
        return Ok(());
    };

    let mut query = AccountBalanceQuery::new();

    query.account_id(op.account_id).max_payment_amount(Hbar::new(1_000_000));

    let cost = query.get_cost(&client).await?;

    assert_eq!(cost, Hbar::ZERO);

    let balance = query.payment_amount(cost).execute(&client).await?;

    anyhow::ensure!(balance.account_id == op.account_id);
    anyhow::ensure!(balance.hbars.to_tinybars() > 0);

    Ok(())
}

#[tokio::test]
async fn query_cost_small_max() -> anyhow::Result<()> {
    let TestEnvironment { config, client } = setup_global();

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");
        return Ok(());
    };

    let mut query = AccountBalanceQuery::new();

    query.account_id(op.account_id).max_payment_amount(Hbar::from_tinybars(1));

    let cost = query.get_cost(&client).await?;

    assert_eq!(cost, Hbar::ZERO);

    let balance = query.payment_amount(cost).execute(&client).await?;

    anyhow::ensure!(balance.account_id == op.account_id);
    anyhow::ensure!(balance.hbars.to_tinybars() > 0);

    Ok(())
}

#[tokio::test]
async fn invalid_account_id_fails() -> anyhow::Result<()> {
    let TestEnvironment { config: _, client } = setup_global();

    let res = AccountBalanceQuery::new()
        .account_id(AccountId {
            shard: 1,
            realm: 0,
            num: 3,
            alias: None,
            evm_address: None,
            checksum: None,
        })
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryNoPaymentPreCheckStatus { status: Status::InvalidAccountId })
    );

    Ok(())
}

#[tokio::test]
async fn query_token_balances() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(10), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("f")
        .initial_supply(10000)
        .decimals(50)
        .treasury_account_id(account.id)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .admin_key(account.key.public_key())
        .supply_key(account.key.public_key())
        .freeze_default(false)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let balance = AccountBalanceQuery::new().account_id(account.id).execute(&client).await?;

    #[allow(deprecated)]
    {
        assert_eq!(balance.tokens.get(&token_id).copied(), Some(10000));
        assert_eq!(balance.token_decimals.get(&token_id).copied(), Some(50));
    }

    TokenBurnTransaction::new()
        .token_id(token_id)
        .amount(10000_u64)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let _ = TokenDeleteTransaction::new()
        .token_id(token_id)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    account.delete(&client).await?;

    Ok(())
}
// Filename: tests/e2e/account/create.rs
use hedera::{
    AccountCreateTransaction,
    AccountInfoQuery,
    Hbar,
    Key,
    PrivateKey,
    TransactionId,
    TransferTransaction,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn initial_balance_and_key() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let receipt = AccountCreateTransaction::new()
        .key(key.public_key())
        .initial_balance(Hbar::new(1))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let account_id = receipt.account_id.unwrap();

    let info = AccountInfoQuery::new().account_id(account_id).execute(&client).await?;

    assert_eq!(info.account_id, account_id);
    assert!(!info.is_deleted);
    assert_eq!(info.key, Key::Single(key.public_key()));
    assert_eq!(info.balance, Hbar::new(1));
    assert_eq!(info.auto_renew_period, Some(Duration::days(90)));
    assert_eq!(info.proxy_received, Hbar::ZERO);

    Ok(())
}

#[tokio::test]
async fn no_initial_balance() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let receipt = AccountCreateTransaction::new()
        .key(key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let account_id = receipt.account_id.unwrap();

    let info = AccountInfoQuery::new().account_id(account_id).execute(&client).await?;

    assert_eq!(info.account_id, account_id);
    assert!(!info.is_deleted);
    assert_eq!(info.key, Key::Single(key.public_key()));
    assert_eq!(info.balance, Hbar::ZERO);
    assert_eq!(info.auto_renew_period, Some(Duration::days(90)));
    assert_eq!(info.proxy_received, Hbar::ZERO);

    Ok(())
}

#[tokio::test]
async fn missing_key_error() {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return;
    };

    let res = AccountCreateTransaction::new().initial_balance(Hbar::new(1)).execute(&client).await;

    assert_matches::assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: hedera::Status::KeyRequired, .. })
    );
}

#[tokio::test]
async fn alias_key() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let alias_id = key.to_account_id(0, 0);

    TransferTransaction::new()
        .hbar_transfer(op.account_id, Hbar::new(-1))
        .hbar_transfer(alias_id, Hbar::new(1))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = AccountInfoQuery::new().account_id(alias_id).execute(&client).await?;

    assert_eq!(info.alias_key, Some(key.public_key()));

    Ok(())
}

#[tokio::test]
#[ignore = "Explicit disagreement between Java and Rust SDKs"]
async fn manages_expiration() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let receipt = AccountCreateTransaction::new()
        .key(key.public_key())
        .transaction_id(TransactionId {
            account_id: op.account_id,
            valid_start: OffsetDateTime::now_utc() - Duration::seconds(40),
            nonce: None,
            scheduled: false,
        })
        .transaction_valid_duration(Duration::seconds(30))
        .freeze_with(&client)?
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let account_id = receipt.account_id.unwrap();

    let info = AccountInfoQuery::new().account_id(account_id).execute(&client).await?;

    assert_eq!(info.account_id, account_id);
    assert!(!info.is_deleted);
    assert_eq!(info.key, Key::Single(key.public_key()));
    assert_eq!(info.balance, Hbar::ZERO);
    assert_eq!(info.auto_renew_period, Some(Duration::days(90)));

    #[allow(deprecated)]
    {
        assert_eq!(info.proxy_account_id, None);
    }
    assert_eq!(info.proxy_received, Hbar::ZERO);

    Ok(())
}

#[tokio::test]
async fn alias_from_admin_key() -> anyhow::Result<()> {
    // Tests the third row of this table
    // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ecdsa();
    let evm_address = admin_key.public_key().to_evm_address().unwrap();

    let account_id = AccountCreateTransaction::new()
        .key(admin_key.public_key())
        .alias(evm_address)
        .freeze_with(&client)?
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    let info = AccountInfoQuery::new().account_id(account_id).execute(&client).await?;

    assert_eq!(info.account_id, account_id);
    assert_eq!(info.contract_account_id, hex::encode(evm_address.to_bytes()));
    assert_eq!(info.key, Key::Single(admin_key.public_key()));

    Ok(())
}

#[tokio::test]
async fn alias_from_admin_key_with_receiver_sig_required() -> anyhow::Result<()> {
    // Tests the fourth row of this table
    // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ecdsa();
    let evm_address = admin_key.public_key().to_evm_address().unwrap();

    let account_id = AccountCreateTransaction::new()
        .receiver_signature_required(true)
        .key(admin_key.public_key())
        .alias(evm_address)
        .freeze_with(&client)?
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    let info = AccountInfoQuery::new().account_id(account_id).execute(&client).await?;

    assert_eq!(info.account_id, account_id);
    assert_eq!(info.contract_account_id, hex::encode(evm_address.to_bytes()));
    assert_eq!(info.key, Key::Single(admin_key.public_key()));

    Ok(())
}

#[tokio::test]
async fn alias_from_admin_key_with_receiver_sig_required_and_no_signature_errors(
) -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ecdsa();
    let evm_address = admin_key.public_key().to_evm_address().unwrap();

    let res = AccountCreateTransaction::new()
        .receiver_signature_required(true)
        .key(admin_key.public_key())
        .alias(evm_address)
        .freeze_with(&client)?
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches::assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: hedera::Status::InvalidSignature, .. })
    );

    Ok(())
}

#[tokio::test]
async fn alias() -> anyhow::Result<()> {
    // Tests the fifth row of this table
    // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    let key = PrivateKey::generate_ecdsa();
    let evm_address = key.public_key().to_evm_address().unwrap();

    let account_id = AccountCreateTransaction::new()
        .key(admin_key.public_key())
        .alias(evm_address)
        .freeze_with(&client)?
        .sign(key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    let info = AccountInfoQuery::new().account_id(account_id).execute(&client).await?;

    assert_eq!(info.account_id, account_id);

    assert_eq!(info.contract_account_id, hex::encode(evm_address.to_bytes()));
    assert_eq!(info.key, Key::Single(admin_key.public_key()));

    Ok(())
}

#[tokio::test]
async fn alias_missing_signature_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    let key = PrivateKey::generate_ecdsa();
    let evm_address = key.public_key().to_evm_address().unwrap();

    let res = AccountCreateTransaction::new()
        .key(admin_key.public_key())
        .alias(evm_address)
        .freeze_with(&client)?
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches::assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: hedera::Status::InvalidSignature, .. })
    );

    Ok(())
}

#[tokio::test]
async fn alias_with_receiver_sig_required() -> anyhow::Result<()> {
    // Tests the sixth row of this table
    // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    let key = PrivateKey::generate_ecdsa();
    let evm_address = key.public_key().to_evm_address().unwrap();

    let account_id = AccountCreateTransaction::new()
        .receiver_signature_required(true)
        .key(admin_key.public_key())
        .alias(evm_address)
        .freeze_with(&client)?
        .sign(key)
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    let info = AccountInfoQuery::new().account_id(account_id).execute(&client).await?;

    assert_eq!(info.account_id, account_id);

    assert_eq!(info.contract_account_id, hex::encode(evm_address.to_bytes()));
    assert_eq!(info.key, Key::Single(admin_key.public_key()));

    Ok(())
}

#[tokio::test]
async fn alias_with_receiver_sig_required_missing_signature_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    let key = PrivateKey::generate_ecdsa();
    let evm_address = key.public_key().to_evm_address().unwrap();

    let res = AccountCreateTransaction::new()
        .receiver_signature_required(true)
        .key(admin_key.public_key())
        .alias(evm_address)
        .freeze_with(&client)?
        .sign(key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches::assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: hedera::Status::InvalidSignature, .. })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_create_account_with_invalid_negative_max_auto_token_assocation(
) -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let res = AccountCreateTransaction::new()
        .key(key.public_key())
        .max_automatic_token_associations(-2)
        .execute(&client)
        .await;

    assert_matches::assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: hedera::Status::InvalidMaxAutoAssociations,
            ..
        })
    );

    Ok(())
}
// Filename: tests/e2e/account/delete.rs
use assert_matches::assert_matches;
use hedera::{
    AccountCreateTransaction,
    AccountDeleteTransaction,
    AccountInfoQuery,
    Hbar,
    PrivateKey,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn create_then_delete() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let receipt = AccountCreateTransaction::new()
        .key(key.public_key())
        .initial_balance(Hbar::new(1))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let account_id = receipt.account_id.unwrap();

    AccountDeleteTransaction::new()
        .transfer_account_id(client.get_operator_account_id().unwrap())
        .account_id(account_id)
        .sign(key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = AccountInfoQuery::new().account_id(account_id).execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryNoPaymentPreCheckStatus { status: Status::AccountDeleted })
    );

    Ok(())
}

#[tokio::test]
async fn missing_account_id_fails() {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return;
    };

    let res = AccountDeleteTransaction::new()
        .transfer_account_id(client.get_operator_account_id().unwrap())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::AccountIdDoesNotExist, .. })
    );
}

#[tokio::test]
async fn missing_deletee_signature_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let receipt = AccountCreateTransaction::new()
        .key(key.public_key())
        .initial_balance(Hbar::new(1))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let account_id = receipt.account_id.unwrap();

    let res = AccountDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .account_id(account_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}
// Filename: tests/e2e/account/info.rs
use assert_matches::assert_matches;
use hedera::{
    account_info_flow,
    AccountInfoQuery,
    Hbar,
    Key,
    PrivateKey,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");

        return Ok(());
    };

    let info = AccountInfoQuery::new().account_id(op.account_id).execute(&client).await?;

    assert_eq!(info.account_id, op.account_id);
    assert!(!info.is_deleted);
    assert_eq!(info.key, Key::Single(op.private_key.public_key()));
    assert!(info.balance.to_tinybars() > 0);
    assert_eq!(info.proxy_received, Hbar::ZERO);

    Ok(())
}

#[tokio::test]
async fn query_cost_for_operator() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");

        return Ok(());
    };

    let mut query = AccountInfoQuery::new();

    query.account_id(op.account_id).max_payment_amount(Hbar::new(1));

    let cost = query.get_cost(&client).await?;

    let info = query.payment_amount(cost).execute(&client).await?;

    assert_eq!(info.account_id, op.account_id);

    Ok(())
}

#[tokio::test]
async fn query_cost_big_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");

        return Ok(());
    };

    let mut query = AccountInfoQuery::new();

    query.account_id(op.account_id).max_payment_amount(Hbar::MAX);

    let cost = query.get_cost(&client).await?;

    let info = query.payment_amount(cost).execute(&client).await?;

    assert_eq!(info.account_id, op.account_id);

    Ok(())
}

#[tokio::test]
async fn query_cost_small_max_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");

        return Ok(());
    };

    let mut query = AccountInfoQuery::new();

    query.account_id(op.account_id).max_payment_amount(Hbar::from_tinybars(1));

    let cost = query.get_cost(&client).await?;

    let res = query.execute(&client).await;

    let (max_query_payment, query_cost) = assert_matches!(
        res,
        Err(hedera::Error::MaxQueryPaymentExceeded {
            max_query_payment,
            query_cost
        }) => (max_query_payment, query_cost)
    );

    assert_eq!(max_query_payment, Hbar::from_tinybars(1));
    // note: there's a very small chance this fails if the cost of a AccountInfoQuery changes right when we execute it.
    assert_eq!(query_cost, cost);

    Ok(())
}

#[tokio::test]
async fn get_cost_insufficient_tx_fee_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");

        return Ok(());
    };

    let res = AccountInfoQuery::new() //
        .account_id(op.account_id)
        .max_payment_amount(Hbar::from_tinybars(10000))
        .payment_amount(Hbar::from_tinybars(1))
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryPaymentPreCheckStatus { status: Status::InsufficientTxFee, .. })
    );

    Ok(())
}

#[tokio::test]
async fn flow_verify_transaction() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");

        return Ok(());
    };

    let new_key = PrivateKey::generate_ed25519();

    let new_public_key = new_key.public_key();

    let mut signed_tx = hedera::AccountCreateTransaction::new();
    signed_tx
        .key(new_public_key)
        .initial_balance(Hbar::from_tinybars(1000))
        .freeze_with(&client)?
        .sign_with_operator(&client)?;

    let mut unsigned_tx = hedera::AccountCreateTransaction::new();
    unsigned_tx
        .key(new_public_key)
        .initial_balance(Hbar::from_tinybars(1000))
        .freeze_with(&client)?;

    assert_matches!(
        account_info_flow::verify_transaction_signature(&client, op.account_id, &mut signed_tx)
            .await,
        Ok(())
    );

    assert_matches!(
        account_info_flow::verify_transaction_signature(&client, op.account_id, &mut unsigned_tx)
            .await,
        Err(hedera::Error::SignatureVerify(_))
    );

    Ok(())
}
// Filename: tests/e2e/account/mod.rs
mod allowance_approve;
mod allowance_delete;
mod balance;
mod create;
mod delete;
mod info;
mod update;

use hedera::{
    AccountId,
    Hbar,
    PrivateKey,
};

#[derive(Clone)]
pub struct Account {
    pub key: PrivateKey,
    pub id: AccountId,
}

impl Account {
    pub async fn create(initial_balance: Hbar, client: &hedera::Client) -> hedera::Result<Self> {
        let key = PrivateKey::generate_ed25519();

        let receipt = hedera::AccountCreateTransaction::new()
            .key(key.public_key())
            .initial_balance(initial_balance)
            .execute(client)
            .await?
            .get_receipt(client)
            .await?;

        let account_id = receipt.account_id.unwrap();

        Ok(Self { key, id: account_id })
    }

    pub async fn delete(self, client: &hedera::Client) -> hedera::Result<()> {
        hedera::AccountDeleteTransaction::new()
            .account_id(self.id)
            .transfer_account_id(client.get_operator_account_id().unwrap())
            .freeze_with(client)?
            .sign(self.key)
            .execute(client)
            .await?
            .get_receipt(client)
            .await?;

        Ok(())
    }

    pub async fn create_with_max_associations(
        max_automatic_token_associations: i32,
        account_key: &PrivateKey,
        client: &hedera::Client,
    ) -> hedera::Result<Self> {
        let receipt = hedera::AccountCreateTransaction::new()
            .key(account_key.public_key())
            .initial_balance(Hbar::new(10))
            .max_automatic_token_associations(max_automatic_token_associations)
            .execute(client)
            .await?
            .get_receipt(client)
            .await?;

        let account_id = receipt.account_id.unwrap();

        Ok(Account { key: account_key.clone(), id: account_id })
    }
}
// Filename: tests/e2e/account/update.rs
use hedera::{
    AccountCreateTransaction,
    AccountInfoQuery,
    AccountUpdateTransaction,
    Hbar,
    Key,
    PrivateKey,
    TokenCreateTransaction,
    TransferTransaction,
};
use time::Duration;

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn set_key() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let key1 = PrivateKey::generate_ed25519();
    let key2 = PrivateKey::generate_ed25519();

    let account_id = AccountCreateTransaction::new()
        .key(key1.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    let info = AccountInfoQuery::new().account_id(account_id).execute(&client).await?;

    // none of these are relevant to this test (they should already be tested by the create E2E tests)
    // assertThat(info.accountId).isEqualTo(accountId);
    // assertThat(info.isDeleted).isFalse();
    // assertThat(info.balance).isEqualTo(new Hbar(0));
    // assertThat(info.autoRenewPeriod).isEqualTo(Duration.ofDays(90));
    // assertThat(info.proxyAccountId).isNull();
    // assertThat(info.proxyReceived).isEqualTo(Hbar.ZERO);

    assert_eq!(info.key, Key::Single(key1.public_key()));

    AccountUpdateTransaction::new()
        .account_id(account_id)
        .key(key2.public_key())
        .freeze_with(&client)?
        .sign(key1)
        .sign(key2.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = AccountInfoQuery::new().account_id(account_id).execute(&client).await?;

    assert_eq!(info.account_id, account_id);
    assert!(!info.is_deleted);
    assert_eq!(info.key, Key::Single(key2.public_key()));
    assert_eq!(info.balance, Hbar::ZERO);
    assert_eq!(info.auto_renew_period, Some(Duration::days(90)));
    assert_eq!(info.proxy_received, Hbar::ZERO);

    Ok(())
}

#[tokio::test]
async fn missing_account_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = AccountUpdateTransaction::new().execute(&client).await;

    assert_matches::assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: hedera::Status::AccountIdDoesNotExist,
            ..
        })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_update_max_token_association_to_lower_value_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account_key = PrivateKey::generate_ed25519();

    // Create account with max token associations of 1
    let account_id = AccountCreateTransaction::new()
        .key(account_key.public_key())
        .max_automatic_token_associations(1)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    // Create token
    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .initial_supply(100_000)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .admin_key(client.get_operator_public_key().unwrap())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    // Associate token with account
    _ = TransferTransaction::new()
        .token_transfer(token_id, client.get_operator_account_id().unwrap(), -10)
        .token_transfer(token_id, account_id, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Update account max token associations to 0
    let res = AccountUpdateTransaction::new()
        .account_id(account_id)
        .max_automatic_token_associations(0)
        .freeze_with(&client)?
        .sign(account_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches::assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: hedera::Status::ExistingAutomaticAssociationsExceedGivenLimit,
            ..
        })
    );

    Ok(())
}
// Filename: tests/e2e/address_book/mod.rs
mod node_create;
// Filename: tests/e2e/address_book/node_create.rs
use std::collections::HashMap;
use std::str::FromStr;

use hedera::{
    AccountId,
    Client,
    NodeCreateTransaction,
    PrivateKey,
    ServiceEndpoint,
};

const VALID_GOSSIP_CERT_DER: &str = "3082052830820310a003020102020101300d06092a864886f70d01010c05003010310e300c060355040313056e6f6465333024170d3234313030383134333233395a181332313234313030383134333233392e3337395a3010310e300c060355040313056e6f64653330820222300d06092a864886f70d01010105000382020f003082020a0282020100af111cff0c4ad8125d2f4b8691ce87332fecc867f7a94ddc0f3f96514cc4224d44af516394f7384c1ef0a515d29aa6116b65bc7e4d7e2d848cf79fbfffedae3a6583b3957a438bdd780c4981b800676ea509bc8c619ae04093b5fc642c4484152f0e8bcaabf19eae025b630028d183a2f47caf6d9f1075efb30a4248679d871beef1b7e9115382270cbdb68682fae4b1fd592cadb414d918c0a8c23795c7c5a91e22b3e90c410825a2bc1a840efc5bf9976a7f474c7ed7dc047e4ddd2db631b68bb4475f173baa3edc234c4bed79c83e2f826f79e07d0aade2d984da447a8514135bfa4145274a7f62959a23c4f0fae5adc6855974e7c04164951d052beb5d45cb1f3cdfd005da894dea9151cb62ba43f4731c6bb0c83e10fd842763ba6844ef499f71bc67fa13e4917fb39f2ad18112170d31cdcb3c61c9e3253accf703dbd8427fdcb87ece78b787b6cfdc091e8fedea8ad95dc64074e1fc6d0e42ea2337e18a5e54e4aaab3791a98dfcef282e2ae1caec9cf986fabe8f36e6a21c8711647177e492d264415e765a86c58599cd97b103cb4f6a01d2edd06e3b60470cf64daca7aecf831197b466cae04baeeac19840a05394bef628aed04b611cfa13677724b08ddfd662b02fd0ef0af17eb7f4fb8c1c17fbe9324f6dc7bcc02449622636cc45ec04909b3120ab4df4726b21bf79e955fe8f832699d2196dcd7a58bfeafb170203010001a38186308183300f0603551d130101ff04053003020100300e0603551d0f0101ff0404030204b030200603551d250101ff0416301406082b0601050507030106082b06010505070302301d0603551d0e04160414643118e05209035edd83d44a0c368de2fb2fe4c0301f0603551d23041830168014643118e05209035edd83d44a0c368de2fb2fe4c0300d06092a864886f70d01010c05000382020100ad41c32bb52650eb4b76fce439c9404e84e4538a94916b3dc7983e8b5c58890556e7384601ca7440dde68233bb07b97bf879b64487b447df510897d2a0a4e789c409a9b237a6ad240ad5464f2ce80c58ddc4d07a29a74eb25e1223db6c00e334d7a27d32bfa6183a82f5e35bccf497c2445a526eabb0c068aba9b94cc092ea4756b0dcfb574f6179f0089e52b174ccdbd04123eeb6d70daeabd8513fcba6be0bc2b45ca9a69802dae11cc4d9ff6053b3a87fd8b0c6bf72fffc3b81167f73cca2b3fd656c5d353c8defca8a76e2ad535f984870a590af4e28fed5c5a125bf360747c5e7742e7813d1bd39b5498c8eb6ba72f267eda034314fdbc596f6b967a0ef8be5231d364e634444c84e64bd7919425171016fcd9bb05f01c58a303dee28241f6e860fc3aac3d92aad7dac2801ce79a3b41a0e1f1509fc0d86e96d94edb18616c000152490f64561713102128990fedd3a5fa642f2ff22dc11bc4dc5b209986a0c3e4eb2bdfdd40e9fdf246f702441cac058dd8d0d51eb0796e2bea2ce1b37b2a2f468505e1f8980a9f66d719df034a6fbbd2f9585991d259678fb9a4aebdc465d22c240351ed44abffbdd11b79a706fdf7c40158d3da87f68d7bd557191a8016b5b899c07bf1b87590feb4fa4203feea9a2a7a73ec224813a12b7a21e5dc93fcde4f0a7620f570d31fe27e9b8d65b74db7dc18a5e51adc42d7805d4661938";

#[tokio::test]
#[ignore = "Temporarily disabled to prevent failed local-node calls"]
async fn create_new_network_node() -> anyhow::Result<()> {
    // Set the network
    let network = HashMap::from([("localhost:50211".into(), AccountId::new(0, 0, 3))]);

    let client = Client::for_network(network)?;
    client.set_mirror_network(vec!["127.0.0.1:5600".into()]);

    // Set the operator to Account Id 0.0.2
    let operator_key = PrivateKey::from_str("302e020100300506032b65700422042091132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137")?;

    client.set_operator(AccountId::new(0, 0, 2), operator_key);

    // The account of the new node
    let account_id = AccountId::new(0, 0, 4);

    // Create new endpoints. IPV4 address is not required
    let endpoint1 =
        ServiceEndpoint { ip_address_v4: None, port: 1234, domain_name: "tests.com".to_owned() };
    let endpoint2 =
        ServiceEndpoint { ip_address_v4: None, port: 123, domain_name: "testing.com".to_owned() };

    // Convert hex string to byte array
    let valid_gossip_cert = VALID_GOSSIP_CERT_DER.as_bytes().to_vec();

    // Generate new admin key
    let admin_key = PrivateKey::generate_ed25519();

    let _ = NodeCreateTransaction::new()
        .account_id(account_id)
        .admin_key(admin_key.public_key())
        .description("test node")
        .gossip_ca_certificate(valid_gossip_cert)
        .gossip_endpoints(vec![endpoint1.clone(), endpoint2.clone()])
        .service_endpoints(vec![endpoint1, endpoint2])
        .freeze_with(&client)?
        .sign(admin_key)
        .execute(&client)
        .await?
        .get_receipt(&client);

    Ok(())
}
// Filename: tests/e2e/client.rs
use std::collections::HashMap;

use hedera::Client;

#[tokio::test]
async fn initialize_with_mirror_network() -> anyhow::Result<()> {
    let mirror_network_str = "testnet.mirrornode.hedera.com:443";
    let client = Client::for_mirror_network(vec![mirror_network_str.to_owned()]).await?;
    let mirror_network = client.mirror_network();

    assert_eq!(mirror_network.len(), 1);
    assert_eq!(mirror_network[0], mirror_network_str);
    assert_ne!(client.network(), HashMap::new());

    Ok(())
}
// Filename: tests/e2e/common/mod.rs
use std::borrow::Cow;
use std::collections::HashMap;
use std::sync::atomic::AtomicBool;

use anyhow::Context;
use hedera::{
    AccountId,
    Client,
    PrivateKey,
};
use once_cell::sync::Lazy;

mod keys {
    pub(super) const NETWORK: &str = "TEST_NETWORK_NAME";

    pub(super) const OPERATOR_KEY: &str = "TEST_OPERATOR_KEY";

    pub(super) const OPERATOR_ID: &str = "TEST_OPERATOR_ID";

    pub(super) const RUN_NONFREE: &str = "TEST_RUN_NONFREE";
}

static CONFIG: Lazy<Config> = Lazy::new(Config::parse_env);
static DEFAULT_LOCAL_NODE_ADDRESS: &str = "127.0.0.1:50211";
static DEFAULT_LOCAL_MIRROR_NODE_ADDRESS: &str = "127.0.0.1:5600";

/// Generates a client using the active config.
///
/// This is a function rather than a `Lazy` because every executor (IE, [`#[tokio::test]`](tokio::test)) needs its own client.
fn client() -> Client {
    let config = &*CONFIG;

    let client = match &*config.network_name {
        "mainnet" => Client::for_mainnet(),
        "testnet" => Client::for_testnet(),
        "previewnet" => Client::for_previewnet(),
        "localhost" => for_local_node(),
        _ => {
            // to ensure we don't spam the logs with `Error creating client: ...`,
            // we just let an arbitrary thread win and log the "error".
            static LOGS_ONCE: AtomicBool = AtomicBool::new(false);

            // note: Relaxed is probably fine, AcqRel is *definitely* fine.
            if !LOGS_ONCE.swap(true, std::sync::atomic::Ordering::AcqRel) {
                log::error!(
                    "Error creating client: {}; creating one using `testnet`",
                    &*config.network_name
                );
            }

            Client::for_testnet()
        }
    };

    if let Some(op) = &config.operator {
        client.set_operator(op.account_id, op.private_key.clone());
    }

    client
}

fn for_local_node() -> Client {
    let mut network: HashMap<String, AccountId> = HashMap::new();
    network.insert(DEFAULT_LOCAL_NODE_ADDRESS.to_string(), AccountId::new(0, 0, 3));

    let client = Client::for_network(network).unwrap();
    client.set_mirror_network([DEFAULT_LOCAL_MIRROR_NODE_ADDRESS.to_string()]);
    client
}

#[derive(Clone)]
pub(crate) struct Operator {
    pub(crate) private_key: PrivateKey,
    pub(crate) account_id: AccountId,
}

impl Operator {
    fn try_parse_env() -> anyhow::Result<Option<Self>> {
        let key = dotenvy::var(keys::OPERATOR_KEY).ok();
        let account_id = dotenvy::var(keys::OPERATOR_ID).ok();

        // note: intentionally avoiding zip in order to log warnings
        let (key, account_id) = match (key, account_id) {
            (Some(key), Some(account_id)) => (key, account_id),

            (Some(_), None) => {
                anyhow::bail!("operator key was set but the account id was not")
            }

            (None, Some(_)) => {
                anyhow::bail!("operator account id was set but the key was not")
            }

            (None, None) => return Ok(None),
        };

        let key = key.parse().context("failed to parse operator key")?;
        let account_id = account_id.parse().context("failed to parse operator account id")?;

        Ok(Some(Self { private_key: key, account_id }))
    }

    fn parse_env() -> Option<Self> {
        match Self::try_parse_env() {
            Ok(res) => res,
            Err(e) => {
                log::warn!("error occurred while parsing operator: {e:?}; ignoring operator");

                None
            }
        }
    }
}

pub(crate) struct Config {
    /// Name of the network used
    pub(crate) network_name: Cow<'static, str>,

    /// The operator to use for non-free transactions / queries,
    /// however it is also a source of a known account / private key for things like `AccountBalanceQuery`.
    pub(crate) operator: Option<Operator>,

    /// A setting to allow tests that cost Hbar to run.
    ///
    /// If this is set and an operator is not provided, a warning will be logged and this will be forcibly disabled.
    pub(crate) run_nonfree_tests: bool,

    /// A flag signifying that local node is the current testing environment.
    pub(crate) is_local: bool,
}

/// Returns true if the provided env var is
fn env_bool(default: bool, var_name: &str) -> bool {
    let Some(var) = dotenvy::var(var_name).ok() else {
        return default;
    };

    if var.as_str() == "1" {
        return true;
    }

    if var.as_str() == "0" {
        return false;
    }

    log::warn!("expected `{var_name}` to be `1` or `0` but it was `{var}`, returning `{default}`");

    default
}

impl Config {
    fn parse_env() -> Self {
        let network_name = dotenvy::var(keys::NETWORK).ok();

        let mut is_local = false;

        // default tests to localhost
        let network_name = network_name.map_or_else(|| Cow::Borrowed("testnet"), Cow::Owned);

        if network_name == "localhost" {
            is_local = true
        }

        let operator = Operator::parse_env();

        let run_nonfree_tests = env_bool(false, keys::RUN_NONFREE);

        Self { network_name, operator, run_nonfree_tests, is_local }
    }
}

pub(crate) struct TestEnvironment {
    pub(crate) config: &'static Config,
    pub(crate) client: Client,
}

pub(crate) fn setup_global() -> TestEnvironment {
    let _ = dotenvy::dotenv();

    let _ = env_logger::builder().parse_default_env().is_test(true).try_init();

    TestEnvironment { config: &CONFIG, client: client() }
}

pub(crate) fn setup_nonfree() -> Option<TestEnvironment> {
    let env = setup_global();

    match env.config.run_nonfree_tests {
        true => Some(env),
        false => {
            log::debug!("skipping non-free test");
            None
        }
    }
}
// Filename: tests/e2e/contract/bytecode.rs
use assert_matches::assert_matches;
use hedera::{
    ContractBytecodeQuery,
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractFunctionParameters,
    ContractInfoQuery,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::contract::SMART_CONTRACT_BYTECODE;

#[tokio::test]
async fn query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents(SMART_CONTRACT_BYTECODE)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let contract_id = ContractCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .gas(200000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .bytecode_file_id(file_id)
        .contract_memo("[e2e::ContractCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .contract_id
        .unwrap();

    let bytecode = ContractBytecodeQuery::new().contract_id(contract_id).execute(&client).await?;

    assert_eq!(bytecode.len(), 798);

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert!(res.is_deleted);

    Ok(())
}

#[tokio::test]
async fn get_cost_big_max_query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents(SMART_CONTRACT_BYTECODE)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let contract_id = ContractCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .gas(200000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .bytecode_file_id(file_id)
        .contract_memo("[e2e::ContractCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .contract_id
        .unwrap();

    let mut binding = ContractBytecodeQuery::new();
    let bytecode = binding.contract_id(contract_id).max_payment_amount(Hbar::new(1000));

    let cost = bytecode.get_cost(&client).await?;

    println!("cost: {cost:?}");

    let bytecode = binding.payment_amount(cost).execute(&client).await?;

    assert_eq!(bytecode.len(), 798);

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn get_cost_small_max_query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents(SMART_CONTRACT_BYTECODE)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let contract_id = ContractCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .gas(200000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .bytecode_file_id(file_id)
        .contract_memo("[e2e::ContractCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .contract_id
        .unwrap();

    let max_payment_amount = Hbar::from_tinybars(1);
    let mut binding = ContractBytecodeQuery::new();
    let bytecode = binding.contract_id(contract_id).max_payment_amount(max_payment_amount);

    let bytecode = bytecode.execute(&client).await;

    assert_matches!(
        bytecode,
        Err(hedera::Error::MaxQueryPaymentExceeded {
            max_query_payment: _max_payment_amount,
            query_cost: _cost
        })
    );

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/contract/create.rs
use assert_matches::assert_matches;
use hedera::{
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractFunctionParameters,
    ContractInfoQuery,
    Key,
    Status,
};

use super::bytecode_file_id;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = bytecode_file_id(&client, op.private_key.public_key()).await?;

    let contract_id = ContractCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .gas(200_000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .bytecode_file_id(file_id)
        .contract_memo("[e2e::ContractCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .contract_id
        .unwrap();

    let info = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert_eq!(info.contract_id, contract_id);
    assert_eq!(info.account_id.to_string(), info.contract_id.to_string());
    assert_eq!(info.admin_key, Some(Key::Single(op.private_key.public_key())));
    assert_eq!(info.storage, 128);
    assert_eq!(info.contract_memo, "[e2e::ContractCreateTransaction]");

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn no_admin_key() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = bytecode_file_id(&client, op.private_key.public_key()).await?;

    let contract_id = ContractCreateTransaction::new()
        .gas(200_000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .bytecode_file_id(file_id)
        .contract_memo("[e2e::ContractCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .contract_id
        .unwrap();

    let info = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert_eq!(info.contract_id, contract_id);
    assert_eq!(info.account_id.to_string(), info.contract_id.to_string());
    assert!(info.admin_key.is_some());
    assert_eq!(info.storage, 128);
    assert_eq!(info.contract_memo, "[e2e::ContractCreateTransaction]");

    Ok(())
}

#[tokio::test]
async fn unset_gas_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = bytecode_file_id(&client, op.private_key.public_key()).await?;

    let res = ContractCreateTransaction::new()
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .bytecode_file_id(file_id)
        .contract_memo("[e2e::ContractCreateTransaction]")
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InsufficientGas, .. })
    );

    Ok(())
}

#[tokio::test]
async fn constructor_parameters_unset_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = bytecode_file_id(&client, op.private_key.public_key()).await?;

    let res = ContractCreateTransaction::new()
        .gas(200_000)
        .bytecode_file_id(file_id)
        .contract_memo("[e2e::ContractCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::ContractRevertExecuted, .. })
    );

    Ok(())
}

#[tokio::test]
async fn bytecode_file_id_unset_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = ContractCreateTransaction::new()
        .gas(200_000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .contract_memo("[e2e::ContractCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(res, Err(hedera::Error::ReceiptStatus { status: Status::InvalidFileId, .. }));

    Ok(())
}
// Filename: tests/e2e/contract/create_flow.rs
use assert_matches::assert_matches;
use hedera::{
    ContractCreateFlow,
    ContractDeleteTransaction,
    ContractFunctionParameters,
    ContractInfoQuery,
    Key,
    PrivateKey,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::contract::SMART_CONTRACT_BYTECODE;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id = ContractCreateFlow::new()
        .bytecode_hex(SMART_CONTRACT_BYTECODE)?
        .admin_key(op.private_key.public_key())
        .gas(200_000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .contract_memo("[e2e::ContractCreateFlow]".to_owned())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .contract_id
        .unwrap();

    let info = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert_eq!(info.contract_id, contract_id);
    assert_eq!(info.account_id.to_string(), info.contract_id.to_string());
    assert_eq!(info.admin_key, Some(Key::Single(op.private_key.public_key())));
    assert_eq!(info.storage, 128);
    assert_eq!(info.contract_memo, "[e2e::ContractCreateFlow]");

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn admin_key_missing_signature_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    let res = ContractCreateFlow::new()
        .bytecode_hex(SMART_CONTRACT_BYTECODE)?
        .admin_key(admin_key.public_key())
        .gas(200_000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .contract_memo("[e2e::ContractCreateFlow]".to_owned())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}

#[tokio::test]
async fn admin_key() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();
    let contract_id = ContractCreateFlow::new()
        .bytecode_hex(SMART_CONTRACT_BYTECODE)?
        .admin_key(admin_key.public_key())
        .gas(200_000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .contract_memo("[e2e::ContractCreateFlow]".to_owned())
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .contract_id
        .unwrap();

    let info = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert_eq!(info.contract_id, contract_id);
    assert_eq!(info.account_id.to_string(), info.contract_id.to_string());
    assert_eq!(info.admin_key, Some(Key::Single(admin_key.public_key())));
    assert_eq!(info.storage, 128);
    assert_eq!(info.contract_memo, "[e2e::ContractCreateFlow]");

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .sign(admin_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn admin_key_sign_with() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();
    let contract_id = ContractCreateFlow::new()
        .bytecode_hex(SMART_CONTRACT_BYTECODE)?
        .admin_key(admin_key.public_key())
        .gas(200_000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .contract_memo("[e2e::ContractCreateFlow]".to_owned())
        .sign_with(admin_key.public_key(), {
            let admin_key = admin_key.clone();
            move |message| admin_key.sign(message)
        })
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .contract_id
        .unwrap();

    let info = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert_eq!(info.contract_id, contract_id);
    assert_eq!(info.account_id.to_string(), info.contract_id.to_string());
    assert_eq!(info.admin_key, Some(Key::Single(admin_key.public_key())));
    assert_eq!(info.storage, 128);
    assert_eq!(info.contract_memo, "[e2e::ContractCreateFlow]");

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .sign(admin_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/contract/delete.rs
use assert_matches::assert_matches;
use hedera::{
    ContractDeleteTransaction,
    ContractInfoQuery,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::contract::ContractAdminKey;

#[tokio::test]
async fn admin_key() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id =
        super::create_contract(&client, op.private_key.public_key(), ContractAdminKey::Operator)
            .await?;

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert!(res.is_deleted);

    Ok(())
}

#[tokio::test]
async fn missing_admin_key_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id = super::create_contract(&client, op.private_key.public_key(), None).await?;

    let res = ContractDeleteTransaction::new()
        .contract_id(contract_id)
        .transfer_account_id(client.get_operator_account_id().unwrap())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::ModifyingImmutableContract, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_contract_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = ContractDeleteTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidContractId, .. })
    );

    Ok(())
}
// Filename: tests/e2e/contract/execute.rs
use assert_matches::assert_matches;
use hedera::{
    ContractDeleteTransaction,
    ContractExecuteTransaction,
    ContractFunctionParameters,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::contract::ContractAdminKey;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id =
        super::create_contract(&client, op.private_key.public_key(), ContractAdminKey::Operator)
            .await?;

    let _ = ContractExecuteTransaction::new()
        .contract_id(contract_id)
        .gas(200_000)
        .function_with_parameters(
            "setMessage",
            ContractFunctionParameters::new().add_string("new message"),
        )
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_contract_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = ContractExecuteTransaction::new()
        .gas(200_000)
        .function_with_parameters(
            "setMessage",
            ContractFunctionParameters::new().add_string("new message"),
        )
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidContractId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_function_parameters_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id =
        super::create_contract(&client, op.private_key.public_key(), ContractAdminKey::Operator)
            .await?;

    let res = ContractExecuteTransaction::new()
        .contract_id(contract_id)
        .gas(200_000)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::ContractRevertExecuted, .. })
    );

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_gas_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id =
        super::create_contract(&client, op.private_key.public_key(), ContractAdminKey::Operator)
            .await?;

    let res = ContractExecuteTransaction::new()
        .contract_id(contract_id)
        .function_with_parameters(
            "setMessage",
            ContractFunctionParameters::new().add_string("new message"),
        )
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InsufficientGas, .. })
    );

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/contract/info.rs
use assert_matches::assert_matches;
use hedera::{
    ContractDeleteTransaction,
    ContractInfoQuery,
    Hbar,
    Key,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::contract::ContractAdminKey;

#[tokio::test]
async fn query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id =
        super::create_contract(&client, op.private_key.public_key(), ContractAdminKey::Operator)
            .await?;

    // assertThat(contractId.hashCode()).isGreaterThan(0);
    // assertThat(contractId.compareTo(ContractId.fromBytes(contractId.toBytes()))).isZero();

    let info = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert_eq!(info.contract_id, contract_id);
    assert_eq!(info.account_id.to_string(), info.contract_id.to_string());
    assert_eq!(info.admin_key, Some(Key::Single(op.private_key.public_key())));
    assert_eq!(info.storage, 128);
    assert_eq!(info.contract_memo, "[e2e::ContractCreateTransaction]");

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn query_no_admin_key() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id = super::create_contract(&client, op.private_key.public_key(), None).await?;

    let info = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert_eq!(info.contract_id, contract_id);
    assert_eq!(info.account_id.to_string(), info.contract_id.to_string());
    // TODO: Fix this when we know it's correct
    // assertEquals(info.adminKey, contractId);
    assert!(info.admin_key.is_some());
    assert_eq!(info.storage, 128);
    assert_eq!(info.contract_memo, "[e2e::ContractCreateTransaction]");

    Ok(())
}

#[tokio::test]
async fn missing_contract_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = ContractInfoQuery::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryNoPaymentPreCheckStatus { status: Status::InvalidContractId })
    );

    Ok(())
}

#[tokio::test]
async fn query_cost_big_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id =
        super::create_contract(&client, op.private_key.public_key(), ContractAdminKey::Operator)
            .await?;

    let mut query = ContractInfoQuery::new();

    query.contract_id(contract_id).max_payment_amount(Hbar::new(10000));

    let cost = query.get_cost(&client).await?;

    let _info = query.payment_amount(cost).execute(&client).await?;

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_small_max_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id =
        super::create_contract(&client, op.private_key.public_key(), ContractAdminKey::Operator)
            .await?;

    let mut query = ContractInfoQuery::new();

    query.contract_id(contract_id).max_payment_amount(Hbar::from_tinybars(1));

    let cost = query.get_cost(&client).await?;

    let res = query.execute(&client).await;

    let (max_query_payment, query_cost) = assert_matches!(
        res,
        Err(hedera::Error::MaxQueryPaymentExceeded {
            max_query_payment,
            query_cost
        }) => (max_query_payment, query_cost)
    );

    assert_eq!(max_query_payment, Hbar::from_tinybars(1));
    // note: there's a very small chance this fails if the cost of a AccountInfoQuery changes right when we execute it.
    assert_eq!(query_cost, cost);

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_insufficient_tx_fee_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id =
        super::create_contract(&client, op.private_key.public_key(), ContractAdminKey::Operator)
            .await?;

    let res = ContractInfoQuery::new()
        .contract_id(contract_id)
        .max_payment_amount(Hbar::from_tinybars(10000))
        .payment_amount(Hbar::from_tinybars(1))
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryPaymentPreCheckStatus { status: Status::InsufficientTxFee, .. })
    );

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/contract/mod.rs
use hedera::{
    ContractCreateTransaction,
    ContractFunctionParameters,
    ContractId,
    FileId,
    PublicKey,
};

mod bytecode;
mod create;
mod create_flow;
mod delete;
mod execute;
mod info;
mod nonce_info;
mod update;

enum ContractAdminKey {
    Operator,
    // Custom(PrivateKey),
}

const SMART_CONTRACT_BYTECODE: &str = concat!(
    "608060405234801561001057600080fd5b506040516104d73803806104d7833981810160405260208110156100",
    "3357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b908301906020",
    "82018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081",
    "516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050",
    "905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b50604052",
    "5050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa",
    "565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f",
    "1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561",
    "017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b80",
    "8211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561",
    "001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee57",
    "8063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b810190602081",
    "01813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001",
    "918460018302840111640100000000831117156100ab57600080fd5b91908080601f0160208091040260200160",
    "405190810160405280939291908181526020018383808284376000920191909152509295506101739450505050",
    "50565b005b6100ec6101a2565b6100fe6101ba565b604080516020808252835181830152835191928392908301",
    "9185019080838360005b83811015610138578181015183820152602001610120565b5050505090509081019060",
    "1f1680156101655780820380516001836020036101000a031916815260200191505b5092505050604051809103",
    "90f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b",
    "505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f60026000",
    "196101008789161502019095169490940493840181900481028201810190925282815260609390929091830182",
    "8280156102455780601f1061021a57610100808354040283529160200191610245565b82019190600052602060",
    "0020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b82",
    "8054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106102",
    "9157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be57",
    "82518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b80821115",
    "6102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625",
    "aa3c8a12de41ae5519752fc89064736f6c63430006000033"
);

/// Creates a File for [`SMART_CONTRACT_BYTECODE`] and returns the File ID.
///
/// If there's already a file for it, the same file will be used.
///
/// *Deleting the file can cause spurious failures in tests, so, don't do that* (it'll expire in `30 days` anyway).
///
/// This is intended as an optimization (cost wise & network resource wise).
async fn bytecode_file_id(
    client: &hedera::Client,
    op_key: hedera::PublicKey,
) -> hedera::Result<FileId> {
    use time::{
        Duration,
        OffsetDateTime,
    };
    static BYTECODE_FILE: tokio::sync::OnceCell<FileId> = tokio::sync::OnceCell::const_new();

    async fn make_file(
        client: &hedera::Client,
        op_key: hedera::PublicKey,
    ) -> hedera::Result<FileId> {
        let file_id = hedera::FileCreateTransaction::new()
            .keys([op_key])
            .contents(SMART_CONTRACT_BYTECODE)
            .expiration_time(OffsetDateTime::now_utc() + Duration::days(30))
            .execute(client)
            .await?
            .get_receipt(client)
            .await?
            .file_id
            .unwrap();

        log::debug!("created `{file_id}@file`");

        Ok(file_id)
    }

    BYTECODE_FILE.get_or_try_init(|| make_file(client, op_key)).await.copied()
}

async fn create_contract(
    client: &hedera::Client,
    op_key: PublicKey,
    admin_key: impl Into<Option<ContractAdminKey>>,
) -> hedera::Result<ContractId> {
    async fn inner(
        client: &hedera::Client,
        op_key: PublicKey,
        admin_key: Option<ContractAdminKey>,
    ) -> hedera::Result<ContractId> {
        let file_id = bytecode_file_id(client, op_key).await?;

        let mut tx = ContractCreateTransaction::new();

        if let Some(ContractAdminKey::Operator) = admin_key {
            tx.admin_key(op_key);
        }

        let contract_id = tx
            .gas(200_000)
            .constructor_parameters(
                ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
            )
            .bytecode_file_id(file_id)
            .contract_memo("[e2e::ContractCreateTransaction]")
            .execute(client)
            .await?
            .get_receipt(client)
            .await?
            .contract_id
            .unwrap();

        Ok(contract_id)
    }

    inner(client, op_key, admin_key.into()).await
}
// Filename: tests/e2e/contract/nonce_info.rs
use hedera::{
    ContractCreateTransaction,
    ContractDeleteTransaction,
    FileCreateTransaction,
    FileDeleteTransaction,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

const SMART_CONTRACT_BYTECODE: &str = "6080604052348015600f57600080fd5b50604051601a90603b565b604051809103906000f0801580156035573d6000803e3d6000fd5b50506047565b605c8061009483390190565b603f806100556000396000f3fe6080604052600080fdfea2646970667358221220a20122cbad3457fedcc0600363d6e895f17048f5caa4afdab9e655123737567d64736f6c634300081200336080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122053dfd8835e3dc6fedfb8b4806460b9b7163f8a7248bac510c6d6808d9da9d6d364736f6c63430008120033";

#[tokio::test]
async fn increment_nonce_through_contract_constructor() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents(SMART_CONTRACT_BYTECODE)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let response = ContractCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .gas(100000)
        .bytecode_file_id(file_id)
        .contract_memo("[e2e::ContractADeploysContractBInConstructor]")
        .execute(&client)
        .await?;

    let record = response.get_record(&client).await?;
    let contract_a = record.receipt.contract_id.unwrap();
    let contract_function_result = record.contract_function_result.unwrap();

    assert_eq!(contract_function_result.contract_nonces.len(), 2);

    let contract_a_nonce_info = contract_function_result
        .contract_nonces
        .iter()
        .find(|it| it.contract_id == contract_a)
        .unwrap();
    let contract_b_nonce_info = contract_function_result
        .contract_nonces
        .iter()
        .find(|it| it.contract_id != contract_a)
        .unwrap();

    // A.nonce = 2
    assert_eq!(contract_a_nonce_info.nonce, 2);
    // B.nonce = 1
    assert_eq!(contract_b_nonce_info.nonce, 1);

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_a)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/contract/update.rs
use assert_matches::assert_matches;
use hedera::{
    ContractDeleteTransaction,
    ContractInfoQuery,
    ContractUpdateTransaction,
    Key,
    Status,
};

use super::ContractAdminKey;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id =
        super::create_contract(&client, op.private_key.public_key(), ContractAdminKey::Operator)
            .await?;

    ContractUpdateTransaction::new()
        .contract_id(contract_id)
        .contract_memo("[e2e::ContractUpdateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ContractInfoQuery::new().contract_id(contract_id).execute(&client).await?;

    assert_eq!(info.contract_id, contract_id);
    assert_eq!(info.account_id.to_string(), info.contract_id.to_string());
    assert_eq!(info.admin_key, Some(Key::Single(op.private_key.public_key())));
    assert_eq!(info.storage, 128);
    assert_eq!(info.contract_memo, "[e2e::ContractUpdateTransaction]");

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_contract_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = ContractUpdateTransaction::new()
        .contract_memo("[e2e::ContractUpdateTransaction]")
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidContractId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn immutable_contract_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let contract_id = super::create_contract(&client, op.private_key.public_key(), None).await?;

    let res = ContractUpdateTransaction::new()
        .contract_id(contract_id)
        .contract_memo("[e2e::ContractUpdateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::ModifyingImmutableContract, .. })
    );

    Ok(())
}
// Filename: tests/e2e/ethereum_transaction.rs
use bytes::{
    BufMut,
    BytesMut,
};
use hedera::{
    AccountInfoQuery,
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractExecuteTransaction,
    ContractFunctionParameters,
    EthereumTransaction,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
    PrivateKey,
    TransferTransaction,
};
use rlp::RlpStream;

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

const SMART_CONTRACT_BYTECODE: &str =
        "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

#[tokio::test]
#[ignore = "Temporarily disabled for incoming local-node fix"]
async fn signer_nonce_changed_on_ethereum_transaction() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    if !config.is_local {
        log::debug!("skipping test due to non-local");
        return Ok(());
    }

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let private_key = PrivateKey::generate_ecdsa();
    let new_alias_id = private_key.to_account_id(0, 0);

    _ = TransferTransaction::new()
        .hbar_transfer(op.account_id, Hbar::new(-1))
        .hbar_transfer(new_alias_id, Hbar::new(1))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Check if Alias Account has been auto-created;
    let _ = AccountInfoQuery::new().account_id(new_alias_id).execute(&client).await?;

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents(SMART_CONTRACT_BYTECODE)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let contract_id = ContractCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .gas(200_000)
        .constructor_parameters(
            ContractFunctionParameters::new().add_string("Hello from Hedera.").to_bytes(None),
        )
        .bytecode_file_id(file_id)
        .contract_memo("[e2e::ContractCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .contract_id
        .unwrap();

    let chain_id = hex::decode("012a").unwrap();
    let nonce = hex::decode("00").unwrap();
    let max_priority_gas = hex::decode("00").unwrap();
    let max_gas = hex::decode("d1385c7bf0").unwrap();
    let gas_limit = hex::decode("0249f0").unwrap();
    let to = hex::decode(contract_id.to_solidity_address().unwrap()).unwrap();
    let value = hex::decode("00").unwrap();
    let call_data: Vec<u8> = ContractExecuteTransaction::new()
        .function_with_parameters(
            "setMessage",
            ContractFunctionParameters::new().add_string("new message"),
        )
        .get_function_parameters()
        .try_into()
        .unwrap();

    let access_list: Vec<u8> = vec![];
    let rec_id = hex::decode("01").map_err(|e| e)?;

    let mut rlp_bytes = BytesMut::new();

    rlp_bytes.put_u8(0x02);

    // RLP encoding the transaction data
    let mut list = RlpStream::new_list_with_buffer(rlp_bytes, 12);
    list.append(&chain_id)
        .append(&nonce)
        .append(&max_priority_gas)
        .append(&max_gas)
        .append(&gas_limit) // Gas limit
        .append(&to)
        .append(&value) // Value
        .append(&call_data)
        .append(&access_list.as_slice());

    let sequence = list.as_raw();

    let signed_bytes = private_key.sign(&sequence);

    let r = &signed_bytes[0..32];
    let s = &signed_bytes[32..64];

    // Add recovery id, r, s values to the list
    list.append(&rec_id);
    list.append(&r);
    list.append(&s);

    let eth_resp =
        EthereumTransaction::new().ethereum_data(list.out().to_vec()).execute(&client).await?;

    // Local node fails to query the record after a successful ethereum transaction.
    // Note: This is a service related bug.
    let eth_record = eth_resp.get_record(&client).await.unwrap();

    let signer_nonce = eth_record.contract_function_result.unwrap().signer_nonce;

    assert_eq!(signer_nonce, Some(1));

    ContractDeleteTransaction::new()
        .transfer_account_id(op.account_id)
        .contract_id(contract_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/fee_schedules.rs
use hedera::{
    FeeSchedules,
    FileContentsQuery,
    FileId,
};

use crate::common::TestEnvironment;

#[tokio::test]
async fn fetch_fee_schedules() -> anyhow::Result<()> {
    let TestEnvironment { client, config: _ } = crate::common::setup_global();

    let contents =
        FileContentsQuery::new().file_id(FileId::new(0, 0, 111)).execute(&client).await?.contents;

    let fee_schedules = FeeSchedules::from_bytes(&contents)?;

    assert!(fee_schedules.current.is_some());

    Ok(())
}
// Filename: tests/e2e/file/append.rs
use hedera::{
    FileAppendTransaction,
    FileContentsQuery,
    FileCreateTransaction,
    FileDeleteTransaction,
    FileInfoQuery,
};
use time::Duration;

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::resources;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    // There are potential bugs in FileAppendTransaction which require more than one node to trigger.
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    // assume_not_local_node

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_append::1]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    FileAppendTransaction::new()
        .file_id(file_id)
        .contents("update")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(info.file_id, file_id);
    assert_eq!(info.size, 33);

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn large_contents() -> anyhow::Result<()> {
    // There are potential bugs in FileAppendTransaction which require more than one node to trigger.
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    // assume_not_local_node

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_append::2]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    FileAppendTransaction::new()
        .file_id(file_id)
        .contents(resources::BIG_CONTENTS)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let contents = FileContentsQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(
        String::from_utf8(contents.contents).unwrap(),
        format!("[rust::e2e::file_append::2]{}", resources::BIG_CONTENTS)
    );

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(info.file_id, file_id);
    assert_eq!(info.size, 13521);

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn large_contents_small_valid_duration() -> anyhow::Result<()> {
    // There are potential bugs in FileAppendTransaction which require more than one node to trigger.
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    // assume_not_local_node

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_append::3]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    // note the transaction_valid_duration, this is the *only* difference between the last test and this one, I'm not sure it actually even properly tests that.
    FileAppendTransaction::new()
        .file_id(file_id)
        .contents(resources::BIG_CONTENTS)
        .transaction_valid_duration(Duration::seconds(25))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let contents = FileContentsQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(
        String::from_utf8(contents.contents).unwrap(),
        format!("[rust::e2e::file_append::3]{}", resources::BIG_CONTENTS)
    );

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(info.file_id, file_id);
    assert_eq!(info.size, 13521);

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/file/contents.rs
use assert_matches::assert_matches;
use hedera::{
    FileContentsQuery,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_contents::1]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let contents = FileContentsQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(contents.contents, b"[rust::e2e::file_contents::1]");

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn query_empty() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let contents = FileContentsQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(contents.contents, b"");

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_file_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = FileContentsQuery::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryNoPaymentPreCheckStatus { status: Status::InvalidFileId })
    );

    Ok(())
}

#[tokio::test]
async fn query_cost_big_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_contents::2]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let mut query = FileContentsQuery::new();

    query.file_id(file_id).max_payment_amount(Hbar::new(1000));

    let cost = query.get_cost(&client).await?;

    let contents = query.payment_amount(cost).execute(&client).await?;

    assert_eq!(contents.contents, b"[rust::e2e::file_contents::2]");

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_small_max_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_contents::3]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let mut query = FileContentsQuery::new();

    query.file_id(file_id).max_payment_amount(Hbar::from_tinybars(1));

    let cost = query.get_cost(&client).await?;

    let res = query.execute(&client).await;

    let (max_query_payment, query_cost) = assert_matches!(
        res,
        Err(hedera::Error::MaxQueryPaymentExceeded {
            max_query_payment,
            query_cost
        }) => (max_query_payment, query_cost)
    );

    assert_eq!(max_query_payment, Hbar::from_tinybars(1));
    // note: there's a very small chance this fails if the cost of a FileContentsQuery changes right when we execute it.
    assert_eq!(query_cost, cost);

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn query_insufficient_tx_fee_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_contents::4]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let res = FileContentsQuery::new()
        .file_id(file_id)
        .max_payment_amount(Hbar::from_tinybars(10000))
        .payment_amount(Hbar::from_tinybars(1))
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryPaymentPreCheckStatus { status: Status::InsufficientTxFee, .. })
    );

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/file/create.rs
use hedera::{
    FileCreateTransaction,
    FileDeleteTransaction,
    FileInfoQuery,
    Key,
    KeyList,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_create]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(info.file_id, file_id);
    assert_eq!(info.size, 24);
    assert!(!info.is_deleted);
    assert_eq!(
        info.keys,
        KeyList { keys: Vec::from([Key::Single(op.private_key.public_key())]), threshold: None }
    );

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn empty_file() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(info.file_id, file_id);
    assert_eq!(info.size, 0);
    assert!(!info.is_deleted);
    assert_eq!(
        info.keys,
        KeyList { keys: Vec::from([Key::Single(op.private_key.public_key())]), threshold: None }
    );

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn no_keys() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(info.file_id, file_id);
    assert_eq!(info.size, 0);
    assert!(!info.is_deleted);
    assert_eq!(info.keys, KeyList { keys: Vec::new(), threshold: None });

    Ok(())
}
// Filename: tests/e2e/file/delete.rs
use assert_matches::assert_matches;
use hedera::{
    FileCreateTransaction,
    FileDeleteTransaction,
    FileInfoQuery,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_delete::1]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert!(info.is_deleted);

    Ok(())
}

#[tokio::test]
async fn immutable_file_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .contents("[rust::e2e::file_delete::2]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let res = FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(res, Err(hedera::Error::ReceiptStatus { status: Status::Unauthorized, .. }));

    Ok(())
}
// Filename: tests/e2e/file/info.rs
use assert_matches::assert_matches;
use hedera::{
    FileCreateTransaction,
    FileDeleteTransaction,
    FileInfoQuery,
    Hbar,
    Key,
    KeyList,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_info::1]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(info.file_id, file_id);
    assert_eq!(info.size, 25);
    assert!(!info.is_deleted);
    assert_eq!(
        info.keys,
        KeyList { keys: Vec::from([Key::Single(op.private_key.public_key())]), threshold: None }
    );

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn query_empty_no_admin_key() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(info.file_id, file_id);
    assert_eq!(info.size, 0);
    assert!(!info.is_deleted);
    assert!(info.keys.is_empty());

    Ok(())
}

#[tokio::test]
async fn query_cost_big_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_info::2]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let mut query = FileInfoQuery::new();

    query.file_id(file_id).max_payment_amount(Hbar::new(1000));

    let cost = query.get_cost(&client).await?;

    query.payment_amount(cost).execute(&client).await?;

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_small_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_info::3]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let mut query = FileInfoQuery::new();

    query.file_id(file_id).max_payment_amount(Hbar::from_tinybars(1));

    let cost = query.get_cost(&client).await?;

    let res = query.execute(&client).await;

    let (max_query_payment, query_cost) = assert_matches!(
        res,
        Err(hedera::Error::MaxQueryPaymentExceeded {
            max_query_payment,
            query_cost
        }) => (max_query_payment, query_cost)
    );

    assert_eq!(max_query_payment, Hbar::from_tinybars(1));
    // note: there's a very small chance this fails if the cost of a FileContentsQuery changes right when we execute it.
    assert_eq!(query_cost, cost);

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_insufficient_tx_fee() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_info::4]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let res = FileInfoQuery::new()
        .file_id(file_id)
        .max_payment_amount(Hbar::from_tinybars(10000))
        .payment_amount(Hbar::from_tinybars(1))
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryPaymentPreCheckStatus { status: Status::InsufficientTxFee, .. })
    );

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/file/mod.rs
mod append;
mod contents;
mod create;
mod delete;
mod info;
mod update;
// Filename: tests/e2e/file/update.rs
use assert_matches::assert_matches;
use hedera::{
    FileCreateTransaction,
    FileDeleteTransaction,
    FileInfoQuery,
    FileUpdateTransaction,
    Key,
    KeyList,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .keys([op.private_key.public_key()])
        .contents("[rust::e2e::file_update::1]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    FileUpdateTransaction::new()
        .file_id(file_id)
        .contents(b"updated file".to_vec())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = FileInfoQuery::new().file_id(file_id).execute(&client).await?;

    assert_eq!(info.file_id, file_id);
    assert_eq!(info.size, 12);
    assert!(!info.is_deleted);
    assert_eq!(
        info.keys,
        KeyList { keys: Vec::from([Key::Single(op.private_key.public_key())]), threshold: None }
    );

    FileDeleteTransaction::new()
        .file_id(file_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn immutable_file_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let file_id = FileCreateTransaction::new()
        .contents("[rust::e2e::file_update::2]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .file_id
        .unwrap();

    let res = FileUpdateTransaction::new()
        .file_id(file_id)
        .contents(Vec::from([0]))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(res, Err(hedera::Error::ReceiptStatus { status: Status::Unauthorized, .. }));

    Ok(())
}

#[tokio::test]
async fn missing_file_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = FileUpdateTransaction::new().contents(b"contents".to_vec()).execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidFileId, .. })
    );

    Ok(())
}
// Filename: tests/e2e/main.rs
mod account;
mod address_book;
mod client;
mod common;
mod contract;
mod ethereum_transaction;
mod fee_schedules;
mod file;
mod network_version_info;
mod node_address_book;
mod prng;
/// Resources for various tests.
///
/// todo: somehow deduplicate this with the version in `examples/`.
mod resources;
mod schedule;
mod token;
mod topic;
// Filename: tests/e2e/network_version_info.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    NetworkVersionInfoQuery,
    Status,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let _info = NetworkVersionInfoQuery::new().execute(&client).await?;

    Ok(())
}

#[tokio::test]
async fn query_cost() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let mut query = NetworkVersionInfoQuery::new();

    query.max_payment_amount(Hbar::new(1));

    let cost = query.get_cost(&client).await?;

    let _info = query.payment_amount(cost).execute(&client).await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_big_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let mut query = NetworkVersionInfoQuery::new();

    query.max_payment_amount(Hbar::MAX);

    let cost = query.get_cost(&client).await?;

    let _info = query.payment_amount(cost).execute(&client).await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_small_max_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let mut query = NetworkVersionInfoQuery::new();

    query.max_payment_amount(Hbar::from_tinybars(1));

    let cost = query.get_cost(&client).await?;

    let res = query.execute(&client).await;

    let (max_query_payment, query_cost) = assert_matches!(
        res,
        Err(hedera::Error::MaxQueryPaymentExceeded {
            max_query_payment,
            query_cost
        }) => (max_query_payment, query_cost)
    );

    assert_eq!(max_query_payment, Hbar::from_tinybars(1));
    // note: there's a very small chance this fails if the cost of a NetworkVersionInfoQuery changes right when we execute it.
    assert_eq!(query_cost, cost);

    Ok(())
}

#[tokio::test]
async fn get_cost_insufficient_tx_fee_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = NetworkVersionInfoQuery::new() //
        .max_payment_amount(Hbar::from_tinybars(10000))
        .payment_amount(Hbar::from_tinybars(1))
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryPaymentPreCheckStatus { status: Status::InsufficientTxFee, .. })
    );

    Ok(())
}
// Filename: tests/e2e/node_address_book.rs
use hedera::NodeAddressBookQuery;

use crate::common::TestEnvironment;

// a fairly trivial function, but one worth having because it actually tests mirror-net.
#[tokio::test]
async fn query_address_book() -> anyhow::Result<()> {
    let TestEnvironment { client, config } = crate::common::setup_global();

    if config.is_local {
        return Ok(());
    }

    let _ = NodeAddressBookQuery::new().execute(&client).await?;

    Ok(())
}
// Filename: tests/e2e/prng.rs
use hedera::PrngTransaction;

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let record =
        PrngTransaction::new().range(100).execute(&client).await?.get_record(&client).await?;

    assert!(record.prng_number.is_some_and(|it| it < 100));

    Ok(())
}
// Filename: tests/e2e/resources/mod.rs
#![allow(dead_code)]

pub const BIG_CONTENTS: &str = include_str!("big_contents.txt");

// /// Bytecode for the simple contract example.
// pub fn simple_bytecode() -> String {
//     const FILE: &'static str = include_str!("hello-world.json");

//     bytecode(FILE)
// }
// /// Bytecode for the stateful contract example.
// pub fn stateful_bytecode() -> String {
//     const FILE: &'static str = include_str!("stateful.json");

//     bytecode(FILE)
// }

// fn bytecode(file: &'static str) -> String {
//     let mut obj: miniserde::json::Object = miniserde::json::from_str(file).unwrap();

//     let value = obj.remove("object").or_else(|| obj.remove("bytecode")).unwrap();

//     match value {
//         miniserde::json::Value::String(it) => return it.clone(),
//         _ => unimplemented!(),
//     }
// }
// Filename: tests/e2e/schedule/create.rs
use std::hash::{
    DefaultHasher,
    Hash,
    Hasher,
};
use std::thread::sleep;

use assert_matches::assert_matches;
use hedera::{
    AccountBalanceQuery,
    AccountCreateTransaction,
    AccountDeleteTransaction,
    AccountUpdateTransaction,
    Hbar,
    Key,
    KeyList,
    PrivateKey,
    ScheduleCreateTransaction,
    ScheduleId,
    ScheduleInfoQuery,
    ScheduleSignTransaction,
    Status,
    TopicCreateTransaction,
    TopicMessageSubmitTransaction,
    TransferTransaction,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

// Seconds in a day
const TEST_SECONDS: i64 = 86400;

#[tokio::test]
#[ignore = "not implemented in Hiero yet"]
async fn create_account() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let mut transaction = AccountCreateTransaction::new();
    transaction.key(key.public_key());

    let schedule_id = ScheduleCreateTransaction::new()
        .scheduled_transaction(transaction)
        .admin_key(op.private_key.public_key())
        .payer_account_id(op.account_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    assert!(info.executed_at.is_some());

    Ok(())
}

#[tokio::test]
#[ignore = "not implemented in Hiero yet"]
async fn create_account_schedule() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let mut transaction = AccountCreateTransaction::new();
    transaction.key(key.public_key());

    let schedule_id = transaction
        .schedule()
        .admin_key(op.private_key.public_key())
        .payer_account_id(op.account_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    assert!(info.executed_at.is_some());
    info.scheduled_transaction().unwrap();

    Ok(())
}

#[tokio::test]
async fn transfer() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let key1 = PrivateKey::generate_ed25519();
    let key2 = PrivateKey::generate_ed25519();
    let key3 = PrivateKey::generate_ed25519();

    let key_list = KeyList::from([key1.public_key(), key2.public_key().into(), key3.public_key()]);

    // Create the account with the `KeyList`
    let mut transaction = AccountCreateTransaction::new();
    let receipt = transaction
        .key(key_list)
        .initial_balance(Hbar::new(1))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let account_id = receipt.account_id.unwrap();

    // Create a transfer transaction with 2/3 signatures.
    let mut transfer = TransferTransaction::new();

    transfer.hbar_transfer(account_id, Hbar::new(-1)).hbar_transfer(op.account_id, Hbar::new(1));

    // Schedule the transactoin
    let mut scheduled = transfer.schedule();

    let receipt = scheduled.execute(&client).await?.get_receipt(&client).await?;

    // Get the schedule ID from the receipt
    let schedule_id = receipt.schedule_id.unwrap();

    // Get the schedule info to see if `signatories` is populated with 2/3 signatures
    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    assert_eq!(info.executed_at, None);

    // Finally send this last signature to Hiero. This last signature _should_ mean the transaction executes
    // since all 3 signatures have been provided.
    ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .sign(key1.clone())
        .sign(key2.clone())
        .sign(key3.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    assert!(info.executed_at.is_some());

    AccountDeleteTransaction::new()
        .account_id(account_id)
        .transfer_account_id(op.account_id)
        .sign(key1)
        .sign(key2)
        .sign(key3)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn double_schedule_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(1), &client).await?;

    let mut transfer = TransferTransaction::new();

    transfer.hbar_transfer(op.account_id, Hbar::new(-1)).hbar_transfer(account.id, Hbar::new(1));

    let schedule_id_1 = transfer
        .schedule()
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info1 = ScheduleInfoQuery::new().schedule_id(schedule_id_1).execute(&client).await?;

    assert!(info1.executed_at.is_some());

    let mut transfer = TransferTransaction::new();

    transfer.hbar_transfer(op.account_id, Hbar::new(-1)).hbar_transfer(account.id, Hbar::new(1));

    let res = transfer.schedule().execute(&client).await?.get_receipt(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::IdenticalScheduleAlreadyCreated, .. })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn topic_message() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    // This is the submit key
    let key = PrivateKey::generate_ed25519();

    let topic_id = TopicCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .auto_renew_account_id(op.account_id)
        .topic_memo("HCS Topic_")
        .submit_key(key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .topic_id
        .unwrap();

    let mut transaction = TopicMessageSubmitTransaction::new();

    transaction.topic_id(topic_id).message("scheduled hcs message");

    // create schedule
    let schedule_id = transaction
        .schedule()
        .admin_key(op.private_key.public_key())
        .payer_account_id(op.account_id)
        .schedule_memo(format!(
            "mirror scheduled E2E signature on create and sign_{}",
            OffsetDateTime::now_utc()
        ))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    assert_eq!(info.schedule_id, schedule_id);

    ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .sign(key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    assert!(info.executed_at.is_some());

    Ok(())
}

#[tokio::test]
async fn can_sign_schedule() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(10), &client).await?;

    // Create transaction to schedule
    let mut transfer = TransferTransaction::new();

    transfer.hbar_transfer(op.account_id, Hbar::new(1)).hbar_transfer(account.id, Hbar::new(-1));

    // Schedule transaction
    let schedule_id = transfer
        .schedule()
        .schedule_memo("HIP-423 E2E test")
        .expiration_time(OffsetDateTime::now_utc() + Duration::seconds(TEST_SECONDS))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction hasn't executed yet
    assert_eq!(info.executed_at, None);

    // Schedule sign
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(account.key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction has executed
    assert!(info.executed_at.is_some());

    assert_eq!(schedule_id.checksum, None);
    assert_eq!(schedule_id, ScheduleId::from_bytes(&schedule_id.to_bytes()[..])?);

    let mut hasher = DefaultHasher::new();

    schedule_id.hash(&mut hasher);
    assert_ne!(hasher.finish(), 0);

    Ok(())
}

#[tokio::test]
async fn schedule_ahead_one_year_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(10), &client).await?;

    // Create transaction to schedule
    let mut transfer = TransferTransaction::new();
    transfer.hbar_transfer(op.account_id, Hbar::new(1)).hbar_transfer(account.id, Hbar::new(-1));

    let res = transfer
        .schedule()
        .schedule_memo("HIP-423 E2E test")
        .expiration_time(OffsetDateTime::now_utc() + Duration::days(365))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: Status::ScheduleExpirationTimeTooFarInFuture,
            ..
        })
    );

    Ok(())
}

#[tokio::test]
async fn schedule_in_the_past_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(10), &client).await?;

    // Create transaction to schedule
    let mut transfer = TransferTransaction::new();
    transfer.hbar_transfer(op.account_id, Hbar::new(1)).hbar_transfer(account.id, Hbar::new(-1));

    let res = transfer
        .schedule()
        .schedule_memo("HIP-423 E2E test")
        .expiration_time(OffsetDateTime::now_utc() - Duration::seconds(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: Status::ScheduleExpirationTimeMustBeHigherThanConsensusTime,
            ..
        })
    );

    Ok(())
}

#[tokio::test]
async fn sign_schedule_and_wait_for_expiry() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(10), &client).await?;

    // Create transaction to schedule
    let mut transfer = TransferTransaction::new();

    transfer.hbar_transfer(op.account_id, Hbar::new(1)).hbar_transfer(account.id, Hbar::new(-1));

    // Schedule transaction
    let schedule_id = transfer
        .schedule()
        .schedule_memo("HIP-423 E2E test")
        .wait_for_expiry(true)
        .expiration_time(OffsetDateTime::now_utc() + Duration::seconds(TEST_SECONDS))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction hasn't executed yet
    assert_eq!(info.executed_at, None);

    // Schedule sign
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(account.key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction hasn't executed yet
    assert!(info.executed_at.is_none());

    assert_eq!(schedule_id.checksum, None);
    assert_eq!(schedule_id, ScheduleId::from_bytes(&schedule_id.to_bytes()[..])?);

    let mut hasher = DefaultHasher::new();
    schedule_id.hash(&mut hasher);
    assert_ne!(hasher.finish(), 0);

    Ok(())
}

#[tokio::test]
async fn sign_with_multi_sig_and_update_signing_requirements() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let key1 = PrivateKey::generate_ed25519();
    let key2 = PrivateKey::generate_ed25519();
    let key3 = PrivateKey::generate_ed25519();
    let key4 = PrivateKey::generate_ed25519();

    let key_list = KeyList {
        keys: vec![key1.public_key().into(), key2.public_key().into(), key3.public_key().into()],
        threshold: Some(2),
    };

    let account_id = AccountCreateTransaction::new()
        .key(key_list)
        .initial_balance(Hbar::new(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    // Create transaction to schedule
    let mut transfer = TransferTransaction::new();

    transfer.hbar_transfer(op.account_id, Hbar::new(1)).hbar_transfer(account_id, Hbar::new(-1));

    // Schedule transaction
    let schedule_id = transfer
        .schedule()
        .schedule_memo("HIP-423 E2E test")
        .expiration_time(OffsetDateTime::now_utc() + Duration::seconds(86400))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction hasn't executed yet
    assert_eq!(info.executed_at, None);

    // Schedule sign
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key1.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction hasn't executed yet
    assert_eq!(info.executed_at, None);

    // Update the signing requirements
    _ = AccountUpdateTransaction::new()
        .account_id(account_id)
        .key(Key::Single(key4.public_key()))
        .freeze_with(&client)?
        .sign(key1)
        .sign(key2)
        .sign(key4.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction hasn't executed yet
    assert_eq!(info.executed_at, None);

    // Schedule sign
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key4)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the schedule is executed
    assert!(info.executed_at.is_some());

    Ok(())
}

#[tokio::test]
async fn sign_with_multi_sig() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let key1 = PrivateKey::generate_ed25519();
    let key2 = PrivateKey::generate_ed25519();
    let key3 = PrivateKey::generate_ed25519();

    let key_list = KeyList {
        keys: vec![key1.public_key().into(), key2.public_key().into(), key3.public_key().into()],
        threshold: Some(2),
    };

    let account_id = AccountCreateTransaction::new()
        .key(key_list)
        .initial_balance(Hbar::new(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    // Create transaction to schedule
    let mut transfer = TransferTransaction::new();

    transfer.hbar_transfer(op.account_id, Hbar::new(1)).hbar_transfer(account_id, Hbar::new(-1));

    // Schedule transaction
    let schedule_id = transfer
        .schedule()
        .schedule_memo("HIP-423 E2E test")
        .expiration_time(OffsetDateTime::now_utc() + Duration::seconds(86400))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction hasn't executed yet
    assert_eq!(info.executed_at, None);

    // Schedule sign
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key1.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction has still not executed
    assert_eq!(info.executed_at, None);

    // Update the signing requirements
    _ = AccountUpdateTransaction::new()
        .account_id(account_id)
        .key(key1.public_key())
        .freeze_with(&client)?
        .sign(key1)
        .sign(key2.clone())
        .execute(&client)
        .await?
        .get_receipt(&client);

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction has still not executed
    assert_eq!(info.executed_at, None);

    // Schedule sign with one key
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(key2)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the schedule is executed
    assert!(info.executed_at.is_some());

    Ok(())
}

#[tokio::test]
async fn execute_with_short_exp_time() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(10), &client).await?;

    // Create transaction to schedule
    let mut transfer = TransferTransaction::new();

    transfer.hbar_transfer(op.account_id, Hbar::new(1)).hbar_transfer(account.id, Hbar::new(-1));

    // Schedule transaction
    let schedule_id = transfer
        .schedule()
        .schedule_memo("HIP-423 E2E test")
        .wait_for_expiry(true)
        .expiration_time(OffsetDateTime::now_utc() + Duration::seconds(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction hasn't executed yet
    assert_eq!(info.executed_at, None);

    // Sign
    _ = ScheduleSignTransaction::new()
        .schedule_id(schedule_id)
        .freeze_with(&client)?
        .sign(account.key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    // Verify the transaction has still not executed
    assert_eq!(info.executed_at, None);

    let initial_balance =
        AccountBalanceQuery::new().account_id(account.id).execute(&client).await?;

    sleep(std::time::Duration::from_millis(10_000));

    let new_balance = AccountBalanceQuery::new().account_id(account.id).execute(&client).await?;

    // Verify the schedule is executed after 10 seconds
    assert_eq!(initial_balance.hbars, new_balance.hbars + Hbar::new(1));

    Ok(())
}
// Filename: tests/e2e/schedule/delete.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    ScheduleDeleteTransaction,
    Status,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(1), &client).await?;

    let schedule_id = {
        let mut tx = TransferTransaction::new();
        tx.hbar_transfer(account.id, Hbar::new(-1)).hbar_transfer(op.account_id, Hbar::new(1));

        tx.schedule()
            .admin_key(op.private_key.public_key())
            .execute(&client)
            .await?
            .get_receipt(&client)
            .await?
            .schedule_id
            .unwrap()
    };

    ScheduleDeleteTransaction::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_admin_key_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(1), &client).await?;

    let schedule_id = {
        let mut tx = TransferTransaction::new();
        tx.hbar_transfer(account.id, Hbar::new(-1)).hbar_transfer(op.account_id, Hbar::new(1));

        tx.schedule().execute(&client).await?.get_receipt(&client).await?.schedule_id.unwrap()
    };

    let res = ScheduleDeleteTransaction::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::ScheduleIsImmutable, .. })
    );

    Ok(())
}

#[tokio::test]
async fn double_delete_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(1), &client).await?;

    let schedule_id = {
        let mut tx = TransferTransaction::new();
        tx.hbar_transfer(account.id, Hbar::new(-1)).hbar_transfer(op.account_id, Hbar::new(1));

        tx.schedule()
            .admin_key(op.private_key.public_key())
            .execute(&client)
            .await?
            .get_receipt(&client)
            .await?
            .schedule_id
            .unwrap()
    };

    ScheduleDeleteTransaction::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = ScheduleDeleteTransaction::new()
        .schedule_id(schedule_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::ScheduleAlreadyDeleted, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_schedule_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = ScheduleDeleteTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidScheduleId, .. })
    );

    Ok(())
}
// Filename: tests/e2e/schedule/info.rs
use assert_matches::assert_matches;
use hedera::{
    AccountCreateTransaction,
    Hbar,
    KeyList,
    PrivateKey,
    ScheduleCreateTransaction,
    ScheduleInfoQuery,
    Status,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
#[ignore = "not implemented in Hiero yet"]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let key = PrivateKey::generate_ed25519();

    let mut transaction = AccountCreateTransaction::new();
    transaction.key(key.public_key());

    let schedule_id = ScheduleCreateTransaction::new()
        .scheduled_transaction(transaction)
        .admin_key(op.private_key.public_key())
        .payer_account_id(op.account_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .schedule_id
        .unwrap();

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    assert!(info.executed_at.is_some());
    info.scheduled_transaction().unwrap();

    Ok(())
}

#[tokio::test]
async fn query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(1), &client).await?;

    let schedule_id = {
        let mut tx = TransferTransaction::new();
        tx.hbar_transfer(account.id, Hbar::new(-1)).hbar_transfer(op.account_id, Hbar::new(1));

        tx.schedule().execute(&client).await?.get_receipt(&client).await?.schedule_id.unwrap()
    };

    let info = ScheduleInfoQuery::new().schedule_id(schedule_id).execute(&client).await?;

    assert_eq!(info.admin_key, None);
    assert_eq!(info.creator_account_id, op.account_id);
    assert_eq!(info.deleted_at, None);
    assert_eq!(info.executed_at, None);
    assert!(info.expiration_time.is_some());
    // assert_eq!(info.ledger_id, client.ledger_id());
    assert_eq!(info.memo, "");
    assert_eq!(info.payer_account_id, Some(op.account_id));
    let _ = info.scheduled_transaction()?;

    assert_eq!(
        info.signatories,
        KeyList { keys: vec![op.private_key.public_key().into()].into(), threshold: None }
    );
    assert!(!info.wait_for_expiry);

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_schedule_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = ScheduleInfoQuery::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryNoPaymentPreCheckStatus { status: Status::InvalidScheduleId })
    );

    Ok(())
}

#[tokio::test]
async fn query_cost() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(1), &client).await?;

    let schedule_id = {
        let mut tx = TransferTransaction::new();
        tx.hbar_transfer(account.id, Hbar::new(-1)).hbar_transfer(op.account_id, Hbar::new(1));

        tx.schedule().execute(&client).await?.get_receipt(&client).await?.schedule_id.unwrap()
    };

    let mut query = ScheduleInfoQuery::new();

    query.schedule_id(schedule_id);

    let cost = query.get_cost(&client).await?;

    _ = query.payment_amount(cost).execute(&client).await?;

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_big_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(1), &client).await?;

    let schedule_id = {
        let mut tx = TransferTransaction::new();
        tx.hbar_transfer(account.id, Hbar::new(-1)).hbar_transfer(op.account_id, Hbar::new(1));

        tx.schedule().execute(&client).await?.get_receipt(&client).await?.schedule_id.unwrap()
    };

    let mut query = ScheduleInfoQuery::new();

    query.schedule_id(schedule_id).max_payment_amount(Hbar::new(1000));

    let cost = query.get_cost(&client).await?;

    let _ = query.payment_amount(cost).execute(&client).await?;

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_small_max_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(1), &client).await?;

    let schedule_id = {
        let mut tx = TransferTransaction::new();
        tx.hbar_transfer(account.id, Hbar::new(-1)).hbar_transfer(op.account_id, Hbar::new(1));

        tx.schedule().execute(&client).await?.get_receipt(&client).await?.schedule_id.unwrap()
    };

    let mut query = ScheduleInfoQuery::new();

    query.schedule_id(schedule_id).max_payment_amount(Hbar::from_tinybars(1));

    let cost = query.get_cost(&client).await?;

    let res = query.execute(&client).await;

    let (max_query_payment, query_cost) = assert_matches!(
        res,
        Err(hedera::Error::MaxQueryPaymentExceeded {
            max_query_payment,
            query_cost
        }) => (max_query_payment, query_cost)
    );

    assert_eq!(max_query_payment, Hbar::from_tinybars(1));
    // note: there's a very small chance this fails if the cost of a FileContentsQuery changes right when we execute it.
    assert_eq!(query_cost, cost);

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_insufficient_tx_fee_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let account = Account::create(Hbar::new(1), &client).await?;

    let schedule_id = {
        let mut tx = TransferTransaction::new();
        tx.hbar_transfer(account.id, Hbar::new(-1)).hbar_transfer(op.account_id, Hbar::new(1));

        tx.schedule().execute(&client).await?.get_receipt(&client).await?.schedule_id.unwrap()
    };

    let mut query = ScheduleInfoQuery::new();

    let res = query
        .schedule_id(schedule_id)
        .max_payment_amount(Hbar::from_tinybars(10000))
        .payment_amount(Hbar::from_tinybars(1))
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryPaymentPreCheckStatus { status: Status::InsufficientTxFee, .. })
    );

    account.delete(&client).await?;

    Ok(())
}
// Filename: tests/e2e/schedule/mod.rs
mod create;
mod delete;
mod info;
// Filename: tests/e2e/token/airdrop.rs
use std::iter::repeat;

use anyhow::anyhow;
use assert_matches::assert_matches;
use hedera::{
    AccountAllowanceApproveTransaction,
    AccountBalanceQuery,
    AccountCreateTransaction,
    FixedFee,
    FixedFeeData,
    Hbar,
    PrivateKey,
    Status,
    TokenAirdropTransaction,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenMintTransaction,
    TokenSupplyType,
    TransactionId,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    Config,
    TestEnvironment,
};
use crate::token::{
    FungibleToken,
    Nft,
    TEST_AMOUNT,
    TEST_FUNGIBLE_INITIAL_BALANCE,
};

#[tokio::test]
async fn airdrop_associated_tokens() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let metadata: Vec<Vec<u8>> = repeat(vec![9, 1, 6]).take(10).collect();

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with unlimited auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account =
        Account::create_with_max_associations(-1, &receiver_key, &client).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(metadata)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Airdrop tokens
    _ = TokenAirdropTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .token_transfer(token.id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Verify the receiver holds the tokens via query
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account.id).execute(&client).await?;

    assert_eq!(
        receiver_account_balance.tokens.get(&token.id).as_deref(),
        Some(&(TEST_AMOUNT as u64))
    );
    assert_eq!(receiver_account_balance.tokens.get(&nft.id).as_deref(), Some(&(2 as u64)));

    // Verify the operator does not hold the tokens
    let operator_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_balance.tokens.get(&token.id), Some(&(999_900 as u64)));
    assert_eq!(operator_balance.tokens.get(&nft.id), Some(&(8 as u64)));

    Ok(())
}

#[tokio::test]
async fn airdrop_non_associated_tokens() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let metadata: Vec<Vec<u8>> = repeat(vec![9, 1, 6]).take(10).collect();

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(metadata)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Airdrop tokens
    let mut tx = TokenAirdropTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .token_transfer(token.id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?;
    tx.validate_status(true).get_receipt(&client).await?;
    let record = tx.get_record(&client).await?;

    // Verify pending airdrops in the transaction record
    assert_eq!(record.pending_airdrop_records.is_empty(), false);

    // Verify the receiver holds the tokens via query
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account.id).execute(&client).await?;

    assert_eq!(receiver_account_balance.tokens.get(&token.id).as_deref(), None,);
    assert_eq!(receiver_account_balance.tokens.get(&nft.id).as_deref(), None);

    // Verify the operator does not hold the tokens
    let operator_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_balance.tokens.get(&token.id), Some(TEST_FUNGIBLE_INITIAL_BALANCE));
    assert_eq!(operator_balance.tokens.get(&nft.id), Some(&(10 as u64)));

    Ok(())
}

#[tokio::test]
async fn airdrop_to_alias() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let metadata: Vec<Vec<u8>> = repeat(vec![9, 1, 6]).take(10).collect();

    let operator_account = test_operator_account(&config).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(metadata)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Airdrop tokens to an alias
    let private_key = PrivateKey::generate_ed25519();
    let public_key = private_key.public_key();

    let alias_account_id = public_key.to_account_id(0, 0);

    // Airdrop tokens
    _ = TokenAirdropTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            alias_account_id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            alias_account_id,
        )
        .token_transfer(token.id, alias_account_id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Verify the receiver holds the tokens via query
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(alias_account_id).execute(&client).await?;

    assert_eq!(
        receiver_account_balance.tokens.get(&token.id).as_deref(),
        Some(&(TEST_AMOUNT as u64))
    );
    assert_eq!(receiver_account_balance.tokens.get(&nft.id).as_deref(), Some(&(2 as u64)));

    // Verify the operator does not hold the tokens
    let operator_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_balance.tokens.get(&token.id), Some(&(999_900 as u64)));
    assert_eq!(operator_balance.tokens.get(&nft.id), Some(&(8 as u64)));

    Ok(())
}

#[tokio::test]
async fn airdrop_with_custom_fees() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account =
        Account::create_with_max_associations(-1, &receiver_key, &client).await?;

    // Create a token and an NFT
    let custom_fee_token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    let fee = FixedFee {
        fee: FixedFeeData { amount: 1, denominating_token_id: Some(custom_fee_token.id) },
        fee_collector_account_id: Some(operator_account.id),
        all_collectors_are_exempt: true,
    };

    let token_id = TokenCreateTransaction::new()
        .name("Test Fungible Token")
        .symbol("TFT")
        .token_memo("I was created for integration tests")
        .decimals(3)
        .initial_supply(1_000_000)
        .max_supply(1_000_000)
        .treasury_account_id(operator_account.id)
        .token_supply_type(TokenSupplyType::Finite)
        .admin_key(operator_account.key.public_key())
        .freeze_key(operator_account.key.public_key())
        .supply_key(operator_account.key.public_key())
        .metadata_key(operator_account.key.public_key())
        .pause_key(operator_account.key.public_key())
        .custom_fees([fee.into()])
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    // Create sender account with unlimited associations and send some tokens to it
    let sender_key = PrivateKey::generate_ed25519();
    let sender_account = Account::create_with_max_associations(-1, &sender_key, &client).await?;

    // Associate the token to the sender
    _ = TokenAssociateTransaction::new()
        .account_id(sender_account.id)
        .token_ids([custom_fee_token.id])
        .freeze_with(&client)?
        .sign(sender_account.key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Send tokens to the sender
    _ = TransferTransaction::new()
        .token_transfer(custom_fee_token.id, operator_account.id, -TEST_AMOUNT)
        .token_transfer(custom_fee_token.id, sender_account.id, TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TransferTransaction::new()
        .token_transfer(token_id, operator_account.id, -TEST_AMOUNT)
        .token_transfer(token_id, sender_account.id, TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Airdrop tokens from the sender to the receiver
    _ = TokenAirdropTransaction::new()
        .token_transfer(token_id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token_id, sender_account.id, -TEST_AMOUNT)
        .freeze_with(&client)?
        .sign(sender_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Verify the custom fee has been paid by the sender to collector
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account.id).execute(&client).await?;

    assert_eq!(
        receiver_account_balance.tokens.get(&token_id).as_deref(),
        Some(&(TEST_AMOUNT as u64))
    );

    let sender_account_balance =
        AccountBalanceQuery::new().account_id(sender_account.id).execute(&client).await?;

    assert_eq!(sender_account_balance.tokens.get(&token_id).as_deref(), Some(&(0 as u64)));
    assert_eq!(sender_account_balance.tokens.get(&custom_fee_token.id), Some(&(99 as u64)));

    // Verify the operator does not hold the tokens
    let operator_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_balance.tokens.get(&token_id), Some(&(999_900 as u64)));
    assert_eq!(operator_balance.tokens.get(&custom_fee_token.id), Some(&(999_901 as u64)));

    Ok(())
}

#[tokio::test]
async fn airdrop_tokens_w_receiver_sig() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account_id = AccountCreateTransaction::new()
        .key(receiver_key.public_key())
        .initial_balance(Hbar::new(1))
        .receiver_signature_required(true)
        .max_automatic_token_associations(-1)
        .freeze_with(&client)?
        .sign(receiver_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    // Airdrop tokens
    _ = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account_id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn airdrop_nfts_w_receiver_sig() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };
    let operator_account = test_operator_account(&config).await?;

    // Create Nfts
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(10).collect::<Vec<Vec<u8>>>())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Create receiver with unlimited auto associations and receiver_sig = true
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account_id = AccountCreateTransaction::new()
        .key(receiver_key.public_key())
        .initial_balance(Hbar::new(1))
        .receiver_signature_required(true)
        .max_automatic_token_associations(-1)
        .freeze_with(&client)?
        .sign(receiver_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    // Airdrop tokens
    _ = TokenAirdropTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            receiver_account_id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            receiver_account_id,
        )
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn token_allowance_and_no_balance_ft_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a spender account with -1 auto associations
    let spender_key = PrivateKey::generate_ed25519();
    let spender_account = Account::create_with_max_associations(-1, &spender_key, &client).await?;

    // Create a receiver account with -1 auto associations
    let sender_key = PrivateKey::generate_ed25519();
    let sender_account = Account::create_with_max_associations(-1, &sender_key, &client).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    _ = TransferTransaction::new()
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .token_transfer(token.id, sender_account.id, TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Approve allowance to the spender
    _ = AccountAllowanceApproveTransaction::new()
        .approve_token_allowance(
            token.id,
            sender_account.id,
            spender_account.id,
            TEST_AMOUNT as u64,
        )
        .freeze_with(&client)?
        .sign(sender_account.key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Airdrop the tokens from the sender to the spender via approval
    // Fails with not supported status
    let res = TokenAirdropTransaction::new()
        .token_transfer(token.id, spender_account.id, TEST_AMOUNT)
        .approved_token_transfer(token.id, spender_account.id, -TEST_AMOUNT)
        .transaction_id(TransactionId::generate(spender_account.id))
        .freeze_with(&client)?
        .sign(spender_account.key)
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::NotSupported, .. })
    );

    Ok(())
}

#[tokio::test]
async fn token_allowance_and_no_balance_nft_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a spender account with -1 auto associations
    let spender_key = PrivateKey::generate_ed25519();
    let spender_account = Account::create_with_max_associations(-1, &spender_key, &client).await?;

    // Create a receiver account with -1 auto associations
    let sender_key = PrivateKey::generate_ed25519();
    let sender_account = Account::create_with_max_associations(-1, &sender_key, &client).await?;

    // Create Nft
    let nft = Nft::create(&client, &operator_account).await?;

    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(10).collect::<Vec<Vec<u8>>>())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    _ = TransferTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            sender_account.id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            sender_account.id,
        )
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Approve allowance to the spender
    _ = AccountAllowanceApproveTransaction::new()
        .approve_token_nft_allowance(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            sender_account.id,
            spender_account.id,
        )
        .approve_token_nft_allowance(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            sender_account.id,
            spender_account.id,
        )
        .freeze_with(&client)?
        .sign(sender_account.key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Airdrop the tokens from the sender to the spender via approval
    // Fails with not supported status
    let res = TokenAirdropTransaction::new()
        .approved_nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            sender_account.id,
            spender_account.id,
        )
        .approved_nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            sender_account.id,
            spender_account.id,
        )
        .transaction_id(TransactionId::generate(spender_account.id))
        .freeze_with(&client)?
        .sign(spender_account.key)
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::NotSupported, .. })
    );

    Ok(())
}

#[tokio::test]
async fn invalid_body_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Airdrop with no tokenID or NftID
    // fails with EMPTY_TOKEN_TRANSFER_BODY
    let res = TokenAirdropTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: Status::EmptyTokenTransferBody,
            ..
        })
    );

    // Create a fungible token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop with invalid transfers
    // fails with INVALID_TRANSACTION_BODY
    let res = TokenAirdropTransaction::new()
        .token_transfer(token.id, operator_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, TEST_AMOUNT)
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: Status::InvalidTransactionBody,
            ..
        })
    );

    Ok(())
}

async fn test_operator_account(config: &Config) -> anyhow::Result<Account> {
    if let Some(operator) = config.operator.clone() {
        Ok(Account { key: operator.private_key, id: operator.account_id })
    } else {
        return Err(anyhow!("no operator configured"));
    }
}
// Filename: tests/e2e/token/associate.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenAssociateTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, Default::default()).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");
        return Ok(());
    };

    TokenAssociateTransaction::new()
        .account_id(op.account_id)
        .freeze_with(&client)?
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_account_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenAssociateTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidAccountId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_signature_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenAssociateTransaction::new()
        .account_id(account.id)
        .freeze_with(&client)?
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    account.delete(&client).await?;

    Ok(())
}
// Filename: tests/e2e/token/burn.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenAssociateTransaction,
    TokenBurnTransaction,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    Key,
    Nft,
    TokenKeys,
};

const KEYS: TokenKeys = TokenKeys { supply: Some(Key::Owner), ..TokenKeys::DEFAULT };

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 10, keys: KEYS },
    )
    .await?;

    let receipt = TokenBurnTransaction::new()
        .amount(10_u64)
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    assert_eq!(receipt.total_supply, 0);

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenBurnTransaction::new().amount(10_u64).execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn burn_zero() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 0, keys: KEYS },
    )
    .await?;

    let receipt = TokenBurnTransaction::new()
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    assert_eq!(receipt.total_supply, 0);

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_supply_key_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 0, keys: KEYS },
    )
    .await?;

    let res = TokenBurnTransaction::new()
        .token_id(token.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn burn_nfts() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = Nft::create(&client, &account).await?;

    let serials = token.mint_incremental(&client, 10).await?;

    // this is specifically what we're testing here.
    TokenBurnTransaction::new()
        .serials(serials)
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn unowned_nft_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = Nft::create(&client, &alice).await?;
    let serials = token.mint_incremental(&client, 1).await?;

    let nft = token.id.nft(serials[0] as u64);

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .nft_transfer(nft, alice.id, bob.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TokenBurnTransaction::new()
        .serials([nft.serial as i64])
        .token_id(token.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TreasuryMustOwnBurnedNft, .. })
    );

    TransferTransaction::new()
        .nft_transfer(nft, bob.id, alice.id)
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.burn(&client, [nft.serial as i64]).await?;
    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}
// Filename: tests/e2e/token/cancel_airdrop.rs
use std::iter::repeat;

use anyhow::anyhow;
use assert_matches::assert_matches;
use hedera::{
    AccountBalanceQuery,
    PrivateKey,
    Status,
    TokenAirdropTransaction,
    TokenAssociateTransaction,
    TokenCancelAirdropTransaction,
    TokenFreezeTransaction,
    TokenMintTransaction,
    TokenPauseTransaction,
    TransactionId,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    Config,
    TestEnvironment,
};
use crate::token::{
    FungibleToken,
    Nft,
    TEST_AMOUNT,
    TEST_FUNGIBLE_INITIAL_BALANCE,
    TEST_MINTED_NFTS,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with unlimited auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(10).collect::<Vec<Vec<u8>>>())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Airdrop tokens
    let record = TokenAirdropTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .token_transfer(token.id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    let record = TokenCancelAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .add_pending_airdrop_id(record.pending_airdrop_records[1].pending_airdrop_id)
        .add_pending_airdrop_id(record.pending_airdrop_records[2].pending_airdrop_id)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Verify transaction record
    assert_eq!(record.pending_airdrop_records.len(), 0);

    // Verify the receiver holds the tokens via query
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account.id).execute(&client).await?;

    assert_eq!(receiver_account_balance.tokens.get(&token.id), None);
    assert_eq!(receiver_account_balance.tokens.get(&nft.id), None);

    // Verify the operator does not hold the tokens
    let operator_account_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_account_balance.tokens.get(&token.id), Some(TEST_FUNGIBLE_INITIAL_BALANCE));
    assert_eq!(operator_account_balance.tokens.get(&nft.id), Some(TEST_MINTED_NFTS));

    Ok(())
}

#[tokio::test]
async fn cancel_frozen_tokens() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop the tokens to both
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Associate the token
    let _ = TokenAssociateTransaction::new()
        .account_id(receiver_account.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(receiver_account.key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Freeze the token
    let _ = TokenFreezeTransaction::new()
        .token_id(token.id)
        .account_id(receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Cancel the airdrop
    let _ = TokenCancelAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn cancel_paused_tokens() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop the tokens to both
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Pause the token
    let _ = TokenPauseTransaction::new()
        .token_id(token.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Cancel the airdrop
    let _ = TokenCancelAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn cancel_to_multiple_receivers() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver1 with 0 auto associations
    let receiver_key_1 = PrivateKey::generate_ed25519();
    let receiver_account_1 =
        Account::create_with_max_associations(0, &receiver_key_1, &client).await?;

    // Create a receiver2 with 0 auto associations
    let receiver_key_2 = PrivateKey::generate_ed25519();
    let receiver_account_2 =
        Account::create_with_max_associations(0, &receiver_key_2, &client).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(10).collect::<Vec<Vec<u8>>>())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Airdrop the tokens to both
    let mut binding = TokenAirdropTransaction::new();
    let record = binding
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            receiver_account_1.id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            receiver_account_1.id,
        )
        .token_transfer(token.id, receiver_account_1.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .nft_transfer(
            nft.id.nft(nft_serials[2].try_into().unwrap()),
            operator_account.id,
            receiver_account_2.id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[3].try_into().unwrap()),
            operator_account.id,
            receiver_account_2.id,
        )
        .token_transfer(token.id, receiver_account_2.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // panic!("here");

    // Verify the txn record
    assert_eq!(record.pending_airdrop_records.len(), 6);

    // Cancel the tokens signing with receiver1 and receiver2
    let pending_airdrop_ids = record
        .pending_airdrop_records
        .iter()
        .map(|record| record.pending_airdrop_id)
        .collect::<Vec<_>>();

    let record = TokenCancelAirdropTransaction::new()
        .pending_airdrop_ids(pending_airdrop_ids)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
    assert_eq!(record.pending_airdrop_records.len(), 0);

    // Verify the receiver1 holds the tokens via query
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account_1.id).execute(&client).await?;

    assert_eq!(receiver_account_balance.tokens.get(&token.id), None);
    assert_eq!(receiver_account_balance.tokens.get(&nft.id), None);

    // Verify the receiver2 holds the tokens via query
    let receiver_account_balance_2 =
        AccountBalanceQuery::new().account_id(receiver_account_2.id).execute(&client).await?;

    assert_eq!(receiver_account_balance_2.tokens.get(&token.id), None);
    assert_eq!(receiver_account_balance_2.tokens.get(&nft.id), None);

    // Verify the operator does not hold the tokens
    let operator_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_balance.tokens.get(&token.id), Some(TEST_FUNGIBLE_INITIAL_BALANCE));
    assert_eq!(operator_balance.tokens.get(&nft.id), Some(TEST_MINTED_NFTS));

    Ok(())
}

#[tokio::test]
async fn cancel_from_multiple_airdrops() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver1 with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(10).collect::<Vec<Vec<_>>>())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Airdrop the tokens to both
    let record1 = TokenAirdropTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    let record2 = TokenAirdropTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    let record3 = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    let pending_airdrop_ids = vec![
        record1.pending_airdrop_records[0].pending_airdrop_id,
        record2.pending_airdrop_records[0].pending_airdrop_id,
        record3.pending_airdrop_records[0].pending_airdrop_id,
    ];

    // Cancel the all the tokens with the receiver
    let record = TokenCancelAirdropTransaction::new()
        .pending_airdrop_ids(pending_airdrop_ids)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
    assert_eq!(record.pending_airdrop_records.len(), 0);

    // Verify the receiver1 holds the tokens via query
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account.id).execute(&client).await?;

    assert_eq!(receiver_account_balance.tokens.get(&token.id).as_deref(), None);
    assert_eq!(receiver_account_balance.tokens.get(&nft.id), None);

    // Verify the operator does not hold the tokens
    let operator_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_balance.tokens.get(&token.id), Some(TEST_FUNGIBLE_INITIAL_BALANCE));
    assert_eq!(operator_balance.tokens.get(&nft.id), Some(TEST_MINTED_NFTS));

    Ok(())
}

#[tokio::test]
async fn cannot_cancel_nonexisting_airdrops_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop the tokens to both
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    let random_account_key = PrivateKey::generate_ed25519();
    let random_account =
        Account::create_with_max_associations(0, &random_account_key, &client).await?;

    // Cancel the tokens with the random account which has not created pending airdrops
    // fails with INVALID_SIGNATURE
    let res = TokenCancelAirdropTransaction::new()
        .transaction_id(TransactionId::generate(random_account.id))
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_cancel_canceled_airdrops_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop tokens from the sender to the receiver
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Cancel the tokens with the receiver
    _ = TokenCancelAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .execute(&client)
        .await?
        .get_record(&client)
        .await;

    // Cancel the tokens with the receiver again
    // fails with INVALID_PENDING_AIRDROP_ID
    let res = TokenCancelAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .execute(&client)
        .await?
        .get_record(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidPendingAirdropId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_cancel_empty_airdrop_list_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Cancel the tokens with the receiver without setting pendingAirdropIds
    // fails with EMPTY_PENDING_AIRDROP_ID_LIST
    let res = TokenCancelAirdropTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: Status::EmptyPendingAirdropIdList,
            ..
        })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_cancel_duplicated_entries_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop tokens
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, TEST_AMOUNT)
        .token_transfer(token.id, operator_account.id, -TEST_AMOUNT)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Cancel the tokens with the receiver again
    // fails with INVALID_PENDING_AIRDROP_ID
    let res = TokenCancelAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: Status::PendingAirdropIdRepeated,
            ..
        })
    );

    Ok(())
}

async fn test_operator_account(config: &Config) -> anyhow::Result<Account> {
    if let Some(operator) = config.operator.clone() {
        Ok(Account { key: operator.private_key, id: operator.account_id })
    } else {
        return Err(anyhow!("no operator configured"));
    }
}
// Filename: tests/e2e/token/claim_airdrop.rs
use std::iter::repeat;

use anyhow::anyhow;
use assert_matches::assert_matches;
use hedera::{
    AccountBalanceQuery,
    PrivateKey,
    Status,
    TokenAirdropTransaction,
    TokenAssociateTransaction,
    TokenClaimAirdropTransaction,
    TokenDeleteTransaction,
    TokenFreezeTransaction,
    TokenMintTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    Config,
    TestEnvironment,
};
use crate::token::{
    FungibleToken,
    Nft,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with unlimited auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(10).collect::<Vec<Vec<u8>>>())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Airdrop tokens
    let mut binding = TokenAirdropTransaction::new();
    let record = binding
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .token_transfer(token.id, receiver_account.id, 100)
        .token_transfer(token.id, operator_account.id, -100)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Verify transaction record
    assert_eq!(record.pending_airdrop_records.len(), 3);
    assert_eq!(record.pending_airdrop_records.get(0).unwrap().pending_airdrop_value, Some(100));
    assert_eq!(
        record.pending_airdrop_records.get(0).unwrap().pending_airdrop_id.token_id,
        Some(token.id)
    );
    assert_eq!(record.pending_airdrop_records.get(0).unwrap().pending_airdrop_id.nft_id, None);

    assert_eq!(record.pending_airdrop_records.get(1).unwrap().pending_airdrop_value, None);
    assert_eq!(
        record.pending_airdrop_records.get(1).unwrap().pending_airdrop_id.nft_id,
        Some(nft.id.nft(1))
    );
    assert_eq!(record.pending_airdrop_records.get(1).unwrap().pending_airdrop_id.token_id, None);

    assert_eq!(record.pending_airdrop_records.get(2).unwrap().pending_airdrop_value, None);
    assert_eq!(
        record.pending_airdrop_records.get(2).unwrap().pending_airdrop_id.nft_id,
        Some(nft.id.nft(2))
    );
    assert_eq!(record.pending_airdrop_records.get(2).unwrap().pending_airdrop_id.token_id, None);

    let record = TokenClaimAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records.get(0).unwrap().pending_airdrop_id)
        .add_pending_airdrop_id(record.pending_airdrop_records.get(1).unwrap().pending_airdrop_id)
        .add_pending_airdrop_id(record.pending_airdrop_records.get(2).unwrap().pending_airdrop_id)
        .freeze_with(&client)?
        .sign(receiver_key)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    assert_eq!(record.pending_airdrop_records.len(), 0);

    // Verify the receiver holds the tokens via query
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account.id).execute(&client).await?;

    assert_eq!(receiver_account_balance.tokens.get(&token.id), Some(&(100 as u64)));
    assert_eq!(receiver_account_balance.tokens.get(&nft.id), Some(&(2 as u64)));

    // Verify the operator does not hold the tokens
    let operator_account_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_account_balance.tokens.get(&token.id), Some(&(999_900 as u64)));
    assert_eq!(operator_account_balance.tokens.get(&nft.id), Some(&(8 as u64)));

    Ok(())
}

#[tokio::test]
async fn claim_to_multiple_receivers() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver1 with 0 auto associations
    let receiver_key_1 = PrivateKey::generate_ed25519();
    let receiver_account_1 =
        Account::create_with_max_associations(0, &receiver_key_1, &client).await?;

    // Create a receiver2 with 0 auto associations
    let receiver_key_2 = PrivateKey::generate_ed25519();
    let receiver_account_2 =
        Account::create_with_max_associations(0, &receiver_key_2, &client).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(10).collect::<Vec<Vec<_>>>())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Airdrop the tokens to both
    let mut binding = TokenAirdropTransaction::new();
    let record = binding
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            receiver_account_1.id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            receiver_account_1.id,
        )
        .token_transfer(token.id, receiver_account_1.id, 100)
        .token_transfer(token.id, operator_account.id, -100)
        .nft_transfer(
            nft.id.nft(nft_serials[2].try_into().unwrap()),
            operator_account.id,
            receiver_account_2.id,
        )
        .nft_transfer(
            nft.id.nft(nft_serials[3].try_into().unwrap()),
            operator_account.id,
            receiver_account_2.id,
        )
        .token_transfer(token.id, receiver_account_2.id, 100)
        .token_transfer(token.id, operator_account.id, -100)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Verify the txn record
    assert_eq!(record.pending_airdrop_records.len(), 6);

    // Claim the tokens signing with receiver1 and receiver2
    let pending_airdrop_ids = record
        .pending_airdrop_records
        .iter()
        .map(|record| record.pending_airdrop_id)
        .collect::<Vec<_>>();

    let record = TokenClaimAirdropTransaction::new()
        .pending_airdrop_ids(pending_airdrop_ids)
        .freeze_with(&client)?
        .sign(receiver_key_1)
        .sign(receiver_key_2)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
    assert_eq!(record.pending_airdrop_records.len(), 0);

    // Verify the receiver1 holds the tokens via query
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account_1.id).execute(&client).await?;

    assert_eq!(receiver_account_balance.tokens.get(&token.id).as_deref(), Some(&(100 as u64)));
    assert_eq!(receiver_account_balance.tokens.get(&nft.id), Some(&(2 as u64)));

    // Verify the receiver2 holds the tokens via query
    let receiver_account_balance_2 =
        AccountBalanceQuery::new().account_id(receiver_account_2.id).execute(&client).await?;

    assert_eq!(receiver_account_balance_2.tokens.get(&token.id).as_deref(), Some(&(100 as u64)));
    assert_eq!(receiver_account_balance_2.tokens.get(&nft.id), Some(&(2 as u64)));

    // Verify the operator does not hold the tokens
    let operator_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_balance.tokens.get(&token.id), Some(&((1_000_000 - 100 * 2) as u64)));
    assert_eq!(operator_balance.tokens.get(&nft.id), Some(&(6 as u64)));

    Ok(())
}

#[tokio::test]
async fn claim_from_multiple_airdrops() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver1 with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token and an NFT
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    // Mint Nfts
    let mint_receipt = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(10).collect::<Vec<Vec<_>>>())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Airdrop the tokens to both
    let record1 = TokenAirdropTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[0].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    let record2 = TokenAirdropTransaction::new()
        .nft_transfer(
            nft.id.nft(nft_serials[1].try_into().unwrap()),
            operator_account.id,
            receiver_account.id,
        )
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    let record3 = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, 100)
        .token_transfer(token.id, operator_account.id, -100)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    let pending_airdrop_ids = vec![
        record1.pending_airdrop_records[0].pending_airdrop_id,
        record2.pending_airdrop_records[0].pending_airdrop_id,
        record3.pending_airdrop_records[0].pending_airdrop_id,
    ];

    let record = TokenClaimAirdropTransaction::new()
        .pending_airdrop_ids(pending_airdrop_ids)
        .freeze_with(&client)?
        .sign(receiver_key)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
    assert_eq!(record.pending_airdrop_records.len(), 0);

    // Verify the receiver1 holds the tokens via query
    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account.id).execute(&client).await?;

    assert_eq!(receiver_account_balance.tokens.get(&token.id).as_deref(), Some(&(100 as u64)));
    assert_eq!(receiver_account_balance.tokens.get(&nft.id), Some(&(2 as u64)));

    // Verify the operator does not hold the tokens
    let operator_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(operator_balance.tokens.get(&token.id), Some(&((1_000_000 - 100) as u64)));
    assert_eq!(operator_balance.tokens.get(&nft.id), Some(&(8 as u64)));

    Ok(())
}

#[tokio::test]
async fn cannot_claim_nonexisting_tokens_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop tokens from the sender to the receiver
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, 100)
        .token_transfer(token.id, operator_account.id, -100)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Claim the tokens with the operator which does not have pending airdrops
    // fails with INVALID_SIGNATURE
    let res = TokenClaimAirdropTransaction::new()
        .pending_airdrop_ids(vec![record.pending_airdrop_records[0].pending_airdrop_id])
        .execute(&client)
        .await?
        .get_record(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_claim_already_claimed_airdrop_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop tokens from the sender to the receiver
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, 100)
        .token_transfer(token.id, operator_account.id, -100)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Claim the tokens with the receiver
    let _ = TokenClaimAirdropTransaction::new()
        .pending_airdrop_ids(vec![record.pending_airdrop_records[0].pending_airdrop_id])
        .freeze_with(&client)?
        .sign(receiver_account.key)
        .execute(&client)
        .await?
        .get_record(&client)
        .await;

    // Claim the tokens with the operator which does not have pending airdrops
    // fails with INVALID_PENDING_AIRDROP_ID
    let res = TokenClaimAirdropTransaction::new()
        .pending_airdrop_ids(vec![record.pending_airdrop_records[0].pending_airdrop_id])
        .freeze_with(&client)?
        .sign(receiver_key)
        .execute(&client)
        .await?
        .get_record(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidPendingAirdropId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_claim_empty_pending_airdrops_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Claim the tokens with the receiver without setting pendingAirdropIds
    // fails with EMPTY_PENDING_AIRDROP_ID_LIST
    let res = TokenClaimAirdropTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: Status::EmptyPendingAirdropIdList,
            ..
        })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_claim_duplicate_entries_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop tokens from the sender to the receiver
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, 100)
        .token_transfer(token.id, operator_account.id, -100)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Claim the tokens with duplicate pending airdrop token ids
    // fails with PENDING_AIRDROP_ID_REPEATED
    let res = TokenClaimAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: Status::PendingAirdropIdRepeated,
            ..
        })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_claim_deleted_tokens_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop tokens from the sender to the receiver
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, 100)
        .token_transfer(token.id, operator_account.id, -100)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Delete the token
    let _ = TokenDeleteTransaction::new()
        .token_id(token.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Claim the tokens with receiver
    // fails with TOKEN_IS_DELETED
    let res = TokenClaimAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .freeze_with(&client)?
        .sign(receiver_key)
        .execute(&client)
        .await?
        .get_record(&client)
        .await;

    assert_matches!(res, Err(hedera::Error::ReceiptStatus { status: Status::TokenWasDeleted, .. }));

    Ok(())
}

#[tokio::test]
async fn cannot_claim_frozen_token_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;

    // Create a receiver account with 0 auto associations
    let receiver_key = PrivateKey::generate_ed25519();
    let receiver_account = Account::create_with_max_associations(0, &receiver_key, &client).await?;

    // Create a token
    let token = FungibleToken::create_ft(&client, &operator_account, 3).await?;

    // Airdrop tokens
    let record = TokenAirdropTransaction::new()
        .token_transfer(token.id, receiver_account.id, 100)
        .token_transfer(token.id, operator_account.id, -100)
        .execute(&client)
        .await?
        .get_record(&client)
        .await?;

    // Associate the token
    let _ = TokenAssociateTransaction::new()
        .account_id(receiver_account.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(receiver_account.key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Freeze the token
    let _ = TokenFreezeTransaction::new()
        .token_id(token.id)
        .account_id(receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // Claim the tokens with receiver
    // fails with ACCOUNT_FROZEN_FOR_TOKEN
    let res = TokenClaimAirdropTransaction::new()
        .add_pending_airdrop_id(record.pending_airdrop_records[0].pending_airdrop_id)
        .freeze_with(&client)?
        .sign(receiver_key)
        .execute(&client)
        .await?
        .get_record(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::AccountFrozenForToken, .. })
    );

    Ok(())
}

async fn test_operator_account(config: &Config) -> anyhow::Result<Account> {
    if let Some(operator) = config.operator.clone() {
        Ok(Account { key: operator.private_key, id: operator.account_id })
    } else {
        return Err(anyhow!("no operator configured"));
    }
}
// Filename: tests/e2e/token/create.rs
use assert_matches::assert_matches;
use hedera::{
    AccountId,
    AnyCustomFee,
    FixedFee,
    FixedFeeData,
    FractionalFee,
    FractionalFeeData,
    Hbar,
    PrivateKey,
    RoyaltyFee,
    Status,
    TokenCreateTransaction,
    TokenId,
    TokenInfoQuery,
    TokenType,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    FungibleToken,
    Nft,
};

fn fixed_fee(fee_collector: AccountId) -> AnyCustomFee {
    FixedFee {
        fee: FixedFeeData { amount: 10, denominating_token_id: Some(TokenId::new(0, 0, 0)) },
        fee_collector_account_id: Some(fee_collector),
        all_collectors_are_exempt: false,
    }
    .into()
}

fn fractional_fee(fee_collector: AccountId) -> AnyCustomFee {
    FractionalFee {
        fee: FractionalFeeData {
            denominator: 20,
            numerator: 1,
            minimum_amount: 1,
            maximum_amount: 20,
            assessment_method: hedera::FeeAssessmentMethod::Exclusive,
        },
        fee_collector_account_id: Some(fee_collector),
        all_collectors_are_exempt: false,
    }
    .into()
}

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .decimals(3)
        .initial_supply(0)
        .treasury_account_id(account.id)
        .admin_key(account.key.public_key())
        .freeze_key(account.key.public_key())
        .wipe_key(account.key.public_key())
        .kyc_key(account.key.public_key())
        .supply_key(account.key.public_key())
        .fee_schedule_key(account.key.public_key())
        .freeze_default(false)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = FungibleToken { id: token_id, owner: account.clone() };

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn minimal() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_name_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenCreateTransaction::new()
        .symbol("F")
        .treasury_account_id(account.id)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::MissingTokenName, .. })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn missing_symbol_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenCreateTransaction::new()
        .name("ffff")
        .treasury_account_id(account.id)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::MissingTokenSymbol, .. })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn missing_treasury_account_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: Status::InvalidTreasuryAccountForToken,
            ..
        })
    );

    Ok(())
}

#[tokio::test]
async fn missing_treasury_account_id_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_admin_key_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let admin_key = PrivateKey::generate_ed25519();

    let res = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .admin_key(admin_key.public_key())
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn custom_fees() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let custom_fees = [fixed_fee(account.id), fractional_fee(account.id)];

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .admin_key(account.key.public_key())
        .custom_fees(custom_fees)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = FungibleToken { id: token_id, owner: account.clone() };

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn too_many_custom_fees_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .admin_key(account.key.public_key())
        .treasury_account_id(account.id)
        .custom_fees(vec![fixed_fee(account.id); 11])
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::CustomFeesListTooLong, .. })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn ten_fixed_fees() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .admin_key(account.key.public_key())
        .treasury_account_id(account.id)
        .custom_fees(vec![fixed_fee(account.id); 10])
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = FungibleToken { id: token_id, owner: account.clone() };

    token.delete(&client).await?;
    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn ten_fractional_fees() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .admin_key(account.key.public_key())
        .treasury_account_id(account.id)
        .custom_fees(vec![fractional_fee(account.id); 10])
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = FungibleToken { id: token_id, owner: account.clone() };
    token.delete(&client).await?;

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn fractional_fee_min_bigger_than_max_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let fee = FractionalFee {
        fee: FractionalFeeData {
            denominator: 3,
            numerator: 1,
            minimum_amount: 3,
            maximum_amount: 2,
            assessment_method: hedera::FeeAssessmentMethod::Exclusive,
        },
        fee_collector_account_id: Some(account.id),
        all_collectors_are_exempt: false,
    }
    .into();

    let res = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .admin_key(account.key.public_key())
        .treasury_account_id(account.id)
        .custom_fees([fee])
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: Status::FractionalFeeMaxAmountLessThanMinAmount,
            ..
        })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn invalid_fee_collector_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let fee = FixedFee {
        fee: FixedFeeData::from_hbar(Hbar::from_tinybars(1)),
        fee_collector_account_id: None,
        all_collectors_are_exempt: false,
    }
    .into();

    let res = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .admin_key(account.key.public_key())
        .treasury_account_id(account.id)
        .custom_fees([fee])
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidCustomFeeCollector, .. })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn negative_fee_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let fee = FixedFee {
        fee: FixedFeeData::from_hbar(Hbar::from_tinybars(-1)),
        fee_collector_account_id: Some(account.id),
        all_collectors_are_exempt: false,
    }
    .into();

    let res = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .admin_key(account.key.public_key())
        .treasury_account_id(account.id)
        .custom_fees([fee])
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::CustomFeeMustBePositive, .. })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn zero_denominator_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let fee = FractionalFee {
        fee: FractionalFeeData {
            denominator: 0,
            numerator: 1,
            minimum_amount: 1,
            maximum_amount: 10,
            assessment_method: hedera::FeeAssessmentMethod::Exclusive,
        },
        fee_collector_account_id: Some(account.id),
        all_collectors_are_exempt: false,
    }
    .into();

    let res = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .admin_key(account.key.public_key())
        .treasury_account_id(account.id)
        .custom_fees([fee])
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::FractionDividesByZero, .. })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn nfts() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .token_type(TokenType::NonFungibleUnique)
        .treasury_account_id(account.id)
        .admin_key(account.key.public_key())
        .freeze_key(account.key.public_key())
        .wipe_key(account.key.public_key())
        .kyc_key(account.key.public_key())
        .supply_key(account.key.public_key())
        .freeze_default(false)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = Nft { id: token_id, owner: account.clone() };

    token.delete(&client).await?;
    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn royalty_fee() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let fee = RoyaltyFee {
        fee: hedera::RoyaltyFeeData {
            denominator: 10,
            numerator: 1,
            fallback_fee: Some(FixedFeeData::from_hbar(Hbar::new(1))),
        },
        fee_collector_account_id: Some(account.id),
        all_collectors_are_exempt: false,
    };

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .supply_key(account.key.public_key())
        .admin_key(account.key.public_key())
        .token_type(TokenType::NonFungibleUnique)
        .custom_fees([fee.into()])
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = Nft { id: token_id, owner: account.clone() };

    token.delete(&client).await?;
    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn auto_renew_account() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .auto_renew_account_id(account.id)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    // auto renew account should be set to operator account
    assert_eq!(info.auto_renew_account.unwrap(), account.id);
    Ok(())
}

#[tokio::test]
async fn autoset_auto_renew_account() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;
    // auto renew account should be set to operator account
    assert_eq!(info.auto_renew_account.unwrap(), client.get_operator_account_id().unwrap());
    Ok(())
}
// Filename: tests/e2e/token/delete.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenDeleteTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    TokenKeys,
};

#[tokio::test]
async fn all_keys() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 0, keys: TokenKeys::ALL_OWNER },
    )
    .await?;

    TokenDeleteTransaction::new()
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn only_admin_key() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token = super::FungibleToken::create(&client, &account, Default::default()).await?;

    TokenDeleteTransaction::new()
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_admin_key_signature_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, Default::default()).await?;

    let res = TokenDeleteTransaction::new()
        .token_id(token.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_admin_key_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };
    let account = Account::create(Hbar::new(0), &client).await?;

    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 0, keys: TokenKeys::NONE },
    )
    .await?;

    let res = TokenDeleteTransaction::new()
        .token_id(token.id)
        .sign(token.owner.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenIsImmutable, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenDeleteTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    Ok(())
}
// Filename: tests/e2e/token/dissociate.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenAssociateTransaction,
    TokenDissociateTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(5), &client),
        Account::create(Hbar::new(1), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, Default::default()).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TokenDissociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");
        return Ok(());
    };

    TokenDissociateTransaction::new()
        .account_id(op.account_id)
        .freeze_with(&client)?
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_account_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenDissociateTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidAccountId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_signature_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenDissociateTransaction::new()
        .account_id(account.id)
        .freeze_with(&client)?
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn unassociated_token_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(5), &client),
        Account::create(Hbar::new(1), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, Default::default()).await?;

    let res = TokenDissociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenNotAssociatedToAccount, .. })
    );

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}
// Filename: tests/e2e/token/fee_schedule_update.rs
use assert_matches::assert_matches;
use hedera::{
    FixedFee,
    FixedFeeData,
    FractionalFee,
    FractionalFeeData,
    Hbar,
    Status,
    TokenFeeScheduleUpdateTransaction,
    TokenInfoQuery,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    Key,
    TokenKeys,
};

const TOKEN_PARAMS: CreateFungibleToken = CreateFungibleToken {
    initial_supply: 0,
    keys: TokenKeys { fee_schedule: Some(Key::Owner), ..TokenKeys::DEFAULT },
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, TOKEN_PARAMS).await?;

    let info = TokenInfoQuery::new().token_id(token.id).execute(&client).await?;

    assert!(info.custom_fees.is_empty());

    let custom_fees = Vec::from([
        FixedFee {
            fee: FixedFeeData::from_hbar(Hbar::from_tinybars(10)),
            fee_collector_account_id: Some(account.id),
            all_collectors_are_exempt: false,
        }
        .into(),
        FractionalFee {
            fee: FractionalFeeData {
                denominator: 20,
                numerator: 1,
                minimum_amount: 1,
                maximum_amount: 10,
                assessment_method: hedera::FeeAssessmentMethod::Exclusive,
            },
            fee_collector_account_id: Some(account.id),
            all_collectors_are_exempt: false,
        }
        .into(),
    ]);

    TokenFeeScheduleUpdateTransaction::new()
        .token_id(token.id)
        .custom_fees(custom_fees.clone())
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = TokenInfoQuery::new().token_id(token.id).execute(&client).await?;

    assert_eq!(custom_fees, info.custom_fees);

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn invalid_signature_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, TOKEN_PARAMS).await?;

    let info = TokenInfoQuery::new().token_id(token.id).execute(&client).await?;

    assert!(info.custom_fees.is_empty());

    let custom_fees = Vec::from([
        FixedFee {
            fee: FixedFeeData::from_hbar(Hbar::from_tinybars(10)),
            fee_collector_account_id: Some(account.id),
            all_collectors_are_exempt: false,
        }
        .into(),
        FractionalFee {
            fee: FractionalFeeData {
                denominator: 20,
                numerator: 1,
                minimum_amount: 1,
                maximum_amount: 10,
                assessment_method: hedera::FeeAssessmentMethod::Exclusive,
            },
            fee_collector_account_id: Some(account.id),
            all_collectors_are_exempt: false,
        }
        .into(),
    ]);

    let res = TokenFeeScheduleUpdateTransaction::new()
        .token_id(token.id)
        .custom_fees(custom_fees.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    token.delete(&client).await?;
    account.delete(&client).await?;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}
// Filename: tests/e2e/token/freeze.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenAssociateTransaction,
    TokenFreezeTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    Key,
    TokenKeys,
};

const TOKEN_PARAMS: CreateFungibleToken = CreateFungibleToken {
    initial_supply: 0,
    keys: TokenKeys { freeze: Some(Key::Owner), ..TokenKeys::DEFAULT },
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TokenFreezeTransaction::new()
        .account_id(bob.id)
        .token_id(token.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenFreezeTransaction::new()
        .account_id(account.id)
        .sign(account.key.clone())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_account_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, TOKEN_PARAMS).await?;

    let res = TokenFreezeTransaction::new()
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidAccountId, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn non_associated_token_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    let res = TokenFreezeTransaction::new()
        .account_id(bob.id)
        .token_id(token.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenNotAssociatedToAccount, .. })
    );

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}
// Filename: tests/e2e/token/grant_kyc.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenAssociateTransaction,
    TokenGrantKycTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    Key,
    TokenKeys,
};

const TOKEN_PARAMS: CreateFungibleToken = CreateFungibleToken {
    initial_supply: 0,
    keys: TokenKeys { kyc: Some(Key::Owner), ..TokenKeys::DEFAULT },
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TokenGrantKycTransaction::new()
        .account_id(bob.id)
        .token_id(token.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenGrantKycTransaction::new()
        .account_id(account.id)
        .sign(account.key.clone())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_account_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 0, ..TOKEN_PARAMS },
    )
    .await?;

    let res = TokenGrantKycTransaction::new()
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidAccountId, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn non_associated_token_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    let res = TokenGrantKycTransaction::new()
        .account_id(bob.id)
        .token_id(token.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenNotAssociatedToAccount, .. })
    );

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}
// Filename: tests/e2e/token/info.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Key,
    PrivateKey,
    Status,
    TokenCreateTransaction,
    TokenInfoQuery,
    TokenSupplyType,
    TokenType,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    FungibleToken,
    Nft,
    TokenKeys,
};

#[tokio::test]

async fn query_all_different_keys() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let freeze_key = PrivateKey::generate_ed25519();
    let wipe_key = PrivateKey::generate_ed25519();
    let kyc_key = PrivateKey::generate_ed25519();
    let supply_key = PrivateKey::generate_ed25519();
    let fee_schedule_key = PrivateKey::generate_ed25519();
    let pause_key = PrivateKey::generate_ed25519();

    let token = FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken {
            initial_supply: 0,
            keys: TokenKeys {
                admin: Some(super::Key::Owner),
                freeze: Some(super::Key::Custom(freeze_key.public_key())),
                wipe: Some(super::Key::Custom(wipe_key.public_key())),
                kyc: Some(super::Key::Custom(kyc_key.public_key())),
                supply: Some(super::Key::Custom(supply_key.public_key())),
                fee_schedule: Some(super::Key::Custom(fee_schedule_key.public_key())),
                pause: Some(super::Key::Custom(pause_key.public_key())),
            },
        },
    )
    .await?;

    let info = TokenInfoQuery::new().token_id(token.id).execute(&client).await?;

    assert_eq!(info.token_id, token.id);
    assert_eq!(info.name, "ffff");
    assert_eq!(info.symbol, "F");
    assert_eq!(info.decimals, 3);
    assert_eq!(info.treasury_account_id, account.id);
    assert_eq!(info.admin_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.freeze_key, Some(Key::Single(freeze_key.public_key())));
    assert_eq!(info.wipe_key, Some(Key::Single(wipe_key.public_key())));
    assert_eq!(info.kyc_key, Some(Key::Single(kyc_key.public_key())));
    assert_eq!(info.supply_key, Some(Key::Single(supply_key.public_key())));
    assert_eq!(info.fee_schedule_key, Some(Key::Single(fee_schedule_key.public_key())));
    assert_eq!(info.pause_key, Some(Key::Single(pause_key.public_key())));
    assert_eq!(info.default_freeze_status, Some(false));
    assert_eq!(info.default_kyc_status, Some(false));
    assert_eq!(info.token_type, TokenType::FungibleCommon);
    assert_eq!(info.supply_type, TokenSupplyType::Infinite);

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]

async fn query_minimal() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(info.token_id, token_id);
    assert_eq!(info.name, "ffff");
    assert_eq!(info.symbol, "F");
    assert_eq!(info.decimals, 0);
    assert_eq!(info.treasury_account_id, account.id);
    assert_eq!(info.admin_key, None);
    assert_eq!(info.freeze_key, None);
    assert_eq!(info.wipe_key, None);
    assert_eq!(info.kyc_key, None);
    assert_eq!(info.supply_key, None);
    assert_eq!(info.default_freeze_status, None);
    assert_eq!(info.default_kyc_status, None);
    assert_eq!(info.token_type, TokenType::FungibleCommon);
    assert_eq!(info.supply_type, TokenSupplyType::Infinite);

    // we have to leave this account, for it is a treasury.
    // account.delete(&client).await?;

    Ok(())
}

#[tokio::test]

async fn query_nft() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .admin_key(account.key.public_key())
        .supply_key(account.key.public_key())
        .token_type(TokenType::NonFungibleUnique)
        .token_supply_type(TokenSupplyType::Finite)
        .max_supply(5000)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = Nft { id: token_id, owner: account.clone() };

    let serials = token.mint_incremental(&client, 10).await?;

    assert_eq!(serials.len(), 10);

    let info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(info.token_id, token_id);
    assert_eq!(info.name, "ffff");
    assert_eq!(info.symbol, "F");
    assert_eq!(info.decimals, 0);
    assert_eq!(info.total_supply, 10);
    assert_eq!(info.treasury_account_id, account.id);
    assert_eq!(info.admin_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.supply_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.default_freeze_status, None);
    assert_eq!(info.default_kyc_status, None);
    assert_eq!(info.token_type, TokenType::NonFungibleUnique);
    assert_eq!(info.supply_type, TokenSupplyType::Finite);
    assert_eq!(info.max_supply, 5000);

    token.burn(&client, serials).await?;
    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]

async fn query_cost() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, Default::default()).await?;

    let mut query = TokenInfoQuery::new();

    query.token_id(token.id);

    let cost = query.get_cost(&client).await?;

    query.payment_amount(cost).execute(&client).await?;

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]

async fn query_cost_big_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, Default::default()).await?;

    let mut query = TokenInfoQuery::new();

    query.token_id(token.id).max_payment_amount(Hbar::new(1000));

    let cost = query.get_cost(&client).await?;

    query.payment_amount(cost).execute(&client).await?;

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]

async fn query_cost_small_max_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, Default::default()).await?;

    let mut query = TokenInfoQuery::new();

    query.token_id(token.id).max_payment_amount(Hbar::from_tinybars(1));

    let cost = query.get_cost(&client).await?;

    let res = query.execute(&client).await;

    let (max_query_payment, query_cost) = assert_matches!(
        res,
        Err(hedera::Error::MaxQueryPaymentExceeded {
            max_query_payment,
            query_cost
        }) => (max_query_payment, query_cost)
    );

    assert_eq!(max_query_payment, Hbar::from_tinybars(1));
    // note: there's a very small chance this fails if the cost of a FileContentsQuery changes right when we execute it.
    assert_eq!(query_cost, cost);

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]

async fn query_cost_insufficient_tx_fee_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, Default::default()).await?;

    let res = TokenInfoQuery::new()
        .token_id(token.id)
        .max_payment_amount(Hbar::from_tinybars(10000))
        .payment_amount(Hbar::from_tinybars(1))
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryPaymentPreCheckStatus { status: Status::InsufficientTxFee, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}
// Filename: tests/e2e/token/mint.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenCreateTransaction,
    TokenMintTransaction,
    TokenSupplyType,
    TokenType,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    FungibleToken,
    Key,
    Nft,
    TokenKeys,
};

const TOKEN_KEYS: TokenKeys = TokenKeys { supply: Some(Key::Owner), ..TokenKeys::DEFAULT };

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    const INITIAL_SUPPLY: u64 = 1_000_000;
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: INITIAL_SUPPLY, keys: TOKEN_KEYS },
    )
    .await?;

    let receipt = TokenMintTransaction::new()
        .amount(10)
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    assert_eq!(receipt.total_supply, INITIAL_SUPPLY + 10);

    token.burn(&client, INITIAL_SUPPLY + 10).await?;
    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn over_supply_limit_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .token_supply_type(hedera::TokenSupplyType::Finite)
        .max_supply(5)
        .treasury_account_id(account.id)
        .admin_key(account.key.public_key())
        .supply_key(account.key.public_key())
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = FungibleToken { id: token_id, owner: account.clone() };

    let res = TokenMintTransaction::new()
        .token_id(token.id)
        .amount(6)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenMaxSupplyReached, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenMintTransaction::new().amount(6).execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn zero() -> anyhow::Result<()> {
    const INITIAL_SUPPLY: u64 = 1_000_000;
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: INITIAL_SUPPLY, keys: TOKEN_KEYS },
    )
    .await?;

    let receipt = TokenMintTransaction::new()
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    assert_eq!(receipt.total_supply, INITIAL_SUPPLY);

    token.burn(&client, INITIAL_SUPPLY).await?;
    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]

async fn missing_supply_key_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 0, keys: TOKEN_KEYS },
    )
    .await?;

    let res = TokenMintTransaction::new()
        .token_id(token.id)
        .amount(10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn nfts() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .admin_key(account.key.public_key())
        .supply_key(account.key.public_key())
        .token_type(TokenType::NonFungibleUnique)
        .token_supply_type(TokenSupplyType::Finite)
        .max_supply(5000)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = Nft { id: token_id, owner: account.clone() };

    let mint_receipt = TokenMintTransaction::new()
        .token_id(token_id)
        .metadata((0..10).map(|it| [it]))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    assert_eq!(mint_receipt.serials.len(), 10);

    token.burn(&client, mint_receipt.serials).await?;
    token.delete(&client).await?;

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn nft_metadata_too_long_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .treasury_account_id(account.id)
        .admin_key(account.key.public_key())
        .supply_key(account.key.public_key())
        .token_type(TokenType::NonFungibleUnique)
        .token_supply_type(TokenSupplyType::Finite)
        .max_supply(5000)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = Nft { id: token_id, owner: account.clone() };

    let res = TokenMintTransaction::new()
        .token_id(token_id)
        .metadata([[1; 101]])
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(res, Err(hedera::Error::ReceiptStatus { status: Status::MetadataTooLong, .. }));

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}
// Filename: tests/e2e/token/mod.rs
mod associate;
mod burn;
mod create;
mod delete;
mod dissociate;
mod fee_schedule_update;
mod freeze;
mod grant_kyc;
mod info;
mod mint;
mod nft_info;
mod nft_transfer;
mod nft_update;
mod pause;
mod reject;
mod reject_flow;

mod airdrop;
mod cancel_airdrop;
mod claim_airdrop;
mod revoke_kyc;
mod transfer;
mod unfreeze;
mod unpause;
mod update;
mod wipe;

use hedera::{
    Client,
    PublicKey,
    TokenBurnTransaction,
    TokenCreateTransaction,
    TokenDeleteTransaction,
    TokenId,
    TokenMintTransaction,
    TransactionResponse,
};
use time::{
    Duration,
    OffsetDateTime,
};
use tokio::task::JoinSet;

use crate::account::Account;
use crate::common::{
    setup_global,
    Operator,
    TestEnvironment,
};

pub(crate) enum Key {
    Owner,
    Custom(PublicKey),
}

pub(crate) struct TokenKeys {
    pub(crate) admin: Option<Key>,
    pub(crate) freeze: Option<Key>,
    pub(crate) wipe: Option<Key>,
    pub(crate) kyc: Option<Key>,
    pub(crate) supply: Option<Key>,
    pub(crate) fee_schedule: Option<Key>,
    pub(crate) pause: Option<Key>,
}

impl TokenKeys {
    const NONE: Self = Self {
        admin: None,
        freeze: None,
        wipe: None,
        kyc: None,
        supply: None,
        fee_schedule: None,
        pause: None,
    };

    const DEFAULT: Self = Self { admin: Some(Key::Owner), ..Self::NONE };

    const ALL_OWNER: Self = Self {
        admin: Some(Key::Owner),
        freeze: Some(Key::Owner),
        wipe: Some(Key::Owner),
        kyc: Some(Key::Owner),
        supply: Some(Key::Owner),
        fee_schedule: Some(Key::Owner),
        pause: Some(Key::Owner),
    };
}

impl Default for TokenKeys {
    fn default() -> Self {
        Self::DEFAULT
    }
}

#[derive(Default)]
pub(crate) struct CreateFungibleToken {
    initial_supply: u64,
    keys: TokenKeys,
}

pub(crate) struct FungibleToken {
    pub(crate) id: TokenId,
    pub(crate) owner: Account,
}

pub(crate) const TEST_FUNGIBLE_INITIAL_BALANCE: &u64 = &1_000_000;
pub(crate) const TEST_MINTED_NFTS: &u64 = &10;
pub(crate) const TEST_AMOUNT: i64 = 100;

impl FungibleToken {
    pub(crate) async fn create(
        client: &Client,
        owner: &Account,
        params: CreateFungibleToken,
    ) -> hedera::Result<Self> {
        let owner_public_key = owner.key.public_key();

        let token_id = {
            let mut tx = TokenCreateTransaction::new();
            tx.name("ffff")
                .symbol("F")
                .decimals(3)
                .treasury_account_id(owner.id)
                .initial_supply(params.initial_supply);

            let keys = params.keys;

            if let Some(it) = keys.admin {
                tx.admin_key(match it {
                    Key::Owner => owner_public_key,
                    Key::Custom(key) => key,
                });
            }

            if let Some(it) = keys.freeze {
                tx.freeze_key(match it {
                    Key::Owner => owner_public_key,
                    Key::Custom(key) => key,
                });
            }

            if let Some(it) = keys.wipe {
                tx.wipe_key(match it {
                    Key::Owner => owner_public_key,
                    Key::Custom(key) => key,
                });
            }

            if let Some(it) = keys.kyc {
                tx.kyc_key(match it {
                    Key::Owner => owner_public_key,
                    Key::Custom(key) => key,
                });
            }

            if let Some(it) = keys.supply {
                tx.supply_key(match it {
                    Key::Owner => owner_public_key,
                    Key::Custom(key) => key,
                });
            }

            if let Some(it) = keys.fee_schedule {
                tx.fee_schedule_key(match it {
                    Key::Owner => owner_public_key,
                    Key::Custom(key) => key,
                });
            }

            if let Some(it) = keys.pause {
                tx.pause_key(match it {
                    Key::Owner => owner_public_key,
                    Key::Custom(key) => key,
                });
            }

            tx.freeze_default(false)
                .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
                .sign(owner.key.clone())
                .execute(client)
                .await?
                .get_receipt(client)
                .await?
                .token_id
                .unwrap()
        };

        Ok(Self { id: token_id, owner: owner.clone() })
    }

    async fn create_ft(
        client: &Client,
        owner: &Account,
        decimals: u32,
    ) -> anyhow::Result<FungibleToken> {
        let id = TokenCreateTransaction::new()
            .name("ffff".to_string())
            .symbol("F".to_string())
            .token_memo("memo".to_string())
            .decimals(decimals)
            .initial_supply(1_000_000)
            .max_supply(1_000_000)
            .treasury_account_id(owner.id)
            .token_supply_type(hedera::TokenSupplyType::Finite)
            .admin_key(owner.key.public_key())
            .freeze_key(owner.key.public_key())
            .wipe_key(owner.key.public_key())
            .supply_key(owner.key.public_key())
            .metadata_key(owner.key.public_key())
            .pause_key(owner.key.public_key())
            .execute(&client)
            .await?
            .get_receipt(&client)
            .await?
            .token_id
            .unwrap();

        Ok(FungibleToken { id, owner: owner.clone() })
    }

    async fn burn(&self, client: &Client, supply: u64) -> hedera::Result<()> {
        hedera::TokenBurnTransaction::new()
            .token_id(self.id)
            .amount(supply)
            .sign(self.owner.key.clone())
            .execute(client)
            .await?
            .get_receipt(client)
            .await?;

        Ok(())
    }

    async fn delete(self, client: &Client) -> hedera::Result<()> {
        TokenDeleteTransaction::new()
            .token_id(self.id)
            .sign(self.owner.key)
            .execute(client)
            .await?
            .get_receipt(client)
            .await?;

        Ok(())
    }
}

pub(crate) struct Nft {
    pub(crate) id: TokenId,
    pub(crate) owner: Account,
}

impl Nft {
    pub(crate) async fn create(client: &Client, owner: &Account) -> hedera::Result<Self> {
        let owner_public_key = owner.key.public_key();
        let token_id = TokenCreateTransaction::new()
            .name("ffff")
            .symbol("F")
            .token_type(hedera::TokenType::NonFungibleUnique)
            .treasury_account_id(owner.id)
            .admin_key(owner_public_key)
            .freeze_key(owner_public_key)
            .wipe_key(owner_public_key)
            .pause_key(owner_public_key)
            .supply_key(owner_public_key)
            .fee_schedule_key(owner_public_key)
            .freeze_default(false)
            .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
            .sign(owner.key.clone())
            .execute(client)
            .await?
            .get_receipt(client)
            .await?
            .token_id
            .unwrap();

        Ok(Self { id: token_id, owner: owner.clone() })
    }

    // fixme: find a better name
    async fn mint_incremental(
        &self,
        client: &Client,
        nfts_to_mint: u8,
    ) -> hedera::Result<Vec<i64>> {
        self.mint(client, (0..nfts_to_mint).map(|it| [it])).await
    }

    pub(crate) async fn mint<Bytes: AsRef<[u8]>>(
        &self,
        client: &Client,
        metadata: impl IntoIterator<Item = Bytes>,
    ) -> hedera::Result<Vec<i64>> {
        async fn inner(
            nft: &Nft,
            client: &Client,
            mut tx: TokenMintTransaction,
        ) -> hedera::Result<Vec<i64>> {
            let serials = tx
                .token_id(nft.id)
                .sign(nft.owner.key.clone())
                .execute(client)
                .await?
                .get_receipt(client)
                .await?
                .serials;

            Ok(serials)
        }

        let mut tx = TokenMintTransaction::new();

        tx.metadata(metadata);

        inner(self, client, tx).await
    }

    pub(crate) async fn burn(
        &self,
        client: &Client,
        serials: impl IntoIterator<Item = i64>,
    ) -> hedera::Result<()> {
        // non generic inner function to save generic instantiations... Not that that's a huge concern here.
        async fn inner(
            nft: &Nft,
            client: &Client,
            mut tx: TokenBurnTransaction,
        ) -> hedera::Result<()> {
            tx.token_id(nft.id)
                .sign(nft.owner.key.clone())
                .execute(client)
                .await?
                .get_receipt(client)
                .await
                .map(drop)
        }

        let mut tx = TokenBurnTransaction::new();

        tx.serials(serials);

        inner(self, client, tx).await
    }

    pub(crate) async fn delete(self, client: &Client) -> hedera::Result<()> {
        TokenDeleteTransaction::new()
            .token_id(self.id)
            .sign(self.owner.key)
            .execute(client)
            .await?
            .get_receipt(client)
            .await?;

        Ok(())
    }
}

#[tokio::test]
async fn mint_several_nfts_at_once() -> anyhow::Result<()> {
    async fn setup(op: &Operator, client: &Client) -> anyhow::Result<TokenId> {
        let token_id = TokenCreateTransaction::new()
            .name("sdk::rust::e2e::mint_many")
            .symbol("")
            .token_type(hedera::TokenType::NonFungibleUnique)
            .treasury_account_id(op.account_id)
            .admin_key(op.private_key.clone().public_key())
            .supply_key(op.private_key.clone().public_key())
            .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
            .freeze_default(false)
            .execute(client)
            .await?
            .get_receipt(client)
            .await?
            .token_id
            .ok_or_else(|| anyhow::anyhow!("Token creation failed"))?;

        log::info!("successfully created token {token_id}");

        Ok(token_id)
    }

    async fn teardown(client: &Client, token_id: TokenId) -> anyhow::Result<()> {
        TokenDeleteTransaction::new()
            .token_id(token_id)
            .execute(client)
            .await?
            .get_receipt(client)
            .await?;

        Ok(())
    }

    const MINT_TRANSACTIONS: usize = 5;
    // mint faster by using less transactions.
    const MAX_MINTS_PER_TX: usize = 10;

    let TestEnvironment { config, client } = setup_global();

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to lack of operator");
        return Ok(());
    };

    if !config.run_nonfree_tests {
        log::debug!("skipping non-free test");
        return Ok(());
    }

    let token_id = setup(op, &client).await?;

    let mut tasks = JoinSet::new();

    for _ in 0..MINT_TRANSACTIONS {
        // give the tasks a bit of time between spawning to avoid hammering the network.
        tokio::time::sleep(std::time::Duration::from_millis(25)).await;
        tasks.spawn({
            let client = client.clone();
            async move { create_nft(&client, token_id, MAX_MINTS_PER_TX).await }
        });
    }

    let mut responses = Vec::with_capacity(MINT_TRANSACTIONS);

    // note: we collect the responses to test simultaniously waiting for multiple receipts next.
    while let Some(response) = tasks.join_next().await {
        let response = response??;

        responses.push(response);
    }

    let mut tasks = JoinSet::new();

    for response in responses {
        // give the tasks a bit of time between spawning to avoid hammering the network.
        tokio::time::sleep(std::time::Duration::from_millis(25)).await;

        let client = client.clone();
        tasks.spawn(async move { response.get_receipt(&client).await });
    }

    while let Some(receipt) = tasks.join_next().await {
        // we error for status here.
        let _receipt = receipt??;
    }

    teardown(&client, token_id).await?;

    Ok(())
}

async fn create_nft(
    client: &Client,
    token_id: TokenId,
    nfts: usize,
) -> hedera::Result<TransactionResponse> {
    TokenMintTransaction::default()
        .token_id(token_id)
        .metadata(vec![Vec::from([0x12, 0x34]); nfts])
        .execute(client)
        .await
}
// Filename: tests/e2e/token/nft_info.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    NftId,
    Status,
    TokenId,
    TokenNftInfoQuery,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::Nft;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = Nft::create(&client, &account).await?;

    let serials = token.mint(&client, [[50_u8]]).await?;

    let nft_id = token.id.nft(serials[0] as u64);

    let nft_info = TokenNftInfoQuery::new().nft_id(nft_id).execute(&client).await?;

    assert_eq!(nft_info.nft_id, nft_id);
    assert_eq!(nft_info.account_id, account.id);
    assert_eq!(nft_info.metadata, vec![50]);

    token.burn(&client, serials).await?;
    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]

async fn invalid_nft_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenNftInfoQuery::new()
        .nft_id(NftId { token_id: TokenId::new(0, 0, 0), serial: 2023 })
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryNoPaymentPreCheckStatus { status: Status::InvalidNftId })
    );

    Ok(())
}

#[tokio::test]
async fn invalid_serial_number_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenNftInfoQuery::new()
        .nft_id(NftId { token_id: TokenId::new(0, 0, 0), serial: u64::MAX })
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryNoPaymentPreCheckStatus {
            status: Status::InvalidTokenNftSerialNumber
        })
    );

    Ok(())
}
// Filename: tests/e2e/token/nft_transfer.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenAssociateTransaction,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::Nft;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = Nft::create(&client, &alice).await?;

    let associate_fut = async {
        TokenAssociateTransaction::new()
            .account_id(bob.id)
            .token_ids([token.id])
            .sign(bob.key.clone())
            .execute(&client)
            .await?
            .get_receipt(&client)
            .await?;

        Ok(())
    };

    let (serials, _) = tokio::try_join!(token.mint_incremental(&client, 10), associate_fut)?;

    let mut transfer_tx = TransferTransaction::new();

    let serials_to_transfer = &serials[..4];

    for &serial in serials_to_transfer {
        transfer_tx.nft_transfer(token.id.nft(serial as u64), alice.id, bob.id);
    }

    transfer_tx.sign(alice.key.clone()).execute(&client).await?.get_receipt(&client).await?;

    let mut transfer_tx = TransferTransaction::new();

    for &serial in serials_to_transfer {
        transfer_tx.nft_transfer(token.id.nft(serial as u64), bob.id, alice.id);
    }

    transfer_tx.sign(bob.key.clone()).execute(&client).await?.get_receipt(&client).await?;

    token.burn(&client, serials).await?;
    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]

async fn unowned_nfts_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = Nft::create(&client, &alice).await?;

    let associate_fut = async {
        TokenAssociateTransaction::new()
            .account_id(bob.id)
            .token_ids([token.id])
            .sign(bob.key.clone())
            .execute(&client)
            .await?
            .get_receipt(&client)
            .await?;

        Ok(())
    };

    let (serials, _) = tokio::try_join!(token.mint_incremental(&client, 10), associate_fut)?;

    let mut transfer_tx = TransferTransaction::new();

    let serials_to_transfer = &serials[..4];

    // try to transfer in the wrong direction
    for &serial in serials_to_transfer {
        transfer_tx.nft_transfer(token.id.nft(serial as u64), bob.id, alice.id);
    }

    let res = transfer_tx.sign(bob.key.clone()).execute(&client).await?.get_receipt(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::SenderDoesNotOwnNftSerialNo, .. })
    );

    token.burn(&client, serials).await?;
    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}
// Filename: tests/e2e/token/nft_update.rs
use std::iter::repeat;

use assert_matches::assert_matches;
use futures_util::stream::{
    self,
    TryStreamExt,
};
use futures_util::StreamExt;
use hedera::{
    Client,
    NftId,
    PrivateKey,
    Status,
    TokenCreateTransaction,
    TokenId,
    TokenInfoQuery,
    TokenMintTransaction,
    TokenNftInfoQuery,
    TokenType,
    TokenUpdateNftsTransaction,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};

#[tokio::test]
async fn update_nft_metadata() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let metadata_key = PrivateKey::generate_ed25519();
    let nft_count = 4;
    let initial_metadata_list: Vec<Vec<u8>> = repeat(vec![9, 1, 6]).take(nft_count).collect();
    let updated_metadata: Vec<u8> = vec![3, 4];
    let updated_metadata_list: Vec<Vec<u8>> =
        repeat(updated_metadata.clone()).take(nft_count).collect();

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .token_type(TokenType::NonFungibleUnique)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .admin_key(client.get_operator_public_key().unwrap())
        .supply_key(client.get_operator_public_key().unwrap())
        .metadata_key(metadata_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    // Mint the token
    let receipt = TokenMintTransaction::new()
        .metadata(initial_metadata_list.clone())
        .token_id(token_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = receipt.serials;
    let metadata_list = get_metadata_list(&client, &token_id, &nft_serials).await?;

    assert_eq!(metadata_list, initial_metadata_list);

    _ = TokenUpdateNftsTransaction::new()
        .token_id(token_id)
        .serials(nft_serials.clone())
        .metadata(updated_metadata)
        .freeze_with(&client)?
        .sign(metadata_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let new_metadata_list = get_metadata_list(&client, &token_id, &nft_serials).await?;
    assert_eq!(new_metadata_list, updated_metadata_list);

    Ok(())
}

#[tokio::test]
async fn cannot_update_without_signed_metadata_key_error() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let supply_key = PrivateKey::generate_ed25519();
    let metadata_key = PrivateKey::generate_ed25519();
    let nft_count = 4;
    let initial_metadata_list: Vec<Vec<u8>> = repeat(vec![9, 1, 6]).take(nft_count).collect();
    let updated_metadata: Vec<u8> = vec![3, 4];

    // Create token with metadata key
    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .token_type(TokenType::NonFungibleUnique)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .admin_key(client.get_operator_public_key().unwrap())
        .supply_key(supply_key.public_key())
        .metadata_key(metadata_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let updated_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(updated_info.metadata_key.unwrap(), metadata_key.public_key().into());

    // Mint token
    let mint_receipt = TokenMintTransaction::new()
        .metadata(initial_metadata_list.clone())
        .token_id(token_id)
        .freeze_with(&client)?
        .sign(supply_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Update Nfts without signing with metadata key
    let res = TokenUpdateNftsTransaction::new()
        .token_id(token_id)
        .serials(nft_serials)
        .metadata(updated_metadata)
        .freeze_with(&client)?
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}

#[tokio::test]
async fn cannot_update_without_set_metadata_key_error() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let supply_key = PrivateKey::generate_ed25519();
    let metadata_key = PrivateKey::generate_ed25519();
    let nft_count = 4;
    let initial_metadata_list: Vec<Vec<u8>> = repeat(vec![9, 1, 6]).take(nft_count).collect();
    let updated_metadata: Vec<u8> = vec![3, 4];

    // Create token without metadata key
    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .token_type(TokenType::NonFungibleUnique)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .admin_key(client.get_operator_public_key().unwrap())
        .supply_key(supply_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.metadata_key, None);

    // Mint Token
    let mint_receipt = TokenMintTransaction::new()
        .metadata(initial_metadata_list.clone())
        .token_id(token_id)
        .freeze_with(&client)?
        .sign(supply_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = mint_receipt.serials;

    // Update Nfts without a set metadata key
    let res = TokenUpdateNftsTransaction::new()
        .token_id(token_id)
        .serials(nft_serials)
        .metadata(updated_metadata)
        .freeze_with(&client)?
        .sign(metadata_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}

async fn get_metadata_list(
    client: &Client,
    token_id: &TokenId,
    serials: &Vec<i64>,
) -> anyhow::Result<Vec<Vec<u8>>> {
    let list = stream::iter(
        serials.into_iter().map(|it| NftId { token_id: token_id.to_owned(), serial: *it as u64 }),
    )
    .then(|nft_id| {
        let client_clone = client;
        async move {
            match TokenNftInfoQuery::new().nft_id(nft_id).execute(&client_clone).await {
                Ok(info) => Ok(info.metadata),
                Err(err) => anyhow::bail!("error calling TokenNftInfoQuery: {err}"), // CHANGE ERROR MESSAGE
            }
        }
    })
    .try_collect::<Vec<_>>()
    .await?;

    Ok(list)
}
// Filename: tests/e2e/token/pause.rs
// SPDX-License-Identifier: Apache-2.0

use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenPauseTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    FungibleToken,
    Key,
    TokenKeys,
};

const TOKEN_PARAMS: CreateFungibleToken = CreateFungibleToken {
    initial_supply: 0,
    keys: TokenKeys { pause: Some(Key::Owner), ..TokenKeys::DEFAULT },
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let owner = Account::create(Hbar::new(0), &client).await?;

    let token = FungibleToken::create(&client, &owner, TOKEN_PARAMS).await?;

    TokenPauseTransaction::new()
        .token_id(token.id)
        .sign(token.owner.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenPauseTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_pause_key_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let owner = Account::create(Hbar::new(0), &client).await?;

    let token = FungibleToken::create(&client, &owner, TOKEN_PARAMS).await?;

    let res = TokenPauseTransaction::new()
        .token_id(token.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_pause_key_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let owner = Account::create(Hbar::new(0), &client).await?;

    let token = FungibleToken::create(&client, &owner, CreateFungibleToken::default()).await?;

    let res = TokenPauseTransaction::new()
        .token_id(token.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenHasNoPauseKey, .. })
    );

    Ok(())
}
// Filename: tests/e2e/token/reject.rs
// SPDX-License-Identifier: Apache-2.0

use std::iter::repeat;

use anyhow::anyhow;
use assert_matches::assert_matches;
use hedera::{
    AccountBalanceQuery,
    Client,
    Hbar,
    PrivateKey,
    Status,
    TokenCreateTransaction,
    TokenFreezeTransaction,
    TokenMintTransaction,
    TokenNftInfoQuery,
    TokenPauseTransaction,
    TokenRejectTransaction,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    Config,
    TestEnvironment,
};
use crate::token::{
    FungibleToken,
    Nft,
};

#[tokio::test]
async fn basic_fungible_token() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let ft1 = create_ft(&client, &operator_account, 3).await?;
    let ft2 = create_ft(&client, &operator_account, 3).await?;
    let receiver_account = create_receiver_account(100, &operator_account.key, &client).await?;

    _ = TransferTransaction::new()
        .token_transfer(ft1.id, operator_account.id, -10)
        .token_transfer(ft1.id, receiver_account.id, 10)
        .token_transfer(ft2.id, operator_account.id, -10)
        .token_transfer(ft2.id, receiver_account.id, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .token_ids(vec![ft1.id, ft2.id])
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let receiver_balance =
        AccountBalanceQuery::new().account_id(receiver_account.id).execute(&client).await?;

    assert_eq!(receiver_balance.tokens.get(&ft1.id), Some(&(0 as u64)));
    assert_eq!(receiver_balance.tokens.get(&ft2.id), Some(&(0 as u64)));

    let treasury_account_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(treasury_account_balance.tokens.get(&ft1.id), Some(&(1_000_000 as u64)));
    assert_eq!(treasury_account_balance.tokens.get(&ft2.id), Some(&(1_000_000 as u64)));

    ft1.delete(&client).await?;
    ft2.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn basic_nft() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let nft1 = Nft::create(&client, &operator_account).await?;
    let nft2 = Nft::create(&client, &operator_account).await?;
    let receiver_account_key = PrivateKey::generate_ed25519();
    let receiver_account = create_receiver_account(100, &receiver_account_key, &client).await?;

    _ = TokenMintTransaction::new()
        .token_id(nft1.id)
        .metadata(repeat(vec![3, 6, 9]).take(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = TokenMintTransaction::new()
        .token_id(nft2.id)
        .metadata(repeat(vec![9, 1, 6]).take(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .serials
        .into_iter()
        .map(|it| it as u64)
        .collect::<Vec<u64>>();

    _ = TransferTransaction::new()
        .nft_transfer(nft1.id.nft(nft_serials[0]), operator_account.id, receiver_account.id)
        .nft_transfer(nft1.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .nft_transfer(nft2.id.nft(nft_serials[0]), operator_account.id, receiver_account.id)
        .nft_transfer(nft2.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .nft_ids(vec![nft1.id.nft(nft_serials[1]), nft2.id.nft(nft_serials[1])])
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_info =
        TokenNftInfoQuery::new().nft_id(nft1.id.nft(nft_serials[1])).execute(&client).await?;

    assert_eq!(nft_info.account_id, operator_account.id);

    let nft_info =
        TokenNftInfoQuery::new().nft_id(nft2.id.nft(nft_serials[1])).execute(&client).await?;

    assert_eq!(nft_info.account_id, operator_account.id);

    nft1.delete(&client).await?;
    nft2.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn ft_and_nft_reject() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let ft1 = create_ft(&client, &operator_account, 3).await?;
    let ft2 = create_ft(&client, &operator_account, 3).await?;
    let nft1 = Nft::create(&client, &operator_account).await?;
    let nft2 = Nft::create(&client, &operator_account).await?;
    let receiver_account_key = PrivateKey::generate_ed25519();
    let receiver_account = create_receiver_account(100, &receiver_account_key, &client).await?;

    _ = TokenMintTransaction::new()
        .token_id(nft1.id)
        .metadata(repeat(vec![3, 6, 9]).take(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let nft_serials = TokenMintTransaction::new()
        .token_id(nft2.id)
        .metadata(repeat(vec![9, 1, 6]).take(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .serials
        .into_iter()
        .map(|it| it as u64)
        .collect::<Vec<u64>>();

    _ = TransferTransaction::new()
        .token_transfer(ft1.id, operator_account.id, -10)
        .token_transfer(ft1.id, receiver_account.id, 10)
        .token_transfer(ft2.id, operator_account.id, -10)
        .token_transfer(ft2.id, receiver_account.id, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TransferTransaction::new()
        .nft_transfer(nft1.id.nft(nft_serials[0]), operator_account.id, receiver_account.id)
        .nft_transfer(nft1.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .nft_transfer(nft2.id.nft(nft_serials[0]), operator_account.id, receiver_account.id)
        .nft_transfer(nft2.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .token_ids(vec![ft1.id, ft2.id])
        .nft_ids(vec![nft1.id.nft(nft_serials[1]), nft2.id.nft(nft_serials[1])])
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let receiver_account_balance =
        AccountBalanceQuery::new().account_id(receiver_account.id).execute(&client).await?;

    assert_eq!(receiver_account_balance.tokens[&ft1.id], 0);
    assert_eq!(receiver_account_balance.tokens[&ft2.id], 0);
    assert_eq!(receiver_account_balance.tokens[&nft1.id], 1);
    assert_eq!(receiver_account_balance.tokens[&nft2.id], 1);

    let treasury_account_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(treasury_account_balance.tokens[&ft1.id], 1_000_000);
    assert_eq!(treasury_account_balance.tokens[&ft2.id], 1_000_000);

    let nft_info =
        TokenNftInfoQuery::new().nft_id(nft1.id.nft(nft_serials[1])).execute(&client).await?;

    assert_eq!(nft_info.account_id, operator_account.id);

    let nft_info =
        TokenNftInfoQuery::new().nft_id(nft2.id.nft(nft_serials[1])).execute(&client).await?;

    assert_eq!(nft_info.account_id, operator_account.id);

    nft1.delete(&client).await?;
    nft2.delete(&client).await?;
    ft1.delete(&client).await?;
    ft2.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn ft_and_nft_freeze_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let ft = create_ft(&client, &operator_account, 18).await?;
    let nft = Nft::create(&client, &operator_account).await?;
    let receiver_account_key = PrivateKey::generate_ed25519();
    let receiver_account = create_receiver_account(100, &receiver_account_key, &client).await?;

    _ = TransferTransaction::new()
        .token_transfer(ft.id, operator_account.id, -10)
        .token_transfer(ft.id, receiver_account.id, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TokenFreezeTransaction::new()
        .token_id(ft.id)
        .account_id(receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .add_token_id(ft.id)
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::AccountFrozenForToken, .. })
    );

    let nft_serials = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .serials
        .into_iter()
        .map(|it| it as u64)
        .collect::<Vec<u64>>();

    _ = TransferTransaction::new()
        .nft_transfer(nft.id.nft(nft_serials[0]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TokenFreezeTransaction::new()
        .token_id(nft.id)
        .account_id(receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .add_nft_id(nft.id.nft(nft_serials[1]))
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::AccountFrozenForToken, .. })
    );

    nft.delete(&client).await?;
    ft.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn ft_and_nft_paused_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let ft = create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;
    let receiver_account_key = PrivateKey::generate_ed25519();
    let receiver_account = create_receiver_account(100, &receiver_account_key, &client).await?;

    _ = TransferTransaction::new()
        .token_transfer(ft.id, operator_account.id, -10)
        .token_transfer(ft.id, receiver_account.id, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TokenPauseTransaction::new()
        .token_id(ft.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .add_token_id(ft.id)
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(res, Err(hedera::Error::ReceiptStatus { status: Status::TokenIsPaused, .. }));

    let nft_serials = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .serials
        .into_iter()
        .map(|it| it as u64)
        .collect::<Vec<u64>>();

    _ = TransferTransaction::new()
        .nft_transfer(nft.id.nft(nft_serials[0]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TokenPauseTransaction::new()
        .token_id(nft.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .add_nft_id(nft.id.nft(nft_serials[1]))
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(res, Err(hedera::Error::ReceiptStatus { status: Status::TokenIsPaused, .. }));

    Ok(())
}

#[tokio::test]
async fn add_or_set_nft_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let nft = Nft::create(&client, &operator_account).await?;
    let receiver_account_key = PrivateKey::generate_ed25519();
    let receiver_account = create_receiver_account(100, &receiver_account_key, &client).await?;

    let nft_serials = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .serials
        .into_iter()
        .map(|it| it as u64)
        .collect::<Vec<u64>>();

    _ = TransferTransaction::new()
        .nft_transfer(nft.id.nft(nft_serials[0]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[2]), operator_account.id, receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .add_token_id(nft.id)
        .nft_ids([nft.id.nft(nft_serials[1]), nft.id.nft(nft_serials[2])])
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: Status::AccountAmountTransfersOnlyAllowedForFungibleCommon,
            ..
        })
    );

    let res = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .token_ids([nft.id])
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: Status::AccountAmountTransfersOnlyAllowedForFungibleCommon,
            ..
        })
    );

    nft.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn treasury_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let ft = create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;

    let res = TokenRejectTransaction::new()
        .owner(operator_account.id)
        .add_token_id(ft.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::AccountIsTreasury, .. })
    );

    let nft_serials = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .serials
        .into_iter()
        .map(|it| it as u64)
        .collect::<Vec<u64>>();

    let res = TokenRejectTransaction::new()
        .owner(operator_account.id)
        .add_nft_id(nft.id.nft(nft_serials[0]))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::AccountIsTreasury, .. })
    );

    Ok(())
}

#[tokio::test]
async fn invalid_sig_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let random_key = PrivateKey::generate_ed25519();
    let ft = create_ft(&client, &operator_account, 3).await?;
    let receiver_account_key = PrivateKey::generate_ed25519();
    let receiver_account = create_receiver_account(100, &receiver_account_key, &client).await?;

    _ = TransferTransaction::new()
        .token_transfer(ft.id, operator_account.id, -10)
        .token_transfer(ft.id, receiver_account.id, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .add_token_id(ft.id)
        .freeze_with(&client)?
        .sign(random_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    ft.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_token_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let res = TokenRejectTransaction::new().owner(operator_account.id).execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: Status::EmptyTokenReferenceList,
            ..
        })
    );

    Ok(())
}

#[tokio::test]
async fn token_reference_list_size_exceeded_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let ft = create_ft(&client, &operator_account, 3).await?;
    let nft = Nft::create(&client, &operator_account).await?;
    let receiver_account_key = PrivateKey::generate_ed25519();
    let receiver_account = create_receiver_account(-1, &receiver_account_key, &client).await?;

    let nft_serials = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .serials
        .into_iter()
        .map(|it| it as u64)
        .collect::<Vec<u64>>();

    _ = TransferTransaction::new()
        .token_transfer(ft.id, operator_account.id, -10)
        .token_transfer(ft.id, receiver_account.id, 10)
        .nft_transfer(nft.id.nft(nft_serials[0]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[2]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[3]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[4]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[5]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[6]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[7]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[8]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[9]), operator_account.id, receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TokenRejectTransaction::new()
        .owner(receiver_account.id)
        .add_token_id(ft.id)
        .nft_ids([
            nft.id.nft(nft_serials[0]),
            nft.id.nft(nft_serials[1]),
            nft.id.nft(nft_serials[2]),
            nft.id.nft(nft_serials[3]),
            nft.id.nft(nft_serials[4]),
            nft.id.nft(nft_serials[5]),
            nft.id.nft(nft_serials[6]),
            nft.id.nft(nft_serials[7]),
            nft.id.nft(nft_serials[8]),
            nft.id.nft(nft_serials[9]),
        ])
        .freeze_with(&client)?
        .sign(receiver_account.key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: Status::TokenReferenceListSizeLimitExceeded,
            ..
        })
    );

    nft.delete(&client).await?;
    ft.delete(&client).await?;

    Ok(())
}

async fn create_ft(
    client: &Client,
    owner: &Account,
    decimals: u32,
) -> anyhow::Result<FungibleToken> {
    let id = TokenCreateTransaction::new()
        .name("ffff".to_string())
        .symbol("F".to_string())
        .token_memo("memo".to_string())
        .decimals(decimals)
        .initial_supply(1_000_000)
        .max_supply(1_000_000)
        .treasury_account_id(owner.id)
        .token_supply_type(hedera::TokenSupplyType::Finite)
        .admin_key(owner.key.public_key())
        .freeze_key(owner.key.public_key())
        .wipe_key(owner.key.public_key())
        .supply_key(owner.key.public_key())
        .metadata_key(owner.key.public_key())
        .pause_key(owner.key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    Ok(FungibleToken { id, owner: owner.clone() })
}

async fn test_operator_account(config: &Config) -> anyhow::Result<Account> {
    if let Some(operator) = config.operator.clone() {
        Ok(Account { key: operator.private_key, id: operator.account_id })
    } else {
        return Err(anyhow!("no operator configured"));
    }
}

async fn create_receiver_account(
    max_automatic_token_associations: i32,
    account_key: &PrivateKey,
    client: &hedera::Client,
) -> hedera::Result<Account> {
    let receipt = hedera::AccountCreateTransaction::new()
        .key(account_key.public_key())
        .initial_balance(Hbar::new(10))
        .max_automatic_token_associations(max_automatic_token_associations)
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    let account_id = receipt.account_id.unwrap();

    Ok(Account { key: account_key.clone(), id: account_id })
}
// Filename: tests/e2e/token/reject_flow.rs
// SPDX-License-Identifier: Apache-2.0

use std::iter::repeat;

use anyhow::anyhow;
use assert_matches::assert_matches;
use hedera::{
    AccountBalanceQuery,
    Client,
    Hbar,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenMintTransaction,
    TokenNftInfoQuery,
    TokenRejectFlow,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    Config,
    TestEnvironment,
};
use crate::token::{
    FungibleToken,
    Nft,
};

#[tokio::test]
async fn basic_flow_fungible_token() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let ft = create_ft(&client, &operator_account, 3).await?;
    let receiver_account = create_receiver_account(0, &operator_account.key, &client).await?;

    _ = TokenAssociateTransaction::new()
        .account_id(receiver_account.id)
        .token_ids(vec![ft.id])
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TransferTransaction::new()
        .token_transfer(ft.id, operator_account.id, -10)
        .token_transfer(ft.id, receiver_account.id, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TokenRejectFlow::new()
        .owner(receiver_account.id)
        .add_token_id(ft.id)
        .freeze_with(client.clone())
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let treasury_account_balance =
        AccountBalanceQuery::new().account_id(operator_account.id).execute(&client).await?;

    assert_eq!(treasury_account_balance.tokens.get(&ft.id), Some(&(1_000_000 as u64)));

    let res = TransferTransaction::new()
        .token_transfer(ft.id, operator_account.id, -10)
        .token_transfer(ft.id, receiver_account.id, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenNotAssociatedToAccount, .. })
    );

    ft.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn basic_flow_nft() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let operator_account = test_operator_account(&config).await?;
    let nft = Nft::create(&client, &operator_account).await?;
    let receiver_account = create_receiver_account(0, &operator_account.key, &client).await?;

    let nft_serials = TokenMintTransaction::new()
        .token_id(nft.id)
        .metadata(repeat(vec![9, 1, 6]).take(5))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .serials
        .into_iter()
        .map(|it| it as u64)
        .collect::<Vec<u64>>();

    _ = TokenAssociateTransaction::new()
        .account_id(receiver_account.id)
        .token_ids([nft.id])
        .freeze_with(&client)?
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TransferTransaction::new()
        .nft_transfer(nft.id.nft(nft_serials[0]), operator_account.id, receiver_account.id)
        .nft_transfer(nft.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TokenRejectFlow::new()
        .owner(receiver_account.id)
        .nft_ids([nft.id.nft(nft_serials[0]), nft.id.nft(nft_serials[1])])
        .freeze_with(client.clone())
        .sign(receiver_account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    println!("here3");

    let nft_info =
        TokenNftInfoQuery::new().nft_id(nft.id.nft(nft_serials[1])).execute(&client).await?;

    assert_eq!(nft_info.account_id, operator_account.id);

    let res = TransferTransaction::new()
        .nft_transfer(nft.id.nft(nft_serials[1]), operator_account.id, receiver_account.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenNotAssociatedToAccount, .. })
    );

    nft.delete(&client).await?;

    Ok(())
}

async fn create_ft(
    client: &Client,
    owner: &Account,
    decimals: u32,
) -> anyhow::Result<FungibleToken> {
    let id = TokenCreateTransaction::new()
        .name("ffff".to_string())
        .symbol("F".to_string())
        .token_memo("memo".to_string())
        .decimals(decimals)
        .initial_supply(1_000_000)
        .max_supply(1_000_000)
        .treasury_account_id(owner.id)
        .token_supply_type(hedera::TokenSupplyType::Finite)
        .admin_key(owner.key.public_key())
        .freeze_key(owner.key.public_key())
        .wipe_key(owner.key.public_key())
        .supply_key(owner.key.public_key())
        .metadata_key(owner.key.public_key())
        .pause_key(owner.key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    Ok(FungibleToken { id, owner: owner.clone() })
}

async fn test_operator_account(config: &Config) -> anyhow::Result<Account> {
    if let Some(operator) = config.operator.clone() {
        Ok(Account { key: operator.private_key, id: operator.account_id })
    } else {
        return Err(anyhow!("no operator configured"));
    }
}

async fn create_receiver_account(
    max_automatic_token_associations: i32,
    account_key: &PrivateKey,
    client: &hedera::Client,
) -> hedera::Result<Account> {
    let receipt = hedera::AccountCreateTransaction::new()
        .key(account_key.public_key())
        .initial_balance(Hbar::new(1))
        .max_automatic_token_associations(max_automatic_token_associations)
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    let account_id = receipt.account_id.unwrap();

    Ok(Account { key: account_key.clone(), id: account_id })
}
// Filename: tests/e2e/token/revoke_kyc.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenAssociateTransaction,
    TokenRevokeKycTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    Key,
    TokenKeys,
};

const TOKEN_PARAMS: CreateFungibleToken = CreateFungibleToken {
    initial_supply: 0,
    keys: TokenKeys { kyc: Some(Key::Owner), ..TokenKeys::DEFAULT },
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TokenRevokeKycTransaction::new()
        .account_id(bob.id)
        .token_id(token.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenRevokeKycTransaction::new()
        .account_id(account.id)
        .sign(account.key.clone())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_account_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, TOKEN_PARAMS).await?;

    let res = TokenRevokeKycTransaction::new()
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidAccountId, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn non_associated_token_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    let res = TokenRevokeKycTransaction::new()
        .account_id(bob.id)
        .token_id(token.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenNotAssociatedToAccount, .. })
    );

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}
// Filename: tests/e2e/token/transfer.rs
use assert_matches::assert_matches;
use hedera::{
    AccountCreateTransaction,
    FixedFee,
    FixedFeeData,
    Hbar,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenId,
    TokenWipeTransaction,
    TransferTransaction,
};
use time::{
    Duration,
    OffsetDateTime,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    FungibleToken,
    Key,
    TokenKeys,
};

const TOKEN_PARAMS: CreateFungibleToken = CreateFungibleToken {
    initial_supply: 10,
    keys: TokenKeys { supply: Some(Key::Owner), ..TokenKeys::DEFAULT },
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .token_transfer(token.id, alice.id, -10)
        .token_transfer(token.id, bob.id, 10)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .token_transfer(token.id, bob.id, -10)
        .token_transfer(token.id, alice.id, 10)
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.burn(&client, 10).await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn insufficient_balance_for_fee_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob, cherry) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client),
    )?;

    let fee = FixedFee {
        all_collectors_are_exempt: true,
        fee_collector_account_id: Some(alice.id),
        fee: FixedFeeData {
            denominating_token_id: Some(TokenId::new(0, 0, 0)),
            amount: 5_000_000_000,
        },
    };

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .initial_supply(1)
        .custom_fees([fee.into()])
        .treasury_account_id(alice.id)
        .freeze_default(false)
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .admin_key(alice.key.public_key())
        .wipe_key(alice.key.public_key())
        .fee_schedule_key(alice.key.public_key())
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token = FungibleToken { id: token_id, owner: alice.clone() };

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TokenAssociateTransaction::new()
        .account_id(cherry.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(cherry.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .token_transfer(token.id, alice.id, -1)
        .token_transfer(token.id, bob.id, 1)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TransferTransaction::new()
        .token_transfer(token.id, bob.id, -1)
        .token_transfer(token.id, cherry.id, 1)
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus {
            status: Status::InsufficientSenderAccountBalanceForCustomFee,
            ..
        })
    );

    TokenWipeTransaction::new()
        .account_id(bob.id)
        .token_id(token.id)
        .amount(1_u64)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client), cherry.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn unowned_token_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // notice the swapped direction
    let res = TransferTransaction::new()
        .token_transfer(token.id, bob.id, -10)
        .token_transfer(token.id, alice.id, 10)
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InsufficientTokenBalance, .. })
    );

    token.burn(&client, 10).await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn decimals() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .token_transfer_with_decimals(token.id, alice.id, -10, 3)
        .token_transfer_with_decimals(token.id, bob.id, 10, 3)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .token_transfer_with_decimals(token.id, bob.id, -10, 3)
        .token_transfer_with_decimals(token.id, alice.id, 10, 3)
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.burn(&client, 10).await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn incorrect_decimals_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let res = TransferTransaction::new()
        .token_transfer_with_decimals(token.id, alice.id, -10, 2)
        .token_transfer_with_decimals(token.id, bob.id, 10, 2)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::UnexpectedTokenDecimals, .. })
    );

    token.burn(&client, 10).await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn transfer_to_account_with_unlimited_associations() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let sender_key = PrivateKey::generate_ed25519();
    let receiver_key = PrivateKey::generate_ed25519();

    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .initial_supply(100_000)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .admin_key(client.get_operator_public_key().unwrap())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let sender_id = AccountCreateTransaction::new()
        .key(sender_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    let receiver_id = AccountCreateTransaction::new()
        .key(receiver_key.public_key())
        .max_automatic_token_associations(-1)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .account_id
        .unwrap();

    _ = TokenAssociateTransaction::new()
        .account_id(sender_id)
        .token_ids([token_id])
        .freeze_with(&client)?
        .sign(sender_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TransferTransaction::new()
        .token_transfer(token_id, client.get_operator_account_id().unwrap(), -10)
        .token_transfer(token_id, sender_id, 10)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    _ = TransferTransaction::new()
        .token_transfer(token_id, sender_id, -10)
        .token_transfer(token_id, receiver_id, 10)
        .freeze_with(&client)?
        .sign(sender_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}
// Filename: tests/e2e/token/unfreeze.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenAssociateTransaction,
    TokenUnfreezeTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    Key,
    TokenKeys,
};

const TOKEN_PARAMS: CreateFungibleToken = CreateFungibleToken {
    initial_supply: 0,
    keys: TokenKeys { freeze: Some(Key::Owner), ..TokenKeys::DEFAULT },
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TokenUnfreezeTransaction::new()
        .account_id(bob.id)
        .token_id(token.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res = TokenUnfreezeTransaction::new()
        .account_id(account.id)
        .sign(account.key.clone())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_account_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = super::FungibleToken::create(&client, &account, TOKEN_PARAMS).await?;

    let res = TokenUnfreezeTransaction::new()
        .token_id(token.id)
        .sign(account.key.clone())
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidAccountId, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn non_associated_token_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(&client, &alice, TOKEN_PARAMS).await?;

    let res = TokenUnfreezeTransaction::new()
        .account_id(bob.id)
        .token_id(token.id)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenNotAssociatedToAccount, .. })
    );

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}
// Filename: tests/e2e/token/unpause.rs
// SPDX-License-Identifier: Apache-2.0

use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenUnpauseTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    FungibleToken,
    Key,
    TokenKeys,
};

const TOKEN_PARAMS: CreateFungibleToken = CreateFungibleToken {
    initial_supply: 0,
    keys: TokenKeys { pause: Some(Key::Owner), ..TokenKeys::DEFAULT },
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let owner = Account::create(Hbar::new(0), &client).await?;

    let token = FungibleToken::create(&client, &owner, TOKEN_PARAMS).await?;

    TokenUnpauseTransaction::new()
        .token_id(token.id)
        .sign(token.owner.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TokenUnpauseTransaction::new().execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_pause_key_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let owner = Account::create(Hbar::new(0), &client).await?;

    let token = FungibleToken::create(&client, &owner, TOKEN_PARAMS).await?;

    let res = TokenUnpauseTransaction::new()
        .token_id(token.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_pause_key_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let owner = Account::create(Hbar::new(0), &client).await?;

    let token = FungibleToken::create(&client, &owner, CreateFungibleToken::default()).await?;

    let res = TokenUnpauseTransaction::new()
        .token_id(token.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenHasNoPauseKey, .. })
    );

    Ok(())
}
// Filename: tests/e2e/token/update.rs
use assert_matches::assert_matches;
use hedera::{
    Client,
    Hbar,
    Key,
    KeyList,
    PrivateKey,
    PublicKey,
    Status,
    TokenCreateTransaction,
    TokenDeleteTransaction,
    TokenId,
    TokenInfoQuery,
    TokenKeyValidation,
    TokenType,
    TokenUpdateTransaction,
};
use time::{
    Duration,
    OffsetDateTime,
};

use super::FungibleToken;
use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    TokenKeys,
};

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;
    let token = FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 0, keys: TokenKeys::ALL_OWNER },
    )
    .await?;

    TokenUpdateTransaction::new()
        .token_id(token.id)
        .token_name("aaaa")
        .token_symbol("A")
        .sign(account.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = TokenInfoQuery::new().token_id(token.id).execute(&client).await?;

    assert_eq!(info.token_id, token.id);
    assert_eq!(info.name, "aaaa");
    assert_eq!(info.symbol, "A");
    assert_eq!(info.decimals, 3);
    assert_eq!(info.treasury_account_id, account.id);
    assert_eq!(info.admin_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.freeze_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.wipe_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.kyc_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.supply_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.pause_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.fee_schedule_key, Some(Key::Single(account.key.public_key())));
    assert_eq!(info.default_freeze_status, Some(false));
    assert_eq!(info.default_kyc_status, Some(false));

    token.delete(&client).await?;
    account.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn immutable_token_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token = FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 0, keys: TokenKeys::NONE },
    )
    .await?;

    let res = TokenUpdateTransaction::new()
        .token_id(token.id)
        .token_name("aaaa")
        .token_symbol("A")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenIsImmutable, .. })
    );

    // can't delete the account because the token still exists, can't delete the token because there's no admin key.

    Ok(())
}

#[tokio::test]
async fn update_immutable_token_metadata() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };
    let initial_metadata = vec![1];
    let updated_metadata = vec![1, 2];
    let metadata_key = PrivateKey::generate_ed25519();

    // Create the Fungible Token with metadata key.
    let token_id = TokenCreateTransaction::new()
        .name("ffff")
        .symbol("F")
        .token_type(TokenType::FungibleCommon)
        .decimals(3)
        .initial_supply(100000)
        .metadata(initial_metadata.clone())
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .admin_key(client.get_operator_public_key().unwrap())
        .metadata_key(metadata_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(&token_info.metadata, &initial_metadata);
    assert_eq!(token_info.metadata_key, Some(Key::Single(metadata_key.public_key())));

    // Update token with metadata key.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata(updated_metadata.clone())
        .freeze_with(&client)?
        .sign(metadata_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.metadata, updated_metadata);

    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Make a token immutable when updating keys to an empty KeyList, signing with an Admin Key,
// and setting the key verification mode to NO_VALIDATION
#[tokio::test]
async fn update_keys_with_admin_sig() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    // Admin, Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(Some(admin_key));

    // Create the token with all keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    let empty_keylist = KeyList::new();

    // Update all lower-privilege keys for token with empty key list,
    // signing with admin key, and verifying with no validation.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .admin_key(empty_keylist.clone())
        .wipe_key(empty_keylist.clone())
        .freeze_key(empty_keylist.clone())
        .kyc_key(empty_keylist.clone())
        .supply_key(empty_keylist.clone())
        .pause_key(empty_keylist.clone())
        .fee_schedule_key(empty_keylist.clone())
        .metadata_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.admin_key.unwrap().to_owned())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.admin_key, None);
    assert_eq!(token_info.freeze_key, None);
    assert_eq!(token_info.wipe_key, None);
    assert_eq!(token_info.kyc_key, None);
    assert_eq!(token_info.supply_key, None);
    assert_eq!(token_info.pause_key, None);
    assert_eq!(token_info.fee_schedule_key, None);
    assert_eq!(token_info.metadata_key, None);

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;

    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Can remove all of tokens lower-privilege keys when updating keys to an empty KeyList,
// signing with an Admin Key, and setting the key verification mode to FULL_VALIDATION
#[tokio::test]
async fn remove_keys_with_admin_sig() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    // Admin, Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(Some(admin_key));

    // Create the token with all keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    let empty_keylist = KeyList::new();

    // Update all lower-privilege keys for token with empty key list,
    // signing with admin key, and verifying with full validation.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .admin_key(empty_keylist.clone())
        .wipe_key(empty_keylist.clone())
        .freeze_key(empty_keylist.clone())
        .kyc_key(empty_keylist.clone())
        .supply_key(empty_keylist.clone())
        .pause_key(empty_keylist.clone())
        .fee_schedule_key(empty_keylist.clone())
        .metadata_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.admin_key.unwrap())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.admin_key, None);
    assert_eq!(token_info.freeze_key, None);
    assert_eq!(token_info.wipe_key, None);
    assert_eq!(token_info.kyc_key, None);
    assert_eq!(token_info.supply_key, None);
    assert_eq!(token_info.pause_key, None);
    assert_eq!(token_info.fee_schedule_key, None);
    assert_eq!(token_info.metadata_key, None);

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Can update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key),
// when signing with an Admin Key, and setting the key verification mode to FULL_VALIDATION, and then revert previous keys
#[tokio::test]
async fn revert_keys_with_admin_sig() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    // Admin, Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(Some(admin_key));

    // Create the token with all keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Generate an unusable key to update the supply key.
    let unusable_key = PublicKey::from_str_ed25519(
        "0x0000000000000000000000000000000000000000000000000000000000000000",
    )
    .unwrap();

    // Update all lower-privilege keys for token with invalid zeros key,
    // signing with admin key, and verifying with full validation.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(unusable_key)
        .freeze_key(unusable_key)
        .kyc_key(unusable_key)
        .supply_key(unusable_key)
        .pause_key(unusable_key)
        .fee_schedule_key(unusable_key)
        .metadata_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.admin_key.as_ref().unwrap().clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.freeze_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.wipe_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.kyc_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.supply_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.pause_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.fee_schedule_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.metadata_key, Some(Key::Single(unusable_key)));

    // Set all lower-privilege keys back to their original values,
    // signing with admin key, and verifying with no validation.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(keys.wipe_key.public_key())
        .freeze_key(keys.freeze_key.public_key())
        .kyc_key(keys.kyc_key.public_key())
        .supply_key(keys.supply_key.public_key())
        .pause_key(keys.pause_key.public_key())
        .fee_schedule_key(keys.fee_schedule_key.public_key())
        .metadata_key(keys.metadata_key.public_key())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.admin_key.as_ref().unwrap().clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(
        token_info.admin_key,
        Some(Key::Single(keys.admin_key.unwrap().clone().public_key()))
    );
    assert_eq!(token_info.freeze_key, Some(Key::Single(keys.freeze_key.public_key())));
    assert_eq!(token_info.wipe_key, Some(Key::Single(keys.wipe_key.public_key())));
    assert_eq!(token_info.kyc_key, Some(Key::Single(keys.kyc_key.public_key())));
    assert_eq!(token_info.supply_key, Some(Key::Single(keys.supply_key.public_key())));
    assert_eq!(token_info.pause_key, Some(Key::Single(keys.pause_key.public_key())));
    assert_eq!(token_info.fee_schedule_key, Some(Key::Single(keys.fee_schedule_key.public_key())));
    assert_eq!(token_info.metadata_key, Some(Key::Single(keys.metadata_key.public_key())));

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Can update all of tokens lower-privilege keys when signing with an Admin Key
// and new respective lower-privilege key, and setting key verification mode to FULL_VALIDATION
#[tokio::test]
async fn update_low_privilege_keys_with_admin_sig() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    // Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(Some(admin_key));

    // New Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let new_keys = generate_keys(None);

    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Update all lower-privilege keys for token with new lower-privilege keys,
    // signing with admin key and new lower-privilege keys, and verifying with full validation.
    _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(new_keys.wipe_key.public_key())
        .freeze_key(new_keys.freeze_key.public_key())
        .kyc_key(new_keys.kyc_key.public_key())
        .supply_key(new_keys.supply_key.public_key())
        .pause_key(new_keys.pause_key.public_key())
        .fee_schedule_key(new_keys.fee_schedule_key.public_key())
        .metadata_key(new_keys.metadata_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.admin_key.unwrap())
        .sign(new_keys.wipe_key.clone())
        .sign(new_keys.freeze_key.clone())
        .sign(new_keys.kyc_key.clone())
        .sign(new_keys.supply_key.clone())
        .sign(new_keys.pause_key.clone())
        .sign(new_keys.fee_schedule_key.clone())
        .sign(new_keys.metadata_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.freeze_key, Some(Key::Single(new_keys.freeze_key.public_key())));
    assert_eq!(token_info.wipe_key, Some(Key::Single(new_keys.wipe_key.public_key())));
    assert_eq!(token_info.kyc_key, Some(Key::Single(new_keys.kyc_key.public_key())));
    assert_eq!(token_info.supply_key, Some(Key::Single(new_keys.supply_key.public_key())));
    assert_eq!(token_info.pause_key, Some(Key::Single(new_keys.pause_key.public_key())));
    assert_eq!(
        token_info.fee_schedule_key,
        Some(Key::Single(new_keys.fee_schedule_key.public_key()))
    );
    assert_eq!(token_info.metadata_key, Some(Key::Single(new_keys.metadata_key.public_key())));

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Cannot make a token immutable when updating keys to an empty KeyList,
// signing with a key that is different from an Admin Key, and setting the key verification mode to NO_VALIDATION
#[tokio::test]
async fn update_keys_empty_keylist_without_admin_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    // Admin (if required), Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(Some(admin_key));

    // Create the token with all keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    let empty_keylist = KeyList::new();

    // Fails to update the immutable token keys to empty keylist without admin signature (sign implicitly with operator key).
    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .kyc_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .pause_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .supply_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .fee_schedule_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .admin_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Cannot make a token immutable when updating keys to an unusable key (i.e. all-zeros key),
// signing with a key that is different from an Admin Key, and setting the key verification mode to NO_VALIDATION
#[tokio::test]
async fn update_keys_unusable_key_without_admin_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    // Admin, Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(Some(admin_key));

    // Create the token with all keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Generate an unusable key.
    let unusable_key = PublicKey::from_str_ed25519(
        "0x0000000000000000000000000000000000000000000000000000000000000000",
    )
    .unwrap();

    // Fails to update the immutable token keys to unusable key  without admin signature (sign implicitly with operator key).
    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(unusable_key.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .kyc_key(unusable_key.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(unusable_key.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .pause_key(unusable_key.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .supply_key(unusable_key.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .fee_schedule_key(unusable_key.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata_key(unusable_key.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .admin_key(unusable_key.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Cannot update the Admin Key to an unusable key (i.e. all-zeros key),
// signing with an Admin Key, and setting the key verification mode to NO_VALIDATION
#[tokio::test]
async fn update_admin_key_to_usuable_key_fail() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Admin and Freeze keys
    let admin_key = PrivateKey::generate_ed25519();
    let supply_key = PrivateKey::generate_ed25519();

    // Create the NFT with admin and supply key.
    let token_id = TokenCreateTransaction::new()
        .name("Test NFT")
        .symbol("TNFT")
        .token_type(TokenType::NonFungibleUnique)
        .treasury_account_id(client.get_operator_account_id().unwrap())
        .admin_key(admin_key.public_key())
        .supply_key(supply_key.public_key())
        .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
        .freeze_with(&client)?
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .token_id
        .unwrap();

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.admin_key, Some(Key::Single(admin_key.public_key())));

    // Generate an unusable key.
    let unusable_key = PublicKey::from_str_ed25519(
        "0x0000000000000000000000000000000000000000000000000000000000000000",
    )
    .unwrap();

    // Update the Admin Key to an unusable key (i.e., all-zeros key),
    // signing with an Admin Key, and setting the key verification mode to NO_VALIDATION
    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .admin_key(unusable_key.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Can update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key),
// when signing with a respective lower-privilege key, and setting the key verification mode to NO_VALIDATION
#[tokio::test]
async fn update_keys_with_lower_privilege_keys_sigs() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };
    // Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(None);

    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Generate an unusable key.
    let unusable_key = PublicKey::from_str_ed25519(
        "0x0000000000000000000000000000000000000000000000000000000000000000",
    )
    .unwrap();

    // Update all of tokens lower-privilege keys to an unusable key (i.e., all-zeros key),
    // when signing with a respective lower-privilege key,
    // and setting the key verification mode to NO_VALIDATION
    let _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(unusable_key)
        .wipe_key(unusable_key)
        .kyc_key(unusable_key)
        .supply_key(unusable_key)
        .pause_key(unusable_key)
        .fee_schedule_key(unusable_key)
        .metadata_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.freeze_key.clone())
        .sign(keys.wipe_key.clone())
        .sign(keys.kyc_key.clone())
        .sign(keys.supply_key.clone())
        .sign(keys.pause_key.clone())
        .sign(keys.fee_schedule_key.clone())
        .sign(keys.metadata_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.freeze_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.wipe_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.kyc_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.supply_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.pause_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.fee_schedule_key, Some(Key::Single(unusable_key)));
    assert_eq!(token_info.metadata_key, Some(Key::Single(unusable_key)));

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Can update all of tokens lower-privilege keys when signing with an old lower-privilege key
// and with a new lower-privilege key, and setting key verification mode to FULL_VALIDATION
#[tokio::test]
async fn update_keys_with_new_and_old_lower_privilege_keys_sigs() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(None);

    // New Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let new_keys = generate_keys(None);

    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Update all of tokens lower-privilege keys when signing with an old respective lower-privilege key,
    // and setting key verification mode to NO_VALIDATION
    let _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(new_keys.freeze_key.public_key())
        .wipe_key(new_keys.wipe_key.public_key())
        .kyc_key(new_keys.kyc_key.public_key())
        .supply_key(new_keys.supply_key.public_key())
        .pause_key(new_keys.pause_key.public_key())
        .fee_schedule_key(new_keys.fee_schedule_key.public_key())
        .metadata_key(new_keys.metadata_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.freeze_key.clone())
        .sign(keys.kyc_key.clone())
        .sign(keys.wipe_key.clone())
        .sign(keys.supply_key.clone())
        .sign(keys.pause_key.clone())
        .sign(keys.fee_schedule_key.clone())
        .sign(keys.metadata_key.clone())
        .sign(new_keys.freeze_key.clone())
        .sign(new_keys.kyc_key.clone())
        .sign(new_keys.wipe_key.clone())
        .sign(new_keys.supply_key.clone())
        .sign(new_keys.pause_key.clone())
        .sign(new_keys.fee_schedule_key.clone())
        .sign(new_keys.metadata_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.freeze_key, Some(Key::Single(new_keys.freeze_key.public_key())));
    assert_eq!(token_info.wipe_key, Some(Key::Single(new_keys.wipe_key.public_key())));
    assert_eq!(token_info.kyc_key, Some(Key::Single(new_keys.kyc_key.public_key())));
    assert_eq!(token_info.supply_key, Some(Key::Single(new_keys.supply_key.public_key())));
    assert_eq!(token_info.pause_key, Some(Key::Single(new_keys.pause_key.public_key())));
    assert_eq!(
        token_info.fee_schedule_key,
        Some(Key::Single(new_keys.fee_schedule_key.public_key()))
    );
    assert_eq!(token_info.metadata_key, Some(Key::Single(new_keys.metadata_key.public_key())));

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Can update all of tokens lower-privilege keys when signing ONLY with an old lower-privilege key,
// and setting key verification mode to NO_VALIDATION
#[tokio::test]
async fn update_keys_with_all_old_lower_privilege_keys_sigs() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(None);

    // New Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let new_keys = generate_keys(None);

    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Update all of tokens lower-privilege keys when signing with all older respective lower-privilege keys,
    // and setting key verification mode to NO_VALIDATION
    let _ = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(new_keys.freeze_key.public_key())
        .wipe_key(new_keys.wipe_key.public_key())
        .kyc_key(new_keys.kyc_key.public_key())
        .supply_key(new_keys.supply_key.public_key())
        .pause_key(new_keys.pause_key.public_key())
        .fee_schedule_key(new_keys.fee_schedule_key.public_key())
        .metadata_key(new_keys.metadata_key.public_key())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.freeze_key.clone())
        .sign(keys.kyc_key.clone())
        .sign(keys.wipe_key.clone())
        .sign(keys.supply_key.clone())
        .sign(keys.pause_key.clone())
        .sign(keys.fee_schedule_key.clone())
        .sign(keys.metadata_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    let token_info = TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    assert_eq!(token_info.freeze_key, Some(Key::Single(new_keys.freeze_key.public_key())));
    assert_eq!(token_info.wipe_key, Some(Key::Single(new_keys.wipe_key.public_key())));
    assert_eq!(token_info.kyc_key, Some(Key::Single(new_keys.kyc_key.public_key())));
    assert_eq!(token_info.supply_key, Some(Key::Single(new_keys.supply_key.public_key())));
    assert_eq!(token_info.pause_key, Some(Key::Single(new_keys.pause_key.public_key())));
    assert_eq!(
        token_info.fee_schedule_key,
        Some(Key::Single(new_keys.fee_schedule_key.public_key()))
    );
    assert_eq!(token_info.metadata_key, Some(Key::Single(new_keys.metadata_key.public_key())));

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Cannot remove all of tokens lower-privilege keys when updating them to an empty KeyList,
// signing with a respective lower-privilege key, and setting the key verification mode to NO_VALIDATION
#[tokio::test]
async fn remove_empty_keylist_keys_lower_privilege_keys_sigs_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(None);

    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    let empty_keylist = KeyList::new();

    // Remove all of tokens lower-privilege keys
    // when updating them to an empty KeyList (trying to remove keys one by one to check all errors),
    // signing with a respective lower-privilege key,
    // and setting the key verification mode to NO_VALIDATION
    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.wipe_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenIsImmutable, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .kyc_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.kyc_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenIsImmutable, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.freeze_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenIsImmutable, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .pause_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.pause_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenIsImmutable, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .supply_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.supply_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenIsImmutable, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .fee_schedule_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.fee_schedule_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenIsImmutable, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata_key(empty_keylist.clone())
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .freeze_with(&client)?
        .sign(keys.metadata_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::TokenIsImmutable, transaction_id: _ })
    );

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Cannot update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key),
// when signing with a key that is different from a respective lower-privilege key, and setting
// the key verification mode to NO_VALIDATION
#[tokio::test]
async fn update_keys_unusable_key_different_key_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(None);

    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Generate an unusable key.
    let unusable_key = PublicKey::from_str_ed25519(
        "0x0000000000000000000000000000000000000000000000000000000000000000",
    )
    .unwrap();

    // Update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key)
    // (trying to remove keys one by one to check all errors),
    // signing with a key that is different from a respective lower-privilege key (implicitly with an operator key),
    // and setting the key verification mode to NO_VALIDATION
    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .kyc_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .pause_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .supply_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .fee_schedule_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::NoValidation)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Cannot update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key),
// when signing ONLY with an old respective lower-privilege key, and setting the key
// verification mode to FULL_VALIDATION
#[tokio::test]
async fn update_with_unusable_key_with_old_key_sig_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(None);

    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Generate an unusable key.
    let unusable_key = PublicKey::from_str_ed25519(
        "0x0000000000000000000000000000000000000000000000000000000000000000",
    )
    .unwrap();

    // Update all of tokens lower-privilege keys to an unusable key (i.e., all-zeros key)
    // (trying to remove keys one by one to check all errors),
    // signing ONLY with an old respective lower-privilege key,
    // and setting the key verification mode to FULL_VALIDATION
    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.wipe_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .kyc_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.kyc_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.freeze_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .pause_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.pause_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .supply_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.supply_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .fee_schedule_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.fee_schedule_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.metadata_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Cannot update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key),
// when signing with an old respective lower-privilege key and new respective lower-privilege key,
// and setting the key verification mode to FULL_VALIDATION
#[tokio::test]
async fn update_unusable_key_old_new_key_sig_full_validation_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(None);

    // New Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let new_keys = generate_keys(None);

    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Generate an unusable key.
    let unusable_key = PublicKey::from_str_ed25519(
        "0x0000000000000000000000000000000000000000000000000000000000000000",
    )
    .unwrap();

    // Update all of tokens lower-privilege keys to an unusable key (i.e., all-zeros key)
    // (trying to remove keys one by one to check all errors),
    // signing with an old respective lower-privilege key and new respective lower-privilege key,
    // and setting the key verification mode to FULL_VALIDATION
    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.wipe_key)
        .sign(new_keys.wipe_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .kyc_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.kyc_key)
        .sign(new_keys.kyc_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.freeze_key)
        .sign(new_keys.freeze_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .pause_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.pause_key)
        .sign(new_keys.pause_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .supply_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.supply_key)
        .sign(new_keys.supply_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .fee_schedule_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.fee_schedule_key)
        .sign(new_keys.fee_schedule_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata_key(unusable_key)
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.metadata_key)
        .sign(new_keys.metadata_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

// HIP-540 (https://hips.hedera.com/hip/hip-540)
// Cannot update all of tokens lower-privilege keys, when signing ONLY with an
// old respective lower-privilege key, and setting the key verification mode to
// FULL_VALIDATION
#[tokio::test]
async fn update_keys_old_key_sig_full_validation_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let keys = generate_keys(None);

    // New Freeze, Wipe, Kyc, Supply, Pause, Fee Schedule, and Metadata keys.
    let new_keys = generate_keys(None);

    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = create_token_with_keys(&client, &keys).await?;

    // Update all of tokens lower-privilege keys
    // (trying to update keys one by one to check all errors),
    // signing ONLY with an old respective lower-privilege key,
    // and setting the key verification mode to FULL_VALIDATION
    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .wipe_key(new_keys.wipe_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.wipe_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .kyc_key(new_keys.kyc_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.kyc_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .freeze_key(new_keys.freeze_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.freeze_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .pause_key(new_keys.pause_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.pause_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .supply_key(new_keys.supply_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.supply_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .fee_schedule_key(new_keys.fee_schedule_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.fee_schedule_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    let tx = TokenUpdateTransaction::new()
        .token_id(token_id)
        .metadata_key(new_keys.metadata_key.public_key())
        .key_verification_mode(TokenKeyValidation::FullValidation)
        .freeze_with(&client)?
        .sign(keys.metadata_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        tx,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, transaction_id: _ })
    );

    _ = TokenDeleteTransaction::new().token_id(token_id).execute(&client).await?;
    Ok(())
}

struct Keys {
    admin_key: Option<PrivateKey>,
    wipe_key: PrivateKey,
    kyc_key: PrivateKey,
    freeze_key: PrivateKey,
    pause_key: PrivateKey,
    supply_key: PrivateKey,
    fee_schedule_key: PrivateKey,
    metadata_key: PrivateKey,
}

fn generate_keys(admin_key: Option<PrivateKey>) -> Keys {
    Keys {
        admin_key,
        wipe_key: PrivateKey::generate_ed25519(),
        kyc_key: PrivateKey::generate_ed25519(),
        freeze_key: PrivateKey::generate_ed25519(),
        pause_key: PrivateKey::generate_ed25519(),
        supply_key: PrivateKey::generate_ed25519(),
        fee_schedule_key: PrivateKey::generate_ed25519(),
        metadata_key: PrivateKey::generate_ed25519(),
    }
}

async fn create_token_with_keys(client: &Client, keys: &Keys) -> anyhow::Result<TokenId> {
    // Create the NFT with all of tokens lower-privilege keys.
    let token_id = {
        let mut tx = TokenCreateTransaction::new();

        tx.name("Test NFT")
            .symbol("TNFT")
            .token_type(TokenType::NonFungibleUnique)
            .expiration_time(OffsetDateTime::now_utc() + Duration::minutes(5))
            .treasury_account_id(client.get_operator_account_id().unwrap())
            .freeze_key(keys.freeze_key.public_key())
            .supply_key(keys.supply_key.public_key())
            .wipe_key(keys.wipe_key.public_key())
            .kyc_key(keys.kyc_key.public_key())
            .pause_key(keys.pause_key.public_key())
            .fee_schedule_key(keys.fee_schedule_key.public_key())
            .metadata_key(keys.metadata_key.public_key());

        if let Some(admin_key) = &keys.admin_key {
            tx.admin_key(admin_key.public_key()).freeze_with(client)?.sign(admin_key.clone());
        }

        tx.execute(&client).await?.get_receipt(&client).await?.token_id.unwrap()
    };

    let token_info: hedera::TokenInfo =
        TokenInfoQuery::new().token_id(token_id).execute(&client).await?;

    if let Some(admin_key) = &keys.admin_key {
        assert_eq!(token_info.admin_key, Some(Key::Single(admin_key.public_key())));
    } else {
        assert_eq!(token_info.admin_key, None);
    }

    assert_eq!(token_info.freeze_key, Some(Key::Single(keys.freeze_key.public_key())));
    assert_eq!(token_info.wipe_key, Some(Key::Single(keys.wipe_key.public_key())));
    assert_eq!(token_info.kyc_key, Some(Key::Single(keys.kyc_key.public_key())));
    assert_eq!(token_info.supply_key, Some(Key::Single(keys.supply_key.public_key())));
    assert_eq!(token_info.pause_key, Some(Key::Single(keys.pause_key.public_key())));
    assert_eq!(token_info.fee_schedule_key, Some(Key::Single(keys.fee_schedule_key.public_key())));
    assert_eq!(token_info.metadata_key, Some(Key::Single(keys.metadata_key.public_key())));

    Ok(token_id)
}
// Filename: tests/e2e/token/wipe.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TokenAssociateTransaction,
    TokenWipeTransaction,
    TransferTransaction,
};

use crate::account::Account;
use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::token::{
    CreateFungibleToken,
    Key,
    TokenKeys,
};

const KEYS: TokenKeys = TokenKeys { wipe: Some(Key::Owner), ..TokenKeys::DEFAULT };

#[tokio::test]
async fn fungible() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(
        &client,
        &alice,
        CreateFungibleToken { initial_supply: 10, keys: KEYS },
    )
    .await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .token_transfer(token.id, alice.id, -10)
        .token_transfer(token.id, bob.id, 10)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TokenWipeTransaction::new()
        .token_id(token.id)
        .account_id(bob.id)
        .amount(10_u64)
        .sign(alice.key.clone())
        .execute(&client)
        .await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]

async fn nft() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::Nft::create(&client, &alice).await?;

    let associate_fut = async {
        TokenAssociateTransaction::new()
            .account_id(bob.id)
            .token_ids([token.id])
            .sign(bob.key.clone())
            .execute(&client)
            .await?
            .get_receipt(&client)
            .await?;

        Ok(())
    };

    let (serials, _) = tokio::try_join!(token.mint_incremental(&client, 10), associate_fut)?;

    let mut transfer_tx = TransferTransaction::new();

    let (serials_to_transfer, serials) = serials.split_at(4);

    for &serial in serials_to_transfer {
        transfer_tx.nft_transfer(token.id.nft(serial as u64), alice.id, bob.id);
    }

    transfer_tx.sign(alice.key.clone()).execute(&client).await?.get_receipt(&client).await?;

    TokenWipeTransaction::new()
        .token_id(token.id)
        .account_id(bob.id)
        .serials(serials_to_transfer.iter().map(|it| *it as u64))
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    token.burn(&client, serials.iter().copied()).await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]

async fn unowned_nft_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::Nft::create(&client, &alice).await?;

    let associate_fut = async {
        TokenAssociateTransaction::new()
            .account_id(bob.id)
            .token_ids([token.id])
            .sign(bob.key.clone())
            .execute(&client)
            .await?
            .get_receipt(&client)
            .await?;

        Ok(())
    };

    let (serials, _) = tokio::try_join!(token.mint_incremental(&client, 10), associate_fut)?;

    // don't transfer them
    let res = TokenWipeTransaction::new()
        .token_id(token.id)
        .account_id(bob.id)
        .serials(serials[0..4].iter().map(|it| *it as u64))
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::AccountDoesNotOwnWipedNft, .. })
    );

    token.burn(&client, serials).await?;
    token.delete(&client).await?;
    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}

#[tokio::test]
async fn missing_account_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let token = super::FungibleToken::create(
        &client,
        &account,
        CreateFungibleToken { initial_supply: 0, keys: KEYS },
    )
    .await?;

    let res = TokenWipeTransaction::new().token_id(token.id).amount(10_u64).execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidAccountId, .. })
    );

    token.delete(&client).await?;
    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]
async fn missing_token_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let account = Account::create(Hbar::new(0), &client).await?;

    let res =
        TokenWipeTransaction::new().account_id(account.id).amount(10_u64).execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTokenId, .. })
    );

    account.delete(&client).await?;
    Ok(())
}

#[tokio::test]

async fn missing_amount() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let (alice, bob) = tokio::try_join!(
        Account::create(Hbar::new(0), &client),
        Account::create(Hbar::new(0), &client)
    )?;

    let token = super::FungibleToken::create(
        &client,
        &alice,
        CreateFungibleToken { initial_supply: 10, keys: KEYS },
    )
    .await?;

    TokenAssociateTransaction::new()
        .account_id(bob.id)
        .token_ids([token.id])
        .freeze_with(&client)?
        .sign(bob.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    TransferTransaction::new()
        .token_transfer(token.id, alice.id, -10)
        .token_transfer(token.id, bob.id, 10)
        .sign(alice.key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    // this is the CUT
    TokenWipeTransaction::new()
        .token_id(token.id)
        .account_id(bob.id)
        .amount(0_u64)
        .sign(alice.key.clone())
        .execute(&client)
        .await?;

    // this is just so that we can actually delete the token.
    TokenWipeTransaction::new()
        .token_id(token.id)
        .account_id(bob.id)
        .amount(10_u64)
        .sign(alice.key.clone())
        .execute(&client)
        .await?;

    token.delete(&client).await?;

    tokio::try_join!(alice.delete(&client), bob.delete(&client))?;

    Ok(())
}
// Filename: tests/e2e/topic/create.rs
use hedera::{
    AccountBalanceQuery,
    AccountCreateTransaction,
    Client,
    CustomFixedFee,
    Hbar,
    Key,
    PrivateKey,
    TokenCreateTransaction,
    TokenId,
    TopicCreateTransaction,
    TopicInfoQuery,
    TopicMessageSubmitTransaction,
    TopicUpdateTransaction,
    TransactionId,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::topic::Topic;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let topic_id = TopicCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .topic_memo("[e2e::TopicCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .topic_id
        .unwrap();

    let topic = Topic { id: topic_id };

    topic.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn fieldless() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let _topic_id = TopicCreateTransaction::new()
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .topic_id
        .unwrap();
    Ok(())
}

#[tokio::test]
async fn autoset_auto_renew_account() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic_id = TopicCreateTransaction::new()
        .admin_key(client.get_operator_public_key().unwrap())
        .topic_memo("[e2e::TopicCreateTransaction]")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .topic_id
        .unwrap();

    let info = TopicInfoQuery::new().topic_id(topic_id).execute(&client).await?;
    assert_eq!(info.auto_renew_account_id.unwrap(), client.get_operator_account_id().unwrap());
    Ok(())
}

async fn create_token(client: &Client) -> anyhow::Result<TokenId> {
    let operator_account_id = client.get_operator_account_id().unwrap();
    let operator_key = client.get_operator_public_key().unwrap();

    let receipt = TokenCreateTransaction::new()
        .name("Test Token")
        .symbol("FT")
        .treasury_account_id(operator_account_id)
        .initial_supply(1_000_000)
        .decimals(2)
        .admin_key(operator_key.clone())
        .supply_key(operator_key)
        .execute(client)
        .await?
        .get_receipt(client)
        .await?;

    Ok(receipt.token_id.unwrap())
}

#[tokio::test]
async fn creates_and_updates_revenue_generating_topic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let fee_exempt_keys = vec![PrivateKey::generate_ecdsa(), PrivateKey::generate_ecdsa()];

    let token1 = create_token(&client).await?;
    let token2 = create_token(&client).await?;

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let custom_fixed_fees = vec![
        CustomFixedFee::new(1, Some(token1), Some(op.account_id)),
        CustomFixedFee::new(2, Some(token2), Some(op.account_id)),
    ];

    // Create revenue-generating topic
    let receipt = TopicCreateTransaction::new()
        .fee_schedule_key(op.private_key.public_key())
        .submit_key(op.private_key.public_key())
        .admin_key(op.private_key.public_key())
        .fee_exempt_keys(fee_exempt_keys.iter().map(|key| key.public_key().into()).collect())
        .custom_fees(custom_fixed_fees)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let topic_id = receipt.topic_id.unwrap();

    let info = TopicInfoQuery::new().topic_id(topic_id).execute(&client).await?;

    assert_eq!(
        info.fee_schedule_key.unwrap().to_bytes(),
        Key::Single(op.private_key.public_key()).to_bytes()
    );

    // Update the revenue-generating topic
    let new_fee_exempt_keys = vec![PrivateKey::generate_ecdsa(), PrivateKey::generate_ecdsa()];
    let new_fee_schedule_key = PrivateKey::generate_ecdsa();

    let new_token1 = create_token(&client).await?;
    let new_token2 = create_token(&client).await?;

    let new_custom_fixed_fees = vec![
        CustomFixedFee::new(3, Some(new_token1), Some(op.account_id)),
        CustomFixedFee::new(4, Some(new_token2), Some(op.account_id)),
    ];

    TopicUpdateTransaction::new()
        .topic_id(topic_id)
        .fee_exempt_keys(new_fee_exempt_keys.iter().map(|key| key.public_key().into()).collect())
        .fee_schedule_key(new_fee_schedule_key.public_key())
        .custom_fees(new_custom_fixed_fees.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let updated_info = TopicInfoQuery::new().topic_id(topic_id).execute(&client).await?;

    assert_eq!(
        updated_info.fee_schedule_key.unwrap().to_bytes(),
        Key::Single(new_fee_schedule_key.public_key()).to_bytes()
    );

    // Validate updated fee exempt keys
    for (idx, key) in new_fee_exempt_keys.iter().enumerate() {
        assert_eq!(
            updated_info.fee_exempt_keys[idx].to_bytes(),
            Key::Single(key.public_key()).to_bytes()
        );
    }

    // Validate updated custom fees
    for (idx, fee) in new_custom_fixed_fees.iter().enumerate() {
        assert_eq!(updated_info.custom_fees[idx].amount, fee.amount);
        assert_eq!(updated_info.custom_fees[idx].denominating_token_id, fee.denominating_token_id);
    }

    Ok(())
}

#[tokio::test]
async fn create_revenue_generating_topic_with_invalid_fee_exempt_key_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let fee_exempt_key = PrivateKey::generate_ecdsa();
    let fee_exempt_key_list_with_duplicates =
        vec![Key::Single(fee_exempt_key.public_key()), Key::Single(fee_exempt_key.public_key())];

    let result = TopicCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .fee_exempt_keys(fee_exempt_key_list_with_duplicates)
        .execute(&client)
        .await;

    assert!(matches!(
        result,
        Err(hedera::Error::TransactionPreCheckStatus {
            status: hedera::Status::FeeExemptKeyListContainsDuplicatedKeys,
            ..
        })
    ));

    // Test exceeding key limit
    let fee_exempt_key_list_exceeding_limit =
        (0..11).map(|_| Key::Single(PrivateKey::generate_ecdsa().public_key())).collect::<Vec<_>>();

    let result = TopicCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .fee_exempt_keys(fee_exempt_key_list_exceeding_limit)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert!(matches!(
        result.unwrap_err(),
        hedera::Error::ReceiptStatus {
            status: hedera::Status::MaxEntriesForFeeExemptKeyListExceeded,
            ..
        }
    ));

    Ok(())
}

// Continuing with more test conversions...
#[tokio::test]
async fn update_fee_schedule_key_without_permission_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let receipt = TopicCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let topic_id = receipt.topic_id.unwrap();
    let fee_schedule_key = PrivateKey::generate_ed25519();

    let result = TopicUpdateTransaction::new()
        .topic_id(topic_id)
        .fee_schedule_key(fee_schedule_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert!(matches!(
        result.unwrap_err(),
        hedera::Error::ReceiptStatus { status: hedera::Status::FeeScheduleKeyCannotBeUpdated, .. }
    ));

    Ok(())
}

#[tokio::test]
async fn update_custom_fees_without_fee_schedule_key_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    // Create a topic without fee schedule key
    let receipt = TopicCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let topic_id = receipt.topic_id.unwrap();

    let token1 = create_token(&client).await?;
    let token2 = create_token(&client).await?;

    let custom_fixed_fees = vec![
        CustomFixedFee::new(1, Some(token1), Some(op.account_id)),
        CustomFixedFee::new(2, Some(token2), Some(op.account_id)),
    ];

    let result = TopicUpdateTransaction::new()
        .topic_id(topic_id)
        .custom_fees(custom_fixed_fees)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert!(matches!(
        result.unwrap_err(),
        hedera::Error::ReceiptStatus { status: hedera::Status::FeeScheduleKeyNotSet, .. }
    ));

    Ok(())
}

#[tokio::test]
async fn charges_hbar_fee_with_limits_applied() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let hbar_amount: u64 = 100_000_000;
    let private_key = PrivateKey::generate_ecdsa();

    let custom_fixed_fee = CustomFixedFee::new(hbar_amount / 2, None, Some(op.account_id));

    let receipt = TopicCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .fee_schedule_key(op.private_key.public_key())
        .add_custom_fee(custom_fixed_fee)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let topic_id = receipt.topic_id.unwrap();

    let account_receipt = AccountCreateTransaction::new()
        .initial_balance(Hbar::new(1))
        .key(private_key.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let account_id = account_receipt.account_id.unwrap();

    client.set_operator(account_id, private_key);

    TopicMessageSubmitTransaction::new()
        .topic_id(topic_id)
        .message("Hello, Hiero hashgraph!".as_bytes().to_vec())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    client.set_operator(op.account_id, PrivateKey::generate_ecdsa());

    let account_info = AccountBalanceQuery::new().account_id(account_id).execute(&client).await?;

    assert!(account_info.hbars.to_tinybars() < (hbar_amount / 2) as i64);

    Ok(())
}

#[tokio::test]
async fn exempts_fee_exempt_keys_from_hbar_fees() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    let Some(op) = &config.operator else {
        log::debug!("skipping test due to missing operator");
        return Ok(());
    };

    let hbar_amount: u64 = 100_000_000;
    let fee_exempt_key1 = PrivateKey::generate_ecdsa();
    let fee_exempt_key2 = PrivateKey::generate_ecdsa();

    let custom_fixed_fee = CustomFixedFee::new(hbar_amount / 2, None, Some(op.account_id));

    let receipt = TopicCreateTransaction::new()
        .admin_key(op.private_key.public_key())
        .fee_schedule_key(op.private_key.public_key())
        .fee_exempt_keys(vec![
            Key::Single(fee_exempt_key1.public_key()),
            Key::Single(fee_exempt_key2.public_key()),
        ])
        .add_custom_fee(custom_fixed_fee)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let topic_id = receipt.topic_id.unwrap();

    let payer_account_receipt = AccountCreateTransaction::new()
        .initial_balance(Hbar::new(1))
        .key(fee_exempt_key1.public_key())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let payer_account_id = payer_account_receipt.account_id.unwrap();

    client.set_operator(payer_account_id, fee_exempt_key1);

    TopicMessageSubmitTransaction::new()
        .topic_id(topic_id)
        .message("Hello, Hiero hashgraph!".as_bytes().to_vec())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    client.set_operator(payer_account_id, PrivateKey::generate_ecdsa());

    let account_info =
        AccountBalanceQuery::new().account_id(payer_account_id).execute(&client).await?;

    assert!(account_info.hbars.to_tinybars() > (hbar_amount / 2) as i64);

    Ok(())
}

// Test temporarily taken out until can figure out a solution for a separate freeze
#[tokio::test]
async fn automatically_assign_auto_renew_account_id_on_topic_create() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic_receipt =
        TopicCreateTransaction::new().execute(&client).await?.get_receipt(&client).await?;

    let topic_id = topic_receipt.topic_id.unwrap();

    let info = TopicInfoQuery::new().topic_id(topic_id).execute(&client).await?;

    assert!(info.auto_renew_account_id.is_some());

    Ok(())
}

#[tokio::test]
async fn create_with_transaction_id_assigns_auto_renew_account_id_to_transaction_id_account_id(
) -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let private_key = PrivateKey::generate_ecdsa();
    let public_key = private_key.public_key();

    let account_receipt = AccountCreateTransaction::new()
        .key(public_key)
        .initial_balance(Hbar::new(10))
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let account_id = account_receipt.account_id.unwrap();

    let topic_receipt = TopicCreateTransaction::new()
        .transaction_id(TransactionId::generate(account_id))
        .freeze_with(&client)?
        .sign(private_key)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let topic_id = topic_receipt.topic_id.unwrap();

    let topic_info = TopicInfoQuery::new().topic_id(topic_id).execute(&client).await?;

    assert_eq!(topic_info.auto_renew_account_id, Some(account_id));

    Ok(())
}
// Filename: tests/e2e/topic/delete.rs
use assert_matches::assert_matches;
use hedera::{
    PrivateKey,
    Status,
    TopicCreateTransaction,
    TopicDeleteTransaction,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::topic::Topic;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;

    TopicDeleteTransaction::new()
        .topic_id(topic.id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    Ok(())
}

#[tokio::test]
async fn immutable_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic_id = TopicCreateTransaction::new()
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .topic_id
        .unwrap();

    let res = TopicDeleteTransaction::new()
        .topic_id(topic_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;
    assert_matches!(res, Err(hedera::Error::ReceiptStatus { status: Status::Unauthorized, .. }));

    Ok(())
}

#[tokio::test]
async fn wrong_admin_key_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let admin_key = PrivateKey::generate_ed25519();

    let topic_id = TopicCreateTransaction::new()
        .admin_key(admin_key.public_key())
        .sign(admin_key.clone())
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?
        .topic_id
        .unwrap();

    let res = TopicDeleteTransaction::new()
        .topic_id(topic_id)
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::ReceiptStatus { status: Status::InvalidSignature, .. })
    );

    Ok(())
}
// Filename: tests/e2e/topic/info.rs
use assert_matches::assert_matches;
use hedera::{
    Hbar,
    Status,
    TopicInfoQuery,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::topic::Topic;

#[tokio::test]
async fn query() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;

    let info = TopicInfoQuery::new().topic_id(topic.id).execute(&client).await?;

    assert_eq!(info.topic_memo, "[e2e::TopicCreateTransaction]");

    topic.delete(&client).await?;

    Ok(())
}
#[tokio::test]
async fn query_cost() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;
    let mut query = TopicInfoQuery::new();

    query.topic_id(topic.id);

    let cost = query.get_cost(&client).await?;

    let info = query.payment_amount(cost).execute(&client).await?;

    assert_eq!(info.topic_memo, "[e2e::TopicCreateTransaction]");

    topic.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_big_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;

    let mut query = TopicInfoQuery::new();

    query.topic_id(topic.id).max_payment_amount(Hbar::new(1000));

    let cost = query.get_cost(&client).await?;

    let info = query.payment_amount(cost).execute(&client).await?;

    assert_eq!(info.topic_memo, "[e2e::TopicCreateTransaction]");

    topic.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_small_max() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;

    let mut query = TopicInfoQuery::new();

    query.topic_id(topic.id).max_payment_amount(Hbar::from_tinybars(1));

    let cost = query.get_cost(&client).await?;

    let res = query.execute(&client).await;

    let (max_query_payment, query_cost) = assert_matches!(
        res,
        Err(hedera::Error::MaxQueryPaymentExceeded {
            max_query_payment,
            query_cost
        }) => (max_query_payment, query_cost)
    );

    assert_eq!(max_query_payment, Hbar::from_tinybars(1));
    // note: there's a very small chance this fails if the cost of a TopicContentsQuery changes right when we execute it.
    assert_eq!(query_cost, cost);

    topic.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn query_cost_insufficient_tx_fee() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;

    let res = TopicInfoQuery::new()
        .topic_id(topic.id)
        .max_payment_amount(Hbar::from_tinybars(10000))
        .payment_amount(Hbar::from_tinybars(1))
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::QueryPaymentPreCheckStatus { status: Status::InsufficientTxFee, .. })
    );

    topic.delete(&client).await?;

    Ok(())
}
// Filename: tests/e2e/topic/message.rs
use hedera::{
    Key,
    TopicInfoQuery,
    TopicMessageQuery,
    TopicMessageSubmitTransaction,
};
use time::OffsetDateTime;

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::resources;
use crate::topic::Topic;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Skip if using local node.
    // Note: Remove when multinode is supported
    if config.is_local {
        return Ok(());
    }

    let topic = Topic::create(&client).await?;

    let info = TopicInfoQuery::new().topic_id(topic.id).execute(&client).await?;

    assert_eq!(info.topic_id, topic.id);
    assert_eq!(info.topic_memo, "[e2e::TopicCreateTransaction]");
    assert_eq!(info.sequence_number, 0);
    assert_eq!(info.admin_key, Some(Key::from(client.get_operator_public_key().unwrap())));

    tokio::time::sleep(std::time::Duration::from_millis(3000)).await;

    tokio::spawn({
        let id = topic.id;
        let client = client.clone();
        async move {
            TopicMessageSubmitTransaction::new()
                .topic_id(id)
                .message("Hello, from HCS!")
                .execute(&client)
                .await?
                .get_receipt(&client)
                .await?;

            anyhow::Ok(())
        }
    });

    let fut = async {
        for _ in 0..20 {
            let res = TopicMessageQuery::new()
                .topic_id(topic.id)
                .start_time(OffsetDateTime::UNIX_EPOCH)
                .limit(1)
                .execute(&client)
                .await;

            tokio::time::sleep(std::time::Duration::from_millis(3000)).await;

            // topic not found -> try again
            if let Err(hedera::Error::GrpcStatus(status)) = &res {
                if status.code() == tonic::Code::NotFound {
                    tokio::time::sleep(std::time::Duration::from_millis(200)).await;
                    continue;
                }
            }

            return res.map_err(anyhow::Error::from);
        }

        anyhow::bail!("Couldn't get topic after 20 attempts")
    };

    let messages = tokio::time::timeout(std::time::Duration::from_secs(60), fut).await??;

    assert_eq!(messages.len(), 1);
    assert_eq!(messages[0].contents, "Hello, from HCS!".as_bytes());
    topic.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn large() -> anyhow::Result<()> {
    let Some(TestEnvironment { config, client }) = setup_nonfree() else {
        return Ok(());
    };

    // Skip if using local node.
    // Note: Remove when multinode is supported
    if config.is_local {
        return Ok(());
    }

    let topic = Topic::create(&client).await?;

    tokio::spawn({
        let id = topic.id;
        let client = client.clone();

        async move {
            TopicMessageSubmitTransaction::new()
                .topic_id(id)
                .message(resources::BIG_CONTENTS)
                .execute(&client)
                .await?
                .get_receipt(&client)
                .await?;

            anyhow::Ok(())
        }
    });

    let fut = async {
        for _ in 0..20 {
            let res = TopicMessageQuery::new()
                .topic_id(topic.id)
                .start_time(OffsetDateTime::UNIX_EPOCH)
                .limit(14)
                .execute(&client)
                .await;

            // topic not found -> try again
            if let Err(hedera::Error::GrpcStatus(status)) = &res {
                if status.code() == tonic::Code::NotFound {
                    tokio::time::sleep(std::time::Duration::from_millis(200)).await;
                    continue;
                }
            }

            return res.map_err(anyhow::Error::from);
        }

        anyhow::bail!("Couldn't get topic after 20 attempts")
    };

    let messages = tokio::time::timeout(std::time::Duration::from_secs(60), fut).await??;

    assert_eq!(messages.len(), 1);
    assert_eq!(messages[0].contents, resources::BIG_CONTENTS.as_bytes());
    topic.delete(&client).await?;

    Ok(())
}
// Filename: tests/e2e/topic/message_submit.rs
use assert_matches::assert_matches;
use hedera::{
    AnyTransaction,
    Status,
    TopicInfoQuery,
    TopicMessageSubmitTransaction,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::resources;
use crate::topic::Topic;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;

    TopicMessageSubmitTransaction::new()
        .topic_id(topic.id)
        .message("Hello, from HCS!")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = TopicInfoQuery::new().topic_id(topic.id).execute(&client).await?;

    assert_eq!(info.topic_id, topic.id);
    assert_eq!(info.sequence_number, 1);

    topic.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn large_message() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;

    let responses = TopicMessageSubmitTransaction::new()
        .topic_id(topic.id)
        .max_chunks(15)
        .message(resources::BIG_CONTENTS)
        .execute_all(&client)
        .await?;

    for response in responses {
        response.get_receipt(&client).await?;
    }

    let info = TopicInfoQuery::new().topic_id(topic.id).execute(&client).await?;

    assert_eq!(info.topic_id, topic.id);
    assert_eq!(info.sequence_number, 14);

    topic.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn missing_topic_id_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let res = TopicMessageSubmitTransaction::new()
        .max_chunks(15)
        .message(resources::BIG_CONTENTS)
        .execute(&client)
        .await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTopicId, .. })
    );

    Ok(())
}

#[tokio::test]
async fn missing_message_fails() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;

    let res = TopicMessageSubmitTransaction::new().topic_id(topic.id).execute(&client).await;

    assert_matches!(
        res,
        Err(hedera::Error::TransactionPreCheckStatus { status: Status::InvalidTopicMessage, .. })
    );

    topic.delete(&client).await?;

    Ok(())
}

#[tokio::test]
async fn decode_hex_regression_test() -> anyhow::Result<()> {
    let transaction_bytes = hex_literal::hex!(
        "2ac2010a580a130a0b08d38f8f880610a09be91512041899e11c120218041880\
        c2d72f22020878da01330a0418a5a12012103030303030303136323736333737\
        31351a190a130a0b08d38f8f880610a09be91512041899e11c1001180112660a\
        640a20603edaec5d1c974c92cb5bee7b011310c3b84b13dc048424cd6ef146d6\
        a0d4a41a40b6a08f310ee29923e5868aac074468b2bde05da95a806e2f4a4f45\
        2177f129ca0abae7831e595b5beaa1c947e2cb71201642bab33fece5184b0454\
        7afc40850a"
    );

    let transaction = AnyTransaction::from_bytes(&transaction_bytes)?;

    let _id = transaction.get_transaction_id().unwrap();

    Ok(())
}
// Filename: tests/e2e/topic/mod.rs
use hedera::{
    Client,
    TopicCreateTransaction,
    TopicDeleteTransaction,
    TopicId,
};

mod create;
mod delete;
mod info;
mod message;
mod message_submit;
mod update;
// mod message;
// mod message_submit;
// mod update;

struct Topic {
    id: TopicId,
}

impl Topic {
    async fn create(client: &Client) -> anyhow::Result<Self> {
        let id = TopicCreateTransaction::new()
            .admin_key(client.get_operator_public_key().unwrap())
            .topic_memo("[e2e::TopicCreateTransaction]")
            .execute(client)
            .await?
            .get_receipt(client)
            .await?
            .topic_id
            .unwrap();

        Ok(Self { id })
    }

    async fn delete(self, client: &Client) -> anyhow::Result<()> {
        TopicDeleteTransaction::new()
            .topic_id(self.id)
            .execute(client)
            .await?
            .get_receipt(client)
            .await?;

        Ok(())
    }
}
// Filename: tests/e2e/topic/update.rs
use hedera::{
    TopicInfoQuery,
    TopicUpdateTransaction,
};

use crate::common::{
    setup_nonfree,
    TestEnvironment,
};
use crate::topic::Topic;

#[tokio::test]
async fn basic() -> anyhow::Result<()> {
    let Some(TestEnvironment { config: _, client }) = setup_nonfree() else {
        return Ok(());
    };

    let topic = Topic::create(&client).await?;

    TopicUpdateTransaction::new()
        .topic_id(topic.id)
        .clear_auto_renew_account_id()
        .topic_memo("hello")
        .execute(&client)
        .await?
        .get_receipt(&client)
        .await?;

    let info = TopicInfoQuery::new().topic_id(topic.id).execute(&client).await?;

    assert_eq!(info.topic_memo, "hello");
    assert_eq!(info.auto_renew_account_id, None);

    topic.delete(&client).await?;
    Ok(())
}
