// Filename: src/sdk/examples/ContractHelper.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_EXAMPLES_CONTRACT_HELPER_H_
#define HIERO_SDK_CPP_EXAMPLES_CONTRACT_HELPER_H_

#include "AccountId.h"
#include "Client.h"
#include "ContractCreateFlow.h"
#include "ContractExecuteTransaction.h"
#include "ContractFunctionParameters.h"
#include "ContractFunctionResult.h"
#include "ContractId.h"
#include "Hbar.h"
#include "PrivateKey.h"
#include "Status.h"
#include "TransactionId.h"
#include "TransactionReceipt.h"
#include "TransactionRecord.h"
#include "TransactionResponse.h"
#include "impl/HexConverter.h"

#include <basic_types.pb.h>
#include <fstream>
#include <functional>
#include <iostream>
#include <memory>
#include <nlohmann/json.hpp>
#include <string_view>
#include <unordered_map>
#include <vector>

namespace Hiero
{
/**
 * ContractHelper de-clutters SolidityPrecompileExample.
 *
 * When we instantiate a ContractHelper, we provide it with the JSON of a compiled solidity contract which is assumed to
 * have functions named "step0()" through "stepN()".
 *
 * Each of these step functions is assumed to take no function parameters, and to return a Hiero ResponseCode which
 * ought to be SUCCESS -- in other words, an int32 with value 22. See
 * examples/precompile-example/HederaResponseCodes.sol.
 *
 * If a step takes function parameters, or if its ContractFunctionResult should be validated with a different method,
 * the user can specify a supplier for a particular step with setParameterSupplier(stepIndex, parametersSupplier), and
 * can specify an alternative validation method with setResultValidator(stepIndex, validateFunction)
 *
 * The contract is created on the Hiero network in the ContractHelper constructor, and when the user is ready to
 * execute the step functions in the contract, they should call executeSteps(firstStepToExecute, lastStepToExecute).
 */
class ContractHelper
{
public:
  /**
   * Initialize this ContractHelper with the JSON file that contains the contract bytecode, the constructor parameters,
   * and the Client to use to create the contract.
   *
   * @param filename              The JSON file that contains the contract bytecode.
   * @param constructorParameters The constructor parameters for the contract.
   * @param client                The Client to use the create the contract.
   */
  ContractHelper(std::string_view filename,
                 const ContractFunctionParameters& constructorParameters,
                 const Client& client)
    : mContractId(ContractCreateFlow()
                    .setBytecode(getBytecodeHex(filename))
                    .setMaxChunks(30U)
                    .setGas(8'000'000)
                    .setConstructorParameters(constructorParameters)
                    .execute(client)
                    .getReceipt(client)
                    .mContractId.value())
  {
  }

  /**
   * Add a result validator for a step.
   *
   * @param step The step the validator should take effect.
   * @param func The validator function to run.
   * @return A reference to this ContractHelper with the newly-added step result validator.
   */
  ContractHelper& setResultValidatorForStep(int step, const std::function<bool(const ContractFunctionResult&)>& func)
  {
    mStepResultValidators.try_emplace(step, func);
    return *this;
  }

  /**
   * Add a parameter supplier for a step.
   *
   * @param step The step the parameter should be supplied.
   * @param func The parameter supplier to run.
   * @return A reference to this ContractHelper with the newly-added step parameter supplier.
   */
  ContractHelper& setParameterSupplierForStep(int step, const std::function<ContractFunctionParameters(void)>& func)
  {
    mStepParameterSupplier.try_emplace(step, func);
    return *this;
  }

  /**
   * Add a payable amount for a step.
   *
   * @param step   The step to which the payable amount should be added.
   * @param amount The payable amount.
   * @return A reference to this ContractHelper with the newly-added payable amount.
   */
  ContractHelper& setPayableAmountForStep(int step, const Hbar& amount)
  {
    mStepPayableAmounts.try_emplace(step, amount);
    return *this;
  }

  /**
   * Add a signer for a step.
   *
   * @param step The step to which the signer should sign.
   * @param key  The PrivateKey with which to sign.
   * @return A reference to this ContractHelper with the newly-added signer key.
   */
  ContractHelper& addSignerForStep(int step, const std::shared_ptr<PrivateKey>& key)
  {
    mStepSigners[step].push_back(key);
    return *this;
  }

  /**
   * Add a fee payer for a step.
   *
   * @param step      The step to which the fee payer should be added.
   * @param accountId The ID of the account paying.
   * @param key       The private key of the fee payer account.
   * @return A reference to this ContractHelper with the newly-added payable amount.
   */
  ContractHelper& setFeePayerForStep(int step, const AccountId& accountId, const std::shared_ptr<PrivateKey>& key)
  {
    mStepFeePayers.try_emplace(step, accountId);
    return addSignerForStep(step, key);
  }

  /**
   * Execute all steps.
   *
   * @param first  The first step to execute.
   * @param last   The last step to execute.
   * @param client The Client to use to execute the steps.
   */
  ContractHelper& executeSteps(int first, int last, const Client& client)
  {
    for (int step = first; step < last + 1; ++step)
    {
      std::cout << "Attempting to execute step " << step << std::endl;

      ContractExecuteTransaction transaction =
        ContractExecuteTransaction().setContractId(mContractId).setGas(10'000'000);

      const bool hasPayableAmount = mStepPayableAmounts.find(step) != mStepPayableAmounts.end();
      const bool hasParameters = mStepParameterSupplier.find(step) != mStepParameterSupplier.end();
      const bool hasFeePayer = mStepFeePayers.find(step) != mStepFeePayers.end();
      const bool hasSigners = mStepSigners.find(step) != mStepSigners.end();
      const bool hasResultValidator = mStepResultValidators.find(step) != mStepResultValidators.end();

      if (hasPayableAmount)
      {
        transaction.setPayableAmount(mStepPayableAmounts.at(step));
      }

      transaction.setFunction("step" + std::to_string(step),
                              hasParameters ? mStepParameterSupplier.at(step)() : ContractFunctionParameters());

      if (hasFeePayer)
      {
        transaction.setTransactionId(TransactionId::generate(mStepFeePayers.at(step)));
      }

      transaction.freezeWith(&client);
      if (hasSigners)
      {
        std::for_each(mStepSigners.at(step).cbegin(),
                      mStepSigners.at(step).cend(),
                      [&transaction](const std::shared_ptr<PrivateKey>& key) { transaction.sign(key); });
      }

      const TransactionRecord txRecord = transaction.execute(client).setValidateStatus(false).getRecord(client);

      const ContractFunctionResult result = txRecord.mContractFunctionResult.value();
      const std::function<bool(const ContractFunctionResult&)> validatorFunc =
        hasResultValidator ? mStepResultValidators.at(step)
                           : [](const ContractFunctionResult& stepResult)
      {
        // Assume no custom validator means the function should return a success.
        const Status status =
          gProtobufResponseCodeToStatus.at(static_cast<proto::ResponseCodeEnum>(stepResult.getInt32(0)));
        return status == Status::SUCCESS;
      };

      if (validatorFunc(result))
      {
        std::cout << "Step " << step
                  << " completed and returned a valid result. TransactionId=" << txRecord.mTransactionId->toString()
                  << std::endl;
      }
      else
      {
        std::cout << "Encountered invalid response status" << std::endl;
      }
    }

    return *this;
  }

private:
  /**
   * Get the hex-encoded bytecode in the input JSON file.
   *
   * @param file The JSON file from which to grab the bytecode.
   * @return The bytecode encoded into a hex string.
   */
  static std::string getBytecodeHex(std::string_view file)
  {
    std::ifstream infile(file.data());
    nlohmann::json json = nlohmann::json::parse(infile);

    if (json.contains("object") && json["object"].is_string())
    {
      return json["object"].get<std::string>();
    }
    else
    {
      return json["bytecode"].get<std::string>();
    }
  }

  /**
   * The ID of the created contract.
   */
  ContractId mContractId;

  /**
   * Map of steps to the step's validator function.
   */
  std::unordered_map<int, std::function<bool(const ContractFunctionResult&)>> mStepResultValidators;

  /**
   * Map of steps to the step's parameter supplier.
   */
  std::unordered_map<int, std::function<ContractFunctionParameters(void)>> mStepParameterSupplier;

  /**
   * Map of steps to the step's payable amount.
   */
  std::unordered_map<int, Hbar> mStepPayableAmounts;

  /**
   * Map of steps to the step's signers.
   */
  std::unordered_map<int, std::vector<std::shared_ptr<PrivateKey>>> mStepSigners;

  /**
   * Map of steps to the ID of the fee payer account.
   */
  std::unordered_map<int, AccountId> mStepFeePayers;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_EXAMPLES_CONTRACT_HELPER_H_
// Filename: src/sdk/main/include/AccountAllowanceApproveTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_ALLOWANCE_APPROVE_TRANSACTION_H_
#define HIERO_SDK_CPP_ACCOUNT_ALLOWANCE_APPROVE_TRANSACTION_H_

#include "HbarAllowance.h"
#include "TokenAllowance.h"
#include "TokenNftAllowance.h"
#include "Transaction.h"

#include <vector>

namespace proto
{
class CryptoApproveAllowanceTransactionBody;
class TransactionBody;
}

namespace Hiero
{
class AccountId;
class Hbar;
class NftId;
class TokenId;
}

namespace Hiero
{
/**
 * A transaction that allows a token owner to delegate a token spender to spend the specified token amount on behalf of
 * the token owner. An owner can provide a token allowance for HBARs, non-fungible and fungible tokens. The owner is the
 * account that owns the tokens and grants the allowance to the spender. The spender is the account that spends tokens
 * authorized by the owner from the owners account. The spender pays for the transaction fees when transferring tokens
 * from the owners account to another recipient.
 *
 * The total number of approvals in this transaction cannot exceed 20. Note that each NFT serial number counts as a
 * single approval, hence a transaction granting 20 serial numbers to a spender will use all of the approvals permitted
 * for the transaction.
 *
 * A single NFT serial number can only be granted to one spender at a time. If an approval assigns a previously approved
 * NFT serial number to a new user, the old user will have their approval removed.
 *
 * Each account is limited to 100 allowances. This limit spans HBAR and fungible token allowances and non-fungible token
 * approved_for_all grants. There is no limit on the number of NFT serial number approvals an owner may grant.
 *
 * The number of allowances set on an account will increase the auto-renewal fee for the account. Conversely, removing
 * allowances will decrease the auto-renewal fee for the account.
 *
 * To decrease the allowance for a given spender, you will need to set the amount to the value you would like to
 * authorize the spender account for. If the spender account was authorized to spend 25 HBARs and the owner now wants to
 * modify their allowance to 5 HBARs, the owner would submit the AccountAllowanceApproveTransaction for 5 HBARs.
 *
 * Only when a spender is set on an explicit NFT ID of a token, do we return the spender ID in TokenNftInfoQuery for the
 * respective NFT. If approveTokenNftAllowanceAllSerials is used to approve all NFTs for a given token class and no NFT
 * ID is specified, we will not return a spender ID for all the serial numbers of that token.
 */
class AccountAllowanceApproveTransaction : public Transaction<AccountAllowanceApproveTransaction>
{
public:
  AccountAllowanceApproveTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a CryptoApproveAllowance transaction.
   */
  explicit AccountAllowanceApproveTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit AccountAllowanceApproveTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Add an Hbar allowance to this AccountAllowanceApproveTransaction.
   *
   * @param ownerAccountId   The ID of the account that is allowing the spending of its Hbar.
   * @param spenderAccountId The ID of the account that is being allowed to spend the owning account's Hbar.
   * @param amount           The amount of Hbar that is being approved to spend. This amount must be positive.
   * @return A reference to this AccountAllowanceApproveTransaction object with the added Hbar allowance.
   * @throws IllegalStateException If this AccountAllowanceApproveTransaction is frozen.
   */
  AccountAllowanceApproveTransaction& approveHbarAllowance(const AccountId& ownerAccountId,
                                                           const AccountId& spenderAccountId,
                                                           const Hbar& amount);

  /**
   * Add a token allowance to this AccountAllowanceApproveTransaction.
   *
   * @param tokenId          The ID of the token of which to approve the spending.
   * @param ownerAccountId   The ID of the account that is allowing the spending of its tokens.
   * @param spenderAccountId The ID of the account that is being allowed to spend the owning account's tokens.
   * @param amount           The amount of the token that is being approved to spend.
   * @return A reference to this AccountAllowanceApproveTransaction object with the added token allowance.
   * @throws IllegalStateException If this AccountAllowanceApproveTransaction is frozen.
   */
  AccountAllowanceApproveTransaction& approveTokenAllowance(const TokenId& tokenId,
                                                            const AccountId& ownerAccountId,
                                                            const AccountId& spenderAccountId,
                                                            const int64_t& amount);

  /**
   * Add an NFT allowance to this AccountAllowanceApproveTransaction.
   *
   * @param nftId                      The ID of the NFT of which to approve the spending.
   * @param ownerAccountId             The ID of the account that is allowing the spending of the NFT.
   * @param spenderAccountId           The ID of the account that is being allowed to spend the owning account's NFT.
   * @param delegatingSpenderAccountId The ID of the account who has an 'approveForAll' allowance from the owner, and is
   *                                   granting approval to the spender to spend on their behalf.
   * @return A reference to this AccountAllowanceApproveTransaction object with the added NFT allowance.
   * @throws IllegalStateException If this AccountAllowanceApproveTransaction is frozen.
   */
  AccountAllowanceApproveTransaction& approveTokenNftAllowance(
    const NftId& nftId,
    const AccountId& ownerAccountId,
    const AccountId& spenderAccountId,
    const AccountId& delegatingSpenderAccountId = AccountId());

  /**
   * Add an allowance for all NFTs of a specific token ID to this AccountAllowanceApproveTransaction.
   *
   * @param tokenId          The ID of the NFT tokens of which to approve the spending.
   * @param ownerAccountId   The ID of the account that is allowing the spending of its NFTs.
   * @param spenderAccountId The ID of the account that is being allowed to spend the owning account's NFTs.
   * @return A reference to this AccountAllowanceApproveTransaction object with the added NFT allowances.
   * @throws IllegalStateException If this AccountAllowanceApproveTransaction is frozen.
   */
  AccountAllowanceApproveTransaction& approveNftAllowanceAllSerials(const TokenId& tokenId,
                                                                    const AccountId& ownerAccountId,
                                                                    const AccountId& spenderAccountId);

  /**
   * Remove all allowances for all NFTs of a specific token ID for a spender.
   *
   * @param tokenId          The ID of the NFT tokens of which to revoke the allowance.
   * @param ownerAccountId   The ID of the account that is revoking the spending of its NFTs.
   * @param spenderAccountId The ID of the account that is no longer allowed to spend the owning account's NFTs.
   * @return A reference to this AccountAllowanceApproveTransaction object with the deleted NFT allowances.
   * @throws IllegalStateException If this AccountAllowanceApproveTransaction is frozen.
   */
  AccountAllowanceApproveTransaction& deleteNftAllowanceAllSerials(const TokenId& tokenId,
                                                                   const AccountId& ownerAccountId,
                                                                   const AccountId& spenderAccountId);

  /**
   * Get the list of Hbar allowance approvals added to this AccountAllowanceApproveTransaction.
   *
   * @return The list of Hbar allowance approvals added to this AccountAllowanceApproveTransaction.
   */
  [[nodiscard]] inline std::vector<HbarAllowance> getHbarApprovals() const { return mHbarAllowances; }

  /**
   * Get the list of fungible token allowance approvals added to this AccountAllowanceApproveTransaction.
   *
   * @return The list of fungible token allowance approvals added to this AccountAllowanceApproveTransaction.
   */
  [[nodiscard]] inline std::vector<TokenAllowance> getTokenApprovals() const { return mTokenAllowances; }

  /**
   * Get the list of NFT allowance approvals added to this AccountAllowanceApproveTransaction.
   *
   * @return The list of NFT allowance approvals added to this AccountAllowanceApproveTransaction.
   */
  [[nodiscard]] inline std::vector<TokenNftAllowance> getNftApprovals() const { return mNftAllowances; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this
   * AccountAllowanceApproveTransaction's data to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this AccountAllowanceApproveTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This AccountAllowanceApproveTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the AccountAllowanceApproveTransaction protobuf representation to the
   * Transaction protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this AccountAllowanceApproveTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a CryptoApproveAllowanceTransactionBody protobuf object from this AccountAllowanceApproveTransaction object.
   *
   * @return A pointer to a CryptoApproveAllowanceTransactionBody protobuf object filled with this
   *         AccountAllowanceApproveTransaction object's data.
   */
  [[nodiscard]] proto::CryptoApproveAllowanceTransactionBody* build() const;

  /**
   * The list of Hbar allowances to be approved.
   */
  std::vector<HbarAllowance> mHbarAllowances;

  /**
   * The list of fungible token allowances to be approved.
   */
  std::vector<TokenAllowance> mTokenAllowances;

  /**
   * The list of NFT allowances to be approved.
   */
  std::vector<TokenNftAllowance> mNftAllowances;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_ALLOWANCE_APPROVE_TRANSACTION_H_
// Filename: src/sdk/main/include/AccountAllowanceDeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_ALLOWANCE_DELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_ACCOUNT_ALLOWANCE_DELETE_TRANSACTION_H_

#include "TokenNftAllowance.h"
#include "Transaction.h"

#include <vector>

namespace proto
{
class CryptoDeleteAllowanceTransactionBody;
class TransactionBody;
}

namespace Hiero
{
class AccountId;
class NftId;
}

namespace Hiero
{
/**
 * A transaction called by the token owner to delete allowances for NFTs only. In order to delete an existing Hbar or
 * fungible token allowance the AccountAllowanceApproveTransaction API should be used with an amount of 0.
 *
 * The total number of NFT serial number deletions contained within the transaction body cannot exceed 20.
 */
class AccountAllowanceDeleteTransaction : public Transaction<AccountAllowanceDeleteTransaction>
{
public:
  AccountAllowanceDeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a CryptoDeleteAllowance transaction.
   */
  explicit AccountAllowanceDeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit AccountAllowanceDeleteTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Remove all NFT allowances from an account.
   *
   * @param nftId The ID of the NFT to remove as an allowance.
   * @param owner The ID of the account from which to remove the allowances.
   * @return A reference to this AccountAllowanceDeleteTransaction object with the added allowance removal.
   * @throws IllegalStateException If this AccountAllowanceDeleteTransaction is frozen.
   */
  AccountAllowanceDeleteTransaction& deleteAllTokenNftAllowances(const NftId& nftId, const AccountId& owner);

  /**
   * Get the list of a NFT allowance removals added to this AccountAllowanceDeleteTransaction.
   *
   * @return The list of a NFT allowance removals added to this AccountAllowanceDeleteTransaction.
   */
  [[nodiscard]] inline std::vector<TokenNftAllowance> getTokenNftAllowanceDeletions() const
  {
    return mNftAllowanceDeletions;
  }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this
   * AccountAllowanceDeleteTransaction's data to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this AccountAllowanceDeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This AccountAllowanceDeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the AccountAllowanceDeleteTransaction protobuf representation to the
   * Transaction protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this AccountAllowanceDeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a CryptoDeleteAllowanceTransactionBody protobuf object from this AccountAllowanceDeleteTransaction object.
   *
   * @return A pointer to a CryptoDeleteAllowanceTransactionBody protobuf object filled with this
   *         AccountAllowanceDeleteTransaction object's data.
   */
  [[nodiscard]] proto::CryptoDeleteAllowanceTransactionBody* build() const;

  /**
   * The list of NFT allowances to be deleted.
   */
  std::vector<TokenNftAllowance> mNftAllowanceDeletions;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_ALLOWANCE_DELETE_TRANSACTION_H_
// Filename: src/sdk/main/include/AccountBalance.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_BALANCE_H_
#define HIERO_SDK_CPP_ACCOUNT_BALANCE_H_

#include "Hbar.h"
#include "TokenId.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <unordered_map>
#include <vector>

namespace proto
{
class CryptoGetAccountBalanceResponse;
}

namespace Hiero
{
/**
 * Response from a Hiero network when the client sends an AccountBalanceQuery.
 */
class AccountBalance
{
public:
  /**
   * Construct an AccountBalance object from a CryptoGetAccountBalanceResponse protobuf object.
   *
   * @param proto The CryptoGetAccountBalance protobuf object from which to construct an AccountBalance object.
   * @return The constructed AccountBalance object.
   */
  [[nodiscard]] static AccountBalance fromProtobuf(const proto::CryptoGetAccountBalanceResponse& proto);

  /**
   * Construct an AccountBalance object from a byte array.
   *
   * @param bytes The byte array from which to construct an AccountBalance object.
   * @return The constructed AccountBalance object.
   */
  [[nodiscard]] static AccountBalance fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a CryptoGetAccountBalanceResponse protobuf object from this FeeSchedules object.
   *
   * @return A pointer to the created CryptoGetAccountBalanceResponse protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::CryptoGetAccountBalanceResponse> toProtobuf() const;

  /**
   * Construct a representative byte array from this AccountBalance object.
   *
   * @return The byte array representing this AccountBalance object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this AccountBalance object.
   *
   * @return The string representation of this AccountBalance object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this AccountBalance to an output stream.
   *
   * @param os      The output stream.
   * @param balance The AccountBalance to print.
   * @return The output stream with this AccountBalance written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const AccountBalance& balance);

  /**
   * The account or contract balance.
   */
  Hbar mBalance;

  /**
   * Map of tokens with associated values.
   */
  std::unordered_map<TokenId, uint64_t> mTokens;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_BALANCE_H_
// Filename: src/sdk/main/include/AccountBalanceQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_BALANCE_QUERY_H_
#define HIERO_SDK_CPP_ACCOUNT_BALANCE_QUERY_H_

#include "AccountId.h"
#include "ContractId.h"
#include "Query.h"

#include <optional>

namespace Hiero
{
class AccountBalance;
}

namespace Hiero
{
/**
 * Get the balance of a Hiero crypto-currency account. This returns only the balance, so it is a smaller and faster
 * reply than an AccountInfoQuery.
 *
 * This query is free.
 */
class AccountBalanceQuery : public Query<AccountBalanceQuery, AccountBalance>
{
public:
  /**
   * Set the ID of the account of which to request the balance. This is mutually exclusive with setContractId() and will
   * clear the contract ID if one is already set.
   *
   * @param accountId The ID of the desired account of which to request the balance.
   * @return A reference to this AccountBalanceQuery object with the newly-set account ID.
   */
  AccountBalanceQuery& setAccountId(const AccountId& accountId);

  /**
   * Set the ID of the contract of which to request the balance. This is mutually exclusive with setAccountId() and will
   * clear the account ID if one is already set.
   *
   * @param contractId The ID of the desired contract of which to request the balance.
   * @return A reference to this AccountBalanceQuery object with the newly-set contract ID.
   */
  AccountBalanceQuery& setContractId(const ContractId& contractId);

  /**
   * Get the ID of the account of which this query is currently configured to get the balance.
   *
   * @return The ID of the account for which this query is meant. Returns uninitialized if a value has not yet been set,
   *         or if a contract ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<AccountId> getAccountId() { return mAccountId; }

  /**
   * Get the ID of the contract of which this query is currently configured to get the balance.
   *
   * @return The ID of the contract for which this query is meant. Returns uninitialized if a value has not yet been
   *         set, or if an account ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<ContractId> getContractId() { return mContractId; }

private:
  /**
   * Derived from Executable. Construct an AccountBalance object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct an AccountBalance object.
   * @return An AccountBalance object filled with the Response protobuf object's data
   */
  [[nodiscard]] AccountBalance mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this AccountBalanceQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this AccountBalanceQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This AccountBalanceQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this AccountBalanceQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * Derived from Query. Does this AccountBalanceQuery require payment?
   *
   * @return \c FALSE, AccountBalanceQuery is free.
   */
  [[nodiscard]] inline bool isPaymentRequired() const override { return false; }

  /**
   * The ID of the account of which this query should get the balance.
   */
  std::optional<AccountId> mAccountId;

  /**
   * The ID of the contract of which this query should get the balance.
   */
  std::optional<ContractId> mContractId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_BALANCE_QUERY_H_
// Filename: src/sdk/main/include/AccountCreateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_CREATE_TRANSACTION_H_
#define HIERO_SDK_CPP_ACCOUNT_CREATE_TRANSACTION_H_

#include "AccountId.h"
#include "Defaults.h"
#include "ECDSAsecp256k1PrivateKey.h"
#include "EvmAddress.h"
#include "Hbar.h"
#include "Key.h"
#include "Transaction.h"

#include <chrono>
#include <memory>
#include <optional>
#include <string>
#include <string_view>

namespace proto
{
class CryptoCreateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * The transaction used to create a new account. After the account is created, the AccountID for it is in the receipt.
 * It can also be retrieved with a GetByKey query. Threshold values can be defined, and records are generated and stored
 * for 25 hours for any transfer that exceeds the thresholds. This account is charged for each record generated, so the
 * thresholds are useful for limiting record generation to happen only for large transactions.
 *
 * The mPublicKey field is the key used to sign transactions for this account. If the account has
 * mReceiverSignatureRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both
 * for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is
 * created, the payer account is charged enough Hbars so that the new account will not expire for the next
 * mAutoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to
 * renew for another mAutoRenewPeriod seconds. If it does not have enough Hbars to renew for that long, then the
 * remaining Hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires,
 * then it is deleted. This transaction must be signed by the payer account. If the mAutoRenewPeriod field is set, the
 * key of the referenced account must sign.
 *
 * An account must be created in a particular realm. If the realmID is left null, then a new realm will be created with
 * the given admin key. If a new realm has a null adminKey, then anyone can create/modify/delete entities in that realm.
 * But if an admin key is given, then any transaction to create/modify/delete an entity in that realm must be signed by
 * that key, though anyone can still call functions on smart contract instances that exist in that realm. A realm ceases
 * to exist when everything within it has expired and no longer exists.
 *
 * The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0 and realm 0, with a
 * null key. Future versions of the API will support multiple realms and multiple shards.
 */
class AccountCreateTransaction : public Transaction<AccountCreateTransaction>
{
public:
  /**
   * Default constructor. Sets the maximum transaction fee to 5 Hbars.
   */
  AccountCreateTransaction();

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a CryptoCreateAccount transaction.
   */
  explicit AccountCreateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit AccountCreateTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * @deprecated This method is deprecated and may be removed in a future release.
   * Use `setKeyWithoutAlias()` instead.
   *
   * Set the key for the new account. The key that must sign each transfer out of the account. If
   * mReceiverSignatureRequired is true, then it must also sign any transfer into the account.
   *
   * @param key The desired key for the new account.
   * @return A reference to this AccountCreateTransaction object with the newly-set key.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  [[deprecated("Use setKeyWithoutAlias() instead")]] AccountCreateTransaction& setKey(const std::shared_ptr<Key>& key);

  /**
   * Set an ECDSA private key, derive its EVM address in the background, and set both the key and alias.
   * This function essentially combines setKey and setAlias in one call.
   *
   * @param ecdsaKey The ECDSA private key to be set.
   * @return A reference to this AccountCreateTransaction object with the newly-set key and alias.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen or the provided key is invalid.
   * @throws invalid_argument If key is null.
   */
  AccountCreateTransaction& setECDSAKeyWithAlias(const std::shared_ptr<ECDSAsecp256k1PrivateKey>& ecdsaKey);

  /**
   * Set the account key and a separate ECDSA key that the EVM address is derived from.
   * A user must sign the transaction with both keys for this flow to be successful.
   *
   * @param key The primary key for the account.
   * @param ecdsaKey The ECDSA private key from which the alias (EVM address) is derived.
   * @return A reference to this AccountCreateTransaction object with the newly-set keys and alias.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen or the provided key is invalid.
   * @throws invalid_argument If key is null.
   */
  AccountCreateTransaction& setKeyWithAlias(const std::shared_ptr<Key>& key,
                                            const std::shared_ptr<ECDSAsecp256k1PrivateKey>& ecdsaKey);

  /**
   * Set the key that must sign each transfer out of the account. If receiverSignatureRequired is true, then it
   * must also sign any transfer into the account.
   *
   * @param key The desired key for the new account.
   * @return A reference to this AccountCreateTransaction object with the newly-set key.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   * @throws invalid_argument If key is null.
   */
  AccountCreateTransaction& setKeyWithoutAlias(const std::shared_ptr<Key>& key);

  /**
   * Set the initial amount to transfer into the new account from the paying account.
   *
   * @param initialBalance The desired balance to transfer into the new account.
   * @return A reference to this AccountCreateTransaction object with the newly-set initial balance.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  AccountCreateTransaction& setInitialBalance(const Hbar& initialBalance);

  /**
   * Set the new account's transfer receiver signature policy. This requires the signature of the new account's key.
   *
   * @param receiveSignatureRequired \c TRUE to require the new account to sign any Hbar transfer transactions that
   *                                 involve transferring Hbars into itself, otherwise \c FALSE.
   * @return A reference to this AccountCreateTransaction object with the newly-set receiver signature policy.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  AccountCreateTransaction& setReceiverSignatureRequired(bool receiveSignatureRequired);

  /**
   * Set the auto renew period for the new account. A Hiero account is charged to extend its expiration date every
   * renew period. If it doesn't have enough balance, it extends as long as possible. If the balance is zero when it
   * expires, then the account is deleted.
   *
   * @param autoRenewPeriod The desired auto renew period for the new account.
   * @return A reference to this AccountCreateTransaction object with the newly-set auto renew period.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  AccountCreateTransaction& setAutoRenewPeriod(const std::chrono::system_clock::duration& autoRenewPeriod);

  /**
   * Set a memo for the new account.
   *
   * @param memo The desired memo for the new account.
   * @return A reference to this AccountCreateTransaction object with the newly-set memo.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  AccountCreateTransaction& setAccountMemo(std::string_view memo);

  /**
   * Set the maximum automatic token associations the new account can have.
   *
   * @param associations The desired maximum amount of token associations for the new account. A value of -1 means
   *                     the new account can have unlimited automatic token associations.
   * @return A reference to this AccountCreateTransaction object with the newly-set maximum automatic token
   *         associations.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  AccountCreateTransaction& setMaxAutomaticTokenAssociations(int32_t associations);

  /**
   * Set the account to which the new account should stake. This is mutually exclusive with mStakedNodeId, and will
   * reset the value of the mStakedNodeId if it is set.
   *
   * @param stakedAccountId The ID of the desired account to which the new account will stake.
   * @return A reference to this AccountCreateTransaction object with the newly-set staked account ID.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  AccountCreateTransaction& setStakedAccountId(const AccountId& stakedAccountId);

  /**
   * Set the node to which the new account should stake. This is mutually exclusive with mStakedAccountId, and will
   * reset the value of the mStakedAccountId if it is set.
   *
   * @param stakedNodeId The ID of the desired node to which the new account will stake.
   * @return A reference to this AccountCreateTransaction object with the newly-set staked node ID.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  AccountCreateTransaction& setStakedNodeId(const uint64_t& stakedNodeId);

  /**
   * Set the staking reward reception policy for the new account.
   *
   * @param declineReward \c TRUE if the new account should decline receiving staking rewards, otherwise \c FALSE.
   * @return A reference to this AccountCreateTransaction object with the newly-set staking rewards reception policy.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  AccountCreateTransaction& setDeclineStakingReward(bool declineReward);

  /**
   * Set the EOA 20-byte address to create for the new account. This EVM address may be either the encoded form of the
   * <shard>.<realm>.<num>, or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
   *
   * @param address The desired EVM address to be used as the account's alias.
   * @return A reference to this AccountCreateTransaction object with the newly-set EVM address account alias.
   * @throws IllegalStateException If this AccountCreateTransaction is frozen.
   */
  AccountCreateTransaction& setAlias(const EvmAddress& address);

  /**
   * Get the key to be used for the new account.
   *
   * @return A pointer to the key to be used for the new account. Nullptr if the key has not yet been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getKey() const { return mKey; }

  /**
   * Get the initial balance to be transferred into the new account upon creation (from the paying account).
   *
   * @return The initial balance to be transferred into the new account upon creation (from the paying account).
   */
  [[nodiscard]] inline Hbar getInitialBalance() const { return mInitialBalance; }

  /**
   * Get the Hbar transfer receiver signature policy to be used by the new account.
   *
   * @return \c TRUE if the new account should be required to sign all incoming Hbar transfers, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool getReceiverSignatureRequired() const { return mReceiverSignatureRequired; }

  /**
   * Get the auto renew period for the new account.
   *
   * @return The auto renew period for the new account.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getAutoRenewPeriod() const { return mAutoRenewPeriod; }

  /**
   * Get the desired memo for the new account.
   *
   * @return The desired memo for the new account.
   */
  [[nodiscard]] inline std::string getAccountMemo() const { return mAccountMemo; }

  /**
   * Get the maximum automatic token associations for the new account.
   *
   * @return The maximum automatic token associations for the new account.
   */
  [[nodiscard]] inline int32_t getMaxAutomaticTokenAssociations() const { return mMaxAutomaticTokenAssociations; }

  /**
   * Get the ID of the account to which the new account will stake.
   *
   * @return The ID of the desired account to which the new account will stake. Returns uninitialized if a value has not
   *         yet been set, or if a staked node ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<AccountId> getStakedAccountId() const { return mStakedAccountId; }

  /**
   * Get the ID of the desired node to which the new account will stake.
   *
   * @return The ID of the desired node to which the new account will stake. Returns uninitialized if a value has not
   *         yet been set, or if a staked account ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<uint64_t> getStakedNodeId() const { return mStakedNodeId; }

  /**
   * Get the staking rewards reception policy for the new account.
   *
   * @return \c TRUE if the new account should decline from receiving staking rewards, otherwise \c FALSE
   */
  [[nodiscard]] inline bool getDeclineStakingReward() const { return mDeclineStakingReward; }

  /**
   * Get the EVM address of the new account.
   *
   * @return The EVM address of the new account. Returns uninitialized if a value has not yet been set.
   */
  [[nodiscard]] inline std::optional<EvmAddress> getAlias() const { return mAlias; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this AccountCreateTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this AccountCreateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This AccountCreateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the AccountCreateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this AccountCreateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a CryptoCreateTransactionBody protobuf object from this AccountCreateTransaction object.
   *
   * @return A pointer to a CryptoCreateTransactionBody protobuf object filled with this AccountCreateTransaction
   *         object's data.
   */
  [[nodiscard]] proto::CryptoCreateTransactionBody* build() const;

  /**
   * The key that must sign each transfer out of the account. If mReceiverSignatureRequired is \c TRUE, then it must
   * also sign any transfer into the account.
   */
  std::shared_ptr<Key> mKey = nullptr;

  /**
   * The initial amount to transfer into the new account.
   */
  Hbar mInitialBalance = Hbar(0LL);

  /**
   * If \c TRUE, the new account's key must sign any transaction being deposited into it (in addition to all
   * withdrawals).
   */
  bool mReceiverSignatureRequired = false;

  /**
   * A Hiero account is charged to extend its expiration date every renew period. If it doesn't have enough balance, it
   * extends as long as possible. If the balance is zero when it expires, then the account is deleted. Defaults to 90
   * days (2160 hours).
   */
  std::chrono::system_clock::duration mAutoRenewPeriod = DEFAULT_AUTO_RENEW_PERIOD;

  /**
   * The memo to be associated with the account (UTF-8 encoding max 100 bytes).
   */
  std::string mAccountMemo;

  /**
   * The maximum number of tokens with which the new account can be implicitly associated. Only allows values up to a
   * maximum value of 5000. A value of -1 means the new account can have unlimited automatic token associations.
   */
  int32_t mMaxAutomaticTokenAssociations = 0;

  /**
   * The ID of the account to which the new account will be staked. Mutually exclusive with mStakedNodeId.
   */
  std::optional<AccountId> mStakedAccountId;

  /**
   * The ID of the node to which the new account will be staked. Mutually exclusive with mStakedAccountId.
   */
  std::optional<uint64_t> mStakedNodeId;

  /**
   * If \c TRUE, the new account will decline receiving staking rewards.
   */
  bool mDeclineStakingReward = false;

  /**
   * The EOA 20-byte address to create that is derived from the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
   */
  std::optional<EvmAddress> mAlias;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_CREATE_TRANSACTION_H_
// Filename: src/sdk/main/include/AccountDeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_DELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_ACCOUNT_DELETE_TRANSACTION_H_

#include "AccountId.h"
#include "Transaction.h"

#include <optional>

namespace proto
{
class CryptoDeleteTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Mark an account as deleted, moving all its current hbars to another account. It will remain in the ledger, marked as
 * deleted, until it expires. Transfers into it a deleted account fail. But a deleted account can still have its
 * expiration extended in the normal way.
 */
class AccountDeleteTransaction : public Transaction<AccountDeleteTransaction>
{
public:
  AccountDeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a CryptoDeleteAccount transaction.
   */
  explicit AccountDeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit AccountDeleteTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Sets the ID of the account to delete.
   *
   * @param accountId The ID of the account to delete.
   * @return A reference to this AccountDeleteTransaction object with the newly-set account ID.
   * @throws IllegalStateException If this AccountDeleteTransaction is frozen.
   */
  AccountDeleteTransaction& setDeleteAccountId(const AccountId& accountId);

  /**
   * Set the ID of the account to which to transfer the deleted account's remaining Hbars.
   *
   * @param accountId The ID of the account to which to transfer the deleted account's remaining Hbars.
   * @return A reference to this AccountDeleteTransaction object with the newly-set transfer account ID.
   * @throws IllegalStateException If this AccountDeleteTransaction is frozen.
   */
  AccountDeleteTransaction& setTransferAccountId(const AccountId& accountId);

  /**
   * Get the ID of the account this AccountDeleteTransaction is currently configured to delete.
   *
   * @return The ID of the account this AccountDeleteTransaction is currently configured to delete. Uninitialized if no
   *         account ID has been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getDeleteAccountId() const { return mDeleteAccountId; }

  /**
   * Get the ID of the account to which this AccountDeleteTransaction is currently configured to transfer the deleted
   * account's remaining Hbars.
   *
   * @return The ID of the account to which this AccountDeleteTransaction is currently configured to transfer the
   *         deleted account's remaining Hbars. Uninitialized if no account ID has been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getTransferAccountId() const { return mTransferAccountId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this AccountDeleteTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this AccountDeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This AccountDeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the AccountDeleteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this AccountDeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a CryptoDeleteTransactionBody protobuf object from this AccountDeleteTransaction object.
   *
   * @return A pointer to a CryptoDeleteTransactionBody protobuf object filled with this AccountDeleteTransaction
   *         object's data.
   */
  [[nodiscard]] proto::CryptoDeleteTransactionBody* build() const;

  /**
   * The ID of the account to delete.
   */
  std::optional<AccountId> mDeleteAccountId;

  /**
   * The ID of the account which will receive all the remaining Hbars from the deleted account.
   */
  std::optional<AccountId> mTransferAccountId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_DELETE_TRANSACTION_H_
// Filename: src/sdk/main/include/AccountId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_ID_H_
#define HIERO_SDK_CPP_ACCOUNT_ID_H_

#include "EvmAddress.h"
#include "PublicKey.h"

#include <cstddef>
#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class AccountID;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * The ID for a crypto-currency account on Hiero.
 */
class AccountId
{
public:
  AccountId() = default;

  /**
   * Construct with an account number.
   *
   * @param num The account number.
   */
  explicit AccountId(uint64_t num);

  /**
   * Construct with a PublicKey alias.
   *
   * @param alias The PublicKey alias.
   */
  explicit AccountId(const std::shared_ptr<PublicKey>& alias);

  /**
   * Construct with an EVM address alias.
   *
   * @param address The EVM address alias.
   */
  explicit AccountId(const EvmAddress& address);

  /**
   * Construct with a shard, realm, an account number, and optionally a checksum.
   *
   * @param shard    The shard number.
   * @param realm    The realm number.
   * @param num      The account number.
   * @param checksum The checksum.
   */
  explicit AccountId(uint64_t shard, uint64_t realm, uint64_t num, std::string_view checksum = "");

  /**
   * Construct with shard and realm numbers, and a PublicKey alias.
   *
   * @param shard The shard number.
   * @param realm The realm number.
   * @param alias The PublicKey alias.
   */
  explicit AccountId(uint64_t shard, uint64_t realm, const std::shared_ptr<PublicKey>& alias);

  /**
   * Construct with shard and realm numbers, and an EVM address alias.
   *
   * @param shard   The shard number.
   * @param realm   The realm number.
   * @param address The EVM address alias.
   */
  explicit AccountId(uint64_t shard, uint64_t realm, const EvmAddress& address);

  /**
   * Compare this AccountId to another AccountId and determine if they represent the same account.
   *
   * @param other The other AccountId with which to compare this AccountId.
   * @return \c TRUE if this AccountId is the same as the input AccountId, otherwise \c FALSE.
   */
  bool operator==(const AccountId& other) const;

  /**
   * Construct an AccountId object from a string of the form "<shard>.<realm>.<num>". <num> can be the account number,
   * the stringified PublicKey alias (DER-encoded), or the stringified EVM address.
   *
   * @param id The account ID string from which to construct.
   * @return The constructed AccountId object.
   * @throws std::invalid_argument If the input string is malformed or the type of <num> cannot be determined.
   */
  [[nodiscard]] static AccountId fromString(std::string_view id);

  /**
   * Construct an AccountId object from a string that represents an EvmAddress and, optionally, a shard and realm
   * number.
   *
   * @param evmAddress The string that represents an EvmAddress.
   * @param shard      The shard number.
   * @param realm      The realm number.
   * @return The constructed AccountId object.
   * @throws std::invalid_argument If the input string is malformed.
   * @throws OpenSSLException If OpenSSL is unable to convert the string to a byte array.
   */
  [[nodiscard]] static AccountId fromEvmAddress(std::string_view evmAddress,
                                                uint64_t shard = 0ULL,
                                                uint64_t realm = 0ULL);

  /**
   * Construct an AccountId object from an EvmAddress object and, optionally, a shard and realm number.
   *
   * @param evmAddress The EvmAddress from which to construct an AccountId.
   * @param shard      The shard number.
   * @param realm      The realm number.
   * @return The constructed AccountId object.
   */
  [[nodiscard]] static AccountId fromEvmAddress(const EvmAddress& evmAddress,
                                                uint64_t shard = 0ULL,
                                                uint64_t realm = 0ULL);

  /**
   * Construct an AccountId from a Solidity address.
   *
   * @param address The Solidity address from which to create an AccountId, in a string.
   * @return The constructed AccountId object.
   * @throws std::invalid_argument If a Solidity address cannot be realized from the input string.
   */
  [[nodiscard]] static AccountId fromSolidityAddress(std::string_view address);

  /**
   * Construct an AccountId object from an AccountID protobuf object.
   *
   * @param proto The AccountID protobuf object from which to create an AccountId object.
   * @return The constructed AccountId object.
   */
  [[nodiscard]] static AccountId fromProtobuf(const proto::AccountID& proto);

  /**
   * Construct an AccountId object from a representative byte array.
   *
   * @param bytes The byte array from which to construct an AccountId object.
   * @return The constructed AccountId object.
   */
  [[nodiscard]] static AccountId fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Verify the checksum of this AccountId using the input Client's network. Does nothing if this AccountId does not use
   * an account number (i.e. it contains a PublicKey or EvmAddress alias).
   *
   * @param client The Client with which to validate this AccountId's checksum.
   * @throws BadEntityException If the checksum of this AccountId is invalid.
   */
  void validateChecksum(const Client& client) const;

  /**
   * Construct an AccountID protobuf object from this AccountId object.
   *
   * @return A pointer to the created AccountID protobuf object filled with this AccountId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::AccountID> toProtobuf() const;

  /**
   * Get the Solidity address representation of this AccountId (Long-Zero address form).
   *
   * @return The Solidity address representation of this AccountId.
   * @throws IllegalStateException If this AccountId contains an alias.
   */
  [[nodiscard]] std::string toSolidityAddress() const;

  /**
   * Populates the EVM address for an Account using the Mirror Node. This function fetches the EVM address for an
   * Account from the Mirror Node.
   *
   * User Note: This Function requires a 3 second sleep if running on testnet environment as the MirrorNode does not
   * update on time for the MirrorNode request sent to it.
   *
   * @param client The Client object used for network access.
   * @return A reference to the modified AccountId object.
   * @throws IllegalStateException if mAccountNum is empty or if the account does not exist in the Mirror Network.
   */
  AccountId& populateAccountEvmAddress(const Client& client);

  /**
   * Get the string representation of this AccountId object.
   *
   * @return The string representation of this AccountId.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Get the string representation of this AccountId object with the checksum.
   *
   * @param client The Client with which to generate the checksum.
   * @return The string representation of this AccountId object with the checksum.
   * @throws IllegalStateException If this AccountId contains an alias.
   */
  [[nodiscard]] std::string toStringWithChecksum([[maybe_unused]] const Client& client) const;

  /**
   * Get a byte array representation of this AccountId object.
   *
   * @return A byte array representation of this AccountId object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Get the checksum of this AccountId.
   *
   * @return The checksum of this AccountId.
   */
  [[nodiscard]] inline std::string getChecksum() const { return mChecksum; }

  /**
   * The shard number.
   */
  uint64_t mShardNum = 0ULL;

  /**
   * The realm number.
   */
  uint64_t mRealmNum = 0ULL;

  /**
   * The account ID number.
   */
  std::optional<uint64_t> mAccountNum;

  /**
   * The public key to be used as the account's alias. Currently only primitive key bytes are supported as an alias
   * (ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)
   *
   * At most one account can ever have a given alias and it is used for account creation if it was automatically created
   * using a crypto transfer. It will be nullptr if an account is created normally. It is immutable once it is set for
   * an account.
   *
   * If a transaction auto-creates the account, any further transfers to that alias will simply be deposited in that
   * account, without creating anything, and with no creation fee being charged.
   */
  std::shared_ptr<PublicKey> mPublicKeyAlias = nullptr;

  /**
   * The ethereum account 20-byte EVM address to be used initially in place of the public key bytes. This EVM address
   * may be either the encoded form of the shard.realm.num or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
   *
   * If a transaction lazily-creates this account, a subsequent transaction will be required containing the public key
   * bytes that map to the EVM address bytes. Lazy account creates will only support the keccak-256 hash of a
   * ECDSA_SECP256K1 primitive key form.
   */
  std::optional<EvmAddress> mEvmAddressAlias;

private:
  /**
   * The checksum of this AccountId.
   */
  mutable std::string mChecksum;
};

} // namespace Hiero

namespace std
{
template<>
struct hash<Hiero::AccountId>
{
  /**
   * Operator override to enable use of AccountId as map key.
   */
  size_t operator()(const Hiero::AccountId& id) const { return hash<string>()(id.toString()); }
};

template<>
struct less<Hiero::AccountId>
{
  /**
   * Operator override to enable use of AccountId in a std::map, which requires fair ordering.
   */
  bool operator()(const Hiero::AccountId& lhs, const Hiero::AccountId& rhs) const
  {
    return lhs.toString() < rhs.toString();
  }
};

} // namespace std

#endif // HIERO_SDK_CPP_ACCOUNT_ID_H_
// Filename: src/sdk/main/include/AccountInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_INFO_H_
#define HIERO_SDK_CPP_ACCOUNT_INFO_H_

#include "AccountId.h"
#include "EvmAddress.h"
#include "Hbar.h"
#include "Key.h"
#include "LedgerId.h"
#include "StakingInfo.h"
#include "TokenId.h"
#include "TokenRelationship.h"

#include <chrono>
#include <cstddef>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

namespace proto
{
class CryptoGetInfoResponse_AccountInfo;
}

namespace Hiero
{
/**
 * Response from a Hiero network when the client sends an AccountInfoQuery.
 */
class AccountInfo
{
public:
  /**
   * Construct an AccountInfo object from a CryptoGetInfoResponse_AccountInfo protobuf object.
   *
   * @param proto The CryptoGetInfoResponse_AccountInfo protobuf object from which to construct an AccountInfo object.
   * @return The constructed AccountInfo object.
   */
  [[nodiscard]] static AccountInfo fromProtobuf(const proto::CryptoGetInfoResponse_AccountInfo& proto);

  /**
   * Construct an AccountInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct an AccountInfo object.
   * @return The constructed AccountInfo object.
   */
  [[nodiscard]] static AccountInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a CryptoGetInfoResponse_AccountInfo protobuf object from this AccountInfo object.
   *
   * @return A pointer to the created CryptoGetInfoResponse_AccountInfo protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::CryptoGetInfoResponse_AccountInfo> toProtobuf() const;

  /**
   * Construct a representative byte array from this AccountInfo object.
   *
   * @return The byte array representing this AccountInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this AccountInfo object.
   *
   * @return The string representation of this AccountInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this AccountInfo to an output stream.
   *
   * @param os   The output stream.
   * @param info The AccountInfo to print.
   * @return The output stream with this AccountInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const AccountInfo& info);

  /**
   * The ID of the queried account.
   */
  AccountId mAccountId;

  /**
   * The contract account ID comprising of both the contract instance and the cryptocurrency account owned by the
   * contract instance, in the format used by Solidity.
   */
  std::string mContractAccountId;

  /**
   * Is the queried account deleted or not? If \c TRUE, then the account has been deleted, it will disappear when it
   * expires, and all transactions for it will fail except the transaction to extend its expiration date.
   */
  bool mIsDeleted = false;

  /**
   * The total amount of Hbar proxy staked to the queried account.
   */
  Hbar mProxyReceived = Hbar(0LL);

  /**
   * The key for the account, which must sign in order to transfer out, or to modify the account in any way other than
   * extending its expiration date.
   */
  std::shared_ptr<Key> mKey = nullptr;

  /**
   * The current balance of the queried account.
   */
  Hbar mBalance = Hbar(0LL);

  /**
   * If \c TRUE, the queried account's key must sign any transaction being deposited into it (in addition to all
   * withdrawals).
   */
  bool mReceiverSignatureRequired = false;

  /**
   * The time at which the queried account will expire.
   */
  std::chrono::system_clock::time_point mExpirationTime = std::chrono::system_clock::now();

  /**
   * The duration of time the queried account uses to automatically extend its expiration period. It it doesn't have
   * enough balance, it extends as long as possible. If it is empty when it expires, then it is deleted.
   */
  std::chrono::system_clock::duration mAutoRenewPeriod;

  /**
   * The queried account's memo.
   */
  std::string mMemo;

  /**
   * The number of NFTs owned by the queried account.
   */
  uint64_t mOwnedNfts = 0ULL;

  /**
   * The maximum number of tokens with which the queried account can be associated.
   */
  int32_t mMaxAutomaticTokenAssociations = 0;

  /**
   * The PublicKey alias of the queried account.
   */
  std::shared_ptr<PublicKey> mPublicKeyAlias = nullptr;

  /**
   * The EVM address alias of the queried account.
   */
  std::optional<EvmAddress> mEvmAddressAlias;

  /**
   * The ID of the ledger from which this AccountInfo was received.
   */
  LedgerId mLedgerId;

  /**
   * The staking metadata for the queried account.
   */
  StakingInfo mStakingInfo;

  /**
   * The token relationships mappings for the queried account.
   */
  std::unordered_map<TokenId, TokenRelationship> mTokenRelationships;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_INFO_H_
// Filename: src/sdk/main/include/AccountInfoQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_INFO_QUERY_H_
#define HIERO_SDK_CPP_ACCOUNT_INFO_QUERY_H_

#include "AccountId.h"
#include "Query.h"

namespace Hiero
{
class AccountInfo;
class TransactionRecord;
}

namespace Hiero
{
/**
 * A query that returns the current state of the account. This query does not include the list of records associated
 * with the account. Anyone on the network can request account info for a given account. Queries do not change the state
 * of the account or require network consensus. The information is returned from a single node processing the query.
 */
class AccountInfoQuery : public Query<AccountInfoQuery, AccountInfo>
{
public:
  /**
   * Set the ID of the account of which to request the info.
   *
   * @param accountId The ID of the desired account of which to request the info.
   * @return A reference to this AccountInfoQuery object with the newly-set account ID.
   */
  AccountInfoQuery& setAccountId(const AccountId& accountId);

  /**
   * Get the ID of the account of which this query is currently configured to get the info.
   *
   * @return The ID of the account for which this query is meant.
   */
  [[nodiscard]] inline AccountId getAccountId() const { return mAccountId; }

private:
  /**
   * Derived from Executable. Construct an AccountInfo object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct an AccountInfo object.
   * @return An AccountInfo object filled with the Response protobuf object's data
   */
  [[nodiscard]] AccountInfo mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this AccountInfoQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this AccountInfoQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This AccountInfoQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this AccountInfoQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the account of which this query should get the info.
   */
  AccountId mAccountId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_INFO_QUERY_H_
// Filename: src/sdk/main/include/AccountRecords.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_RECORDS_H_
#define HIERO_SDK_CPP_ACCOUNT_RECORDS_H_

#include "AccountId.h"
#include "TransactionRecord.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class CryptoGetAccountRecordsResponse;
}

namespace Hiero
{
/**
 * Response from a Hiero network when the client sends an AccountRecordsQuery.
 */
class AccountRecords
{
public:
  /**
   * Construct an AccountRecords object from a CryptoGetAccountRecordsResponse protobuf object.
   *
   * @param proto The CryptoGetAccountRecordsResponse protobuf object from which to construct an AccountRecords object.
   * @return The constructed AccountRecords object.
   */
  [[nodiscard]] static AccountRecords fromProtobuf(const proto::CryptoGetAccountRecordsResponse& proto);

  /**
   * Construct an AccountRecords object from a byte array.
   *
   * @param bytes The byte array from which to construct an AccountRecords object.
   * @return The constructed AccountRecords object.
   */
  [[nodiscard]] static AccountRecords fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a CryptoGetAccountRecordsResponse protobuf object from this AccountRecords object.
   *
   * @return A pointer to the created CryptoGetAccountRecordsResponse protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::CryptoGetAccountRecordsResponse> toProtobuf() const;

  /**
   * Construct a representative byte array from this AccountRecords object.
   *
   * @return The byte array representing this AccountRecords object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this AccountRecords object.
   *
   * @return The string representation of this AccountRecords object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this AccountRecords to an output stream.
   *
   * @param os      The output stream.
   * @param records The AccountRecords to print.
   * @return The output stream with this AccountRecords written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const AccountRecords& records);

  /**
   * The ID of the queried account.
   */
  AccountId mAccountId;

  /**
   * The list of TransactionRecords for the queried account.
   */
  std::vector<TransactionRecord> mRecords;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_RECORDS_H_
// Filename: src/sdk/main/include/AccountRecordsQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_RECORDS_QUERY_H_
#define HIERO_SDK_CPP_ACCOUNT_RECORDS_QUERY_H_

#include "AccountId.h"
#include "Query.h"

#include <vector>

namespace Hiero
{
class AccountRecords;
class TransactionRecord;
}

namespace Hiero
{
/**
 * Get all the records for an account for any transfers into it and out of it, that were above the threshold, during the
 * last 25 hours.
 */
class AccountRecordsQuery : public Query<AccountRecordsQuery, AccountRecords>
{
public:
  /**
   * Set the ID of the account of which to request the records.
   *
   * @param accountId The ID of the desired account of which to request the records.
   * @return A reference to this AccountRecordsQuery object with the newly-set account ID.
   */
  AccountRecordsQuery& setAccountId(const AccountId& accountId);

  /**
   * Get the ID of the account of which this query is currently configured to get the records.
   *
   * @return The ID of the account for which this query is meant.
   */
  [[nodiscard]] inline AccountId getAccountId() const { return mAccountId; }

private:
  /**
   * Derived from Executable. Construct an AccountRecords object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct an AccountRecords object.
   * @return An AccountRecords object filled with the Response protobuf object's data
   */
  [[nodiscard]] AccountRecords mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this AccountRecordsQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this AccountRecordsQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This AccountRecordsQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this AccountRecordsQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the account of which this query should get the records.
   */
  AccountId mAccountId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_RECORDS_QUERY_H_
// Filename: src/sdk/main/include/AccountUpdateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ACCOUNT_UPDATE_TRANSACTION_H_
#define HIERO_SDK_CPP_ACCOUNT_UPDATE_TRANSACTION_H_

#include "AccountId.h"
#include "PublicKey.h"
#include "Transaction.h"

#include <chrono>
#include <memory>
#include <string>

namespace proto
{
class CryptoUpdateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Change properties for the given account. Any null field is ignored (left unchanged). This transaction must be signed
 * by the existing key for this account. If the transaction is changing the key field, then the transaction must be
 * signed by both the old key (from before the change) and the new key. The old key must sign for security. The new key
 * must sign as a safeguard to avoid accidentally changing to an invalid key, and then having no way to recover. If the
 * update transaction sets the <tt>auto_renew_account</tt> field to anything other than the sentinel <tt>0.0.0</tt>, the
 * key of the referenced account must sign.
 */
class AccountUpdateTransaction : public Transaction<AccountUpdateTransaction>
{
public:
  AccountUpdateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a CryptoUpdate transaction.
   */
  explicit AccountUpdateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit AccountUpdateTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the account to update.
   *
   * @param accountId The ID of the account this transaction should update.
   * @return A reference to this AccountUpdateTransaction object with the newly-set account ID.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set a new key for the account. The key must sign each transfer out of the account. If mReceiverSignatureRequired is
   * true, then it must also sign any transfer into the account.
   *
   * @param publicKey The desired new key for the account.
   * @return A reference to this AccountUpdateTransaction object with the newly-set key.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setKey(const std::shared_ptr<Key>& key);

  /**
   * Set a new transfer receiver signature policy for the account.
   *
   * @param receiveSignatureRequired \c TRUE to require the account to now sign any Hbar transfer transactions that
   *                                 involve transferring Hbars into itself, otherwise \c FALSE.
   * @return A reference to this AccountUpdateTransaction object with the newly-set receiver signature policy.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setReceiverSignatureRequired(bool receiveSignatureRequired);

  /**
   * Set a new auto renew period for the account. A Hiero account is charged to extend its expiration date every
   * renew period. If it doesn't have enough balance, it extends as long as possible. If the balance is zero when it
   * expires, then the account is deleted.
   *
   * @param autoRenewPeriod The desired new auto renew period for the account.
   * @return A reference to this AccountUpdateTransaction object with the newly-set auto renew period.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setAutoRenewPeriod(const std::chrono::system_clock::duration& autoRenewPeriod);

  /**
   * Set a new expiration time for the account.
   *
   * @param expiration The desired new expiration time for the account.
   * @return A reference to this AccountUpdateTransaction object with the newly-set expiration time.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setExpirationTime(const std::chrono::system_clock::time_point& expiration);

  /**
   * Set a new memo for the account.
   *
   * @param memo The desired new memo for the account.
   * @return A reference to this AccountUpdateTransaction object with the newly-set memo.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setAccountMemo(std::string_view memo);

  /**
   * Clear the memo for the account.
   *
   * @return A reference to this AccountUpdateTransaction object with the newly-cleared memo.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& clearAccountMemo();

  /**
   * Set the new maximum automatic token associations the account can have.
   *
   * @param associations The desired new maximum amount of token associations for the account.
   * @return A reference to this AccountUpdateTransaction object with the newly-set maximum automatic token
   *         associations.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setMaxAutomaticTokenAssociations(int32_t associations);

  /**
   * Set the new account to which the account should stake. This is mutually exclusive with mStakedNodeId, and will
   * reset the value of the mStakedNodeId if it is set.
   *
   * @param stakedAccountId The ID of the desired new account to which the account will stake.
   * @return A reference to this AccountUpdateTransaction object with the newly-set staked account ID.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setStakedAccountId(const AccountId& stakedAccountId);

  /**
   * Clear the account to which this account should stake.
   *
   * @return A reference to this AccountUpdateTransaction object with the newly-cleared staked account ID.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& clearStakedAccountId();

  /**
   * Set the new node to which the account should stake. This is mutually exclusive with mStakedAccountId, and will
   * reset the value of the mStakedAccountId if it is set.
   *
   * @param stakedNodeId The ID of the desired new node to which the account will stake.
   * @return A reference to this AccountUpdateTransaction object with the newly-set staked node ID.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setStakedNodeId(const uint64_t& stakedNodeId);

  /**
   * Clear the node to which this account should stake.
   *
   * @return A reference to this AccountUpdateTransaction object with the newly-cleared staked node ID.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& clearStakedNodeId();

  /**
   * Set a new staking reward reception policy for the account.
   *
   * @param declineReward \c TRUE if the account should decline receiving staking rewards, otherwise \c FALSE.
   * @return A reference to this AccountUpdateTransaction object with the newly-set staking rewards reception policy.
   * @throws IllegalStateException If this AccountUpdateTransaction is frozen.
   */
  AccountUpdateTransaction& setDeclineStakingReward(bool declineReward);

  /**
   * Get the ID of the account to update.
   *
   * @return The ID of the account to update.
   */
  [[nodiscard]] inline AccountId getAccountId() const { return mAccountId; }

  /**
   * Get the new public key to be used for the account.
   *
   * @return A pointer to the new public key to be used for the account. Nullptr if the key has not yet been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getKey() const { return mKey; }

  /**
   * Get the new Hbar transfer receiver signature policy to be used by the account.
   *
   * @return \c TRUE if the new account should be required to sign all incoming Hbar transfers, otherwise \c FALSE.
   */
  [[nodiscard]] inline std::optional<bool> getReceiverSignatureRequired() const { return mReceiverSignatureRequired; }

  /**
   * Get the new auto renew period for the account.
   *
   * @return The new auto renew period for the new account.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::duration> getAutoRenewPeriod() const
  {
    return mAutoRenewPeriod;
  }

  /**
   * Get the new expiration time for the account.
   *
   * @return The new expiration time for the account.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::time_point> getExpirationTime() const
  {
    return mExpirationTime;
  }

  /**
   * Get the new memo for the account.
   *
   * @return The new memo for the account.
   */
  [[nodiscard]] inline std::optional<std::string> getAccountMemo() const { return mAccountMemo; }

  /**
   * Get the new maximum automatic token associations for the account.
   *
   * @return The new maximum automatic token associations for the account.
   */
  [[nodiscard]] inline std::optional<int32_t> getMaxAutomaticTokenAssociations() const
  {
    return mMaxAutomaticTokenAssociations;
  }

  /**
   * Get the ID of the new account to which the account will stake.
   *
   * @return The ID of the desired new account to which the account will stake. Returns uninitialized if a value has not
   *         yet been set, or if a staked node ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<AccountId> getStakedAccountId() const { return mStakedAccountId; }

  /**
   * Get the ID of the desired new node to which the account will stake.
   *
   * @return The ID of the desired new node to which the account will stake. Returns uninitialized if a value has not
   *         yet been set, or if a staked account ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<uint64_t> getStakedNodeId() const { return mStakedNodeId; }

  /**
   * Get the new staking rewards reception policy for the account.
   *
   * @return \c TRUE if the new account should decline from receiving staking rewards, otherwise \c FALSE
   */
  [[nodiscard]] inline std::optional<bool> getDeclineStakingReward() const { return mDeclineStakingReward; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this AccountUpdateTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this AccountUpdateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This AccountUpdateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the AccountUpdateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this AccountUpdateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a CryptoUpdateTransactionBody protobuf object from this AccountUpdateTransaction object.
   *
   * @return A pointer to a CryptoUpdateTransactionBody protobuf object filled with this AccountUpdateTransaction
   *         object's data.
   */
  [[nodiscard]] proto::CryptoUpdateTransactionBody* build() const;

  /**
   * The ID of the account to update.
   */
  AccountId mAccountId;

  /**
   * The new key to use to sign each transfer out of the account. If mReceiverSignatureRequired is \c TRUE, then it must
   * also sign any transfer into the account.
   */
  std::shared_ptr<Key> mKey = nullptr;

  /**
   * If \c TRUE, the account will have to sign any transaction being deposited into it (in addition to all withdrawals).
   */
  std::optional<bool> mReceiverSignatureRequired;

  /**
   * The new duration to use for the account to automatically extend its expiration period. It it doesn't have enough
   * balance, it extends as long as possible. If it is empty when it expires, then it is deleted.
   */
  std::optional<std::chrono::system_clock::duration> mAutoRenewPeriod;

  /**
   * The new expiration time to which to extend this account.
   */
  std::optional<std::chrono::system_clock::time_point> mExpirationTime;

  /**
   * The new memo to be associated with the account (UTF-8 encoding max 100 bytes).
   */
  std::optional<std::string> mAccountMemo;

  /**
   * The new maximum number of tokens with which the account can be implicitly associated. Only allows values up to a
   * maximum value of 5000. A value of -1 means the account can have unlimited token associations.
   */
  std::optional<int32_t> mMaxAutomaticTokenAssociations;

  /**
   * The ID of the new account to which this account will be staked. Mutually exclusive with mStakedNodeId.
   */
  std::optional<AccountId> mStakedAccountId;

  /**
   * The ID of the new node to which this account will be staked. Mutually exclusive with mStakedAccountId.
   */
  std::optional<uint64_t> mStakedNodeId;

  /**
   * If \c TRUE, the account will now decline receiving staking rewards.
   */
  std::optional<bool> mDeclineStakingReward;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ACCOUNT_UPDATE_TRANSACTION_H_
// Filename: src/sdk/main/include/AddressBookQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ADDRESS_BOOK_QUERY_H_
#define HIERO_SDK_CPP_ADDRESS_BOOK_QUERY_H_

#include "Defaults.h"
#include "FileId.h"

#include <chrono>

namespace Hiero
{
class Client;
class NodeAddressBook;
}

namespace com::hedera::mirror::api::proto
{
class AddressBookQuery;
}

namespace Hiero
{
/**
 * A query that returns the current address book being used by the network's consensus nodes.
 */
class AddressBookQuery
{
public:
  /**
   * Submit this AddressBookQuery to a Hiero network.
   *
   * @param client The Client to use to submit this AddressBookQuery.
   * @return The NodeAddressBook object sent from the Hiero network that contains the result of this AddressBookQuery.
   * @throws MaxAttemptsExceededException If this AddressBookQuery attempts to execute past the number of allowable
   *                                      attempts.
   * @throws PrecheckStatusException      If this AddressBookQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  NodeAddressBook execute(const Client& client);

  /**
   * Submit this AddressBookQuery to a Hiero network with a specific timeout.
   *
   * @param client  The Client to use to submit this AddressBookQuery.
   * @param timeout The desired timeout for the execution of this AddressBookQuery.
   * @return The NodeAddressBook object sent from the Hiero network that contains the result of this AddressBookQuery.
   * @throws MaxAttemptsExceededException If this AddressBookQuery attempts to execute past the number of allowable
   *                                      attempts.
   * @throws PrecheckStatusException      If this AddressBookQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  NodeAddressBook execute(const Client& client, const std::chrono::system_clock::duration& timeout);

  /**
   * Set the ID of the file of which to request the address book.
   *
   * @param fileId The ID of the file of which to request the address book.
   * @return A reference to this AddressBookQuery object with the newly-set file ID.
   */
  AddressBookQuery& setFileId(const FileId& fileId);

  /**
   * Set the number of node addresses to retrieve. Set to 0 to retrieve all node addresses.
   *
   * @param limit The number of node addresses to retrieve.
   * @return A reference to this AddressBookQuery object with the newly-set node address limit.
   */
  AddressBookQuery& setLimit(unsigned int limit);

  /**
   * Set the maximum number of attempts to try and execute this AddressBookQuery.
   *
   * @param attempts The maximum number of attempts to try and execute this AddressBookQuery.
   * @return A reference to this AddressBookQuery object with the newly-set maximum attempts.
   */
  AddressBookQuery& setMaxAttempts(unsigned int attempts);

  /**
   * Set the maximum amount of time to wait before attempting to resubmit this AddressBookQuery.
   *
   * @param backoff The maximum amount of time to wait before attempting to resubmit this AddressBookQuery.
   * @return A reference to this Client with the newly-set maximum backoff time.
   * @throws std::invalid_argument If the desired maximum backoff duration is shorter than DEFAULT_MIN_BACKOFF.
   */
  AddressBookQuery& setMaxBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Get the ID of the file of which this query is currently configured to get the address book.
   *
   * @return The ID of the file for which this query is meant.
   */
  [[nodiscard]] inline FileId getFileId() const { return mFileId; }

  /**
   * Get the number of node addresses to retrieve.
   *
   * @return The number of node addresses to retrieve.
   */
  [[nodiscard]] inline unsigned int getLimit() const { return mLimit; }

  /**
   * Get the maximum number of attempts to try and execute this AddressBookQuery.
   *
   * @return The maximum number of attempts to try and execute this AddressBookQuery.
   */
  [[nodiscard]] inline unsigned int getMaxAttempts() const { return mMaxAttempts; }

  /**
   * Get the maximum amount of time to wait before attempting to resubmit this AddressBookQuery.
   *
   * @return The the maximum amount of time to wait before attempting to resubmit this AddressBookQuery.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getMaxBackoff() const { return mMaxBackoff; }

private:
  /**
   * Build an AddressBookQuery protobuf object from this AddressBookQuery.
   *
   * @return The AddressBookQuery protobuf object built from this AddressBookQuery.
   */
  com::hedera::mirror::api::proto::AddressBookQuery build() const;

  /**
   * The ID of the file of which this query should get the address book.
   */
  FileId mFileId;

  /**
   * The number of node addresses to retrieve. 0 retrieves all node addresses.
   */
  unsigned int mLimit = 0U;

  /**
   * The maximum number of attempts to try and execute this AddressBookQuery.
   */
  unsigned int mMaxAttempts = DEFAULT_MAX_ATTEMPTS;

  /**
   * The the maximum amount of time to wait before attempting to resubmit this AddressBookQuery.
   */
  std::chrono::system_clock::duration mMaxBackoff = DEFAULT_MAX_BACKOFF;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ADDRESS_BOOK_QUERY_H_
// Filename: src/sdk/main/include/AssessedCustomFee.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ASSESSED_CUSTOM_FEE_H_
#define HIERO_SDK_CPP_ASSESSED_CUSTOM_FEE_H_

#include "AccountId.h"
#include "TokenId.h"

#include <cstddef>
#include <cstdint>
#include <memory>
#include <optional>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class AssessedCustomFee;
}

namespace Hiero
{
/**
 * A custom transfer fee that was assessed during the handling of a CryptoTransfer.
 */
class AssessedCustomFee
{
public:
  /**
   * Construct an AssessedCustomFee object from an AssessedCustomFee protobuf object.
   *
   * @param proto The AssessedCustomFee protobuf object from which to construct an AssessedCustomFee object.
   * @return The constructed AssessedCustomFee object.
   */
  [[nodiscard]] static AssessedCustomFee fromProtobuf(const proto::AssessedCustomFee& proto);

  /**
   * Construct an AssessedCustomFee object from a byte array.
   *
   * @param bytes The byte array from which to construct an AssessedCustomFee object.
   * @return The constructed AssessedCustomFee object.
   */
  [[nodiscard]] static AssessedCustomFee fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct an AssessedCustomFee protobuf object from this AssessedCustomFee object.
   *
   * @return A pointer to the created AssessedCustomFee protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::AssessedCustomFee> toProtobuf() const;

  /**
   * Construct a representative byte array from this AssessedCustomFee object.
   *
   * @return The byte array representing this AssessedCustomFee object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this AssessedCustomFee object.
   *
   * @return The string representation of this AssessedCustomFee object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this AssessedCustomFee to an output stream.
   *
   * @param os  The output stream.
   * @param fee The AssessedCustomFee to print.
   * @return The output stream with this AssessedCustomFee written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const AssessedCustomFee& fee);

  /**
   * The number of units assessed for the fee.
   */
  int64_t mAmount = 0LL;

  /**
   * The denomination of the fee. The denomination is Hbar if left unset.
   */
  std::optional<TokenId> mTokenId;

  /**
   * The ID of the account to receive the assessed fee.
   */
  AccountId mFeeCollectorAccountId;

  /**
   * The IDs of the accounts who paid this fee (i.e. their balances would be higher if not for this fee).
   */
  std::vector<AccountId> mPayerAccountIdList;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ASSESSED_CUSTOM_FEE_H_
// Filename: src/sdk/main/include/ChunkedTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CHUNKED_TRANSACTION_H_
#define HIERO_SDK_CPP_CHUNKED_TRANSACTION_H_

#include "Defaults.h"
#include "Transaction.h"
#include "TransactionId.h"

#include <chrono>
#include <cstddef>
#include <cstdint>
#include <functional>
#include <future>
#include <stdexcept>
#include <string_view>
#include <unordered_map>
#include <vector>

namespace Hiero
{
class Client;
class TransactionResponse;
}

namespace Hiero
{
/**
 * Base class for all transactions that require being divided into chunks.
 *
 * @tparam SdkRequestType The SDK request type.
 */
template<typename SdkRequestType>
class ChunkedTransaction : public Transaction<SdkRequestType>
{
public:
  /**
   * Derived from Executable. Execute this ChunkedTransaction. This should NOT be used if multiple chunks are being sent
   * (i.e. data.size() > mMaxChunkSize); opt to use `executeAll()` instead.
   *
   * @param client The Client to use to submit this ChunkedTransaction.
   * @return The TransactionResponse object sent from the Hiero network that contains the result of the first chunked
   *         request.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionResponse execute(const Client& client) override;

  /**
   * Derived from Executable. Execute this ChunkedTransaction with a specific timeout. This should NOT be used if
   * multiple chunks are being sent (i.e. data.size() > mMaxChunkSize); opt to use `executeAll()` instead.
   *
   * @param client The Client to use to submit this ChunkedTransaction.
   * @param timeout The desired timeout for the execution of this ChunkedTransaction.
   * @return The TransactionResponse object sent from the Hiero network that contains the result of the first chunked
   *         request.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionResponse execute(const Client& client, const std::chrono::system_clock::duration& timeout) override;

  /**
   * Derived from Executable. Execute this ChunkedTransaction asynchronously with a specific timeout.
   *
   * @param client  The Client to use to submit this ChunkedTransaction.
   * @param timeout The desired timeout for the execution of this ChunkedTransaction.
   * @return The future TransactionResponse object sent from the Hiero network that contains the result of the request.
   * @throws MaxAttemptsExceededException If this ChunkedTransaction attempts to execute past the number of allowable
   *                                      attempts.
   * @throws PrecheckStatusException      If this ChunkedTransaction fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<TransactionResponse> executeAsync(const Client& client,
                                                const std::chrono::system_clock::duration& timeout) override;

  /**
   * Execute all chunks of this ChunkedTransaction.
   *
   * @param client The Client to use to submit this ChunkedTransaction.
   * @return The list of TransactionResponse objects sent from the Hiero network that contains the result of the
   *         requests.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::vector<TransactionResponse> executeAll(const Client& client);

  /**
   * Execute all chunks of this ChunkedTransaction with a specific timeout.
   *
   * @param client The Client to use to submit this ChunkedTransaction.
   * @param timeout The desired timeout for the execution of this ChunkedTransaction.
   * @return The list of TransactionResponse objects sent from the Hiero network that contains the result of the
   *         requests.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::vector<TransactionResponse> executeAll(const Client& client, const std::chrono::system_clock::duration& timeout);

  /**
   * Execute all chunks of this ChunkedTransaction asynchronously.
   *
   * @param client The Client to use to submit this ChunkedTransaction.
   * @return The future list of TransactionResponse objects sent from the Hiero network that contains the result of the
   *         requests.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<std::vector<TransactionResponse>> executeAllAsync(const Client& client);

  /**
   * Execute all chunks of this ChunkedTransaction asynchronously with a specified timeout.
   *
   * @param client  The Client to use to submit this ChunkedTransaction.
   * @param timeout The desired timeout for the execution of this ChunkedTransaction.
   * @return The future list of TransactionResponse objects sent from the Hiero network that contains the result of the
   *         requests.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<std::vector<TransactionResponse>> executeAllAsync(const Client& client,
                                                                const std::chrono::system_clock::duration& timeout);

  /**
   * Execute all chunks of this ChunkedTransaction asynchronously and consume the response and/or exception with a
   * callback.
   *
   * @param client   The Client to use to submit this ChunkedTransaction.
   * @param callback The callback that should consume the response/exception.
   */
  void executeAllAsync(
    const Client& client,
    const std::function<void(const std::vector<TransactionResponse>&, const std::exception&)>& callback);

  /**
   * Execute all chunks of this ChunkedTransaction asynchronously with a specified timeout and consume the response
   * and/or exception with a callback.
   *
   * @param client   The Client to use to submit this ChunkedTransaction.
   * @param timeout  The desired timeout for the execution of this ChunkedTransaction.
   * @param callback The callback that should consume the response/exception.
   */
  void executeAllAsync(
    const Client& client,
    const std::chrono::system_clock::duration& timeout,
    const std::function<void(const std::vector<TransactionResponse>&, const std::exception&)>& callback);

  /**
   * Execute all chunks of this ChunkedTransaction asynchronously and consume the response and/or exception with
   * separate callbacks.
   *
   * @param client            The Client to use to submit this Executable.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void executeAllAsync(const Client& client,
                       const std::function<void(const std::vector<TransactionResponse>&)>& responseCallback,
                       const std::function<void(const std::exception&)>& exceptionCallback);

  /**
   * Execute all chunks of this ChunkedTransaction asynchronously with a specific timeout and consume the response
   * and/or exception with separate callbacks.
   *
   * @param client            The Client to use to submit this Executable.
   * @param timeout           The desired timeout for the execution of this Executable.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void executeAllAsync(const Client& client,
                       const std::chrono::system_clock::duration& timeout,
                       const std::function<void(const std::vector<TransactionResponse>&)>& responseCallback,
                       const std::function<void(const std::exception&)>& exceptionCallback);

  /**
   * Derived from Transaction. Add a signature to this ChunkedTransaction.
   *
   * @param publicKey The associated PublicKey of the PrivateKey that generated the signature.
   * @param signature The signature to add.
   * @return A reference to this derived ChunkedTransaction object with the newly-added signature.
   * @throws IllegalStateException If there are multiple chunks in this ChunkedTransaction,there is not exactly one node
   *                               account ID set, or if this ChunkedTransaction is not frozen.
   */
  SdkRequestType& addSignature(const std::shared_ptr<PublicKey>& publicKey,
                               const std::vector<std::byte>& signature) override;

  /**
   * Derived from Transaction. Get the signatures of each potential Transaction protobuf object this ChunkedTransaction
   * may send.
   *
   * @return The map of node account IDs to their PublicKeys and signatures.
   */
  [[nodiscard]] std::map<AccountId, std::map<std::shared_ptr<PublicKey>, std::vector<std::byte>>> getSignatures()
    const override;

  /**
   * Get the signatures of all chunks of this ChunkedTransaction, for each potential node to which it may be sent.
   *
   * @return The list of signatures for each node account ID for each chunk.
   */
  [[nodiscard]] std::vector<std::map<AccountId, std::map<std::shared_ptr<PublicKey>, std::vector<std::byte>>>>
  getAllSignatures() const;

  /**
   * Derived from Transaction. Get the SHA384 hash of this ChunkedTransaction.
   *
   * @return The SHA384 hash of this Transaction.
   * @throws IllegalStateException If this ChunkedTransaction contains multiple chunks or this ChunkedTransaction is
   * not frozen.
   */
  [[nodiscard]] std::vector<std::byte> getTransactionHash() const override;

  /**
   * Derived from Transaction. Get the SHA384 hash of each potential Transaction protobuf object this ChunkedTransaction
   * may send.
   *
   * @return The map of node account IDs to the SHA384 hash of their Transaction.
   * @throws IllegalStateException If this ChunkedTransaction contains multiple chunks or this ChunkedTransaction is not
   *                               frozen.
   */
  [[nodiscard]] std::map<AccountId, std::vector<std::byte>> getTransactionHashPerNode() const override;

  /**
   * Get the SHA384 hashes of all Transaction protobuf objects for each chunk of this ChunkedTransaction, for each node
   * account ID.
   *
   * @return The list of Transaction protobuf object hashes for each node account ID for each chunk.
   * @throws IllegalStateException If this ChunkedTransaction isn't frozen.
   */
  [[nodiscard]] std::vector<std::map<AccountId, std::vector<std::byte>>> getAllTransactionHashesPerNode() const;

  /**
   * Set the maximum number of chunks for this ChunkedTransaction.
   *
   * @param chunks The maximum number of chunks for this ChunkedTransaction.
   * @return A reference to this derived ChunkedTransaction object with the newly-set chunk maximum.
   */
  SdkRequestType& setMaxChunks(unsigned int chunks);

  /**
   * Set the size of each chunk, in bytes, for this ChunkedTransaction.
   *
   * @param size The size of each chunk, in bytes, for this ChunkedTransaction.
   * @return A reference to this derived ChunkedTransaction object with the newly-set chunk size.
   */
  SdkRequestType& setChunkSize(unsigned int size);

  /**
   * Get the maximum number of chunks for this ChunkedTransaction.
   *
   * @return The maximum number of chunks for this ChunkedTransaction.
   */
  [[nodiscard]] unsigned int getMaxChunks() const;

  /**
   * Get the size of each chunk, in bytes, for this ChunkedTransaction.
   *
   * @return The size of each chunk, in bytes, for this ChunkedTransaction.
   */
  [[nodiscard]] unsigned int getChunkSize() const;

protected:
  ChunkedTransaction();
  ~ChunkedTransaction();
  ChunkedTransaction(const ChunkedTransaction&);
  ChunkedTransaction& operator=(const ChunkedTransaction&);
  ChunkedTransaction(ChunkedTransaction&&) noexcept;
  ChunkedTransaction& operator=(ChunkedTransaction&&) noexcept;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param txBody The TransactionBody protobuf object from which to construct.
   */
  explicit ChunkedTransaction(const proto::TransactionBody& txBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects. This
   * will ignore the first TransactionId entry (as its information will be stored in the base Transaction
   * implementation) and construct additional Transaction protobuf objects for each additional chunk of the Transaction
   * that must be sent.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit ChunkedTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the data for this ChunkedTransaction.
   *
   * @param data The data for this ChunkedTransaction.
   * @return A reference to this derived ChunkedTransaction object with the newly-set data.
   */
  SdkRequestType& setData(const std::vector<std::byte>& data);
  SdkRequestType& setData(std::string_view data);

  /**
   * Get the data for this ChunkedTransaction.
   *
   * @return The data for this ChunkedTransaction.
   */
  [[nodiscard]] std::vector<std::byte> getData() const;

  /**
   * Get the data contained in the input chunk of this ChunkedTransaction.
   *
   * @param chunk The chunk number of which to get the data.
   * @return The data contained in the input chunk number.
   */
  [[nodiscard]] std::vector<std::byte> getDataForChunk(unsigned int chunk) const;

  /**
   * Set the receipt retrieval policy for this ChunkedTransaction.
   *
   * @param retrieveReceipt \c TRUE if this ChunkedTransaction should retrieve a receipt after each submitted chunk,
   *                        otherwise \c FALSE.
   */
  void setShouldGetReceipt(bool retrieveReceipt);

  /**
   * Get the receipt retrieval policy for this ChunkedTransaction.
   *
   * @retrun retrieveReceipt \c TRUE if this ChunkedTransaction should retrieve a receipt after each submitted chunk,
   *                         otherwise \c FALSE.
   */
  [[nodiscard]] bool getShouldGetReceipt() const;

private:
  /**
   * Build and add the derived ChunkedTransaction's chunked protobuf representation to the TransactionBody protobuf
   * object.
   *
   * @param chunk The chunk number.
   * @param total The total number of chunks being created.
   * @param body  The TransactionBody protobuf object to which to add the chunked data.
   */
  virtual void addToChunk(uint32_t chunk, [[maybe_unused]] uint32_t total, proto::TransactionBody& body) const = 0;

  /**
   * Derived from Executable. Construct a Transaction protobuf object from this ChunkedTransaction, based on the attempt
   * number. This will take into account the current chunk of this ChunkedTransaction trying to be sent.
   *
   * @param index The index of the node account ID that's associated with the Node being used to execute this
   *              ChunkedTransaction.
   * @return A Transaction protobuf object filled with this ChunkedTransaction's data, based on the node account ID at
   *         the given index.
   */
  [[nodiscard]] proto::Transaction makeRequest(unsigned int index) const override;

  /**
   * Derived from Transaction. Regenerate the SignedTransaction protobuf objects for this ChunkedTransaction.
   *
   * @param client A pointer to the Client to use to regenerate the SignedTransaction protobuf objects.
   */
  void regenerateSignedTransactions(const Client* client) const override;

  /**
   * Derived from Transaction. Clear the SignedTransaction and Transaction protobuf objects held by this
   * ChunkedTransaction.
   */
  void clearTransactions() const override;

  /**
   * Derived from Transaction. Get the ID of the previously-executed ChunkedTransaction.
   *
   * @return The ID of the previously-executed ChunkedTransaction.
   */
  [[nodiscard]] TransactionId getCurrentTransactionId() const override;

  /**
   * Get the number of chunks that will be required to send this full ChunkedTransaction.
   *
   * @return The number of chunks that will be required to send this full ChunkedTransaction.
   */
  [[nodiscard]] unsigned int getNumberOfChunksRequired() const;

  /**
   * Implementation object used to hide implementation details and internal headers.
   */
  struct ChunkedTransactionImpl;
  std::unique_ptr<ChunkedTransactionImpl> mImpl;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CHUNKED_TRANSACTION_H_// Filename: src/sdk/main/include/Client.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CLIENT_H_
#define HIERO_SDK_CPP_CLIENT_H_

#include <chrono>
#include <functional>
#include <future>
#include <memory>
#include <nlohmann/json.hpp>
#include <optional>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

namespace Hiero
{
namespace internal
{
class MirrorNetwork;
class Network;
}
class AccountId;
class Hbar;
class LedgerId;
class Logger;
class NodeAddressBook;
class PrivateKey;
class PublicKey;
class SubscriptionHandle;
}

namespace Hiero
{
/**
 * Managed client for use on the Hiero network.
 */
class Client
{
public:
  /**
   * Constructor creates implementation object.
   */
  Client();

  /**
   * Destructor closes all network connections.
   */
  ~Client();

  /**
   * No copying allowed. Underlying connections should be moved instead of copied.
   */
  Client(const Client&) = delete;
  Client& operator=(const Client&) = delete;
  Client(Client&&) noexcept;
  Client& operator=(Client&&) noexcept;

  /**
   * Construct a Client pre-configured for a specific Hiero network.
   *
   * @param networkMap The map with string representation of node addresses with their corresponding accountId.
   * @return A reference to this Client object with the newly-set operator account ID from the map.
   */
  [[nodiscard]] static Client forNetwork(const std::unordered_map<std::string, AccountId>& networkMap);

  /**
   * Construct a Client pre-configured for a specific mirror network. This will attempt to pull the network address
   * book from the input mirror network and establish its consensus network with that.
   *
   * @param mirrorNetwork The mirror node network from which to grab the address book and initialize the Client's
   *                      consensus network.
   * @return A Client with the input mirror network and the corresponding address book consensus network
   */
  [[nodiscard]] static Client forMirrorNetwork(const std::vector<std::string>& mirrorNetwork);

  /**
   * Construct a Client by a name. The name must be one of "mainnet", "testnet", or "previewnet", otherwise this will
   * throw std::invalid_argument.
   *
   * @param name The name of the Client to construct.
   * @return A Client object that is set-up to communicate with the input network name.
   */
  [[nodiscard]] static Client forName(std::string_view name);

  /**
   * Construct a Client pre-configured for Hiero Mainnet access.
   *
   * @return A Client object that is set-up to communicate with the Hiero Mainnet.
   */
  [[nodiscard]] static Client forMainnet();

  /**
   * Construct a Client pre-configured for Hiero Testnet access.
   *
   * @return A Client object that is set-up to communicate with the Hiero Testnet.
   */
  [[nodiscard]] static Client forTestnet();

  /**
   * Construct a Client pre-configured for Hiero Previewnet access.
   *
   * @return A Client object that is set-up to communicate with the Hiero Previewnet.
   */
  [[nodiscard]] static Client forPreviewnet();

  /**
   * Construct a Client from a JSON configuration string.
   *
   * @param json The JSON configuration string.
   * @return A Client object initialized with the properties specified in the JSON configuration string.
   */
  [[nodiscard]] static Client fromConfig(std::string_view json);

  /**
   * Construct a Client from a JSON configuration object.
   *
   * @param json The JSON configuration object.
   * @return A Client object initialized with the properties specified in the JSON configuration object.
   */
  [[nodiscard]] static Client fromConfig(const nlohmann::json& json);

  /**
   * Construct a Client from a JSON configuration file.
   *
   * @param path The filepath to the JSON configuration file.
   * @return A Client object initialized with the properties specified in the JSON configuration file.
   */
  [[nodiscard]] static Client fromConfigFile(std::string_view path);

  /**
   * Send a ping to a given node.
   *
   * @param nodeAccountId The ID of the account of the node to ping.
   */
  void ping(const AccountId& nodeAccountId) const;

  /**
   * Send a ping to a given node with a specified timeout.
   *
   * @param nodeAccountId The ID of the account of the node to ping.
   * @param timeout       The desired timeout for the ping.
   */
  void ping(const AccountId& nodeAccountId, const std::chrono::system_clock::duration& timeout) const;

  /**
   * Send a ping to a given node asynchronously.
   *
   * @param nodeAccountId The ID of the account of the node to ping.
   */
  std::future<void> pingAsync(const AccountId& nodeAccountId) const;

  /**
   * Send a ping to a given node asynchronously with a specified timeout.
   *
   * @param nodeAccountId The ID of the account of the node to ping.
   * @param timeout       The desired timeout for the ping.
   */
  std::future<void> pingAsync(const AccountId& nodeAccountId, const std::chrono::system_clock::duration& timeout) const;

  /**
   * Send a ping to a given node asynchronously and consume the exception, if there is one, with a callback.
   *
   * @param nodeAccountId The ID of the account of the node to ping.
   * @param callback      The callback that should consume the exception, if there is one.
   */
  void pingAsync(const AccountId& nodeAccountId, const std::function<void(const std::exception&)>& callback) const;

  /**
   * Send a ping to a given node asynchronously with a specified timeout and consume the exception, if there is one,
   * with a callback.
   *
   * @param nodeAccountId The ID of the account of the node to ping.
   * @param timeout       The desired timeout for the ping.
   * @param callback      The callback that should consume the exception, if there is one.
   */
  void pingAsync(const AccountId& nodeAccountId,
                 const std::chrono::system_clock::duration& timeout,
                 const std::function<void(const std::exception&)>& callback) const;

  /**
   * Send a ping to all consensus nodes on this Client's network.
   */
  void pingAll() const;

  /**
   * Send a ping to all consensus nodes on this Client's network with a specified timeout.
   *
   * @param timeout The desired timeout for the ping.
   */
  void pingAll(const std::chrono::system_clock::duration& timeout) const;

  /**
   * Send a ping to all consensus nodes on this Client's network asynchronously.
   */
  std::future<void> pingAllAsync() const;

  /**
   * Send a ping to all consensus nodes on this Client's network asynchronously with a specified timeout.
   *
   * @param timeout The desired timeout for the ping.
   */
  std::future<void> pingAllAsync(const std::chrono::system_clock::duration& timeout) const;

  /**
   * Send a ping to all consensus nodes on this Client's network asynchronously and consume the exception, if there is
   * one, with a callback.
   *
   * @param callback The callback that should consume the exception, if there is one.
   */
  void pingAllAsync(const std::function<void(const std::exception&)>& callback) const;

  /**
   * Send a ping to all consensus nodes on this Client's network asynchronously with a specified timeout and consume the
   * exception, if there is one, with a callback.
   *
   * @param timeout  The desired timeout for the ping.
   * @param callback The callback that should consume the exception, if there is one.
   */
  void pingAllAsync(const std::chrono::system_clock::duration& timeout,
                    const std::function<void(const std::exception&)>& callback) const;

  /**
   * Set the account that will, by default, be paying for requests submitted by this Client. The operator account ID is
   * used to generate the default transaction ID for all transactions executed with this Client. The operator private
   * key is used to sign all transactions executed by this Client.
   *
   * @param accountId  The account ID of the operator.
   * @param privateKey The private key of the operator.
   * @return A reference to this Client object with the newly-set operator account ID and private key.
   */
  Client& setOperator(const AccountId& accountId, const std::shared_ptr<PrivateKey>& privateKey);

  /**
   * Set the account that will, by default, be paying for requests submitted by this Client. The operator account ID is
   * used to generate the default transaction ID for all transactions executed with this Client. The operator public
   * key and signer function is used to sign all transactions executed by this Client.
   *
   * @param accountId The account ID of the operator.
   * @param publicKey The public key of the operator.
   * @param signer    The function used to sign.
   * @return A reference to this Client object with the newly-set operator account ID, public key, and signer function.
   */
  Client& setOperatorWith(const AccountId& accountId,
                          const std::shared_ptr<PublicKey>& publicKey,
                          const std::function<std::vector<std::byte>(const std::vector<std::byte>&)>& signer);

  /**
   * Get the account ID of this Client's operator.
   *
   * @return The account ID of this Client's operator. Uninitialized if the operator has not been set.
   */
  [[nodiscard]] std::optional<AccountId> getOperatorAccountId() const;

  /**
   * Get the public key of this Client's operator.
   *
   * @return A pointer to the public key of this Client's operator. Nullptr if the operator has not been set.
   */
  [[nodiscard]] std::shared_ptr<PublicKey> getOperatorPublicKey() const;

  /**
   * Get the signer function of this Client's operator.
   *
   * @return The signer function of this Client's operator. Uninitialized if the operator has not been set.
   */
  [[nodiscard]] std::optional<std::function<std::vector<std::byte>(const std::vector<std::byte>&)>> getOperatorSigner()
    const;

  /**
   * Initiate an orderly close of communications with the networks with which this Client was configured to
   * communicate. Preexisting transactions or queries continue but subsequent calls would be immediately cancelled.
   *
   * After this method returns, this Client can be re-used. All network communication can be re-established as needed.
   */
  void close();

  /**
   * Set the maximum transaction fee willing to be paid for transactions executed by this Client. Every request
   * submitted with this Client will have its maximum transaction fee overwritten by this Client's maximum transaction
   * fee if and only if it has not been set manually in the request itself.
   *
   * @param fee The desired maximum transaction fee willing to be paid for transactions submitted by this Client.
   * @return A reference to this Client object with the newly-set maximum transaction fee.
   * @throws std::invalid_argument If the transaction fee is negative.
   */
  Client& setMaxTransactionFee(const Hbar& fee);

  /**
   * Get the maximum transaction fee willing to be paid for transactions submitted by this Client.
   *
   * @return The maximum transaction fee willing to be paid by this Client. Uninitialized if the fee has not been set.
   */
  [[nodiscard]] std::optional<Hbar> getMaxTransactionFee() const;

  /**
   * Set the maximum query payment willing to be paid for transactions executed by this Client. Every request submitted
   * with this Client will have its maximum query payment overwritten by this Client's maximum query payment if and only
   * if it has not been set manually in the request itself.
   *
   * @param payment The desired maximum query payment willing to be paid for queries submitted by this Client.
   * @return A reference to this Client object with the newly-set maximum query payment.
   * @throws std::invalid_argument If the query payment is negative.
   */
  Client& setMaxQueryPayment(const Hbar& payment);

  /**
   * Get the maximum payment willing to be paid for queries submitted by this Client.
   *
   * @return The maximum query payment willing to be paid by this Client. Uninitialized if the fee has not been set.
   */
  [[nodiscard]] std::optional<Hbar> getMaxQueryPayment() const;

  /**
   * Set the transaction ID regeneration policy for transactions executed by this Client. Every transaction submitted
   * with this Client will have its transaction ID regeneration policy overwritten by this Client's transaction ID
   * regeneration policy if and only if it has not been set manually in the request itself.
   *
   * @param regenerate The desired transaction ID regeneration policy for transactions submitted by this Client.
   * @return A reference to this Client object with the newly-set transaction ID regeneration policy.
   */
  Client& setTransactionIdRegenerationPolicy(bool regenerate);

  /**
   * Get the transaction ID regeneration policy for transactions submitted by this Client.
   *
   * @return The default transaction ID regeneration policy for this Client. Uninitialized if the policy has not been
   *         set.
   */
  [[nodiscard]] std::optional<bool> getTransactionIdRegenerationPolicy() const;

  /**
   * Set the automatic entity checksum validation policy.
   *
   * @param validate \c TRUE if this Client should validate entity checksums when submitting Executables, otherwise \c
   *                 FALSE.
   * @return A reference to this Client with the newly-set automatic entity checksum validation policy.
   */
  Client& setAutoValidateChecksums(bool validate);

  /**
   * Is automatic entity checksum validation turned on for this Client?
   *
   * @return \c TRUE if automatic entity checksum validation is turned on, otherwise \c FALSE.
   */
  [[nodiscard]] bool isAutoValidateChecksumsEnabled() const;

  /**
   * Replace the network being used by this Client with nodes contained in an address book.
   *
   * @param addressBook The NodeAddressBook which contains the new nodes to be used by this Client's network.
   * @return A reference to this Client with the newly-set network.
   */
  Client& setNetworkFromAddressBook(const NodeAddressBook& addressBook);

  /**
   * Set the consensus network with which this Client should communicate.
   *
   * @param network The map IPs and ports to the account IDs of the consensus nodes with which this Client should
   *                communicate.
   * @return A reference to this Client object with the newly-set consensus network.
   */
  Client& setNetwork(const std::unordered_map<std::string, AccountId>& network);

  /**
   * Get the map of consensus nodes on this Client's network.
   *
   * @return The map of consensus nodes on this Client's network.
   */
  [[nodiscard]] std::unordered_map<std::string, AccountId> getNetwork() const;

  /**
   * Set the mirror network with which this Client should communicate.
   *
   * @param network The list of IPs and ports of the mirror nodes with which this Client should communicate.
   * @return A reference to this Client object with the newly-set mirror network.
   */
  Client& setMirrorNetwork(const std::vector<std::string>& network);

  /**
   * Get the list of mirror nodes on this Client's network.
   *
   * @return The list of mirror nodes on this Client's network.
   */
  [[nodiscard]] std::vector<std::string> getMirrorNetwork() const;

  /**
   * Set the Logger to be used by this Client.
   *
   * @param logger The Logger to be used by this Client.
   * @return A reference to this Client with the newly-set logger.
   */
  Client& setLogger(const Logger& logger);

  /**
   * Get the Logger used by this Client.
   *
   * @return The Logger used by this Client.
   */
  [[nodiscard]] Logger getLogger() const;

  /**
   * Set the period of time this Client wait between updating its network. This will immediately cancel any scheduled
   * network updates and start a new waiting period.
   *
   * @param update The period of time this Client wait between updating its network.
   * @return A reference to this Client with the newly-set network update period.
   */
  Client& setNetworkUpdatePeriod(const std::chrono::system_clock::duration& update);

  /**
   * Get the period of time this Client wait between updating its network.
   *
   * @return The period of time this Client wait between updating its network.
   */
  [[nodiscard]] std::chrono::system_clock::duration getNetworkUpdatePeriod() const;

  /**
   * Set the ID of the ledger of this Client's Network. Useful when constructing a Network which is a subset of an
   * existing known network. Does nothing if the Client's Network is not yet initialized.
   *
   * @param ledgerId The LedgerId to set.
   * @return A reference to this Client with the newly-set ledger ID.
   */
  Client& setLedgerId(const LedgerId& ledgerId);

  /**
   * Get the ID of the ledger on which this Client's Network is running.
   *
   * @returns The ID of the ledger on which this Client's Network is running.
   * @throws UninitializedException If this Client does not have a Network initialized.
   */
  [[nodiscard]] LedgerId getLedgerId() const;

  /**
   * Set this Client's consensus node network's TLS policy.
   *
   * @param enable \c TRUE to enable TLS for consensus nodes, otherwise \c FALSE.
   * @return A reference to this Client with the newly-set TLS policy.
   */
  Client& setTransportSecurity(bool enable);

  /**
   * Is TLS currently enabled for this Client's consensus nodes?
   *
   * @return \c TRUE if TLS is currently enabled, otherwise \c FALSE.
   */
  [[nodiscard]] bool isTransportSecurity() const;

  /**
   * Set this Client's consensus node network's certificate verification policy.
   *
   * @param verify \c TRUE to enable certification verification for consensus nodes, otherwise \c FALSE.
   * @return A reference to this Client with the newly-set certificate verification policy.
   */
  Client& setVerifyCertificates(bool verify);

  /**
   * Is certificate verification enabled?
   *
   * @return \c TRUE if certification verification is enabled, otherwise \c FALSE.
   */
  [[nodiscard]] bool isVerifyCertificates() const;

  /**
   * Set the length of time a request sent by this Client can be processed before it times out.
   *
   * @param timeout The desired timeout for requests submitted by this Client.
   * @return A reference to this Client object with the newly-set request timeout.
   */
  Client& setRequestTimeout(const std::chrono::system_clock::duration& timeout);

  /**
   * Get the length of time a request sent by this Client can be processed before it times out.
   *
   * @return The request timeout duration.
   */
  [[nodiscard]] std::chrono::system_clock::duration getRequestTimeout() const;

  /**
   * Set the maximum number of times this Client is willing to resubmit failed requests before considering the execution
   * of the request a failure. Every request submitted with this Client will have its maximum number of attempts
   * overwritten by this Client's maximum number of attempts if and only if it has not been set manually in the request
   * itself.
   *
   * @param attempts The desired maximum number of execution attempts for requests submitted by this Client.
   * @return A reference to this Client with the newly-set maximum number of execution attempts.
   */
  Client& setMaxAttempts(unsigned int attempts);

  /**
   * Get the maximum number of times this Client is willing to resubmit failed requests before considering the execution
   * of the request a failure.
   *
   * @return The maximum number of execution attempts. Uninitialized value if not previously set.
   */
  [[nodiscard]] std::optional<unsigned int> getMaxAttempts() const;

  /**
   * Set the minimum amount of time this Client should wait before attempting to resubmit a previously failed request to
   * the network. Every request submitted with this Client will have its minimum backoff time overwritten by this
   * Client's minimum backoff time if and only if it has not been set manually in the request itself.
   *
   * @param backoff The desired minimum amount of time this Client should wait before attempting to resubmit a
   *                previously failed to a particular node.
   * @return A reference to this Client with the newly-set minimum backoff time.
   * @throws std::invalid_argument If the desired minimum backoff duration is longer than the set maximum backoff time
   *                               (DEFAULT_MAX_BACKOFF if the maximum backoff time has not been set).
   */
  Client& setMinBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Get the minimum amount of time this Client should wait before attempting to resubmit a previously failed request to
   * the network.
   *
   * @return The minimum backoff time for Nodes for unsuccessful requests sent by this Client. Uninitialized value if
   *         not previously set.
   */
  [[nodiscard]] std::optional<std::chrono::system_clock::duration> getMinBackoff() const;

  /**
   * Set the maximum amount of time this Client should wait before attempting to resubmit a previously failed request to
   * the network. Every request submitted with this Client will have its maximum backoff time overwritten by this
   * Client's maximum backoff time if and only if it has not been set manually in the request itself.
   *
   * @param backoff The desired maximum amount of time requests submitted by this Client should wait before attempting
   *                to resubmit themselves to a particular node.
   * @return A reference to this Client with the newly-set maximum backoff time.
   * @throws std::invalid_argument If the desired maximum backoff duration is shorter than the set minimum backoff time
   *                               (DEFAULT_MIN_BACKOFF if the minimum backoff time has not been set).
   */
  Client& setMaxBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Get the maximum amount of time this Client should wait before attempting to resubmit a previously failed request to
   * the network.
   *
   * @return The maximum backoff time for Nodes for unsuccessful requests sent by this Client. Uninitialized value if
   *         not previously set.
   */
  [[nodiscard]] std::optional<std::chrono::system_clock::duration> getMaxBackoff() const;

  /**
   * Set the maximum amount of time this Client should spend trying to execute a request before giving up on that
   * request attempt. Every request submitted with this Client will have its gRPC deadline overwritten by this Client's
   * gRPC deadline if and only if it has not been set manually in the request itself.
   *
   * @param deadline The desired maximum amount of time this requests submitted by this Client should spend trying to
   *                 execute.
   * @return A reference to this Client with the newly-set gRPC deadline.
   */
  Client& setGrpcDeadline(const std::chrono::system_clock::duration& deadline);

  /**
   * Get the maximum amount of time this Client should spend trying to execute a request before giving up on that
   * request attempt.
   *
   * @return The maximum amount of time this requests submitted by this Client should spend trying to execute.
   *         Uninitialized value if not previously set.
   */
  [[nodiscard]] std::optional<std::chrono::system_clock::duration> getGrpcDeadline() const;

  /**
   * Set the maximum number of times any node in the network can received a bad gRPC status before being removed from
   * the network.
   *
   * @param attempts The number of times any node can receive a bad gRPC status before being removed from the network.
   * @return A reference to this Client with the newly-set max node attempts.
   */
  Client& setMaxNodeAttempts(unsigned int attempts);

  /**
   * Get the maximum number of times any node in the network can received a bad gRPC status before being removed from
   * the network.
   *
   * @return The maximum number of times any node in the network can received a bad gRPC status before being removed
   *         from the network.
   */
  [[nodiscard]] unsigned int getMaxNodeAttempts() const;

  /**
   * Set the minimum backoff time for nodes in this Client's network.
   *
   * @param backoff The desired minimum backoff time to set for nodes in this Client's network.
   * @return A reference to this Client with the newly-set minimum node backoff time.
   */
  Client& setNodeMinBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Get the minimum backoff time for nodes in this Client's network.
   *
   * @return The minimum backoff time to set for nodes in this Client's network.
   */
  [[nodiscard]] std::chrono::system_clock::duration getNodeMinBackoff() const;

  /**
   * Set the maximum backoff time for nodes in this Client's network.
   *
   * @param backoff The desired maximum backoff time to set for nodes in this Client's network.
   * @return A reference to this Client with the newly-set maximum node backoff time.
   */
  Client& setNodeMaxBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Get the maximum backoff time for nodes in this Client's network.
   *
   * @return The maximum backoff time to set for nodes in this Client's network.
   */
  [[nodiscard]] std::chrono::system_clock::duration getNodeMaxBackoff() const;

  /**
   * Set the minimum amount of time for a node to wait after it receives a bad gRPC status for it to be deemed
   * "healthy".
   *
   * @param time The desired minimum amount of time for a node to wait before it's considered "healthy" again.
   * @return A reference to this Client with the newly-set minimum node readmit time.
   */
  Client& setMinNodeReadmitTime(const std::chrono::system_clock::duration& time);

  /**
   * Get the minimum amount of time for a node to wait after it receives a bad gRPC status for it to be deemed
   * "healthy".
   *
   * @return The minimum amount of time for a node to wait before it's considered "healthy" again.
   */
  [[nodiscard]] std::chrono::system_clock::duration getMinNodeReadmitTime() const;

  /**
   * Set the maximum amount of time for a node to wait after it receives a bad gRPC status for it to be deemed
   * "healthy".
   *
   * @param time The desired maximum amount of time for a node to wait before it's considered "healthy" again.
   * @return A reference to this Client with the newly-set maximum node readmit time.
   */
  Client& setMaxNodeReadmitTime(const std::chrono::system_clock::duration& time);

  /**
   * Get the maximum amount of time for a node to wait after it receives a bad gRPC status for it to be deemed
   * "healthy".
   *
   * @return The maximum amount of time for a node to wait before it's considered "healthy" again.
   */
  [[nodiscard]] std::chrono::system_clock::duration getMaxNodeReadmitTime() const;

  /**
   * Set the maximum number of nodes to be chosen per request. By default, this Client will select 1/3 of the total
   * available nodes per request.
   *
   * @param maxNodes The desired maximum number of nodes this Client should use per request.
   * @return A reference to this Client with the newly-set maximum nodes per request.
   */
  Client& setMaxNodesPerTransaction(unsigned int maxNodes);

  /**
   * Get the maximum number of nodes to be chosen per request. By default, this Client will select 1/3 of the total
   * available nodes per request.
   *
   * @return The maximum number of nodes this Client should use per request.
   */
  [[nodiscard]] unsigned int getMaxNodesPerTransaction() const;

  /**
   * Add a subscription for this Client to track.
   *
   * @param subscription The subscription for this Client to track.
   */
  void trackSubscription(const std::shared_ptr<SubscriptionHandle>& subscription) const;

  /**
   * Remove a subscription from this Client to track.
   *
   * @param subscription The subscription for this Client to untrack.
   */
  void untrackSubscription(const std::shared_ptr<SubscriptionHandle>& subscription) const;

  /**
   * Get a pointer to the Network this Client is using to communicate with consensus nodes.
   *
   * @return A pointer to the Network this Client is using to communicate with consensus nodes.
   */
  [[nodiscard]] std::shared_ptr<internal::Network> getClientNetwork() const;

  /**
   * Get a pointer to the MirrorNetwork this Client is using to communicate with mirror nodes.
   *
   * @return A pointer to the MirrorNetwork this Client is using to communicate with mirror nodes.
   */
  [[nodiscard]] std::shared_ptr<internal::MirrorNetwork> getClientMirrorNetwork() const;

private:
  /**
   * Replace the network being used by this Client with nodes contained in an address book.
   *
   * @param addressBook The NodeAddressBook which contains the new nodes to be used by this Client's network.
   */
  void setNetworkFromAddressBookInternal(const NodeAddressBook& addressBook);

  /**
   * Start the network update thread.
   *
   * @param period The period of time to wait before a network update is performed.
   */
  void startNetworkUpdateThread(const std::chrono::system_clock::duration& period);

  /**
   * Schedule a network update.
   */
  void scheduleNetworkUpdate();

  /**
   * Cancel any scheduled network updates.
   */
  void cancelScheduledNetworkUpdate();

  /**
   * Helper function used for moving a Client implementation into this Client, as well as doing network update thread
   * handling.
   *
   * @param other The Client to move into this Client.
   */
  void moveClient(Client&& other);

  /**
   * Implementation object used to hide implementation details and internal headers.
   */
  struct ClientImpl;
  std::unique_ptr<ClientImpl> mImpl;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CLIENT_H_
// Filename: src/sdk/main/include/ContractByteCodeQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_BYTE_CODE_QUERY_H_
#define HIERO_SDK_CPP_CONTRACT_BYTE_CODE_QUERY_H_

#include "ContractId.h"
#include "Query.h"

#include <cstddef>
#include <vector>

namespace Hiero
{
/**
 * A query that returns the bytecode for a smart contract instance. Anyone can request the byte code of a smart contract
 * instance on the network. Queries do not change the state of the smart contract or require network consensus. The
 * information is returned from a single node processing the query.
 */
using ContractByteCode = std::vector<std::byte>;
class ContractByteCodeQuery : public Query<ContractByteCodeQuery, ContractByteCode>
{
public:
  /**
   * Set the ID of the contract of which to request the byte code.
   *
   * @param contractId The ID of the contract of which to request the byte code.
   * @return A reference to this ContractByteCodeQuery object with the newly-set contract ID.
   */
  ContractByteCodeQuery& setContractId(const ContractId& contractId);

  /**
   * Get the ID of the contract of which this query is currently configured to get the byte code.
   *
   * @return The ID of the contract for which this query is meant.
   */
  [[nodiscard]] inline ContractId getContractId() const { return mContractId; }

private:
  /**
   * Derived from Executable. Construct a ContractByteCode object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a ContractByteCode object.
   * @return A ContractByteCode object filled with the Response protobuf object's data
   */
  [[nodiscard]] ContractByteCode mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this ContractByteCodeQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this ContractByteCodeQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ContractByteCodeQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this ContractByteCodeQuery's data, with the input
   * QueryHeader protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the contract of which this query should get the byte code.
   */
  ContractId mContractId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_BYTE_CODE_QUERY_H_
// Filename: src/sdk/main/include/ContractCallQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_CALL_QUERY_H_
#define HIERO_SDK_CPP_CONTRACT_CALL_QUERY_H_

#include "AccountId.h"
#include "ContractFunctionParameters.h"
#include "ContractId.h"
#include "Query.h"

#include <cstddef>
#include <optional>
#include <string_view>
#include <vector>

namespace Hiero
{
class ContractFunctionResult;
}

namespace Hiero
{
/**
 * A query that calls a function of the given smart contract instance, giving it function parameters as its inputs. This
 * is performed locally on the particular node that the client is communicating with. It cannot change the state of the
 * contract instance (and so, cannot spend anything from the instance's cryptocurrency account). It will not have a
 * consensus timestamp. It cannot generate a record or a receipt. The response will contain the output returned by the
 * function call. This is useful for calling getter functions, which purely read the state and don't change it. It is
 * faster and cheaper than a normal call because it is purely local to a single node.
 *
 * Unlike a contract execution transaction, the node will consume the entire amount of provided gas in determining the
 * fee for this query.
 */
class ContractCallQuery : public Query<ContractCallQuery, ContractFunctionResult>
{
public:
  /**
   * Set the function name to call. Optionally, function parameters can be passed as well.
   *
   * @param name       The name of the function to call.
   * @param parameters The parameters to pass to the function.
   * @return A reference to this ContractCallQuery object with the newly-set function name and optional function
   *         parameters.
   */
  ContractCallQuery& setFunction(std::string_view name,
                                 const ContractFunctionParameters& parameters = ContractFunctionParameters());

  /**
   * Set the ID of the contract from which to call a function.
   *
   * @param contractId The ID of the contract from which to call a function.
   * @return A reference to this ContractCallQuery object with the newly-set contract ID.
   */
  ContractCallQuery& setContractId(const ContractId& contractId);

  /**
   * Set the amount of gas to use for the call. All of the gas offered will be used and charged a corresponding fee.
   *
   * @param gas The amount of gas to use for the call.
   * @return A reference to this ContractCallQuery object with the newly-set gas.
   */
  ContractCallQuery& setGas(const uint64_t& gas);

  /**
   * Set the function parameters for the function call.
   *
   * @param functionParameters The function parameters for the function call.
   * @return A reference to this ContractCallQuery object with the newly-set function parameters.
   */
  ContractCallQuery& setFunctionParameters(const std::vector<std::byte>& functionParameters);

  /**
   * Set the ID of the account to be used as the "sender" for the function call.
   *
   * @param sender The ID of the account to be used as the "sender" for the function call.
   * @return A reference to this ContractCallQuery object with the newly-set sender account ID.
   */
  ContractCallQuery& setSenderAccountId(const AccountId& accountId);

  /**
   * Get the ID of the contract from which this query is currently configured to call a function.
   *
   * @return The ID of the contract from which this query is currently configured to call a function.
   */
  [[nodiscard]] inline ContractId getContractId() const { return mContractId; }

  /**
   * Get the amount of gas this query is currently configured to use for the function call.
   *
   * @return The amount of gas this query is currently configured to use for the function call.
   */
  [[nodiscard]] inline uint64_t getGas() const { return mGas; }

  /**
   * Get the function parameters this query is currently configured to use for the function call.
   *
   * @return The function parameters this query is currently configured to use for the function call.
   */
  [[nodiscard]] inline std::vector<std::byte> getFunctionParameters() const { return mFunctionParameters; }

  /**
   * Get the ID of the account this query is currently configured to use as the sender.
   *
   * @return The ID of the account this query is currently configured to use as the sender. Uninitialized if no sender
   *         account ID has been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getSenderAccountId() const { return mSenderAccountId; }

private:
  /**
   * Derived from Executable. Construct a ContractFunctionResult object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a ContractFunctionResult object.
   * @return A ContractFunctionResult object filled with the Response protobuf object's data
   */
  [[nodiscard]] ContractFunctionResult mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this ContractCallQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this ContractCallQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ContractCallQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this ContractCallQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the contract from which this query should call a function.
   */
  ContractId mContractId;

  /**
   * The amount of gas this query should use for the function call.
   */
  uint64_t mGas = 0ULL;

  /**
   * The function parameters this query should use for the function call.
   */
  std::vector<std::byte> mFunctionParameters;

  /**
   * The ID of the account this query should use as the sender.
   */
  std::optional<AccountId> mSenderAccountId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_CALL_QUERY_H_
// Filename: src/sdk/main/include/ContractCreateFlow.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_CREATE_FLOW_H_
#define HIERO_SDK_CPP_CONTRACT_CREATE_FLOW_H_

#include "AccountId.h"
#include "Defaults.h"
#include "Hbar.h"
#include "Key.h"
#include "TransactionResponse.h"

#include <chrono>
#include <cstddef>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero
{
class Client;
class ContractFunctionParameters;
class PrivateKey;
}

namespace Hiero
{
/**
 * A helper class to create a contract file bytecode directly. This will use FileCreateTransaction and
 * FileAppendTransaction as necessary to create the file followed by ContractCreateTransaction to create the contract,
 * and finally FileDeleteTransaction to delete the created file since it's no longer necessary.
 */
class ContractCreateFlow
{
public:
  /**
   * Execute the Transactions in this flow (FileCreateTransaction, FileAppendTransaction (if needed),
   * ContractCreateTransaction, and a FileDeleteTransaction).
   *
   * @param client The Client to use to submit these Transactions.
   * @return The TransactionResponse object of the ContractCreateTransaction.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionResponse execute(const Client& client);

  /**
   * Execute the Transactions in this flow (FileCreateTransaction, FileAppendTransaction (if needed),
   * ContractCreateTransaction, and a FileDeleteTransaction) with a specified timeout.
   *
   * @param client  The Client to use to submit these Transactions.
   * @param timeout The desired timeout for the execution of these Transactions.
   * @return The TransactionResponse object of the ContractCreateTransaction.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionResponse execute(const Client& client, const std::chrono::system_clock::duration& timeout);

  /**
   * Set the bytes of the smart contract bytecode. If the bytecode is large (>5K), then it must be stored in a file.
   *
   * @param byteCode The bytecode for the new smart contract instance.
   * @return A reference to this ContractCreateFlow object with the newly-set bytecode.
   * @throws OpenSSLException If input bytecode string is not hex-encoded.
   */
  ContractCreateFlow& setBytecode(const std::vector<std::byte>& byteCode);
  ContractCreateFlow& setBytecode(std::string_view byteCode);

  /**
   * Set the admin key for the new smart contract instance. The state of the smart contract instance and its fields can
   * be modified arbitrarily if this key signs a transaction to modify it. If this is not set, then such modifications
   * are not possible, and there is no administrator that can override the normal operation of the new smart contract
   * instance. Note, if this smart contract instance is created with no admin keys, then there is no administrator to
   * authorize changing the admin keys, so there can never be any admin keys for that instance.
   *
   * @param key The admin key for the new smart contract instance.
   * @return A reference to this ContractCreateFlow object with the newly-set admin key.
   */
  ContractCreateFlow& setAdminKey(const std::shared_ptr<Key>& key);

  /**
   * Set the amount of gas required to run the constructor of the new smart contract instance.
   *
   * @param gas The amount of gas to run the constructor of the new smart contract instance.
   * @return A reference to this ContractCreateFlow object with the newly-set amount of gas.
   */
  ContractCreateFlow& setGas(const uint64_t& gas);

  /**
   * Set the initial amount of Hbar to put into the cryptocurrency account associated with and owned by the new smart
   * contract instance.
   *
   * @param initialBalance The initial balance for the cryptocurrency account owned by the new smart contract instance.
   * @return A reference to this ContractCreateFlow object with the newly-set initial balance.
   */
  ContractCreateFlow& setInitialBalance(const Hbar& initialBalance);

  /**
   * Set the auto renew period for the new smart contract instance. The smart contract instance will be charged to
   * extend its expiration date every renew period. If it doesn't have enough balance, it extends as long as possible.
   * If the balance is zero when it expires, then the smart contract instance is deleted.
   *
   * @param autoRenewPeriod The desired auto renew period for the new smart contract instance.
   * @return A reference to this ContractCreateFlow object with the newly-set auto renew period.
   */
  ContractCreateFlow& setAutoRenewPeriod(const std::chrono::system_clock::duration& autoRenewPeriod);

  /**
   * Set the parameters to pass to the new smart contract instance's constructor.
   *
   * @param constructorParameters The parameters to pass to the new smart contract instance's constructor.
   * @return A reference to this ContractCreateFlow object with the newly-set constructor parameters.
   */
  ContractCreateFlow& setConstructorParameters(const ContractFunctionParameters& constructorParameters);
  ContractCreateFlow& setConstructorParameters(const std::vector<std::byte>& constructorParameters);

  /**
   * Set the memo for the new smart contract instance.
   *
   * @param memo The memo for the new smart contract instance.
   * @return A reference to this ContractCreateFlow object with the newly-set memo.
   */
  ContractCreateFlow& setMemo(std::string_view memo);

  /**
   * Set the maximum number of tokens with which the new smart contract instance can be automatically associated.
   *
   * @param associations The maximum amount of token associations for the new smart contract instance.
   * @return A reference to this ContractCreateFlow object with the newly-set maximum automatic token associations.
   */
  ContractCreateFlow& setMaxAutomaticTokenAssociations(int32_t associations);

  /**
   * Set the account to charge for auto-renewal of the new smart contract instance. If not set, or set to an account
   * with zero Hbar balance, the contract's own Hbar balance will be used to cover auto-renewal fees.
   *
   * @param autoRenewAccountId The ID of the account to charge for auto-renewal of the new smart contract instance.
   * @return A reference to this ContractCreateFlow object with the newly-set auto-renewal account ID.
   */
  ContractCreateFlow& setAutoRenewAccountId(const AccountId& autoRenewAccountId);

  /**
   * Set the ID of the account to which the new smart contract instance should stake. This is mutually exclusive with
   * mStakedNodeId, and will reset the value of the mStakedNodeId if it is set.
   *
   * @param stakedAccountId The ID of the account to which the new smart contract instance will stake.
   * @return A reference to this ContractCreateFlow object with the newly-set staked account ID.
   */
  ContractCreateFlow& setStakedAccountId(const AccountId& stakedAccountId);

  /**
   * Set the ID of the node to which the new smart contract instance should stake. This is mutually exclusive with
   * mStakedAccountId, and will reset the value of the mStakedAccountId if it is set.
   *
   * @param stakedNodeId The ID of the desired node to which the new smart contract instance will stake.
   * @return A reference to this ContractCreateFlow object with the newly-set staked node ID.
   */
  ContractCreateFlow& setStakedNodeId(const uint64_t& stakedNodeId);

  /**
   * Set the staking reward reception policy for the new smart contract instance.
   *
   * @param declineReward \c TRUE if the new smart contract instance should decline receiving staking rewards, otherwise
   *                      \c FALSE.
   * @return A reference to this ContractCreateFlow object with the newly-set staking rewards reception policy.
   */
  ContractCreateFlow& setDeclineStakingReward(bool declineReward);

  /**
   * Set the desired account IDs of nodes to which this transaction will be submitted.
   *
   * @param nodeAccountIds The desired list of account IDs of nodes to submit this request.
   * @return A reference to this ContractCreateFlow object with the newly-set node account IDs.
   */
  ContractCreateFlow& setNodeAccountIds(const std::vector<AccountId>& nodeAccountIds);

  /**
   * Set the maximum number of chunks for the FileAppendTransaction that will be sent as a part of this
   * ContractCreateFlow.
   *
   * @param chunks The maximum number of chunks for the FileAppendTransaction.
   * @return A reference to this ContractCreateFlow object with the newly-set chunk maximum.
   */
  ContractCreateFlow& setMaxChunks(unsigned int chunks);

  /**
   * Freeze the ContractCreateTransaction with a Client. The Client's operator will be used to generate a transaction
   * ID, and the client's network will be used to generate a list of node account IDs.
   *
   * NOTE: Since Client's can't be copied, this ContractCreateFlow will store a pointer to the input Client. It is the
   * responsibility of the user to make sure that the Client does not go out of scope or get destroyed until this
   * ContractCreateFlow is done executing, otherwise this will crash upon execution.
   *
   * @param client The Client with which to freeze the ContractCreateTransaction.
   * @return A reference to this ContractCreateFlow object with the newly-set freeze Client.
   * @throws UninitializedException If Client operator has not been initialized.
   */
  ContractCreateFlow& freezeWith(const Client& client);

  /**
   * Set the PrivateKey with which the ContractCreateTransaction will be signed.
   *
   * @param key The PrivateKey with which to sign the ContractCreateTransaction.
   * @return A reference to this ContractCreateFlow object with the newly-set signing PrivateKey.
   */
  ContractCreateFlow& sign(const std::shared_ptr<PrivateKey>& key);

  /**
   * Set the PublicKey and signer function with which the ContractCreateTransaction will be signed.
   *
   * @param key    The PublicKey with which to sign the ContractCreateTransaction.
   * @param signer The callback function to use to sign the ContractCreateTransaction.
   * @return A reference to this ContractCreateFlow object with the newly-set public key and signer function.
   */
  ContractCreateFlow& signWith(const std::shared_ptr<PublicKey>& key,
                               const std::function<std::vector<std::byte>(const std::vector<std::byte>&)>& signer);

  /**
   * Set the Client operator with which the ContractCreateTransaction will be signed.
   *
   * @param client The Client operator to sign the ContractCreateTransaction.
   * @return A reference to this ContractCreateFlow object with the newly-set signing operator.
   * @throws UninitializedException If the Client operator has not yet been set.
   */
  ContractCreateFlow& signWithOperator(const Client& client);

  /**
   * Get the bytes of the smart contract initcode.
   *
   * @return The bytes of the desired smart contract initcode.
   */
  [[nodiscard]] inline std::vector<std::byte> getBytecode() const { return mBytecode; }

  /**
   * Get the admin key for the new smart contract instance.
   *
   * @return A pointer to the admin key for the new smart contract instance. Return nullptr if the admin key has not yet
   *         been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getAdminKey() const { return mAdminKey; }

  /**
   * Get the amount of gas required to run the constructor of the new smart contract instance.
   *
   * @return The amount of gas required to run the constructor of the new smart contract instance.
   */
  [[nodiscard]] inline uint64_t getGas() const { return mGas; }

  /**
   * Get the initial amount of Hbar to put into the cryptocurrency account associated with and owned by the new smart
   * contract instance.
   *
   * @return The initial amount of Hbar to put into the cryptocurrency account associated with and owned by the new
   *         smart contract instance.
   */
  [[nodiscard]] inline Hbar getInitialBalance() const { return mInitialBalance; }

  /**
   * Get the auto renew period for the new smart contract instance.
   *
   * @return The auto renew period for the new smart contract instance.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getAutoRenewPeriod() const { return mAutoRenewPeriod; }

  /**
   * Get the parameters to pass to the new smart contract instance's constructor.
   *
   * @return The parameters to pass to the new smart contract instance's constructor.
   */
  [[nodiscard]] inline std::vector<std::byte> getConstructorParameters() const { return mConstructorParameters; }

  /**
   * Get the memo for the new smart contract instance.
   *
   * @return The memo for the new smart contract instance.
   */
  [[nodiscard]] inline std::string getMemo() const { return mMemo; }

  /**
   * Get the maximum number of tokens with which the new smart contract instance can be automatically associated.
   *
   * @return The maximum number of tokens with which the new smart contract instance can be automatically associated.
   */
  [[nodiscard]] inline int32_t getMaxAutomaticTokenAssociations() const { return mMaxAutomaticTokenAssociations; }

  /**
   * Get the account to charge for auto-renewal of the new smart contract instance.
   *
   * @return The account to charge for auto-renewal of the new smart contract instance. Uninitialized if no auto-renew
   *         account ID has been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getAutoRenewAccountId() const { return mAutoRenewAccountId; }

  /**
   * Get the ID of the account to which the new smart contract instance should stake.
   *
   * @return The ID of the account to which the new smart contract instance should stake. Returns uninitialized if a
   *         value has not yet been set, or if a staked node ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<AccountId> getStakedAccountId() const { return mStakedAccountId; }

  /**
   * Get the ID of the node to which the new smart contract instance should stake.
   *
   * @return The ID of the node to which the new smart contract instance should stake. Returns uninitialized if a value
   *         has not yet been set, or if a staked account ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<uint64_t> getStakedNodeId() const { return mStakedNodeId; }

  /**
   * Get the staking rewards reception policy for the new smart contract instance.
   *
   * @return \c TRUE if the new smart contract instance should decline from receiving staking rewards, otherwise \c
   *         FALSE.
   */
  [[nodiscard]] inline bool getDeclineStakingReward() const { return mDeclineStakingReward; }

  /**
   * Get the list of account IDs for nodes with which execution will be attempted.
   *
   * @return The list of account IDs of nodes this ContractCreateFlow would attempt request submission.
   */
  [[nodiscard]] inline std::vector<AccountId> getNodeAccountIds() const { return mNodeAccountIds; }

  /**
   * Get the maximum number of chunks for the FileAppendTransaction that will be sent as a part of this
   * ContractCreateFlow.
   *
   * @return The maximum number of chunks for the FileAppendTransaction that will be sent as a part of this
   * ContractCreateFlow.
   */
  [[nodiscard]] inline unsigned int getMaxChunks() const { return mMaxChunks; }

private:
  /**
   * The bytes of the smart contract bytecode.
   */
  std::vector<std::byte> mBytecode;

  /**
   * The maximum number of chunks into which the FileAppendTransaction that will be sent as a part of this
   * ContractCreateFlow will get broken up.
   */
  unsigned int mMaxChunks = DEFAULT_MAX_CHUNKS;

  /**
   * The admin key for the new smart contract instance.
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The amount of gas required to run the constructor of the new smart contract instance.
   */
  uint64_t mGas = 0ULL;

  /**
   * The initial amount of Hbar to put into the cryptocurrency account associated with and owned by the new smart
   * contract instance.
   */
  Hbar mInitialBalance = Hbar(0LL);

  /**
   * A Hiero smart contract instance is charged to extend its expiration date every renew period. If it doesn't have
   * enough balance, it extends as long as possible. If the balance is zero when it expires, then the smart contract
   * instance is deleted.
   */
  std::chrono::system_clock::duration mAutoRenewPeriod = DEFAULT_AUTO_RENEW_PERIOD;

  /**
   * The parameters to pass to the new smart contract instance's constructor.
   */
  std::vector<std::byte> mConstructorParameters;

  /**
   * The memo to be associated with the smart contract instance (UTF-8 encoding max 100 bytes).
   */
  std::string mMemo;

  /**
   * The maximum number of tokens with which the new smart contract instance can be implicitly associated.
   */
  int32_t mMaxAutomaticTokenAssociations = 0;

  /**
   * The account to charge for auto-renewal of the new smart contract instance.
   */
  std::optional<AccountId> mAutoRenewAccountId;

  /**
   * The ID of the account to which the new smart contract instance will be staked. Mutually exclusive with
   * mStakedNodeId.
   */
  std::optional<AccountId> mStakedAccountId;

  /**
   * If \c TRUE, the new smart contract instance will decline receiving staking rewards.
   */
  bool mDeclineStakingReward = false;

  /**
   * The Client with which to freeze the ContractCreateTransaction.
   */
  const Client* mFreezeWithClient = nullptr;

  /**
   * The PrivateKey with which to sign the ContractCreateTransaction.
   */
  std::shared_ptr<PrivateKey> mPrivateKey = nullptr;

  /**
   * The PublicKey associated with the signer function to sign the ContractCreateTransaction.
   */
  std::shared_ptr<PublicKey> mPublicKey = nullptr;

  /**
   * The signer function to use to sign the ContractCreateTransaction.
   */
  std::optional<std::function<std::vector<std::byte>(const std::vector<std::byte>&)>> mSigner;

  /**
   * The ID of the node to which the new smart contract instance will be staked. Mutually exclusive with
   * mStakedAccountId.
   */
  std::optional<uint64_t> mStakedNodeId;

  /**
   * The list of account IDs of the nodes with which execution should be attempted.
   */
  std::vector<AccountId> mNodeAccountIds;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_CREATE_FLOW_H_
// Filename: src/sdk/main/include/ContractCreateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_CREATE_TRANSACTION_H_
#define HIERO_SDK_CPP_CONTRACT_CREATE_TRANSACTION_H_

#include "AccountId.h"
#include "FileId.h"
#include "Hbar.h"
#include "Key.h"
#include "Transaction.h"

#include <chrono>
#include <cstddef>
#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class ContractCreateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Start a new smart contract instance. After the instance is created, the ContractId for it is in the receipt, and can
 * be retrieved by the Record or with a GetByKey query. The instance will run the bytecode, either stored in a
 * previously created file or in the transaction body itself for small contracts.
 *
 * The constructor will be executed using the given amount of gas, and any unspent gas will be refunded to the paying
 * account. Constructor inputs come from the given constructorParameters.
 *  - The instance will exist for autoRenewPeriod seconds. When that is reached, it will renew itself for another
 *    autoRenewPeriod seconds by charging its associated cryptocurrency account (which it creates here). If it has
 *    insufficient cryptocurrency to extend that long, it will extend as long as it can. If its balance is zero, the
 *    instance will be deleted.
 *
 *  - A smart contract instance normally enforces rules, so "the code is law". For example, an ERC-20 contract prevents
 *    a transfer from being undone without a signature by the recipient of the transfer. This is always enforced if the
 *    contract instance was created with the adminKeys being null. But for some uses, it might be desirable to create
 *    something like an ERC-20 contract that has a specific group of trusted individuals who can act as a "supreme
 *    court" with the ability to override the normal operation, when a sufficient number of them agree to do so. If
 *    adminKeys is not null, then they can sign a transaction that can change the state of the smart contract in
 *    arbitrary ways, such as to reverse a transaction that violates some standard of behavior that is not covered by
 *    the code itself. The admin keys can also be used to change the autoRenewPeriod, and change the adminKeys field
 *    itself. The API currently does not implement this ability. But it does allow the adminKeys field to be set and
 *    queried, and will in the future implement such admin abilities for any instance that has a non-null adminKeys.
 *
 *  - If this constructor stores information, it is charged gas to store it. There is a fee in Hbars to maintain that
 *    storage until the expiration time, and that fee is added as part of the transaction fee.
 *
 *  - An entity (account, file, or smart contract instance) must be created in a particular realm. If the realmID is
 *    left null, then a new realm will be created with the given admin key. If a new realm has a null adminKey, then
 *    anyone can create/modify/delete entities in that realm. But if an admin key is given, then any transaction to
 *    create/modify/delete an entity in that realm must be signed by that key, though anyone can still call functions on
 *    smart contract instances that exist in that realm. A realm ceases to exist when everything within it has expired
 *    and no longer exists.
 *
 *  - The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0 and realm 0,
 *    with a null key. Future versions of the API will support multiple realms and multiple shards.
 *
 *  - The optional memo field can contain a string whose length is up to 100 bytes. That is the size after Unicode NFD
 *    then UTF-8 conversion. This field can be used to describe the smart contract. It could also be used for other
 *    purposes. One recommended purpose is to hold a hexadecimal string that is the SHA-384 hash of a PDF file
 *    containing a human-readable legal contract. Then, if the admin keys are the public keys of human arbitrators, they
 *    can use that legal document to guide their decisions during a binding arbitration tribunal, convened to consider
 *    any changes to the smart contract in the future. The memo field can only be changed using the admin keys. If there
 *    are no admin keys, then it cannot be changed after the smart contract is created.
 *
 * Signing requirements: If an admin key is set, it must sign the transaction. If an auto-renew account is set, its key
 * must sign the transaction.
 */
class ContractCreateTransaction : public Transaction<ContractCreateTransaction>
{
public:
  /**
   * Default constructor. Sets the maximum transaction fee to 20 Hbars.
   */
  ContractCreateTransaction();

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ContractCreateInstance transaction.
   */
  explicit ContractCreateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit ContractCreateTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the file that contains the smart contract bytecode. A copy will be made and held by the contract
   * instance, and have the same expiration time as the instance. If the bytecode is large (>5K), then it must be stored
   * in a file. This is mutually exclusive with mBytecode, and will reset the value of the mBytecode if it is set.
   *
   * @param fileId The ID of the file that contains the bytecode for the new smart contract instance.
   * @return A reference to this ContractCreateTransaction object with the newly-set file ID.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setBytecodeFileId(const FileId& fileId);

  /**
   * Set the bytes of the smart contract bytecode. If the bytecode is large (>5K), then it must be stored in a file.
   * This is mutually exclusive with mBytecodeFileId, and will reset the value of the mBytecodeFileId if it is set.
   *
   * @param initCode The bytecode for the new smart contract instance.
   * @return A reference to this ContractCreateTransaction object with the newly-set initcode.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setBytecode(const std::vector<std::byte>& initCode);

  /**
   * Set the admin key for the new smart contract instance. The state of the smart contract instance and its fields can
   * be modified arbitrarily if this key signs a transaction to modify it. If this is not set, then such modifications
   * are not possible, and there is no administrator that can override the normal operation of the new smart contract
   * instance. Note, if this smart contract instance is created with no admin keys, then there is no administrator to
   * authorize changing the admin keys, so there can never be any admin keys for that instance.
   *
   * @param key The admin key for the new smart contract instance.
   * @return A reference to this ContractCreateTransaction object with the newly-set admin key.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setAdminKey(const std::shared_ptr<Key>& key);

  /**
   * Set the amount of gas required to run the constructor of the new smart contract instance.
   *
   * @param gas The amount of gas to run the constructor of the new smart contract instance.
   * @return A reference to this ContractCreateTransaction object with the newly-set amount of gas.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setGas(const uint64_t& gas);

  /**
   * Set the initial amount of Hbar to put into the cryptocurrency account associated with and owned by the new smart
   * contract instance.
   *
   * @param initialBalance The initial balance for the cryptocurrency account owned by the new smart contract instance.
   * @return A reference to this ContractCreateTransaction object with the newly-set initial balance.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setInitialBalance(const Hbar& initialBalance);

  /**
   * Set the auto renew period for the new smart contract instance. The smart contract instance will be charged to
   * extend its expiration date every renew period. If it doesn't have enough balance, it extends as long as possible.
   * If the balance is zero when it expires, then the smart contract instance is deleted.
   *
   * @param autoRenewPeriod The desired auto renew period for the new smart contract instance.
   * @return A reference to this ContractCreateTransaction object with the newly-set auto renew period.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setAutoRenewPeriod(const std::chrono::system_clock::duration& autoRenewPeriod);

  /**
   * Set the parameters to pass to the new smart contract instance's constructor.
   *
   * @param constructorParameters The parameters to pass to the new smart contract instance's constructor.
   * @return A reference to this ContractCreateTransaction object with the newly-set constructor parameters.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setConstructorParameters(const std::vector<std::byte>& constructorParameters);

  /**
   * Set the memo for the new smart contract instance.
   *
   * @param memo The memo for the new smart contract instance.
   * @return A reference to this ContractCreateTransaction object with the newly-set memo.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setMemo(std::string_view memo);

  /**
   * Set the maximum number of tokens with which the new smart contract instance can be automatically associated.
   *
   * @param associations The maximum amount of token associations for the new smart contract instance.
   * @return A reference to this ContractCreateTransaction object with the newly-set maximum automatic token
   *         associations.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setMaxAutomaticTokenAssociations(int32_t associations);

  /**
   * Set the account to charge for auto-renewal of the new smart contract instance. If not set, or set to an account
   * with zero Hbar balance, the contract's own Hbar balance will be used to cover auto-renewal fees.
   *
   * @param autoRenewAccountId The ID of the account to charge for auto-renewal of the new smart contract instance.
   * @return A reference to this ContractCreateTransaction object with the newly-set auto-renewal account ID.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setAutoRenewAccountId(const AccountId& autoRenewAccountId);

  /**
   * Set the ID of the account to which the new smart contract instance should stake. This is mutually exclusive with
   * mStakedNodeId, and will reset the value of the mStakedNodeId if it is set.
   *
   * @param stakedAccountId The ID of the account to which the new smart contract instance will stake.
   * @return A reference to this ContractCreateTransaction object with the newly-set staked account ID.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setStakedAccountId(const AccountId& stakedAccountId);

  /**
   * Set the ID of the node to which the new smart contract instance should stake. This is mutually exclusive with
   * mStakedAccountId, and will reset the value of the mStakedAccountId if it is set.
   *
   * @param stakedNodeId The ID of the desired node to which the new smart contract instance will stake.
   * @return A reference to this ContractCreateTransaction object with the newly-set staked node ID.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setStakedNodeId(const uint64_t& stakedNodeId);

  /**
   * Set the staking reward reception policy for the new smart contract instance.
   *
   * @param declineReward \c TRUE if the new smart contract instance should decline receiving staking rewards, otherwise
   *                      \c FALSE.
   * @return A reference to this ContractCreateTransaction object with the newly-set staking rewards reception policy.
   * @throws IllegalStateException If this ContractCreateTransaction is frozen.
   */
  ContractCreateTransaction& setDeclineStakingReward(bool declineReward);

  /**
   * Get the ID of the file that contains the smart contract initcode.
   *
   * @return The ID of the file that contains the desired smart contract initcode. Returns uninitialized if a value has
   *         not yet been set, or if mBytecode has been set more recently.
   */
  [[nodiscard]] inline std::optional<FileId> getFileId() const { return mBytecodeFileId; }

  /**
   * Get the bytes of the smart contract initcode.
   *
   * @return The bytes of the desired smart contract initcode. Returns uninitialized if a value has not yet been set, or
   *         if the mBytecodeFileId has been set more recently.
   */
  [[nodiscard]] inline std::optional<std::vector<std::byte>> getInitCode() const { return mBytecode; }

  /**
   * Get the admin key for the new smart contract instance.
   *
   * @return A pointer to the admin key for the new smart contract instance. Return nullptr if the admin key has not yet
   *         been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getAdminKey() const { return mAdminKey; }

  /**
   * Get the amount of gas required to run the constructor of the new smart contract instance.
   *
   * @return The amount of gas required to run the constructor of the new smart contract instance.
   */
  [[nodiscard]] inline uint64_t getGas() const { return mGas; }

  /**
   * Get the initial amount of Hbar to put into the cryptocurrency account associated with and owned by the new smart
   * contract instance.
   *
   * @return The initial amount of Hbar to put into the cryptocurrency account associated with and owned by the new
   *         smart contract instance.
   */
  [[nodiscard]] inline Hbar getInitialBalance() const { return mInitialBalance; }

  /**
   * Get the auto renew period for the new smart contract instance.
   *
   * @return The auto renew period for the new smart contract instance.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getAutoRenewPeriod() const { return mAutoRenewPeriod; }

  /**
   * Get the parameters to pass to the new smart contract instance's constructor.
   *
   * @return The parameters to pass to the new smart contract instance's constructor.
   */
  [[nodiscard]] inline std::vector<std::byte> getConstructorParameters() const { return mConstructorParameters; }

  /**
   * Get the memo for the new smart contract instance.
   *
   * @return The memo for the new smart contract instance.
   */
  [[nodiscard]] inline std::string getMemo() const { return mMemo; }

  /**
   * Get the maximum number of tokens with which the new smart contract instance can be automatically associated.
   *
   * @return The maximum number of tokens with which the new smart contract instance can be automatically associated.
   */
  [[nodiscard]] inline int32_t getMaxAutomaticTokenAssociations() const { return mMaxAutomaticTokenAssociations; }

  /**
   * Get the account to charge for auto-renewal of the new smart contract instance.
   *
   * @return The account to charge for auto-renewal of the new smart contract instance. Uninitialized if no auto-renew
   *         account ID has been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getAutoRenewAccountId() const { return mAutoRenewAccountId; }

  /**
   * Get the ID of the account to which the new smart contract instance should stake.
   *
   * @return The ID of the account to which the new smart contract instance should stake. Returns uninitialized if a
   *         value has not yet been set, or if a staked node ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<AccountId> getStakedAccountId() const { return mStakedAccountId; }

  /**
   * Get the ID of the node to which the new smart contract instance should stake.
   *
   * @return The ID of the node to which the new smart contract instance should stake. Returns uninitialized if a value
   *         has not yet been set, or if a staked account ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<uint64_t> getStakedNodeId() const { return mStakedNodeId; }

  /**
   * Get the staking rewards reception policy for the new smart contract instance.
   *
   * @return \c TRUE if the new smart contract instance should decline from receiving staking rewards, otherwise \c
   *         FALSE.
   */
  [[nodiscard]] inline bool getDeclineStakingReward() const { return mDeclineStakingReward; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this ContractCreateTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this ContractCreateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ContractCreateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the ContractCreateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this ContractCreateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ContractCreateTransactionBody protobuf object from this ContractCreateTransaction object.
   *
   * @return A pointer to a ContractCreateTransactionBody protobuf object filled with this ContractCreateTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ContractCreateTransactionBody* build() const;

  /**
   * The ID of the file that contains the smart contract bytecode.
   */
  std::optional<FileId> mBytecodeFileId;

  /**
   * The bytes of the smart contract bytecode.
   */
  std::optional<std::vector<std::byte>> mBytecode;

  /**
   * The admin key for the new smart contract instance.
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The amount of gas required to run the constructor of the new smart contract instance.
   */
  uint64_t mGas = 0ULL;

  /**
   * The initial amount of Hbar to put into the cryptocurrency account associated with and owned by the new smart
   * contract instance.
   */
  Hbar mInitialBalance = Hbar(0LL);

  /**
   * A Hiero smart contract instance is charged to extend its expiration date every renew period. If it doesn't have
   * enough balance, it extends as long as possible. If the balance is zero when it expires, then the smart contract
   * instance is deleted.
   */
  std::chrono::system_clock::duration mAutoRenewPeriod = DEFAULT_AUTO_RENEW_PERIOD;

  /**
   * The parameters to pass to the new smart contract instance's constructor.
   */
  std::vector<std::byte> mConstructorParameters;

  /**
   * The memo to be associated with the smart contract instance (UTF-8 encoding max 100 bytes).
   */
  std::string mMemo;

  /**
   * The maximum number of tokens with which the new smart contract instance can be implicitly associated.
   */
  int32_t mMaxAutomaticTokenAssociations = 0;

  /**
   * The account to charge for auto-renewal of the new smart contract instance.
   */
  std::optional<AccountId> mAutoRenewAccountId;

  /**
   * The ID of the account to which the new smart contract instance will be staked. Mutually exclusive with
   * mStakedNodeId.
   */
  std::optional<AccountId> mStakedAccountId;

  /**
   * The ID of the node to which the new smart contract instance will be staked. Mutually exclusive with
   * mStakedAccountId.
   */
  std::optional<uint64_t> mStakedNodeId;

  /**
   * If \c TRUE, the new smart contract instance will decline receiving staking rewards.
   */
  bool mDeclineStakingReward = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_CREATE_TRANSACTION_H_
// Filename: src/sdk/main/include/ContractDeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_DELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_CONTRACT_DELETE_TRANSACTION_H_

#include "AccountId.h"
#include "ContractId.h"
#include "Transaction.h"

#include <optional>

namespace proto
{
class ContractDeleteTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that deletes a smart contract from a Hiero network. Once a smart contract is marked deleted, you will
 * not be able to modify any of the contract's properties.
 *
 * If a smart contract did not have an admin key defined, you cannot delete the smart contract. You can verify the smart
 * contract was deleted by submitting a smart contract info query to the network. If a smart contract has an associated
 * Hbar balance, you will need to transfer the balance to another Hiero account.
 *
 * Transaction Signing Requirements:
 *  - If the admin key was defined for the smart contract it is required to sign the transaction.
 *  - The client operator's (fee payer account) private key is required to sign the transaction.
 */
class ContractDeleteTransaction : public Transaction<ContractDeleteTransaction>
{
public:
  ContractDeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ContractDeleteInstance transaction.
   */
  explicit ContractDeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit ContractDeleteTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the contract to delete.
   *
   * @param contractId The ID of the contract to delete.
   * @return A reference to this ContractDeleteTransaction object with the newly-set contract ID.
   * @throws IllegalStateException If this ContractDeleteTransaction is frozen.
   */
  ContractDeleteTransaction& setContractId(const ContractId& contractId);

  /**
   * Set the ID of the account that will receive the deleted smart contract's remaining Hbars. This is mutually
   * exclusive with mTransferContractId, and will reset the value of mTransferAccountId if it is set.
   *
   * @param accountId The ID of the account that will receive the deleted smart contract's remaining Hbars.
   * @return A reference to this ContractDeleteTransaction object with the newly-set transfer account ID.
   * @throws IllegalStateException If this ContractDeleteTransaction is frozen.
   */
  ContractDeleteTransaction& setTransferAccountId(const AccountId& accountId);

  /**
   * Set the ID of the contract that will receive the deleted smart contract's remaining Hbars. This is mutually
   * exclusive with mTransferAccountId, and will reset the value of mTransferContractId if it is set.
   *
   * @param contractId The ID of the contract that will receive the deleted smart contract's remaining Hbars.
   * @return A reference to this ContractDeleteTransaction object with the newly-set transfer contract ID.
   * @throws IllegalStateException If this ContractDeleteTransaction is frozen.
   */
  ContractDeleteTransaction& setTransferContractId(const ContractId& contractId);

  /**
   * Get the ID of the contract to delete.
   *
   * @return The ID of the contract to delete.
   */
  [[nodiscard]] inline ContractId getContractId() const { return mContractId; }

  /**
   * Get the ID of the account that will receive the deleted smart contract's remaining Hbars.
   *
   * @return The ID of the account that will receive the deleted smart contract's remaining Hbars. Returns uninitialized
   *         if a value has not yet been set, or if a transfer contract ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<AccountId> getTransferAccountId() const { return mTransferAccountId; }

  /**
   * Get the ID of the contract that will receive the deleted smart contract's remaining Hbars.
   *
   * @return The ID of the contract that will receive the deleted smart contract's remaining Hbars. Returns
   *         uninitialized if a value has not yet been set, or if a transfer account ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<ContractId> getTransferContractId() const { return mTransferContractId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this ContractDeleteTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this ContractDeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ContractDeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the ContractDeleteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this ContractDeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ContractDeleteTransactionBody protobuf object from this ContractDeleteTransaction object.
   *
   * @return A pointer to a ContractDeleteTransactionBody protobuf object filled with this ContractDeleteTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ContractDeleteTransactionBody* build() const;

  /**
   * The ID of the contract to delete.
   */
  ContractId mContractId;

  /**
   * The ID of the account that will receive the deleted smart contract's remaining Hbars.
   */
  std::optional<AccountId> mTransferAccountId;

  /**
   * The ID of the contract that will receive the deleted smart contract's remaining Hbars.
   */
  std::optional<ContractId> mTransferContractId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_DELETE_TRANSACTION_H_
// Filename: src/sdk/main/include/ContractExecuteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_EXECUTE_TRANSACTION_H_
#define HIERO_SDK_CPP_CONTRACT_EXECUTE_TRANSACTION_H_

#include "ContractFunctionParameters.h"
#include "ContractId.h"
#include "Hbar.h"
#include "Transaction.h"

#include <cstddef>
#include <string_view>
#include <vector>

namespace proto
{
class ContractCallTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * The transaction calls a function of the given smart contract instance, giving it functionParameters as its input. The
 * call can use at maximum the given amount of gas – the paying account will not be charged for any unspent gas. If this
 * function results in data being stored, an amount of gas is calculated that reflects this storage burden. The amount
 * of gas used, as well as other attributes of the transaction, e.g. size, and number of signatures to be verified,
 * determine the fee for the transaction – which is charged to the paying account.
 *
 * Transaction Signing Requirements:
 *  - The key of the transaction fee-paying account.
 */
class ContractExecuteTransaction : public Transaction<ContractExecuteTransaction>
{
public:
  ContractExecuteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ContractCall transaction.
   */
  explicit ContractExecuteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit ContractExecuteTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the contract to call.
   *
   * @param fileId The ID of the contract to call.
   * @return A reference to this ContractExecuteTransaction object with the newly-set contract ID.
   * @throws IllegalStateException If this ContractExecuteTransaction is frozen.
   */
  ContractExecuteTransaction& setContractId(const ContractId& contractId);

  /**
   * Set the maximum amount of gas to use for the function call.
   *
   * @param gas The maximum amount of gas to use for the function call.
   * @return A reference to this ContractExecuteTransaction object with the newly-set amount of gas.
   * @throws IllegalStateException If this ContractExecuteTransaction is frozen.
   */
  ContractExecuteTransaction& setGas(const uint64_t& gas);

  /**
   * Set the amount to pay for the function call.
   *
   * @param amount The amount to pay for the function call.
   * @return A reference to this ContractExecuteTransaction object with the newly-set payable amount.
   * @throws IllegalStateException If this ContractExecuteTransaction is frozen.
   */
  ContractExecuteTransaction& setPayableAmount(const Hbar& amount);

  /**
   * Set the function parameters for the function call.
   *
   * @param parameters The parameters to pass to function call.
   * @return A reference to this ContractExecuteTransaction object with the newly-set function parameters.
   * @throws IllegalStateException If this ContractExecuteTransaction is frozen.
   */
  ContractExecuteTransaction& setFunctionParameters(const std::vector<std::byte>& parameters);

  /**
   * Set the function to call, optionally with its parameters.
   *
   * @param name       The name of the function to call.
   * @param parameters The function parameters to pass to the function call.
   * @return A reference to this ContractExecuteTransaction object with the newly-set function name and parameters.
   * @throws IllegalStateException If this ContractExecuteTransaction is frozen.
   */
  ContractExecuteTransaction& setFunction(std::string_view name,
                                          const ContractFunctionParameters& parameters = ContractFunctionParameters());

  /**
   * Get the ID of the contract to call.
   *
   * @return The ID of the contract to call
   */
  [[nodiscard]] inline ContractId getContractId() const { return mContractId; }

  /**
   * Get the maximum amount of gas to use for the function call.
   *
   * @return The maximum amount of gas to use for the function call.
   */
  [[nodiscard]] inline uint64_t getGas() const { return mGas; }

  /**
   * Get the amount to pay for the function call.
   *
   * @return The amount to pay for the function call.
   */
  [[nodiscard]] inline Hbar getPayableAmount() const { return mPayableAmount; }

  /**
   * Get the function parameters for the function call.
   *
   * @return The function parameters for the function call.
   */
  [[nodiscard]] inline std::vector<std::byte> getFunctionParameters() const { return mFunctionParameters; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this ContractExecuteTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this ContractExecuteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ContractExecuteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the ContractExecuteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this ContractExecuteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ContractCallTransactionBody protobuf object from this ContractExecuteTransaction object.
   *
   * @return A pointer to a ContractCallTransactionBody protobuf object filled with this ContractExecuteTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ContractCallTransactionBody* build() const;

  /**
   * The ID of the contract to call.
   */
  ContractId mContractId;

  /**
   * The maximum amount of gas to use for the function call.
   */
  uint64_t mGas = 0ULL;

  /**
   * The amount to pay for the function call
   */
  Hbar mPayableAmount = Hbar(0LL);

  /**
   * The function parameters for the function call.
   */
  std::vector<std::byte> mFunctionParameters;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_EXECUTE_TRANSACTION_H_
// Filename: src/sdk/main/include/ContractFunctionParameters.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_FUNCTION_PARAMETERS_H_
#define HIERO_SDK_CPP_CONTRACT_FUNCTION_PARAMETERS_H_

#include "ContractFunctionSelector.h"

#include <cstddef>
#include <string_view>
#include <vector>

namespace Hiero
{
class ContractFunctionParameters
{
public:
  /**
   * Add a string parameter type.
   *
   * @param param The string parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added string parameter.
   */
  ContractFunctionParameters& addString(std::string_view param);

  /**
   * Add a string array parameter type.
   *
   * @param param The string array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added string array parameter.
   */
  ContractFunctionParameters& addStringArray(const std::vector<std::string>& param);

  /**
   * Add a bytes parameter type.
   *
   * @param param The bytes parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added bytes parameter.
   */
  ContractFunctionParameters& addBytes(const std::vector<std::byte>& param);

  /**
   * Add a bytes array parameter type.
   *
   * @param param The bytes array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added bytes array parameter.
   */
  ContractFunctionParameters& addBytesArray(const std::vector<std::vector<std::byte>>& param);

  /**
   * Add a bytes32 parameter type.
   *
   * @param param The bytes32 parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added bytes32 parameter.
   * @throws std::invalid_argument If the byte array length is greater than 32.
   */
  ContractFunctionParameters& addBytes32(const std::vector<std::byte>& param);

  /**
   * Add a bytes32 array parameter type.
   *
   * @param param The bytes32 array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added bytes32 array parameter.
   * @throws std::invalid_argument If any of the byte array lengths are greater than 32.
   */
  ContractFunctionParameters& addBytes32Array(const std::vector<std::vector<std::byte>>& param);

  /**
   * Add a bool parameter type.
   *
   * @param param The bool parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added bool parameter.
   */
  ContractFunctionParameters& addBool(bool param);

  /**
   * Add an int8 parameter type.
   *
   * @param param The int8 parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added int8 parameter.
   */
  ContractFunctionParameters& addInt8(int8_t param);

  /**
   * Add an int32 parameter type.
   *
   * @param param The int32 parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added int32 parameter.
   */
  ContractFunctionParameters& addInt32(int32_t param);

  /**
   * Add an int64 parameter type.
   *
   * @param param The int64 parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added int64 parameter.
   */
  ContractFunctionParameters& addInt64(int64_t param);

  /**
   * Add an int256 parameter type.
   *
   * @param param The int256 parameter to add, as a byte array.
   * @return A reference to this ContractFunctionParameters with the newly-added int256 parameter.
   * @throws std::invalid_argument If in the input byte array isn't 32 bytes.
   */
  ContractFunctionParameters& addInt256(const std::vector<std::byte>& param);

  /**
   * Add an int8 array parameter type.
   *
   * @param param The int8 array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added int8 array parameter.
   */
  ContractFunctionParameters& addInt8Array(const std::vector<int8_t>& param);

  /**
   * Add an int32 array parameter type.
   *
   * @param param The int32 array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added int32 array parameter.
   */
  ContractFunctionParameters& addInt32Array(const std::vector<int32_t>& param);

  /**
   * Add an int64 array parameter type.
   *
   * @param param The int64 array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added int64 array parameter.
   */
  ContractFunctionParameters& addInt64Array(const std::vector<int64_t>& param);

  /**
   * Add an int256 array parameter type.
   *
   * @param param The int256 array parameter to add, as an array of byte arrays.
   * @return A reference to this ContractFunctionParameters with the newly-added int256 array parameter.
   */
  ContractFunctionParameters& addInt256Array(const std::vector<std::vector<std::byte>>& param);

  /**
   * Add a uint8 parameter type.
   *
   * @param param The uint8 parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added uint8 parameter.
   */
  ContractFunctionParameters& addUint8(uint8_t param);

  /**
   * Add a uint32 parameter type.
   *
   * @param param The uint32 parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added uint32 parameter.
   */
  ContractFunctionParameters& addUint32(uint32_t param);

  /**
   * Add a uint64 parameter type.
   *
   * @param param The uint64 parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added uint64 parameter.
   */
  ContractFunctionParameters& addUint64(uint64_t param);

  /**
   * Add a uint256 parameter type.
   *
   * @param param The uint256 parameter to add, as a byte array.
   * @return A reference to this ContractFunctionParameters with the newly-added uint256 parameter.
   * @throws std::invalid_argument If in the input byte array isn't 32 bytes.
   */
  ContractFunctionParameters& addUint256(const std::vector<std::byte>& param);

  /**
   * Add a uint8 array parameter type.
   *
   * @param param The uint8 array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added uint8 array parameter.
   */
  ContractFunctionParameters& addUint8Array(const std::vector<uint8_t>& param);

  /**
   * Add a uint32 array parameter type.
   *
   * @param param The uint32 array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added uint32 array parameter.
   */
  ContractFunctionParameters& addUint32Array(const std::vector<uint32_t>& param);

  /**
   * Add a uint64 array parameter type.
   *
   * @param param The uint64 array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added uint64 array parameter.
   */
  ContractFunctionParameters& addUint64Array(const std::vector<uint64_t>& param);

  /**
   * Add a uint256 array parameter type.
   *
   * @param param The uint256 array parameter to add, as an array of byte arrays.
   * @return A reference to this ContractFunctionParameters with the newly-added uint256 array parameter.
   */
  ContractFunctionParameters& addUint256Array(const std::vector<std::vector<std::byte>>& param);

  /**
   * Add a Solidity address parameter type.
   *
   * @param param The Solidity address parameter to add, as a string.
   * @return A reference to this ContractFunctionParameters with the newly-added address parameter.
   * @throws std::invalid_argument If the input address is malformed.
   */
  ContractFunctionParameters& addAddress(std::string_view param);

  /**
   * Add a Solidity address array parameter type.
   *
   * @param param The Solidity address array parameter to add.
   * @return A reference to this ContractFunctionParameters with the newly-added address array parameter.
   * @throws std::invalid_argument If any input address is malformed.
   */
  ContractFunctionParameters& addAddressArray(const std::vector<std::string>& param);

  /**
   * Add a Solidity function parameter type.
   *
   * @param address  The Solidity address of the function.
   * @param selector The ContractFunctionSelector to use to call the function, or the selector bytes.
   * @return A reference to this ContractFunctionParameters with the newly-added function parameter.
   * @throws std::invalid_argument If the input address is malformed.
   */
  ContractFunctionParameters& addFunction(std::string_view address, const ContractFunctionSelector& selector);
  ContractFunctionParameters& addFunction(std::string_view address, const std::vector<std::byte>& selector);

  /**
   * Get the encoding of the currently-added parameters.
   *
   * @param name The name of the function to which these parameters are being passed.
   * @return The encoding of the function parameters.
   */
  [[nodiscard]] std::vector<std::byte> toBytes(std::string_view name = "") const;

private:
  /**
   * Wrapper struct to hold argument data.
   */
  struct Argument
  {
    Argument(std::vector<std::byte> value, bool dynamic)
      : mValue(std::move(value))
      , mIsDynamic(dynamic)
    {
    }

    /**
     * The argument data.
     */
    std::vector<std::byte> mValue;

    /**
     * Is this argument dynamic?
     */
    bool mIsDynamic = false;
  };

  /**
   * The list of arguments to add ot the function call.
   */
  std::vector<Argument> mArguments;

  /**
   * The contract function to call.
   */
  ContractFunctionSelector mFunction;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_FUNCTION_PARAMETERS_H_
// Filename: src/sdk/main/include/ContractFunctionResult.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_FUNCTION_RESULT_H_
#define HIERO_SDK_CPP_CONTRACT_FUNCTION_RESULT_H_

#include "AccountId.h"
#include "ContractId.h"
#include "ContractLogInfo.h"
#include "ContractNonceInfo.h"
#include "EvmAddress.h"
#include "Hbar.h"

#include <cstddef>
#include <memory>
#include <optional>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class ContractFunctionResult;
}

namespace Hiero
{
/**
 * Class to represent the result of invoking a contract via ContractCallQuery, ContractExecuteTransaction, or the result
 * of a contract constructor being called by ContractCreateTransaction.
 */
class ContractFunctionResult
{
public:
  /**
   * The error prefix representing an error in contract execution.
   */
  static inline const std::vector<std::byte> ERROR_PREFIX = { std::byte(8),
                                                              std::byte(-61),
                                                              std::byte(121),
                                                              std::byte(-96) };

  /**
   * Construct a ContractFunctionResult object from a ContractFunctionResult protobuf object.
   *
   * @param proto The ContractFunctionResult protobuf object from which to construct a ContractFunctionResult object.
   * @return The constructed ContractFunctionResult object.
   */
  [[nodiscard]] static ContractFunctionResult fromProtobuf(const proto::ContractFunctionResult& proto);

  /**
   * Construct a ContractFunctionResult object from a byte array.
   *
   * @param bytes The byte array from which to construct a ContractFunctionResult object.
   * @return The constructed ContractFunctionResult object.
   */
  [[nodiscard]] static ContractFunctionResult fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a ContractFunctionResult protobuf object from this ContractFunctionResult object.
   *
   * @return A pointer to the created ContractFunctionResult protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::ContractFunctionResult> toProtobuf() const;

  /**
   * Construct a representative byte array from this ContractFunctionResult object.
   *
   * @return The byte array representing this ContractFunctionResult object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this ContractFunctionResult object.
   *
   * @return The string representation of this ContractFunctionResult object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this ContractFunctionResult to an output stream.
   *
   * @param os     The output stream.
   * @param result The ContractFunctionResult to print.
   * @return The output stream with this ContractFunctionResult written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const ContractFunctionResult& result);

  /**
   * Get the value at the input index as a string.
   *
   * @param index The index at which to retrieve the string.
   * @return The value at the input index as a string.
   */
  [[nodiscard]] std::string getString(int index) const;

  /**
   * Get the value at the input index as a string array.
   *
   * @param index The index at which to retrieve the string array.
   * @return The value at the input index as a string array.
   */
  [[nodiscard]] std::vector<std::string> getStringArray(int index) const;

  /**
   * Get the value at the input index as a byte array.
   *
   * @param index The index at which to retrieve the byte array.
   * @return The value at the input index as a byte array.
   */
  [[nodiscard]] std::vector<std::byte> getByteArray(int index) const;

  /**
   * Get the value at the input index as a Solidity 32-byte value.
   *
   * @param index The index at which to retrieve the 32-byte value.
   * @return The value at the input index as a 32-byte value.
   */
  [[nodiscard]] std::vector<std::byte> getBytes32(int index) const;

  /**
   * Get the value at the input index as a boolean.
   *
   * @param index The index at which to retrieve the boolean value.
   * @return The value at the input index as a bool value.
   */
  [[nodiscard]] bool getBool(int index) const;

  /**
   * Get the value at the input index as a signed 8-bit integer. If the actual value is wider, it will be truncated to
   * the last byte.
   *
   * @param index The index at which to retrieve the signed 8-bit integer value.
   * @return The value at the input index as a signed 8-bit integer value.
   */
  [[nodiscard]] int8_t getInt8(int index) const;

  /**
   * Get the value at the input index as a signed 32-bit integer. If the actual value is wider, it will be truncated to
   * the last 4 bytes.
   *
   * @param index The index at which to retrieve the signed 32-bit integer value.
   * @return The value at the input index as a signed 32-bit integer value.
   */
  [[nodiscard]] int32_t getInt32(int index) const;

  /**
   * Get the value at the input index as a signed 64-bit integer. If the actual value is wider, it will be truncated to
   * the last 8 bytes.
   *
   * @param index The index at which to retrieve the signed 64-bit integer value.
   * @return The value at the input index as a signed 64-bit integer value.
   */
  [[nodiscard]] int64_t getInt64(int index) const;

  /**
   * Get the value at the input index as an unsigned 8-bit integer. If the actual value is wider, it will be truncated
   * to the last byte.
   *
   * @param index The index at which to retrieve the unsigned 8-bit integer value.
   * @return The value at the input index as an unsigned 8-bit integer value.
   */
  [[nodiscard]] uint8_t getUint8(int index) const;

  /**
   * Get the value at the input index as an unsigned 32-bit integer. If the actual value is wider, it will be truncated
   * to the last 4 bytes.
   *
   * @param index The index at which to retrieve the unsigned 32-bit integer value.
   * @return The value at the input index as an unsigned 32-bit integer value.
   */
  [[nodiscard]] uint32_t getUint32(int index) const;

  /**
   * Get the value at the input index as an unsigned 64-bit integer. If the actual value is wider, it will be truncated
   * to the last 8 bytes.
   *
   * @param index The index at which to retrieve the unsigned 64-bit integer value.
   * @return The value at the input index as an unsigned 64-bit integer value.
   */
  [[nodiscard]] uint64_t getUint64(int index) const;

  /**
   * Get the value at the input index as a Solidity address.
   *
   * @param index The index at which to retrieve the Solidity address value.
   * @return The value at the input index as a Solidity address value.
   */
  [[nodiscard]] std::string getAddress(int index) const;

  /**
   * The ID of the contract whose functions was called.
   */
  ContractId mContractId;

  /**
   * The result returned by the function.
   */
  std::vector<std::byte> mContractCallResult;

  /**
   * The error message, in case there was an error during smart contract execution.
   */
  std::string mErrorMessage;

  /**
   * The bloom filter for the record.
   */
  std::vector<std::byte> mBloom;

  /**
   * The units of gas used to execute the contract.
   */
  uint64_t mGasUsed = 0ULL;

  /**
   * The log info for events returned by the function.
   */
  std::vector<ContractLogInfo> mLogs;

  /**
   * The created contract's 20-byte EVM address.
   */
  std::optional<EvmAddress> mEvmAddress;

  /**
   * The amount of gas available for the call, aka the gasLimit.
   *
   * This field should only be populated when the paired TransactionBody in the record stream is not a
   * ContractCreateTransactionBody or a ContractCallTransactionBody.
   */
  uint64_t mGas = 0ULL;

  /**
   * The amount sent (the function must be payable if this is nonzero).
   *
   * This field should only be populated when the paired TransactionBody in the record stream is not a
   * ContractCreateTransactionBody or a ContractCallTransactionBody.
   */
  Hbar mHbarAmount;

  /**
   * The parameters passed into the contract call.
   *
   * This field should only be populated when the paired TransactionBody in the record stream is not a
   * ContractCreateTransactionBody or a ContractCallTransactionBody.
   */
  std::vector<std::byte> mFunctionParameters;

  /**
   * The account that is the "sender." If not present it is the account ID from the transaction ID.
   *
   * This field should only be populated when the paired TransactionBody in the record stream is not a
   * ContractCreateTransactionBody or a ContractCallTransactionBody.
   */
  AccountId mSenderAccountId;

  /**
   * A vector of updated contract account nonces containing the new nonce value for each contract account. This is
   * always empty in a ContractCallLocalResponse#ContractFunctionResult message, since no internal creations can happen
   * in a static EVM call.
   */
  std::vector<ContractNonceInfo> mContractNonces;

  /**
   * If not null this field specifies what the value of the signer account nonce is post transaction execution.
   * For transactions that don't update the signer nonce, this field should be null.
   */
  std::optional<int64_t> mSignerNonce;

private:
  /**
   * Get bytes that are a dynamic size.
   *
   * @param index The index at which to find the bytes.
   * @return The bytes of the proper size.
   */
  [[nodiscard]] std::vector<std::byte> getDynamicBytes(int index) const;

  /**
   * Get the 32-bit integer value at a specific index.
   *
   * @param index The index from which to get the 32-bit integer.
   * @return The 32-bit integer at the input index.
   */
  [[nodiscard]] int getIntValueAt(int index) const;

  /**
   * Get the bytes at a specific start index all the way to a specific end index.
   *
   * @param start The starting index of the bytes to retrieve.
   * @param end   The ending index of the bytes to retrieve.
   * @return The bytes between the start and end indices.
   */
  [[nodiscard]] std::vector<std::byte> getByteString(int start, int end) const;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_FUNCTION_RESULT_H_
// Filename: src/sdk/main/include/ContractFunctionSelector.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_FUNCTION_SELECTOR_H_
#define HIERO_SDK_CPP_CONTRACT_FUNCTION_SELECTOR_H_

#include <cstddef>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero
{
class ContractFunctionSelector
{
public:
  /**
   * Add a string parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added string parameter.
   */
  ContractFunctionSelector& addString();

  /**
   * Add a string array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added string array parameter.
   */
  ContractFunctionSelector& addStringArray();

  /**
   * Add a bytes parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added bytes parameter.
   */
  ContractFunctionSelector& addBytes();

  /**
   * Add a bytes array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added bytes array parameter.
   */
  ContractFunctionSelector& addBytesArray();

  /**
   * Add a bytes32 parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added bytes32 parameter.
   */
  ContractFunctionSelector& addBytes32();

  /**
   * Add a bytes32 array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added bytes32 array parameter.
   */
  ContractFunctionSelector& addBytes32Array();

  /**
   * Add a bool parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added bool parameter.
   */
  ContractFunctionSelector& addBool();

  /**
   * Add an int8 parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added int8 parameter.
   */
  ContractFunctionSelector& addInt8();

  /**
   * Add an int32 parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added int32 parameter.
   */
  ContractFunctionSelector& addInt32();

  /**
   * Add an int64 parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added int64 parameter.
   */
  ContractFunctionSelector& addInt64();

  /**
   * Add an int256 parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added int256 parameter.
   */
  ContractFunctionSelector& addInt256();

  /**
   * Add an int8 array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added int8 array parameter.
   */
  ContractFunctionSelector& addInt8Array();

  /**
   * Add an int32 array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added int32 array parameter.
   */
  ContractFunctionSelector& addInt32Array();

  /**
   * Add an int64 array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added int64 array parameter.
   */
  ContractFunctionSelector& addInt64Array();

  /**
   * Add an int256 array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added int256 array parameter.
   */
  ContractFunctionSelector& addInt256Array();

  /**
   * Add a uint8 parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added uint8 parameter.
   */
  ContractFunctionSelector& addUint8();

  /**
   * Add a uint32 parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added uint32 parameter.
   */
  ContractFunctionSelector& addUint32();

  /**
   * Add a uint64 parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added uint64 parameter.
   */
  ContractFunctionSelector& addUint64();

  /**
   * Add a uint256 parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added uint256 parameter.
   */
  ContractFunctionSelector& addUint256();

  /**
   * Add a uint8 array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added uint8 array parameter.
   */
  ContractFunctionSelector& addUint8Array();

  /**
   * Add a uint32 array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added uint32 array parameter.
   */
  ContractFunctionSelector& addUint32Array();

  /**
   * Add a uint64 array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added uint64 array parameter.
   */
  ContractFunctionSelector& addUint64Array();

  /**
   * Add a uint256 array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added uint256 array parameter.
   */
  ContractFunctionSelector& addUint256Array();

  /**
   * Add an address parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added address parameter.
   */
  ContractFunctionSelector& addAddress();

  /**
   * Add an address array parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added address array parameter.
   */
  ContractFunctionSelector& addAddressArray();

  /**
   * Add a function parameter.
   *
   * @return A reference to this ContractFunctionSelector with the newly-added function parameter.
   */
  ContractFunctionSelector& addFunction();

  /**
   * Get the function selector bytes for all currently added parameters.
   *
   * @param name The name of the function.
   * @return The Solidity function selector bytes.
   */
  [[nodiscard]] std::vector<std::byte> finish(std::string_view name = "") const;

private:
  /**
   * Add a Solidity parameter to this function selector.
   *
   * @param type The name of the type to add.
   * @return A reference to this ContractFunctionSelector with the newly-added parameter.
   */
  ContractFunctionSelector& addParameter(std::string_view type);

  /**
   * The bytes of the function.
   */
  std::vector<std::byte> mFunctionCall;

  /**
   * Should a comma be added before adding a parameter?
   */
  bool addComma = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_FUNCTION_SELECTOR_H_
// Filename: src/sdk/main/include/ContractId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_ID_H_
#define HIERO_SDK_CPP_CONTRACT_ID_H_

#include "EvmAddress.h"
#include "Key.h"

#include <cstddef>
#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class ContractID;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * The ID for a smart contract instance.
 */
class ContractId : public Key
{
public:
  ContractId() = default;

  /**
   * Construct with a contract number.
   *
   * @param num The contract number.
   */
  explicit ContractId(uint64_t num);

  /**
   * Construct with an EVM address.
   *
   * @param address The EVM address.
   */
  explicit ContractId(const EvmAddress& address);

  /**
   * Construct with a shard, realm, a contract number, and optionally a checksum.
   *
   * @param shard    The shard number.
   * @param realm    The realm number.
   * @param num      The contract number.
   * @param checksum The checksum.
   */
  explicit ContractId(uint64_t shard, uint64_t realm, uint64_t num, std::string_view checksum = "");

  /**
   * Construct with shard and realm numbers, and an EVM address.
   *
   * @param shard   The shard number.
   * @param realm   The realm number.
   * @param address The EVM address.
   */
  explicit ContractId(uint64_t shard, uint64_t realm, const EvmAddress& address);

  /**
   * Compare this ContractId to another ContractId and determine if they represent the same contract.
   *
   * @param other The other ContractId with which to compare this ContractId.
   * @return \c TRUE if this ContractId is the same as the input ContractId, otherwise \c FALSE.
   */
  bool operator==(const ContractId& other) const;

  /**
   * Construct a ContractId object from a string of the form "<shard>.<realm>.<num>". <num> can be the contract number
   * or a stringified EVM address.
   *
   * @param id The contract ID string from which to construct.
   * @return The constructed ContractId object.
   * @throws std::invalid_argument If the input string is malformed or the type of <num> cannot be determined.
   */
  [[nodiscard]] static ContractId fromString(std::string_view id);

  /**
   * Construct a ContractId object from a string that represents an EvmAddress and, optionally, a shard and realm
   * number.
   *
   * @param evmAddress The string that represents an EvmAddress.
   * @param shard      The shard number.
   * @param realm      The realm number.
   * @return The constructed ContractId object.
   * @throws std::invalid_argument If the input string is malformed.
   * @throws OpenSSLException If OpenSSL is unable to convert the string to a byte array.
   */
  [[nodiscard]] static ContractId fromEvmAddress(std::string_view evmAddress,
                                                 uint64_t shard = 0ULL,
                                                 uint64_t realm = 0ULL);

  /**
   * Construct a ContractId object from an EvmAddress object and, optionally, a shard and realm number.
   *
   * @param evmAddress The EvmAddress from which to construct a ContractId.
   * @param shard      The shard number.
   * @param realm      The realm number.
   * @return The constructed ContractId object.
   */
  [[nodiscard]] static ContractId fromEvmAddress(const EvmAddress& evmAddress,
                                                 uint64_t shard = 0ULL,
                                                 uint64_t realm = 0ULL);

  /**
   * Construct a ContractId from a Solidity address.
   *
   * @param address The Solidity address from which to create a ContractId, as a string.
   * @return The constructed ContractId object.
   * @throws std::invalid_argument If a Solidity address cannot be realized from the input string.
   */
  [[nodiscard]] static ContractId fromSolidityAddress(std::string_view address);

  /**
   * Construct an ContractId object from an ContractID protobuf object.
   *
   * @param proto The ContractID protobuf object from which to create an ContractId object.
   * @return The constructed ContractId object.
   */
  [[nodiscard]] static ContractId fromProtobuf(const proto::ContractID& id);

  /**
   * Construct a ContractId object from a representative byte array.
   *
   * @param bytes The byte array from which to construct a ContractId object.
   * @return The constructed ContractId object.
   */
  [[nodiscard]] static ContractId fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Derived from Key. Create a clone of this ContractId object.
   *
   * @return A pointer to the created clone of this ContractId.
   */
  [[nodiscard]] std::unique_ptr<Key> clone() const override;

  /**
   * Derived from Key. Construct a Key protobuf object from this ContractId object.
   *
   * @return A pointer to the created Key protobuf object filled with this ContractId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::Key> toProtobufKey() const override;

  /**
   * Derived from Key. Get a byte array representation of this ContractId object.
   *
   * @return A byte array representation of this ContractId object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const override;

  /**
   * Verify the checksum of this ContractId using the input Client's network. Does nothing if this ContractId does not
   * use a contract number (i.e. it contains an EvmAddress).
   *
   * @param client The Client with which to validate this ContractId's checksum.
   * @throws BadEntityException If the checksum of this ContractId is invalid.
   */
  void validateChecksum(const Client& client) const;

  /**
   * Construct a ContractID protobuf object from this ContractId object.
   *
   * @return A pointer to the created ContractID protobuf object filled with this ContractId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::ContractID> toProtobuf() const;

  /**
   * Get the Solidity address representation of this ContractId (Long-Zero address form).
   *
   * @return The Solidity address representation of this ContractId.
   */
  [[nodiscard]] std::string toSolidityAddress() const;

  /**
   * Get the string representation of this ContractId object.
   *
   * @return The string representation of this ContractId.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Get the string representation of this ContractId object with the checksum.
   *
   * @param client The Client with which to generate the checksum.
   * @return The string representation of this ContractId object with the checksum.
   * @throws IllegalStateException If this ContractId contains an alias.
   */
  [[nodiscard]] std::string toStringWithChecksum([[maybe_unused]] const Client& client) const;

  /**
   * Get the checksum of this ContractId.
   *
   * @return The checksum of this ContractId.
   */
  [[nodiscard]] inline std::string getChecksum() const { return mChecksum; }

  /**
   * The shard number.
   */
  uint64_t mShardNum = 0ULL;

  /**
   * The realm number.
   */
  uint64_t mRealmNum = 0ULL;

  /**
   * The contract number.
   */
  std::optional<uint64_t> mContractNum;

  /**
   * The 20-byte EVM address of the contract.
   *
   * Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id. This address is as follows:
   *  - The first 4 bytes are the big-endian representation of the shard.
   *  - The next 8 bytes are the big-endian representation of the realm.
   *  - The final 8 bytes are the big-endian representation of the number.
   *
   * Contracts created via CREATE2 have an additional, primary address that is derived from the EIP-1014 specification,
   * and does not have a simple relation to a shard.realm.num id.
   *
   * (Please do note that CREATE2 contracts can also be referenced by the three-part EVM address described above.)
   */
  std::optional<EvmAddress> mEvmAddress;

private:
  /**
   * The checksum of this ContractId.
   */
  mutable std::string mChecksum;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_ID_H_
// Filename: src/sdk/main/include/ContractInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_INFO_H_
#define HIERO_SDK_CPP_CONTRACT_INFO_H_

#include "AccountId.h"
#include "ContractId.h"
#include "Hbar.h"
#include "Key.h"
#include "LedgerId.h"
#include "StakingInfo.h"
#include "TokenId.h"
#include "TokenRelationship.h"

#include <chrono>
#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>

namespace proto
{
class ContractGetInfoResponse_ContractInfo;
}

namespace Hiero
{
/**
 * Contains information about a smart contract instance. This includes the account that it uses, the file containing its
 * initcode (if a file was used to initialize the contract), and the time when it will expire.
 */
class ContractInfo
{
public:
  /**
   * Construct a ContractInfo object from a ContractGetInfoResponse_ContractInfo protobuf object.
   *
   * @param proto The ContractGetInfoResponse_ContractInfo protobuf object from which to construct a ContractInfo
   *              object.
   * @return The constructed ContractInfo object.
   */
  [[nodiscard]] static ContractInfo fromProtobuf(const proto::ContractGetInfoResponse_ContractInfo& proto);

  /**
   * Construct a ContractInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a ContractInfo object.
   * @return The constructed ContractInfo object.
   */
  [[nodiscard]] static ContractInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a ContractGetInfoResponse_ContractInfo protobuf object from this ContractInfo object.
   *
   * @return A pointer to the created ContractGetInfoResponse_ContractInfo protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::ContractGetInfoResponse_ContractInfo> toProtobuf() const;

  /**
   * Construct a representative byte array from this ContractInfo object.
   *
   * @return The byte array representing this ContractInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this ContractInfo object.
   *
   * @return The string representation of this ContractInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this ContractInfo to an output stream.
   *
   * @param os   The output stream.
   * @param info The ContractInfo to print.
   * @return The output stream with this ContractInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const ContractInfo& info);

  /**
   * The ID of the contract.
   */
  ContractId mContractId;

  /**
   * The ID of the account that is owned by the contract.
   */
  AccountId mAccountId;

  /**
   * The ID of both the contract and the account owned by the contract, in the format used by Solidity.
   */
  std::string mContractAccountId;

  /**
   * Pointer to the admin key that can be used to modify the state of the contract.
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The expiration time of the queried contract and its account.
   */
  std::chrono::system_clock::time_point mExpirationTime;

  /**
   * The duration of time the queried contract uses to automatically extend its expiration period.
   */
  std::chrono::system_clock::duration mAutoRenewPeriod;

  /**
   * Get the number of bytes of storage the queried contract is using (which affects the cost to extend the expiration
   * time).
   */
  uint64_t mStorage = 0ULL;

  /**
   * The contract memo.
   */
  std::string mMemo;

  /**
   * The current contract balance.
   */
  Hbar mBalance = Hbar(0LL);

  /**
   * Has this contract been deleted?
   */
  bool mIsDeleted = false;

  /**
   * The ledger ID from which the response was returned.
   */
  LedgerId mLedgerId;

  /**
   * The ID of the account to charge for auto-renewal. If not set, or set to an account with zero Hbar balance, the
   * contract's own Hbar balance will be used to cover auto-renewal fees.
   */
  std::optional<AccountId> mAutoRenewAccountId;

  /**
   * The maximum number of token associations for this contract.
   */
  int32_t mMaxAutomaticTokenAssociations = 0U;

  /**
   * The staking metadata for this contract.
   */
  StakingInfo mStakingInfo;

  /**
   * The token relationships mappings for the queried account.
   */
  std::unordered_map<TokenId, TokenRelationship> mTokenRelationships;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_INFO_H_
// Filename: src/sdk/main/include/ContractInfoQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_INFO_QUERY_H_
#define HIERO_SDK_CPP_CONTRACT_INFO_QUERY_H_

#include "ContractId.h"
#include "Query.h"

namespace Hiero
{
class ContractInfo;
}

namespace Hiero
{
/**
 * A query that returns the current state of a smart contract instance, including its balance. Queries do not change the
 * state of the smart contract or require network consensus. The information is returned from a single node processing
 * the query.
 *
 * Query Signing Requirements:
 *  - The client operator account's private key (fee payer) is required to sign this query.
 */
class ContractInfoQuery : public Query<ContractInfoQuery, ContractInfo>
{
public:
  /**
   * Set the ID of the contract of which to request the info.
   *
   * @param contractId The ID of the contract of which to request the info.
   * @return A reference to this ContractInfoQuery object with the newly-set account ID.
   */
  ContractInfoQuery& setContractId(const ContractId& contractId);

  /**
   * Get the ID of the contract of which this query is currently configured to get the info.
   *
   * @return The ID of the contract for which this query is meant.
   */
  [[nodiscard]] inline ContractId getContractId() { return mContractId; }

private:
  /**
   * Derived from Executable. Construct a ContractInfo object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a ContractInfo object.
   * @return A ContractInfo object filled with the Response protobuf object's data
   */
  [[nodiscard]] ContractInfo mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this ContractInfoQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this ContractInfoQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ContractInfoQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this ContractInfoQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the contract of which this query should get the info.
   */
  ContractId mContractId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_INFO_QUERY_H_
// Filename: src/sdk/main/include/ContractLogInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_LOG_INFO_H_
#define HIERO_SDK_CPP_CONTRACT_LOG_INFO_H_

#include "ContractId.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class ContractLoginfo;
}

namespace Hiero
{
/**
 * The log information for an event returned by a smart contract function call. One function call may return several
 * such events.
 */
class ContractLogInfo
{
public:
  /**
   * Construct a ContractLogInfo object from a ContractLoginfo protobuf object.
   *
   * @param proto The ContractLoginfo protobuf object from which to construct a ContractLogInfo object.
   * @return The constructed ContractLogInfo object.
   */
  [[nodiscard]] static ContractLogInfo fromProtobuf(const proto::ContractLoginfo& proto);

  /**
   * Construct a ContractLogInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a TransactionRecord object.
   * @return The constructed ContractLogInfo object.
   */
  [[nodiscard]] static ContractLogInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a ContractLoginfo protobuf object from this ContractLogInfo object.
   *
   * @return A pointer to the created ContractLoginfo protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::ContractLoginfo> toProtobuf() const;

  /**
   * Construct a representative byte array from this ContractLogInfo object.
   *
   * @return The byte array representing this ContractLogInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this ContractLogInfo object.
   *
   * @return The string representation of this ContractLogInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this ContractLogInfo to an output stream.
   *
   * @param os      The output stream.
   * @param logInfo The ContractLogInfo to print.
   * @return The output stream with this ContractLogInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const ContractLogInfo& logInfo);

  /**
   * The ID of the contract that emitted this log event.
   */
  ContractId mContractId;

  /**
   * The bloom filter for this particular log event.
   */
  std::vector<std::byte> mBloom;

  /**
   * The topics for this particular log event.
   */
  std::vector<std::vector<std::byte>> mTopics;

  /**
   * The log event data.
   */
  std::vector<std::byte> mData;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_LOG_INFO_H_
// Filename: src/sdk/main/include/ContractNonceInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_NONCE_INFO_H_
#define HIERO_SDK_CPP_CONTRACT_NONCE_INFO_H_

#include "ContractId.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class ContractNonceInfo;
}

namespace Hiero
{
/**
 * Info about a contract account's nonce value.
 * A nonce of a contract is only incremented when that contract creates another contract.
 */
class ContractNonceInfo
{
public:
  ContractNonceInfo() = default;

  /**
   * Construct with a contract ID and nonce.
   *
   * @param contractId The ID of the contract.
   * @param nonce      The nonce.
   */
  ContractNonceInfo(ContractId contractId, int64_t nonce);

  /**
   * Compare this ContractNonceInfo to another ContractNonceInfo and determine if they represent the same nonce for a
   * specific ContractId.
   *
   * @param other The other ContractNonceInfo with which to compare this ContractNonceInfo.
   * @return \c TRUE if this ContractNonceInfo is the same as the input ContractNonceInfo, otherwise \c FALSE.
   */
  bool operator==(const ContractNonceInfo& other) const;

  /**
   * Construct a ContractNonceInfo object from a ContractNonceInfo protobuf object.
   *
   * @param proto The ContractNonceInfo protobuf object from which to construct a ContractNonceInfo object.
   * @return The constructed ContractNonceInfo object.
   */
  [[nodiscard]] static ContractNonceInfo fromProtobuf(const proto::ContractNonceInfo& proto);

  /**
   * Construct a ContractNonceInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a TransactionRecord object.
   * @return The constructed ContractNonceInfo object.
   */
  [[nodiscard]] static ContractNonceInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a ContractNonceInfo protobuf object from this ContractNonceInfo object.
   *
   * @return A pointer to the created ContractNonceInfo protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::ContractNonceInfo> toProtobuf() const;

  /**
   * Construct a representative byte array from this ContractNonceInfo object.
   *
   * @return The byte array representing this ContractNonceInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this ContractNonceInfo object.
   *
   * @return The string representation of this ContractNonceInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this ContractNonceInfo to an output stream.
   *
   * @param os        The output stream.
   * @param nonceInfo The ContractNonceInfo to print.
   * @return The output stream with this ContractNonceInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const ContractNonceInfo& nonceInfo);

  /**
   * The ID of the contract.
   */
  ContractId mContractId;

  /**
   * The current value of the contract account's nonce property.
   */
  int64_t mNonce = 0LL;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_NONCE_INFO_H_
// Filename: src/sdk/main/include/ContractUpdateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CONTRACT_UPDATE_TRANSACTION_H_
#define HIERO_SDK_CPP_CONTRACT_UPDATE_TRANSACTION_H_

#include "AccountId.h"
#include "ContractId.h"
#include "Key.h"
#include "Transaction.h"

#include <chrono>
#include <memory>
#include <optional>
#include <string>
#include <string_view>

namespace proto
{
class ContractUpdateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that allows you to modify the smart contract entity state like admin keys, proxy account, auto-renew
 * period, and memo. This transaction does not update the contract that is tied to the smart contract entity. The
 * contract tied to the entity is immutable. The contract entity is immutable if an admin key is not specified. Once the
 * transaction has been successfully executed on a Hiero network the previous field values will be updated with the new
 * ones. To get a previous state of a smart contract instance, you can query a mirror node for that data. Any null field
 * is ignored (left unchanged).
 *
 * Transaction Signing Requirements:
 *  - If only the expiration time is being modified, then no signature is needed on this transaction other than for the
 *    account paying for the transaction itself.
 *  - If any other smart contract entity property is being modified, the transaction must be signed by the admin key.
 *  - If the admin key is being updated, the new key must sign.
 */
class ContractUpdateTransaction : public Transaction<ContractUpdateTransaction>
{
public:
  ContractUpdateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ContractUpdateInstance transaction.
   */
  explicit ContractUpdateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit ContractUpdateTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the contract to update.
   *
   * @param contractId The ID of the contract to update.
   * @return A reference to this ContractUpdateTransaction object with the newly-set contract ID.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   */
  ContractUpdateTransaction& setContractId(const ContractId& contractId);

  /**
   * Set a new expiration time for the contract.
   *
   * @param expiration The desired new expiration time for the contract.
   * @return A reference to this ContractUpdateTransaction object with the newly-set expiration time.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   */
  ContractUpdateTransaction& setExpirationTime(const std::chrono::system_clock::time_point& expiration);

  /**
   * Set a new admin key for the contract.
   *
   * @param adminKey The desired new admin key for the contract.
   * @return A reference to this ContractUpdateTransaction object with the newly-set admin key.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   */
  ContractUpdateTransaction& setAdminKey(const std::shared_ptr<Key>& adminKey);

  /**
   * Set a new auto renew period for the contract.
   *
   * @param autoRenewPeriod The desired new auto renew period for the contract.
   * @return A reference to this ContractUpdateTransaction object with the newly-set auto renew period.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   */
  ContractUpdateTransaction& setAutoRenewPeriod(const std::chrono::system_clock::duration& autoRenewPeriod);

  /**
   * Set a new memo for the contract.
   *
   * @param memo The desired new memo for the contract.
   * @return A reference to this ContractUpdateTransaction object with the newly-set memo.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   * @throws std::length_error If the memo is more than 100 characters.
   */
  ContractUpdateTransaction& setContractMemo(std::string_view memo);

  /**
   * Set the new maximum automatic token associations the contract can have.
   *
   * @param associations The desired new maximum amount of token associations for the contract.
   * @return A reference to this ContractUpdateTransaction object with the newly-set maximum automatic token
   *         associations.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   */
  ContractUpdateTransaction& setMaxAutomaticTokenAssociations(int32_t associations);

  /**
   * Set the ID of the account that will auto-renew this contract.
   *
   * @param autoRenewAccountId The ID of the desired new account that will auto-renew this contract.
   * @return A reference to this ContractUpdateTransaction object with the newly-set auto-renew account ID.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   */
  ContractUpdateTransaction& setAutoRenewAccountId(const AccountId& autoRenewAccountId);

  /**
   * Set the new account to which the contract should stake. This is mutually exclusive with mStakedNodeId, and will
   * reset the value of the mStakedNodeId if it is set.
   *
   * @param stakedAccountId The ID of the desired new account to which the contract will stake.
   * @return A reference to this ContractUpdateTransaction object with the newly-set staked account ID.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   */
  ContractUpdateTransaction& setStakedAccountId(const AccountId& stakedAccountId);

  /**
   * Set the new node to which the contract should stake. This is mutually exclusive with mStakedAccountId, and will
   * reset the value of the mStakedAccountId if it is set.
   *
   * @param stakedNodeId The ID of the desired new node to which the contract will stake.
   * @return A reference to this ContractUpdateTransaction object with the newly-set staked node ID.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   */
  ContractUpdateTransaction& setStakedNodeId(const uint64_t& stakedNodeId);

  /**
   * Set a new staking reward reception policy for the contract.
   *
   * @param declineReward \c TRUE if the contract should decline receiving staking rewards, otherwise \c FALSE.
   * @return A reference to this ContractUpdateTransaction object with the newly-set staking rewards reception policy.
   * @throws IllegalStateException If this ContractUpdateTransaction is frozen.
   */
  ContractUpdateTransaction& setDeclineStakingReward(bool declineReward);

  /**
   * Get the ID of the contract to update.
   *
   * @return The ID of the contract to update.
   */
  [[nodiscard]] inline ContractId getContractId() const { return mContractId; }

  /**
   * Get the new expiration time for the contract.
   *
   * @return The new expiration time for the contract. Returns uninitialized if a new expiration time has not yet been
   *         set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::time_point> getExpirationTime() const
  {
    return mExpirationTime;
  }

  /**
   * Get the new admin key to be used for the contract.
   *
   * @return A pointer to the new admin key to be used for the contract. Returns nullptr if the key has not yet been
   *         set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getAdminKey() const { return mAdminKey; }

  /**
   * Get the new auto renew period for the contract.
   *
   * @return The new auto renew period for the new contract. Returns uninitialized if a new auto-renew period has not
   *         yet been set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::duration> getAutoRenewPeriod() const
  {
    return mAutoRenewPeriod;
  }

  /**
   * Get the new memo for the contract.
   *
   * @return The new memo for the contract. Returns uninitialized if a new memo has not yet been set.
   */
  [[nodiscard]] inline std::optional<std::string> getContractMemo() const { return mContractMemo; }

  /**
   * Get the new maximum automatic token associations for the contract.
   *
   * @return The new maximum automatic token associations for the contract. Returns uninitialized if a new maximum
   *         automatic token associations amount has not yet been set.
   */
  [[nodiscard]] inline std::optional<int32_t> getMaxAutomaticTokenAssociations() const
  {
    return mMaxAutomaticTokenAssociations;
  }

  /**
   * Get the ID of the account that will auto-renew this contract.
   *
   * @return The ID of the account that will auto-renew this contract. Returns uninitialized if a new auto-renew account
   *         ID has not yet been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getAutoRenewAccountId() const { return mAutoRenewAccountId; };

  /**
   * Get the ID of the account to which the contract will stake.
   *
   * @return The ID of the desired new account to which the account will stake. Returns uninitialized if a new staked
   *         account ID has not yet been set, or if a staked node ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<AccountId> getStakedAccountId() const { return mStakedAccountId; }

  /**
   * Get the ID of the desired new node to which the contract will stake.
   *
   * @return The ID of the desired new node to which the contract will stake. Returns uninitialized if a new staked node
   *         ID has not yet been set, or if a staked account ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<uint64_t> getStakedNodeId() const { return mStakedNodeId; }

  /**
   * Get the new staking rewards reception policy for the contract.
   *
   * @return \c TRUE if the contract should decline from receiving staking rewards, otherwise \c FALSE. Returns
   *         uninitialized if a new staking rewards reception policy has not yet been set.
   */
  [[nodiscard]] inline std::optional<bool> getDeclineStakingReward() const { return mDeclineStakingReward; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this ContractUpdateTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this ContractUpdateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ContractUpdateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the ContractUpdateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this ContractUpdateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ContractUpdateTransactionBody protobuf object from this ContractUpdateTransaction object.
   *
   * @return A pointer to a ContractUpdateTransactionBody protobuf object filled with this ContractUpdateTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ContractUpdateTransactionBody* build() const;

  /**
   * The ID of the contract to update.
   */
  ContractId mContractId;

  /**
   * The new expiration time for the contract.
   */
  std::optional<std::chrono::system_clock::time_point> mExpirationTime;

  /**
   * The new admin key to be used for the contract.
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The new auto renew period for the contract.
   */
  std::optional<std::chrono::system_clock::duration> mAutoRenewPeriod;

  /**
   * The new memo for the contract (UTF-8 encoding max 100 bytes).
   */
  std::optional<std::string> mContractMemo;

  /**
   * The new maximum automatic token associations for the contract. Only allows values up to a maximum value of 5000.
   */
  std::optional<int32_t> mMaxAutomaticTokenAssociations;

  /**
   * The ID of the account that will auto-renew this contract.
   */
  std::optional<AccountId> mAutoRenewAccountId;

  /**
   * The ID of the new account to which this contract will be staked. Mutually exclusive with mStakedNodeId.
   */
  std::optional<AccountId> mStakedAccountId;

  /**
   * The ID of the new node to which this contract will be staked. Mutually exclusive with mStakedAccountId.
   */
  std::optional<uint64_t> mStakedNodeId;

  /**
   * If \c TRUE, the contract will now decline receiving staking rewards.
   */
  std::optional<bool> mDeclineStakingReward;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CONTRACT_UPDATE_TRANSACTION_H_
// Filename: src/sdk/main/include/CustomFee.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CUSTOM_FEE_H_
#define HIERO_SDK_CPP_CUSTOM_FEE_H_

#include "AccountId.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class CustomFee;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * Base class for custom fees. This is assessed during a CryptoTransfer that transfers units of the token to which the
 * fee is attached. A custom fee may be either fixed, fractional, or a royalty, and must specify a fee collector account
 * to receive the assessed fees. Only positive fees may be assessed.
 */
class CustomFee
{
public:
  virtual ~CustomFee() = default;

  /**
   * Construct a CustomFee object from a CustomFee protobuf object.
   *
   * @param proto The CustomFee protobuf object from which to construct a CustomFee object.
   * @return A pointer to the constructed CustomFee object.
   */
  [[nodiscard]] static std::unique_ptr<CustomFee> fromProtobuf(const proto::CustomFee& proto);

  /**
   * Construct a CustomFee object from a byte array.
   *
   * @param bytes The byte array from which to construct a CustomFee object.
   * @return A pointer to the constructed CustomFee object.
   */
  [[nodiscard]] static std::unique_ptr<CustomFee> fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Create a clone of this CustomFee object.
   *
   * @return A pointer to the created clone of this CustomFee.
   */
  [[nodiscard]] virtual std::unique_ptr<CustomFee> clone() const = 0;

  /**
   * Construct a CustomFee protobuf object from this CustomFee object.
   *
   * @return A pointer to the created CustomFee protobuf object filled with this CustomFee object's data.
   */
  [[nodiscard]] virtual std::unique_ptr<proto::CustomFee> toProtobuf() const = 0;

  /**
   * Construct a string representation of this CustomFee object.
   *
   * @return The string representation of this CustomFee object.
   */
  [[nodiscard]] virtual std::string toString() const = 0;

  /**
   * Write this CustomFee to an output stream.
   *
   * @param os  The output stream.
   * @param fee The CustomFee to print.
   * @return The output stream with this CustomFee written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const CustomFee& fee);

  /**
   * Verify the checksums of all the entities involved in this CustomFee.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This CustomFee's checksums are not valid.
   */
  virtual void validateChecksums(const Client& client) const;

  /**
   * Construct a representative byte array from this CustomFee object.
   *
   * @return The byte array representing this CustomFee object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Get the ID of the desired fee collector account.
   *
   * @return The ID of the desired fee collector account.
   */
  [[nodiscard]] inline AccountId getFeeCollectorAccountId() const { return mFeeCollectorAccountId; }

  /**
   * Get the fee collector exemption policy.
   *
   * @return \c TRUE if fee collectors are currently configured to be exempt from this CustomFee, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool getAllCollectorsAreExempt() const { return mAllCollectorsAreExempt; }

protected:
  /**
   * Prevent public copying and moving to prevent slicing. Use the 'clone()' virtual method instead.
   */
  CustomFee() = default;
  CustomFee(const CustomFee&) = default;
  CustomFee& operator=(const CustomFee&) = default;
  CustomFee(CustomFee&&) noexcept = default;
  CustomFee& operator=(CustomFee&&) noexcept = default;

  /**
   * Create the initial protobuf CustomFee object, populated with this CustomFee's private members, to be used by
   * derived classes' toProtobuf() functions.
   *
   * @return A pointer to CustomFee protobuf object filled-in with this CustomFee's private members.
   */
  [[nodiscard]] std::unique_ptr<proto::CustomFee> initProtobuf() const;

  /**
   * The ID of the account that should receive the fee.
   */
  AccountId mFeeCollectorAccountId;

  /**
   * Should all token fee collection accounts be exempt from this fee?
   */
  bool mAllCollectorsAreExempt = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CUSTOM_FEE_H_
// Filename: src/sdk/main/include/CustomFeeBase.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CUSTOM_FEE_BASE_H_
#define HIERO_SDK_CPP_CUSTOM_FEE_BASE_H_

#include "AccountId.h"
#include "CustomFee.h"

namespace Hiero
{
/**
 * Helper class to sit between CustomFee and its derived implementations. This is done so that CustomFee isn't required
 * to be a templated type.
 */
template<typename FeeType>
class CustomFeeBase : public CustomFee
{
public:
  /**
   * Set the ID of the desired fee collector account.
   *
   * @param accountId The ID of the desired fee collector account.
   * @return A reference to this derived CustomFee object, with the newly-set fee collector account ID.
   */
  FeeType& setFeeCollectorAccountId(const AccountId& accountId);

  /**
   * Set the fee collector exemption policy.
   *
   * @param exempt \c TRUE if fee collectors should be exempt from this CustomFee, otherwise \c FALSE.
   * @return A reference ot this derived CustomFee object, with the newly-set fee collector exemption policy.
   */
  FeeType& setAllCollectorsAreExempt(bool exempt);

protected:
  /**
   * Prevent public copying and moving to prevent slicing. Use the 'clone()' virtual method instead.
   */
  CustomFeeBase() = default;
  CustomFeeBase(const CustomFeeBase&) = default;
  CustomFeeBase& operator=(const CustomFeeBase&) = default;
  CustomFeeBase(CustomFeeBase&&) noexcept = default;
  CustomFeeBase& operator=(CustomFeeBase&&) noexcept = default;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CUSTOM_FEE_BASE_H_
// Filename: src/sdk/main/include/CustomFeeLimit.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CUSTOM_FEE_LIMIT_H_
#define HIERO_SDK_CPP_CUSTOM_FEE_LIMIT_H_

#include "AccountId.h"
#include "CustomFixedFee.h"
#include <optional>
#include <string>
#include <vector>

namespace proto
{
class CustomFeeLimit;
}

namespace Hiero
{
/**
 * Represents a maximum custom fee a user is willing to pay.
 */
class CustomFeeLimit
{
public:
  /**
   * Creates a CustomFeeLimit object from a protobuf representation.
   *
   * @param protoFeeLimit The protobuf object to convert from.
   * @return A CustomFeeLimit object constructed from the protobuf data.
   */
  [[nodiscard]] static CustomFeeLimit fromProtobuf(const proto::CustomFeeLimit& protoFeeLimit);

  /**
   * Converts this CustomFeeLimit object to a protobuf representation.
   *
   * @return A pointer to proto::CustomFeeLimit object.
   */
  [[nodiscard]] std::unique_ptr<proto::CustomFeeLimit> toProtobuf() const;

  /**
   * Sets the payer ID for the fee limit.
   *
   * @param payerId The AccountId to set.
   * @return A reference to this object for method chaining.
   */
  CustomFeeLimit& setPayerId(const AccountId& payerId);

  /**
   * Gets the payer ID.
   *
   * @return The optional AccountId of the payer.
   */
  [[nodiscard]] std::optional<AccountId> getPayerId() const;

  /**
   * Sets the custom fees.
   *
   * @param customFees The list of custom fees.
   * @return A reference to this object for method chaining.
   */
  CustomFeeLimit& setCustomFees(const std::vector<CustomFixedFee>& customFees);

  /**
   * Adds a custom fee to the list.
   *
   * @param customFee The CustomFixedFee to add.
   * @return A reference to this object for method chaining.
   */
  CustomFeeLimit& addCustomFee(const CustomFixedFee& customFee);

  /**
   * Gets the custom fees.
   *
   * @return A vector of CustomFixedFee objects.
   */
  [[nodiscard]] std::vector<CustomFixedFee> getCustomFees() const;

  /**
   * Converts the CustomFeeLimit object to a human-readable string.
   *
   * @return A string representation of the CustomFeeLimit.
   */
  [[nodiscard]] std::string toString() const;

private:
  /**
   * Optional payer ID for the fee.
   */
  std::optional<AccountId> mPayerId;

  /**
   * List of custom fees.
   */
  std::vector<CustomFixedFee> mCustomFees;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CUSTOM_FEE_LIMIT_H_
// Filename: src/sdk/main/include/CustomFixedFee.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CUSTOM_FIXED_FEE_H_
#define HIERO_SDK_CPP_CUSTOM_FIXED_FEE_H_

#include "CustomFeeBase.h"
#include "Hbar.h"
#include "TokenId.h"

#include <memory>
#include <optional>

namespace proto
{
class FixedFee;
}

namespace Hiero
{
/**
 * A fixed number of units (Hbar or token) to assess as a fee during a CryptoTransfer that transfers units of the token
 * to which this fixed fee is attached.
 */
class CustomFixedFee : public CustomFeeBase<CustomFixedFee>
{
public:
  /**
   * Create a CustomFixedFee object from a FixedFee protobuf object.
   *
   * @param proto The FixedFee protobuf object from which to create an CustomFixedFee object.
   * @return A pointer to the constructed CustomFixedFee object.
   */
  [[nodiscard]] static CustomFixedFee fromProtobuf(const proto::FixedFee& proto);

  /**
   * Derived from CustomFee. Create a clone of this CustomFixedFee object.
   *
   * @return A pointer to the created clone of this CustomFixedFee.
   */
  [[nodiscard]] std::unique_ptr<CustomFee> clone() const override;

  /**
   * Derived from CustomFee. Construct a CustomFee protobuf object from this CustomFixedFee object.
   *
   * @return A pointer to the created CustomFee protobuf object filled with this CustomFixedFee object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::CustomFee> toProtobuf() const override;

  /**
   * Derived from CustomFee. Construct a string representation of this CustomFee object.
   *
   * @return The string representation of this CustomFee object.
   */
  [[nodiscard]] std::string toString() const override;

  /**
   * Derived from CustomFee. Verify the checksums of all the entities involved in this CustomFixedFee.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This CustomFixedFee's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Construct a FixedFee protobuf object from this CustomFixedFee object.
   *
   * @return A pointer to the created FixedFee protobuf object filled with this CustomFixedFee object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::FixedFee> toFixedFeeProtobuf() const;

  /**
   * Set the desired fee amount.
   *
   * @param amount The desired fee amount.
   * @return A reference to this CustomFixedFee object, with the newly-set fee amount.
   */
  CustomFixedFee& setAmount(const uint64_t& amount);
  CustomFixedFee& setHbarAmount(const Hbar& amount);

  /**
   * Set the ID of the denominating token.
   *
   * @param tokenId The ID of the denominating token.
   * @return A reference ot this CustomFixedFee object, with the newly-set denominating token ID.
   */
  CustomFixedFee& setDenominatingTokenId(const TokenId& tokenId);

  /**
   * Set the ID of the denominating token to the token being created (as part of a TokenCreateTransaction).
   *
   * @return A reference ot this CustomFixedFee object, with the newly-set denominating token ID.
   */
  CustomFixedFee& setDenominatingTokenToSameToken();

  /**
   * Get the desired fee amount.
   *
   * @return The desired fee amount.
   */
  [[nodiscard]] inline uint64_t getAmount() const { return mAmount; }
  [[nodiscard]] inline Hbar getHbarAmount() const { return Hbar(static_cast<int64_t>(mAmount), HbarUnit::TINYBAR()); }

  /**
   * Get the ID of the denominating token.
   *
   * @return The ID of the denominating token. Returns uninitialized if a token ID has not yet been set.
   */
  [[nodiscard]] inline std::optional<TokenId> getDenominatingTokenId() const { return mDenominatingTokenId; }

private:
  /**
   * The number of units to assess as a fee.
   */
  uint64_t mAmount = 0ULL;

  /**
   * The denomination of the fee. If left unset, Hbar will be the denomination. In a TokenCreateTransaction, if set to
   * the sentinel value of 0.0.0, the created token will be the denomination.
   */
  std::optional<TokenId> mDenominatingTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CUSTOM_FIXED_FEE_H_
// Filename: src/sdk/main/include/CustomFractionalFee.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CUSTOM_FRACTIONAL_FEE_H_
#define HIERO_SDK_CPP_CUSTOM_FRACTIONAL_FEE_H_

#include "CustomFeeBase.h"
#include "FeeAssessmentMethod.h"

#include <memory>
#include <optional>

namespace proto
{
class FractionalFee;
}

namespace Hiero
{
/**
 * A fraction of the transferred units of a token to assess as a fee. The amount assessed will never be less than the
 * given mMinimumAmount, and never greater than the given mMaximumAmount. The denomination is always units of the token
 * to which this fractional fee is attached.
 */
class CustomFractionalFee : public CustomFeeBase<CustomFractionalFee>
{
public:
  /**
   * Create a CustomFractionalFee object from a FractionalFee protobuf object.
   *
   * @param proto The FractionalFee protobuf object from which to create an CustomFractionalFee object.
   * @return A pointer to the constructed CustomFractionalFee object.
   */
  [[nodiscard]] static CustomFractionalFee fromProtobuf(const proto::FractionalFee& proto);

  /**
   * Derived from CustomFee. Create a clone of this CustomFractionalFee object.
   *
   * @return A pointer to the created clone of this CustomFractionalFee.
   */
  [[nodiscard]] std::unique_ptr<CustomFee> clone() const override;

  /**
   * Derived from CustomFee. Construct a CustomFee protobuf object from this CustomFractionalFee object.
   *
   * @return A pointer to the created CustomFee protobuf object filled with this CustomFractionalFee object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::CustomFee> toProtobuf() const override;

  /**
   * Derived from CustomFee. Construct a string representation of this CustomFractionalFee object.
   *
   * @return The string representation of this CustomFractionalFee object.
   */
  [[nodiscard]] std::string toString() const override;

  /**
   * Set the desired numerator of the fractional amount of the transferred units to assess as a part of this
   * CustomFractionalFee.
   *
   * @param numerator The desired numerator of the fractional amount of the transferred units to assess as a part of
   *                  this CustomFractionalFee.
   * @return A reference to this CustomFractionalFee object, with the newly-set numerator.
   */
  CustomFractionalFee& setNumerator(const int64_t& numerator);

  /**
   * Set the desired denominator of the fractional amount of the transferred units to assess as a part of this
   * CustomFractionalFee.
   *
   * @param denominator The desired denominator of the fractional amount of the transferred units to assess as a part of
   *                    this CustomFractionalFee.
   * @return A reference to this CustomFractionalFee object, with the newly-set denominator.
   */
  CustomFractionalFee& setDenominator(const int64_t& denominator);

  /**
   * Set the desired minimum amount to assess as a part of this CustomFractionalFee.
   *
   * @param amount The desired minimum amount to assess as a part of this CustomFractionalFee.
   * @return A reference ot this CustomFractionalFee object, with the newly-set minimum amount.
   */
  CustomFractionalFee& setMinimumAmount(const uint64_t& amount);

  /**
   * Set the desired maximum amount to assess as a part of this CustomFractionalFee.
   *
   * @param amount The desired maximum amount to assess as a part of this CustomFractionalFee.
   * @return A reference ot this CustomFractionalFee object, with the newly-set maximum amount.
   */
  CustomFractionalFee& setMaximumAmount(const uint64_t& amount);

  /**
   * Set the desired fee assessment method.
   *
   * @param method The desired fee assessment method.
   * @return A reference ot this CustomFractionalFee object, with the newly-set fee assessment method.
   */
  CustomFractionalFee& setAssessmentMethod(FeeAssessmentMethod method);

  /**
   * Get the desired numerator of the fractional amount of the transferred units to assess as a part of this
   * CustomFractionalFee.
   *
   * @return The desired numerator of the fractional amount of the transferred units to assess as a part of this
   *         CustomFractionalFee.
   */
  [[nodiscard]] inline int64_t getNumerator() const { return mNumerator; }

  /**
   * Get the desired denominator of the fractional amount of the transferred units to assess as a part of this
   * CustomFractionalFee.
   *
   * @return The desired denominator of the fractional amount of the transferred units to assess as a part of this
   *         CustomFractionalFee.
   */
  [[nodiscard]] inline int64_t getDenominator() const { return mDenominator; }

  /**
   * Get the desired minimum amount to assess as a part of this CustomFractionalFee.
   *
   * @return The desired minimum amount to assess as a part of this CustomFractionalFee.
   */
  [[nodiscard]] inline uint64_t getMinimumAmount() const { return mMinAmount; }

  /**
   * Get the desired maximum amount to assess as a part of this CustomFractionalFee.
   *
   * @return The desired maximum amount to assess as a part of this CustomFractionalFee.
   */
  [[nodiscard]] inline uint64_t getMaximumAmount() const { return mMaxAmount; }

  /**
   * Get the desired fee assessment method.
   *
   * @return The desired fee assessment method.
   */
  [[nodiscard]] inline FeeAssessmentMethod getAssessmentMethod() const { return mAssessmentMethod; }

private:
  /**
   * The numerator of the fractional amount of the transferred units to assess as a part of this CustomFractionalFee.
   */
  int64_t mNumerator = 0LL;

  /**
   * The denominator of the fractional amount of the transferred units to assess as a part of this CustomFractionalFee.
   */
  int64_t mDenominator = 1LL;

  /**
   * The desired minimum amount to assess as a part of this CustomFractionalFee
   */
  uint64_t mMinAmount = 0ULL;

  /**
   * The desired maximum amount to assess as a part of this CustomFractionalFee
   */
  uint64_t mMaxAmount = 0ULL;

  /**
   * How is this CustomFractionalFee assessed?
   */
  FeeAssessmentMethod mAssessmentMethod = FeeAssessmentMethod::INCLUSIVE;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CUSTOM_FRACTIONAL_FEE_H_
// Filename: src/sdk/main/include/CustomRoyaltyFee.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_CUSTOM_ROYALTY_FEE_H_
#define HIERO_SDK_CPP_CUSTOM_ROYALTY_FEE_H_

#include "CustomFeeBase.h"
#include "CustomFixedFee.h"

#include <optional>

namespace proto
{
class RoyaltyFee;
}

namespace Hiero
{
/**
 * A fee to assess during a CryptoTransfer that changes ownership of an NFT. Defines the fraction of the fungible value
 * exchanged for an NFT that the ledger should collect as a royalty. ("Fungible value" includes both ℏ and units of
 * fungible HTS tokens.) When the NFT sender does not receive any fungible value, the ledger will assess the fallback
 * fee, if present, to the new NFT owner. Royalty fees can only be added to tokens of type NON_FUNGIBLE_UNIQUE.
 */
class CustomRoyaltyFee : public CustomFeeBase<CustomRoyaltyFee>
{
public:
  /**
   * Create a CustomRoyaltyFee object from a RoyaltyFee protobuf object.
   *
   * @param proto The RoyaltyFee protobuf object from which to create an CustomRoyaltyFee object.
   * @return A pointer to the constructed CustomRoyaltyFee object.
   */
  [[nodiscard]] static CustomRoyaltyFee fromProtobuf(const proto::RoyaltyFee& proto);

  /**
   * Derived from CustomFee. Create a clone of this CustomRoyaltyFee object.
   *
   * @return A pointer to the created clone of this CustomRoyaltyFee.
   */
  [[nodiscard]] std::unique_ptr<CustomFee> clone() const override;

  /**
   * Derived from CustomFee. Construct a CustomFee protobuf object from this CustomRoyaltyFee object.
   *
   * @return A pointer to the created CustomFee protobuf object filled with this CustomRoyaltyFee object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::CustomFee> toProtobuf() const override;

  /**
   * Derived from CustomFee. Construct a string representation of this CustomRoyaltyFee object.
   *
   * @return The string representation of this CustomRoyaltyFee object.
   */
  [[nodiscard]] std::string toString() const override;

  /**
   * Set the desired numerator of the fractional amount of the transferred units to assess as a part of this
   * CustomRoyaltyFee.
   *
   * @param numerator The desired numerator of the fractional amount of the transferred units to assess as a part of
   *                  this CustomRoyaltyFee.
   * @return A reference to this CustomRoyaltyFee object, with the newly-set numerator.
   */
  CustomRoyaltyFee& setNumerator(const int64_t& numerator);

  /**
   * Set the desired denominator of the fractional amount of the transferred units to assess as a part of this
   * CustomRoyaltyFee.
   *
   * @param denominator The desired denominator of the fractional amount of the transferred units to assess as a part of
   *                    this CustomRoyaltyFee.
   * @return A reference to this CustomRoyaltyFee object, with the newly-set denominator.
   */
  CustomRoyaltyFee& setDenominator(const int64_t& denominator);

  /**
   * Set the desired CustomFixedFee to be assessed to the NFT receiver when there is no fungible value exchanged with
   * the sender of the NFT.
   *
   * @param fee The desired CustomFixedFee to be assessed to the NFT receiver when there is no fungible value exchanged
   *            with the sender of the NFT.
   * @return A reference to this CustomRoyaltyFee object, with the newly-set fallback fee.
   */
  CustomRoyaltyFee& setFallbackFee(const CustomFixedFee& fee);

  /**
   * Set the desired numerator of the fractional amount of the transferred units to assess as a part of this
   * CustomRoyaltyFee.
   *
   * @return The desired numerator of the fractional amount of the transferred units to assess as a part of this
   *         CustomRoyaltyFee.
   */
  [[nodiscard]] inline int64_t getNumerator() const { return mNumerator; }

  /**
   * Set the desired denominator of the fractional amount of the transferred units to assess as a part of this
   * CustomRoyaltyFee.
   *
   * @return The desired denominator of the fractional amount of the transferred units to assess as a part of this
   *         CustomRoyaltyFee.
   */
  [[nodiscard]] inline int64_t getDenominator() const { return mDenominator; }

  /**
   * Get the desired CustomFixedFee to be assessed to the NFT receiver when there is no fungible value exchanged with
   * the sender of the NFT.
   *
   * @return The desired CustomFixedFee to be assessed to the NFT receiver when there is no fungible value exchanged
   *         with the sender of the NFT. Returns uninitialized if no fallback fee has yet been set.
   */
  [[nodiscard]] inline std::optional<CustomFixedFee> getFallbackFee() const { return mFallbackFee; }

private:
  /**
   * The numerator of the fractional amount of the transferred units to assess as a part of this CustomRoyaltyFee.
   */
  int64_t mNumerator = 0LL;

  /**
   * The denominator of the fractional amount of the transferred units to assess as a part of this CustomRoyaltyFee.
   */
  int64_t mDenominator = 1LL;

  /**
   * The CustomFixedFee to be assessed to the NFT receiver when there is no fungible value exchanged with the sender of
   * the NFT.
   */
  std::optional<CustomFixedFee> mFallbackFee;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_CUSTOM_ROYALTY_FEE_H_
// Filename: src/sdk/main/include/Defaults.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_DEFAULTS_H_
#define HIERO_SDK_CPP_DEFAULTS_H_

#include "Hbar.h"

#include <chrono>

namespace Hiero
{
/**
 * The default duration of time to try and submit a request.
 */
constexpr auto DEFAULT_REQUEST_TIMEOUT = std::chrono::minutes(2);
/**
 * The default maximum number of times a request will attempt to be submitted before considering the execution failed.
 */
constexpr auto DEFAULT_MAX_ATTEMPTS = 10U;
/**
 * The default minimum duration of time to wait before retrying to submit a previously-failed request.
 */
constexpr auto DEFAULT_MIN_BACKOFF = std::chrono::milliseconds(250);
/**
 * The default maximum duration of time to wait before retrying to submit a previously-failed request.
 */
constexpr auto DEFAULT_MAX_BACKOFF = std::chrono::seconds(8);
/**
 * The default maximum amount of time to spend on one execution attempt
 */
constexpr auto DEFAULT_GRPC_DEADLINE = std::chrono::seconds(10);
/**
 * The default maximum number of times a node is allowed to return a bad gRPC status before it is permanently removed
 * from a network. 0 indicates there's no maximum.
 */
constexpr auto DEFAULT_MAX_NODE_ATTEMPTS = 0U;
/**
 * The default minimum duration of time to wait before retrying to submit a previously-failed request to the same node.
 */
constexpr auto DEFAULT_MIN_NODE_BACKOFF = std::chrono::seconds(8);
/**
 * The default maximum duration of time to wait before retrying to submit a previously-failed request to the same node.
 */
constexpr auto DEFAULT_MAX_NODE_BACKOFF = std::chrono::hours(1);
/**
 * The default amount of time to allow a node to gracefully close a gRPC connection before forcibly terminating it.
 */
constexpr auto DEFAULT_CLOSE_TIMEOUT = std::chrono::seconds(30);
/**
 * The default maximum transaction fee.
 */
constexpr auto DEFAULT_MAX_TRANSACTION_FEE = Hbar(2LL);
/**
 * The default maximum query payment
 */
constexpr auto DEFAULT_MAX_QUERY_PAYMENT = Hbar(1LL);
/**
 * The default auto-renew period.
 */
constexpr auto DEFAULT_AUTO_RENEW_PERIOD = std::chrono::hours(2160);
/**
 * The default duration of time a Transaction will remain valid.
 */
constexpr auto DEFAULT_TRANSACTION_VALID_DURATION = std::chrono::minutes(2);
/**
 * The default transaction ID regeneration policy.
 */
constexpr auto DEFAULT_REGENERATE_TRANSACTION_ID = true;
/**
 * The default size of a chunk for a ChunkedTransaction.
 */
constexpr auto DEFAULT_CHUNK_SIZE = 1024U;
/**
 * The default number of chunks for a ChunkedTransaction.
 */
constexpr auto DEFAULT_MAX_CHUNKS = 20U;
/**
 * The default amount of time to wait after a network update to update again.
 */
constexpr auto DEFAULT_NETWORK_UPDATE_PERIOD = std::chrono::hours(24);
/**
 * The default amount of time to wait after Client creation to update the network for the first time.
 */
constexpr auto DEFAULT_NETWORK_UPDATE_INITIAL_DELAY = std::chrono::seconds(10);
/**
 * The default name of Logger types.
 */
constexpr auto DEFAULT_LOGGER_NAME = "HIERO_CPP_SDK_LOGGER";
}

#endif // HIERO_SDK_CPP_DEFAULTS_H_// Filename: src/sdk/main/include/DelegateContractId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_DELEGATE_CONTRACT_ID_H_
#define HIERO_SDK_CPP_DELEGATE_CONTRACT_ID_H_

#include "ContractId.h"

#include <string_view>

namespace proto
{
class ContractID;
}

namespace Hiero
{
/**
 * A smart contract that, if the recipient of the active message frame, should be treated as having signed. (Note this
 * does not mean the code being executed in the frame code being executed in the frame delegatecall. So setting this key
 * is a more permissive version of setting the contractId key, which also requires the code in the active message frame
 * belong to the contract with the given id. The delegate contract ID can be set as Key.
 */
class DelegateContractId : public ContractId
{
public:
  DelegateContractId() = default;

  /**
   * Construct with a contract number.
   *
   * @param num The contract number.
   */
  explicit DelegateContractId(uint64_t num);

  /**
   * Construct with a shard, realm, a contract number, and optionally a checksum.
   *
   * @param shard    The shard number.
   * @param realm    The realm number.
   * @param num      The account number.
   * @param checksum The checksum.
   */
  explicit DelegateContractId(uint64_t shard, uint64_t realm, uint64_t num, std::string_view checksum = "");

  /**
   * Compare this DelegateContractId to another DelegateContractId and determine if they represent the same contract.
   *
   * @param other The other DelegateContractId with which to compare this DelegateContractId.
   * @return \c TRUE if this DelegateContractId is the same as the input DelegateContractId, otherwise \c FALSE.
   */
  [[nodiscard]] bool operator==(const DelegateContractId& other) const;

  /**
   * Construct a DelegateContractId object from a string of the form "<shard>.<realm>.<num>".
   *
   * @param id The contract ID string from which to construct.
   * @return The constructed DelegateContractId object.
   */
  [[nodiscard]] static DelegateContractId fromString(std::string_view id);

  /**
   * Construct a DelegateContractId from a Solidity address.
   *
   * @param address The Solidity address from which to create a DelegateContractId, as a string.
   * @return The constructed DelegateContractId object.
   * @throws std::invalid_argument If a Solidity address cannot be realized from the input string.
   */
  [[nodiscard]] static DelegateContractId fromSolidityAddress(std::string_view address);

  /**
   * Construct an DelegateContractId object from an DelegateContractId protobuf object.
   *
   * @param proto The DelegateContractId protobuf object from which to create an DelegateContractId object.
   * @return The constructed DelegateContractId object.
   */
  [[nodiscard]] static DelegateContractId fromProtobuf(const proto::ContractID& id);

  /**
   * Construct a DelegateContractId object from a representative byte array.
   *
   * @param bytes The byte array from which to construct a DelegateContractId object.
   * @return The constructed ContractId object.
   */
  [[nodiscard]] static DelegateContractId fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Derived from Key. Create a clone of this DelegateContractId object.
   *
   * @return A pointer to the created clone of this DelegateContractId.
   */
  [[nodiscard]] std::unique_ptr<Key> clone() const override;

  /**
   * Derived from Key. Construct a Key protobuf object from this DelegateContractId object.
   *
   * @return A pointer to the created Key protobuf object filled with this DelegateContractId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::Key> toProtobufKey() const override;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_DELEGATE_CONTRACT_ID_H_
// Filename: src/sdk/main/include/ECDSAsecp256k1PrivateKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ECDSA_SECP256K1_PRIVATE_KEY_H_
#define HIERO_SDK_CPP_ECDSA_SECP256K1_PRIVATE_KEY_H_

#include "PrivateKey.h"

#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero::internal::OpenSSLUtils
{
class EVP_PKEY;
}

namespace Hiero
{
/**
 * A class representing an ECDSA secp256k1 private key.
 */
class ECDSAsecp256k1PrivateKey : public PrivateKey
{
public:
  /**
   * The number of bytes in an ECDSAsecp256k1PrivateKey.
   */
  static constexpr const size_t KEY_SIZE = 32ULL;

  /**
   * The prefix bytes of a DER-encoded ECDSAsecp256k1PrivateKey.
   */
  static inline const std::vector<std::byte> DER_ENCODED_PREFIX_BYTES = {
    std::byte(0x30), std::byte(0x30), std::byte(0x02), std::byte(0x01), std::byte(0x00), std::byte(0x30),
    std::byte(0x07), std::byte(0x06), std::byte(0x05), std::byte(0x2B), std::byte(0x81), std::byte(0x04),
    std::byte(0x00), std::byte(0x0A), std::byte(0x04), std::byte(0x22), std::byte(0x04), std::byte(0x20)
  };

  /**
   * The hex-encoded string of the DER-encoded prefix bytes of an ECDSAsecp256k1PrivateKey.
   */
  static inline const std::string DER_ENCODED_PREFIX_HEX = "3030020100300706052B8104000A04220420";

  /**
   * The maximum number of bytes in an ECDSAsecp256k1PrivateKey signature.
   */
  static constexpr const size_t MAX_SIGNATURE_SIZE = 72ULL;

  /**
   * The number of bytes in a raw ECDSAsecp256k1PrivateKey signature ((r,s) form).
   */
  static constexpr const size_t RAW_SIGNATURE_SIZE = 64ULL;

  /**
   * The number of bytes in the r value of an ECDSAsecp256k1PrivateKey signature.
   */
  static constexpr const size_t R_SIZE = 32ULL;

  /**
   * The number of bytes in the s value of an ECDSAsecp256k1PrivateKey signature.
   */
  static constexpr const size_t S_SIZE = 32ULL;

  /**
   * Disallow default construction of an ECDSAsecp256k1PrivateKey, as an uninitialized ECDSAsecp256k1PrivateKey provides
   * no functionality. Instead, a factory function should be used.
   */
  ECDSAsecp256k1PrivateKey() = delete;

  /**
   * Generate a new ECDSAsecp256k1PrivateKey.
   *
   * @return A pointer to the generated ECDSAsecp256k1PrivateKey.
   * @throws OpenSSLException If OpenSSL fails to generate a key.
   */
  [[nodiscard]] static std::unique_ptr<ECDSAsecp256k1PrivateKey> generatePrivateKey();

  /**
   * Construct an ECDSAsecp256k1PrivateKey object from a hex-encoded string (DER-encoded or raw).
   *
   * @param key The hex string from which to construct an ECDSAsecp256k1PrivateKey.
   * @return A pointer to an ECDSAsecp256k1PrivateKey representing the input hex string.
   * @throws BadKeyException If an ECDSAsecp256k1PrivateKey cannot be realized from the input hex string.
   */
  [[nodiscard]] static std::unique_ptr<ECDSAsecp256k1PrivateKey> fromString(std::string_view key);

  /**
   * Construct an ECDSAsecp256k1PrivateKey object from a byte vector (DER-encoded or raw).
   *
   * @param bytes The vector of bytes from which to construct an ECDSAsecp256k1PrivateKey.
   * @return A pointer to an ECDSAsecp256k1PrivateKey representing the input bytes.
   * @throws BadKeyException If an ECDSAsecp256k1PrivateKey cannot be realized from the input bytes.
   */
  [[nodiscard]] static std::unique_ptr<ECDSAsecp256k1PrivateKey> fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct an ECDSAsecp256k1PrivateKey from a seed array.
   *
   * @param seed The seed byte array from which to construct an ECDSAsecp256k1PrivateKey.
   * @return A pointer to an ECDSAsecp256k1PrivateKey representing the input seed bytes.
   * @throws BadKeyException If an ECDSAsecp256k1PrivateKey cannot be realized from the input seed bytes.
   */
  [[nodiscard]] static std::unique_ptr<ECDSAsecp256k1PrivateKey> fromSeed(const std::vector<std::byte>& seed);

  /**
   * Derived from Key. Create a clone of this ECDSAsecp256k1PrivateKey object.
   *
   * @return A pointer to the created clone of this ECDSAsecp256k1PrivateKey.
   */
  [[nodiscard]] std::unique_ptr<Key> clone() const override;

  /**
   * Derived from Key. Construct a Key protobuf object from this ECDSAsecp256k1PrivateKey object's
   * ECDSAsecp256k1PublicKey.
   *
   * @return A pointer to a created Key protobuf object filled with this ECDSAsecp256k1PrivateKey object's
   *         ECDSAsecp256k1PublicKey data.
   * @throws OpenSSLException If OpenSSL is unable to serialize this ECDSAsecp256k1PrivateKey object's
   *                          ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::unique_ptr<proto::Key> toProtobufKey() const override;

  /**
   * Derived from PrivateKey. Derive a child ECDSAsecp256k1PrivateKey from this ECDSAsecp256k1PrivateKey.
   *
   * @param childIndex The index of the child to derive.
   * @return A pointer to the derived ECDSAsecp256k1PrivateKey child.
   * @throws OpenSSLException       If OpenSSL is unable to derive a key with the given childIndex.
   * @throws UninitializedException If this ECDSAsecp256k1PrivateKey was not initialized with a chain code.
   */
  [[nodiscard]] std::unique_ptr<PrivateKey> derive(uint32_t childIndex) const override;

  /**
   * Derived from PrivateKey. Sign an arbitrary byte array.
   *
   * @param bytesToSign The bytes to sign.
   * @return The signature of the byte array.
   * @throws OpenSSLException If OpenSSL is unable to generate a signature.
   */
  [[nodiscard]] std::vector<std::byte> sign(const std::vector<std::byte>& bytesToSign) const override;

  /**
   * Derived from PrivateKey. Get the hex-encoded string of the DER-encoded bytes of this ECDSAsecp256k1PrivateKey.
   *
   * @return The hex-encoded string of the DER-encoded bytes of this ECDSAsecp256k1PrivateKey.
   */
  [[nodiscard]] std::string toStringDer() const override;

  /**
   * Derived from PrivateKey. Get the hex-encoded string of the raw, non-DER-encoded bytes of this
   * ECDSAsecp256k1PrivateKey.
   *
   * @return The hex-encoded string of the raw bytes of this ECDSAsecp256k1PrivateKey.
   */
  [[nodiscard]] std::string toStringRaw() const override;

  /**
   * Derived from Key. Get the byte representation of this ECDSAsecp256k1PrivateKey. Returns the same result as
   * toBytesDer().
   *
   * @return The DER-encoded bytes of this ECDSAsecp256k1PrivateKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const override;

  /**
   * Derived from PrivateKey. Get the DER-encoded bytes of this ECDSAsecp256k1PrivateKey.
   *
   * @return The DER-encoded bytes of this ECDSAsecp256k1PrivateKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytesDer() const override;

  /**
   * Derived from PrivateKey. Get the raw, non-DER-encoded bytes of this ECDSAsecp256k1PrivateKey.
   *
   * @return The raw bytes of this ECDSAsecp256k1PrivateKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytesRaw() const override;

private:
  /**
   * Construct from a wrapped OpenSSL key object and optionally a chain code.
   *
   * @param key       The wrapped OpenSSL key object.
   * @param chainCode The chain code.
   * @throws OpenSSLException If OpenSSL is unable to get this ECDSAsecp256k1PrivateKey's corresponding
   *                          ECDSAsecp256k1PrivateKey's bytes.
   * @throws BadKeyException  If the chain code is malformed.
   */
  explicit ECDSAsecp256k1PrivateKey(internal::OpenSSLUtils::EVP_PKEY&& key,
                                    std::vector<std::byte> chainCode = std::vector<std::byte>());
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ECDSA_SECP256K1_PRIVATE_KEY_H_
// Filename: src/sdk/main/include/ECDSAsecp256k1PublicKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ECDSA_SECP256K1_PUBLIC_KEY_H_
#define HIERO_SDK_CPP_ECDSA_SECP256K1_PUBLIC_KEY_H_

#include "PublicKey.h"

#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero
{
class EvmAddress;
}

namespace Hiero
{
/**
 * A class representing an ECDSA secp256k1 public key.
 */
class ECDSAsecp256k1PublicKey : public PublicKey
{
public:
  /**
   * The number of raw bytes in an uncompressed ECDSAsecp256k1PublicKey.
   */
  static constexpr const size_t UNCOMPRESSED_KEY_SIZE = 65ULL;

  /**
   * The number of raw bytes in a compressed ECDSAsecp256k1PublicKey.
   */
  static constexpr const size_t COMPRESSED_KEY_SIZE = 33ULL;

  /**
   * The prefix bytes of a DER-encoded, uncompressed ECDSAsecp256k1PublicKey.
   */
  static inline const std::vector<std::byte> DER_ENCODED_UNCOMPRESSED_PREFIX_BYTES = {
    std::byte(0x30), std::byte(0x56), std::byte(0x30), std::byte(0x10), std::byte(0x06), std::byte(0x07),
    std::byte(0x2A), std::byte(0x86), std::byte(0x48), std::byte(0xCE), std::byte(0x3D), std::byte(0x02),
    std::byte(0x01), std::byte(0x06), std::byte(0x05), std::byte(0x2B), std::byte(0x81), std::byte(0x04),
    std::byte(0x00), std::byte(0x0A), std::byte(0x03), std::byte(0x42), std::byte(0x00)
  };

  /**
   * The hex-encoded string of the DER-encoded prefix bytes of an uncompressed ECDSAsecp256k1PublicKey.
   */
  static inline const std::string DER_ENCODED_UNCOMPRESSED_PREFIX_HEX =
    "3056301006072A8648CE3D020106052B8104000A034200";

  /**
   * The prefix bytes of a DER-encoded, compressed ECDSAsecp256k1PublicKey.
   */
  static inline const std::vector<std::byte> DER_ENCODED_COMPRESSED_PREFIX_BYTES = {
    std::byte(0x30), std::byte(0x2D), std::byte(0x30), std::byte(0x07), std::byte(0x06),
    std::byte(0x05), std::byte(0x2B), std::byte(0x81), std::byte(0x04), std::byte(0x00),
    std::byte(0x0A), std::byte(0x03), std::byte(0x22), std::byte(0x00)
  };

  /**
   * The hex-encoded string of the DER-encoded prefix bytes of a compressed ECDSAsecp256k1PublicKey.
   */
  static inline const std::string DER_ENCODED_COMPRESSED_PREFIX_HEX = "302D300706052B8104000A032200";

  /**
   * Disallow default construction of an ECDSAsecp256k1PublicKey, as an uninitialized ECDSAsecp256k1PublicKey provides
   * no functionality. Instead, a factory function should be used.
   */
  ECDSAsecp256k1PublicKey() = delete;

  /**
   * Construct an ECDSAsecp256k1PublicKey object from a hex-encoded string (DER-encoded or raw).
   *
   * @param key The hex string from which to construct an ECDSAsecp256k1PublicKey. May be either compressed or
   *            uncompressed.
   * @return A pointer to an ECDSAsecp256k1PublicKey representing the input hex string.
   * @throws BadKeyException If an ECDSAsecp256k1PublicKey cannot be realized from the input hex string.
   */
  [[nodiscard]] static std::unique_ptr<ECDSAsecp256k1PublicKey> fromString(std::string_view key);

  /**
   * Construct an ECDSAsecp256k1PublicKey object from a byte vector (DER-encoded or raw).
   *
   * @param bytes The vector of bytes from which to construct an ECDSAsecp256k1PublicKey.
   * @return A pointer to an ECDSAsecp256k1PublicKey representing the input bytes.
   * @throws BadKeyException If an ECDSAsecp256k1PublicKey cannot be realized from the input bytes.
   */
  [[nodiscard]] static std::unique_ptr<ECDSAsecp256k1PublicKey> fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Converts an uncompressed ECDSAsecp256k1PublicKey byte vector to a compressed ECDSAsecp256k1PublicKey byte vector.
   *
   * @param uncompressedBytes The uncompressed bytes of the ECDSAsecp256k1PublicKey.
   * @return A byte vector representing the ECDSAsecp256k1PublicKey in compressed form.
   * @throws std::invalid_argument If the input bytes are not the correct uncompressed key size or malformed.
   * @throws OpenSSLException      If OpenSSL is unable to compress the input bytes.
   */
  [[nodiscard]] static std::vector<std::byte> compressBytes(const std::vector<std::byte>& uncompressedBytes);

  /**
   * Converts a compressed ECDSAsecp256k1PublicKey byte vector to an uncompressed ECDSAsecp256k1PublicKey byte vector.
   *
   * @param compressedBytes The compressed bytes of the ECDSAsecp256k1PublicKey.
   * @return A byte vector representing the ECDSAsecp256k1PublicKey in uncompressed form.
   * @throws std::invalid_argument If the input bytes are not the correct compressed key size or malformed.
   * @throws OpenSSLException      If OpenSSL is unable to uncompress the input bytes.
   */
  [[nodiscard]] static std::vector<std::byte> uncompressBytes(const std::vector<std::byte>& compressedBytes);

  /**
   * Derived from Key. Create a clone of this ECDSAsecp256k1PublicKey object.
   *
   * @return A pointer to the created clone of this ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::unique_ptr<Key> clone() const override;

  /**
   * Derived from Key. Construct a Key protobuf object from this ECDSAsecp256k1PublicKey object.
   *
   * @return A pointer to a created Key protobuf object filled with this ECDSAsecp256k1PublicKey object's data.
   * @throws OpenSSLException If OpenSSL is unable to serialize this ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::unique_ptr<proto::Key> toProtobufKey() const override;

  /**
   * Derived from PublicKey. Verify that a signature was made by the ECDSAsecp256k1PrivateKey which corresponds to this
   * ECDSAsecp256k1PublicKey.
   *
   * @param signatureBytes The byte vector representing the signature.
   * @param signedBytes    The bytes which were purportedly signed to create the signature.
   * @return \c TRUE if the signature is valid, otherwise \c FALSE.
   * @throws OpenSSLException If OpenSSL is unable to verify the signature.
   */
  [[nodiscard]] bool verifySignature(const std::vector<std::byte>& signatureBytes,
                                     const std::vector<std::byte>& signedBytes) const override;

  /**
   * Derived from PublicKey. Get the hex-encoded string of the DER-encoded bytes of this ECDSAsecp256k1PublicKey.
   *
   * @return The hex-encoded string of the DER-encoded bytes of this ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::string toStringDer() const override;

  /**
   * Derived from PublicKey. Get the hex-encoded string of the raw bytes of this ECDSAsecp256k1PublicKey.
   *
   * @return The hex-encoded string of the raw bytes of this ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::string toStringRaw() const override;

  /**
   * Derived from Key. Get the byte representation of this ECDSAsecp256k1PublicKey. Returns the same result as
   * toBytesDer().
   *
   * @return The DER-encoded bytes of this ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const override;

  /**
   * Derived from PublicKey. Get the DER-encoded bytes of this ECDSAsecp256k1PublicKey.
   *
   * @return The DER-encoded bytes of this ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytesDer() const override;

  /**
   * Derived from PublicKey. Get the raw bytes of this ECDSAsecp256k1PublicKey.
   *
   * @return The raw bytes of this ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytesRaw() const override;

  /**
   * Derived from PublicKey. Serialize this ECDSAsecp256k1PublicKey to a SignaturePair protobuf object with the given
   * signature.
   *
   * @param signature The signature created by this ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::unique_ptr<proto::SignaturePair> toSignaturePairProtobuf(
    const std::vector<std::byte>& signature) const override;

  /**
   * Construct an EvmAddress from this ECDSAsecp256k1PublicKey. The constructed EvmAddress will be the last 20 bytes of
   * the keccak-256 hash of this ECDSAsecp256k1PublicKey.
   *
   * @return The constructed EvmAddress.
   */
  [[nodiscard]] EvmAddress toEvmAddress() const;

private:
  /**
   * Construct from a wrapped OpenSSL key object.
   *
   * @param key The wrapped OpenSSL key object from which to construct this ECDSAsecp256k1PublicKey.
   */
  explicit ECDSAsecp256k1PublicKey(internal::OpenSSLUtils::EVP_PKEY&& key);

  /**
   * Derived from PublicKey. Get a std::shared_ptr to this ECDSAsecp256k1PublicKey.
   *
   * @returns A pointer to this ECDSAsecp256k1PublicKey.
   */
  [[nodiscard]] std::shared_ptr<PublicKey> getShared() const override;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ECDSA_SECP256K1_PUBLIC_KEY_H_
// Filename: src/sdk/main/include/ED25519PrivateKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ED25519_PRIVATE_KEY_H_
#define HIERO_SDK_CPP_ED25519_PRIVATE_KEY_H_

#include "PrivateKey.h"

#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero::internal::OpenSSLUtils
{
class EVP_PKEY;
}

namespace Hiero
{
/**
 * A class representing an ED25519 private key.
 */
class ED25519PrivateKey : public PrivateKey
{
public:
  /**
   * The number of bytes in an ED25519PrivateKey.
   */
  static constexpr const size_t KEY_SIZE = 32ULL;

  /**
   * The prefix bytes of a DER-encoded ED25519PrivateKey.
   */
  static inline const std::vector<std::byte> DER_ENCODED_PREFIX_BYTES = {
    std::byte(0x30), std::byte(0x2E), std::byte(0x02), std::byte(0x01), std::byte(0x00), std::byte(0x30),
    std::byte(0x05), std::byte(0x06), std::byte(0x03), std::byte(0x2B), std::byte(0x65), std::byte(0x70),
    std::byte(0x04), std::byte(0x22), std::byte(0x04), std::byte(0x20)
  };

  /**
   * The hex-encoded string of the DER-encoded prefix bytes of an ED25519PrivateKey.
   */
  static inline const std::string DER_ENCODED_PREFIX_HEX = "302E020100300506032B657004220420";

  /**
   * SDK needs to provide a way to set an unusable key such as an Ed25519 all-zeros
   * key, since it is (presumably) impossible to find the 32-byte string whose SHA-512 hash begins with 32 bytes
   * of zeros. We recommend using all-zeros to clearly advertise any unsuable keys.
   */
  static inline const std::string ZERO_KEY_STR = "0000000000000000000000000000000000000000000000000000000000000000";

  /**
   * Disallow default construction of an ED25519PrivateKey, as an uninitialized ED25519PrivateKey provides no
   * functionality. Instead, a factory function should be used.
   */
  ED25519PrivateKey() = delete;

  /**
   * Generate a new ED25519PrivateKey.
   *
   * @return A pointer to the generated ED25519PrivateKey.
   * @throws OpenSSLException If OpenSSL fails to generate a key.
   */
  [[nodiscard]] static std::unique_ptr<ED25519PrivateKey> generatePrivateKey();

  /**
   * Construct an ED25519PrivateKey object from a hex-encoded string (DER-encoded or raw).
   *
   * @param key The hex string from which to construct an ED25519PrivateKey.
   * @return A pointer to an ED25519PrivateKey representing the input hex string.
   * @throws BadKeyException If an ED25519PrivateKey cannot be realized from the input hex string.
   */
  [[nodiscard]] static std::unique_ptr<ED25519PrivateKey> fromString(std::string_view key);

  /**
   * Construct an ED25519PrivateKey object from a byte vector (DER-encoded or raw).
   *
   * @param bytes The vector of bytes from which to construct an ED25519PrivateKey.
   * @return A pointer to an ED25519PrivateKey representing the input bytes.
   * @throws BadKeyException If an ED25519PrivateKey cannot be realized from the input bytes.
   */
  [[nodiscard]] static std::unique_ptr<ED25519PrivateKey> fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct an ED25519PrivateKey from a seed array.
   *
   * @param seed The seed byte array from which to construct an ED25519PrivateKey.
   * @return A pointer to an ED25519PrivateKey representing the input seed bytes.
   * @throws BadKeyException If an ED25519PrivateKey cannot be realized from the input seed bytes.
   */
  [[nodiscard]] static std::unique_ptr<ED25519PrivateKey> fromSeed(const std::vector<std::byte>& seed);

  /**
   * Derived from Key. Create a clone of this ED25519PrivateKey object.
   *
   * @return A pointer to the created clone of this ED25519PrivateKey.
   */
  [[nodiscard]] std::unique_ptr<Key> clone() const override;

  /**
   * Derived from Key. Construct a Key protobuf object from this ED25519PrivateKey object's ED25519PublicKey.
   *
   * @return A pointer to a created Key protobuf object filled with this ED25519PrivateKey object's ED25519PublicKey
   *         data.
   * @throws OpenSSLException If OpenSSL is unable to serialize this ED25519PrivateKey object's ED25519PublicKey.
   */
  [[nodiscard]] std::unique_ptr<proto::Key> toProtobufKey() const override;

  /**
   * Derived from PrivateKey. Derive a child ED25519PrivateKey from this ED25519PrivateKey.
   *
   * @param childIndex The unhardened index of the child to derive.
   * @return A pointer to the derived ED25519PrivateKey child.
   * @throws OpenSSLException       If OpenSSL is unable to derive a key with the given childIndex.
   * @throws UninitializedException If this ED25519PrivateKey was not initialized with a chain code.
   * @throws std::invalid_argument  If the input index is hardened.
   */
  [[nodiscard]] std::unique_ptr<PrivateKey> derive(uint32_t childIndex) const override;

  /**
   * Derived from PrivateKey. Sign an arbitrary byte array.
   *
   * @param bytesToSign The bytes to sign.
   * @return The signature of the byte array.
   * @throws OpenSSLException If OpenSSL is unable to generate a signature.
   */
  [[nodiscard]] std::vector<std::byte> sign(const std::vector<std::byte>& bytesToSign) const override;

  /**
   * Derived from PrivateKey. Get the hex-encoded string of the DER-encoded bytes of this ED25519PrivateKey.
   *
   * @return The hex-encoded string of the DER-encoded bytes of this ED25519PrivateKey.
   */
  [[nodiscard]] std::string toStringDer() const override;

  /**
   * Derived from PrivateKey. Get the hex-encoded string of the raw, non-DER-encoded bytes of this ED25519PrivateKey.
   *
   * @return The hex-encoded string of the raw bytes of this ED25519PrivateKey.
   */
  [[nodiscard]] std::string toStringRaw() const override;

  /**
   * Derived from Key. Get the byte representation of this ED25519PrivateKey. Returns the same result as toBytesRaw().
   *
   * @return The DER-encoded bytes of this ED25519PrivateKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const override;

  /**
   * Derived from PrivateKey. Get the DER-encoded bytes of this ED25519PrivateKey.
   *
   * @return The DER-encoded bytes of this ED25519PrivateKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytesDer() const override;

  /**
   * Derived from PrivateKey. Get the raw, non-DER-encoded bytes of this ED25519PrivateKey.
   *
   * @return The raw bytes of this ED25519PrivateKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytesRaw() const override;

  /**
   * Construct an ED25519PrivateKey object from zero key string.
   *
   * @return A pointer to an ED25519PrivateKey all zero key. Unusable key defined in HIP-540.
   * @throws BadKeyException If an ED25519PrivateKey cannot be realized zero key hex string.
   */
  [[nodiscard]] static std::unique_ptr<ED25519PrivateKey> getZeroKey();

private:
  /**
   * Construct from a wrapped OpenSSL key object and optionally a chain code.
   *
   * @param key       The wrapped OpenSSL key object.
   * @param chainCode The chain code.
   * @throws OpenSSLException If OpenSSL is unable to get this ED25519PrivateKey's corresponding ED25519PrivateKey's
   *                          bytes.
   * @throws BadKeyException  If the chain code is malformed.
   */
  explicit ED25519PrivateKey(internal::OpenSSLUtils::EVP_PKEY&& key,
                             std::vector<std::byte> chainCode = std::vector<std::byte>());
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ED25519_PRIVATE_KEY_H_
// Filename: src/sdk/main/include/ED25519PublicKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ED25519_PUBLIC_KEY_H_
#define HIERO_SDK_CPP_ED25519_PUBLIC_KEY_H_

#include "PublicKey.h"

#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero
{
/**
 * A class representing an ED25519 public key.
 */
class ED25519PublicKey : public PublicKey
{
public:
  /**
   * The number of raw bytes in an ED25519PublicKey.
   */
  static constexpr const size_t KEY_SIZE = 32ULL;

  /**
   * The prefix bytes of a DER-encoded ED25519PublicKey.
   */
  static inline const std::vector<std::byte> DER_ENCODED_PREFIX_BYTES = {
    std::byte(0x30), std::byte(0x2A), std::byte(0x30), std::byte(0x05), std::byte(0x06), std::byte(0x03),
    std::byte(0x2B), std::byte(0x65), std::byte(0x70), std::byte(0x03), std::byte(0x21), std::byte(0x00)
  };

  /**
   * The hex-encoded string of the DER-encoded prefix bytes of an ED25519PublicKey.
   */
  static inline const std::string DER_ENCODED_PREFIX_HEX = "302A300506032B6570032100";

  /**
   * Disallow default construction of an ED25519PublicKey, as an uninitialized ED25519PublicKey provides no
   * functionality. Instead, a factory function should be used.
   */
  ED25519PublicKey() = delete;

  /**
   * Construct an ED25519PublicKey object from a hex-encoded string (DER-encoded or raw).
   *
   * @param key The hex string from which to construct an ED25519PublicKey.
   * @return A pointer to an ED25519PublicKey representing the input hex string.
   * @throws BadKeyException If an ED25519PublicKey cannot be realized from the input hex string.
   */
  [[nodiscard]] static std::unique_ptr<ED25519PublicKey> fromString(std::string_view key);

  /**
   * Construct an ED25519PublicKey object from a byte vector (DER-encoded or raw).
   *
   * @param bytes The vector of bytes from which to construct an ED25519PublicKey.
   * @return A pointer to an ED25519PublicKey representing the input bytes.
   * @throws BadKeyException If an ED25519PublicKey cannot be realized from the input bytes.
   */
  [[nodiscard]] static std::unique_ptr<ED25519PublicKey> fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Derived from Key. Create a clone of this ED25519PublicKey object.
   *
   * @return A pointer to the created clone of this ED25519PublicKey.
   */
  [[nodiscard]] std::unique_ptr<Key> clone() const override;

  /**
   * Derived from Key. Construct a Key protobuf object from this ED25519PublicKey object.
   *
   * @return A pointer to a created Key protobuf object filled with this ED25519PublicKey object's data.
   * @throws OpenSSLException If OpenSSL is unable to serialize this ED25519PublicKey.
   */
  [[nodiscard]] std::unique_ptr<proto::Key> toProtobufKey() const override;

  /**
   * Derived from PublicKey. Verify that a signature was made by the ED25519PrivateKey which corresponds to this
   * ED25519PublicKey.
   *
   * @param signatureBytes The byte vector representing the signature.
   * @param signedBytes    The bytes which were purportedly signed to create the signature.
   * @return \c TRUE if the signature is valid for this ED25519PublicKey's private key, otherwise \c FALSE.
   * @throws OpenSSLException If OpenSSL is unable to verify the signature.
   */
  [[nodiscard]] bool verifySignature(const std::vector<std::byte>& signatureBytes,
                                     const std::vector<std::byte>& signedBytes) const override;

  /**
   * Derived from PublicKey. Get the hex-encoded string of the DER-encoded bytes of this ED25519PublicKey.
   *
   * @return The hex-encoded string of the DER-encoded bytes of this ED25519PublicKey.
   */
  [[nodiscard]] std::string toStringDer() const override;

  /**
   * Derived from PublicKey. Get the hex-encoded string of the raw bytes of this ED25519PublicKey.
   *
   * @return The hex-encoded string of the raw bytes of this ED25519PublicKey.
   */
  [[nodiscard]] std::string toStringRaw() const override;

  /**
   * Derived from Key. Get the byte representation of this ED25519PublicKey. Returns the same result as toBytesRaw().
   *
   * @return The DER-encoded bytes of this ED25519PublicKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const override;

  /**
   * Derived from PublicKey. Get the DER-encoded bytes of this ED25519PublicKey.
   *
   * @return The DER-encoded bytes of this ED25519PublicKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytesDer() const override;

  /**
   * Derived from PublicKey. Get the raw bytes of this ED25519PublicKey.
   *
   * @return The raw bytes of this ED25519PublicKey.
   */
  [[nodiscard]] std::vector<std::byte> toBytesRaw() const override;

  /**
   * Derived from PublicKey. Serialize this ED25519PublicKey to a SignaturePair protobuf object with the given
   * signature.
   *
   * @param signature The signature created by this ED25519PublicKey.
   */
  [[nodiscard]] std::unique_ptr<proto::SignaturePair> toSignaturePairProtobuf(
    const std::vector<std::byte>& signature) const override;

private:
  /**
   * Construct from a wrapped OpenSSL key object.
   *
   * @param key The wrapped OpenSSL key object from which to construct this ED25519PublicKey.
   */
  explicit ED25519PublicKey(internal::OpenSSLUtils::EVP_PKEY&& key);

  /**
   * Derived from PublicKey. Get a std::shared_ptr to this ED25519PublicKey.
   *
   * @returns A pointer to this ED25519PublicKey.
   */
  [[nodiscard]] std::shared_ptr<PublicKey> getShared() const override;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ED25519_PUBLIC_KEY_H_
// Filename: src/sdk/main/include/Endpoint.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ENDPOINT_H_
#define HIERO_SDK_CPP_ENDPOINT_H_

#include "IPv4Address.h"

#include <memory>
#include <string>

namespace proto
{
class ServiceEndpoint;
}

namespace Hiero
{
/**
 * A network endpoint, which contains an IPv4 address or domain name and a port.
 */
class Endpoint
{
public:
  /**
   * Construct an Endpoint object from a ServiceEndpoint protobuf object.
   *
   * @param proto The ServiceEndpoint protobuf object from which to construct an Endpoint object.
   * @return The constructed Endpoint object.
   */
  [[nodiscard]] static Endpoint fromProtobuf(const proto::ServiceEndpoint& protoServiceEndpoint);

  /**
   * Construct a ServiceEndpoint protobuf object from this Endpoint object.
   *
   * @return A pointer to the created ServiceEndpoint protobuf object filled with this Endpoint object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::ServiceEndpoint> toProtobuf() const;

  /**
   * Get a string representation of this Endpoint.
   *
   * @return A string representation of this Endpoint.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Set the IP address of this Endpoint.
   *
   * @param address The IP address to set.
   * @return A reference to this Endpoint with the newly-set IP address.
   */
  Endpoint& setAddress(const IPv4Address& address);

  /**
   * Set the port of this Endpoint.
   *
   * @param port The port to set.
   * @return A reference to this Endpoint with the newly-set port.
   */
  Endpoint& setPort(unsigned int port);

  /**
   * Set the domain name of this Endpoint.
   *
   * @param domainName The domain name to set.
   * @return A reference to this Endpoint with the newly-set domain name.
   */
  Endpoint& setDomainName(std::string_view domainName);

  /**
   * Get the IP address of this Endpoint.
   *
   * @return The IP address of this Endpoint.
   */
  [[nodiscard]] inline IPv4Address getAddress() const { return mAddress; }

  /**
   * Get the port of this Endpoint.
   *
   * @return The port of this Endpoint.
   */
  [[nodiscard]] inline unsigned int getPort() const { return mPort; }

  /**
   * Get the domain name of this Endpoint.
   *
   * @return The domain name of this Endpoint.
   */
  [[nodiscard]] inline const std::string& getDomainName() const { return mDomainName; }

private:
  /**
   * The IP address of the Endpoint.
   */
  IPv4Address mAddress;

  /**
   * The port of the Endpoint.
   */
  unsigned int mPort = 0U;

  /**
   * A node domain name.
   * This MUST be the fully qualified domain(DNS) name of the node.
   * This value MUST NOT be more than 253 characters.
   * domain_name and ipAddressV4 are mutually exclusive.
   * When the `domain_name` field is set, the `ipAddressV4` field MUST NOT be set.
   * When the `ipAddressV4` field is set, the `domain_name` field MUST NOT be set.
   */
  std::string mDomainName;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ENDPOINT_H_
// Filename: src/sdk/main/include/EthereumFlow.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ETHEREUM_FLOW_H_
#define HIERO_SDK_CPP_ETHEREUM_FLOW_H_

#include "EthereumTransactionData.h"
#include "Hbar.h"

#include <chrono>
#include <memory>
#include <optional>

namespace Hiero
{
class Client;
class TransactionResponse;
}

namespace Hiero
{
/**
 * A helper class to execute an EthereumTransaction. This will use FileCreateTransaction and FileAppendTransaction as
 * necessary to create a file with the call data followed by an EthereumTransaction to execute the EthereumData.
 */
class EthereumFlow
{
public:
  /**
   * Execute the Transactions in this flow (FileCreateTransaction and FileAppendTransaction (if needed), and an
   * EthereumTransaction).
   *
   * @param client The Client to use to submit these Transactions.
   * @return The TransactionResponse object of the EthereumTransaction.
   * @throws MaxAttemptsExceededException If any Transaction attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If any Transaction fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionResponse execute(const Client& client);

  /**
   * Execute the Transactions in this flow (FileCreateTransaction and FileAppendTransaction (if needed), and an
   * EthereumTransaction) with a specified timeout.
   *
   * @param client  The Client to use to submit these Transactions.
   * @param timeout The desired timeout for the execution of these Transactions.
   * @return The TransactionResponse object of the EthereumTransaction.
   * @throws IllegalStateException        If the EthereumData is not set.
   * @throws MaxAttemptsExceededException If any Transaction attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If any Transaction fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionResponse execute(const Client& client, const std::chrono::system_clock::duration& timeout);

  /**
   * Set the bytes of the raw EthereumTransaction (RLP encoded type 0, 1, or 2).
   *
   * @param data The ethereum data to set.
   * @return A reference to this EthereumFlow object with the newly-set ethereum data.
   * @throws std::invalid_argument If the input data is not RLP-encoded Ethereum data.
   */
  EthereumFlow& setEthereumData(const std::vector<std::byte>& data);

  /**
   * Set the maximum amount that the payer of the Hiero transaction is willing to pay to complete the
   * EthereumTransaction.
   *
   * @param maxGasAllowance The maximum amount that the payer of the Hiero transaction is willing to pay to complete
   *                        the EthereumTransaction.
   * @return A reference to this EthereumFlow object with the newly-set maximum gas allowance.
   */
  EthereumFlow& setMaxGasAllowance(const Hbar& maxGasAllowance);

  /**
   * Get the raw EthereumTransaction data.
   *
   * @return The raw EthereumTransaction data.
   */
  [[nodiscard]] inline std::shared_ptr<EthereumTransactionData> getEthereumData() const { return mEthereumData; }

  /**
   * Get the maximum amount that the payer of the Hiero transaction is willing to pay to complete the
   * EthereumTransaction.
   *
   * @return The maximum amount that the payer of the Hiero transaction is willing to pay to complete the
   *         EthereumTransaction. Returns uninitialized in no max gas allowance has been set.
   */
  [[nodiscard]] inline std::optional<Hbar> getMaxGasAllowance() const { return mMaxGasAllowance; }

private:
  /**
   * The maximum size for a EthereumTransaction call data.
   */
  static constexpr unsigned int MAX_ETHEREUM_DATA_SIZE = 5120U;

  /**
   * The data to be submitted as a part of the EthereumTransaction.
   */
  std::shared_ptr<EthereumTransactionData> mEthereumData = nullptr;

  /**
   * The maximum amount that the payer of the Hiero transaction is willing to pay to complete the transaction.
   *
   * Ordinarily the account with the ECDSA alias corresponding to the public key that is extracted from the
   * ethereum data signature is responsible for fees that result from the execution of the transaction. If that amount
   * of authorized fees is not sufficient then the payer of the transaction can be charged, up to but not exceeding this
   * amount. If the ethereum data transaction authorized an amount that was insufficient then the payer will only be
   * charged the amount needed to make up the difference. If the gas price in the transaction was set to zero then the
   * payer will be assessed the entire fee.
   */
  std::optional<Hbar> mMaxGasAllowance;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ETHEREUM_FLOW_H_
// Filename: src/sdk/main/include/EthereumTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ETHEREUM_TRANSACTION_H_
#define HIERO_SDK_CPP_ETHEREUM_TRANSACTION_H_

#include "FileId.h"
#include "Hbar.h"
#include "Transaction.h"

#include <cstddef>
#include <optional>
#include <vector>

namespace proto
{
class EthereumTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * The raw Ethereum transaction (RLP encoded type 0, 1, and 2) will hold signed Ethereum transactions and execute them
 * as Hiero transactions in a prescribed manner.
 *
 * Transaction Signing Requirements:
 *  - The key of the transaction fee-paying account.
 */
class EthereumTransaction : public Transaction<EthereumTransaction>
{
public:
  EthereumTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent an EthereumTransaction transaction.
   */
  explicit EthereumTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit EthereumTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the raw Ethereum transaction (RLP encoded type 0, 1, and 2).
   *
   * @param ethereumData The raw Ethereum transaction.
   * @return A reference to this EthereumTransaction object with the newly-set ethereum data.
   * @throws IllegalStateException If this EthereumTransaction is frozen.
   */
  EthereumTransaction& setEthereumData(const std::vector<std::byte>& ethereumData);

  /**
   * Set the ID of the file that contains the call data.
   *
   * @param fileId The ID of the file that contains the call data.
   * @return A reference to this EthereumTransaction object with the newly-set call data file ID.
   * @throws IllegalStateException If this EthereumTransaction is frozen.
   */
  EthereumTransaction& setCallDataFileId(const FileId& fileId);

  /**
   * Set the maximum amount that the payer of the Hiero transaction is willing to pay to complete this
   * EthereumTransaction.
   *
   * @param maxGasAllowance The maximum amount that the payer of the Hiero transaction is willing to pay to complete
   *                        this EthereumTransaction.
   * @return A reference to this EthereumTransaction object with the newly-set transfer maximum gas allowance.
   * @throws IllegalStateException If this EthereumTransaction is frozen.
   */
  EthereumTransaction& setMaxGasAllowance(const Hbar& maxGasAllowance);

  /**
   * Get the raw Ethereum transaction.
   *
   * @return The raw Ethereum transaction.
   */
  [[nodiscard]] inline std::vector<std::byte> getEthereumData() const { return mEthereumData; }

  /**
   * Get the ID of the file that contains the call data.
   *
   * @return The ID of the file that contains the call data. Returns uninitialized if a value has not been set.
   */
  [[nodiscard]] inline std::optional<FileId> getCallDataFileId() const { return mCallDataFileId; }

  /**
   * Get the maximum amount that the payer of the Hiero transaction is willing to pay to complete this
   * EthereumTransaction.
   *
   * @return The maximum amount that the payer of the Hiero transaction is willing to pay to complete this
   *         EthereumTransaction.
   */
  [[nodiscard]] inline Hbar getMaxGasAllowance() const { return mMaxGasAllowance; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this EthereumTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this EthereumTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This EthereumTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the EthereumTransaction protobuf representation to the Transaction protobuf
   * object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this EthereumTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a EthereumTransactionBody protobuf object from this EthereumTransaction object.
   *
   * @return A pointer to a EthereumTransactionBody protobuf object filled with this EthereumTransaction object's data.
   */
  [[nodiscard]] proto::EthereumTransactionBody* build() const;

  /**
   * The raw Ethereum transaction (RLP encoded type 0, 1, and 2).
   */
  std::vector<std::byte> mEthereumData;

  /**
   * The ID of the file that contains the call data.
   *
   * For large transactions (for example contract creation) this should be used to set the FileId of an HFS file
   * containing the call data of the ethereum data. The data in the ethereum will be re-written with the call data
   * element as a zero-length string with the original contents in the referenced file at the time of execution. The
   * ethereum data will need to be "rehydrated" with the call data for signature validation to pass.
   */
  std::optional<FileId> mCallDataFileId;

  /**
   * The maximum amount that the payer of the Hiero transaction is willing to pay to complete the transaction.
   *
   * Ordinarily the account with the ECDSA alias corresponding to the public key that is extracted from the
   * ethereum data signature is responsible for fees that result from the execution of the transaction. If that amount
   * of authorized fees is not sufficient then the payer of the transaction can be charged, up to but not exceeding this
   * amount. If the ethereum data transaction authorized an amount that was insufficient then the payer will only be
   * charged the amount needed to make up the difference. If the gas price in the transaction was set to zero then the
   * payer will be assessed the entire fee.
   */
  Hbar mMaxGasAllowance = Hbar(0LL);
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ETHEREUM_TRANSACTION_H_
// Filename: src/sdk/main/include/EthereumTransactionData.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ETHEREUM_TRANSACTION_DATA_H_
#define HIERO_SDK_CPP_ETHEREUM_TRANSACTION_DATA_H_

#include <cstddef>
#include <memory>
#include <string>
#include <vector>

namespace Hiero
{
/**
 * Wrapper class for Ethereum data.
 */
class EthereumTransactionData
{
public:
  EthereumTransactionData() = default;
  virtual ~EthereumTransactionData() = default;

  /**
   * Construct with call data.
   *
   * @param callData The call data.
   */
  explicit EthereumTransactionData(std::vector<std::byte> callData);

  /**
   * Construct an EthereumTransactionData object from raw bytes.
   *
   * @param bytes The raw bytes of the ethereum data.
   * @return A pointer to the constructed EthereumTransactionData.
   */
  [[nodiscard]] static std::unique_ptr<EthereumTransactionData> fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Serialize this EthereumTransactionData object into RLP-encoded bytes.
   *
   * @return The RLP-encoded serialized EthereumTransactionData.
   */
  [[nodiscard]] virtual std::vector<std::byte> toBytes() const = 0;

  /**
   * Serialize this EthereumTransactionData object into a hex-encoded, RLP-encoded string.
   *
   * @return The hex-encoded, RLP-encoded EthereumTransactionData.
   */
  [[nodiscard]] virtual std::string toString() const = 0;

  /**
   * The call data.
   */
  std::vector<std::byte> mCallData;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ETHEREUM_TRANSACTION_DATA_H_
// Filename: src/sdk/main/include/EthereumTransactionDataEip1559.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ETHEREUM_TRANSACTION_DATA_EIP1559_H_
#define HIERO_SDK_CPP_ETHEREUM_TRANSACTION_DATA_EIP1559_H_

#include "EthereumTransactionData.h"

#include <cstddef>
#include <memory>
#include <string>
#include <vector>

namespace Hiero
{
/**
 * Wrapper class for EIP1559 Ethereum data.
 */
class EthereumTransactionDataEip1559 : public EthereumTransactionData
{
public:
  EthereumTransactionDataEip1559() = default;

  /**
   * Construct with all fields of Ethereum EIP1559 data.
   *
   * @param chainId  The chain ID.
   * @param nonce    The transaction nonce.
   * @param gasPrice The price of one gas.
   * @param gasLimit The amount of gas available for the transaction.
   * @param to       The receiver of the transaction.
   * @param value    The value of the transaction.
   * @param callData The call data.
   * @param v        The v value of the signature.
   * @param r        The r value of the signature.
   * @param s        The s value of the signature.
   */
  explicit EthereumTransactionDataEip1559(std::vector<std::byte> chainId,
                                          std::vector<std::byte> nonce,
                                          std::vector<std::byte> maxPriorityGas,
                                          std::vector<std::byte> maxGas,
                                          std::vector<std::byte> gasLimit,
                                          std::vector<std::byte> to,
                                          std::vector<std::byte> value,
                                          std::vector<std::byte> callData,
                                          std::vector<std::byte> accessList,
                                          std::vector<std::byte> recoveryId,
                                          std::vector<std::byte> r,
                                          std::vector<std::byte> s);

  /**
   * Construct an EthereumTransactionDataEip1559 object from raw bytes.
   *
   * @param bytes The raw bytes of the ethereum data.
   * @return The constructed EthereumTransactionDataEip1559.
   * @throws std::invalid_argument If the input byte array doesn't follow EIP1559 standards.
   */
  [[nodiscard]] static EthereumTransactionDataEip1559 fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Derived from EthereumTransactionData. Serialize this EthereumTransactionDataEip1559 object into RLP-encoded bytes.
   *
   * @return The RLP-encoded serialized EthereumTransactionDataEip1559.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const override;

  /**
   * Derived from EthereumTransactionData. Serialize this EthereumTransactionDataEip1559 object into a hex-encoded,
   * RLP-encoded string.
   *
   * @return The hex-encoded, RLP-encoded EthereumTransactionDataEip1559.
   */
  [[nodiscard]] std::string toString() const override;

  /**
   * The ID of the chain.
   */
  std::vector<std::byte> mChainId;

  /**
   * The transaction's nonce.
   */
  std::vector<std::byte> mNonce;

  /**
   * An 'optional' additional fee in Ethereum that is paid directly to miners in order to incentivize them to include
   * your transaction in a block. Not used in Hiero
   */
  std::vector<std::byte> mMaxPriorityGas;

  /**
   * The maximum amount, in tinybars, that the payer of the Hiero transaction is willing to pay to complete the
   * transaction.
   */
  std::vector<std::byte> mMaxGas;

  /**
   * The amount of gas available for the transaction.
   */
  std::vector<std::byte> mGasLimit;

  /**
   * The receiver of the transaction.
   */
  std::vector<std::byte> mTo;

  /**
   * The transaction value.
   */
  std::vector<std::byte> mValue;

  /**
   * The array of addresses and storage keys that the transaction plans to access.
   */
  std::vector<std::byte> mAccessList;

  /**
   * The recovery parameter used to ease the signature verification.
   */
  std::vector<std::byte> mRecoveryId;

  /**
   * The R value of the signature.
   */
  std::vector<std::byte> mR;

  /**
   * The S value of the signature.
   */
  std::vector<std::byte> mS;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ETHEREUM_TRANSACTION_DATA_EIP1559_H_
// Filename: src/sdk/main/include/EthereumTransactionDataLegacy.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ETHEREUM_TRANSACTION_DATA_LEGACY_H_
#define HIERO_SDK_CPP_ETHEREUM_TRANSACTION_DATA_LEGACY_H_

#include "EthereumTransactionData.h"

#include <cstddef>
#include <memory>
#include <string>
#include <vector>

namespace Hiero
{
/**
 * Wrapper class for legacy Ethereum data.
 */
class EthereumTransactionDataLegacy : public EthereumTransactionData
{
public:
  EthereumTransactionDataLegacy() = default;

  /**
   * Construct with all fields of Ethereum legacy data.
   *
   * @param nonce    The transaction nonce.
   * @param gasPrice The price of one gas.
   * @param gasLimit The amount of gas available for the transaction.
   * @param to       The receiver of the transaction.
   * @param value    The value of the transaction.
   * @param callData The call data.
   * @param v        The v value of the signature.
   * @param r        The r value of the signature.
   * @param s        The s value of the signature.
   */
  explicit EthereumTransactionDataLegacy(std::vector<std::byte> nonce,
                                         std::vector<std::byte> gasPrice,
                                         std::vector<std::byte> gasLimit,
                                         std::vector<std::byte> to,
                                         std::vector<std::byte> value,
                                         std::vector<std::byte> callData,
                                         std::vector<std::byte> v,
                                         std::vector<std::byte> r,
                                         std::vector<std::byte> s);

  /**
   * Construct an EthereumTransactionDataLegacy object from raw bytes.
   *
   * @param bytes The raw bytes of the ethereum data.
   * @return The constructed EthereumTransactionDataLegacy.
   * @throws std::invalid_argument If the input byte array isn't a list of RLP-encoded values or there aren't the
   *                               correct number of values (9).
   */
  [[nodiscard]] static EthereumTransactionDataLegacy fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Derived from EthereumTransactionData. Serialize this EthereumTransactionDataLegacy object into RLP-encoded bytes.
   *
   * @return The RLP-encoded serialized EthereumTransactionDataLegacy.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const override;

  /**
   * Derived from EthereumTransactionData. Serialize this EthereumTransactionDataLegacy object into a hex-encoded,
   * RLP-encoded string.
   *
   * @return The hex-encoded, RLP-encoded EthereumTransactionDataLegacy.
   */
  [[nodiscard]] std::string toString() const override;

  /**
   * The transaction's nonce.
   */
  std::vector<std::byte> mNonce;

  /**
   * The price for one gas.
   */
  std::vector<std::byte> mGasPrice;

  /**
   * The amount of gas available for the transaction.
   */
  std::vector<std::byte> mGasLimit;

  /**
   * The receiver of the transaction.
   */
  std::vector<std::byte> mTo;

  /**
   * The transaction value.
   */
  std::vector<std::byte> mValue;

  /**
   * The V value of the signature.
   */
  std::vector<std::byte> mV;

  /**
   * The R value of the signature.
   */
  std::vector<std::byte> mR;

  /**
   * The S value of the signature.
   */
  std::vector<std::byte> mS;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ETHEREUM_TRANSACTION_DATA_LEGACY_H_
// Filename: src/sdk/main/include/EvmAddress.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_EVM_ADDRESS_H_
#define HIERO_SDK_CPP_EVM_ADDRESS_H_

#include <string>
#include <string_view>
#include <vector>

namespace Hiero
{
/**
 * A wrapper class for a 20-byte ethereum account address.
 */
class EvmAddress
{
public:
  /**
   * The number of bytes an EVM address should be.
   */
  static constexpr const size_t NUM_BYTES = 20ULL;

  /**
   * Construct an EvmAddress from a hex-encoded string that represents the 20-byte EVM address.
   *
   * @param address The hex-encoded string representing the EvmAddress.
   * @throws std::invalid_argument If the input string is malformed.
   * @throws OpenSSLException If OpenSSL is unable to convert the string to a byte array.
   */
  [[nodiscard]] static EvmAddress fromString(std::string_view address);

  /**
   * Construct an EvmAddress from a 20-byte buffer.
   *
   * @param bytes The bytes of the EvmAddress.
   * @throws std::invalid_argument If the input byte buffer is not 20 bytes long.
   */
  [[nodiscard]] static EvmAddress fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Get the hex-encoded string representation of this EVM address.
   *
   * @return The hex-encoded string representation of this EVM address.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Get the bytes of this EVM address.
   *
   * @return The bytes of this EVM address.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

private:
  EvmAddress() = default;

  /**
   * Helper function for making sure this EVM address is correctly formed.
   *
   * @throws std::invalid_argument If this EVM address is malformed.
   */
  void checkEvmAddress() const;

  /**
   * The 20-byte buffer that represents the address for an ethereum account.
   */
  std::vector<std::byte> mEvmAddress;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_EVM_ADDRESS_H_
// Filename: src/sdk/main/include/ExchangeRate.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_EXCHANGE_RATE_H_
#define HIERO_SDK_CPP_EXCHANGE_RATE_H_

#include <chrono>
#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class ExchangeRate;
}

namespace Hiero
{
/**
 * An exchange rate between hbar and cents (USD) and the time at which the exchange rate will expire, and be superseded
 * by a new exchange rate.
 */
class ExchangeRate
{
public:
  ExchangeRate() = default;

  /**
   * Construct from an Hbar amount, cents amount, and an expiration time.
   *
   * @param hbar  The amount of Hbar.
   * @param cents The amount of USD (in cents).
   * @param expirationTime The time this ExchangeRate expires.
   */
  ExchangeRate(int hbar, int cents, const std::chrono::system_clock::time_point& expirationTime);

  /**
   * Construct an ExchangeRate object from an ExchangeRate protobuf object.
   *
   * @param proto The ExchangeRate protobuf object from which to construct an ExchangeRate object.
   * @return The constructed ExchangeRate object.
   */
  [[nodiscard]] static ExchangeRate fromProtobuf(const proto::ExchangeRate& proto);

  /**
   * Construct an ExchangeRate object from a byte array.
   *
   * @param bytes The byte array from which to construct an ExchangeRate object.
   * @return The constructed ExchangeRate object.
   */
  [[nodiscard]] static ExchangeRate fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct an ExchangeRate protobuf object from this ExchangeRate object.
   *
   * @return A pointer to the created ExchangeRate protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::ExchangeRate> toProtobuf() const;

  /**
   * Construct a representative byte array from this ExchangeRate object.
   *
   * @return The byte array representing this ExchangeRate object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this ExchangeRate object.
   *
   * @return The string representation of this ExchangeRate object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this ExchangeRate to an output stream.
   *
   * @param os   The output stream.
   * @param rate The ExchangeRate to print.
   * @return The output stream with this ExchangeRate written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const ExchangeRate& rate);

  /**
   * Denotes Hbar equivalent to cents.
   */
  int mHbars = 0;

  /**
   * Denotes cents equivalent to Hbar.
   */
  int mCents = 0;

  /**
   * Expiration time of this ExchangeRate.
   */
  std::chrono::system_clock::time_point mExpirationTime;

  /**
   * Calculated exchange rate.
   */
  double mExchangeRateInCents = 0.0;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_EXCHANGE_RATE_H_
// Filename: src/sdk/main/include/ExchangeRates.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_EXCHANGE_RATE_SET_H_
#define HIERO_SDK_CPP_EXCHANGE_RATE_SET_H_

#include "ExchangeRate.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class ExchangeRateSet;
}

namespace Hiero
{
/**
 * Two sets of exchange rates, one being the current exchange rate and its expiration, and the other being the exchange
 * rate to be used after the current expires.
 */
class ExchangeRates
{
public:
  ExchangeRates() = default;

  /**
   * Construct with the current ExchangeRate and the next ExchangeRate.
   *
   * @param current The current ExchangeRate.
   * @param next    The next ExchangeRate.
   */
  ExchangeRates(const ExchangeRate& current, const ExchangeRate& next);

  /**
   * Construct an ExchangeRates object from an ExchangeRateSet protobuf object.
   *
   * @param proto The ExchangeRateSet protobuf object from which to construct an ExchangeRates object.
   * @return The constructed ExchangeRates object.
   */
  [[nodiscard]] static ExchangeRates fromProtobuf(const proto::ExchangeRateSet& proto);

  /**
   * Construct an ExchangeRates object from a byte array.
   *
   * @param bytes The byte array from which to construct an ExchangeRates object.
   * @return The constructed ExchangeRates object.
   */
  [[nodiscard]] static ExchangeRates fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct an ExchangeRateSet protobuf object from this ExchangeRates object.
   *
   * @return A pointer to the created ExchangeRateSet protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::ExchangeRateSet> toProtobuf() const;

  /**
   * Construct a representative byte array from this ExchangeRates object.
   *
   * @return The byte array representing this ExchangeRates object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this ExchangeRates object.
   *
   * @return The string representation of this ExchangeRates object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this ExchangeRates to an output stream.
   *
   * @param os    The output stream.
   * @param rates The ExchangeRates to print.
   * @return The output stream with this ExchangeRates written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const ExchangeRates& rates);

  /**
   * The current exchange rate.
   */
  ExchangeRate mCurrentRate;

  /**
   * The next exchange rate which will take effect when current rate expires.
   */
  ExchangeRate mNextRate;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_EXCHANGE_RATE_SET_H_
// Filename: src/sdk/main/include/Executable.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_EXECUTABLE_H_
#define HIERO_SDK_CPP_EXECUTABLE_H_

#include "AccountId.h"
#include "Defaults.h"
#include "Logger.h"

#include <chrono>
#include <functional>
#include <future>
#include <memory>
#include <mutex>
#include <optional>
#include <stdexcept>
#include <vector>

namespace Hiero
{
namespace internal
{
class Node;
}
class Client;
class TransactionId;
enum class Status;
}

namespace grpc
{
class Status;
}

namespace Hiero
{
/**
 * Base class for queries and transactions that contains the behavior for executing and submitting requests.
 *
 * @tparam SdkRequestType    The SDK request type.
 * @tparam ProtoRequestType  The protobuf request message type.
 * @tparam ProtoResponseType The protobuf response message type.
 * @tparam SdkResponseType   The SDK response type.
 */
template<typename SdkRequestType, typename ProtoRequestType, typename ProtoResponseType, typename SdkResponseType>
class Executable
{
public:
  /**
   * Submit this Executable to a Hiero network.
   *
   * @param client The Client to use to submit this Executable.
   * @return The SdkResponseType object sent from the Hiero network that contains the result of the request.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  virtual SdkResponseType execute(const Client& client);

  /**
   * Submit this Executable to a Hiero network with a specific timeout.
   *
   * @param client  The Client to use to submit this Executable.
   * @param timeout The desired timeout for the execution of this Executable.
   * @return The SdkResponseType object sent from the Hiero network that contains the result of the request.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  virtual SdkResponseType execute(const Client& client, const std::chrono::system_clock::duration& timeout);

  /**
   * Submit this Executable to a Hiero network asynchronously.
   *
   * @param client The Client to use to submit this Executable.
   * @return The future SdkResponseType object sent from the Hiero network that contains the result of the request.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<SdkResponseType> executeAsync(const Client& client);

  /**
   * Submit this Executable to a Hiero network asynchronously with a specific timeout.
   *
   * @param client  The Client to use to submit this Executable.
   * @param timeout The desired timeout for the execution of this Executable.
   * @return The future SdkResponseType object sent from the Hiero network that contains the result of the request.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  virtual std::future<SdkResponseType> executeAsync(const Client& client,
                                                    const std::chrono::system_clock::duration& timeout);

  /**
   * Submit this Executable to a Hiero network asynchronously and consume the response and/or exception with a
   * callback.
   *
   * @param client   The Client to use to submit this Executable.
   * @param callback The callback that should consume the response/exception.
   */
  void executeAsync(const Client& client,
                    const std::function<void(const SdkResponseType&, const std::exception&)>& callback);

  /**
   * Submit this Executable to a Hiero network asynchronously with a specific timeout and consume the response and/or
   * exception with a callback.
   *
   * @param client   The Client to use to submit this Executable.
   * @param timeout  The desired timeout for the execution of this Executable.
   * @param callback The callback that should consume the response/exception.
   */
  void executeAsync(const Client& client,
                    const std::chrono::system_clock::duration& timeout,
                    const std::function<void(const SdkResponseType&, const std::exception&)>& callback);

  /**
   * Submit this Executable to a Hiero network asynchronously and consume the response and/or exception with separate
   * callbacks.
   *
   * @param client            The Client to use to submit this Executable.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void executeAsync(const Client& client,
                    const std::function<void(const SdkResponseType&)>& responseCallback,
                    const std::function<void(const std::exception&)>& exceptionCallback);

  /**
   * Submit this Executable to a Hiero network asynchronously with a specific timeout and consume the response and/or
   * exception with separate callbacks.
   *
   * @param client            The Client to use to submit this Executable.
   * @param timeout           The desired timeout for the execution of this Executable.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void executeAsync(const Client& client,
                    const std::chrono::system_clock::duration& timeout,
                    const std::function<void(const SdkResponseType&)>& responseCallback,
                    const std::function<void(const std::exception&)>& exceptionCallback);

  /**
   * Set the desired account IDs of nodes to which this request will be submitted.
   *
   * @param nodeAccountIds The desired list of account IDs of nodes to submit this request.
   * @return A reference to this Executable derived class with the newly-set node account IDs.
   */
  virtual SdkRequestType& setNodeAccountIds(std::vector<AccountId> nodeAccountIds);

  /**
   * Set the Logger to be used by this Executable.
   *
   * @param logger The Logger to be used by this Executable.
   * @return A reference to this Executable derived class with the newly-set logger.
   */
  SdkRequestType& setLogger(const Logger& logger);

  /**
   * Set a callback to be called right before a request is sent. The callback will receive the request protobuf and the
   * callback should return the same request protobuf. The callback has an opportunity to read, copy, or modify the
   * request that will be sent.
   *
   * @param listener The request listener.
   * @return A reference to this Executable derived class with the newly-set request listener.
   */
  SdkRequestType& setRequestListener(const std::function<ProtoRequestType(ProtoRequestType&)>& listener);

  /**
   * Set a callback to be called right before a response is returned. The callback will receive the response protobuf
   * and the callback should return the same response protobuf. The callback has an opportunity to read, copy, or modify
   * the response that will be used.
   *
   * @param listener The response listener.
   * @return A reference to this Executable derived class with the newly-set response listener.
   */
  SdkRequestType& setResponseListener(const std::function<ProtoResponseType(ProtoResponseType&)>& listener);

  /**
   * Set the maximum number of times this Executable should try to resubmit itself after a failed attempt before it
   * considers itself a failure. This will override the maximum number of attempts of the Client used to submit this
   * Executable.
   *
   * @param attempts The desired maximum number of execution attempts.
   * @return A reference to this Executable derived class with the newly-set maximum number of execution attempts.
   */
  SdkRequestType& setMaxAttempts(uint32_t attempts);

  /**
   * Set the minimum amount of time a Node should wait after this Executable failed to execute before being willing to
   * submit this Executable again. This will override the minimum backoff time of the Client used to submit this
   * Executable.
   *
   * @param backoff The desired minimum amount of time this Executable should wait between retries.
   * @return A reference to this Executable derived class with the newly-set minimum backoff time.
   * @throws std::invalid_argument If the desired minimum backoff duration is longer than the set maximum backoff time
   *                               (DEFAULT_MAX_BACKOFF if the maximum backoff time has not been set).
   */
  SdkRequestType& setMinBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Set the maximum amount of time a Node should wait after this Executable failed to execute before being willing to
   * submit this Executable again. This will override the maximum backoff time of the Client used to submit this
   * Executable.
   *
   * @param backoff The desired maximum amount of time this Executable should wait between retries.
   * @return A reference to this Executable derived class with the newly-set maximum backoff time.
   * @throws std::invalid_argument If the desired maximum backoff duration is shorter than the set minimum backoff time
   *                               (DEFAULT_MIN_BACKOFF if the minimum backoff time has not been set).
   */
  SdkRequestType& setMaxBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Set the maximum amount of time this Executable should spend trying to execute a request before giving up on that
   * request attempt. This will override the gRPC deadline of the Client used to submit this Executable.
   *
   * @param deadline The desired maximum amount of time this Executable should spend trying to execute one request.
   * @return A reference to this Executable derived class with the newly-set gRPC deadline time.
   */
  SdkRequestType& setGrpcDeadline(const std::chrono::system_clock::duration& deadline);

  /**
   * Get the list of account IDs for nodes with which execution will be attempted.
   *
   * @return The list of account IDs of nodes this Executable would attempt request submission.
   */
  [[nodiscard]] inline std::vector<AccountId> getNodeAccountIds() const { return mNodeAccountIds; }

  /**
   * Get the maximum number of times this Executable should try to resubmit itself after a failed attempt before it
   * considers itself a failure.
   *
   * @return The maximum number of execution attempts. Uninitialized value if not previously set.
   */
  [[nodiscard]] inline std::optional<uint32_t> getMaxAttempts() const { return mMaxAttempts; }

  /**
   * Get the minimum amount of time a Node should wait after this Executable failed to execute before being willing to
   * submit this Executable again.
   *
   * @return The minimum backoff time for Nodes for execution attempts of this Executable. Uninitialized value if not
   *         previously set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::duration> getMinBackoff() const { return mMinBackoff; }

  /**
   * Get the maximum amount of time a Node should wait after this Executable failed to execute before being willing to
   * submit this Executable again.
   *
   * @return The maximum backoff time for Nodes for execution attempts of this Executable. Uninitialized value if not
   *         previously set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::duration> getMaxBackoff() const { return mMaxBackoff; }

  /**
   * Set the maximum amount of time this Executable should spend trying to execute a request before giving up on that
   * request attempt.
   *
   * @return The maximum backoff time this Executable should spend on one submission attempt. Uninitialized value if not
   *         previously set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::duration> getGrpcDeadline() const
  {
    return mGrpcDeadline;
  }

protected:
  Executable() = default;
  ~Executable() = default;
  Executable(const Executable&) = default;
  Executable& operator=(const Executable&) = default;
  Executable(Executable&&) noexcept = default;
  Executable& operator=(Executable&&) noexcept = default;

  /**
   * Enumeration describing the status of a submitted Executable.
   */
  enum class ExecutionStatus
  {
    /**
     * The request was successfully executed.
     */
    SUCCESS,
    /**
     * There was an error on the server side that shouldn't be retried.
     */
    SERVER_ERROR,
    /**
     * There was a user error with the request.
     */
    REQUEST_ERROR,
    /**
     * The call was successful but an operation did not complete.
     */
    RETRY
  };

  /**
   * Determine the ExecutionStatus of this Executable after being submitted.
   *
   * @param status   The response status from the network.
   * @param client   The Client that submitted this Executable.
   * @param response The ProtoResponseType received from the network in response to submitting this Executable.
   * @return The status of the submitted Executable.
   */
  [[nodiscard]] virtual ExecutionStatus determineStatus(Status status,
                                                        [[maybe_unused]] const Client& client,
                                                        [[maybe_unused]] const ProtoResponseType& response);

  /**
   * Gets the mirror node resolution for the query.
   *
   * This function returns the mirror node resolution by accessing the first element
   * of the vector mMirrorNodeIds.
   *
   * @return The mirror node resolution as a std::string.
   */
  [[nodiscard]] std::string getMirrorNodeResolution() const { return mMirrorNodeIds[0]; }

private:
  /**
   * Construct a ProtoRequestType object from this Executable, based on the node account ID at the given index.
   *
   * @param index The index of the node account ID that's associated with the Node being used to execute this
   *              Executable.
   * @return A ProtoRequestType object filled with this Executable's data, based on the node account ID at the given
   *         index.
   */
  [[nodiscard]] virtual ProtoRequestType makeRequest(unsigned int index) const = 0;

  /**
   * Construct an SdkResponseType from a ProtoResponseType object.
   *
   * @param response The ProtoResponseType object from which to construct an SdkResponseType object.
   * @return An SdkResponseType object filled with the ProtoResponseType object's data.
   */
  [[nodiscard]] virtual SdkResponseType mapResponse(const ProtoResponseType& response) const = 0;

  /**
   * Get the status response code from a ProtoResponseType object.
   *
   * @param response The ProtoResponseType object from which to grab the status response code.
   * @return The status response code of the input ProtoResponseType object.
   */
  [[nodiscard]] virtual Status mapResponseStatus(const ProtoResponseType& response) const = 0;

  /**
   * Submit a ProtoRequestType object which contains this Executable's data to a Node.
   *
   * @param request  The ProtoRequestType object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] virtual grpc::Status submitRequest(const ProtoRequestType& request,
                                                   const std::shared_ptr<internal::Node>& node,
                                                   const std::chrono::system_clock::time_point& deadline,
                                                   ProtoResponseType* response) const = 0;

  /**
   * Perform any needed actions for this Executable when it is being submitted.
   *
   * @param client The Client being used to submit this Executable.
   */
  virtual void onExecute([[maybe_unused]] const Client& client) = 0;

  /**
   * Get the ID of the transaction for this Executable. For Queries, this is the ID of the payment transaction. For
   * Transactions, this is simply its own transaction ID.
   *
   * @return The ID of the transaction of this Executable.
   */
  [[nodiscard]] virtual std::optional<TransactionId> getTransactionIdInternal() const = 0;

  /**
   * Set the execution parameters to be used to submit this Executable. If any of mMaxAttempts, mMinBackoff, or
   * mMaxBackoff have been set with setMaxAttempts(), setMinBackoff(), or setMaxBackoff() respectively, these values
   * will be placed into mCurrentMaxAttempts, mCurrentMinBackoff, and mCurrentMaxBackoff respectively. If these values
   * have not been set for this Executable, the respective values for the Client will be grabbed and set instead. If
   * these values have not been set in the Client, the defaults are set.
   *
   * @param client The Client submitting this Executable.
   */
  void setExecutionParameters(const Client& client);

  /**
   * Get a list of Nodes that are on the input Client's Network that are being run by this Executable's node account
   * IDs.
   *
   * @param client The Client from which to get the list of Nodes.
   * @return A list of Nodes that are being run by this Executable's node account IDs.
   */
  [[nodiscard]] std::vector<std::shared_ptr<internal::Node>> getNodesFromNodeAccountIds(const Client& client) const;

  /**
   * Get the index of a Node from a list of Nodes to which to try and send this Executable. This will prioritize getting
   * "healthy" Nodes first in order to ensure as little wait time to submit as possible.
   *
   * @param nodes   The list of Nodes from which to select a Node.
   * @param attempt The attempt number of trying to submit this Executable.
   * @return A pointer to a Node to which to try and send this Executable.
   */
  [[nodiscard]] unsigned int getNodeIndexForExecute(const std::vector<std::shared_ptr<internal::Node>>& nodes,
                                                    unsigned int attempt) const;

  /**
   * The Logger to be used by this Executable.
   */
  Logger mLogger;

  /**
   * The list of account IDs of the nodes with which execution should be attempted.
   */
  std::vector<AccountId> mNodeAccountIds;

  /**
   * The list of node IDs of the mirror nodes with which query should be attempted.
   */
  std::vector<std::string> mMirrorNodeIds;

  /**
   * The callback to be called before a request is sent. The callback will receive the protobuf of the request and
   * return the protobuf of the request. This allows the callback to read, copy, and/or modify the request that will be
   * sent.
   */
  std::function<ProtoRequestType(ProtoRequestType&)> mRequestListener;

  /**
   * The callback to be called before a response is returned. The callback will receive the protobuf of the response and
   * return the protobuf of the response. This allows the callback to read, copy, and/or modify the response that will
   * be used.
   */
  std::function<ProtoResponseType(ProtoResponseType&)> mResponseListener;

  /**
   * The maximum number of attempts that will be made to submit this Executable. If not set, a submission will use the
   * Client's set maximum number of attempts. If that's not set, DEFAULT_MAX_ATTEMPTS will be used.
   */
  std::optional<uint32_t> mMaxAttempts;

  /**
   * The minimum amount of time to wait between submission attempts. If not set, a submission will use the Client's set
   * minimum backoff. If that's not set, DEFAULT_MIN_BACKOFF will be used.
   */
  std::optional<std::chrono::system_clock::duration> mMinBackoff;

  /**
   * The maximum amount of time to wait between submission attempts. If not set, a submission will use the Client's set
   * maximum backoff. If that's not set, DEFAULT_MAX_BACKOFF will be used.
   */
  std::optional<std::chrono::system_clock::duration> mMaxBackoff;

  /**
   * The timeout for one single execution attempt. If not set, a submission will use the Client's set gRPC deadline. If
   * that's not set, DEFAULT_GRPC_DEADLINE will be used.
   */
  std::optional<std::chrono::system_clock::duration> mGrpcDeadline;

  /**
   * The maximum number of attempts to be used for an execution. This may be this Executable's mMaxAttempts, the
   * Client's max attempts, or DEFAULT_MAX_ATTEMPTS.
   */
  uint32_t mCurrentMaxAttempts = 0;

  /**
   * The minimum backoff to be used for an execution. This may be this Executable's mMinBackoff, the Client's set
   * minimum backoff, or DEFAULT_MIN_BACKOFF.
   */
  std::chrono::system_clock::duration mCurrentMinBackoff = DEFAULT_MIN_BACKOFF;

  /**
   * The maximum backoff to be used for an execution. This may be this Executable's mMaxBackoff, the Client's set
   * maximum backoff, or DEFAULT_MAX_BACKOFF.
   */
  std::chrono::system_clock::duration mCurrentMaxBackoff = DEFAULT_MAX_BACKOFF;

  /**
   * The current backoff time being used during the current execution. Every failed submission attempt waits a certain
   * amount of time that is double the previous amount of time this Executable waited for its previous submission
   * attempt, up to the specified maximum backoff time, at which point the execution is considered a failure.
   */
  std::chrono::system_clock::duration mCurrentBackoff = DEFAULT_MIN_BACKOFF;

  /**
   * The current gRPC deadline being used for the current execution. This may be the Executable's mGrpcDeadline, the
   * Client's set gRPC deadline, or DEFAULT_GRPC_DEADLINE.
   */
  std::chrono::system_clock::duration mCurrentGrpcDeadline = DEFAULT_GRPC_DEADLINE;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_EXECUTABLE_H_
// Filename: src/sdk/main/include/FeeAssessmentMethod.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FEE_ASSESSMENT_METHOD_H_
#define HIERO_SDK_CPP_FEE_ASSESSMENT_METHOD_H_

#include <string>
#include <unordered_map>

namespace Hiero
{
/**
 * An enumeration the describes how a fee should be assessed.
 */
enum class FeeAssessmentMethod
{
  /**
   * If Alice is paying Bob and an INCLUSIVE fractional fee is collected to be sent to Charlie, the amount Alice
   * declares she will pay in the transfer transaction includes the fee amount. In other words, Bob receives the amount
   * that Alice intended to send minus the fee.
   */
  INCLUSIVE,
  /**
   * If Alice is paying Bob, and an EXCLUSIVE fractional fee is collected to be sent to Charlie, the amount Alice
   * declares she will pay in the transfer transaction does not include the fee amount. In other words, Alice is charged
   * the fee in addition to the amount she intended to send to Bob.
   */
  EXCLUSIVE
};

/**
 * Map of FeeAssessmentMethod to its corresponding string.
 */
const std::unordered_map<FeeAssessmentMethod, std::string> gFeeAssessmentMethodToString = {
  {FeeAssessmentMethod::INCLUSIVE,  "INCLUSIVE"},
  { FeeAssessmentMethod::EXCLUSIVE, "EXCLUSIVE"}
};

/**
 * Map of FeeAssessmentMethod string representation to its corresponding enum value.
 */
[[maybe_unused]] const std::unordered_map<std::string, FeeAssessmentMethod> gStringToFeeAssessmentMethod = {
  {"INCLUSIVE",  FeeAssessmentMethod::INCLUSIVE},
  { "EXCLUSIVE", FeeAssessmentMethod::EXCLUSIVE}
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FEE_ASSESSMENT_METHOD_H_
// Filename: src/sdk/main/include/FeeComponents.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FEE_COMPONENTS_H_
#define HIERO_SDK_CPP_FEE_COMPONENTS_H_

#include <cstddef>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

namespace proto
{
class FeeComponents;
}

namespace Hiero
{
/**
 * A set of prices the nodes use in determining transaction and query fees, and constants involved in fee calculations.
 * Nodes multiply the amount of resources consumed by a transaction or query by the corresponding price to calculate the
 * appropriate fee. Units are one-thousandth of a tinyCent.
 */
class FeeComponents
{
public:
  /**
   * Construct an FeeComponents object from a FeeComponents protobuf object.
   *
   * @param proto The FeeComponents protobuf object from which to construct an FeeComponents object.
   * @return The constructed FeeComponents object.
   */
  [[nodiscard]] static FeeComponents fromProtobuf(const proto::FeeComponents& proto);

  /**
   * Construct an FeeComponents object from a byte array.
   *
   * @param bytes The byte array from which to construct an FeeComponents object.
   * @return The constructed FeeComponents object.
   */
  [[nodiscard]] static FeeComponents fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a FeeComponents protobuf object from this FeeComponents object.
   *
   * @return A pointer to the created FeeComponents protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::FeeComponents> toProtobuf() const;

  /**
   * Construct a representative byte array from this FeeComponents object.
   *
   * @return The byte array representing this FeeComponents object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this FeeComponents object.
   *
   * @return The string representation of this FeeComponents object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Set the minimum component.
   *
   * @param min The minimum component to set.
   * @return A reference to this FeeComponents with the newly-set minimum.
   */
  inline FeeComponents& setMin(int64_t min)
  {
    mMin = min;
    return *this;
  }

  /**
   * Set the maximum component.
   *
   * @param max The maximum component to set.
   * @return A reference to this FeeComponents with the newly-set maximum.
   */
  inline FeeComponents& setMax(int64_t max)
  {
    mMax = max;
    return *this;
  }

  /**
   * Set the constant component.
   *
   * @param constant The constant component to set.
   * @return A reference to this FeeComponents with the newly-set constant.
   */
  inline FeeComponents& setConstant(int64_t constant)
  {
    mConstant = constant;
    return *this;
  }

  /**
   * Set the transaction bandwidth bytes.
   *
   * @param bytes The transaction bandwidth bytes to set.
   * @return A reference to this FeeComponents with the newly-set transaction bandwidth bytes.
   */
  inline FeeComponents& setTransactionBandwidthBytes(int64_t bytes)
  {
    mTransactionBandwidthBytes = bytes;
    return *this;
  }

  /**
   * Set the transaction verification price per signature.
   *
   * @param price The transaction verification price per signature to set.
   * @return A reference to this FeeComponents with the newly-set transaction verification price per signature.
   */
  inline FeeComponents& setTransactionVerification(int64_t price)
  {
    mTransactionVerification = price;
    return *this;
  }

  /**
   * Set the price of RAM consumed in byte hours.
   *
   * @param price The price of RAM consumed in byte hours to set.
   * @return A reference to this FeeComponents with the newly-set price of RAM consumed in byte hours.
   */
  inline FeeComponents& setTransactionRamByteHour(int64_t price)
  {
    mTransactionRamByteHour = price;
    return *this;
  }

  /**
   * Set the price of storage consumed in byte hours.
   *
   * @param price The price of storage consumed in byte hours to set.
   * @return A reference to this FeeComponents with the newly-set price of storage consumed in byte hours.
   */
  inline FeeComponents& setTransactionStorageByteHour(int64_t price)
  {
    mTransactionStorageByteHour = price;
    return *this;
  }

  /**
   * Set the price of computation in gas.
   *
   * @param price The price of computation in gas to set.
   * @return A reference to this FeeComponents with the newly-set the price of computation in gas.
   */
  inline FeeComponents& setContractTransactionGas(int64_t price)
  {
    mContractTransactionGas = price;
    return *this;
  }

  /**
   * Set the price per hbar transferred.
   *
   * @param price The price per hbar transferred to set.
   * @return A reference to this FeeComponents with the newly-set the price per hbar transferred.
   */
  inline FeeComponents& setTransferVolumeHbar(int64_t price)
  {
    mTransferVolumeHbar = price;
    return *this;
  }

  /**
   * Set the price for data retrieved in bytes.
   *
   * @param price The price for data retrieved in bytes to set.
   * @return A reference to this FeeComponents with the newly-set the price for data retrieved in bytes.
   */
  inline FeeComponents& setResponseMemoryByte(int64_t price)
  {
    mResponseMemoryByte = price;
    return *this;
  }

  /**
   * Set the price for data retrieved from disk.
   *
   * @param price The price for data retrieved from disk to set.
   * @return A reference to this FeeComponents with the newly-set the price for data retrieved from disk.
   */
  inline FeeComponents& setResponseDiskByte(int64_t price)
  {
    mResponseDiskByte = price;
    return *this;
  }

  /**
   * Get the minimum component.
   *
   * @return The minimum component.
   */
  [[nodiscard]] inline int64_t getMin() const { return mMin; }

  /**
   * Get the maximum component.
   *
   * @return The maximum component.
   */
  [[nodiscard]] inline int64_t getMax() const { return mMax; }

  /**
   * Get the constant component.
   *
   * @return The constant component.
   */
  [[nodiscard]] inline int64_t getConstant() const { return mConstant; }

  /**
   * Get the transaction bandwidth bytes.
   *
   * @return The transaction bandwidth bytes.
   */
  [[nodiscard]] inline int64_t getTransactionBandwidthBytes() const { return mTransactionBandwidthBytes; }

  /**
   * Get the transaction verification price per signature.
   *
   * @return The transaction verification price per signature.
   */
  [[nodiscard]] inline int64_t getTransactionVerification() const { return mTransactionVerification; }

  /**
   * Get the price of ram consumed in byte hours.
   *
   * @return The price of ram consumed in byte hours.
   */
  [[nodiscard]] inline int64_t getTransactionRamByteHour() const { return mTransactionRamByteHour; }

  /**
   * Get the price of storage consumed in byte hours.
   *
   * @return The price of storage consumed in byte hours.
   */
  [[nodiscard]] inline int64_t getTransactionStorageByteHour() const { return mTransactionStorageByteHour; }

  /**
   * Get the price of computation in gas.
   *
   * @return The price of computation in gas.
   */
  [[nodiscard]] inline int64_t getContractTransactionGas() const { return mContractTransactionGas; }

  /**
   * Get the price per hbar transferred.
   *
   * @return The price per hbar transferred.
   */
  [[nodiscard]] inline int64_t getTransferVolumeHbar() const { return mTransferVolumeHbar; }

  /**
   * Get the price for data retrieved in bytes.
   *
   * @return The price for data retrieved in bytes.
   */
  [[nodiscard]] inline int64_t getResponseMemoryByte() const { return mResponseMemoryByte; }

  /**
   * Get the price for data retrieved from disk.
   *
   * @return The price for data retrieved from disk.
   */
  [[nodiscard]] inline int64_t getResponseDiskByte() const { return mResponseDiskByte; }

private:
  /**
   * A minimum, the calculated fee must be greater than this value.
   */
  int64_t mMin = 0LL;

  /**
   * A maximum, the calculated fee must be less than this value.
   */
  int64_t mMax = 0LL;

  /**
   * A constant contribution to the fee.
   */
  int64_t mConstant = 0LL;

  /**
   * The price of bandwidth consumed by a transaction, measured in bytes.
   */
  int64_t mTransactionBandwidthBytes = 0LL;

  /**
   * The price per signature verification for a transaction.
   */
  int64_t mTransactionVerification = 0LL;

  /**
   * The price of RAM consumed by a transaction, measured in byte-hours.
   */
  int64_t mTransactionRamByteHour = 0LL;

  /**
   * The price of storage consumed by a transaction, measured in byte-hours.
   */
  int64_t mTransactionStorageByteHour = 0LL;

  /**
   * The price of computation for a smart contract transaction, measured in gas.
   */
  int64_t mContractTransactionGas = 0LL;

  /**
   * The price per hbar transferred for a transfer.
   */
  int64_t mTransferVolumeHbar = 0LL;

  /**
   * The price of bandwidth for data retrieved from memory for a response, measured in bytes.
   */
  int64_t mResponseMemoryByte = 0LL;

  /**
   * The price of bandwidth for data retrieved from disk for a response, measured in bytes.
   */
  int64_t mResponseDiskByte = 0LL;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FEE_COMPONENTS_H_
// Filename: src/sdk/main/include/FeeData.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FEE_DATA_H_
#define HIERO_SDK_CPP_FEE_DATA_H_

#include "FeeComponents.h"
#include "FeeDataType.h"

#include <cstddef>
#include <memory>
#include <string>
#include <vector>

namespace proto
{
class FeeData;
}

namespace Hiero
{
/**
 * The total fee charged for a transaction. It is composed of three components - a node fee that compensates the
 * specific node that submitted the transaction, a network fee that compensates the network for assigning the
 * transaction a consensus timestamp, and a service fee that compensates the network for the ongoing maintenance of the
 * consequences of the transaction.
 */
class FeeData
{
public:
  /**
   * Construct an FeeData object from a FeeData protobuf object.
   *
   * @param proto The FeeData protobuf object from which to construct an FeeData object.
   * @return The constructed FeeData object.
   */
  [[nodiscard]] static FeeData fromProtobuf(const proto::FeeData& proto);

  /**
   * Construct an FeeData object from a byte array.
   *
   * @param bytes The byte array from which to construct an FeeData object.
   * @return The constructed FeeData object.
   */
  [[nodiscard]] static FeeData fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a FeeData protobuf object from this FeeData object.
   *
   * @return A pointer to the created FeeData protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::FeeData> toProtobuf() const;

  /**
   * Construct a representative byte array from this FeeData object.
   *
   * @return The byte array representing this FeeData object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this FeeData object.
   *
   * @return The string representation of this FeeData object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Set the node fee data.
   *
   * @param fee The node fee data to set.
   * @return A reference to this FeeData with the newly-set node fee data.
   */
  inline FeeData& setNodeData(const FeeComponents& fee)
  {
    mNodeData = fee;
    return *this;
  }

  /**
   * Set the network fee data.
   *
   * @param fee The network fee data to set.
   * @return A reference to this FeeData with the newly-set network fee data.
   */
  inline FeeData& setNetworkData(const FeeComponents& fee)
  {
    mNetworkData = fee;
    return *this;
  }

  /**
   * Set the service fee data.
   *
   * @param fee The service fee data to set.
   * @return A reference to this FeeData with the newly-set service fee data.
   */
  inline FeeData& setServiceData(const FeeComponents& fee)
  {
    mServiceData = fee;
    return *this;
  }

  /**
   * Set the fee data type.
   *
   * @param type The fee data type to set.
   * @return A reference to this FeeData with the newly-set fee data type.
   */
  inline FeeData& setType(FeeDataType type)
  {
    mType = type;
    return *this;
  }

  /**
   * Get the node fee data.
   *
   * @return The node fee data.
   */
  [[nodiscard]] inline FeeComponents getNodeData() const { return mNodeData; }

  /**
   * Get the network fee data.
   *
   * @return The network fee data.
   */
  [[nodiscard]] inline FeeComponents getNetworkData() const { return mNetworkData; }

  /**
   * Get the service fee data.
   *
   * @return The service fee data.
   */
  [[nodiscard]] inline FeeComponents getServiceData() const { return mServiceData; }

  /**
   * Get the fee data type.
   *
   * @return The fee data type.
   */
  [[nodiscard]] inline FeeDataType getType() const { return mType; }

private:
  /**
   * The components for the fee being paid to the submitting node.
   */
  FeeComponents mNodeData;

  /**
   * The components for the fee being paid to the network for processing a transaction.
   */
  FeeComponents mNetworkData;

  /**
   * The components for the fee being paid to the network for providing the service associated with the transaction.
   */
  FeeComponents mServiceData;

  /**
   * The data type distinguishing between different types of FeeData, correlating to the same Hiero functionality.
   */
  FeeDataType mType = FeeDataType::DEFAULT;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FEE_DATA_H_
// Filename: src/sdk/main/include/FeeDataType.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FEE_DATA_TYPE_H_
#define HIERO_SDK_CPP_FEE_DATA_TYPE_H_

#include <string>
#include <unordered_map>

namespace proto
{
enum SubType : int;
}

namespace Hiero
{
/**
 * Enumeration of fee data types.
 */
enum class FeeDataType
{
  /**
   * The resource prices have no special scope.
   */
  DEFAULT,
  /**
   * The resource prices are scoped to an operation on a fungible common token.
   */
  TOKEN_FUNGIBLE_COMMON,
  /**
   * The resource prices are scoped to an operation on a non-fungible unique token.
   */
  TOKEN_NON_FUNGIBLE_UNIQUE,
  /**
   * The resource prices are scoped to an operation on a fungible common token with a custom fee schedule.
   */
  TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES,
  /**
   * The resource prices are scoped to an operation on a non-fungible unique token with a custom fee schedule.
   */
  TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES,
  /**
   * The resource prices are scoped to a ScheduleCreate containing a ContractCall.
   */
  SCHEDULE_CREATE_CONTRACT_CALL
};

/**
 * Map of protobuf SubTypes to their corresponding FeeDataTypes.
 */
extern const std::unordered_map<proto::SubType, FeeDataType> gProtobufSubTypeToFeeDataType;

/**
 * Map of FeeDataTypes to their corresponding protobuf SubTypes.
 */
extern const std::unordered_map<FeeDataType, proto::SubType> gFeeDataTypeToProtobufSubType;

/**
 * Map of FeeDataType to its corresponding string.
 */
[[maybe_unused]] extern const std::unordered_map<FeeDataType, std::string> gFeeDataTypeToString;

} // namespace Hiero

#endif // HIERO_SDK_CPP_FEE_DATA_TYPE_H_
// Filename: src/sdk/main/include/FeeSchedule.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FEE_SCHEDULE_H_
#define HIERO_SDK_CPP_FEE_SCHEDULE_H_

#include "TransactionFeeSchedule.h"

#include <chrono>
#include <cstddef>
#include <memory>
#include <string>
#include <vector>

namespace proto
{
class FeeSchedule;
}

namespace Hiero
{
/**
 * A list of resource prices fee for different transactions and queries and the time period at which this fee schedule
 * will expire. Nodes use the prices to determine the fees for all transactions based on how much of those resources
 * each transaction uses.
 */
class FeeSchedule
{
public:
  /**
   * Construct a FeeSchedule object from a FeeSchedule protobuf object.
   *
   * @param proto The FeeSchedule protobuf object from which to construct an FeeSchedule object.
   * @return The constructed FeeSchedule object.
   */
  [[nodiscard]] static FeeSchedule fromProtobuf(const proto::FeeSchedule& proto);

  /**
   * Construct a FeeSchedule object from a byte array.
   *
   * @param bytes The byte array from which to construct an FeeSchedule object.
   * @return The constructed FeeSchedule object.
   */
  [[nodiscard]] static FeeSchedule fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a FeeSchedule protobuf object from this FeeSchedule object.
   *
   * @return A pointer to the created FeeSchedule protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::FeeSchedule> toProtobuf() const;

  /**
   * Construct a representative byte array from this FeeSchedule object.
   *
   * @return The byte array representing this FeeSchedule object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this FeeSchedule object.
   *
   * @return The string representation of this FeeSchedule object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Add a TransactionFeeSchedule.
   *
   * @param schedule The schedule to add.
   * @return A reference to this FeeSchedule with the newly-added schedule.
   */
  inline FeeSchedule& addTransactionFeeSchedule(const TransactionFeeSchedule& schedule)
  {
    mTransactionFeeSchedules.push_back(schedule);
    return *this;
  }

  /**
   * Set the expiration time.
   *
   * @param time The expiration time to set.
   * @return A reference to this FeeSchedule with the newly-set expiration time.
   */
  inline FeeSchedule& setExpirationTime(const std::chrono::system_clock::time_point& time)
  {
    mExpirationTime = time;
    return *this;
  }

  /**
   * Get the list of TransactionFeeSchedules.
   *
   * @return The list of TransactionFeeSchedules.
   */
  [[nodiscard]] inline std::vector<TransactionFeeSchedule> getTransactionFeeSchedules() const
  {
    return mTransactionFeeSchedules;
  }

  /**
   * Get the expiration time.
   *
   * @return The expiration time.
   */
  [[nodiscard]] inline std::chrono::system_clock::time_point getExpirationTime() const { return mExpirationTime; }

private:
  /**
   * The list of price coefficients for network resources.
   */
  std::vector<TransactionFeeSchedule> mTransactionFeeSchedules;

  /**
   * The expiration time of this FeeSchedule.
   */
  std::chrono::system_clock::time_point mExpirationTime = std::chrono::system_clock::now();
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FEE_SCHEDULE_H_
// Filename: src/sdk/main/include/FeeSchedules.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FEE_SCHEDULES_H_
#define HIERO_SDK_CPP_FEE_SCHEDULES_H_

#include "FeeSchedule.h"

#include <chrono>
#include <cstddef>
#include <memory>
#include <string>
#include <vector>

namespace proto
{
class CurrentAndNextFeeSchedule;
}

namespace Hiero
{
/**
 * Two fee schedules, one being the current fee schedule and its expiration, and the other being the fee schedule to be
 * used after the current expires.
 */
class FeeSchedules
{
public:
  /**
   * Construct a FeeSchedules object from a CurrentAndNextFeeSchedule protobuf object.
   *
   * @param proto The CurrentAndNextFeeSchedule protobuf object from which to construct an FeeSchedules object.
   * @return The constructed FeeSchedules object.
   */
  [[nodiscard]] static FeeSchedules fromProtobuf(const proto::CurrentAndNextFeeSchedule& proto);

  /**
   * Construct a FeeSchedules object from a byte array.
   *
   * @param bytes The byte array from which to construct an FeeSchedules object.
   * @return The constructed FeeSchedules object.
   */
  [[nodiscard]] static FeeSchedules fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a CurrentAndNextFeeSchedule protobuf object from this FeeSchedules object.
   *
   * @return A pointer to the created CurrentAndNextFeeSchedule protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::CurrentAndNextFeeSchedule> toProtobuf() const;

  /**
   * Construct a representative byte array from this FeeSchedules object.
   *
   * @return The byte array representing this FeeSchedules object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this FeeSchedules object.
   *
   * @return The string representation of this FeeSchedules object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Set the current fee schedule.
   *
   * @param schedule The current fee schedule to set.
   * @return A reference to this FeeSchedules with the newly-added current fee schedule.
   */
  inline FeeSchedules& setCurrent(const FeeSchedule& schedule)
  {
    mCurrentFeeSchedule = schedule;
    return *this;
  }

  /**
   * Set the next fee schedule.
   *
   * @param schedule The next fee schedule to set.
   * @return A reference to this FeeSchedules with the newly-added next fee schedule.
   */
  inline FeeSchedules& setNext(const FeeSchedule& schedule)
  {
    mNextFeeSchedule = schedule;
    return *this;
  }

  /**
   * Get the current fee schedule.
   *
   * @return The current fee schedule.
   */
  [[nodiscard]] inline FeeSchedule getCurrent() const { return mCurrentFeeSchedule; }

  /**
   * Get the next fee schedule.
   *
   * @return The next fee schedule.
   */
  [[nodiscard]] inline FeeSchedule getNext() const { return mNextFeeSchedule; }

private:
  /**
   * The current FeeSchedule.
   */
  FeeSchedule mCurrentFeeSchedule;

  /**
   * The next FeeSchedule.
   */
  FeeSchedule mNextFeeSchedule;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FEE_SCHEDULES_H_
// Filename: src/sdk/main/include/FileAppendTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FILE_APPEND_TRANSACTION_H_
#define HIERO_SDK_CPP_FILE_APPEND_TRANSACTION_H_

#include "ChunkedTransaction.h"
#include "FileId.h"

#include <cstddef>
#include <string_view>
#include <vector>

namespace proto
{
class FileAppendTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that appends new file content to the end of an existing file. The contents of the file can be viewed by
 * submitting a FileContentsQuery request.
 *
 * Transaction Signing Requirements:
 *  - The key on the file is required to sign the transaction if different than the client operator account key.
 */
class FileAppendTransaction : public ChunkedTransaction<FileAppendTransaction>
{
public:
  /**
   * The default chunk size for a FileAppendTransaction.
   */
  static constexpr unsigned int DEFAULT_CHUNK_SIZE = 4096U;

  /**
   * Default constructor. Sets the maximum transaction fee to 5 Hbars, chunk size to 2048 bytes, and sets the receipt
   * retrieval policy to always retrieve receipts between chunk submissions.
   */
  FileAppendTransaction();

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a FileAppend transaction.
   */
  explicit FileAppendTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit FileAppendTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the file to which to append.
   *
   * @param fileId The ID of the file to which to append.
   * @return A reference to this FileAppendTransaction object with the newly-set file ID.
   * @throws IllegalStateException If this FileAppendTransaction is frozen.
   */
  FileAppendTransaction& setFileId(const FileId& fileId);

  /**
   * Set the contents to append.
   *
   * @param contents The contents of the new file.
   * @return A reference to this FileAppendTransaction object with the newly-set contents.
   * @throws IllegalStateException If this FileAppendTransaction is frozen.
   */
  FileAppendTransaction& setContents(const std::vector<std::byte>& contents);
  FileAppendTransaction& setContents(std::string_view contents);

  /**
   * Get the ID of the file to which to append.
   *
   * @return The ID of the file to which to append.
   */
  [[nodiscard]] inline FileId getFileId() const { return mFileId; }

  /**
   * Get the contents to append.
   *
   * @return The contents to append.
   */
  [[nodiscard]] inline std::vector<std::byte> getContents() const { return getData(); }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this FileAppendTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this FileAppendTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This FileAppendTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add this FileAppendTransaction's protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Derived from ChunkedTransaction. Build and add this FileAppendTransaction's chunked protobuf representation to the
   * TransactionBody protobuf object.
   *
   * @param chunk The chunk number.
   * @param total The total number of chunks being created.
   * @param body  The TransactionBody protobuf object to which to add the chunked data.
   */
  void addToChunk(uint32_t chunk, uint32_t /*total*/, proto::TransactionBody& body) const override;

  /**
   * Initialize this FileAppendTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a FileAppendTransactionBody protobuf object from this FileAppendTransaction object. Optionally, build this
   * FileAppendTransaction for a specific chunk.
   *
   * @param chunk The chunk number for which to build this FileAppendTransaction. The default value (-1) indicates to
   *              build for all chunks (i.e. build with all data).
   * @return A pointer to a FileAppendTransactionBody protobuf object filled with this FileAppendTransaction object's
   *         data.
   */
  [[nodiscard]] proto::FileAppendTransactionBody* build(int chunk = -1) const;

  /**
   * The ID of the file to which to append.
   */
  FileId mFileId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FILE_APPEND_TRANSACTION_H_
// Filename: src/sdk/main/include/FileContentsQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FILE_CONTENTS_QUERY_H_
#define HIERO_SDK_CPP_FILE_CONTENTS_QUERY_H_

#include "FileId.h"
#include "Query.h"

#include <cstddef>
#include <optional>
#include <vector>

namespace Hiero
{
/**
 * A query to get the contents of a file. Queries do not change the state of the file or require network consensus. The
 * information is returned from a single node processing the query.
 *
 * Query Signing Requirements:
 *  - The client operator private key is required to sign the query request.
 */
using FileContents = std::vector<std::byte>;
class FileContentsQuery : public Query<FileContentsQuery, FileContents>
{
public:
  /**
   * Set the ID of the file of which to request the contents.
   *
   * @param fileId The ID of the file of which to request the contents.
   * @return A reference to this FileContentsQuery object with the newly-set file ID.
   */
  FileContentsQuery& setFileId(const FileId& fileId);

  /**
   * Get the ID of the file of which this query is currently configured to get the contents.
   *
   * @return The ID of the file for which this query is meant.
   */
  [[nodiscard]] inline FileId getFileId() const { return mFileId; }

private:
  /**
   * Derived from Executable. Construct a FileContents object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a FileContents object.
   * @return A FileContents object filled with the Response protobuf object's data
   */
  [[nodiscard]] FileContents mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this FileContentsQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this FileContentsQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This FileContentsQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this FileContentsQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the file of which this query should get the contents.
   */
  FileId mFileId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FILE_CONTENTS_QUERY_H_
// Filename: src/sdk/main/include/FileCreateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FILE_CREATE_TRANSACTION_H_
#define HIERO_SDK_CPP_FILE_CREATE_TRANSACTION_H_

#include "Defaults.h"
#include "Key.h"
#include "KeyList.h"
#include "Transaction.h"

#include <chrono>
#include <cstddef>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class FileCreateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that creates a new file on a Hiero network. The file is referenced by its file ID which can be
 * obtained from the receipt or record once the transaction reaches consensus on a Hiero network. The file does not
 * have a file name. If the file is too big to create with a single FileCreateTransaction(), the file can be appended
 * with the remaining content multiple times using the FileAppendTransaction().
 *
 * Transaction Signing Requirements:
 *  - The key on the file is required to sign the transaction if different than the client operator account key.
 */
class FileCreateTransaction : public Transaction<FileCreateTransaction>
{
public:
  /**
   * Default constructor. Sets the maximum transaction fee to 5 Hbars.
   */
  FileCreateTransaction();

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a FileCreate transaction.
   */
  explicit FileCreateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit FileCreateTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the time at which the new file will expire. When the file expires, it will be deleted. To prevent the file from
   * being deleted, use a FileUpdateTransaction to update with the new expiration time.
   *
   * @param expirationTime The time at which the new file will expire.
   * @return A reference to this FileCreateTransaction object with the newly-set expiration time.
   * @throws IllegalStateException If this FileCreateTransaction is frozen.
   */
  FileCreateTransaction& setExpirationTime(const std::chrono::system_clock::time_point& expirationTime);

  /**
   * Set the Keys that must sign when mutating the new file via FileAppendTransactions or FileUpdateTransactions. If no
   * keys are provided, then the file is immutable and any of the aforementioned transactions will fail.
   *
   * @param keys The keys that must sign any Transaction that edits the created file.
   * @return A reference to this FileCreateTransaction object with the newly-set keys.
   * @throws IllegalStateException If this FileCreateTransaction is frozen.
   */
  FileCreateTransaction& setKeys(const std::vector<std::shared_ptr<Key>>& keys);
  FileCreateTransaction& setKeys(const KeyList& keys);

  /**
   * Set the contents of the new file. The contents cannot exceed 4096 bytes. A FileAppendTransaction must be used to
   * set larger contents.
   *
   * @param contents The contents of the new file.
   * @return A reference to this FileCreateTransaction object with the newly-set contents.
   * @throws std::invalid_argument If the number of bytes exceeds 4096.
   * @throws IllegalStateException If this FileCreateTransaction is frozen.
   */
  FileCreateTransaction& setContents(const std::vector<std::byte>& contents);
  FileCreateTransaction& setContents(std::string_view contents);

  /**
   * Set the memo for the new file. The memo cannot exceed 100 bytes.
   *
   * @param contents The contents of the new file.
   * @return A reference to this FileCreateTransaction object with the newly-set contents.
   * @throws std::invalid_argument If the number of bytes exceeds 4096.
   * @throws IllegalStateException If this FileCreateTransaction is frozen.
   */
  FileCreateTransaction& setFileMemo(std::string_view memo);

  /**
   * Get the time at which the new file will expire.
   *
   * @return The time at which the new file will expire
   */
  [[nodiscard]] inline std::chrono::system_clock::time_point getExpirationTime() const { return mExpirationTime; }

  /**
   * Get the Keys that must sign Transactions to mutate the new file.
   *
   * @return The Keys that must sign Transactions to mutate the new file.
   */
  [[nodiscard]] inline KeyList getKeys() const { return mKeys; }

  /**
   * Get the contents of the new file.
   *
   * @return The contents of the new file
   */
  [[nodiscard]] inline std::vector<std::byte> getContents() const { return mContents; }

  /**
   * Get the memo for the new file.
   *
   * @return The memo for the new file.
   */
  [[nodiscard]] inline std::string getFileMemo() const { return mFileMemo; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this FileCreateTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this FileCreateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This FileCreateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the FileCreateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this FileCreateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a FileCreateTransactionBody protobuf object from this FileCreateTransaction object.
   *
   * @return A pointer to a FileCreateTransactionBody protobuf object filled with this FileCreateTransaction object's
   *         data.
   */
  [[nodiscard]] proto::FileCreateTransactionBody* build() const;

  /**
   * The time at which the new file will expire.
   */
  std::chrono::system_clock::time_point mExpirationTime = std::chrono::system_clock::now() + DEFAULT_AUTO_RENEW_PERIOD;

  /**
   * The keys that must sign Transactions to mutate the new file.
   */
  KeyList mKeys;

  /**
   * The contents of the new file.
   */
  std::vector<std::byte> mContents;

  /**
   * The memo for the new file.
   */
  std::string mFileMemo;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FILE_CREATE_TRANSACTION_H_
// Filename: src/sdk/main/include/FileDeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FILE_DELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_FILE_DELETE_TRANSACTION_H_

#include "FileId.h"
#include "Transaction.h"

namespace proto
{
class FileDeleteTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that deletes a file from a Hiero network. When deleted, a file's contents are truncated to zero length
 * and it can no longer be updated or appended to, or its expiration time extended. When you request the contents or
 * info of a deleted file, the network will return FILE_DELETED.
 *
 * Transaction Signing Requirements:
 *  - The key(s) on the file are required to sign the transaction.
 *  - If you do not sign with the key(s) on the file, you will receive an INVALID_SIGNATURE network error.
 */
class FileDeleteTransaction : public Transaction<FileDeleteTransaction>
{
public:
  FileDeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a FileDelete transaction.
   */
  explicit FileDeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit FileDeleteTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the file to delete.
   *
   * @param fileId The ID of the file to delete.
   * @return A reference to this FileDeleteTransaction object with the newly-set file ID.
   * @throws IllegalStateException If this FileDeleteTransaction is frozen.
   */
  FileDeleteTransaction& setFileId(const FileId& fileId);

  /**
   * Get the ID of the file to delete.
   *
   * @return The ID of the file to delete.
   */
  [[nodiscard]] inline FileId getFileId() const { return mFileId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this FileDeleteTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this FileDeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This FileDeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the FileDeleteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this FileDeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a FileDeleteTransactionBody protobuf object from this FileDeleteTransaction object.
   *
   * @return A pointer to a FileDeleteTransactionBody protobuf object filled with this FileDeleteTransaction object's
   *         data.
   */
  [[nodiscard]] proto::FileDeleteTransactionBody* build() const;

  /**
   * The ID of the file to delete.
   */
  FileId mFileId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FILE_DELETE_TRANSACTION_H_
// Filename: src/sdk/main/include/FileId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FILE_ID_H_
#define HIERO_SDK_CPP_FILE_ID_H_

#include <cstddef>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class FileID;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * The ID for a file on Hiero.
 */
class FileId
{
public:
  FileId() = default;

  /**
   * The public NodeAddressBook for the current network.
   */
  [[maybe_unused]] static const FileId ADDRESS_BOOK;

  /**
   * The fee schedule for the current network.
   */
  [[maybe_unused]] static const FileId FEE_SCHEDULE;

  /**
   * The current exchange rate of HBAR to USD for the current network.
   */
  [[maybe_unused]] static const FileId EXCHANGE_RATES;

  /**
   * Construct with a file number.
   *
   * @param num The file number.
   */
  explicit FileId(uint64_t num);

  /**
   * Construct with a shard, realm, a file number, and optionally a checksum.
   *
   * @param shard    The shard number.
   * @param realm    The realm number.
   * @param num      The file number.
   * @param checksum The checksum.
   */
  explicit FileId(uint64_t shard, uint64_t realm, uint64_t num, std::string_view checksum = "");

  /**
   * Compare this FileId to another FileId and determine if they represent the same file.
   *
   * @param other The other FileId with which to compare this FileId.
   * @return \c TRUE if this FileId is the same as the input FileId, otherwise \c FALSE.
   */
  bool operator==(const FileId& other) const;

  /**
   * Construct a FileId object from a string of the form "<shard>.<realm>.<num>".
   *
   * @param id The file ID string from which to construct.
   * @return The constructed FileId object.
   * @throws std::invalid_argument If the input string is malformed.
   */
  [[nodiscard]] static FileId fromString(std::string_view id);

  /**
   * Construct a FileId from a Solidity address.
   *
   * @param address The Solidity address from which to create a FileId, as a string.
   * @return The constructed FileId object.
   * @throws std::invalid_argument If a Solidity address cannot be realized from the input string.
   */
  [[nodiscard]] static FileId fromSolidityAddress(std::string_view address);

  /**
   * Construct a FileId from a FileId protobuf object.
   *
   * @param proto The FileId protobuf object from which to create a FileId object.
   * @return The constructed FileId object.
   */
  [[nodiscard]] static FileId fromProtobuf(const proto::FileID& proto);

  /**
   * Construct a FileId object from a representative byte array.
   *
   * @param bytes The byte array from which to construct a FileId object.
   * @return The constructed FileId object.
   */
  [[nodiscard]] static FileId fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Verify the checksum of this FileId using the input Client's network.
   *
   * @param client The Client with which to validate this FileId's checksum.
   * @throws BadEntityException If the checksum of this FileId is invalid.
   */
  void validateChecksum(const Client& client) const;

  /**
   * Construct a FileID protobuf object from this FileId object.
   *
   * @return A pointer to the created FileId protobuf object filled with this FileId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::FileID> toProtobuf() const;

  /**
   * Get the Solidity address representation of this FileId (Long-Zero address form).
   *
   * @return The Solidity address representation of this FileId.
   */
  [[nodiscard]] std::string toSolidityAddress() const;

  /**
   * Get the string representation of this FileId object.
   *
   * @return The string representation of this FileId.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Get the string representation of this FileId object with the checksum.
   *
   * @param client The Client with which to generate the checksum.
   * @return The string representation of this FileId object with the checksum.
   */
  [[nodiscard]] std::string toStringWithChecksum([[maybe_unused]] const Client& client) const;

  /**
   * Get a byte array representation of this FileId object.
   *
   * @return A byte array representation of this FileId object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Get the checksum of this ContractId.
   *
   * @return The checksum of this ContractId.
   */
  [[nodiscard]] inline std::string getChecksum() const { return mChecksum; }

  /**
   * The shard number.
   */
  uint64_t mShardNum = 0ULL;

  /**
   * The realm number.
   */
  uint64_t mRealmNum = 0ULL;

  /**
   * The file number.
   */
  uint64_t mFileNum = 0ULL;

private:
  /**
   * The checksum of this FileIds.
   */
  mutable std::string mChecksum;
};

} // namespace Hiero

namespace std
{
template<>
struct hash<Hiero::FileId>
{
  /**
   * Operator override to enable use of FileId as map key
   */
  size_t operator()(const Hiero::FileId& id) const { return hash<string>()(id.toString()); }
};

} // namespace std

#endif // HIERO_SDK_CPP_FILE_ID_H_
// Filename: src/sdk/main/include/FileInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FILE_INFO_H_
#define HIERO_SDK_CPP_FILE_INFO_H_

#include "FileId.h"
#include "KeyList.h"
#include "LedgerId.h"

#include <chrono>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class FileGetInfoResponse_FileInfo;
}

namespace Hiero
{
/**
 * Contains information about a file instance.
 */
class FileInfo
{
public:
  /**
   * Construct a FileInfo object from a FileGetInfoResponse_FileInfo protobuf object.
   *
   * @param proto The FileGetInfoResponse_FileInfo protobuf object from which to construct a FileInfo object.
   * @return The constructed FileInfo object.
   */
  [[nodiscard]] static FileInfo fromProtobuf(const proto::FileGetInfoResponse_FileInfo& proto);

  /**
   * Construct a FileInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a FileInfo object.
   * @return The constructed FileInfo object.
   */
  [[nodiscard]] static FileInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a FileGetInfoResponse_FileInfo protobuf object from this FileInfo object.
   *
   * @return A pointer to the created FileGetInfoResponse_FileInfo protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::FileGetInfoResponse_FileInfo> toProtobuf() const;

  /**
   * Construct a representative byte array from this FileInfo object.
   *
   * @return The byte array representing this FileInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this FileInfo object.
   *
   * @return The string representation of this FileInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this FileInfo to an output stream.
   *
   * @param os   The output stream.
   * @param info The FileInfo to print.
   * @return The output stream with this FileInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const FileInfo& info);

  /**
   * The ID of the file.
   */
  FileId mFileId;

  /**
   * The file size, in bytes.
   */
  uint64_t mSize = 0ULL;

  /**
   * The time at which this file is set to expire.
   */
  std::chrono::system_clock::time_point mExpirationTime;

  /**
   * Is this file deleted, but not yet expired?
   */
  bool mIsDeleted = false;

  /**
   * The admin keys for the file.
   */
  KeyList mAdminKeys;

  /**
   * The memo associated with the file.
   */
  std::string mMemo;

  /**
   * The ID of the ledger on which this file exists.
   */
  LedgerId mLedgerId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FILE_INFO_H_
// Filename: src/sdk/main/include/FileInfoQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FILE_INFO_QUERY_H_
#define HIERO_SDK_CPP_FILE_INFO_QUERY_H_

#include "FileId.h"
#include "Query.h"

namespace Hiero
{
class FileInfo;
class TransactionRecord;
}

namespace Hiero
{
/**
 * A query that returns the current state of a file. Queries do not change the state of the file or require network
 * consensus. The information is returned from a single node processing the query.
 */
class FileInfoQuery : public Query<FileInfoQuery, FileInfo>
{
public:
  /**
   * Set the ID of the file of which to request the info.
   *
   * @param fileId The ID of the desired file of which to request the info.
   * @return A reference to this FileInfoQuery object with the newly-set file ID.
   */
  FileInfoQuery& setFileId(const FileId& fileId);

  /**
   * Get the ID of the file of which this query is currently configured to get the info.
   *
   * @return The ID of the file for which this query is meant.
   */
  [[nodiscard]] inline FileId getfileId() const { return mFileId; }

private:
  /**
   * Derived from Executable. Construct a FileInfo object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a FileInfo object.
   * @return A FileInfo object filled with the Response protobuf object's data
   */
  [[nodiscard]] FileInfo mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this FileInfoQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this FileInfoQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This FileInfoQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this FileInfoQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the file of which this query should get the info.
   */
  FileId mFileId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FILE_INFO_QUERY_H_
// Filename: src/sdk/main/include/FileUpdateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FILE_UPDATE_TRANSACTION_H_
#define HIERO_SDK_CPP_FILE_UPDATE_TRANSACTION_H_

#include "FileId.h"
#include "Key.h"
#include "KeyList.h"
#include "Transaction.h"

#include <chrono>
#include <cstddef>
#include <optional>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class FileUpdateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that updates the state of an existing file on a Hiero network. Once the transaction has been
 * processed, the network will be updated with the new field values of the file. If you need to access a previous state
 * of the file, you can query a mirror node.
 *
 * Transaction Signing Requirements:
 *  - The key or keys on the file are required to sign this transaction to modify the file properties.
 *  - If you are updating the keys on the file, you must sign with the old key and the new key.
 *  - If you do not sign with the key(s) on the file, you will receive an INVALID_SIGNATURE network error.
 */
class FileUpdateTransaction : public Transaction<FileUpdateTransaction>
{
public:
  FileUpdateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a FileUpdate transaction.
   */
  explicit FileUpdateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit FileUpdateTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the file to update.
   *
   * @param fileId The ID of the file to update.
   * @return A reference to this FileUpdateTransaction object with the newly-set file ID.
   * @throws IllegalStateException If this FileUpdateTransaction is frozen.
   */
  FileUpdateTransaction& setFileId(const FileId& fileId);

  /**
   * Set the new time at which the file will expire.
   *
   * @param expirationTime The new time at which the file will expire.
   * @return A reference to this FileUpdateTransaction object with the newly-set expiration time.
   * @throws IllegalStateException If this FileUpdateTransaction is frozen.
   */
  FileUpdateTransaction& setExpirationTime(const std::chrono::system_clock::time_point& expirationTime);

  /**
   * Set the new key(s) that must sign when mutating the file.
   *
   * @param keys The keys that must sign any Transaction that edits the created file.
   * @return A reference to this FileUpdateTransaction object with the newly-set keys.
   * @throws IllegalStateException If this FileUpdateTransaction is frozen.
   */
  FileUpdateTransaction& setKeys(const std::vector<std::shared_ptr<Key>>& keys);
  FileUpdateTransaction& setKeys(const KeyList& keys);

  /**
   * Set the new contents of the file. The contents cannot exceed 4096 bytes. A FileAppendTransaction must be used to
   * set larger contents.
   *
   * @param contents The new contents of the file.
   * @return A reference to this FileUpdateTransaction object with the newly-set contents.
   * @throws std::invalid_argument If the number of bytes exceeds 4096.
   * @throws IllegalStateException If this FileUpdateTransaction is frozen.
   */
  FileUpdateTransaction& setContents(const std::vector<std::byte>& contents);
  FileUpdateTransaction& setContents(std::string_view contents);

  /**
   * Set the new memo for the file.
   *
   * @param memo The new memo of the file.
   * @return A reference to this FileUpdateTransaction object with the newly-set memo.
   * @throws IllegalStateException If this FileUpdateTransaction is frozen.
   */
  FileUpdateTransaction& setFileMemo(std::string_view memo);

  /**
   * Get the ID of the file to update.
   *
   * @return The ID of the file to update.
   */
  [[nodiscard]] inline FileId getFileId() const { return mFileId; }

  /**
   * Get the new time at which the file will expire.
   *
   * @return The new time at which the file will expire.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::time_point> getExpirationTime() const
  {
    return mExpirationTime;
  }

  /**
   * Get the new keys to be associated with the file.
   *
   * @return The new keys to be associated with the file.
   */
  [[nodiscard]] inline std::optional<KeyList> getKeys() const { return mKeys; }

  /**
   * Get the new contents of the file.
   *
   * @return The new contents of the file
   */
  [[nodiscard]] inline std::optional<std::vector<std::byte>> getContents() const { return mContents; }

  /**
   * Get the new memo for the file.
   *
   * @return The new memo for the file.
   */
  [[nodiscard]] inline std::optional<std::string> getFileMemo() const { return mFileMemo; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this FileUpdateTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this FileUpdateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This FileUpdateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the FileUpdateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this FileUpdateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a FileUpdateTransactionBody protobuf object from this FileUpdateTransaction object.
   *
   * @return A pointer to a FileUpdateTransactionBody protobuf object filled with this FileUpdateTransaction object's
   *         data.
   */
  [[nodiscard]] proto::FileUpdateTransactionBody* build() const;

  /**
   * The ID of the file to update.
   */
  FileId mFileId;

  /**
   * The new time at which the file will expire.
   */
  std::optional<std::chrono::system_clock::time_point> mExpirationTime;

  /**
   * The new keys that must sign Transactions to mutate the file.
   */
  std::optional<KeyList> mKeys;

  /**
   * The new contents of the file.
   */
  std::optional<std::vector<std::byte>> mContents;

  /**
   * The new memo for the file.
   */
  std::optional<std::string> mFileMemo;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FILE_UPDATE_TRANSACTION_H_
// Filename: src/sdk/main/include/FreezeTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FREEZE_TRANSACTION_H_
#define HIERO_SDK_CPP_FREEZE_TRANSACTION_H_

#include "FileId.h"
#include "FreezeType.h"
#include "Transaction.h"

#include <chrono>
#include <cstddef>
#include <optional>
#include <vector>

namespace proto
{
class FreezeTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 *
 * At consensus, sets the consensus time at which the platform should stop creating events and accepting transactions,
 * and enter a maintenance window.
 *
 * Transaction Signing Requirements:
 *  - The key(s) on the file are required to sign the transaction.
 */
class FreezeTransaction : public Transaction<FreezeTransaction>
{
public:
  FreezeTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a Freeze transaction.
   */
  explicit FreezeTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit FreezeTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the file to use for the network software upgrade.
   *
   * @param fileId The ID of the file to use for the network software upgrade.
   * @return A reference to this FreezeTransaction object with the newly-set file ID.
   * @throws IllegalStateException If this FreezeTransaction is frozen.
   */
  FreezeTransaction& setFileId(const FileId& fileId);

  /**
   * Set the expected hash of the contents of the update file.
   *
   * @param hash The expected hash of the contents of the update file.
   * @return A reference to this FreezeTransaction object with the newly-set file hash.
   * @throws IllegalStateException If this FreezeTransaction is frozen.
   */
  FreezeTransaction& setFileHash(const std::vector<std::byte>& hash);

  /**
   * Set the consensus time at which the maintenance window should begin.
   *
   * @param time The consensus time at which the maintenance window should begin.
   * @return A reference to this FreezeTransaction object with the newly-set start time.
   * @throws IllegalStateException If this FreezeTransaction is frozen.
   */
  FreezeTransaction& setStartTime(const std::chrono::system_clock::time_point& time);

  /**
   * Set the type of network freeze or upgrade operation to perform.
   *
   * @param type The type of network freeze or upgrade operation to perform.
   * @return A reference to this FreezeTransaction object with the newly-set freeze type.
   * @throws IllegalStateException If this FreezeTransaction is frozen.
   */
  FreezeTransaction& setFreezeType(const FreezeType& type);

  /**
   * Get the ID of the file to use for the network software upgrade.
   *
   * @return The ID of the file to use for the network software upgrade. Returns uninitialized if the file ID has not
   *         been set.
   */
  [[nodiscard]] inline std::optional<FileId> getFileId() const { return mFileId; }

  /**
   * Get the expected hash of the contents of the update file.
   *
   * @return The expected hash of the contents of the update file.
   */
  [[nodiscard]] inline std::vector<std::byte> getFileHash() const { return mFileHash; }

  /**
   * Get the consensus time at which the maintenance window should begin.
   *
   * @return The consensus time at which the maintenance window should begin.Returns uninitialized if the start time has
   *         not been set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::time_point> getStartTime() const { return mStartTime; }

  /**
   * Get the type of network freeze or upgrade operation to perform.
   *
   * @return The type of network freeze or upgrade operation to perform.
   */
  [[nodiscard]] inline FreezeType getFreezeType() const { return mFreezeType; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this FreezeTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this FreezeTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This FreezeTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the FreezeTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this FreezeTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a FreezeTransactionBody protobuf object from this FreezeTransaction object.
   *
   * @return A pointer to a FreezeTransactionBody protobuf object filled with this FreezeTransaction object's
   *         data.
   */
  [[nodiscard]] proto::FreezeTransactionBody* build() const;

  /**
   * The ID of the file to use for the network software upgrade.
   */
  std::optional<FileId> mFileId;

  /**
   * The expected hash of the contents of the update file.
   */
  std::vector<std::byte> mFileHash;

  /**
   * The consensus time at which the maintenance window should begin.
   */
  std::optional<std::chrono::system_clock::time_point> mStartTime;

  /**
   * The type of network freeze or upgrade operation to perform.
   */
  FreezeType mFreezeType = FreezeType::UNKNOWN_FREEZE_TYPE;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_FREEZE_TRANSACTION_H_
// Filename: src/sdk/main/include/FreezeType.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_FREEZE_TYPE_H_
#define HIERO_SDK_CPP_FREEZE_TYPE_H_

#include <string_view>
#include <unordered_map>

namespace proto
{
enum FreezeType : int;
}

namespace Hiero
{
/**
 * The type of network freeze or upgrade operation to be performed. This type dictates which fields are required.
 */
enum class FreezeType
{
  /**
   * An (invalid) default value for this enum, to ensure the client explicitly sets the intended type of freeze
   * transaction.
   */
  UNKNOWN_FREEZE_TYPE,
  /**
   * Freezes the network at the specified time. The start time field must be provided and must reference a future time.
   * Any values specified for the update file and file hash fields will be ignored. This transaction does not perform
   * any network changes or upgrades and requires manual intervention to restart the network.
   */
  FREEZE_ONLY,
  /**
   * A non-freezing operation that initiates network wide preparation in advance of a scheduled freeze upgrade. The
   * update_file and file_hash fields must be provided and valid. The start_time field may be omitted and any value
   * present will be ignored.
   */
  PREPARE_UPGRADE,
  /**
   * Freezes the network at the specified time and performs the previously prepared automatic upgrade across the entire
   * network.
   */
  FREEZE_UPGRADE,
  /**
   * Aborts a pending network freeze operation.
   */
  FREEZE_ABORT,
  /**
   * Performs an immediate upgrade on auxiliary services and containers providing telemetry/metrics. Does not impact
   * network operations.
   */
  TELEMETRY_UPGRADE
};

/**
 * Map of protobuf FreezeTypes to the corresponding FreezeType.
 */
extern const std::unordered_map<proto::FreezeType, FreezeType> gProtobufFreezeTypeToFreezeType;

/**
 * Map of FreezeTypes to the corresponding protobuf FreezeType.
 */
extern const std::unordered_map<FreezeType, proto::FreezeType> gFreezeTypeToProtobufFreezeType;

/**
 * Map of FreezeType to its corresponding string.
 */
[[maybe_unused]] extern const std::unordered_map<FreezeType, const char*> gFreezeTypeToString;

} // namespace Hiero

#endif // HIERO_SDK_CPP_FREEZE_TYPE_H_
// Filename: src/sdk/main/include/Hbar.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_HBAR_H_
#define HIERO_SDK_CPP_HBAR_H_

#include "HbarUnit.h"

#include <cmath>
#include <regex>

namespace Hiero
{
/**
 * Represents a quantity of hbar.
 *
 * Implemented as a wrapper class to force handling of units. Direct interfacing with Hiero accepts amounts in tinybars
 * however the nominal unit is hbar.
 */

class Hbar
{
public:
  /**
   * Default constructor.
   */
  constexpr Hbar() = default;

  /**
   * Constructs a new Hbar of the specified value.
   *
   * @param amount The amount of Hbar.
   */
  constexpr explicit Hbar(const int64_t& amount)
    : Hbar(amount, HbarUnit::HBAR())
  {
  }

  /**
   * Constructs a new Hbar of the specified value in the specified unit.
   *
   * @param amount The amount.
   * @param unit   The unit for amount.
   */
  constexpr explicit Hbar(const int64_t& amount, const HbarUnit& unit)
    : mValueInTinybar(amount * static_cast<int64_t>(unit.getTinybars()))
  {
  }

  /**
   * Static function to create an Hbar instance from the specified number of tinybars.
   *
   * @param tinybars The amount of tinybars to convert to Hbar.
   * @return A new Hbar instance representing the specified number of tinybars.
   */
  static Hbar fromTinybars(int64_t tinybars) { return Hbar(tinybars, HbarUnit::TINYBAR()); }

  /**
   * Convert this Hbar value to a different unit and return it as an int64_t.
   *
   * @param unit The unit to convert to from Hbar.
   * @return An int64_t representing the converted value.
   */
  inline int64_t to(const HbarUnit& unit) const { return mValueInTinybar / unit.getTinybars(); }

  /**
   * Compare this Hbar to another Hbar and determine if they represent the same amount.
   *
   * @param other The other Hbar with which to compare this Hbar.
   * @return \c TRUE if this Hbar is the same amount as the input Hbar, otherwise \c FALSE.
   */
  bool operator==(const Hbar& other) const { return mValueInTinybar == other.mValueInTinybar; }

  /**
   * Add another Hbar to this Hbar.
   *
   * @param other THe other Hbar to add to this Hbar.
   * @return A new Hbar object with the new value.
   */
  Hbar operator+(const Hbar& other) const { return Hbar(mValueInTinybar + other.mValueInTinybar, HbarUnit::TINYBAR()); }

  /**
   * Add another Hbar to this Hbar and save the value.
   *
   * @param other The other Hbar to add to this Hbar.
   * @return A reference to this Hbar with the new value.
   */
  Hbar& operator+=(const Hbar& other)
  {
    mValueInTinybar += other.mValueInTinybar;
    return *this;
  }

  /**
   * Converts the provided string into an amount of Hbars.
   *
   * @param text The string representing the amount of Hbar.
   * @throws std::invalid_argument If the input string can not be converted to Hbar unit.
   * @return An Hbar instance.
   */
  [[nodiscard]] static Hbar fromString(const std::string& text);

  /**
   * Helper function to get the HbarUnit from the given symbol string.
   *
   * @param symbolString The symbol string representing the HbarUnit.
   * @return The corresponding HbarUnit.
   * @throws std::invalid_argument if the symbol is not recognized.
   */
  [[nodiscard]] static HbarUnit getUnit(const std::string& symbolString);

  /**
   * Convert this Hbar value to tinybars.
   *
   * @return The amount this Hbar object represents in tinybars.
   */
  [[nodiscard]] inline int64_t toTinybars() const { return mValueInTinybar; }

  /**
   * Convert this Hbar value to a string representation.
   *
   * @return A string representing the Hbar value.
   */
  std::string toString() const;

  /**
   * Returns an Hbar whose value is negative this Hbar.
   *
   * @return An Hbar object representing the negated value of this Hbar.
   */
  [[nodiscard]] inline Hbar negated() const { return Hbar(-mValueInTinybar, HbarUnit::TINYBAR()); }

private:
  /**
   * The value of this Hbar object in tinybars.
   */
  int64_t mValueInTinybar = 0LL;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_HBAR_H_
// Filename: src/sdk/main/include/HbarAllowance.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_HBAR_ALLOWANCE_H_
#define HIERO_SDK_CPP_HBAR_ALLOWANCE_H_

#include "AccountId.h"
#include "Hbar.h"

#include <memory>

namespace proto
{
class CryptoAllowance;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * An approved allowance of Hbar transfers for a spender.
 */
class HbarAllowance
{
public:
  HbarAllowance() = default;

  /**
   * Construct with an owner, spender, and an amount.
   *
   * @param owner   The ID of the account approving an allowance of its Hbars.
   * @param spender The ID of the account being allowed to spend the Hbars.
   * @param amount  The amount of Hbars that are being allowed to be spent.
   */
  HbarAllowance(AccountId owner, AccountId spender, const Hbar& amount);

  /**
   * Construct an HbarAllowance object from a CryptoAllowance protobuf object.
   *
   * @param proto The CryptoAllowance protobuf object from which to construct an HbarAllowance object.
   * @return The constructed HbarAllowance object.
   */
  [[nodiscard]] static HbarAllowance fromProtobuf(const proto::CryptoAllowance& proto);

  /**
   * Validate the checksums of the entity IDs in this HbarAllowance.
   *
   * @param client The Client to use to validate the checksums.
   * @throws BadEntityException If the checksums are not valid.
   */
  void validateChecksums(const Client& client) const;

  /**
   * Construct a CryptoAllowance protobuf object from this HbarAllowance object.
   *
   * @return A pointer to a constructed CryptoAllowance protobuf object filled with this HbarAllowance object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::CryptoAllowance> toProtobuf() const;

  /**
   * The ID of the account approving an allowance of its Hbars.
   */
  AccountId mOwnerAccountId;

  /**
   * The ID of the account being allowed to spend the Hbars.
   */
  AccountId mSpenderAccountId;

  /**
   * The amount of Hbars that are being allowed to be spent.
   */
  Hbar mAmount;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_HBAR_ALLOWANCE_H_
// Filename: src/sdk/main/include/HbarTransfer.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_HBAR_TRANSFER_H_
#define HIERO_SDK_CPP_HBAR_TRANSFER_H_

#include "AccountId.h"
#include "Hbar.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class AccountAmount;
}

namespace Hiero
{
class HbarTransfer
{
public:
  HbarTransfer() = default;

  /**
   * Construct with an account ID, amount, and approval.
   *
   * @param accountId The ID of the account doing the transfer.
   * @param amount    The amount to transfer.
   * @param approval  \c TRUE if this is an approved allowance transfer, otherwise \c FALSE.
   */
  explicit HbarTransfer(AccountId accountId, const Hbar& amount, bool approval);

  /**
   * Construct an HbarTransfer object from an AccountAmount protobuf object.
   *
   * @param proto The AccountAmount protobuf object from which to construct an HbarTransfer object.
   * @return The constructed HbarTransfer object.
   */
  [[nodiscard]] static HbarTransfer fromProtobuf(const proto::AccountAmount& proto);

  /**
   * Construct an HbarTransfer object from a byte array.
   *
   * @param bytes The byte array from which to construct an HbarTransfer object.
   * @return The constructed HbarTransfer object.
   */
  [[nodiscard]] static HbarTransfer fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct an AccountAmount protobuf object from this HbarTransfer object.
   *
   * @return A pointer to the created HbarTransfer protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::AccountAmount> toProtobuf() const;

  /**
   * Construct a representative byte array from this HbarTransfer object.
   *
   * @return The byte array representing this HbarTransfer object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this HbarTransfer object.
   *
   * @return The string representation of this HbarTransfer object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this HbarTransfer to an output stream.
   *
   * @param os       The output stream.
   * @param transfer The HbarTransfer to print.
   * @return The output stream with this HbarTransfer written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const HbarTransfer& transfer);

  /**
   * The ID of the account associated with this HbarTransfer.
   */
  AccountId mAccountId;

  /**
   * The amount of Hbar transferred or to be transferred.
   */
  Hbar mAmount = Hbar(0ULL);

  /**
   * Is this transfer approved or not?
   */
  bool mIsApproved = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_HBAR_TRANSFER_H_
// Filename: src/sdk/main/include/HbarUnit.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HBAR_UNIT_H_
#define HBAR_UNIT_H_

#include <map>
#include <string>

namespace Hiero
{
/**
 * Common units of Hbar; for the most part they follow SI prefix conventions.
 */
class HbarUnit
{
public:
  /**
   * The atomic (smallest) unit of hbar, used natively by the Hiero network. It is equivalent to 1/100,000,000 hbar.
   */
  static constexpr HbarUnit TINYBAR() { return { "tℏ", 1ULL }; }

  /**
   * Equivalent to 100 tinybar or 1/1,000,000 hbar.
   */
  static constexpr HbarUnit MICROBAR() { return { "μℏ", 100ULL }; }

  /**
   * Equivalent to 100,000 tinybar or 1/1,000 hbar.
   */
  static constexpr HbarUnit MILLIBAR() { return { "mℏ", 100000ULL }; }

  /**
   * The base unit of hbar, equivalent to 100 million tinybar.
   */
  static constexpr HbarUnit HBAR() { return { "ℏ", 100000000ULL }; }

  /**
   * Equivalent to 1 thousand hbar or 100 billion tinybar.
   */
  static constexpr HbarUnit KILOBAR() { return { "kℏ", 100000000000ULL }; }

  /**
   * Equivalent to 1 million hbar or 100 trillion tinybar.
   */
  static constexpr HbarUnit MEGABAR() { return { "Mℏ", 100000000000000ULL }; }

  /**
   * Equivalent to 1 billion hbar or 100 quadrillion tinybar. The maximum hbar amount supported by Hiero in any context
   * is ~92 gigabar (2^63 tinybar); use this unit sparingly.
   */
  static constexpr HbarUnit GIGABAR() { return { "Gℏ", 100000000000000000ULL }; }

  /**
   * Get the symbol of the current unit.
   *
   * @return The symbol of this unit.
   */
  [[nodiscard]] constexpr const char* getSymbol() const { return mSymbol; }

  /**
   * Get the value of this unit, in tinybars.
   *
   * @return The unit value, in tinybars.
   */
  [[nodiscard]] constexpr uint64_t getTinybars() const { return mTinybars; }

private:
  /**
   * Construct with a symbol and a value.
   * @param sym The symbol of the unit
   * @param val The value of the unit, in tinybars
   */
  constexpr HbarUnit(const char* sym, const uint64_t& val)
    : mSymbol(sym)
    , mTinybars(val)
  {
  }

  /**
   * The associated symbol of this unit
   */
  const char* mSymbol;

  /**
   * The value of this unit, in tinybars
   */
  const uint64_t mTinybars;
};

} // namespace Hiero

#endif // HBAR_UNIT_H_// Filename: src/sdk/main/include/IPv4Address.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IPV4_ADDRESS_H_
#define HIERO_SDK_CPP_IPV4_ADDRESS_H_

#include <array>
#include <cstddef>
#include <string>
#include <vector>

namespace Hiero
{
/**
 * An IPv4 address (without port).
 */
class IPv4Address
{
public:
  /**
   * Construct an IPv4Address object from a byte array.
   *
   * @param bytes The byte array from which to construct an IPv4Address.
   * @return The constructed IPv4Address object.
   * @throws std::invalid_argument If an IPv4Address could not be realized from the input bytes.
   */
  [[nodiscard]] static IPv4Address fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Get the byte array representation of this IPv4Address.
   *
   * @return The byte array representation of this IPv4Address.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Get the string representation of this IPv4Address.
   *
   * @return The string representation of this IPv4Address.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Check if the IPV4Address is empty.
   *
   * @return The boolean representation of an IPV4Address empty state.
   */
  [[nodiscard]] bool isEmpty() const;

private:
  /**
   * The four octets of the address.
   */
  std::vector<std::byte> mAddress;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_IPV4_ADDRESS_H_
// Filename: src/sdk/main/include/Key.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_KEY_H_
#define HIERO_SDK_CPP_KEY_H_

#include <cstddef>
#include <memory>
#include <vector>

namespace proto
{
class Key;
}

namespace Hiero
{
/**
 * A generic base class for the signing authority or key that entities in Hiero may have.
 */
class Key
{
public:
  virtual ~Key() = default;

  /**
   * Construct a Key object from a Key protobuf object.
   *
   * @param proto The Key protobuf object from which to create a Key object.
   * @return A pointer to the created PublicKey object.
   * @throws std::invalid_argument If the Key protobuf type is not recognized.
   */
  [[nodiscard]] static std::unique_ptr<Key> fromProtobuf(const proto::Key& proto);

  /**
   * Create a clone of this Key object.
   *
   * @return A pointer to the created clone of this Key.
   */
  [[nodiscard]] virtual std::unique_ptr<Key> clone() const = 0;

  /**
   * Construct a Key protobuf object from this Key object.
   *
   * @return A pointer to the created Key protobuf object filled with this Key object's data.
   */
  [[nodiscard]] virtual std::unique_ptr<proto::Key> toProtobufKey() const = 0;

  /**
   * Get the byte representation of this Key.
   *
   * @return The byte representation of this Key.
   */
  [[nodiscard]] virtual std::vector<std::byte> toBytes() const;

protected:
  Key() = default;

  /**
   * Prevent public copying and moving to prevent slicing. Use the 'clone()' virtual method instead.
   */
  Key(const Key&) = default;
  Key& operator=(const Key&) = default;
  Key(Key&&) = default;
  Key& operator=(Key&&) = default;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_KEY_H_
// Filename: src/sdk/main/include/KeyList.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_KEYLIST_H_
#define HIERO_SDK_CPP_KEYLIST_H_

#include "Key.h"

#include <memory>
#include <string>
#include <vector>

namespace proto
{
class Key;
class KeyList;
class ThresholdKey;
}

namespace Hiero
{
/**
 * A key list key structure where all the keys in the list are required to sign transactions that modify accounts,
 * topics, tokens, smart contracts, or files. A key list can contain a ED25519 or ECDSAsecp256k1 key type.
 *
 * If all the keys in the key list key structure do not sign, the transaction will fail and return an
 * "INVALID_SIGNATURE" error. A key list can have repeated keys. A signature for the repeated key will count as many
 * times as the key is listed in the key list. For example, a key list has three keys. Two of the three public keys in
 * the list are the same. When a user signs a transaction with the repeated key it will account for two out of the three
 * keys required signature.
 */
class KeyList : public Key
{
public:
  /**
   * Construct a KeyList object from a KeyList protobuf object.
   *
   * @param proto     The KeyList protobuf object from which to create a KeyList object.
   * @param threshold The optional threshold of Keys that must sign.
   * @return The created KeyList object.
   * @throws BadKeyException If a key in the KeyList protobuf is unable to be created.
   */
  [[nodiscard]] static KeyList fromProtobuf(const proto::KeyList& proto);

  /**
   * Construct a KeyList object from a ThresholdKey protobuf object.
   *
   * @param proto     The ThresholdKey protobuf object from which to create a KeyList object.
   * @return The created KeyList object.
   * @throws BadKeyException If a key in the KeyList protobuf is unable to be created.
   */
  [[nodiscard]] static KeyList fromProtobuf(const proto::ThresholdKey& proto);

  /**
   * Construct a KeyList object from a list of Keys.
   *
   * @param keys The list of Keys to add to this KeyList.
   * @return The created KeyList object.
   */
  [[nodiscard]] static KeyList of(const std::vector<std::shared_ptr<Key>>& keys);

  /**
   * Construct a Keylist object with a threshold.
   *
   * @param threshold The number of Keys in the KeyList that must sign.
   * @param The created Keylist object.
   */
  [[nodiscard]] static KeyList withThreshold(uint32_t threshold);

  /**
   * Derived from Key. Create a clone of this KeyList object.
   *
   * @return A pointer to the created clone of this KeyList.
   */
  [[nodiscard]] std::unique_ptr<Key> clone() const override;

  /**
   * Derived from Key. Construct a Key protobuf object from this KeyList object.
   *
   * @return A pointer to the created Key protobuf object filled with this KeyList object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::Key> toProtobufKey() const override;

  /**
   * Construct a KeyList protobuf object from this KeyList object.
   *
   * @return A pointer to a created KeyList protobuf object filled with this KeyList object's data.
   * @throws OpenSSLException If OpenSSL is unable to serialize any key in this KeyList.
   */
  [[nodiscard]] std::unique_ptr<proto::KeyList> toProtobuf() const;

  /**
   * Construct a string representation of this KeyList object.
   *
   * @return The string representation of this KeyList object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this KeyList to an output stream.
   *
   * @param os   The output stream.
   * @param list The KeyList to print.
   * @return The output stream with this KeyList written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const KeyList& list);

  /**
   * Set the threshold for this KeyList.
   *
   * @param threshold The threshold for this KeyList.
   * @return A reference to this KeyList with the newly-set threshold.
   */
  KeyList& setThreshold(uint32_t threshold);

  /**
   * Get the threshold for this KeyList.
   *
   * @return The threshold number of Keys that must sign.
   */
  [[nodiscard]] inline uint32_t getThreshold() const { return mThreshold; }

  /**
   * Get the number of keys in this KeyList.
   *
   * @return The number of keys in this KeyList.
   */
  [[nodiscard]] size_t size() const;

  /**
   * Determine if this KeyList contains any keys.
   *
   * @return \c TRUE if this KeyList is empty, otherwise \c FALSE.
   */
  [[nodiscard]] bool empty() const;

  /**
   * Determine if this KeyList contains a certain key.
   *
   * @param key The key to determine if this KeyList contains.
   * @return \c TRUE if this KeyList contains the input key, otherwise \c FALSE.
   */
  [[nodiscard]] bool contains(const Key* key) const;

  /**
   * Add a key to this KeyList.
   *
   * @param key The key to add to this KeyList.
   */
  void push_back(const std::shared_ptr<Key>& key);

  /**
   * Remove a key from this KeyList. Does nothing if the input key is not a part of this KeyList.
   *
   * @param key The key to remove from this KeyList.
   */
  void remove(const Key* key);

  /**
   * Remove all keys from this KeyList.
   */
  void clear();

private:
  /**
   * The list of Keys that all must sign transactions.
   */
  std::vector<std::shared_ptr<Key>> mKeys;

  /**
   * The threshold number of keys that must sign a transaction. 0 means all keys must sign.
   */
  uint32_t mThreshold = 0;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_KEYLIST_H_
// Filename: src/sdk/main/include/LedgerId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_LEDGER_ID_H_
#define HIERO_SDK_CPP_LEDGER_ID_H_

#include <cstddef>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero
{
class LedgerId
{
public:
  LedgerId() = default;

  /**
   * The Hiero Mainnet ledger ID.
   */
  static const LedgerId MAINNET;

  /**
   * The Hiero Testnet ledger ID.
   */
  static const LedgerId TESTNET;

  /**
   * The Hiero Previewnet ledger ID.
   */
  static const LedgerId PREVIEWNET;

  /**
   * Construct a LedgerId from a byte array.
   *
   * @param bytes The bytes from which to construct this LedgerId.
   */
  explicit LedgerId(std::vector<std::byte> bytes);

  /**
   * Compare this LedgerId to another LedgerId and determine if they represent the same ledger.
   *
   * @param other The other LedgerId with which to compare this LedgerId.
   * @return \c TRUE if this LedgerId is the same as the input LedgerId, otherwise \c FALSE.
   */
  bool operator==(const LedgerId& other) const;

  /**
   * Construct a LedgerId object from a string. The string can be either hex-encoded bytes, or "mainnet", "testnet", or
   * "previewnet".
   *
   * @param id The ledger ID string from which to construct.
   * @return The constructed LedgerId object.
   * @throws std::invalid_argument If a LedgerId cannot be realized from the input hex-encoded string.
   */
  [[nodiscard]] static LedgerId fromString(std::string_view id);

  /**
   * Get the string representation of this LedgerId. This will either return "mainnet", "testnet", "previewnet", or the
   * hex-encoded bytes.
   *
   * @return The string representation of this LedgerId.
   * @throws OpenSSLException If OpenSSL is unable to hex-encode the bytes.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Does this LedgerId represent the LedgerId of the Hiero Mainnet?
   *
   * @return \c TRUE if this LedgerId represent the LedgerId of the Hiero Mainnet, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool isMainnet() const { return *this == MAINNET; }

  /**
   * Does this LedgerId represent the LedgerId of the Hiero Testnet?
   *
   * @return \c TRUE if this LedgerId represent the LedgerId of the Hiero Testnet, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool isTestnet() const { return *this == TESTNET; }

  /**
   * Does this LedgerId represent the LedgerId of the Hiero Previewnet?
   *
   * @return \c TRUE if this LedgerId represent the LedgerId of the Hiero Previewnet, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool isPreviewnet() const { return *this == PREVIEWNET; }

  /**
   * Does this LedgerId represent the LedgerId of any Hiero network?
   *
   * @return \c TRUE if this LedgerId represents the LedgerId of any Hiero network, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool isKnownNetwork() const { return isMainnet() || isTestnet() || isPreviewnet(); }

  /**
   * Get the bytes of this LedgerId.
   *
   * @return The bytes of this LedgerId.
   */
  [[nodiscard]] inline std::vector<std::byte> toBytes() const { return mLedgerId; }

private:
  /**
   * The bytes of this LedgerId.
   */
  std::vector<std::byte> mLedgerId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_LEDGER_ID_H_
// Filename: src/sdk/main/include/Logger.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_LOGGER_H_
#define HIERO_SDK_CPP_LOGGER_H_

#include "Defaults.h"

#include <log4cxx/logger.h>
#include <memory>
#include <string_view>

namespace Hiero
{
/**
 * Logger class used by the Hiero C++ SDK. In essence, it's a wrapper for a log4cxx logger instance and provides easier
 * usage.
 */
class Logger
{
public:
  /**
   * Enumeration of logging levels used by Loggers.
   */
  enum class LoggingLevel
  {
    TRACE,
    DEBUG,
    INFO,
    WARN,
    ERROR,
    SILENT
  };

  Logger() = default;

  /**
   * Construct with a specific logging level.
   *
   * @param level The level at which this Logger should log.
   */
  explicit Logger(LoggingLevel level);

  /**
   * Log a trace-level message.
   *
   * @param message The trace-level message to log.
   */
  void trace(std::string_view message) const;

  /**
   * Log a debug-level message.
   *
   * @param message The debug-level message to log.
   */
  void debug(std::string_view message) const;

  /**
   * Log a info-level message.
   *
   * @param message The info-level message to log.
   */
  void info(std::string_view message) const;

  /**
   * Log a warn-level message.
   *
   * @param message The warn-level message to log.
   */
  void warn(std::string_view message) const;

  /**
   * Log a error-level message.
   *
   * @param message The error-level message to log.
   */
  void error(std::string_view message) const;

  /**
   * Set the log4cxx logger this Logger should use.
   *
   * @param logger The log4cxx logger to use.
   * @return A reference to this Logger with the newly-set log4cxx logger.
   */
  Logger& setLogger(const log4cxx::LoggerPtr& logger);

  /**
   * Set the log level for this Logger.
   *
   * @param level The level at which this Logger should log.
   * @return A reference to this Logger with the newly-set logging level.
   */
  Logger& setLevel(LoggingLevel level);

  /**
   * Silence this Logger from logging.
   *
   * @param silent \c TRUE if this Logger should be silent, otherwise \c FALSE.
   * @param A reference to this Logger with the newly-set silence policy.
   */
  Logger& setSilent(bool silent);

  /**
   * Get the log4cxx logger used by this Logger.
   *
   * @return The log4cxx logger used by this Logger.
   */
  [[nodiscard]] inline log4cxx::LoggerPtr getLogger() const { return mLogger; }

  /**
   * Get the LoggingLevel currently being used by this Logger.
   *
   * @return The LoggingLevel currently being used by this Logger.
   */
  [[nodiscard]] inline LoggingLevel getLevel() const { return mCurrentLevel; }

private:
  /**
   * The wrapped log4cxx logger.
   */
  log4cxx::LoggerPtr mLogger = log4cxx::Logger::getLogger(DEFAULT_LOGGER_NAME);

  /**
   * The current logger level.
   */
  LoggingLevel mCurrentLevel = LoggingLevel::TRACE;

  /**
   * The previous logger level.
   */
  LoggingLevel mPreviousLevel = LoggingLevel::TRACE;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_LOGGER_H_
// Filename: src/sdk/main/include/Mnemonic.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_MNEMONIC_H_
#define HIERO_SDK_CPP_MNEMONIC_H_

#include <cstdint>
#include <set>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero
{
/**
 * The mnemonic represented by this class is in 1 of 3 formats:
 *  1. The legacy v1 format. This mnemonic has 22 words from the "legacy-english.txt" word list
 *  2. The legacy v2 format. This mnemonic has 24 words from the "bip39-english.txt" word list. This format is
 *     indistinguishable from the standard format: in order to correctly compute the private key from this mnemonic, the
 *     user must know that they have a legacy phrase
 *  3. The standard format, as defined by BIP39. A BIP39 phrase may have either 12 or 24 words, from the
 *     "bip39-english.txt" list
 */
class Mnemonic
{
public:
  virtual ~Mnemonic() = default;

  /**
   * Get the string representation of this Mnemonic with the form "<word> <word> <word>..." (words separated by spaces).
   *
   * @return The string representation of this Mnemonic.
   */
  [[nodiscard]] std::string toString() const;

protected:
  Mnemonic() = default;

  /**
   * The standard BIP39 word list.
   */
  static const std::vector<std::string_view> BIP39_WORD_LIST;

  /**
   * Splits a mnemonic string into individual words.
   *
   * @param fullMnemonic The mnemonic, represented as a single string, to split.
   * @param delimiter The delimiter with which to separate the words.
   * @return A vector containing the individual words of the mnemonic.
   */
  [[nodiscard]] static std::vector<std::string> splitMnemonicString(std::string_view fullMnemonic,
                                                                    std::string_view delimiter);

  /**
   * Computes the checksum byte from an array of entropy.
   *
   * @param entropy The array of entropy of which to compute the checksum.
   * @return The checksum of the entropy.
   */
  [[nodiscard]] static std::byte computeChecksumFromEntropy(const std::vector<std::byte>& entropy);

  /**
   * Initialize this Mnemonic with a vector of word indices.
   *
   * @param indices The indices with which to initialize this mnemonic.
   * @throws BadMnemonicException If the provided indices aren't valid.
   */
  void initialize(const std::vector<uint16_t>& indices);

  /**
   * Get the indices of the input words.
   *
   * @param words The words from which to get the indices.
   * @return A vector of indices of the input words.
   */
  [[nodiscard]] std::vector<uint16_t> wordsToIndices(const std::vector<std::string>& words) const;

  /**
   * Checks whether the checksum word of this Mnemonic is correct.
   *
   * @return \c TRUE if the checksum succeeds, otherwise \c FALSE.
   */
  [[nodiscard]] bool verifyChecksum() const;

  /**
   * Computes the entropy and checksum of the Mnemonic, as described in BIP39.
   *
   * @return A byte vector, representing the entropy and checksum of the mnemonic.
   */
  [[nodiscard]] std::vector<std::byte> computeEntropyAndChecksum() const;

  /**
   * Get the word list for this Mnemonic.
   *
   * @return The words that make up this Mnemonic.
   */
  [[nodiscard]] virtual const std::vector<std::string_view>& getWordList() const = 0;

  /**
   * Get the values which represent acceptable word counts for this Mnemonic. Some mnemonic types have only 1 acceptable
   * word count, others have multiple.
   *
   * @return The set of acceptable word counts for this Mnemonic.
   */
  [[nodiscard]] virtual const std::set<unsigned long>& getAcceptableWordCounts() const = 0;

private:
  /**
   * Check a vector of indices to determine if they are all valid in the applicable word list.
   *
   * @param indices The indices of which to check the validity.
   * @return \c TRUE if all indices are valid for the applicable word list, otherwise \c FALSE.
   */
  [[nodiscard]] bool validateIndexInputs(const std::vector<uint16_t>& indices) const;

  /**
   * Get the index of a given word in the applicable word list.
   *
   * @param word The word of which to get the index.
   * @return The index of the given word in this Mnemonic's word list.
   * @throws BadMnemonicException If the input word is not in this Mnemonic's word list.
   */
  [[nodiscard]] uint16_t getIndexFromWordString(std::string_view word) const;

  /**
   * Get the word at the given index in this Mnemonic's word list.
   *
   * @param index The index of the word to get.
   * @return The word at input index.
   * @throws std::out_of_range If the index is out of the range of this Mnemonic's word list.
   */
  [[nodiscard]] std::string getWordFromIndex(uint16_t index) const;

  /**
   * The indices of the words that make up this Mnemonic. Each index in this vector represents a word of the Mnemonic.
   * 16 bit unsigned values are used, since BIP39 indices need 11 bits, and legacy word list indices need 12.
   */
  std::vector<uint16_t> mWordIndices;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_MNEMONIC_H_
// Filename: src/sdk/main/include/MnemonicBIP39.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_MNEMONIC_BIP39_H_
#define HIERO_SDK_CPP_MNEMONIC_BIP39_H_

#include "Mnemonic.h"
#include "PrivateKey.h"

#include <cstdint>
#include <memory>
#include <set>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero
{
/**
 * A standard BIP39 mnemonic.
 */
class MnemonicBIP39 : public Mnemonic
{
public:
  /**
   * Initialize a MnemonicBIP39 from a vector of word indices.
   *
   * @param wordIndices The indices of the words from the BIP39 word list to use to create a MnemonicBIP39.
   * @return An initialized MnemonicBIP39.
   * @throws BadMnemonicException If the input indices are not valid or there is an invalid checksum.
   */
  [[nodiscard]] static MnemonicBIP39 initializeBIP39Mnemonic(const std::vector<uint16_t>& wordIndices);

  /**
   * Initialize a MnemonicBIP39 from a vector of word strings.
   *
   * @param words The words from which to create a MnemonicBIP39.
   * @return An initialized MnemonicBIP39.
   * @throws BadMnemonicException If any of the input words are not part of the BIP39 standard word list or if the
   *                              checksum is invalid.
   */
  [[nodiscard]] static MnemonicBIP39 initializeBIP39Mnemonic(const std::vector<std::string>& words);

  /**
   * Initialize a MnemonicBIP39 from a string containing all the words of a mnemonic phrase.
   *
   * @param fullMnemonic The string that contains all the words from which to create a MnemonicBIP39.
   * @param delimiter    The delimiting string for the mnemonic string.
   * @return An initialized MnemonicBIP39.
   * @throws BadMnemonicException If any of the input words are not part of the BIP39 standard word list or if the
   *                              checksum is invalid.
   */
  [[nodiscard]] static MnemonicBIP39 initializeBIP39Mnemonic(std::string_view fullMnemonic,
                                                             std::string_view delimiter = " ");

  /**
   * Generate a MnemonicBIP39 phrase with 12 words.
   *
   * @return The newly-generated MnemonicBIP39.
   */
  [[nodiscard]] static MnemonicBIP39 generate12WordBIP39Mnemonic();

  /**
   * Generate a MnemonicBIP39 phrase with 24 words.
   *
   * @return The newly-generated MnemonicBIP39.
   */
  [[nodiscard]] static MnemonicBIP39 generate24WordBIP39Mnemonic();

  /**
   * Generate a SLIP44-standard ED25519PrivateKey from this Mnemonic using the input passphrase at the specified
   * unhardened index.
   *
   * @param passphrase The passphrase to use to generate the ED25519PrivateKey.
   * @param index      The unhardened index in the derivation path from which to derive the ED25519PrivateKey.
   * @return A pointer to the derived ED25519PrivateKey.
   * @throws OpenSSLException If OpenSSL is unable to generate a key from this MnemonicBIP39.
   * @throws std::invalid_argument If the index is already hardened.
   */
  [[nodiscard]] std::unique_ptr<PrivateKey> toStandardEd25519PrivateKey(std::string_view passphrase = "",
                                                                        uint32_t index = 0) const;

  /**
   * Generate a SLIP44-standard ECDSAsecp256k1PrivateKey from this Mnemonic using the input passphrase at the specified
   * index.
   *
   * @param passphrase The passphrase to use to generate the ECDSAsecp256k1PrivateKey.
   * @param index      The index in the derivation path from which to derive the ECDSAsecp256k1PrivateKey.
   * @return A pointer to the derived ECDSAsecp256k1PrivateKey.
   * @throws OpenSSLException If OpenSSL is unable to generate a key from this MnemonicBIP39.
   */
  [[nodiscard]] std::unique_ptr<PrivateKey> toStandardECDSAsecp256k1PrivateKey(std::string_view passphrase = "",
                                                                               uint32_t index = 0) const;

  /**
   * Compute a seed that results from this MnemonicBIP39.
   *
   * @param passphrase The passphrase to use in seed generation.
   * @return This MnemonicBIP39's seed, given the input passphrase.
   * @throws OpenSSLException If OpenSSL is unable to compute a seed.
   */
  [[nodiscard]] std::vector<std::byte> toSeed(std::string_view passphrase = "") const;

  /**
   * Compute the word indices that result from the input entropy.
   *
   * @param entropy The entropy from which to compute the word indices.
   * @return A vector containing the word indices.
   */
  [[nodiscard]] static std::vector<uint16_t> entropyToWordIndices(const std::vector<std::byte>& entropy);

private:
  /**
   * Hidden constructor. Static initialization/generation functions should be used to create MnemonicBIP39 objects.
   */
  MnemonicBIP39() = default;

  /**
   * Derived from Mnemonic. Get a reference to the BIP39 word list.
   *
   * @return The BIP39 word list.
   */
  [[nodiscard]] const std::vector<std::string_view>& getWordList() const override;

  /**
   * Get the set of acceptable word counts. In the case of a BIP39 passphrase, this set will include 12 and 24.
   *
   * @return The set of acceptable word counts.
   */
  [[nodiscard]] const std::set<unsigned long>& getAcceptableWordCounts() const override;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_MNEMONIC_BIP39_H_
// Filename: src/sdk/main/include/NetworkVersionInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_NETWORK_VERSION_INFO_H_
#define HIERO_SDK_CPP_NETWORK_VERSION_INFO_H_

#include "SemanticVersion.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class NetworkGetVersionInfoResponse;
}

namespace Hiero
{
/**
 * Contains information about the network's version.
 */
class NetworkVersionInfo
{
public:
  NetworkVersionInfo() = default;

  /**
   * Construct from a protobuf schema SemanticVersion and a Hiero services SemanticVersion.
   *
   * @param hapi   The SemanticVersion of the protobuf schema.
   * @param hiero The SemanticVersion of the Hiero services.
   */
  NetworkVersionInfo(const SemanticVersion& hapi, const SemanticVersion& hiero);

  /**
   * Construct a NetworkVersionInfo object from a NetworkGetVersionInfoResponse protobuf object.
   *
   * @param proto The NetworkGetVersionInfoResponse protobuf object from which to construct a NetworkVersionInfo object.
   * @return The constructed NetworkVersionInfo object.
   */
  [[nodiscard]] static NetworkVersionInfo fromProtobuf(const proto::NetworkGetVersionInfoResponse& proto);

  /**
   * Construct a NetworkVersionInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a NetworkVersionInfo object.
   * @return The constructed NetworkVersionInfo object.
   */
  [[nodiscard]] static NetworkVersionInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a NetworkGetVersionInfoResponse protobuf object from this NetworkVersionInfo object.
   *
   * @return A pointer to the created NetworkGetVersionInfoResponse protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::NetworkGetVersionInfoResponse> toProtobuf() const;

  /**
   * Construct a representative byte array from this NetworkVersionInfo object.
   *
   * @return The byte array representing this NetworkVersionInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this NetworkVersionInfo object.
   *
   * @return The string representation of this NetworkVersionInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this NetworkVersionInfo to an output stream.
   *
   * @param os   The output stream.
   * @param info The NetworkVersionInfo to print.
   * @return The output stream with this NetworkVersionInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const NetworkVersionInfo& info);

  /**
   * The version of the protobuf schema in use by the network.
   */
  SemanticVersion mProtobufVersion;

  /**
   * The version of the Hiero services in use by the network.
   */
  SemanticVersion mServicesVersion;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_NETWORK_VERSION_INFO_H_
// Filename: src/sdk/main/include/NetworkVersionInfoQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_NETWORK_VERSION_INFO_QUERY_H_
#define HIERO_SDK_CPP_NETWORK_VERSION_INFO_QUERY_H_

#include "Query.h"

namespace Hiero
{
class NetworkVersionInfo;
}

namespace Hiero
{
/**
 * Get the deployed versions of Hiero Services and the HAPI proto in semantic version format.
 */
class NetworkVersionInfoQuery : public Query<NetworkVersionInfoQuery, NetworkVersionInfo>
{
private:
  /**
   * Derived from Executable. Construct a NetworkVersionInfo object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a NetworkVersionInfo object.
   * @return A NetworkVersionInfo object filled with the Response protobuf object's data
   */
  [[nodiscard]] NetworkVersionInfo mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this NetworkVersionInfoQuery's data to a
   * Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this NetworkVersionInfoQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This NetworkVersionInfoQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this NetworkVersionInfoQuery's data, with the input
   * QueryHeader protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_NETWORK_VERSION_INFO_QUERY_H_
// Filename: src/sdk/main/include/NftId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_NFT_ID_H_
#define HIERO_SDK_CPP_NFT_ID_H_

#include "TokenId.h"

#include <string>
#include <string_view>

namespace proto
{
class NftID;
}

namespace Hiero
{
/**
 * The ID of a non-fungible token (NFT).
 */
class NftId
{
public:
  NftId() = default;

  /**
   * Construct with a TokenId and a serial number.
   *
   * @param id The token ID to set.
   * @param serialNumber The serial number to set.
   * @throws std::invalid_argument If the serial number is too big (max value is std::numeric_limits<int64_t>::max()).
   */
  explicit NftId(TokenId id, const uint64_t& serialNumber);

  /**
   * Compare this NftId to another NftId and determine if they represent the same token.
   *
   * @param other The other NftId with which to compare this NftId.
   * @return \c TRUE if this NftId is the same as the input NftId, otherwise \c FALSE.
   */
  bool operator==(const NftId& other) const;

  /**
   * Construct an NftId object from a string of the form "<shard>.<realm>.<num>/<serialNum>".
   *
   * @param id The NFT ID string from which to construct.
   * @throws std::invalid_argument If the input string is malformed.
   */
  [[nodiscard]] static NftId fromString(std::string_view id);

  /**
   * Construct an NftId object from a NftID protobuf object.
   *
   * @param proto The NftID protobuf object from which to construct a NftId object.
   * @return The constructed NftId object.
   */
  [[nodiscard]] static NftId fromProtobuf(const proto::NftID& proto);

  /**
   * Construct an NftID protobuf object from this NftId object.
   *
   * @return A pointer to the created NftID protobuf object filled with this NftId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::NftID> toProtobuf() const;

  /**
   * Get the string representation of this NftId object with the form "<shard>.<realm>.<num>/<serialNum>".
   *
   * @return The string representation of this NftId.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * The ID of the non-fungible token of which this NFT is an instance.
   */
  TokenId mTokenId;

  /**
   * The serial number of this instance.
   */
  uint64_t mSerialNum = 0ULL;
};

} // namespace Hiero

namespace std
{
template<>
struct hash<Hiero::NftId>
{
  /**
   * Operator override to enable use of NftId as map key.
   */
  size_t operator()(const Hiero::NftId& id) const { return hash<string>()(id.toString()); }
};

} // namespace std

#endif // HIERO_SDK_CPP_NFT_ID_H_
// Filename: src/sdk/main/include/NodeAddress.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_NODE_ADDRESS_H_
#define HIERO_SDK_CPP_NODE_ADDRESS_H_

#include "AccountId.h"
#include "Endpoint.h"

#include <cstddef>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class NodeAddress;
}

namespace Hiero
{
/**
 * Class containing all information related to the address(es) of a node.
 */
class NodeAddress
{
public:
  /**
   * Construct a NodeAddress object from a NodeAddress protobuf object.
   *
   * @param proto The NodeAddress protobuf object from which to construct a NodeAddress object.
   * @return The constructed NodeAddress object.
   */
  [[nodiscard]] static NodeAddress fromProtobuf(const proto::NodeAddress& protoNodeAddress);

  /**
   * Construct a NodeAddress protobuf object from this NodeAddress object.
   *
   * @return A pointer to the created NodeAddress protobuf object filled with this NodeAddress object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::NodeAddress> toProtobuf() const;

  /**
   * Get a string representation of this NodeAddress.
   *
   * @return A string representing this NodeAddress.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Set the public key of this NodeAddress. This should be a hex-encoded string of the public key's DER encoding.
   *
   * @param publicKey The hex-encoded and DER-encoded public key to set.
   * @return A reference to this NodeAddress with the newly-set public key.
   */
  NodeAddress& setPublicKey(std::string_view publicKey);

  /**
   * Set the node ID of this NodeAddress.
   *
   * @param nodeId The node ID to set.
   * @return A reference to this NodeAddress with the newly-set node ID.
   */
  NodeAddress& setNodeId(const int64_t& nodeId);

  /**
   * Set the account ID of this NodeAddress.
   *
   * @param accountId The account ID to set.
   * @return A reference to this NodeAddress with the newly-set account ID.
   */
  NodeAddress& setAccountId(const AccountId& accountId);

  /**
   * Set the certificate hash of this NodeAddress. This should be hex-encoded SHA384 hash of the UTF-8 NFKD encoding of
   * the remote node's TLS cert in PEM format.
   *
   * @param certHash The certificate hash to set.
   * @return A reference to this NodeAddress with the newly-set certificate hash.
   */
  NodeAddress& setCertHash(std::string_view certHash);
  NodeAddress& setCertHash(std::vector<std::byte> certHash);

  /**
   * Set the list of endpoints of this NodeAddress.
   *
   * @param endpoints The list of endpoints to set.
   * @return A reference to this NodeAddress with the newly-set endpoints.
   */
  NodeAddress& setEndpoints(const std::vector<Endpoint>& endpoints);

  /**
   * Set the description text of this NodeAddress.
   *
   * @param description The description text to set.
   * @return A reference to this NodeAddress with the newly-set description.
   */
  NodeAddress& setDescription(std::string_view description);

  /**
   * Get the node ID of this NodeAddress.
   *
   * @return The node ID of this NodeAddress.
   */
  [[nodiscard]] inline int64_t getNodeId() const { return mNodeId; }

  /**
   * Get the public key of this NodeAddress.
   *
   * @return The public key of this NodeAddress.
   */
  [[nodiscard]] inline std::string getPublicKey() const { return mRSAPublicKey; }

  /**
   * Get the account ID of this NodeAddress.
   *
   * @return The account ID of this NodeAddress.
   */
  [[nodiscard]] inline AccountId getAccountId() const { return mNodeAccountId; }

  /**
   * Get the node certificate hash of this NodeAddress.
   *
   * @return The node certificate hash of this NodeAddress.
   */
  [[nodiscard]] inline std::vector<std::byte> getCertHash() const { return mNodeCertHash; }

  /**
   * Get the list of endpoints of this NodeAddress.
   *
   * @return The list of endpoints of this NodeAddress.
   */
  [[nodiscard]] inline const std::vector<Endpoint>& getEndpoints() const { return mEndpoints; }

  /**
   * Get the description text of this NodeAddress.
   *
   * @return The description text of this NodeAddress.
   */
  [[nodiscard]] inline std::string getDescription() const { return mDescription; }

private:
  /**
   * The node's public key.
   */
  std::string mRSAPublicKey;

  /**
   * The ID of the node.
   */
  int64_t mNodeId = -1;

  /**
   * The account ID associated with the node.
   */
  AccountId mNodeAccountId;

  /**
   * The SHA-384 hash of the node's certificate chain.
   */
  std::vector<std::byte> mNodeCertHash;

  /**
   * The Endpoints associated with the node.
   */
  std::vector<Endpoint> mEndpoints;

  /**
   * A string description of the node.
   */
  std::string mDescription;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_NODE_ADDRESS_H_
// Filename: src/sdk/main/include/NodeAddressBook.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_NODE_ADDRESS_BOOK_H_
#define HIERO_SDK_CPP_NODE_ADDRESS_BOOK_H_

#include "NodeAddress.h"

#include <cstddef>
#include <vector>

namespace proto
{
class NodeAddressBook;
}

namespace Hiero
{
/**
 * An address book containing all known nodes on the network.
 */
class NodeAddressBook
{
public:
  /**
   * Construct a NodeAddressBook object from a NodeAddressBook protobuf object.
   *
   * @param proto The NodeAddressBook protobuf object from which to construct a NodeAddressBook object.
   * @return The constructed NodeAddressBook object.
   */
  [[nodiscard]] static NodeAddressBook fromProtobuf(const proto::NodeAddressBook& proto);

  /**
   * Construct a NodeAddressBook object from a byte array.
   *
   * @param bytes The byte array from which to construct a NodeAddressBook object.
   * @return The constructed NodeAddressBook object.
   */
  [[nodiscard]] static NodeAddressBook fromBytes(const std::vector<char>& bytes);

  /**
   * Construct a NodeAddressBook protobuf object from this NodeAddressBook object.
   *
   * @return A pointer to the created NodeAddressBook protobuf object filled with this NodeAddressBook object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::NodeAddressBook> toProtobuf() const;

  /**
   * Get the byte array representation of this NodeAddressBook.
   *
   * @return The byte array representation of this NodeAddressBook.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Set the list of NodeAddresses in this NodeAddressBook.
   *
   * @param addresses The list of NodeAddresses to set.
   * @return A reference to this NodeAddressBook with the newly-set NodeAddress list.
   */
  NodeAddressBook& setNodeAddresses(const std::vector<NodeAddress>& addresses);

  /**
   * Get the list of NodeAddresses.
   *
   * @return The list of NodeAddresses.
   */
  [[nodiscard]] inline std::vector<NodeAddress> getNodeAddresses() const { return mNodeAddresses; }

private:
  /**
   * The list of NodeAddresses.
   */
  std::vector<NodeAddress> mNodeAddresses;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_NODE_ADDRESS_BOOK_H_
// Filename: src/sdk/main/include/NodeCreateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_NODE_CREATE_TRANSACTION_H_
#define HIERO_SDK_CPP_NODE_CREATE_TRANSACTION_H_

#include "AccountId.h"
#include "Endpoint.h"
#include "Transaction.h"

namespace proto
{
class TransactionBody;
}

namespace com::hedera::hapi::node::addressbook
{
class NodeCreateTransactionBody;
}

namespace aproto = com::hedera::hapi::node::addressbook;

namespace Hiero
{
/**
 * A transaction to add a new consensus node to the network address book.
 *
 * This transaction SHALL be considered a "privileged transaction".
 *
 * This message supports a transaction to create a new node in the network
 * address book. The transaction, once complete, enables a new consensus node
 * to join the network, and requires governing council authorization.
 *
 * - A `NodeCreateTransactionBody` MUST be signed by the governing council.
 * - A `NodeCreateTransactionBody` MUST be signed by the `Key` assigned to the
 *   `admin_key` field.
 * - The newly created node information SHALL be added to the network address
 *   book information in the network state.
 * - The new entry SHALL be created in "state" but SHALL NOT participate in
 *   network consensus and SHALL NOT be present in network "configuration"
 *   until the next "upgrade" transaction (as noted below).
 * - All new address book entries SHALL be added to the active network
 *   configuration during the next `freeze` transaction with the field
 *   `freeze_type` set to `PREPARE_UPGRADE`.
 *
 * ### Record Stream Effects
 * Upon completion the newly assigned `node_id` SHALL be in the transaction
 * receipt.
 */
class NodeCreateTransaction : public Transaction<NodeCreateTransaction>
{
public:
  NodeCreateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a NodeCreate transaction.
   */
  explicit NodeCreateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit NodeCreateTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Get the node account identifier.
   *
   * @return An account identifier.
   */
  [[nodiscard]] const AccountId& getAccountId() const { return mAccountId; };

  /**
   * Get the short description of the node.
   *
   * @return An optional string containing the description.
   */
  [[nodiscard]] const std::optional<std::string>& getDescription() const { return mDescription; };

  /**
   * Get the list of service endpoints for gossip.
   *
   * @return A vector of gossip service endpoints.
   */
  [[nodiscard]] const std::vector<Endpoint>& getGossipEndpoints() const { return mGossipEndpoints; };

  /**
   * Get the list of service endpoints for gRPC calls.
   *
   * @return A vector of gRPC service endpoints.
   */
  [[nodiscard]] const std::vector<Endpoint>& getServiceEndpoints() const { return mServiceEndpoints; };

  /**
   * Get the certificate used to sign gossip events.
   *
   * @return A vector of bytes representing the gossip CA certificate in DER encoding.
   */
  [[nodiscard]] const std::vector<std::byte>& getGossipCaCertificate() const { return mGossipCaCertificate; };

  /**
   * Get the hash of the node gRPC TLS certificate.
   *
   * @return A vector of bytes representing the SHA-384 hash of the gRPC TLS certificate.
   */
  [[nodiscard]] const std::optional<std::vector<std::byte>>& getGrpcCertificateHash() const
  {
    return mGrpcCertificateHash;
  };

  /**
   * Get the administrative key controlled by the node operator.
   *
   * @return A shared pointer to the administrative Key.
   */
  [[nodiscard]] const std::shared_ptr<Key>& getAdminKey() const { return mAdminKey; };

  /**
   * Set the node account identifier.
   *
   * @param accountId The AccountId to set.
   * @return A reference to this NodeCreateTransaction with the newly-set account identifier.
   */
  NodeCreateTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set the description for the node.
   *
   * @param description A string containing the description.
   * @return A reference to this NodeCreateTransaction with the newly-set description.
   */
  NodeCreateTransaction& setDescription(std::string_view description);

  /**
   * Set the list of service endpoints for gossip.
   *
   * @param endpoints A vector of Endpoint objects for gossip.
   * @return A reference to this NodeCreateTransaction with the newly-set gossip endpoints.
   */
  NodeCreateTransaction& setGossipEndpoints(const std::vector<Endpoint>& endpoints);

  /**
   * Set the list of service endpoints for gRPC calls.
   *
   * @param endpoints A vector of Endpoint objects for gRPC.
   * @return A reference to this NodeCreateTransaction with the newly-set service endpoints.
   */
  NodeCreateTransaction& setServiceEndpoints(const std::vector<Endpoint>& endpoints);

  /**
   * Set the certificate used to sign gossip events.
   *
   * @param certificate A vector of bytes representing the gossip CA certificate in DER encoding.
   * @return A reference to this NodeCreateTransaction with the newly-set gossip CA certificate.
   */
  NodeCreateTransaction& setGossipCaCertificate(const std::vector<std::byte>& certificate);

  /**
   * Set the hash of the node gRPC TLS certificate.
   *
   * @param hash A vector of bytes representing the SHA-384 hash of the gRPC TLS certificate.
   * @return A reference to this NodeCreateTransaction with the newly-set gRPC certificate hash.
   */
  NodeCreateTransaction& setGrpcCertificateHash(const std::vector<std::byte>& hash);

  /**
   * Set the administrative key controlled by the node operator.
   *
   * @param key A shared pointer to a Key object representing the administrative key.
   * @return A reference to this NodeCreateTransaction with the newly-set administrative key.
   */
  NodeCreateTransaction& setAdminKey(const std::shared_ptr<Key>& key);

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this NodeCreateTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this NodeCreateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This NodeCreateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the NodeCreateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this NodeCreateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a NodeCreateTransactionBody protobuf object from this NodeCreateTransaction object.
   *
   * @return A pointer to a NodeCreateTransactionBody protobuf object filled with this NodeCreateTransaction object's
   *         data.
   */
  [[nodiscard]] aproto::NodeCreateTransactionBody* build() const;

  /**
   * A Node account identifier.
   * This account identifier MUST be in the "account number" form.
   * This account identifier MUST NOT use the alias field.
   * If the identified account does not exist, this transaction SHALL fail.
   * Multiple nodes MAY share the same node account.
   * This field is REQUIRED.
   */
  AccountId mAccountId;

  /**
   * A short description of the node.
   * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.
   * This field is OPTIONAL.
   */
  std::optional<std::string> mDescription;

  /**
   * A list of service endpoints for gossip.
   * These endpoints SHALL represent the published endpoints to which other
   * consensus nodes may _gossip_ transactions.
   * These endpoints MUST specify a port.
   * This list MUST NOT be empty.
   * This list MUST NOT contain more than `10` entries.
   * The first two entries in this list SHALL be the endpoints published to
   * all consensus nodes.
   * All other entries SHALL be reserved for future use.
   * Each network may have additional requirements for these endpoints.
   * A client MUST check network-specific documentation for those
   * details.
   * If the network configuration value `gossipFqdnRestricted` is set, then
   * all endpoints in this list MUST supply only IP address.
   * If the network configuration value `gossipFqdnRestricted` is _not_ set,
   * then endpoints in this list MAY supply either IP address or FQDN, but
   * MUST NOT supply both values for the same endpoint.
   */
  std::vector<Endpoint> mGossipEndpoints;

  /**
   * A list of service endpoints for gRPC calls.
   * These endpoints SHALL represent the published gRPC endpoints to which
   * clients may submit transactions.
   * These endpoints MUST specify a port.
   * Endpoints in this list MAY supply either IP address or FQDN, but MUST
   * NOT supply both values for the same endpoint.
   * This list MUST NOT be empty.
   * This list MUST NOT contain more than `8` entries.
   */
  std::vector<Endpoint> mServiceEndpoints;

  /**
   * A certificate used to sign gossip events.
   * This value MUST be a certificate of a type permitted for gossip
   * signatures.
   * This value MUST be the DER encoding of the certificate presented.
   * This field is REQUIRED and MUST NOT be empty.
   */
  std::vector<std::byte> mGossipCaCertificate;

  /**
   * A hash of the node gRPC TLS certificate.
   * This value MAY be used to verify the certificate presented by the node
   * during TLS negotiation for gRPC.
   * This value MUST be a SHA-384 hash.
   * The TLS certificate to be hashed MUST first be in PEM format and MUST be
   * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
   * the hash algorithm.
   * This field is OPTIONAL.
   */
  std::optional<std::vector<std::byte>> mGrpcCertificateHash;

  /**
   * An administrative key controlled by the node operator.
   * This key MUST sign this transaction.
   * This key MUST sign each transaction to update this node.
   * This field MUST contain a valid `Key` value.
   * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
   */
  std::shared_ptr<Key> mAdminKey;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_NODE_CREATE_TRANSACTION_H_
// Filename: src/sdk/main/include/NodeDeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_NODE_DELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_NODE_DELETE_TRANSACTION_H_

#include "Transaction.h"

namespace proto
{
class NodeDeleteTransactionBody;
class TransactionBody;
}

namespace com::hedera::hapi::node::addressbook
{
class NodeDeleteTransactionBody;
}

namespace aproto = com::hedera::hapi::node::addressbook;

namespace Hiero
{
/**
 * A transaction to delete a node from the network address book.
 *
 * This transaction body SHALL be considered a "privileged transaction".
 *
 * - A `NodeDeleteTransactionBody` MUST be signed by the governing council.
 * - Upon success, the address book entry SHALL enter a "pending delete"
 *   state.
 * - All address book entries pending deletion SHALL be removed from the
 *   active network configuration during the next `freeze` transaction with
 *   the field `freeze_type` set to `PREPARE_UPGRADE`.<br/>
 * - A deleted address book node SHALL be removed entirely from network state.
 * - A deleted address book node identifier SHALL NOT be reused.
 *
 * ### Record Stream Effects
 * Upon completion the "deleted" `node_id` SHALL be in the transaction
 * receipt.
 */
class NodeDeleteTransaction : public Transaction<NodeDeleteTransaction>
{
public:
  NodeDeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a NodeDelete transaction.
   */
  explicit NodeDeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit NodeDeleteTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Get the consensus node identifier in the network state.
   *
   * @return A uint64_t representing the node identifier.
   */
  [[nodiscard]] uint64_t getNodeId() const { return mNodeId; };

  /**
   * Set the consensus node identifier in the network state.
   *
   * @param nodeId A uint64_t representing the node identifier.
   * @return A reference to this NodeDeleteTransaction with the newly-set node identifier.
   */
  NodeDeleteTransaction& setNodeId(uint64_t nodeId);

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this NodeDeleteTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this NodeDeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This NodeDeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the NodeDeleteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this NodeDeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a NodeDeleteTransactionBody protobuf object from this NodeDeleteTransaction object.
   *
   * @return A pointer to a NodeDeleteTransactionBody protobuf object filled with this NodeDeleteTransaction object's
   *         data.
   */
  [[nodiscard]] aproto::NodeDeleteTransactionBody* build() const;

  /**
   * A consensus node identifier in the network state.
   * The node identified MUST exist in the network address book.
   * The node identified MUST NOT be deleted.
   * This value is REQUIRED.
   */
  uint64_t mNodeId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_NODE_DELETE_TRANSACTION_H_
// Filename: src/sdk/main/include/NodeUpdateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_NODE_UPDATE_TRANSACTION_H_
#define HIERO_SDK_CPP_NODE_UPDATE_TRANSACTION_H_

#include "Endpoint.h"
#include "Transaction.h"

namespace proto
{
class TransactionBody;
}

namespace com::hedera::hapi::node::addressbook
{
class NodeUpdateTransactionBody;
}

namespace aproto = com::hedera::hapi::node::addressbook;

namespace Hiero
{
/**
 * Transaction to modify address book node attributes.
 *
 * - This transaction SHALL enable the node operator, as identified by the
 *   `admin_key`, to modify operational attributes of the node.
 * - This transaction MUST be signed by the active `admin_key` for the node.
 * - If this transaction sets a new value for the `admin_key`, then both the
 *   current `admin_key`, and the new `admin_key` MUST sign this transaction.
 * - This transaction SHALL NOT change any field that is not set (is null) in
 *   this transaction body.
 * - This SHALL create a pending update to the node, but the change SHALL NOT
 *   be immediately applied to the active configuration.
 * - All pending node updates SHALL be applied to the active network
 *   configuration during the next `freeze` transaction with the field
 *   `freeze_type` set to `PREPARE_UPGRADE`.
 *
 * ### Record Stream Effects
 * Upon completion the `node_id` for the updated entry SHALL be in the
 * transaction receipt.
 */
class NodeUpdateTransaction : public Transaction<NodeUpdateTransaction>
{
public:
  NodeUpdateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a NodeUpdate transaction.
   */
  explicit NodeUpdateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit NodeUpdateTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Get the consensus node identifier in the network state.
   *
   * @return A uint64_t representing the node identifier.
   */
  [[nodiscard]] uint64_t getNodeId() const { return mNodeId; };

  /**
   * Get the node account identifier.
   *
   * @return An account identifier.
   */
  [[nodiscard]] const AccountId& getAccountId() const { return mAccountId; };

  /**
   * Get the short description of the node.
   *
   * @return An optional string containing the description.
   */
  [[nodiscard]] const std::optional<std::string>& getDescription() const { return mDescription; };

  /**
   * Get the list of service endpoints for gossip.
   *
   * @return A vector of gossip service endpoints.
   */
  [[nodiscard]] const std::vector<Endpoint>& getGossipEndpoints() const { return mGossipEndpoints; };

  /**
   * Get the list of service endpoints for gRPC calls.
   *
   * @return A vector of gRPC service endpoints.
   */
  [[nodiscard]] const std::vector<Endpoint>& getServiceEndpoints() const { return mServiceEndpoints; };

  /**
   * Get the certificate used to sign gossip events.
   *
   * @return A vector of bytes representing the gossip CA certificate in DER encoding.
   */
  [[nodiscard]] const std::vector<std::byte>& getGossipCaCertificate() const { return mGossipCaCertificate; };

  /**
   * Get the hash of the node gRPC TLS certificate.
   *
   * @return A vector of bytes representing the SHA-384 hash of the gRPC TLS certificate.
   */
  [[nodiscard]] const std::optional<std::vector<std::byte>>& getGrpcCertificateHash() const
  {
    return mGrpcCertificateHash;
  };

  /**
   * Get the administrative key controlled by the node operator.
   *
   * @return A shared pointer to the administrative Key.
   */
  [[nodiscard]] const std::shared_ptr<Key>& getAdminKey() const { return mAdminKey; };

  /**
   * Set the consensus node identifier in the network state.
   *
   * @param nodeId A uint64_t representing the node identifier.
   * @return A reference to this NodeUpdateTransaction with the newly-set node identifier.
   */
  NodeUpdateTransaction& setNodeId(uint64_t nodeId);

  /**
   * Set the node account identifier.
   *
   * @param accountId The AccountId to set.
   * @return A reference to this NodeUpdateTransaction with the newly-set account identifier.
   */
  NodeUpdateTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set the description for the node.
   *
   * @param description A string containing the description.
   * @return A reference to this NodeUpdateTransaction with the newly-set description.
   */
  NodeUpdateTransaction& setDescription(std::string_view description);

  /**
   * Set the list of service endpoints for gossip.
   *
   * @param endpoints A vector of Endpoint objects for gossip.
   * @return A reference to this NodeUpdateTransaction with the newly-set gossip endpoints.
   */
  NodeUpdateTransaction& setGossipEndpoints(const std::vector<Endpoint>& endpoints);

  /**
   * Set the list of service endpoints for gRPC calls.
   *
   * @param endpoints A vector of Endpoint objects for gRPC.
   * @return A reference to this NodeUpdateTransaction with the newly-set service endpoints.
   */
  NodeUpdateTransaction& setServiceEndpoints(const std::vector<Endpoint>& endpoints);

  /**
   * Set the certificate used to sign gossip events.
   *
   * @param certificate A vector of bytes representing the gossip CA certificate in DER encoding.
   * @return A reference to this NodeUpdateTransaction with the newly-set gossip CA certificate.
   */
  NodeUpdateTransaction& setGossipCaCertificate(const std::vector<std::byte>& certificate);

  /**
   * Set the hash of the node gRPC TLS certificate.
   *
   * @param hash A vector of bytes representing the SHA-384 hash of the gRPC TLS certificate.
   * @return A reference to this NodeUpdateTransaction with the newly-set gRPC certificate hash.
   */
  NodeUpdateTransaction& setGrpcCertificateHash(const std::vector<std::byte>& hash);

  /**
   * Set the administrative key controlled by the node operator.
   *
   * @param key A shared pointer to a Key object representing the administrative key.
   * @return A reference to this NodeUpdateTransaction with the newly-set administrative key.
   */
  NodeUpdateTransaction& setAdminKey(const std::shared_ptr<Key>& key);

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this NodeUpdateTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this NodeUpdateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This NodeUpdateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the NodeUpdateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this NodeUpdateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a NodeUpdateTransactionBody protobuf object from this NodeUpdateTransaction object.
   *
   * @return A pointer to a NodeUpdateTransactionBody protobuf object filled with this NodeUpdateTransaction object's
   *         data.
   */
  [[nodiscard]] aproto::NodeUpdateTransactionBody* build() const;

  /**
   * A consensus node identifier in the network state.
   * The node identified MUST exist in the network address book.
   * The node identified MUST NOT be deleted.
   * This value is REQUIRED.
   */
  uint64_t mNodeId;

  /**
   * A Node account identifier.
   * This account identifier MUST be in the "account number" form.
   * This account identifier MUST NOT use the alias field.
   * If the identified account does not exist, this transaction SHALL fail.
   * Multiple nodes MAY share the same node account.
   * This field is REQUIRED.
   */
  AccountId mAccountId;

  /**
   * A short description of the node.
   * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.
   * This field is OPTIONAL.
   */
  std::optional<std::string> mDescription;

  /**
   * A list of service endpoints for gossip.
   * These endpoints SHALL represent the published endpoints to which other
   * consensus nodes may _gossip_ transactions.
   * These endpoints MUST specify a port.
   * This list MUST NOT be empty.
   * This list MUST NOT contain more than `10` entries.
   * The first two entries in this list SHALL be the endpoints published to
   * all consensus nodes.
   * All other entries SHALL be reserved for future use.
   * Each network may have additional requirements for these endpoints.
   * A client MUST check network-specific documentation for those
   * details.
   * If the network configuration value `gossipFqdnRestricted` is set, then
   * all endpoints in this list MUST supply only IP address.
   * If the network configuration value `gossipFqdnRestricted` is _not_ set,
   * then endpoints in this list MAY supply either IP address or FQDN, but
   * MUST NOT supply both values for the same endpoint.
   */
  std::vector<Endpoint> mGossipEndpoints;

  /**
   * A list of service endpoints for gRPC calls.
   * These endpoints SHALL represent the published gRPC endpoints to which
   * clients may submit transactions.
   * These endpoints MUST specify a port.
   * Endpoints in this list MAY supply either IP address or FQDN, but MUST
   * NOT supply both values for the same endpoint.
   * This list MUST NOT be empty.
   * This list MUST NOT contain more than `8` entries.
   */
  std::vector<Endpoint> mServiceEndpoints;

  /**
   * A certificate used to sign gossip events.
   * This value MUST be a certificate of a type permitted for gossip
   * signatures.
   * This value MUST be the DER encoding of the certificate presented.
   * This field is REQUIRED and MUST NOT be empty.
   */
  std::vector<std::byte> mGossipCaCertificate;

  /**
   * A hash of the node gRPC TLS certificate.
   * This value MAY be used to verify the certificate presented by the node
   * during TLS negotiation for gRPC.
   * This value MUST be a SHA-384 hash.
   * The TLS certificate to be hashed MUST first be in PEM format and MUST be
   * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
   * the hash algorithm.
   * This field is OPTIONAL.
   */
  std::optional<std::vector<std::byte>> mGrpcCertificateHash;

  /**
   * An administrative key controlled by the node operator.
   * This key MUST sign this transaction.
   * This key MUST sign each transaction to update this node.
   * This field MUST contain a valid `Key` value.
   * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
   */
  std::shared_ptr<Key> mAdminKey;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_NODE_UPDATE_TRANSACTION_H_
// Filename: src/sdk/main/include/PendingAirdropId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_PENDING_AIRDROP_ID_H_
#define HIERO_SDK_CPP_PENDING_AIRDROP_ID_H_

#include "AccountId.h"
#include "NftId.h"
#include "TokenId.h"

#include <cstddef>
#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class PendingAirdropId;
class TokenReference;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * A unique, composite, identifier for a pending airdrop.
 *
 * Each pending airdrop SHALL be uniquely identified by a PendingAirdropId.
 * A PendingAirdropId SHALL be recorded when created and MUST be provided in any transaction
 * that would modify that pending airdrop (such as a `claimAirdrop` or `cancelAirdrop`).
 */
class PendingAirdropId
{
public:
  PendingAirdropId() = default;

  /**
   * Construct with two AccountIDs and a TokenId.
   *
   * @param sender The accountID of the sender.
   * @param receiver The accountID of the receiver.
   * @param tokenId The tokenID of the pending airdrop.
   */
  explicit PendingAirdropId(AccountId sender, AccountId receiver, TokenId tokenId);

  /**
   * Construct with two AccountIDs and a NftId.
   *
   * @param sender The accountID of the sender.
   * @param receiver The accountID of the receiver.
   * @param tokenId The tokenID of the pending airdrop.
   */
  explicit PendingAirdropId(AccountId sender, AccountId receiver, NftId tokenId);

  /**
   * Construct an PendingAirdropId object from an PendingAirdropId protobuf object.
   *
   * @param proto The PendingAirdropId protobuf object from which to create an PendingAirdropId object.
   * @return The constructed PendingAirdropId object.
   */
  [[nodiscard]] static PendingAirdropId fromProtobuf(const proto::PendingAirdropId& proto);

  /**
   * Verify the checksum of this PendingAirdropId using the input Client's network.
   *
   * @param client The Client with which to validate this PendingAirdropId's checksum.
   * @throws BadEntityException If the checksum of this PendingAirdropId is invalid.
   */
  void validateChecksum(const Client& client) const;

  /**
   * Construct an PendingAirdropId protobuf object from this PendingAirdropId object.
   *
   * @return A pointer to the created PendingAirdropId protobuf object filled with this PendingAirdropId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::PendingAirdropId> toProtobuf() const;

  /**
   * Get the string representation of this PendingAirdropId object.
   *
   * @return The string representation of this PendingAirdropId.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * A sending account.
   * This is the account that initiated, and SHALL fund, this pending airdrop.
   * This field is REQUIRED.
   */
  AccountId mSender;

  /**
   * A receiving account.
   * This is the ID of the account that SHALL receive the airdrop.
   * This field is REQUIRED.
   */
  AccountId mReceiver;

  /**
   * A token ID.
   * This is the type of token for a fungible/common token airdrop.
   * This field is REQUIRED for a fungible/common token and MUST NOT be used for a
   * non-fungible/unique token.
   */
  std::optional<TokenId> mFt;

  /**
   * The id of a single NFT, consisting of a Token ID and serial number.
   * This is the type of token for a non-fungible/unique token airdrop.
   * This field is REQUIRED for a non-fungible/unique token and MUST NOT be used for a
   * fungible/common token.
   */
  std::optional<NftId> mNft;
};

}

#endif // HIERO_SDK_CPP_PENDING_AIRDROP_ID_H_// Filename: src/sdk/main/include/PendingAirdropRecord.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_PENDING_AIRDROP_RECORD_H_
#define HIERO_SDK_CPP_PENDING_AIRDROP_RECORD_H_

#include "PendingAirdropId.h"

namespace proto
{
class PendingAirdropRecord;
class PendingAirdropId;
}

namespace Hiero
{
/**
 * A record of a new pending airdrop.
 */
class PendingAirdropRecord
{
public:
  PendingAirdropRecord() = default;

  /**
   * Construct with two AccountIDs.
   *
   * @param PendingAirdropId The PendingAirdropId.
   * @param amount The amount airdropped.
   */
  explicit PendingAirdropRecord(PendingAirdropId PendingAirdropId, uint64_t amount);

  /**
   * Construct an PendingAirdropRecord object from an PendingAirdropRecord protobuf object.
   *
   * @param proto The PendingAirdropRecord protobuf object from which to create an PendingAirdropRecord object.
   * @return The constructed PendingAirdropRecord object.
   */
  [[nodiscard]] static PendingAirdropRecord fromProtobuf(const proto::PendingAirdropRecord& proto);

  /**
   * Construct an PendingAirdropRecord protobuf object from this PendingAirdropRecord object.
   *
   * @return A pointer to the created PendingAirdropRecord protobuf object filled with this PendingAirdropRecord
   * object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::PendingAirdropRecord> toProtobuf() const;

  /**
   * Get the string representation of this PendingAirdropRecord object.
   *
   * @return The string representation of this PendingAirdropRecord.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * A unique, composite, identifier for a pending airdrop.
   * This field is REQUIRED.
   */
  PendingAirdropId mPendingAirdropId;

  /**
   * A single pending airdrop amount.
   * If the pending airdrop is for a fungible/common token this field is REQUIRED
   * and SHALL be the current amount of tokens offered.
   * If the pending airdrop is for a non-fungible/unique token, this field SHALL NOT
   * be set.
   */
  uint64_t mAmount;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_PENDING_AIRDROP_RECORD_H_// Filename: src/sdk/main/include/PrivateKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_PRIVATE_KEY_H_
#define HIERO_SDK_CPP_PRIVATE_KEY_H_

#include "Key.h"

#include <cstddef>
#include <cstdint>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace Hiero
{
template<typename SdkRequestType>
class Transaction;

class PublicKey;
class WrappedTransaction;
}

namespace Hiero::internal::OpenSSLUtils
{
class EVP_PKEY;
}

namespace Hiero
{
/**
 * A generic class representing a private key.
 */
class PrivateKey : public Key
{
public:
  /**
   * The number of bytes in a PrivateKey chain code.
   */
  static constexpr const size_t CHAIN_CODE_SIZE = 32ULL;

  /**
   * Default destructor, but must define after PrivateKeyImpl is defined (in source file).
   */
  ~PrivateKey() override;

  /**
   * Construct a PrivateKey object from a hex-encoded, DER-encoded key string.
   *
   * @param key The DER-encoded hex string from which to construct a PrivateKey.
   * @return A pointer to an PrivateKey representing the input DER-encoded hex string.
   * @throws BadKeyException If the private key type (ED25519 or ECDSAsecp256k1) is unable to be determined or realized
   *                         from the input hex string.
   */
  [[nodiscard]] static std::unique_ptr<PrivateKey> fromStringDer(std::string_view key);

  /**
   * Construct a PrivateKey object from a DER-encoded byte vector.
   *
   * @param bytes The vector of DER-encoded bytes from which to construct a PrivateKey.
   * @return A pointer to a PrivateKey representing the input DER-encoded bytes.
   * @throws BadKeyException If the private key type (ED25519 or ECDSAsecp256k1) is unable to be determined or realized
   *                         from the input byte array.
   */
  [[nodiscard]] static std::unique_ptr<PrivateKey> fromBytesDer(const std::vector<std::byte>& bytes);

  /**
   * Derive a child PrivateKey from this PrivateKey.
   *
   * @param childIndex The index of the child to derive.
   * @return A pointer to the derived PrivateKey child.
   */
  [[nodiscard]] virtual std::unique_ptr<PrivateKey> derive(uint32_t childIndex) const = 0;

  /**
   * Sign an arbitrary byte array.
   *
   * @param bytesToSign The bytes to sign.
   * @return The signature of the byte array.
   */
  [[nodiscard]] virtual std::vector<std::byte> sign(const std::vector<std::byte>& bytesToSign) const = 0;

  /**
   * Get the hex-encoded string of the DER-encoded bytes of this PrivateKey.
   *
   * @return The hex-encoded string of the DER-encoded bytes of this PrivateKey.
   */
  [[nodiscard]] virtual std::string toStringDer() const = 0;

  /**
   * Get the hex-encoded string of the raw, non-DER-encoded bytes of this PrivateKey.
   *
   * @return The hex-encoded string of the raw bytes of this PrivateKey.
   */
  [[nodiscard]] virtual std::string toStringRaw() const = 0;

  /**
   * Get the DER-encoded bytes of this PrivateKey.
   *
   * @return The DER-encoded bytes of this PrivateKey.
   */
  [[nodiscard]] virtual std::vector<std::byte> toBytesDer() const = 0;

  /**
   * Get the raw, non-DER-encoded bytes of this PrivateKey.
   *
   * @return The raw bytes of this PrivateKey.
   */
  [[nodiscard]] virtual std::vector<std::byte> toBytesRaw() const = 0;

  /**
   * Sign a Transaction with this PrivateKey.
   *
   * @param transaction The Transaction to sign.
   * @return The generated signature.
   * @throws IllegalStateException If there is not exactly one node account ID set for the Transaction or if the
   *                               Transaction is not frozen and doesn't have a TransactionId set.
   */
  template<typename SdkRequestType>
  std::vector<std::byte> signTransaction(Transaction<SdkRequestType>& transaction) const;
  std::vector<std::byte> signTransaction(WrappedTransaction& transaction) const;

  /**
   * Get this PrivateKey's chain code. It is possible that the chain code could be empty.
   *
   * @return This PrivateKey's chaincode if it exists, otherwise an empty vector.
   */
  [[nodiscard]] std::vector<std::byte> getChainCode() const;

  /**
   * Get the PublicKey that corresponds to this PrivateKey.
   *
   * @return A pointer to the PublicKey that corresponds to this PrivateKey.
   */
  [[nodiscard]] std::shared_ptr<PublicKey> getPublicKey() const;

  /**
   * Write this PrivateKey in DER-encoded hex to an output stream.
   *
   * @param os  The output stream.
   * @param key The PrivateKey to print.
   * @return The output stream with this PrivateKey written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const PrivateKey& key);

protected:
  /**
   * Prevent public copying and moving to prevent slicing. Use the 'clone()' virtual method instead.
   */
  PrivateKey(const PrivateKey&);
  PrivateKey& operator=(const PrivateKey&);
  PrivateKey(PrivateKey&&) noexcept;
  PrivateKey& operator=(PrivateKey&&) noexcept;

  /**
   * Construct from a wrapped OpenSSL key object and optionally a chain code.
   *
   * @param key       The wrapped OpenSSL key object.
   * @param chainCode The chain code.
   * @throws OpenSSLException If OpenSSL is unable to get this PrivateKey's corresponding PrivateKey's bytes.
   * @throws BadKeyException  If the chain code is malformed.
   */
  explicit PrivateKey(internal::OpenSSLUtils::EVP_PKEY&& key,
                      std::vector<std::byte> chainCode = std::vector<std::byte>());

  /**
   * Get this PrivateKey's wrapped OpenSSL key object.
   *
   * @return This PrivateKey's wrapped OpenSSL key object.
   */
  [[nodiscard]] internal::OpenSSLUtils::EVP_PKEY getInternalKey() const;

private:
  /**
   * Implementation object used to hide implementation details and internal headers.
   */
  struct PrivateKeyImpl;
  std::unique_ptr<PrivateKeyImpl> mImpl;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_PRIVATE_KEY_H_
// Filename: src/sdk/main/include/PrngTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_PRNG_TRANSACTION_H_
#define HIERO_SDK_CPP_PRNG_TRANSACTION_H_

#include "Transaction.h"

namespace proto
{
class UtilPrngTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that generates a pseudorandom number. When the pseudorandom number generate transaction executes, its
 * transaction record will contain the 384-bit array of pseudorandom bytes. The transaction has an optional range
 * parameter. If the parameter is given and is positive, then the record will contain a 32-bit pseudorandom integer r,
 * where 0 <= r < range instead of containing the 384 pseudorandom bits.
 *
 * When the nth transaction needs a pseudorandom number, it is given the running hash of all records up to and including
 * the record for transaction n-3. If it needs 384 bits, then it uses the entire hash. If it needs 256 bits, it uses the
 * first 256 bits of the hash. If it needs a random number r that is in the range 0 <= r < range, then it lets x be the
 * first 32 bits of the hash (interpreted as a signed integer).
 *
 * The choice of using the hash up to transaction n-3 rather than n-1 is to ensure the transactions can be processed
 * quickly. Because the thread calculating the hash will have more time to complete it before it is needed. The use of
 * n-3 rather than n-1000000 is to make it hard to predict the pseudorandom number in advance.
 */
class PrngTransaction : public Transaction<PrngTransaction>
{
public:
  PrngTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a UtilPrng.
   */
  explicit PrngTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit PrngTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the range of the pseudorandom number to generate.
   *
   * @param range The range of the pseudorandom number to generate.
   * @return A reference to this PrngTransaction object with the newly-set range.
   * @throws IllegalStateException If this PrngTransaction is frozen.
   */
  PrngTransaction& setRange(int range);

  /**
   * Get the range of the pseudorandom number to generate.
   *
   * @return The the range of the pseudorandom number to generate.
   */
  [[nodiscard]] inline int getRange() const { return mRange; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this PrngTransaction's data to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this PrngTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This PrngTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the PrngTransaction protobuf representation to the Transaction protobuf
   * object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this PrngTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a UtilPrngTransactionBody protobuf object from this PrngTransaction object.
   *
   * @return A pointer to a UtilPrngTransactionBody protobuf object filled with this PrngTransaction object's data.
   */
  [[nodiscard]] proto::UtilPrngTransactionBody* build() const;

  /**
   * The range from which to return the pseudorandom number. If this is , a 384-bit pseudorandom number will be returned
   * in the TransactionRecord. If this is set, a 32-bit pseudorandom number will be returned between 0 and the specified
   * range.
   */
  int mRange = 0;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_PRNG_TRANSACTION_H_
// Filename: src/sdk/main/include/ProxyStaker.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_PROXY_STAKER_H_
#define HIERO_SDK_CPP_PROXY_STAKER_H_

#include "AccountId.h"
#include "Hbar.h"

#include <cstddef>
#include <cstdint>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class ProxyStaker;
}

namespace Hiero
{
/**
 * Information about a single account that is proxy staking.
 */
class ProxyStaker
{
public:
  ProxyStaker() = default;

  /**
   * Construct with an account ID and an amount.
   *
   * @param accountID The account ID that is staking.
   * @param amount    The amount the account is staking.
   */
  ProxyStaker(AccountId accountId, int64_t amount);

  /**
   * Construct a ProxyStaker object from a ProxyStaker protobuf object.
   *
   * @param proto The ProxyStaker protobuf object from which to construct a ProxyStaker object.
   * @return The constructed ProxyStaker object.
   */
  [[nodiscard]] static ProxyStaker fromProtobuf(const proto::ProxyStaker& proto);

  /**
   * Construct a ProxyStaker object from a byte array.
   *
   * @param bytes The byte array from which to construct a ProxyStaker object.
   * @return The constructed ProxyStaker object.
   */
  [[nodiscard]] static ProxyStaker fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a ProxyStaker protobuf object from this ProxyStaker object.
   *
   * @return A pointer to the created ProxyStaker protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::ProxyStaker> toProtobuf() const;

  /**
   * Construct a representative byte array from this ProxyStaker object.
   *
   * @return The byte array representing this ProxyStaker object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this ProxyStaker object.
   *
   * @return The string representation of this ProxyStaker object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this ProxyStaker to an output stream.
   *
   * @param os     The output stream.
   * @param staker The ProxyStaker to print.
   * @return The output stream with this ProxyStaker written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const ProxyStaker& staker);

  /**
   * The ID of the account that is proxy staking.
   */
  AccountId mAccountId;

  /**
   * The number of Hbars that are currently proxy staked.
   */
  Hbar mAmount;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_PROXY_STAKER_H_
// Filename: src/sdk/main/include/PublicKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_PUBLIC_KEY_H_
#define HIERO_SDK_CPP_PUBLIC_KEY_H_

#include "Key.h"

#include <memory>
#include <ostream>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class Key;
class SignaturePair;
}

namespace Hiero
{
namespace internal::OpenSSLUtils
{
class EVP_PKEY;
}

class AccountId;
}

namespace Hiero
{
/**
 * A generic class representing a public key.
 */
class PublicKey
  : public Key
  , public std::enable_shared_from_this<PublicKey>
{
public:
  /**
   * Default destructor, but must define after PublicKeyImpl is defined (in source file).
   */
  ~PublicKey() override;

  /**
   * Construct a PublicKey object from a hex-encoded, DER-encoded key string.
   *
   * @param key The DER-encoded hex string from which to construct a PublicKey.
   * @return A pointer to an PublicKey representing the input DER-encoded hex string.
   * @throws BadKeyException If the public key type (ED25519 or ECDSAsecp256k1) is unable to be determined or realized
   *                         from the input hex string.
   */
  [[nodiscard]] static std::unique_ptr<PublicKey> fromStringDer(std::string_view key);

  /**
   * Construct a PublicKey object from a raw byte vector. This will attempt to determine the type of key based on the
   * input byte vector length.
   *
   * @param bytes The vector of raw bytes from which to construct a PublicKey.
   * @return A pointer to a PublicKey representing the input DER-encoded bytes.
   * @throws BadKeyException If the public key type (ED25519 or ECDSAsecp256k1) is unable to be determined or realized
   *                         from the input byte array.
   */
  [[nodiscard]] static std::unique_ptr<PublicKey> fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a PublicKey object from a DER-encoded byte vector.
   *
   * @param bytes The vector of DER-encoded bytes from which to construct a PublicKey.
   * @return A pointer to a PublicKey representing the input DER-encoded bytes.
   * @throws BadKeyException If the public key type (ED25519 or ECDSAsecp256k1) is unable to be determined or realized
   *                         from the input byte array.
   */
  [[nodiscard]] static std::unique_ptr<PublicKey> fromBytesDer(const std::vector<std::byte>& bytes);

  /**
   * Construct a PublicKey object from a byte array representing an alias.
   *
   * @param alias The bytes representing an alias.
   * @return A pointer to a PublicKey representing the input alias bytes, or nullptr if the input alias byte array does
   *         not represent a PublicKey.
   */
  [[nodiscard]] static std::unique_ptr<PublicKey> fromAliasBytes(const std::vector<std::byte>& bytes);

  /**
   * Verify that a signature was made by the PrivateKey which corresponds to this PublicKey.
   *
   * @param signatureBytes The byte vector representing the signature.
   * @param signedBytes    The bytes which were purportedly signed to create the signature.
   * @return \c TRUE if the signature is valid, otherwise \c FALSE.
   */
  [[nodiscard]] virtual bool verifySignature(const std::vector<std::byte>& signatureBytes,
                                             const std::vector<std::byte>& signedBytes) const = 0;

  /**
   * Get the hex-encoded string of the DER-encoded bytes of this PublicKey.
   *
   * @return The hex-encoded string of the DER-encoded bytes of this PublicKey.
   */
  [[nodiscard]] virtual std::string toStringDer() const = 0;

  /**
   * Get the hex-encoded string of the raw bytes of this PublicKey.
   *
   * @return The hex-encoded string of the raw bytes of this PublicKey.
   */
  [[nodiscard]] virtual std::string toStringRaw() const = 0;

  /**
   * Get the DER-encoded bytes of this PublicKey.
   *
   * @return The DER-encoded bytes of this PublicKey.
   */
  [[nodiscard]] virtual std::vector<std::byte> toBytesDer() const = 0;

  /**
   * Get the raw bytes of this PublicKey.
   *
   * @return The raw bytes of this PublicKey.
   */
  [[nodiscard]] virtual std::vector<std::byte> toBytesRaw() const = 0;

  /**
   * Serialize this PublicKey to a SignaturePair protobuf object with the given signature.
   *
   * @param signature The signature created by this PublicKey.
   */
  [[nodiscard]] virtual std::unique_ptr<proto::SignaturePair> toSignaturePairProtobuf(
    const std::vector<std::byte>& signature) const = 0;

  /**
   * Construct an AccountId object using this PublicKey as its alias.
   *
   * @param shard The shard of the AccountId.
   * @param realm The realm of the AccountId.
   * @return The constructed AccountId.
   */
  [[nodiscard]] AccountId toAccountId(uint64_t shard = 0ULL, uint64_t realm = 0ULL) const;

  /**
   * Write this PublicKey in DER-encoded hex to an output stream.
   *
   * @param os  The output stream.
   * @param key The PublicKey to print.
   * @return The output stream with this PublicKey written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const PublicKey& key);

protected:
  /**
   * Prevent public copying and moving to prevent slicing. Use the 'clone()' virtual method instead.
   */
  PublicKey(const PublicKey&);
  PublicKey& operator=(const PublicKey&);
  PublicKey(PublicKey&&) noexcept;
  PublicKey& operator=(PublicKey&&) noexcept;

  /**
   * Construct with a wrapped OpenSSL key object.
   *
   * @param key The wrapped OpenSSL key object.
   */
  explicit PublicKey(internal::OpenSSLUtils::EVP_PKEY&& key);

  /**
   * Get this PublicKey's wrapped OpenSSL key object.
   *
   * @return This PublicKey's wrapped OpenSSL key object.
   */
  [[nodiscard]] internal::OpenSSLUtils::EVP_PKEY getInternalKey() const;

private:
  /**
   * Get a std::shared_ptr to this PublicKey.
   *
   * @returns A pointer to this PublicKey.
   */
  [[nodiscard]] virtual std::shared_ptr<PublicKey> getShared() const = 0;

  /**
   * Implementation object used to hide implementation details and internal headers.
   */
  struct PublicKeyImpl;
  std::unique_ptr<PublicKeyImpl> mImpl;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_PUBLIC_KEY_H_
// Filename: src/sdk/main/include/Query.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_QUERY_H_
#define HIERO_SDK_CPP_QUERY_H_

#include "Executable.h"

#include <chrono>
#include <functional>
#include <future>
#include <memory>
#include <optional>
#include <stdexcept>

namespace proto
{
class Query;
class QueryHeader;
class Response;
class ResponseHeader;
class Transaction;
}

namespace Hiero
{
class Client;
class Hbar;
class TransactionId;
}

namespace Hiero
{
/**
 * Base class for all queries that can be submitted to Hiero.
 *
 * @tparam SdkRequestType  The SDK request type.
 * @tparam SdkResponseType The SDK response type.
 */
template<typename SdkRequestType, typename SdkResponseType>
class Query : public Executable<SdkRequestType, proto::Query, proto::Response, SdkResponseType>
{
public:
  /**
   * Get the expected cost of this Query.
   *
   * @param client The Client to use to fetch the cost.
   * @return The expected cost of this Query.
   */
  [[nodiscard]] Hbar getCost(const Client& client);

  /**
   * Get the expected cost of this Query with a specific timeout.
   *
   * @param client  The Client to use to fetch the cost.
   * @param timeout The timeout to use to get the cost.
   * @return The expected cost of this Query.
   */
  [[nodiscard]] Hbar getCost(const Client& client, const std::chrono::system_clock::duration& timeout);

  /**
   * Get the expected cost of this Query asynchronously.
   *
   * @param client The Client to use to fetch the cost.
   * @return The expected cost of this Query.
   */
  [[nodiscard]] std::future<Hbar> getCostAsync(const Client& client);

  /**
   * Get the expected cost of this Query asynchronously with a specific timeout.
   *
   * @param client  The Client to use to fetch the cost.
   * @param timeout The timeout to use to get the cost.
   * @return The expected cost of this Query.
   */
  [[nodiscard]] std::future<Hbar> getCostAsync(const Client& client,
                                               const std::chrono::system_clock::duration& timeout);

  /**
   * Get the expected cost of this Query asynchronously and consume the response and/or exception with a callback.
   *
   * @param client   The Client to use to fetch the cost.
   * @param callback The callback that should consume the response/exception.
   */
  void getCostAsync(const Client& client, const std::function<void(const Hbar&, const std::exception&)>& callback);

  /**
   * Get the expected cost of this Query asynchronously with a specific timeout and consume the response and/or
   * exception with a callback.
   *
   * @param client   The Client to use to fetch the cost.
   * @param timeout  The timeout to use to get the cost.
   * @param callback The callback that should consume the response/exception.
   */
  void getCostAsync(const Client& client,
                    const std::chrono::system_clock::duration& timeout,
                    const std::function<void(const Hbar&, const std::exception&)>& callback);

  /**
   * Get the expected cost of this Query asynchronously and consume the response and/or exception with separate
   * callbacks.
   *
   * @param client            The Client to use to fetch the cost.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void getCostAsync(const Client& client,
                    const std::function<void(const Hbar&)>& responseCallback,
                    const std::function<void(const std::exception&)>& exceptionCallback);

  /**
   * Get the expected cost of this Query asynchronously with a specific timeout and consume the response and/or
   * exception with separate callbacks.
   *
   * @param client            The Client to use to fetch the cost.
   * @param timeout           The timeout to use to get the cost.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void getCostAsync(const Client& client,
                    const std::chrono::system_clock::duration& timeout,
                    const std::function<void(const Hbar&)>& responseCallback,
                    const std::function<void(const std::exception&)>& exceptionCallback);

  /**
   * Set an amount to pay for this Query. The Client will submit exactly this amount and no remainder will be returned.
   *
   * @param amount The amount to pay for this Query.
   * @return A reference to this derived Query with the newly-set payment.
   */
  SdkRequestType& setQueryPayment(const Hbar& amount);

  /**
   * Set a maximum amount to pay for this Query. A Query without an explicit payment amount set will first query for the
   * cost of the Query and attach a payment for that amount from the operator account on the client to the node account
   * ID. Set to 0 to disable automatic implicit payments.
   *
   * @param maxAmount The maximum amount to pay for this Query.
   * @return A reference to this derived Query with the newly-set payment.
   */
  SdkRequestType& setMaxQueryPayment(const Hbar& maxAmount);

  /**
   * Set the TransactionId of the payment Transaction for this Query.
   *
   * @param transactionId The TransactionId to set.
   * @return A reference to this derived Query with the newly-set payment transaction ID.
   */
  SdkRequestType& setPaymentTransactionId(const TransactionId& transactionId);

  /**
   * Get the TransactionId of the payment Transaction for this Query.
   *
   * @return The TransactionId of the payment Transaction for this Query. Uninitialized if no payment transaction ID has
   *         been set.
   */
  [[nodiscard]] std::optional<TransactionId> getPaymentTransactionId() const;

protected:
  /**
   * Prevent public copying and moving to prevent slicing. Use the 'clone()' virtual method instead.
   */
  Query();
  ~Query();
  Query(const Query&);
  Query& operator=(const Query&);
  Query(Query&&) noexcept;
  Query& operator=(Query&&) noexcept;

  /**
   * Get the cost of the Query from the ResponseHeader protobuf object and set it in this Query, if this Query was
   * configured to get the cost.
   *
   * @param header The ResponseHeader protobuf object from which to get the cost.
   */
  void saveCostFromHeader(const proto::ResponseHeader& header) const;

  /**
   * Is this Query meant a cost query?
   *
   * @return \c TRUE if this Query is meant to get the cost, otherwise \c FALSE.
   */
  [[nodiscard]] bool isCostQuery() const;

private:
  /**
   * Build a Query protobuf object with this Query's data, with the input QueryHeader protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] virtual proto::Query buildRequest(proto::QueryHeader* header) const = 0;

  /**
   * Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] virtual proto::ResponseHeader mapResponseHeader(const proto::Response& response) const = 0;

  /**
   * Verify that all the checksums in this Transaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This Transaction's checksums are not valid.
   */
  virtual void validateChecksums(const Client& client) const = 0;

  /**
   * Derived from Executable. Construct a Query protobuf object from this Query, based on the node account ID at the
   * given index.
   *
   * @param index The index of the node account ID that's associated with the Node being used to execute this Query.
   * @return A Query protobuf object filled with this Query's data, based on the node account ID at the given index.
   */
  [[nodiscard]] proto::Query makeRequest(unsigned int index) const override;

  /**
   * Derived from Executable. Get the status response code from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to grab the status response code.
   * @return The status response code of the input Response protobuf object.
   */
  [[nodiscard]] Status mapResponseStatus(const proto::Response& response) const override;

  /**
   * Derived from Executable. Perform any needed actions for this Query when it is being submitted.
   *
   * @param client The Client being used to submit this Query.
   */
  void onExecute(const Client& client) override;

  /**
   * Derived from Executable. Get the ID of the payment transaction for this Query.
   *
   * @return The ID of the payment transaction of this Query.
   */
  [[nodiscard]] std::optional<TransactionId> getTransactionIdInternal() const override;

  /**
   * Does this Query require payment? Default to \c TRUE, as most Queries do.
   *
   * @return \c TRUE if this Query requires payment, otherwise \c FALSE.
   */
  [[nodiscard]] inline virtual bool isPaymentRequired() const { return true; }

  /**
   * Implementation object used to hide implementation details and internal headers.
   */
  struct QueryImpl;
  std::unique_ptr<QueryImpl> mImpl;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_QUERY_H_
// Filename: src/sdk/main/include/RequestType.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_REQUEST_TYPE_H_
#define HIERO_SDK_CPP_REQUEST_TYPE_H_

#include <string>
#include <unordered_map>

namespace proto
{
enum HederaFunctionality : int;
}

namespace Hiero
{
/**
 * Enumeration of all queries and transactions supported by Hiero.
 */
enum class RequestType
{
  NONE,
  CRYPTO_TRANSFER,
  CRYPTO_UPDATE,
  CRYPTO_DELETE,
  CRYPTO_ADD_LIVE_HASH,
  CRYPTO_DELETE_LIVE_HASH,
  CONTRACT_CALL,
  CONTRACT_CREATE,
  CONTRACT_UPDATE,
  FILE_CREATE,
  FILE_APPEND,
  FILE_UPDATE,
  FILE_DELETE,
  CRYPTO_GET_ACCOUNT_BALANCE,
  CRYPTO_GET_ACCOUNT_RECORDS,
  CRYPTO_GET_INFO,
  CONTRACT_CALL_LOCAL,
  CONTRACT_GET_INFO,
  CONTRACT_GET_BYTECODE,
  GET_BY_SOLIDITY_ID,
  GET_BY_KEY,
  CRYPTO_GET_LIVE_HASH,
  CRYPTO_GET_STAKERS,
  FILE_GET_CONTENTS,
  FILE_GET_INFO,
  TRANSACTION_GET_RECORD,
  CONTRACT_GET_RECORDS,
  CRYPTO_CREATE,
  SYSTEM_DELETE,
  SYSTEM_UNDELETE,
  CONTRACT_DELETE,
  FREEZE,
  CREATE_TRANSACTION_RECORD,
  CRYPTO_ACCOUNT_AUTO_RENEW,
  CONTRACT_AUTO_RENEW,
  GET_VERSION_INFO,
  TRANSACTION_GET_RECEIPT,
  CONSENSUS_CREATE_TOPIC,
  CONSENSUS_UPDATE_TOPIC,
  CONSENSUS_DELETE_TOPIC,
  CONSENSUS_GET_TOPIC_INFO,
  CONSENSUS_SUBMIT_MESSAGE,
  UNCHECKED_SUBMIT,
  TOKEN_CREATE,
  TOKEN_GET_INFO,
  TOKEN_FREEZE_ACCOUNT,
  TOKEN_UNFREEZE_ACCOUNT,
  TOKEN_GRANT_KYC_TO_ACCOUNT,
  TOKEN_REVOKE_KYC_FROM_ACCOUNT,
  TOKEN_DELETE,
  TOKEN_UPDATE,
  TOKEN_MINT,
  TOKEN_BURN,
  TOKEN_ACCOUNT_WIPE,
  TOKEN_ASSOCIATE_TO_ACCOUNT,
  TOKEN_DISSOCIATE_FROM_ACCOUNT,
  SCHEDULE_CREATE,
  SCHEDULE_DELETE,
  SCHEDULE_SIGN,
  SCHEDULE_GET_INFO,
  TOKEN_GET_ACCOUNT_NFT_INFOS,
  TOKEN_GET_NFT_INFO,
  TOKEN_GET_NFT_INFOS,
  TOKEN_FEE_SCHEDULE_UPDATE,
  NETWORK_GET_EXECUTION_TIME,
  TOKEN_PAUSE,
  TOKEN_UNPAUSE,
  CRYPTO_APPROVE_ALLOWANCE,
  CRYPTO_DELETE_ALLOWANCE,
  GET_ACCOUNT_DETAILS,
  ETHEREUM_TRANSACTION,
  NODE_STAKE_UPDATE,
  UTIL_PRNG,
  TOKEN_UPDATE_NFTS
};

/**
 * Map of protobuf HederaFunctionality to their corresponding RequestTypes.
 */
extern const std::unordered_map<proto::HederaFunctionality, RequestType> gProtobufHederaFunctionalityToRequestType;

/**
 * Map of RequestTypes to their corresponding protobuf HederaFunctionality.
 */
extern const std::unordered_map<RequestType, proto::HederaFunctionality> gRequestTypeToProtobufHederaFunctionality;

/**
 * Map of RequestTypes to its corresponding string.
 */
[[maybe_unused]] extern const std::unordered_map<RequestType, std::string> gRequestTypeToString;

} // namespace Hiero

#endif // HIERO_SDK_CPP_REQUEST_TYPE_H_
// Filename: src/sdk/main/include/ScheduleCreateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SCHEDULE_CREATE_TRANSACTION_H_
#define HIERO_SDK_CPP_SCHEDULE_CREATE_TRANSACTION_H_

#include "AccountId.h"
#include "Key.h"
#include "Transaction.h"

#include <chrono>
#include <memory>
#include <optional>
#include <string>
#include <string_view>

namespace proto
{
class SchedulableTransactionBody;
class ScheduleCreateTransactionBody;
class TransactionBody;
class WrappedTransaction;
}

namespace Hiero
{
/**
 * A transaction that creates a schedule entity on a Hiero network. The entity ID for a schedule transaction is
 * referred to as the ScheduleId. After successfully executing a schedule create transaction, you can obtain the
 * ScheduleId by requesting the receipt of the transaction immediately after the transaction was executed. The receipt
 * also contains the scheduled transaction ID. The scheduled transaction ID is used to to request the record of the
 * scheduled transaction if it is successfully executed.
 *
 * If two users submit the same schedule create transaction, the first one to reach consensus will create the schedule
 * ID and the second one will have the schedule ID returned in the receipt of the transaction. The receipt status of the
 * second identical schedule transaction will return an "IDENTICAL_SCHEDULE_ALREADY_CREATED" response from the network.
 * The user who submits the second transaction would need to submit a ScheduleSign transaction to add their signature to
 * the schedule transaction.
 *
 * To retain the ability to delete a schedule transaction, you will need to populate the admin key field when creating a
 * schedule transaction. The admin key will be required to sign the ScheduleDelete transaction to delete the scheduled
 * transaction from the network. If you do not assign an admin key during the creation of the schedule transaction, you
 * will have an immutable schedule transaction.
 *
 * Transaction Signing Requirements:
 *  - The key of the account paying for the creation of the schedule transaction.
 *  - The key of the payer account ID paying for the execution of the scheduled transaction.
 *  - If the payer account is not specified, the operator account will be used to pay for the execution by default.
 *  - The admin key if set.
 *  - You can optionally sign with any of the required signatures for the scheduled (inner) transaction. Freeze the
 *    schedule transaction and call the sign() method to add signatures.
 */
class ScheduleCreateTransaction : public Transaction<ScheduleCreateTransaction>
{
public:
  ScheduleCreateTransaction();
  ~ScheduleCreateTransaction();
  ScheduleCreateTransaction(const ScheduleCreateTransaction&);
  ScheduleCreateTransaction& operator=(const ScheduleCreateTransaction&);
  ScheduleCreateTransaction(ScheduleCreateTransaction&&) noexcept;
  ScheduleCreateTransaction& operator=(ScheduleCreateTransaction&&) noexcept;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ScheduleCreate transaction.
   */
  explicit ScheduleCreateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit ScheduleCreateTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the Transaction to schedule.
   *
   * @param transaction The Transaction to schedule.
   * @return A reference to this ScheduleCreateTransaction object with the newly-set scheduled transaction.
   * @throws IllegalStateException  If this ScheduleCreateTransaction is frozen.
   * @throws UninitializedException If the input WrappedTransaction does not contain a Transaction.
   */
  ScheduleCreateTransaction& setScheduledTransaction(const WrappedTransaction& transaction);

  /**
   * Set the memo of the schedule entity.
   *
   * @param memo The memo of the schedule entity.
   * @return A reference to this ScheduleCreateTransaction object with the newly-set memo.
   */
  ScheduleCreateTransaction& setScheduleMemo(std::string_view memo);

  /**
   * Set the admin key of the schedule entity.
   *
   * @param key The admin key of the schedule entity.
   * @return A reference to this ScheduleCreateTransaction object with the newly-set admin key.
   */
  ScheduleCreateTransaction& setAdminKey(const std::shared_ptr<Key>& key);

  /**
   * Set the ID of the account that will pay for the scheduled transaction when it executes. Defaults to the payer of
   * this ScheduleCreateTransaction if not provided.
   *
   * @param accountId The ID of the account that will pay for the scheduled transaction when it executes.
   * @return A reference to this ScheduleCreateTransaction object with the newly-set payer account ID.
   */
  ScheduleCreateTransaction& setPayerAccountId(const AccountId& accountId);

  /**
   * Set the expiration time of the schedule entity.
   *
   * @param time The expiration time of the schedule entity.
   * @return A reference to this ScheduleCreateTransaction object with the newly-set expiration time.
   */
  ScheduleCreateTransaction& setExpirationTime(const std::chrono::system_clock::time_point& time);

  /**
   * Set the schedule entity's wait-for-expiry policy.
   *
   * @param wait \c TRUE if the transaction should be executed at time of expiration, \c FALSE if it should execute when
   *             it receives all signatures.
   * @return A reference to this ScheduleCreateTransaction object with the newly-set expiration time.
   */
  ScheduleCreateTransaction& setWaitForExpiry(bool wait);

  /**
   * Get the Transaction (wrapped) to schedule.
   *
   * @return The Transaction (wrapped) to schedule.
   */
  [[nodiscard]] WrappedTransaction getScheduledTransaction() const;

  /**
   * Get the memo of the schedule entity.
   *
   * @return The memo of the schedule entity.
   */
  [[nodiscard]] std::string getScheduleMemo() const;

  /**
   * Get the admin key of the schedule entity.
   *
   * @return The admin key of the schedule entity.
   */
  [[nodiscard]] std::shared_ptr<Key> getAdminKey() const;

  /**
   * Get the ID of the account that will pay for the scheduled transaction when it executes.
   *
   * @return The ID of the account that will pay for the scheduled transaction when it executes. Returns uninitialized
   *         if no payer account ID has been set.
   */
  [[nodiscard]] std::optional<AccountId> getPayerAccountId() const;

  /**
   * Get the expiration time of the schedule entity.
   *
   * @return The expiration time of the schedule entity. Returns uninitialized if no expiration time has been set.
   */
  [[nodiscard]] std::optional<std::chrono::system_clock::time_point> getExpirationTime() const;

  /**
   * Get the schedule entity's wait-for-expiry policy.
   *
   * @return The schedule entity's wait-for-expiry policy. Returns \c TRUE if the transaction will be executed at time
   *         of expiration, \c FALSE if it will execute when it receives all signatures.
   */
  [[nodiscard]] bool isWaitForExpiry() const;

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this ScheduleCreateTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this ScheduleCreateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ScheduleCreateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the ScheduleCreateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this ScheduleCreateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ScheduleCreateTransactionBody protobuf object from this ScheduleCreateTransaction object.
   *
   * @return A pointer to a ScheduleCreateTransactionBody protobuf object filled with this ScheduleCreateTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ScheduleCreateTransactionBody* build() const;

  /**
   * Implementation object used to hide implementation details and internal headers.
   */
  struct ScheduleCreateTransactionImpl;
  std::unique_ptr<ScheduleCreateTransactionImpl> mImpl;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_SCHEDULE_CREATE_TRANSACTION_H_
// Filename: src/sdk/main/include/ScheduleDeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SCHEDULE_DELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_SCHEDULE_DELETE_TRANSACTION_H_

#include "ScheduleId.h"
#include "Transaction.h"

#include <optional>

namespace proto
{
class ScheduleDeleteTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that deletes a scheduled transaction from the network. You can delete a scheduled transaction if only
 * the admin key was set during the creation of the scheduled transaction. If an admin key was not set, the attempted
 * deletion will result in "SCHEDULE_IS_IMMUTABLE" response from the network. Once the scheduled transaction is deleted,
 * the scheduled transaction will be marked as deleted with the consensus timestamp the scheduled transaction was
 * deleted at.
 *
 * Transaction Signing Requirements:
 *  - The admin key of the scheduled transaction.
 */
class ScheduleDeleteTransaction : public Transaction<ScheduleDeleteTransaction>
{
public:
  ScheduleDeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ScheduleDelete.
   */
  explicit ScheduleDeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit ScheduleDeleteTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the schedule to delete.
   *
   * @param scheduleId The ID of the schedule to delete.
   * @return A reference to this ScheduleDeleteTransaction object with the newly-set schedule ID.
   * @throws IllegalStateException If this ScheduleDeleteTransaction is frozen.
   */
  ScheduleDeleteTransaction& setScheduleId(const ScheduleId& scheduleId);

  /**
   * Get the ID of the schedule this ScheduleDeleteTransaction is currently configured to delete.
   *
   * @return The ID of the schedule this ScheduleDeleteTransaction is currently configured to delete. Uninitialized if
   *         no schedule ID has been set.
   */
  [[nodiscard]] inline std::optional<ScheduleId> getScheduleId() const { return mScheduleId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this ScheduleDeleteTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this ScheduleDeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ScheduleDeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the ScheduleDeleteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this ScheduleDeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ScheduleDeleteTransactionBody protobuf object from this ScheduleDeleteTransaction object.
   *
   * @return A pointer to a ScheduleDeleteTransactionBody protobuf object filled with this ScheduleDeleteTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ScheduleDeleteTransactionBody* build() const;

  /**
   * The ID of the schedule to delete.
   */
  std::optional<ScheduleId> mScheduleId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_SCHEDULE_DELETE_TRANSACTION_H_
// Filename: src/sdk/main/include/ScheduleId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SCHEDULE_ID_H_
#define HIERO_SDK_CPP_SCHEDULE_ID_H_

#include <cstddef>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class ScheduleID;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * The ID for a schedule on Hiero.
 */
class ScheduleId
{
public:
  ScheduleId() = default;

  /**
   * Construct with a schedule number.
   *
   * @param num The schedule number.
   */
  explicit ScheduleId(uint64_t num);

  /**
   * Construct with a shard, realm, a schedule number, and optionally a checksum.
   *
   * @param shard    The shard number.
   * @param realm    The realm number.
   * @param num      The schedule number.
   * @param checksum The checksum.
   */
  explicit ScheduleId(uint64_t shard, uint64_t realm, uint64_t num, std::string_view checksum = "");

  /**
   * Compare this ScheduleId to another ScheduleId and determine if they represent the same schedule.
   *
   * @param other The other ScheduleId with which to compare this ScheduleId.
   * @return \c TRUE if this ScheduleId is the same as the input ScheduleId, otherwise \c FALSE.
   */
  bool operator==(const ScheduleId& other) const;

  /**
   * Construct a ScheduleId object from a string of the form "<shard>.<realm>.<num>".
   *
   * @param id The schedule ID string from which to construct.
   * @return The constructed ScheduleId object.
   * @throws std::invalid_argument If the input string is malformed.
   */
  [[nodiscard]] static ScheduleId fromString(std::string_view id);

  /**
   * Construct a ScheduleId from a ScheduleId protobuf object.
   *
   * @param proto The ScheduleId protobuf object from which to create a ScheduleId object.
   * @return The constructed ScheduleId object.
   */
  [[nodiscard]] static ScheduleId fromProtobuf(const proto::ScheduleID& proto);

  /**
   * Construct a ScheduleId object from a representative byte array.
   *
   * @param bytes The byte array from which to construct a ScheduleId object.
   * @return The constructed ScheduleId object.
   */
  [[nodiscard]] static ScheduleId fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Verify the checksum of this ScheduleId using the input Client's network.
   *
   * @param client The Client with which to validate this ScheduleId's checksum.
   * @throws BadEntityException If the checksum of this ScheduleId is invalid.
   */
  void validateChecksum(const Client& client) const;

  /**
   * Construct a ScheduleID protobuf object from this ScheduleId object.
   *
   * @return A pointer to the created ScheduleId protobuf object filled with this ScheduleId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::ScheduleID> toProtobuf() const;

  /**
   * Get the string representation of this ScheduleId object.
   *
   * @return The string representation of this ScheduleId.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Get the string representation of this ScheduleId object with the checksum.
   *
   * @param client The Client with which to generate the checksum.
   * @return The string representation of this ScheduleId object with the checksum.
   */
  [[nodiscard]] std::string toStringWithChecksum([[maybe_unused]] const Client& client) const;

  /**
   * Get a byte array representation of this ScheduleId object.
   *
   * @return A byte array representation of this ScheduleId object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Get the checksum of this ContractId.
   *
   * @return The checksum of this ContractId.
   */
  [[nodiscard]] inline std::string getChecksum() const { return mChecksum; }

  /**
   * The shard number.
   */
  uint64_t mShardNum = 0ULL;

  /**
   * The realm number.
   */
  uint64_t mRealmNum = 0ULL;

  /**
   * The schedule number.
   */
  uint64_t mScheduleNum = 0ULL;

private:
  /**
   * The checksum of this ScheduleIds.
   */
  mutable std::string mChecksum;
};

} // namespace Hiero

namespace std
{
template<>
struct hash<Hiero::ScheduleId>
{
  /**
   * Operator override to enable use of ScheduleId as map key
   */
  size_t operator()(const Hiero::ScheduleId& id) const { return hash<string>()(id.toString()); }
};

} // namespace std

#endif // HIERO_SDK_CPP_SCHEDULE_ID_H_
// Filename: src/sdk/main/include/ScheduleInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SCHEDULE_INFO_H_
#define HIERO_SDK_CPP_SCHEDULE_INFO_H_

#include "AccountId.h"
#include "Key.h"
#include "KeyList.h"
#include "LedgerId.h"
#include "ScheduleId.h"
#include "TransactionId.h"
#include "WrappedTransaction.h"

#include <chrono>
#include <cstddef>
#include <memory>
#include <optional>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class ScheduleInfo;
}

namespace Hiero
{
/**
 * Response from a Hiero network when the client sends a ScheduleInfoQuery.
 */
class ScheduleInfo
{
public:
  /**
   * Construct a ScheduleInfo object from a ScheduleInfo protobuf object.
   *
   * @param proto The ScheduleInfo protobuf object from which to construct a ScheduleInfo object.
   * @return The constructed ScheduleInfo object.
   */
  [[nodiscard]] static ScheduleInfo fromProtobuf(const proto::ScheduleInfo& proto);

  /**
   * Construct a ScheduleInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a ScheduleInfo object.
   * @return The constructed ScheduleInfo object.
   */
  [[nodiscard]] static ScheduleInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a ScheduleInfo protobuf object from this ScheduleInfo object.
   *
   * @return A pointer to the created ScheduleInfo protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::ScheduleInfo> toProtobuf() const;

  /**
   * Construct a representative byte array from this ScheduleInfo object.
   *
   * @return The byte array representing this ScheduleInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this ScheduleInfo object.
   *
   * @return The string representation of this ScheduleInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this ScheduleInfo to an output stream.
   *
   * @param os   The output stream.
   * @param info The ScheduleInfo to print.
   * @return The output stream with this ScheduleInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const ScheduleInfo& info);

  /**
   * The ID of the schedule.
   */
  ScheduleId mScheduleId;

  /**
   * The consensus timestamp the scheduled transaction was executed. If the scheduled transaction has not yet executed,
   * this will be uninitialized.
   */
  std::optional<std::chrono::system_clock::time_point> mExecutionTime;

  /**
   * The consensus timestamp that the scheduled transaction was deleted. If the scheduled transaction has not been
   * deleted, this will be uninitialized.
   */
  std::optional<std::chrono::system_clock::time_point> mDeletionTime;

  /**
   * The consensus timestamp at which the scheduled transaction will expire.
   */
  std::chrono::system_clock::time_point mExpirationTime;

  /**
   * The scheduled transaction.
   */
  WrappedTransaction mScheduledTransaction;

  /**
   * The publicly visible memo of the schedule entity.
   */
  std::string mMemo;

  /**
   * The admin key of the schedule entity.
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The signatories who have provided their signatures thus far for the scheduled transaction.
   */
  KeyList mSignatories;

  /**
   * The ID of the account that created the scheduled transaction.
   */
  AccountId mCreatorAccountId;

  /**
   * The ID of the account paying for the execution of the scheduled transaction.
   */
  AccountId mPayerAccountId;

  /**
   * The ID of the scheduled transaction, if it executes.
   */
  TransactionId mScheduledTransactionId;

  /**
   * The ID of the ledger from which this response was returned.
   */
  LedgerId mLedgerId;

  /**
   * If \c TRUE, the scheduled transaction will wait to execute until its expiration time. If \c FALSE, the scheduled
   * transaction will execute when it receives a sufficient signature amount.
   */
  bool mWaitForExpiry = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_SCHEDULE_INFO_H_
// Filename: src/sdk/main/include/ScheduleInfoQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SCHEDULE_INFO_QUERY_H_
#define HIERO_SDK_CPP_SCHEDULE_INFO_QUERY_H_

#include "Query.h"
#include "ScheduleId.h"

namespace Hiero
{
class ScheduleInfo;
class TransactionRecord;
}

namespace Hiero
{
/**
 * A query that returns information about the current state of a schedule transaction on a Hiero network.
 */
class ScheduleInfoQuery : public Query<ScheduleInfoQuery, ScheduleInfo>
{
public:
  /**
   * Set the ID of the schedule of which to request the info.
   *
   * @param schedule The ID of the schedule of which to request the info.
   * @return A reference to this ScheduleInfoQuery object with the newly-set schedule ID.
   */
  ScheduleInfoQuery& setScheduleId(const ScheduleId& scheduleId);

  /**
   * Get the ID of the schedule of which this query is currently configured to get the info.
   *
   * @return The ID of the schedule for which this query is meant.
   */
  [[nodiscard]] inline ScheduleId getScheduleId() const { return mScheduleId; }

private:
  /**
   * Derived from Executable. Construct a ScheduleInfo object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a ScheduleInfo object.
   * @return A ScheduleInfo object filled with the Response protobuf object's data
   */
  [[nodiscard]] ScheduleInfo mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this ScheduleInfoQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this ScheduleInfoQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ScheduleInfoQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this ScheduleInfoQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the schedule of which this query should get the info.
   */
  ScheduleId mScheduleId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_SCHEDULE_INFO_QUERY_H_
// Filename: src/sdk/main/include/ScheduleSignTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SCHEDULE_SIGN_TRANSACTION_H_
#define HIERO_SDK_CPP_SCHEDULE_SIGN_TRANSACTION_H_

#include "ScheduleId.h"
#include "Transaction.h"

#include <optional>

namespace proto
{
class ScheduleSignTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that appends signatures to a scheduled transaction. You will need to know the schedule ID to reference
 * the scheduled transaction to submit signatures. A record will be generated for each ScheduleSign transaction that is
 * successful and the scheduled entity will subsequently update with the public keys that have signed the scheduled
 * transaction. To view the keys that have signed the scheduled transaction, you can query the network for the schedule
 * info. Once a scheduled transaction receives the last required signature, the scheduled transaction executes.
 *
 * Transaction Signing Requirements:
 *  - The key of the account paying for the transaction.
 */
class ScheduleSignTransaction : public Transaction<ScheduleSignTransaction>
{
public:
  ScheduleSignTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ScheduleSign.
   */
  explicit ScheduleSignTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit ScheduleSignTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the schedule to sign.
   *
   * @param scheduleId The ID of the schedule to sign.
   * @return A reference to this ScheduleSignTransaction object with the newly-set schedule ID.
   * @throws IllegalStateException If this ScheduleSignTransaction is frozen.
   */
  ScheduleSignTransaction& setScheduleId(const ScheduleId& scheduleId);

  /**
   * Clear the currently configured schedule ID.
   *
   * @return A reference to this ScheduleSignTransaction object with the newly-cleared schedule ID.
   * @throws IllegalStateException If this ScheduleSignTransaction is frozen.
   */
  ScheduleSignTransaction& clearScheduleId();

  /**
   * Get the ID of the schedule this ScheduleSignTransaction is currently configured to sign.
   *
   * @return The ID of the schedule this ScheduleSignTransaction is currently configured to sign. Uninitialized if no
   *         schedule ID has been set.
   */
  [[nodiscard]] inline std::optional<ScheduleId> getScheduleId() const { return mScheduleId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this ScheduleSignTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this ScheduleSignTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This ScheduleSignTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the ScheduleSignTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this ScheduleSignTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ScheduleSignTransactionBody protobuf object from this ScheduleSignTransaction object.
   *
   * @return A pointer to a ScheduleSignTransactionBody protobuf object filled with this ScheduleSignTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ScheduleSignTransactionBody* build() const;

  /**
   * The ID of the schedule to sign.
   */
  std::optional<ScheduleId> mScheduleId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_SCHEDULE_SIGN_TRANSACTION_H_
// Filename: src/sdk/main/include/SemanticVersion.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SEMANTIC_VERSION_H_
#define HIERO_SDK_CPP_SEMANTIC_VERSION_H_

#include <cstddef>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class SemanticVersion;
}

namespace Hiero
{
/**
 * Hiero follows semantic versioning for both the HAPI protobufs and the Services software. This type allows the
 * getVersionInfo query in the NetworkService to return the deployed versions of both protobufs and software on the node
 * answering the query.
 */
class SemanticVersion
{
public:
  SemanticVersion() = default;

  /**
   * Construct from a major, minor, and patch number.
   *
   * @param major The major number.
   * @param minor The minor number.
   * @param patch The patch number.
   * @param pre   The pre-release version number.
   * @param build The build metadata.
   */
  SemanticVersion(int major, int minor, int patch, std::string_view pre = "", std::string_view build = "");

  /**
   * Compare this SemanticVersion to another SemanticVersion and determine if they represent the same semantic version.
   *
   * @param other The other SemanticVersion with which to compare this SemanticVersion.
   * @return \c TRUE if this SemanticVersion is the same as the input SemanticVersion, otherwise \c FALSE.
   */
  bool operator==(const SemanticVersion& other) const;

  /**
   * Construct a SemanticVersion object from a SemanticVersion protobuf object.
   *
   * @param proto The SemanticVersion protobuf object from which to construct a SemanticVersion object.
   * @return The constructed SemanticVersion object.
   */
  [[nodiscard]] static SemanticVersion fromProtobuf(const proto::SemanticVersion& proto);

  /**
   * Construct a SemanticVersion object from a byte array.
   *
   * @param bytes The byte array representing a SemanticVersion object.
   * @return The constructed SemanticVersion object.
   */
  [[nodiscard]] static SemanticVersion fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a SemanticVersion protobuf object from this SemanticVersion object.
   *
   * @return A pointer to the created SemanticVersion protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::SemanticVersion> toProtobuf() const;

  /**
   * Construct a representative byte array from this SemanticVersion object.
   *
   * @return The byte array representing this SemanticVersion object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this SemanticVersion object.
   *
   * @return The string representation of this SemanticVersion object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Major number. Increases with incompatible API changes.
   */
  int mMajor = 0;

  /**
   * Minor number. Increases with backwards-compatible new functionality.
   */
  int mMinor = 0;

  /**
   * Patch number. Increases with backwards-compatible bug fixes.
   */
  int mPatch = 0;

  /**
   * Pre-release version. This may be denoted by appending a hyphen and a series of dot-separated identifiers.
   */
  std::string mPre;

  /**
   * Build metadata. This may be denoted by appending a plus sign and a series of dot-separated identifiers immediately
   * following the patch or pre-release version.
   */
  std::string mBuild;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_SEMANTIC_VERSION_H_
// Filename: src/sdk/main/include/StakingInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_STAKING_INFO_H_
#define HIERO_SDK_CPP_STAKING_INFO_H_

#include "AccountId.h"
#include "Hbar.h"

#include <chrono>
#include <cstddef>
#include <memory>
#include <optional>
#include <string>
#include <vector>

namespace proto
{
class StakingInfo;
}

namespace Hiero
{
/**
 * The staking metadata for an account or contract.
 */
class StakingInfo
{
public:
  /**
   * Construct a StakingInfo object from a StakingInfo protobuf object.
   *
   * @param proto The StakingInfo protobuf object from which to construct a StakingInfo object.
   * @return The constructed StakingInfo object.
   */
  [[nodiscard]] static StakingInfo fromProtobuf(const proto::StakingInfo& proto);

  /**
   * Construct a StakingInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a StakingInfo object.
   * @return The constructed StakingInfo object.
   */
  [[nodiscard]] static StakingInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a StakingInfo protobuf object from this StakingInfo object.
   *
   * @return A pointer to the created StakingInfo protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::StakingInfo> toProtobuf() const;

  /**
   * Construct a representative byte array from this StakingInfo object.
   *
   * @return The byte array representing this StakingInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this StakingInfo object.
   *
   * @return The string representation of this StakingInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this StakingInfo to an output stream.
   *
   * @param os   The output stream.
   * @param info The StakingInfo to print.
   * @return The output stream with this StakingInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const StakingInfo& info);

  /**
   * Is this account/contract declining to receive staking rewards?
   */
  bool mDeclineRewards = false;

  /**
   * The staking period during which either the staking settings for this account/contract changed (such as starting
   * staking or changing mStakedNodeId) or the most recent reward was earned, whichever is later. If this
   * account/contract is not currently staked to a node, then this field is not set.
   */
  std::optional<std::chrono::system_clock::time_point> mStakePeriodStart;

  /**
   * The amount of Hbar that this account/contract will receive in the next reward situation.
   */
  Hbar mPendingReward = Hbar(0LL);

  /**
   * The total balance of all accounts staked to this account/contract.
   */
  Hbar mStakedToMe = Hbar(0LL);

  /**
   * The ID of the account to which the account/contract is staking. Mutually exclusive with mStakedNodeId.
   */
  std::optional<AccountId> mStakedAccountId;

  /**
   * The ID of the node to which the account/contract is staking. Mutually exclusive with mStakedAccountId.
   */
  std::optional<uint64_t> mStakedNodeId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_STAKING_INFO_H_
// Filename: src/sdk/main/include/Status.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_STATUS_H_
#define HIERO_SDK_CPP_STATUS_H_

#include <string>
#include <unordered_map>

namespace proto
{
enum ResponseCodeEnum : int;
}

namespace Hiero
{
/**
 * Enumeration of possible transaction status types.
 *
 * The success variant is SUCCESS which is what a TransactionReceipt will contain for a successful transaction.
 */
enum class Status
{
  /**
   * The transaction passed the pre-check validations.
   */
  OK,

  /**
   * For any error not handled by specific error codes listed below.
   */
  INVALID_TRANSACTION,

  /**
   * Payer account does not exist.
   */
  PAYER_ACCOUNT_NOT_FOUND,

  /**
   * Node Account provided does not match the node account of the node the transaction was submitted
   * to.
   */
  INVALID_NODE_ACCOUNT,

  /**
   * Pre-Check error when TransactionValidStart + transactionValidDuration is less than current
   * consensus time.
   */
  TRANSACTION_EXPIRED,

  /**
   * Transaction start time is greater than current consensus time
   */
  INVALID_TRANSACTION_START,

  /**
   * The given transactionValidDuration was either non-positive, or greater than the maximum
   * valid duration of 180 secs.
   */
  INVALID_TRANSACTION_DURATION,

  /**
   * The transaction signature is not valid
   */
  INVALID_SIGNATURE,

  /**
   * Transaction memo size exceeded 100 bytes
   */
  MEMO_TOO_LONG,

  /**
   * The fee provided in the transaction is insufficient for this type of transaction
   */
  INSUFFICIENT_TX_FEE,

  /**
   * The payer account has insufficient cryptocurrency to pay the transaction fee
   */
  INSUFFICIENT_PAYER_BALANCE,

  /**
   * This transaction ID is a duplicate of one that was submitted to this node or reached consensus
   * in the last 180 seconds (receipt period)
   */
  DUPLICATE_TRANSACTION,

  /**
   * If API is throttled out
   */
  BUSY,

  /**
   * The API is not currently supported
   */
  NOT_SUPPORTED,

  /**
   * The file id is invalid or does not exist
   */
  INVALID_FILE_ID,

  /**
   * The account id is invalid or does not exist
   */
  INVALID_ACCOUNT_ID,

  /**
   * The contract id is invalid or does not exist
   */
  INVALID_CONTRACT_ID,

  /**
   * Transaction id is not valid
   */
  INVALID_TRANSACTION_ID,

  /**
   * Receipt for given transaction id does not exist
   */
  RECEIPT_NOT_FOUND,

  /**
   * Record for given transaction id does not exist
   */
  RECORD_NOT_FOUND,

  /**
   * The solidity id is invalid or entity with this solidity id does not exist
   */
  INVALID_SOLIDITY_ID,

  /**
   * The responding node has submitted the transaction to the network. Its final status is still
   * unknown.
   */
  UNKNOWN,

  /**
   * The transaction succeeded
   */
  SUCCESS,

  /**
   * There was a system error and the transaction failed because of invalid request parameters.
   */
  FAIL_INVALID,

  /**
   * There was a system error while performing fee calculation, reserved for future.
   */
  FAIL_FEE,

  /**
   * There was a system error while performing balance checks, reserved for future.
   */
  FAIL_BALANCE,

  /**
   * Key not provided in the transaction body
   */
  KEY_REQUIRED,

  /**
   * Unsupported algorithm/encoding used for keys in the transaction
   */
  BAD_ENCODING,

  /**
   * When the account balance is not sufficient for the transfer
   */
  INSUFFICIENT_ACCOUNT_BALANCE,

  /**
   * During an update transaction when the system is not able to find the Users Solidity address
   */
  INVALID_SOLIDITY_ADDRESS,

  /**
   * Not enough gas was supplied to execute transaction
   */
  INSUFFICIENT_GAS,

  /**
   * contract byte code size is over the limit
   */
  CONTRACT_SIZE_LIMIT_EXCEEDED,

  /**
   * local execution (query) is requested for a function which changes state
   */
  LOCAL_CALL_MODIFICATION_EXCEPTION,

  /**
   * Contract REVERT OPCODE executed
   */
  CONTRACT_REVERT_EXECUTED,

  /**
   * For any contract execution related error not handled by specific error codes listed above.
   */
  CONTRACT_EXECUTION_EXCEPTION,

  /**
   * In Query validation, account with +ve(amount) value should be Receiving node account, the
   * receiver account should be only one account in the list
   */
  INVALID_RECEIVING_NODE_ACCOUNT,

  /**
   * Header is missing in Query request
   */
  MISSING_QUERY_HEADER,

  /**
   * The update of the account failed
   */
  ACCOUNT_UPDATE_FAILED,

  /**
   * Provided key encoding was not supported by the system
   */
  INVALID_KEY_ENCODING,

  /**
   * null solidity address
   */
  NULL_SOLIDITY_ADDRESS,

  /**
   * update of the contract failed
   */
  CONTRACT_UPDATE_FAILED,

  /**
   * the query header is invalid
   */
  INVALID_QUERY_HEADER,

  /**
   * Invalid fee submitted
   */
  INVALID_FEE_SUBMITTED,

  /**
   * Payer signature is invalid
   */
  INVALID_PAYER_SIGNATURE,

  /**
   * The keys were not provided in the request.
   */
  KEY_NOT_PROVIDED,

  /**
   * Expiration time provided in the transaction was invalid.
   */
  INVALID_EXPIRATION_TIME,

  /**
   * WriteAccess Control Keys are not provided for the file
   */
  NO_WACL_KEY,

  /**
   * The contents of file are provided as empty.
   */
  FILE_CONTENT_EMPTY,

  /**
   * The crypto transfer credit and debit do not sum equal to 0
   */
  INVALID_ACCOUNT_AMOUNTS,

  /**
   * Transaction body provided is empty
   */
  EMPTY_TRANSACTION_BODY,

  /**
   * Invalid transaction body provided
   */
  INVALID_TRANSACTION_BODY,

  /**
   * the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of
   * signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)
   */
  INVALID_SIGNATURE_TYPE_MISMATCHING_KEY,

  /**
   * the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList,
   * or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding
   * signatureList should also have 3 base signatures.
   */
  INVALID_SIGNATURE_COUNT_MISMATCHING_KEY,

  /**
   * the livehash body is empty
   */
  EMPTY_LIVE_HASH_BODY,

  /**
   * the livehash data is missing
   */
  EMPTY_LIVE_HASH,

  /**
   * the keys for a livehash are missing
   */
  EMPTY_LIVE_HASH_KEYS,

  /**
   * the livehash data is not the output of a SHA-384 digest
   */
  INVALID_LIVE_HASH_SIZE,

  /**
   * the query body is empty
   */
  EMPTY_QUERY_BODY,

  /**
   * the crypto livehash query is empty
   */
  EMPTY_LIVE_HASH_QUERY,

  /**
   * the livehash is not present
   */
  LIVE_HASH_NOT_FOUND,

  /**
   * the account id passed has not yet been created.
   */
  ACCOUNT_ID_DOES_NOT_EXIST,

  /**
   * the livehash already exists for a given account
   */
  LIVE_HASH_ALREADY_EXISTS,

  /**
   * File WACL keys are invalid
   */
  INVALID_FILE_WACL,

  /**
   * Serialization failure
   */
  SERIALIZATION_FAILED,

  /**
   * The size of the Transaction is greater than transactionMaxBytes
   */
  TRANSACTION_OVERSIZE,

  /**
   * The Transaction has more than 50 levels
   */
  TRANSACTION_TOO_MANY_LAYERS,

  /**
   * Contract is marked as deleted
   */
  CONTRACT_DELETED,

  /**
   * the platform node is either disconnected or lagging behind.
   */
  PLATFORM_NOT_ACTIVE,

  /**
   * one public key matches more than one prefixes on the signature map
   */
  KEY_PREFIX_MISMATCH,

  /**
   * transaction not created by platform due to large backlog
   */
  PLATFORM_TRANSACTION_NOT_CREATED,

  /**
   * auto renewal period is not a positive number of seconds
   */
  INVALID_RENEWAL_PERIOD,

  /**
   * the response code when a smart contract id is passed for a crypto API request
   */
  INVALID_PAYER_ACCOUNT_ID,

  /**
   * the account has been marked as deleted
   */
  ACCOUNT_DELETED,

  /**
   * the file has been marked as deleted
   */
  FILE_DELETED,

  /**
   * same accounts repeated in the transfer account list
   */
  ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS,

  /**
   * attempting to set negative balance value for crypto account
   */
  SETTING_NEGATIVE_ACCOUNT_BALANCE,

  /**
   * when deleting smart contract that has crypto balance either transfer account or transfer smart
   * contract is required
   */
  OBTAINER_REQUIRED,

  /**
   * when deleting smart contract that has crypto balance you can not use the same contract id as
   * transferContractId as the one being deleted
   */
  OBTAINER_SAME_CONTRACT_ID,

  /**
   * transferAccountId or transferContractId specified for contract delete does not exist
   */
  OBTAINER_DOES_NOT_EXIST,

  /**
   * attempting to modify (update or delete a immutable smart contract, i.e. one created without a
   * admin key)
   */
  MODIFYING_IMMUTABLE_CONTRACT,

  /**
   * Unexpected exception thrown by file system functions
   */
  FILE_SYSTEM_EXCEPTION,

  /**
   * the duration is not a subset of [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]
   */
  AUTORENEW_DURATION_NOT_IN_RANGE,

  /**
   * Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex
   * string.
   */
  ERROR_DECODING_BYTESTRING,

  /**
   * File to create a smart contract was of length zero
   */
  CONTRACT_FILE_EMPTY,

  /**
   * Bytecode for smart contract is of length zero
   */
  CONTRACT_BYTECODE_EMPTY,

  /**
   * Attempt to set negative initial balance
   */
  INVALID_INITIAL_BALANCE,

  /**
   * Special Account Operations should be performed by only Genesis account, return this code if it
   * is not Genesis Account
   */
  ACCOUNT_IS_NOT_GENESIS_ACCOUNT,

  /**
   * The fee payer account doesn't have permission to submit such Transaction
   */
  PAYER_ACCOUNT_UNAUTHORIZED,

  /**
   * FreezeTransactionBody is invalid
   */
  INVALID_FREEZE_TRANSACTION_BODY,

  /**
   * FreezeTransactionBody does not exist
   */
  FREEZE_TRANSACTION_BODY_NOT_FOUND,

  /**
   * Exceeded the number of accounts (both from and to) allowed for crypto transfer list
   */
  TRANSFER_LIST_SIZE_LIMIT_EXCEEDED,

  /**
   * Smart contract result size greater than specified maxResultSize
   */
  RESULT_SIZE_LIMIT_EXCEEDED,

  /**
   * The payer account is not a special account(account 0.0.55)
   */
  NOT_SPECIAL_ACCOUNT,

  /**
   * Negative gas was offered in smart contract call
   */
  CONTRACT_NEGATIVE_GAS,

  /**
   * Negative value / initial balance was specified in a smart contract call / create
   */
  CONTRACT_NEGATIVE_VALUE,

  /**
   * Failed to update fee file
   */
  INVALID_FEE_FILE,

  /**
   * Failed to update exchange rate file
   */
  INVALID_EXCHANGE_RATE_FILE,

  /**
   * Payment tendered for contract local call cannot cover both the fee and the gas
   */
  INSUFFICIENT_LOCAL_CALL_GAS,

  /**
   * Entities with Entity ID below 1000 are not allowed to be deleted
   */
  ENTITY_NOT_ALLOWED_TO_DELETE,

  /**
   * Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2)
   * account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account
   * A/c 0.0.50 - Update all Network Function accounts and perform all the Network Functions listed
   * below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102),
   * ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate
   * (0.0.112).
   */
  AUTHORIZATION_FAILED,

  /**
   * Fee Schedule Proto uploaded but not valid (append or update is required)
   */
  FILE_UPLOADED_PROTO_INVALID,

  /**
   * Fee Schedule Proto uploaded but not valid (append or update is required)
   */
  FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK,

  /**
   * Fee Schedule Proto File Part uploaded
   */
  FEE_SCHEDULE_FILE_PART_UPLOADED,

  /**
   * The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage
   */
  EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED,

  /**
   * Contract permanent storage exceeded the currently allowable limit
   */
  MAX_CONTRACT_STORAGE_EXCEEDED,

  /**
   * Transfer Account should not be same as Account to be deleted
   */
  TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT,

  TOTAL_LEDGER_BALANCE_INVALID,

  /**
   * The expiration date/time on a smart contract may not be reduced
   */
  EXPIRATION_REDUCTION_NOT_ALLOWED,

  /**
   * Gas exceeded currently allowable gas limit per transaction
   */
  MAX_GAS_LIMIT_EXCEEDED,

  /**
   * File size exceeded the currently allowable limit
   */
  MAX_FILE_SIZE_EXCEEDED,

  /**
   * When a valid signature is not provided for operations on account with receiverSigRequired=true
   */
  RECEIVER_SIG_REQUIRED,

  /**
   * The Topic ID specified is not in the system.
   */
  INVALID_TOPIC_ID,

  /**
   * A provided admin key was invalid. Verify the bytes for an ED25519PublicKey are exactly 32 bytes; and the bytes for
   * a compressed ECDSA(secp256k1) key are exactly 33 bytes, with the first byte either 0x02 or 0x03.
   */
  INVALID_ADMIN_KEY,

  /**
   * A provided submit key was invalid.
   */
  INVALID_SUBMIT_KEY,

  /**
   * An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).
   */
  UNAUTHORIZED,

  /**
   * A ConsensusService message is empty.
   */
  INVALID_TOPIC_MESSAGE,

  /**
   * The autoRenewAccount specified is not a valid, active account.
   */
  INVALID_AUTORENEW_ACCOUNT,

  /**
   * An adminKey was not specified on the topic, so there must not be an autoRenewAccount.
   */
  AUTORENEW_ACCOUNT_NOT_ALLOWED,

  /**
   * The topic has expired, was not automatically renewed, and is in a 7 day grace period before the
   * topic will be deleted unrecoverably. This error response code will not be returned until
   * autoRenew functionality is supported by HAPI.
   */
  TOPIC_EXPIRED,

  /**
   * chunk number must be from 1 to total (chunks) inclusive.
   */
  INVALID_CHUNK_NUMBER,

  /**
   * For every chunk, the payer account that is part of initialTransactionID must match the Payer Account of this
   * transaction. The entire initialTransactionID should match the transactionID of the first chunk, but this is not
   * checked or enforced by Hiero except when the chunk number is 1.
   */
  INVALID_CHUNK_TRANSACTION_ID,

  /**
   * Account is frozen and cannot transact with the token
   */
  ACCOUNT_FROZEN_FOR_TOKEN,

  /**
   * An involved account already has more than tokens.maxPerAccount associations with non-deleted tokens.
   */
  TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED,

  /**
   * The token is invalid or does not exist
   */
  INVALID_TOKEN_ID,

  /**
   * Invalid token decimals
   */
  INVALID_TOKEN_DECIMALS,

  /**
   * Invalid token initial supply
   */
  INVALID_TOKEN_INITIAL_SUPPLY,

  /**
   * Treasury Account does not exist or is deleted
   */
  INVALID_TREASURY_ACCOUNT_FOR_TOKEN,

  /**
   * Token Symbol is not UTF-8 capitalized alphabetical string
   */
  INVALID_TOKEN_SYMBOL,

  /**
   * Freeze key is not set on token
   */
  TOKEN_HAS_NO_FREEZE_KEY,

  /**
   * Amounts in transfer list are not net zero
   */
  TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN,

  /**
   * A token symbol was not provided
   */
  MISSING_TOKEN_SYMBOL,

  /**
   * The provided token symbol was too long
   */
  TOKEN_SYMBOL_TOO_LONG,

  /**
   * KYC must be granted and account does not have KYC granted
   */
  ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN,

  /**
   * KYC key is not set on token
   */
  TOKEN_HAS_NO_KYC_KEY,

  /**
   * Token balance is not sufficient for the transaction
   */
  INSUFFICIENT_TOKEN_BALANCE,

  /**
   * Token transactions cannot be executed on deleted token
   */
  TOKEN_WAS_DELETED,

  /**
   * Supply key is not set on token
   */
  TOKEN_HAS_NO_SUPPLY_KEY,

  /**
   * Wipe key is not set on token
   */
  TOKEN_HAS_NO_WIPE_KEY,

  /**
   * The requested token mint amount would cause an invalid total supply
   */
  INVALID_TOKEN_MINT_AMOUNT,

  /**
   * The requested token burn amount would cause an invalid total supply
   */
  INVALID_TOKEN_BURN_AMOUNT,

  /**
   * A required token-account relationship is missing
   */
  TOKEN_NOT_ASSOCIATED_TO_ACCOUNT,

  /**
   * The target of a wipe operation was the token treasury account
   */
  CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT,

  /**
   * The provided KYC key was invalid.
   */
  INVALID_KYC_KEY,

  /**
   * The provided wipe key was invalid.
   */
  INVALID_WIPE_KEY,

  /**
   * The provided freeze key was invalid.
   */
  INVALID_FREEZE_KEY,

  /**
   * The provided supply key was invalid.
   */
  INVALID_SUPPLY_KEY,

  /**
   * Token Name is not provided
   */
  MISSING_TOKEN_NAME,

  /**
   * Token Name is too long
   */
  TOKEN_NAME_TOO_LONG,

  /**
   * The provided wipe amount must not be negative, zero or bigger than the token holder balance
   */
  INVALID_WIPING_AMOUNT,

  /**
   * Token does not have Admin key set, thus update/delete transactions cannot be performed
   */
  TOKEN_IS_IMMUTABLE,

  /**
   * An associateToken operation specified a token already associated to the account
   */
  TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT,

  /**
   * An attempted operation is invalid until all token balances for the target account are zero
   */
  TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES,

  /**
   * An attempted operation is invalid because the account is a treasury
   */
  ACCOUNT_IS_TREASURY,

  /**
   * Same TokenIDs present in the token list
   */
  TOKEN_ID_REPEATED_IN_TOKEN_LIST,

  /**
   * Exceeded the number of token transfers (both from and to) allowed for token transfer list
   */
  TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED,

  /**
   * TokenTransfersTransactionBody has no TokenTransferList
   */
  EMPTY_TOKEN_TRANSFER_BODY,

  /**
   * TokenTransfersTransactionBody has a TokenTransferList with no AccountAmounts
   */
  EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS,

  /**
   * The Scheduled entity does not exist; or has now expired, been deleted, or been executed
   */
  INVALID_SCHEDULE_ID,

  /**
   * The Scheduled entity cannot be modified. Admin key not set
   */
  SCHEDULE_IS_IMMUTABLE,

  /**
   * The provided Scheduled Payer does not exist
   */
  INVALID_SCHEDULE_PAYER_ID,

  /**
   * The Schedule Create Transaction TransactionID account does not exist
   */
  INVALID_SCHEDULE_ACCOUNT_ID,

  /**
   * The provided sig map did not contain any new valid signatures from required signers of the scheduled transaction
   */
  NO_NEW_VALID_SIGNATURES,

  /**
   * The required signers for a scheduled transaction cannot be resolved, for example because they do not exist or have
   * been deleted
   */
  UNRESOLVABLE_REQUIRED_SIGNERS,

  /**
   * Only whitelisted transaction types may be scheduled
   */
  SCHEDULED_TRANSACTION_NOT_IN_WHITELIST,

  /**
   * At least one of the signatures in the provided sig map did not represent a valid signature for any required signer
   */
  SOME_SIGNATURES_WERE_INVALID,

  /**
   * The scheduled field in the TransactionID may not be set to true
   */
  TRANSACTION_ID_FIELD_NOT_ALLOWED,

  /**
   * A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that is, all fields
   * other than scheduledPayerAccountID)
   */
  IDENTICAL_SCHEDULE_ALREADY_CREATED,

  /**
   * A string field in the transaction has a UTF-8 encoding with the prohibited zero byte
   */
  INVALID_ZERO_BYTE_IN_STRING,

  /**
   * A schedule being signed or deleted has already been deleted
   */
  SCHEDULE_ALREADY_DELETED,

  /**
   * A schedule being signed or deleted has already been executed
   */
  SCHEDULE_ALREADY_EXECUTED,

  /**
   * ConsensusSubmitMessage request's message size is larger than allowed.
   */
  MESSAGE_SIZE_TOO_LARGE,

  /**
   * An operation was assigned to more than one throttle group in a given bucket
   */
  OPERATION_REPEATED_IN_BUCKET_GROUPS,

  /**
   * The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte integral type
   */
  BUCKET_CAPACITY_OVERFLOW,

  /**
   * Given the network size in the address book, the node-level capacity for an operation would never be enough to
   * accept a single request; usually means a bucket burstPeriod should be increased
   */
  NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION,

  /**
   * A bucket was defined without any throttle groups
   */
  BUCKET_HAS_NO_THROTTLE_GROUPS,

  /**
   * A throttle group was granted zero opsPerSec
   */
  THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC,

  /**
   * The throttle definitions file was updated, but some supported operations were not assigned a bucket
   */
  SUCCESS_BUT_MISSING_EXPECTED_OPERATION,

  /**
   * The new contents for the throttle definitions system file were not valid protobuf
   */
  UNPARSEABLE_THROTTLE_DEFINITIONS,

  /**
   * The new throttle definitions system file were invalid, and no more specific error could be divined
   */
  INVALID_THROTTLE_DEFINITIONS,

  /**
   * The transaction references an account which has passed its expiration without renewal funds available, and
   * currently remains in the ledger only because of the grace period given to expired entities
   */
  ACCOUNT_EXPIRED_AND_PENDING_REMOVAL,

  /**
   * Invalid token max supply
   */
  INVALID_TOKEN_MAX_SUPPLY,

  /**
   * Invalid token nft serial number
   */
  INVALID_TOKEN_NFT_SERIAL_NUMBER,

  /**
   * Invalid nft id
   */
  INVALID_NFT_ID,

  /**
   * Nft metadata is too long
   */
  METADATA_TOO_LONG,

  /**
   * Repeated operations count exceeds the limit
   */
  BATCH_SIZE_LIMIT_EXCEEDED,

  /**
   * The range of data to be gathered is out of the set boundaries
   */
  INVALID_QUERY_RANGE,

  /**
   * A custom fractional fee set a denominator of zero
   */
  FRACTION_DIVIDES_BY_ZERO,

  /**
   * More than 10 custom fees were specified
   */
  CUSTOM_FEES_LIST_TOO_LONG,

  /**
   * Any of the feeCollector accounts for customFees is invalid
   */
  INVALID_CUSTOM_FEE_COLLECTOR,

  /**
   * Any of the token Ids in customFees is invalid
   */
  INVALID_TOKEN_ID_IN_CUSTOM_FEES,

  /**
   * Any of the token Ids in customFees are not associated to feeCollector
   */
  TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR,

  /**
   * A token cannot have more units minted due to its configured supply ceiling
   */
  TOKEN_MAX_SUPPLY_REACHED,

  /**
   * The transaction attempted to move an NFT serial number from an account other than its owner
   */
  SENDER_DOES_NOT_OWN_NFT_SERIAL_NO,

  /**
   * A custom fee schedule entry did not specify either a fixed or fractional fee
   */
  CUSTOM_FEE_NOT_FULLY_SPECIFIED,

  /**
   * Only positive fees may be assessed at this time
   */
  CUSTOM_FEE_MUST_BE_POSITIVE,

  /**
   * Fee schedule key is not set on token
   */
  TOKEN_HAS_NO_FEE_SCHEDULE_KEY,

  /**
   * A fractional custom fee exceeded the range of a 64-bit signed integer
   */
  CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE,

  /**
   * A royalty cannot exceed the total fungible value exchanged for an NFT
   */
  ROYALTY_FRACTION_CANNOT_EXCEED_ONE,

  /**
   * Each fractional custom fee must have its maximum_amount, if specified, at least its minimum_amount
   */
  FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT,

  /**
   * A fee schedule update tried to clear the custom fees from a token whose fee schedule was already empty
   */
  CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES,

  /**
   * Only tokens of type FUNGIBLE_COMMON can be used to as fee schedule denominations
   */
  CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON,

  /**
   * Only tokens of type FUNGIBLE_COMMON can have fractional fees
   */
  CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON,

  /**
   * The provided custom fee schedule key was invalid
   */
  INVALID_CUSTOM_FEE_SCHEDULE_KEY,

  /**
   * The requested token mint metadata was invalid
   */
  INVALID_TOKEN_MINT_METADATA,

  /**
   * The requested token burn metadata was invalid
   */
  INVALID_TOKEN_BURN_METADATA,

  /**
   * The treasury for a unique token cannot be changed until it owns no NFTs
   */
  CURRENT_TREASURY_STILL_OWNS_NFTS,

  /**
   * An account cannot be dissociated from a unique token if it owns NFTs for the token
   */
  ACCOUNT_STILL_OWNS_NFTS,

  /**
   * A NFT can only be burned when owned by the unique token's treasury
   */
  TREASURY_MUST_OWN_BURNED_NFT,

  /**
   * An account did not own the NFT to be wiped
   */
  ACCOUNT_DOES_NOT_OWN_WIPED_NFT,

  /**
   * An AccountAmount token transfers list referenced a token type other than FUNGIBLE_COMMON
   */
  ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON,

  /**
   * All the NFTs allowed in the current price regime have already been minted
   */
  MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED,

  /**
   * The payer account has been marked as deleted
   */
  PAYER_ACCOUNT_DELETED,

  /**
   * The reference chain of custom fees for a transferred token exceeded the maximum length of 2
   */
  CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH,

  /**
   * More than 20 balance adjustments were to satisfy a CryptoTransfer and its implied custom fee payments
   */
  CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS,

  /**
   * The sender account in the token transfer transaction could not afford a custom fee
   */
  INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE,

  /**
   * Currently no more than 4,294,967,295 NFTs may be minted for a given unique token type
   */
  SERIAL_NUMBER_LIMIT_REACHED,

  /**
   * Only tokens of type NON_FUNGIBLE_UNIQUE can have royalty fees
   */
  CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE,

  /**
   * The account has reached the limit on the automatic associations count.
   */
  NO_REMAINING_AUTOMATIC_ASSOCIATIONS,

  /**
   * Already existing automatic associations are more than the new maximum automatic associations.
   */
  EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT,

  /**
   * Cannot set the number of automatic associations for an account more than the maximum allowed
   * token associations tokens.maxPerAccount.
   */
  REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT,

  /**
   * Token is paused. This Token cannot be a part of any kind of Transaction until unpaused.
   */
  TOKEN_IS_PAUSED,

  /**
   * Pause key is not set on token
   */
  TOKEN_HAS_NO_PAUSE_KEY,

  /**
   * The provided pause key was invalid
   */
  INVALID_PAUSE_KEY,

  /**
   * The update file in a freeze transaction body must exist.
   */
  FREEZE_UPDATE_FILE_DOES_NOT_EXIST,

  /**
   * The hash of the update file in a freeze transaction body must match the in-memory hash.
   */
  FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH,

  /**
   * A FREEZE_UPGRADE transaction was handled with no previous update prepared.
   */
  NO_UPGRADE_HAS_BEEN_PREPARED,

  /**
   * A FREEZE_ABORT transaction was handled with no scheduled freeze.
   */
  NO_FREEZE_IS_SCHEDULED,

  /**
   * The update file hash when handling a FREEZE_UPGRADE transaction differs from the file
   * hash at the time of handling the PREPARE_UPGRADE transaction.
   */
  UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE,

  /**
   * The given freeze start time was in the (consensus) past.
   */
  FREEZE_START_TIME_MUST_BE_FUTURE,

  /**
   * The prepared update file cannot be updated or appended until either the upgrade has
   * been completed, or a FREEZE_ABORT has been handled.
   */
  PREPARED_UPDATE_FILE_IS_IMMUTABLE,

  /**
   * Once a freeze is scheduled, it must be aborted before any other type of freeze can
   * can be performed.
   */
  FREEZE_ALREADY_SCHEDULED,

  /**
   * If an NMT upgrade has been prepared, the following operation must be a FREEZE_UPGRADE.
   * (To issue a FREEZE_ONLY, submit a FREEZE_ABORT first.)
   */
  FREEZE_UPGRADE_IN_PROGRESS,

  /**
   * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
   * confirm the id of the file to be used in the upgrade.
   */
  UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED,

  /**
   * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
   * confirm the hash of the file to be used in the upgrade.
   */
  UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED,

  /**
   * Consensus throttle did not allow execution of this transaction. System is throttled at
   * consensus level.
   */
  CONSENSUS_GAS_EXHAUSTED,

  /**
   * A precompiled contract succeeded, but was later reverted.
   */
  REVERTED_SUCCESS,

  /**
   * All contract storage allocated to the current price regime has been consumed.
   */
  MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED,

  /**
   * An alias used in a CryptoTransfer transaction is not the serialization of a primitive Key
   * message--that is, a Key with a single Ed25519 or ECDSA(secp256k1) public key and no
   * unknown protobuf fields.
   */
  INVALID_ALIAS_KEY,

  /**
   * A fungible token transfer expected a different number of decimals than the involved
   * type actually has.
   */
  UNEXPECTED_TOKEN_DECIMALS,

  /**
   * The transfer account id in CryptoDelete transaction is invalid or does not exist.
   */
  INVALID_TRANSFER_ACCOUNT_ID,

  /**
   * The fee collector account id in TokenFeeScheduleUpdate is invalid or does not exist.
   */
  INVALID_FEE_COLLECTOR_ACCOUNT_ID,

  /**
   * The alias already set on an account cannot be updated using CryptoUpdate transaction.
   */
  ALIAS_IS_IMMUTABLE,

  /**
   * An approved allowance specifies a spender account that is the same as the hbar/token
   * owner account.
   */
  SPENDER_ACCOUNT_SAME_AS_OWNER,

  /**
   * The establishment or adjustment of an approved allowance cause the token allowance
   * to exceed the token maximum supply.
   */
  AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY,

  /**
   * The specified amount for an approved allowance cannot be negative.
   */
  NEGATIVE_ALLOWANCE_AMOUNT,

  /**
   * The spender does not have an existing approved allowance with the hbar/token owner.
   */
  SPENDER_DOES_NOT_HAVE_ALLOWANCE,

  /**
   * The transfer amount exceeds the current approved allowance for the spender account.
   */
  AMOUNT_EXCEEDS_ALLOWANCE,

  /**
   * The payer account of an approveAllowances or adjustAllowance transaction is attempting
   * to go beyond the maximum allowed number of allowances.
   */
  MAX_ALLOWANCES_EXCEEDED,

  /**
   * No allowances have been specified in the approval transaction.
   */
  EMPTY_ALLOWANCES,

  /**
   * Fungible common token used in NFT allowances
   */
  FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES,

  /**
   * Non fungible token used in fungible token allowances
   */
  NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES,

  /**
   * The account id specified as the owner is invalid or does not exist.
   */
  INVALID_ALLOWANCE_OWNER_ID,

  /**
   * The account id specified as the spender is invalid or does not exist.
   */
  INVALID_ALLOWANCE_SPENDER_ID,

  /**
   * If the account Id specified as the delegating spender is invalid or does not exist.
   */
  INVALID_DELEGATING_SPENDER,

  /**
   * The delegating Spender cannot grant approveForAll allowance on a NFT token type for another spender.
   */
  DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL,

  /**
   * The delegating Spender cannot grant allowance on a NFT serial for another spender as it doesnt not have
   * approveForAll granted on token-owner.
   */
  DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL,

  /**
   * The scheduled transaction could not be created because it's expiration_time was too far in the future.
   */
  SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE,

  /**
   * The scheduled transaction could not be created because it's expiration_time was less than or equal to the consensus
   * time.
   */
  SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME,

  /**
   * The scheduled transaction could not be created because it would cause throttles to be violated on the specified
   * expiration_time.
   */
  SCHEDULE_FUTURE_THROTTLE_EXCEEDED,

  /**
   * The scheduled transaction could not be created because it would cause the gas limit to be violated on the specified
   * expiration_time.
   */
  SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED,

  /**
   * The ethereum transaction either failed parsing or failed signature validation, or some other EthereumTransaction
   * error not covered by another response code.
   */
  INVALID_ETHEREUM_TRANSACTION,

  /**
   * EthereumTransaction was signed against a chainId that this network does not support.
   */
  WRONG_CHAIN_ID,

  /**
   * This transaction specified an ethereumNonce that is not the current ethereumNonce of the account.
   */
  WRONG_NONCE,

  /**
   * The ethereum transaction specified an access list, which the network does not support.
   */
  ACCESS_LIST_UNSUPPORTED,

  /**
   * A schedule being signed or deleted has passed it's expiration date and is pending execution if needed and then
   * expiration.
   */
  SCHEDULE_PENDING_EXPIRATION,

  /**
   * A selfdestruct or ContractDelete targeted a contract that is a token treasury.
   */
  CONTRACT_IS_TOKEN_TREASURY,

  /**
   * A selfdestruct or ContractDelete targeted a contract with non-zero token balances.
   */
  CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES,

  /**
   * A contract referenced by a transaction is "detached"; that is, expired and lacking any
   * hbar funds for auto-renewal payment---but still within its post-expiry grace period.
   */
  CONTRACT_EXPIRED_AND_PENDING_REMOVAL,

  /**
   * A ContractUpdate requested removal of a contract's auto-renew account, but that contract has
   * no auto-renew account.
   */
  CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT,

  /**
   * A delete transaction submitted via HAPI set permanent_removal=true
   */
  PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION,

  /**
   * A CryptoCreate or ContractCreate used the deprecated proxyAccountID field.
   */
  PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED,

  /**
   * An account set the staked_account_id to itself in CryptoUpdate or ContractUpdate transactions.
   */
  SELF_STAKING_IS_NOT_ALLOWED,

  /**
   * The staking account id or staking node id given is invalid or does not exist.
   */
  INVALID_STAKING_ID,

  /**
   * Native staking, while implemented, has not yet enabled by the council.
   */
  STAKING_NOT_ENABLED,

  /**
   * The range provided in UtilPrng transaction is negative.
   */
  INVALID_PRNG_RANGE,

  /**
   * The maximum number of entities allowed in the current price regime have been created.
   */
  MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED,

  /**
   * The full prefix signature for precompile is not valid
   */
  INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE,

  /**
   * The combined balances of a contract and its auto-renew account (if any) did not cover
   * the rent charged for net new storage used in a transaction.
   */
  INSUFFICIENT_BALANCES_FOR_STORAGE_RENT,

  /**
   * A contract transaction tried to use more than the allowed number of child records, via
   * either system contract records or internal contract creations.
   */
  MAX_CHILD_RECORDS_EXCEEDED,

  /**
   * The combined balances of a contract and its auto-renew account (if any) or balance of an account did not cover
   * the auto-renewal fees in a transaction.
   */
  INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES,

  /**
   * A transaction's protobuf message includes unknown fields; could mean that a client expects not-yet-released
   * functionality to be available.
   */
  TRANSACTION_HAS_UNKNOWN_FIELDS,

  /**
   * The account cannot be modified. Account's key is not set
   */
  ACCOUNT_IS_IMMUTABLE,

  /**
   * An alias that is assigned to an account or contract cannot be assigned to another account or contract.
   */
  ALIAS_ALREADY_ASSIGNED,

  /**
   * A provided metadata key was invalid. Verification includes, for example, checking the size of Ed25519 and
   * ECDSA(secp256k1) public keys.
   */
  INVALID_METADATA_KEY,

  /**
   * Metadata key is not set on token.
   */
  TOKEN_HAS_NO_METADATA_KEY,

  /**
   * Token Metadata is not provided
   */
  MISSING_TOKEN_METADATA,

  /**
   * NFT serial numbers are missing in the TokenUpdateNftsTransactionBody
   */
  MISSING_SERIAL_NUMBERS,

  /**
   * The maximum automatic associations value is not valid. The most common cause for this error is a value less than
   * `-1`.
   */
  INVALID_MAX_AUTO_ASSOCIATIONS,

  /**
   * The transaction attempted to use duplicate `TokenReference`.<br/>
   * This affects `TokenReject` attempting to reject same token reference more than once.
   */
  TOKEN_REFERENCE_REPEATED,

  /**
   * The account id specified as the owner in `TokenReject` is invalid or does not exist.
   */
  INVALID_OWNER_ID,

  /**
   * The transaction attempted to use empty `TokenReference` list.
   */
  EMPTY_TOKEN_REFERENCE_LIST,

  /**
   * The transaction attempted to the use an empty List of `PendingAirdropId`.
   */
  EMPTY_PENDING_AIRDROP_ID_LIST,

  /**
   * The transaction attempted to the same `PendingAirdropId` twice.
   */
  PENDING_AIRDROP_ID_REPEATED,

  /**
   * The transaction attempted to use more than the allowed number of `PendingAirdropId`.
   */
  PENDING_AIRDROP_ID_LIST_TOO_LONG,

  /**
   * A pending airdrop already exists for the specified NFT.
   */
  PENDING_NFT_AIRDROP_ALREADY_EXISTS,

  /**
   * The identified account is sender for one or more pending airdrop(s)
   * and cannot be deleted.
   * Requester should cancel all pending airdrops before resending
   * this transaction.
   */
  ACCOUNT_HAS_PENDING_AIRDROPS,

  /**
   * Consensus throttle did not allow execution of this transaction.
   * The transaction should be retried after a modest delay.
   */
  THROTTLED_AT_CONSENSUS,

  /**
   * The provided pending airdrop id is invalid.
   * This pending airdrop MAY already be claimed or cancelled.
   * The client SHOULD query a mirror node to determine the current status of
   * the pending airdrop.
   */
  INVALID_PENDING_AIRDROP_ID,

  /**
   * The token to be airdropped has a fallback royalty fee and cannot be
   * sent or claimed via an airdrop transaction.
   */
  TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY,

  /**
   * This airdrop claim is for a pending airdrop with an invalid token.
   * The token might be deleted, or the sender may not have enough tokens
   * to fulfill the offer.
   * The client SHOULD query mirror node to determine the status of the pending
   * airdrop and whether the sender can fulfill the offer.
   */
  INVALID_TOKEN_IN_PENDING_AIRDROP,

  /**
   * A transaction failed because the consensus node identified is
   * deleted from the address book.
   */
  NODE_DELETED,

  /**
   * A transaction failed because the consensus node identified is not valid or
   * does not exist in state.
   */
  INVALID_NODE_ID,

  /**
   * A transaction failed because one or more entries in the list of
   * service endpoints for the `gossip_endpoint` field is invalid.<br/>
   * The most common cause for this response is a service endpoint that has
   * the domain name (DNS) set rather than address and port.
   */
  INVALID_GOSSIP_ENDPOINT,

  /**
   * A transaction failed because the node account identifier provided
   * does not exist or is not valid.<br/>
   * One common source of this error is providing a node account identifier
   * using the "alias" form rather than "numeric" form.
   */
  INVALID_NODE_ACCOUNT_ID,

  /**
   * A transaction failed because the description field cannot be encoded
   * as UTF-8 or is more than 100 bytes when encoded.
   */
  INVALID_NODE_DESCRIPTION,

  /**
   * A transaction failed because one or more entries in the list of
   * service endpoints for the `service_endpoint` field is invalid.<br/>
   * The most common cause for this response is a service endpoint that has
   * the domain name (DNS) set rather than address and port.
   */
  INVALID_SERVICE_ENDPOINT,

  /**
   * A transaction failed because the TLS certificate provided for the
   * node is missing or invalid.<br/>
   * The certificate MUST be a TLS certificate of a type permitted for gossip
   * signatures.<br/>
   * The value presented MUST be a UTF-8 NFKD encoding of the TLS
   * certificate.<br/>
   * The certificate encoded MUST be in PEM format.<br/>
   * The `gossip_ca_certificate` field is REQUIRED and MUST NOT be empty.
   */
  INVALID_GOSSIP_CA_CERTIFICATE,

  /**
   * A transaction failed because the hash provided for the gRPC certificate
   * is present but invalid.<br/>
   * The `grpc_certificate_hash` MUST be a SHA-384 hash.<br/>
   * The input hashed MUST be a UTF-8 NFKD encoding of the actual TLS
   * certificate.<br/>
   * The certificate to be encoded MUST be in PEM format.
   */
  INVALID_GRPC_CERTIFICATE,

  /**
   * The maximum number of nodes allowed in the address book have been created.
   */
  MAX_NODES_CREATED,

  /**
   * In ServiceEndpoint, domain_name and ipAddressV4 are mutually exclusive
   */
  IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT,

  /**
   *  Fully qualified domain name is not allowed in gossip_endpoint
   */
  GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN,

  /**
   * In ServiceEndpoint, domain_name size too large
   */
  FQDN_SIZE_TOO_LARGE,

  /**
   * ServiceEndpoint is invalid
   */
  INVALID_ENDPOINT,

  /**
   * The number of gossip endpoints exceeds the limit
   */
  GOSSIP_ENDPOINTS_EXCEEDED_LIMIT,

  /**
   * A scheduled transaction configured to wait for expiry to execute was given
   * an expiry time not strictly after the time at which its creation reached
   * consensus.
   */
  SCHEDULE_EXPIRY_MUST_BE_FUTURE,

  /**
   * A scheduled transaction configured to wait for expiry to execute was given
   * an expiry time too far in the future after the time at which its creation
   * reached consensus.
   */
  SCHEDULE_EXPIRY_TOO_LONG,

  /**
   * A scheduled transaction configured to wait for expiry to execute was given
   * an expiry time at which there is already too many transactions scheduled to
   * expire; its creation must be retried with a different expiry.
   */
  SCHEDULE_EXPIRY_IS_BUSY,

  /**
   * A scheduled transaction configured to wait for expiry to execute was not
   * given an explicit expiration time.
   */
  MISSING_EXPIRY_TIME,

  /**
   * A contract operation attempted to schedule another transaction after it
   * had already scheduled a recursive contract call.
   */
  NO_SCHEDULING_ALLOWED_AFTER_SCHEDULED_RECURSION,

  /**
   * A contract can schedule recursive calls a finite number of times (this is
   * approximately four million times with typical network configuration.)
   */
  RECURSIVE_SCHEDULING_LIMIT_REACHED,

  /**
   * The target network is waiting for the ledger ID to be set, which is a
   * side effect of finishing the network's TSS construction.
   */
  WAITING_FOR_LEDGER_ID,

  /**
   * The provided fee exempt key list size exceeded the limit.
   */
  MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED,

  /**
   * The provided fee exempt key list contains duplicated keys.
   */
  FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS,

  /**
   * The provided fee exempt key list contains an invalid key.
   */
  INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST,

  /**
   * The provided fee schedule key contains an invalid key.
   */
  INVALID_FEE_SCHEDULE_KEY,

  /**
   * If a fee schedule key is not set when we create a topic
   * we cannot add it on update.
   */
  FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED,

  /**
   * If the topic's custom fees are updated the topic SHOULD have a
   * fee schedule key
   */
  FEE_SCHEDULE_KEY_NOT_SET,

  /**
   * The fee amount is exceeding the amount that the payer
   * is willing to pay.
   */
  MAX_CUSTOM_FEE_LIMIT_EXCEEDED,

  /**
   * There are no corresponding custom fees.
   */
  NO_VALID_MAX_CUSTOM_FEE,

  /**
   * The provided list contains invalid max custom fee.
   */
  INVALID_MAX_CUSTOM_FEES,

  /**
   * The provided max custom fee list contains fees with
   * duplicate denominations.
   */
  DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST,

  /**
   * The provided max custom fee list contains fees with
   * duplicate account id.
   */
  DUPLICATE_ACCOUNT_ID_IN_MAX_CUSTOM_FEE_LIST,

  /**
   * Max custom fees list is not supported for this operation.
   */
  MAX_CUSTOM_FEES_IS_NOT_SUPPORTED

};

/**
 * Map of protobuf ResponseCodeEnums to the corresponding Status.
 */
extern const std::unordered_map<proto::ResponseCodeEnum, Status> gProtobufResponseCodeToStatus;

/**
 * Map of Status to its corresponding ResponseCodeEnum protobuf.
 */
extern const std::unordered_map<Status, proto::ResponseCodeEnum> gStatusToProtobufResponseCode;

/**
 * Map of Status to its corresponding string.
 */
[[maybe_unused]] extern const std::unordered_map<Status, std::string> gStatusToString;

} // namespace Hiero

#endif // HIERO_SDK_CPP_STATUS_H_
// Filename: src/sdk/main/include/SubscriptionHandle.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SUBSCRIPTION_HANDLE_H_
#define HIERO_SDK_CPP_SUBSCRIPTION_HANDLE_H_

#include <functional>
#include <mutex>

namespace Hiero
{
class SubscriptionHandle
{
public:
  /**
   * Destructor unsubscribes.
   */
  ~SubscriptionHandle();

  /**
   * Unsubscribe from the subscription this SubscriptionHandle is holding.
   */
  void unsubscribe() const;

  /**
   * Set the function to run when unsubscribing.
   *
   * @param onUnsubscribe The function to run when unsubscribing.
   */
  void setOnUnsubscribe(const std::function<void(void)>& onUnsubscribe);

private:
  /**
   * The function to run when attempting to unsubscribe.
   */
  std::function<void(void)> mUnsubscribeFunc;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_SUBSCRIPTION_HANDLE_H_
// Filename: src/sdk/main/include/SystemDeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SYSTEM_DELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_SYSTEM_DELETE_TRANSACTION_H_

#include "ContractId.h"
#include "FileId.h"
#include "Transaction.h"

#include <optional>

namespace proto
{
class SystemDeleteTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Delete a file or smart contract - can only be done with a Hiero administrative multisignature. When it is deleted,
 * it immediately disappears from the system as seen by the user, but is still stored internally until the expiration
 * time, at which time it is truly and permanently deleted. Until that time, it can be undeleted by the Hiero
 * administrative multisignature. When a smart contract is deleted, the cryptocurrency account within it continues to
 * exist, and is not affected by the expiration time here.
 *
 * Transaction Signing Requirements:
 *  - The Hiero administrative multisignature.
 */
class SystemDeleteTransaction : public Transaction<SystemDeleteTransaction>
{
public:
  SystemDeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a SystemDelete.
   */
  explicit SystemDeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit SystemDeleteTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the file to delete. This is mutually exclusive with mContractId, and will reset the value of
   * mContractId if it is set.
   *
   * @param fileId The ID of the file to delete.
   * @return A reference to this SystemDeleteTransaction object with the newly-set file ID.
   * @throws IllegalStateException If this SystemDeleteTransaction is frozen.
   */
  SystemDeleteTransaction& setFileId(const FileId& fileId);

  /**
   * Set the ID of the contract to delete. This is mutually exclusive with mFileId, and will reset the value of mFileId
   * if it is set.
   *
   * @param contractId The ID of the contract to delete.
   * @return A reference to this SystemDeleteTransaction object with the newly-set contract ID.
   * @throws IllegalStateException If this SystemDeleteTransaction is frozen.
   */
  SystemDeleteTransaction& setContractId(const ContractId& contractId);

  /**
   * Set the timestamp at which the deleted file will truly be permanently deleted.
   *
   * @param timestamp The timestamp at which the deleted file will truly be permanently deleted.
   * @return A reference to this SystemDeleteTransaction object with the newly-set expiration time.
   * @throws IllegalStateException If this SystemDeleteTransaction is frozen.
   */
  SystemDeleteTransaction& setExpirationTime(const std::chrono::system_clock::time_point& timestamp);

  /**
   * Get the ID of the file this SystemDeleteTransaction is currently configured to delete.
   *
   * @return The ID of the file this SystemDeleteTransaction is currently configured to delete. Returns uninitialized if
   *         a value has not yet been set, or if a contract ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<FileId> getFileId() const { return mFileId; }

  /**
   * Get the ID of the contract this SystemDeleteTransaction is currently configured to delete.
   *
   * @return The ID of the contract this SystemDeleteTransaction is currently configured to delete. Returns
   *         uninitialized if a value has not yet been set, or if a file ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<ContractId> getContractId() const { return mContractId; }

  /**
   * Get the timestamp at which the deleted file will truly be permanently deleted.
   *
   * @return The timestamp at which the deleted file will truly be permanently deleted.
   */
  [[nodiscard]] inline std::chrono::system_clock::time_point getExpirationTime() const { return mExpirationTime; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this SystemDeleteTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this SystemDeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This SystemDeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the SystemDeleteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this SystemDeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a SystemDeleteTransactionBody protobuf object from this SystemDeleteTransaction object.
   *
   * @return A pointer to a SystemDeleteTransactionBody protobuf object filled with this SystemDeleteTransaction
   *         object's data.
   */
  [[nodiscard]] proto::SystemDeleteTransactionBody* build() const;

  /**
   * The ID of the file to delete. Mutually exclusive with mContractId.
   */
  std::optional<FileId> mFileId;

  /**
   * The ID of the contract to delete. Mutually exclusive with mFileId.
   */
  std::optional<ContractId> mContractId;

  /**
   * The timestamp at which the deleted file will truly be permanently deleted
   */
  std::chrono::system_clock::time_point mExpirationTime;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_SYSTEM_DELETE_TRANSACTION_H_
// Filename: src/sdk/main/include/SystemUndeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_SYSTEM_UNDELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_SYSTEM_UNDELETE_TRANSACTION_H_

#include "ContractId.h"
#include "FileId.h"
#include "Transaction.h"

#include <optional>

namespace proto
{
class SystemUndeleteTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Undelete a file or smart contract that was deleted by SystemDelete; requires a Hiero administrative multisignature.
 *
 * Transaction Signing Requirements:
 *  - The Hiero administrative multisignature.
 */
class SystemUndeleteTransaction : public Transaction<SystemUndeleteTransaction>
{
public:
  SystemUndeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a SystemUndelete.
   */
  explicit SystemUndeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit SystemUndeleteTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the file to undelete. This is mutually exclusive with mContractId, and will reset the value of
   * mContractId if it is set.
   *
   * @param fileId The ID of the file to undelete.
   * @return A reference to this SystemUndeleteTransaction object with the newly-set file ID.
   * @throws IllegalStateException If this SystemUndeleteTransaction is frozen.
   */
  SystemUndeleteTransaction& setFileId(const FileId& fileId);

  /**
   * Set the ID of the contract to undelete. This is mutually exclusive with mFileId, and will reset the value of
   * mFileId if it is set.
   *
   * @param contractId The ID of the contract to undelete.
   * @return A reference to this SystemUndeleteTransaction object with the newly-set contract ID.
   * @throws IllegalStateException If this SystemUndeleteTransaction is frozen.
   */
  SystemUndeleteTransaction& setContractId(const ContractId& contractId);

  /**
   * Get the ID of the file this SystemUndeleteTransaction is currently configured to undelete.
   *
   * @return The ID of the file this SystemUndeleteTransaction is currently configured to undelete. Returns
   * uninitialized if a value has not yet been set, or if a contract ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<FileId> getFileId() const { return mFileId; }

  /**
   * Get the ID of the contract this SystemUndeleteTransaction is currently configured to undelete.
   *
   * @return The ID of the contract this SystemUndeleteTransaction is currently configured to undelete. Returns
   *         uninitialized if a value has not yet been set, or if a file ID has been set most recently.
   */
  [[nodiscard]] inline std::optional<ContractId> getContractId() const { return mContractId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this SystemUndeleteTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this SystemUndeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This SystemUndeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the SystemUndeleteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this SystemUndeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a SystemUndeleteTransactionBody protobuf object from this SystemUndeleteTransaction object.
   *
   * @return A pointer to a SystemUndeleteTransactionBody protobuf object filled with this SystemUndeleteTransaction
   *         object's data.
   */
  [[nodiscard]] proto::SystemUndeleteTransactionBody* build() const;

  /**
   * The ID of the file to undelete. Mutually exclusive with mContractId.
   */
  std::optional<FileId> mFileId;

  /**
   * The ID of the contract to undelete. Mutually exclusive with mFileId.
   */
  std::optional<ContractId> mContractId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_SYSTEM_UNDELETE_TRANSACTION_H_// Filename: src/sdk/main/include/TokenAirdropTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_AIRDROP_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_AIRDROP_TRANSACTION_H_

#include "TokenNftTransfer.h"
#include "TokenTransfer.h"
#include "Transaction.h"

namespace proto
{
class TokenAirdropTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Airdrop one or more tokens to one or more accounts.
 *
 * ### Effects
 * This distributes tokens from the balance of one or more sending account(s) to the balance
 * of one or more recipient accounts. Accounts MAY receive the tokens in one of four ways.
 *
 *  - An account already associated to the token to be distributed SHALL receive the
 *    airdropped tokens immediately to the recipient account balance.
 *    The fee for this transfer SHALL include the transfer, the airdrop fee, and any custom fees.
 *  - An account with available automatic association slots SHALL be automatically
 *    associated to the token, and SHALL immediately receive the airdropped tokens to the
 *    recipient account balance.
 *    The fee for this transfer SHALL include the transfer, the association, the cost to renew
 *    that association once, the airdrop fee, and any custom fees.
 *  - An account with "receiver signature required" set SHALL have a "Pending Airdrop" created
 *    and must claim that airdrop with a `claimAirdrop` transaction.
 *    The fee for this transfer SHALL include the transfer, the association, the cost to renew
 *    that association once, the airdrop fee, and any custom fees. If the pending airdrop is not
 *    claimed immediately, the `sender` SHALL pay the cost to renew the token association, and
 *    the cost to maintain the pending airdrop, until the pending airdrop is claimed or cancelled.
 *  - An account with no available automatic association slots SHALL have a "Pending Airdrop"
 *    created and must claim that airdrop with a `claimAirdrop` transaction.
 *    The fee for this transfer SHALL include the transfer, the association, the cost to renew
 *    that association once, the airdrop fee, and any custom fees. If the pending airdrop is not
 *    claimed immediately, the `sender` SHALL pay the cost to renew the token association, and
 *    the cost to maintain the pending airdrop, until the pending airdrop is claimed or cancelled.
 *
 * If an airdrop would create a pending airdrop for a fungible/common token, and a pending airdrop
 * for the same sender, receiver, and token already exists, the existing pending airdrop
 * SHALL be updated to add the new amount to the existing airdrop, rather than creating a new
 * pending airdrop.
 *
 * Any airdrop that completes immediately SHALL be irreversible. Any airdrop that results in a
 * "Pending Airdrop" MAY be canceled via a `cancelAirdrop` transaction.
 *
 * All transfer fees (including custom fees and royalties), as well as the rent cost for the
 * first auto-renewal period for any automatic-association slot occupied by the airdropped
 * tokens, SHALL be charged to the account paying for this transaction.
 *
 * ### Record Stream Effects
 * - Each successful transfer SHALL be recorded in `token_transfer_list` for the transaction record.
 * - Each successful transfer that consumes an automatic association slot SHALL populate the
 *   `automatic_association` field for the record.
 * - Each pending transfer _created_ SHALL be added to the `pending_airdrops` field for the record.
 * - Each pending transfer _updated_ SHALL be added to the `pending_airdrops` field for the record.
 */
class TokenAirdropTransaction : public Transaction<TokenAirdropTransaction>
{
public:
  TokenAirdropTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenAirdrop transaction.
   */
  explicit TokenAirdropTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenAirdropTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Add a token transfer to be submitted as part of this TokenAirdropTransaction.
   *
   * @param tokenId   The ID of the token associated with this transfer.
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The number of tokens to transfer.
   * @return A reference to this TokenAirdropTransaction object with the newly-added token transfer.
   * @throws IllegalStateException If this TokenAirdropTransaction is frozen.
   */
  TokenAirdropTransaction& addTokenTransfer(const TokenId& tokenId, const AccountId& accountId, const int64_t& amount);

  /**
   * Add an NFT transfer to be submitted as part of this TokenAirdropTransaction.
   *
   * @param nftId             The ID of the NFT associated with this transfer.
   * @param senderAccountId   The ID of the account sending the NFT.
   * @param receiverAccountId The ID of the receiving sending the NFT.
   * @return A reference to this TokenAirdropTransaction object with the newly-added NFT transfer.
   * @throws IllegalStateException If this TokenAirdropTransaction is frozen.
   */
  TokenAirdropTransaction& addNftTransfer(const NftId& nftId,
                                          const AccountId& senderAccountId,
                                          const AccountId& receiverAccountId);

  /**
   * Add a token transfer with decimals to be submitted as part of this TokenAirdropTransaction.
   *
   * @param tokenId   The ID of the token associated with this transfer.
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The number of tokens to transfer.
   * @param decimals  The number of decimals in the transfer amount.
   * @return A reference to this TokenAirdropTransaction object with the newly-added token transfer.
   * @throws IllegalStateException If this TokenAirdropTransaction is frozen.
   * @throws std::invalid_argument If decimals does not match previously set decimals for this token.
   */
  TokenAirdropTransaction& addTokenTransferWithDecimals(const TokenId& tokenId,
                                                        const AccountId& accountId,
                                                        const int64_t& amount,
                                                        uint32_t decimals);

  /**
   * Add an approved token transfer to be submitted as part of this TokenAirdropTransaction.
   *
   * @param tokenId   The ID of the token associated with this transfer.
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The number of tokens to transfer.
   * @return A reference to this TokenAirdropTransaction object with the newly-added approved token transfer.
   * @throws IllegalStateException If this TokenAirdropTransaction is frozen.
   */
  TokenAirdropTransaction& addApprovedTokenTransfer(const TokenId& tokenId,
                                                    const AccountId& accountId,
                                                    const int64_t& amount);

  /**
   * Add an approved NFT transfer to be submitted as part of this TokenAirdropTransaction.
   *
   * @param nftId             The ID of the NFT associated with this transfer.
   * @param senderAccountId   The ID of the account sending the NFT.
   * @param receiverAccountId The ID of the receiving sending the NFT.
   * @return A reference to this TokenAirdropTransaction object with the newly-added approved NFT transfer.
   * @throws IllegalStateException If this TokenAirdropTransaction is frozen.
   */
  TokenAirdropTransaction& addApprovedNftTransfer(const NftId& nftId,
                                                  const AccountId& senderAccountId,
                                                  const AccountId& receiverAccountId);

  /**
   * Add an approved token transfer with decimals to be submitted as part of this TokenAirdropTransaction.
   *
   * @param tokenId   The ID of the token associated with this transfer.
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The number of tokens to transfer.
   * @param decimals  The number of decimals in the transfer amount.
   * @return A reference to this TokenAirdropTransaction object with the newly-added approved token transfer.
   * @throws IllegalStateException If this TokenAirdropTransaction is frozen.
   * @throws std::invalid_argument If decimals does not match previously set decimals for this token.
   */
  TokenAirdropTransaction& addApprovedTokenTransferWithDecimals(const TokenId& tokenId,
                                                                const AccountId& accountId,
                                                                const int64_t& amount,
                                                                uint32_t decimals);

  /**
   * Get all token transfers that have been added to this TokenAirdropTransaction.
   *
   * @return The map of token transfers.
   */
  [[nodiscard]] std::unordered_map<TokenId, std::unordered_map<AccountId, int64_t>> getTokenTransfers() const;

  /**
   * Get all NFT transfers that have been added to this TokenAirdropTransaction.
   *
   * @return The map of NFT transfers.
   */
  [[nodiscard]] std::unordered_map<TokenId, std::vector<TokenNftTransfer>> getNftTransfers() const;

  /**
   * Get the expected decimals for token transfers that have been added to this TokenAirdropTransaction.
   *
   * @return The map of expected decimals.
   */
  [[nodiscard]] std::unordered_map<TokenId, uint32_t> getTokenIdDecimals() const;

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenAirdropTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenAirdropTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenAirdropTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenAirdropTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenAirdropTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenAirdropTransactionBody protobuf object from this TokenAirdropTransaction object.
   *
   * @return A pointer to a TokenAirdropTransactionBody protobuf object filled with this TokenAirdropTransaction
   * object's data.
   */
  [[nodiscard]] proto::TokenAirdropTransactionBody* build() const;

  /**
   * Add a token transfer to the token transfers list.
   *
   * @param transfer The token transfer to add.
   */
  void doTokenTransfer(const TokenTransfer& transfer);

  /**
   * Add an NFT transfer to the NFT transfers list.
   *
   * @param nftId The ID of the NFT.
   * @param sender The ID of the account sending the NFT.
   * @param receiver The ID of the account receiving the NFT.
   * @param approved \c TRUE if this is an approved allowance NFT transfer, otherwise \c FALSE.
   */
  void doNftTransfer(const NftId& nftId, const AccountId& sender, const AccountId& receiver, bool approved);

  /**
   * The desired token adjustments.
   */
  std::vector<TokenTransfer> mTokenTransfers;

  /**
   * The desired NFT adjustments.
   */
  std::vector<TokenNftTransfer> mNftTransfers;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_AIRDROP_TRANSACTION_H_// Filename: src/sdk/main/include/TokenAllowance.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_ALLOWANCE_H_
#define HIERO_SDK_CPP_TOKEN_ALLOWANCE_H_

#include "AccountId.h"
#include "TokenId.h"

#include <cstddef>
#include <cstdint>
#include <memory>
#include <vector>

namespace proto
{
class TokenAllowance;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * An approved allowance of fungible token transfers for a spender.
 */
class TokenAllowance
{
public:
  TokenAllowance() = default;

  /**
   * Construct with a token ID, owner, spender, and amount.
   *
   * @param tokenId The ID of the token that is being approved to be spent.
   * @param owner   The ID of the account approving an allowance of its tokens.
   * @param spender The ID of the account being allowed to spend the tokens.
   * @param amount  The amount of tokens that are being allowed to be spent.
   */
  TokenAllowance(const TokenId& tokenId, AccountId owner, AccountId spender, int64_t amount);

  /**
   * Construct a TokenAllowance object from a TokenAllowance protobuf object.
   *
   * @param proto The TokenAllowance protobuf object from which to construct an TokenAllowance object.
   * @return The constructed TokenAllowance object.
   */
  [[nodiscard]] static TokenAllowance fromProtobuf(const proto::TokenAllowance& proto);

  /**
   * Construct a TokenAllowance object from a byte array.
   *
   * @param bytes The byte array from which to construct an TokenAllowance object.
   * @return The constructed TokenAllowance object.
   */
  [[nodiscard]] static TokenAllowance fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Validate the checksums of the entity IDs in this TokenAllowance.
   *
   * @param client The Client to use to validate the checksums.
   * @throws BadEntityException If the checksums are not valid.
   */
  void validateChecksums(const Client& client) const;

  /**
   * Construct a TokenAllowance protobuf object from this TokenAllowance object.
   *
   * @return A pointer to a constructed TokenAllowance protobuf object filled with this TokenAllowance object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::TokenAllowance> toProtobuf() const;

  /**
   * Construct a byte array from this TokenAllowance object.
   *
   * @return A byte array representing this TokenAllowance object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * The ID of the token that is being approved to be spent.
   */
  TokenId mTokenId;

  /**
   * The ID of the account approving an allowance of its tokens.
   */
  AccountId mOwnerAccountId;

  /**
   * The ID of the account being allowed to spend the tokens.
   */
  AccountId mSpenderAccountId;

  /**
   * The amount of tokens that are being allowed to be spent.
   */
  int64_t mAmount = 0LL;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_ALLOWANCE_H_
// Filename: src/sdk/main/include/TokenAssociateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_ASSOCIATE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_ASSOCIATE_TRANSACTION_H_

#include "AccountId.h"
#include "TokenId.h"
#include "Transaction.h"

#include <optional>
#include <vector>

namespace proto
{
class TokenAssociateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Associates the provided Hiero account with the provided Hiero token(s). Hiero accounts must be associated with a
 * fungible or non-fungible token first before you can transfer tokens to that account. When you transfer a custom
 * fungible or non-fungible token to the alias account ID, the token association step is skipped and the account will
 * automatically be associated with the token upon creation. In the case of a NON_FUNGIBLE token type, once an account
 * is associated, it can hold any number of NFTs (serial numbers) of that token type. The Hiero account that is
 * associated with a token is required to sign the transaction.
 *
 *  - If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
 *  - If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
 *  - If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
 *  - If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
 *  - If an association between the provided account and any of the tokens already exists, the transaction will resolve
 *    to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.
 *  - If the provided account's associations count exceeds the constraint of maximum token associations per account, the
 *    transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.
 *  - On success, associations between the provided account and tokens are made and the account is ready to interact
 *    with the tokens.
 *
 * There is currently no limit on the number of token IDs that can be associated with an account (reference HIP-367).
 * Still, you can see TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED responses for pre-HIP-367 transactions.
 *
 * Transaction Signing Requirements:
 *  - The key of the account to which the token is being associated
 *  - Transaction fee payer account key
 */
class TokenAssociateTransaction : public Transaction<TokenAssociateTransaction>
{
public:
  TokenAssociateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenAssociate transaction.
   */
  explicit TokenAssociateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenAssociateTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the account to be associated with the provided tokens.
   *
   * @param accountId The ID of the account to be associated.
   * @return A reference to this TokenAssociateTransaction object with the newly-set account ID.
   * @throws IllegalStateException If this TokenAssociateTransaction is frozen.
   */
  TokenAssociateTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set the IDs of the tokens to be associated with the provided account.
   *
   * @param tokenIds The IDs of the tokens to be associated.
   * @return A reference to this TokenAssociateTransaction object with the newly-set token IDs.
   * @throws IllegalStateException If this TokenAssociateTransaction is frozen.
   */
  TokenAssociateTransaction& setTokenIds(const std::vector<TokenId>& tokenIds);

  /**
   * Get the ID of the account to be associated with the provided tokens.
   *
   * @return The ID of the account to be associated with the provided tokens. Returns uninitialized if no account ID has
   *         been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getAccountId() const { return mAccountId; }

  /**
   * Get the IDs of the tokens to be associated with the provided account.
   *
   * @return The IDs of the tokens to be associated with the provided account.
   */
  [[nodiscard]] inline std::vector<TokenId> getTokenIds() const { return mTokenIds; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenAssociateTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenAssociateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenAssociateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenAssociateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenAssociateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenAssociateTransactionBody protobuf object from this TokenAssociateTransaction object.
   *
   * @return A pointer to a TokenAssociateTransactionBody protobuf object filled with this TokenAssociateTransaction
   *         object's data.
   */
  [[nodiscard]] proto::TokenAssociateTransactionBody* build() const;

  /**
   * The ID of the account to be associated with the provided tokens.
   */
  std::optional<AccountId> mAccountId;

  /**
   * The IDs of the tokens to be associated with the provided account.
   */
  std::vector<TokenId> mTokenIds;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_ASSOCIATE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenAssociation.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_ASSOCIATION_H_
#define HIERO_SDK_CPP_TOKEN_ASSOCIATION_H_

#include "AccountId.h"
#include "TokenId.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class TokenAssociation;
}

namespace Hiero
{
/**
 * A helper class that represents an account's association with a particular token.
 */
class TokenAssociation
{
public:
  /**
   * Construct a TokenAssociation object from a TokenAssociation protobuf object.
   *
   * @param proto The TokenAssociation protobuf object from which to construct a TokenAssociation object.
   * @return The constructed TokenAssociation object.
   */
  [[nodiscard]] static TokenAssociation fromProtobuf(const proto::TokenAssociation& proto);

  /**
   * Construct a TokenAssociation object from a byte array.
   *
   * @param bytes The byte array from which to construct a TokenAssociation object.
   * @return The constructed TokenAssociation object.
   */
  [[nodiscard]] static TokenAssociation fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a TokenAssociation protobuf object from this TokenAssociation object.
   *
   * @return A pointer to the created TokenAssociation protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::TokenAssociation> toProtobuf() const;

  /**
   * Construct a representative byte array from this TokenAssociation object.
   *
   * @return The byte array representing this TokenAssociation object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this TokenAssociation object.
   *
   * @return The string representation of this TokenAssociation object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this TokenAssociation to an output stream.
   *
   * @param os     The output stream.
   * @param record The TokenAssociation to print.
   * @return The output stream with this TokenAssociation written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const TokenAssociation& record);

  /**
   * The ID of the account associated with the token.
   */
  AccountId mAccountId;

  /**
   * The ID of the token associated with the account.
   */
  TokenId mTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_ASSOCIATION_H_
// Filename: src/sdk/main/include/TokenBurnTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_BURN_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_BURN_TRANSACTION_H_

#include "TokenId.h"
#include "Transaction.h"

#include <cstdint>
#include <vector>

namespace proto
{
class TokenBurnTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Burns fungible and non-fungible tokens owned by the treasury account. If no supply key is defined, this transaction
 * will resolve to TOKEN_HAS_NO_SUPPLY_KEY. The operation decreases the total supply of the token. Total supply cannot
 * go below zero. The amount provided must be in the lowest denomination possible. Example: Token A has 2 decimals. In
 * order to burn 100 tokens, one must provide an amount of 10000. In order to burn 100.55 tokens, one must provide an
 * amount of 10055. This transaction accepts zero unit token burn operations for fungible tokens (HIP-564).
 *
 * Transaction Signing Requirements:
 *  - Supply key.
 *  - Transaction fee payer account key.
 */
class TokenBurnTransaction : public Transaction<TokenBurnTransaction>
{
public:
  TokenBurnTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenBurn transaction.
   */
  explicit TokenBurnTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenBurnTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the token to burn.
   *
   * @param tokenId The ID of the token to burn.
   * @return A reference to this TokenBurnTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenBurnTransaction is frozen.
   */
  TokenBurnTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Set the amount of FUNGIBLE_COMMON tokens to burn. This should be in the lowest denomination possible.
   *
   * @param amount The amount of FUNGIBLE_COMMON tokens to burn.
   * @return A reference to this TokenBurnTransaction object with the newly-set amount.
   * @throws IllegalStateException If this TokenBurnTransaction is frozen.
   */
  TokenBurnTransaction& setAmount(uint64_t amount);

  /**
   * Set the serial numbers of NON_FUNGIBLE_UNIQUE tokens to burn.
   *
   * @param serialNumbers The serial numbers of NON_FUNGIBLE_UNIQUE tokens to burn.
   * @return A reference to this TokenBurnTransaction object with the newly-set serial numbers.
   * @throws IllegalStateException If this TokenBurnTransaction is frozen.
   */
  TokenBurnTransaction& setSerialNumbers(const std::vector<uint64_t>& serialNumbers);

  /**
   * Get the ID of the token to burn.
   *
   * @return The ID of the token to burn.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

  /**
   * Get the amount of FUNGIBLE_COMMON tokens to burn.
   *
   * @return The amount of FUNGIBLE_COMMON tokens to burn.
   */
  [[nodiscard]] inline uint64_t getAmount() const { return mAmount; }

  /**
   * Get the serial numbers of the NON_FUNGIBLE_UNIQUE tokens to burn.
   *
   * @return The serial numbers of the NON_FUNGIBLE_UNIQUE tokens to burn.
   */
  [[nodiscard]] inline std::vector<uint64_t> getSerialNumbers() const { return mSerialNumbers; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenBurnTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenBurnTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenBurnTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenBurnTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenBurnTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenBurnTransactionBody protobuf object from this TokenBurnTransaction object.
   *
   * @return A pointer to a TokenBurnTransactionBody protobuf object filled with this TokenBurnTransaction object's
   *         data.
   */
  [[nodiscard]] proto::TokenBurnTransactionBody* build() const;

  /**
   * The ID of the token to burn.
   */
  TokenId mTokenId;

  /**
   * Applicable to tokens of type FUNGIBLE_COMMON. The amount of tokens to burn from the treasury account. Amount must
   * be a positive non-zero number in the lowest denomination possible and not bigger than the token balance of the
   * treasury account.
   */
  uint64_t mAmount = 0ULL;

  /**
   * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.
   */
  std::vector<uint64_t> mSerialNumbers;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_BURN_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenCancelAirdropTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_CANCEL_AIRDROP_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_CANCEL_AIRDROP_TRANSACTION_H_

#include "PendingAirdropId.h"
#include "Transaction.h"

namespace proto
{
class TokenCancelAirdropTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Token cancel airdrop
 * Remove one or more pending airdrops from state on behalf of the sender(s)
 * for each airdrop.
 *
 * Each pending airdrop canceled SHALL be removed from state and SHALL NOT be available to claim.
 * Each cancellation SHALL be represented in the transaction body and SHALL NOT be restated
 * in the record file.
 * All cancellations MUST succeed for this transaction to succeed.
 */
class TokenCancelAirdropTransaction : public Transaction<TokenCancelAirdropTransaction>
{
public:
  TokenCancelAirdropTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenCancelAirdrop transaction.
   */
  explicit TokenCancelAirdropTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenCancelAirdropTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Get the list of pending airdrops to be claimed.
   *
   * @return A vector of Pending Airdrop Id objects.
   */
  [[nodiscard]] std::vector<PendingAirdropId> getPendingAirdrops() const { return mPendingAirdrops; };

  /**
   * Set the Pending Airdrops to be claimed
   *
   * @param pendingAirdrops The list of Pending Airdrop Id objects
   * @return A reference to this TokenClaimAirdropTransaction with the newly-set pending airdrops.
   */
  TokenCancelAirdropTransaction& setPendingAirdrops(const std::vector<PendingAirdropId>& pendingAirdrops);

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenCancelAirdropTransaction's
   * data to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenCancelAirdropTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenCancelAirdropTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenCancelAirdropTransaction protobuf representation to the
   * Transaction protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenCancelAirdropTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenCancelAirdropTransactionBody protobuf object from this TokenCancelAirdropTransaction object.
   *
   * @return A pointer to a TokenCancelAirdropTransactionBody protobuf object filled with this
   * TokenCancelAirdropTransaction object's data.
   */
  [[nodiscard]] proto::TokenCancelAirdropTransactionBody* build() const;

  /**
   * A list of one or more pending airdrop identifiers.
   * This list declares the set of pending airdrop entries that the client
   * wishes to cancel; on success all listed pending airdrop entries
   * will be removed.
   * This transaction MUST be signed by the account referenced by a `sender_id` for
   * each entry in this list.
   * This list MUST NOT have any duplicate entries.
   * This list MUST contain between 1 and 10 entries, inclusive.
   */
  std::vector<PendingAirdropId> mPendingAirdrops;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_CANCEL_AIRDROP_TRANSACTION_H_// Filename: src/sdk/main/include/TokenClaimAirdropTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_CLAIM_AIRDROP_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_CLAIM_AIRDROP_TRANSACTION_H_

#include "PendingAirdropId.h"
#include "Transaction.h"

namespace proto
{
class TokenClaimAirdropTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Token claim airdrop
 * Complete one or more pending transfers on behalf of the
 * recipient(s) for an airdrop.
 *
 * The sender MUST have sufficient balance to fulfill the airdrop at the
 * time of claim. If the sender does not have sufficient balance, the
 * claim SHALL fail.
 * Each pending airdrop successfully claimed SHALL be removed from state and
 * SHALL NOT be available to claim again.
 * Each claim SHALL be represented in the transaction body and
 * SHALL NOT be restated in the record file.
 * All claims MUST succeed for this transaction to succeed.
 *
 * ### Record Stream Effects
 * The completed transfers SHALL be present in the transfer list.
 */
class TokenClaimAirdropTransaction : public Transaction<TokenClaimAirdropTransaction>
{
public:
  TokenClaimAirdropTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenClaimAirdrop transaction.
   */
  explicit TokenClaimAirdropTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenClaimAirdropTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Get the list of pending airdrops to be claimed.
   *
   * @return A vector of Pending Airdrop Id objects.
   */
  [[nodiscard]] std::vector<PendingAirdropId> getPendingAirdrops() const { return mPendingAirdrops; };

  /**
   * Set the Pending Airdrops to be claimed
   *
   * @param pendingAirdrops The list of Pending Airdrop Id objects
   * @return A reference to this TokenClaimAirdropTransaction with the newly-set pending airdrops.
   */
  TokenClaimAirdropTransaction& setPendingAirdrops(const std::vector<PendingAirdropId>& pendingAirdrops);

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenClaimAirdropTransaction's
   * data to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenClaimAirdropTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenClaimAirdropTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenClaimAirdropTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenClaimAirdropTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenClaimAirdropTransactionBody protobuf object from this TokenClaimAirdropTransaction object.
   *
   * @return A pointer to a TokenClaimAirdropTransactionBody protobuf object filled with this
   * TokenClaimAirdropTransaction object's data.
   */
  [[nodiscard]] proto::TokenClaimAirdropTransactionBody* build() const;

  /**
   * A list of one or more pending airdrop identifiers.
   * This transaction MUST be signed by the account identified by
   * the `receiver_id` for each entry in this list.
   * This list MUST contain between 1 and 10 entries, inclusive.
   * This list MUST NOT have any duplicate entries.
   */
  std::vector<PendingAirdropId> mPendingAirdrops;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_CLAIM_AIRDROP_TRANSACTION_H_// Filename: src/sdk/main/include/TokenCreateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_CREATE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_CREATE_TRANSACTION_H_

#include "AccountId.h"
#include "CustomFee.h"
#include "Defaults.h"
#include "Key.h"
#include "TokenSupplyType.h"
#include "TokenType.h"
#include "Transaction.h"

#include <chrono>
#include <cstdint>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class TokenCreateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Create a new fungible or non-fungible token (NFT) on the Hiero network. After you submit the transaction to the
 * Hiero network, you can obtain the new token ID by requesting the receipt.
 *
 * For non-fungible tokens, the token ID represents an NFT class. Once the token is created, you will have to mint each
 * NFT using the token mint operation.
 *
 * Transaction Signing Requirements:
 *  - Treasury key is required to sign.
 *  - Admin key, if specified.
 *  - Transaction fee payer key.
 */
class TokenCreateTransaction : public Transaction<TokenCreateTransaction>
{
public:
  /**
   * Default constructor. Sets the maximum transaction fee to 40 Hbars.
   */
  TokenCreateTransaction();

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenCreation transaction.
   */
  explicit TokenCreateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenCreateTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the desired name for the new token.
   *
   * @param name The desired name for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set token name.
   */
  TokenCreateTransaction& setTokenName(std::string_view name);

  /**
   * Set the desired symbol for the new token.
   *
   * @param symbol The desired symbol for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set token symbol.
   */
  TokenCreateTransaction& setTokenSymbol(std::string_view symbol);

  /**
   * Set the desired number of decimals for the new FUNGIBLE_COMMON token. If the new token is to be of type
   * NON_FUNGIBLE_UNIQUE, this must be 0 (to which it defaults).
   *
   * @param decimals The desired number of decimals for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set number of decimals.
   */
  TokenCreateTransaction& setDecimals(uint32_t decimals);

  /**
   * Set the desired initial supply of FUNGIBLE_COMMON tokens. If the new token is to be of type NON_FUNGIBLE_UNIQUE,
   * this must be 0 (to which it defaults).
   *
   * @param amount The desired initial supply of the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set initial supply.
   */
  TokenCreateTransaction& setInitialSupply(const uint64_t& amount);

  /**
   * Set the desired ID of the treasury account, which will receive the specified initial supply of new tokens.
   *
   * @param accountId The ID of the desired treasury account for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set treasury account ID.
   */
  TokenCreateTransaction& setTreasuryAccountId(const AccountId& accountId);

  /**
   * Set the desired admin key for the new token.
   *
   * @param key The desired admin key for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set admin key.
   */
  TokenCreateTransaction& setAdminKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired KYC key for the new token.
   *
   * @param key The desired KYC key for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set KYC key.
   */
  TokenCreateTransaction& setKycKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired freeze key for the new token.
   *
   * @param key The desired freeze key for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set freeze key.
   */
  TokenCreateTransaction& setFreezeKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired wipe key for the new token.
   *
   * @param key The desired wipe key for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set wipe key.
   */
  TokenCreateTransaction& setWipeKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired supply key for the new token.
   *
   * @param key The desired supply key for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set supply key.
   */
  TokenCreateTransaction& setSupplyKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired default freeze status for the new token.
   *
   * @param freeze The desired default freeze status for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set default freeze status.
   */
  TokenCreateTransaction& setFreezeDefault(bool freeze);

  /**
   * Set the desired expiration time for the new token.
   *
   * If autoRenewPeriod is set - this value will be ignored and the expiration
   * time will be calculated based on: autoRenewPeriod + currentTime
   *
   * Setting this value will clear the autoRenewPeriod as the autoRenewPeriod period has
   * a default value of 7890000 seconds and leaving it set will override the expiration time.
   *
   * @param expiration The desired expiration time for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set default expiration time.
   */
  TokenCreateTransaction& setExpirationTime(const std::chrono::system_clock::time_point& expiration);

  /**
   * Set the ID of the desired auto-renew account for the new token.
   *
   * @param accountId The ID of the desired auto-renew account for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set auto-renew account ID.
   */
  TokenCreateTransaction& setAutoRenewAccountId(const AccountId& accountId);

  /**
   * Set the desired auto-renew period for the new token.
   *
   * If expirationTime is set - autoRenewPeriod will be effectively ignored and
   * it's effect will be replaced by expirationTime
   *
   * @param period The desired auto-renew period for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set auto-renew period.
   */
  TokenCreateTransaction& setAutoRenewPeriod(const std::chrono::system_clock::duration& period);

  /**
   * Set the desired memo for the new token.
   *
   * @param memo The desired memo for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set memo.
   */
  TokenCreateTransaction& setTokenMemo(std::string_view memo);

  /**
   * Set the desired type for the new token.
   *
   * @param type The desired type for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set token type.
   */
  TokenCreateTransaction& setTokenType(TokenType type);

  /**
   * Set the desired supply type for the new token.
   *
   * @param type The desired supply type for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set supply type.
   */
  TokenCreateTransaction& setSupplyType(TokenSupplyType type);

  /**
   * Set the desired maximum supply for the new token.
   *
   * @param max The desired maximum supply for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set maximum supply.
   */
  TokenCreateTransaction& setMaxSupply(const uint64_t& max);

  /**
   * Set the desired fee schedule key for the new token.
   *
   * @param key The desired fee schedule key for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set fee schedule key.
   */
  TokenCreateTransaction& setFeeScheduleKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired custom fees to be assessed during a TransferTransaction that transfers units of the new token.
   *
   * @param fees The desired custom fees to be assessed during a TransferTransaction that transfers units of the new
   *             token.
   * @return A reference to this TokenCreateTransaction with the newly-set fee custom fees.
   */
  TokenCreateTransaction& setCustomFees(const std::vector<std::shared_ptr<CustomFee>>& fees);

  /**
   * Set the desired pause key for the new token.
   *
   * @param key The desired pause key for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set pause key.
   */
  TokenCreateTransaction& setPauseKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired metadata for the new token.
   *
   * @param metadata The desired metadata for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set metadata.
   */
  TokenCreateTransaction& setMetadata(const std::vector<std::byte>& metadata);

  /**
   * Set the desired metadata key for the new token.
   *
   * @param key The desired metadata key for the new token.
   * @return A reference to this TokenCreateTransaction with the newly-set metadata key.
   */
  TokenCreateTransaction& setMetadataKey(const std::shared_ptr<Key>& metadataKey);

  /**
   * Get the desired name for the new token.
   *
   * @return The desired name for the new token.
   */
  [[nodiscard]] inline std::string getTokenName() const { return mTokenName; }

  /**
   * Get the desired symbol for the new token.
   *
   * @return The desired symbol for the new token.
   */
  [[nodiscard]] inline std::string getTokenSymbol() const { return mTokenSymbol; }

  /**
   * Get the desired number of decimals for the new token.
   *
   * @return The desired number of decimals for the new token.
   */
  [[nodiscard]] inline uint32_t getDecimals() const { return mDecimals; }

  /**
   * Get the desired initial supply of new tokens.
   *
   * @return The desired initial supply of FUNGIBLE_COMMON new tokens.
   */
  [[nodiscard]] inline uint64_t getInitialSupply() const { return mInitialSupply; }

  /**
   * Get the ID of the desired treasury account for the supply of new tokens.
   *
   * @return The ID of the desired treasury account for the supply of new tokens. Returns uninitialized if no treasury
   *         account has been set yet.
   */
  [[nodiscard]] inline std::optional<AccountId> getTreasuryAccountId() const { return mTreasuryAccountId; }

  /**
   * Get the desired admin key for the new token.
   *
   * @return The desired admin key for the new token.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getAdminKey() const { return mAdminKey; }

  /**
   * Get the desired KYC key for the new token.
   *
   * @return The desired KYC key for the new token.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getKycKey() const { return mKycKey; }

  /**
   * Get the desired freeze key for the new token.
   *
   * @return The desired freeze key for the new token.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getFreezeKey() const { return mFreezeKey; }

  /**
   * Get the desired wipe key for the new token.
   *
   * @return The desired wipe key for the new token.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getWipeKey() const { return mWipeKey; }

  /**
   * Get the desired supply key for the new token.
   *
   * @return The desired supply key for the new token.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getSupplyKey() const { return mSupplyKey; }

  /**
   * Get the desired default freeze status for the new token.
   *
   * @return The desired default freeze status for the new token.
   */
  [[nodiscard]] inline bool getFreezeDefault() const { return mFreezeDefault; }

  /**
   * Get the desired expiration time for the new token.
   *
   * @return The desired expiration time for the new token.
   */
  [[nodiscard]] inline std::chrono::system_clock::time_point getExpirationTime() const { return mExpirationTime; }

  /**
   * Get the ID of the desired auto-renew account for the new token.
   *
   * @return The ID of the desired auto-renew account for the new token. Returns uninitialized if no auto-renew account
   *         ID has been set yet.
   */
  [[nodiscard]] inline std::optional<AccountId> getAutoRenewAccountId() const { return mAutoRenewAccountId; }

  /**
   * Get the desired auto-renew period for the new token.
   *
   * @return The desired auto-renew period for the new token.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getAutoRenewPeriod() const { return mAutoRenewPeriod; }

  /**
   * Get the desired memo for the new token.
   *
   * @return The desired memo for the new token.
   */
  [[nodiscard]] inline std::string getTokenMemo() const { return mTokenMemo; }

  /**
   * Get the desired type for the new token.
   *
   * @return The desired type for the new token.
   */
  [[nodiscard]] inline TokenType getTokenType() const { return mTokenType; }

  /**
   * Get the desired token supply type for the new token.
   *
   * @return The desired token supply type for the new token.
   */
  [[nodiscard]] inline TokenSupplyType getSupplyType() const { return mSupplyType; }

  /**
   * Get the desired maximum supply for the new token.
   *
   * @return The desired maximum supply for the new token.
   */
  [[nodiscard]] inline uint64_t getMaxSupply() const { return mMaxSupply; }

  /**
   * Get the desired fee schedule key for the new token.
   *
   * @return The desired fee schedule key for the new token.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getFeeScheduleKey() const { return mFeeScheduleKey; }

  /**
   * Get the desired custom fees to be assessed during a TransferTransaction that transfers units of the new token.
   *
   * @return The desired custom fees to be assessed during a TransferTransaction that transfers units of the new token.
   */
  [[nodiscard]] inline std::vector<std::shared_ptr<CustomFee>> getCustomFees() const { return mCustomFees; }

  /**
   * Get the desired pause key for the new token.
   *
   * @return The desired pause key for the new token.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getPauseKey() const { return mPauseKey; }

  /**
   * Get the desired metadata for the new token.
   *
   * @return The desired metadata for the new token.
   */
  [[nodiscard]] inline std::vector<std::byte> getMetadata() const { return mMetadata; }

  /**
   * Get the desired metadata key for the new token.
   *
   * @return The desired metadata key for the new token.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getMetadataKey() const { return mMetadataKey; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenCreateTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenCreateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenCreateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenCreateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenCreateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenCreateTransactionBody protobuf object from this TokenCreateTransaction object.
   *
   * @return A pointer to a TokenCreateTransactionBody protobuf object filled with this TokenCreateTransaction object's
   *         data.
   */
  [[nodiscard]] proto::TokenCreateTransactionBody* build() const;

  /**
   * The publicly visible name of the token. The token name is specified as a string of UTF-8 characters in Unicode.
   * UTF-8 encoding of this Unicode cannot contain the 0 byte (NUL). The token name is not unique. Maximum of 100
   * characters.
   */
  std::string mTokenName;

  /**
   * The publicly visible token symbol. The token symbol is specified as a string of UTF-8 characters in Unicode. UTF-8
   * encoding of this Unicode cannot contain the 0 byte (NUL). The token symbol is not unique. Maximum of 100
   * characters.
   */
  std::string mTokenSymbol;

  /**
   * For tokens of type FUNGIBLE_COMMON, the number of decimal places by which a token is divisible. This field can
   * never be changed. For tokens of type NON_FUNGIBLE_UNIQUE, this must be 0.
   */
  uint32_t mDecimals = 0U;

  /**
   * The initial supply of FUNGIBLE_COMMON tokens to be put in circulation. The initial supply is sent to the
   * Treasury Account. The supply is in the lowest denomination possible. For tokens of type NON_FUNGIBLE_UNIQUE, this
   * must be 0.
   */
  uint64_t mInitialSupply = 0ULL;

  /**
   * The account which will act as a treasury for the token. This account will receive the specified initial supply or
   * the newly minted NFTs in the case for NON_FUNGIBLE_UNIQUE type.
   */
  std::optional<AccountId> mTreasuryAccountId;

  /**
   * The Key which can perform update/delete operations on the token. If nullptr, the token can be perceived as
   * immutable (not being able to be updated/deleted).
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The Key which can grant or revoke KYC of an account for the token's transactions. If nullptr, KYC is not required,
   * and KYC grant or revoke operations are not possible.
   */
  std::shared_ptr<Key> mKycKey = nullptr;

  /**
   * The Key which can sign to freeze or unfreeze an account for token transactions. If nullptr, freezing is not
   * possible.
   */
  std::shared_ptr<Key> mFreezeKey = nullptr;

  /**
   * The Key which can wipe the token balance of an account. If nullptr, wipe is not possible.
   */
  std::shared_ptr<Key> mWipeKey = nullptr;

  /**
   * The Key which can change the supply of a token. The Key is used to sign token mint and burn operations.
   */
  std::shared_ptr<Key> mSupplyKey = nullptr;

  /**
   * The default Freeze status (frozen or unfrozen) of Hiero accounts relative to this token. If true, an account must
   * be unfrozen before it can receive the token.
   */
  bool mFreezeDefault = false;

  /**
   * The epoch second at which the token should expire. If mAutoRenewAccountId and mAutoRenewPeriod are specified, this
   * is coerced to the current epoch second plus the mAutoRenewPeriod.
   */
  std::chrono::system_clock::time_point mExpirationTime = std::chrono::system_clock::now() + DEFAULT_AUTO_RENEW_PERIOD;

  /**
   * The ID of the account which will be automatically charged to renew the token's expiration, at the interval
   * specified in mAutoRenewPeriod.
   */
  std::optional<AccountId> mAutoRenewAccountId;

  /**
   * The interval at which the auto-renew account will be charged to extend the token's expiry.
   */
  std::chrono::system_clock::duration mAutoRenewPeriod = DEFAULT_AUTO_RENEW_PERIOD;

  /**
   * The memo associated with the token (UTF-8 encoding max 100 bytes).
   */
  std::string mTokenMemo;

  /**
   * IWA compatibility. Specifies the token type.
   */
  TokenType mTokenType = TokenType::FUNGIBLE_COMMON;

  /**
   * IWA compatibility. Specifies the token supply type.
   */
  TokenSupplyType mSupplyType = TokenSupplyType::INFINITE;

  /**
   * IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the maximum number of tokens
   * that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial numbers)
   * that can be minted. This field can never be changed.
   */
  uint64_t mMaxSupply = 0ULL;

  /**
   * The Key which can change the token's custom fee schedule. This Key must sign a TokenFeeScheduleUpdate transaction.
   */
  std::shared_ptr<Key> mFeeScheduleKey = nullptr;

  /**
   * The custom fees to be assessed during a TransferTransaction that transfers units of the new token.
   */
  std::vector<std::shared_ptr<CustomFee>> mCustomFees;

  /**
   * The Key which can pause and unpause the new token. If nullptr, the token pause status defaults to
   * PauseNotApplicable, otherwise Unpaused.
   */
  std::shared_ptr<Key> mPauseKey = nullptr;

  /**
   * Metadata of the created token definition.
   */
  std::vector<std::byte> mMetadata;

  /**
   * The key which can change the metadata of a token (token definition, partition definition, and individual NFTs).
   */
  std::shared_ptr<Key> mMetadataKey = nullptr;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_CREATE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenDeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_DELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_DELETE_TRANSACTION_H_

#include "TokenId.h"
#include "Transaction.h"

#include <optional>

namespace proto
{
class TokenDeleteTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Deleting a token marks a token as deleted, though it will remain in the ledger. The operation must be signed by the
 * specified admin key of the token. If the admin key is not set, the transaction will result in TOKEN_IS_IMMUTABlE.
 * Once deleted, update, mint, burn, wipe, freeze, unfreeze, grant KYC, revoke KYC and token transfer transactions will
 * resolve to TOKEN_WAS_DELETED.
 *
 * For NFTs, you cannot delete a specific NFT. You can delete the class of the NFT specified by the token ID after you
 * have burned all associated NFTs associated with the token class
 *
 * Transaction Signing Requirements:
 *  - Admin key
 *  - Transaction fee payer account key
 */
class TokenDeleteTransaction : public Transaction<TokenDeleteTransaction>
{
public:
  TokenDeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenDelete transaction.
   */
  explicit TokenDeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenDeleteTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the token to delete.
   *
   * @param tokenId The ID of the token to delete.
   * @return A reference to this TokenDeleteTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenDeleteTransaction is frozen.
   */
  TokenDeleteTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Get the ID of the token this TokenDeleteTransaction is currently configured to delete.
   *
   * @return The ID of the account this TokenDeleteTransaction is currently configured to delete. Uninitialized if no
   *         token ID has been set.
   */
  [[nodiscard]] inline std::optional<TokenId> getTokenId() const { return mTokenId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenDeleteTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenDeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenDeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenDeleteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenDeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenDeleteTransactionBody protobuf object from this TokenDeleteTransaction object.
   *
   * @return A pointer to a TokenDeleteTransactionBody protobuf object filled with this TokenDeleteTransaction
   *         object's data.
   */
  [[nodiscard]] proto::TokenDeleteTransactionBody* build() const;

  /**
   * The ID of the token to delete.
   */
  std::optional<TokenId> mTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_DELETE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenDissociateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_DISSOCIATE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_DISSOCIATE_TRANSACTION_H_

#include "AccountId.h"
#include "TokenId.h"
#include "Transaction.h"

#include <optional>
#include <vector>

namespace proto
{
class TokenDissociateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Disassociates the provided Hiero account from the provided Hiero tokens. This transaction must be signed by the
 * provided account's key. Once the association is removed, no token related operation can be performed to that account.
 * AccountBalanceQuery and AccountInfoQuery will not return anything related to the token that was disassociated.
 *
 *  - If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
 *  - If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
 *  - If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
 *  - If an association between the provided account and any of the tokens does not exist, the transaction will resolve
 *    to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
 *  - If the provided account has a nonzero balance with any of the provided tokens, the transaction will resolve to
 *    TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.
 *
 * On success, associations between the provided account and tokens are removed. The account is required to have a zero
 * balance of the token you wish to disassociate. If a token balance is present, you will receive a
 * TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES error.
 *
 * Transaction Signing Requirements:
 *  - The key of the account from which the token is being dissociated.
 *  - Transaction fee payer account key.
 */
class TokenDissociateTransaction : public Transaction<TokenDissociateTransaction>
{
public:
  TokenDissociateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenDissociate transaction.
   */
  explicit TokenDissociateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenDissociateTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the account to be dissociated from the provided tokens.
   *
   * @param accountId The ID of the account to be dissociated from the provided tokens.
   * @return A reference to this TokenDissociateTransaction object with the newly-set account ID.
   * @throws IllegalStateException If this TokenDissociateTransaction is frozen.
   */
  TokenDissociateTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set the IDs of the tokens to be dissociated from the provided account.
   *
   * @param tokenIds The IDs of the tokens to be dissociated from the provided account.
   * @return A reference to this TokenDissociateTransaction object with the newly-set token IDs.
   * @throws IllegalStateException If this TokenDissociateTransaction is frozen.
   */
  TokenDissociateTransaction& setTokenIds(const std::vector<TokenId>& tokenIds);

  /**
   * Get the ID of the account to be dissociated from the provided tokens.
   *
   * @return The ID of the account to be dissociated from the provided tokens. Returns uninitialized if no account ID
   *         has been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getAccountId() const { return mAccountId; }

  /**
   * Get the IDs of the tokens to be dissociated from the provided account.
   *
   * @return The IDs of the tokens to be dissociated from the provided account.
   */
  [[nodiscard]] inline std::vector<TokenId> getTokenIds() const { return mTokenIds; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenDissociateTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenDissociateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenDissociateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenDissociateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenDissociateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenDissociateTransactionBody protobuf object from this TokenDissociateTransaction object.
   *
   * @return A pointer to a TokenDissociateTransactionBody protobuf object filled with this TokenDissociateTransaction
   *         object's data.
   */
  [[nodiscard]] proto::TokenDissociateTransactionBody* build() const;

  /**
   * The ID of the account to be dissociated from the provided tokens.
   */
  std::optional<AccountId> mAccountId;

  /**
   * The IDs of the tokens to be dissociated from the provided account.
   */
  std::vector<TokenId> mTokenIds;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_DISSOCIATE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenFeeScheduleUpdateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_FEE_SCHEDULE_UPDATE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_FEE_SCHEDULE_UPDATE_TRANSACTION_H_

#include "CustomFee.h"
#include "TokenId.h"
#include "Transaction.h"

#include <memory>
#include <vector>

namespace proto
{
class TokenFeeScheduleUpdateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Update the custom fees for a given token. If the token does not have a fee schedule, the network response returned
 * will be CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES. You will need to sign the transaction with the fee schedule key to
 * update the fee schedule for the token. If you do not have a fee schedule key set for the token, you will not be able
 * to update the fee schedule.
 *
 * Transaction Signing Requirements:
 *  - Fee schedule key.
 *  - Transaction fee payer account key.
 */
class TokenFeeScheduleUpdateTransaction : public Transaction<TokenFeeScheduleUpdateTransaction>
{
public:
  TokenFeeScheduleUpdateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenFeeScheduleUpdate transaction.
   */
  explicit TokenFeeScheduleUpdateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenFeeScheduleUpdateTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the token whose fee schedule is to be updated.
   *
   * @param tokenId The ID of the token whose fee schedule is to be updated.
   * @return A reference to this TokenFeeScheduleUpdateTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenFeeScheduleUpdateTransaction is frozen.
   */
  TokenFeeScheduleUpdateTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Set the new custom fees to be assessed during transfers of the token.
   *
   * @param fees The new custom fees to be assessed during transfers of the token.
   * @return A reference to this TokenFeeScheduleUpdateTransaction object with the newly-set fees.
   * @throws IllegalStateException If this TokenFeeScheduleUpdateTransaction is frozen.
   */
  TokenFeeScheduleUpdateTransaction& setCustomFees(const std::vector<std::shared_ptr<CustomFee>>& fees);

  /**
   * Get the ID of the token whose fee schedule is to be updated.
   *
   * @return The ID of the token whose fee schedule is to be updated.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

  /**
   * Get the new custom fees to be assessed during transfers of the token.
   *
   * @return The new custom fees to be assessed during transfers of the token.
   */
  [[nodiscard]] inline std::vector<std::shared_ptr<CustomFee>> getCustomFees() const { return mCustomFees; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this
   * TokenFeeScheduleUpdateTransaction's data to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenFeeScheduleUpdateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenFeeScheduleUpdateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenFeeScheduleUpdateTransaction protobuf representation to the
   * Transaction protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenFeeScheduleUpdateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenFeeScheduleUpdateTransactionBody protobuf object from this TokenFeeScheduleUpdateTransaction object.
   *
   * @return A pointer to a TokenFeeScheduleUpdateTransactionBody protobuf object filled with this
   * TokenFeeScheduleUpdateTransaction object's data.
   */
  [[nodiscard]] proto::TokenFeeScheduleUpdateTransactionBody* build() const;

  /**
   * The ID of the token whose fee schedule is to be updated.
   */
  TokenId mTokenId;

  /**
   * The new custom fees to be assessed during transfers of the token.
   */
  std::vector<std::shared_ptr<CustomFee>> mCustomFees;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_FEE_SCHEDULE_UPDATE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenFreezeTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_FREEZE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_FREEZE_TRANSACTION_H_

#include "AccountId.h"
#include "TokenId.h"
#include "Transaction.h"

namespace proto
{
class TokenFreezeAccountTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Freezes transfers of the specified token for the account. The transaction must be signed by the token's freeze key.
 *
 *  - If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
 *  - If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
 *  - If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
 *  - If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
 *  - If an Association between the provided token and account is not found, the transaction will resolve to
 *    TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
 *  - If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
 *
 * Once executed the Account is marked as Frozen and will not be able to receive or send tokens unless unfrozen. The
 * operation is idempotent.
 *
 * Transaction Signing Requirements:
 *  - Freeze key.
 *  - Transaction fee payer account key.
 */
class TokenFreezeTransaction : public Transaction<TokenFreezeTransaction>
{
public:
  TokenFreezeTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenFreeze transaction.
   */
  explicit TokenFreezeTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenFreezeTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the account to be frozen for the specified token.
   *
   * @param accountId The ID of the account to be frozen for the specified token.
   * @return A reference to this TokenFreezeTransaction object with the newly-set account ID.
   * @throws IllegalStateException If this TokenFreezeTransaction is frozen.
   */
  TokenFreezeTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set the ID of the token to be frozen for the specified account.
   *
   * @param tokenId The ID of the token to be frozen for the specified account.
   * @return A reference to this TokenFreezeTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenFreezeTransaction is frozen.
   */
  TokenFreezeTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Get the ID of the account to be frozen for the specified token.
   *
   * @return The ID of the account to be frozen for the specified token.
   */
  [[nodiscard]] inline AccountId getAccountId() const { return mAccountId; }

  /**
   * Get the ID of the token to be frozen for the specified account.
   *
   * @return The ID of the token to be frozen for the specified account.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenFreezeTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenFreezeTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenFreezeTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenFreezeTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenFreezeTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenFreezeAccountTransactionBody protobuf object from this TokenFreezeTransaction object.
   *
   * @return A pointer to a TokenFreezeAccountTransactionBody protobuf object filled with this TokenFreezeTransaction
   *         object's data.
   */
  [[nodiscard]] proto::TokenFreezeAccountTransactionBody* build() const;

  /**
   * The ID of the account to be frozen for the specified token.
   */
  AccountId mAccountId;

  /**
   * The ID of the token to be frozen for the specified account.
   */
  TokenId mTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_FREEZE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenGrantKycTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_GRANT_KYC_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_GRANT_KYC_TRANSACTION_H_

#include "AccountId.h"
#include "TokenId.h"
#include "Transaction.h"

#include <optional>
#include <vector>

namespace proto
{
class TokenGrantKycTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Grants KYC to the Hiero accounts for the given Hiero token. This transaction must be signed by the token's KYC Key.
 *
 *  - If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
 *  - If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
 *  - If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
 *  - If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
 *  - If an association between the provided token and account is not found, the transaction will resolve to
 *    TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
 *  - If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
 *
 * Once executed the Account is marked as KYC Granted.
 *
 * Transaction Signing Requirements:
 *  - KYC key.
 *  - Transaction fee payer account key.
 */
class TokenGrantKycTransaction : public Transaction<TokenGrantKycTransaction>
{
public:
  TokenGrantKycTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenGrantKyc transaction.
   */
  explicit TokenGrantKycTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenGrantKycTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the account to have passed KYC for this token.
   *
   * @param accountId The ID of the account to have passed KYC for this token.
   * @return A reference to this TokenGrantKycTransaction object with the newly-set account ID.
   * @throws IllegalStateException If this TokenGrantKycTransaction is frozen.
   */
  TokenGrantKycTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set the ID of the token for which the account has passed KYC.
   *
   * @param tokenId The ID of the token for which the account has passed KYC.
   * @return A reference to this TokenGrantKycTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenGrantKycTransaction is frozen.
   */
  TokenGrantKycTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Get the ID of the account to have passed KYC for this token.
   *
   * @return The ID of the account to have passed KYC for this token.
   */
  [[nodiscard]] inline AccountId getAccountId() const { return mAccountId; }

  /**
   * Get the ID of the token for which the account has passed KYC.
   *
   * @return The ID of the token for which the account has passed KYC.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenGrantKycTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenGrantKycTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenGrantKycTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenGrantKycTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenGrantKycTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenGrantKycTransactionBody protobuf object from this TokenGrantKycTransaction object.
   *
   * @return A pointer to a TokenGrantKycTransactionBody protobuf object filled with this TokenGrantKycTransaction
   *         object's data.
   */
  [[nodiscard]] proto::TokenGrantKycTransactionBody* build() const;

  /**
   * The ID of the account to have passed KYC for this token.
   */
  AccountId mAccountId;

  /**
   * The ID of the token for which the account has passed KYC.
   */
  TokenId mTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_GRANT_KYC_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_ID_H_
#define HIERO_SDK_CPP_TOKEN_ID_H_

#include <cstddef>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class TokenID;
}

namespace Hiero
{
class Client;
class NftId;
}

namespace Hiero
{
/**
 * The ID for a token on Hiero.
 */
class TokenId
{
public:
  TokenId() = default;

  /**
   * Construct with a token number.
   *
   * @param num The token number.
   */
  explicit TokenId(uint64_t num);

  /**
   * Construct with a shard, realm, a token number, and optionally a checksum.
   *
   * @param shard    The shard number.
   * @param realm    The realm number.
   * @param num      The token number.
   * @param checksum The checksum.
   */
  explicit TokenId(uint64_t shard, uint64_t realm, uint64_t num, std::string_view checksum = "");

  /**
   * Compare this TokenId to another TokenId and determine if they represent the same token.
   *
   * @param other The other TokenId with which to compare this TokenId.
   * @return \c TRUE if this TokenId is the same as the input TokenId, otherwise \c FALSE.
   */
  bool operator==(const TokenId& other) const;

  /**
   * Construct a TokenId object from a string of the form "<shard>.<realm>.<num>".
   *
   * @param id The token ID string from which to construct.
   * @return The constructed TokenId object.
   * @throws std::invalid_argument If the input string is malformed.
   */
  [[nodiscard]] static TokenId fromString(std::string_view id);

  /**
   * Construct a TokenId from a Solidity address.
   *
   * @param address The Solidity address from which to create a TokenId, as a string.
   * @return The constructed TokenId object.
   * @throws std::invalid_argument If a Solidity address cannot be realized from the input string.
   */
  [[nodiscard]] static TokenId fromSolidityAddress(std::string_view address);

  /**
   * Construct a TokenId from a TokenId protobuf object.
   *
   * @param proto The TokenId protobuf object from which to create a TokenId object.
   * @return The constructed TokenId object.
   */
  [[nodiscard]] static TokenId fromProtobuf(const proto::TokenID& proto);

  /**
   * Construct a TokenId object from a representative byte array.
   *
   * @param bytes The byte array from which to construct a TokenId object.
   * @return The constructed TokenId object.
   */
  [[nodiscard]] static TokenId fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Verify the checksum of this TokenId using the input Client's network.
   *
   * @param client The Client with which to validate this TokenId's checksum.
   * @throws BadEntityException If the checksum of this TokenId is invalid.
   */
  void validateChecksum(const Client& client) const;

  /**
   * Construct an NftId from this TokenId and a serial number.
   *
   * @param serial The serial number of the NftId.
   * @param The constructed NftId.
   */
  [[nodiscard]] NftId nft(uint64_t serial) const;

  /**
   * Construct a TokenID protobuf object from this TokenId object.
   *
   * @return A pointer to the created TokenId protobuf object filled with this TokenId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::TokenID> toProtobuf() const;

  /**
   * Get the string representation of this TokenId object.
   *
   * @return The string representation of this TokenId.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Get the string representation of this TokenId object with the checksum.
   *
   * @param client The Client with which to generate the checksum.
   * @return The string representation of this TokenId object with the checksum.
   */
  [[nodiscard]] std::string toStringWithChecksum([[maybe_unused]] const Client& client) const;

  /**
   * Get a byte array representation of this TokenId object.
   *
   * @return A byte array representation of this TokenId object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Get the checksum of this ContractId.
   *
   * @return The checksum of this ContractId.
   */
  [[nodiscard]] inline std::string getChecksum() const { return mChecksum; }

  /**
   * The shard number.
   */
  uint64_t mShardNum = 0ULL;

  /**
   * The realm number.
   */
  uint64_t mRealmNum = 0ULL;

  /**
   * The token number.
   */
  uint64_t mTokenNum = 0ULL;

private:
  /**
   * The checksum of this TokenIds.
   */
  mutable std::string mChecksum;
};

} // namespace Hiero

namespace std
{
template<>
struct hash<Hiero::TokenId>
{
  /**
   * Operator override to enable use of TokenId as map key
   */
  size_t operator()(const Hiero::TokenId& id) const { return hash<string>()(id.toString()); }
};

} // namespace std

#endif // HIERO_SDK_CPP_TOKEN_ID_H_
// Filename: src/sdk/main/include/TokenInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_INFO_H_
#define HIERO_SDK_CPP_TOKEN_INFO_H_

#include "AccountId.h"
#include "CustomFee.h"
#include "Key.h"
#include "LedgerId.h"
#include "TokenId.h"
#include "TokenSupplyType.h"
#include "TokenType.h"

#include <chrono>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <optional>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class TokenInfo;
}

namespace Hiero
{
/**
 * Response from a Hiero network when the client sends an TokenInfoQuery.
 */
class TokenInfo
{
public:
  /**
   * Construct a TokenInfo object from a TokenInfo protobuf object.
   *
   * @param proto The TokenInfo protobuf object from which to construct a TokenInfo object.
   * @return The constructed TokenInfo object.
   */
  [[nodiscard]] static TokenInfo fromProtobuf(const proto::TokenInfo& proto);

  /**
   * Construct a TokenInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a TokenInfo object.
   * @return The constructed TokenInfo object.
   */
  [[nodiscard]] static TokenInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a TokenInfo protobuf object from this TokenInfo object.
   *
   * @return A pointer to the created TokenInfo protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::TokenInfo> toProtobuf() const;

  /**
   * Construct a representative byte array from this TokenInfo object.
   *
   * @return The byte array representing this TokenInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this TokenInfo object.
   *
   * @return The string representation of this TokenInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this TokenInfo to an output stream.
   *
   * @param os   The output stream.
   * @param info The TokenInfo to print.
   * @return The output stream with this TokenInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const TokenInfo& info);

  /**
   * The ID of the token.
   */
  TokenId mTokenId;

  /**
   * The name of the token. It is a string of ASCII only characters.
   */
  std::string mTokenName;

  /**
   * The symbol of the token. It is a UTF-8 capitalized alphabetical string.
   */
  std::string mTokenSymbol;

  /**
   * The number of decimal places by which a token is divisible. Always 0 for NON_FUNGIBLE_UNIQUE tokens.
   */
  uint32_t mDecimals = 0U;

  /**
   * For FUNGIBLE_COMMON tokens - the total supply of tokens that are currently in circulation. For NON_FUNGIBLE_UNIQUE
   * tokens - the number of NFTs created of this token instance.
   */
  uint64_t mTotalSupply = 0ULL;

  /**
   * The ID of the treasury account for the token.
   */
  AccountId mTreasuryAccountId;

  /**
   * The key which can perform update/delete operations on the token. If nullptr, the token can be perceived as
   * immutable (not being able to be updated/deleted).
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The key which can grant or revoke KYC of an account for the token's transactions. If nullptr, KYC is not required,
   * and KYC grant or revoke operations are not possible.
   */
  std::shared_ptr<Key> mKycKey = nullptr;

  /**
   * The key which can  freeze or unfreeze an account for token transactions. If nullptr, freezing is not possible.
   */
  std::shared_ptr<Key> mFreezeKey = nullptr;

  /**
   * The key which can wipe the token balance of an account. If nullptr, wipe is not possible.
   */
  std::shared_ptr<Key> mWipeKey = nullptr;

  /**
   * The key which can change the supply of a token. The key is used to sign token mint and burn operations.
   */
  std::shared_ptr<Key> mSupplyKey = nullptr;

  /**
   * The default freeze status (FreezeNotApplicable, Frozen, or Unfrozen) of Hiero accounts relative to this token.
   * Uninitialized if mFreezeKey is empty, \c TRUE if mFreezeKey is set and mDefaultFreeze is set to true, or \c FALSE
   * if mFreezeKey is set and mDefaultFreeze is set to false.
   */
  std::optional<bool> mDefaultFreezeStatus;

  /**
   * The default KYC status (KycNotApplicable or Revoked) of Hiero accounts relative to this token. KycNotApplicable if
   * mKycKey is not set, otherwise \c FALSE (no way to have the default KYC status be Granted (or \c TRUE)).
   */
  std::optional<bool> mDefaultKycStatus;

  /**
   * Specifies whether the token was deleted or not.
   */
  bool mIsDeleted = false;

  /**
   * The ID of the account which will be automatically charged to renew the token's expiration, at the interval
   * specified in mAutoRenewPeriod.
   */
  AccountId mAutoRenewAccountId;

  /**
   * The interval at which the auto-renew account will be charged to extend the token's expiry.
   */
  std::chrono::system_clock::duration mAutoRenewPeriod;

  /**
   * The epoch second at which the token should expire.
   */
  std::chrono::system_clock::time_point mExpirationTime;

  /**
   * The memo associated with the token (UTF-8 encoding max 100 bytes).
   */
  std::string mTokenMemo;

  /**
   * The token type.
   */
  TokenType mTokenType = TokenType::FUNGIBLE_COMMON;

  /**
   * The token supply type.
   */
  TokenSupplyType mSupplyType = TokenSupplyType::INFINITE;

  /**
   * For FUNGIBLE_COMMON tokens - the maximum number of fungible tokens that can be in circulation. For
   * NON_FUNGIBLE_UNIQUE tokens - the maximum number of NFTs (serial numbers) that can be in circulation.
   */
  uint64_t mMaxSupply = 0ULL;

  /**
   * The key which can change the token's custom fee schedule. If nullptr, the fee schedule is immutable.
   */
  std::shared_ptr<Key> mFeeScheduleKey = nullptr;

  /**
   * The custom fees to be assessed during a TransferTransaction that transfers units of the token.
   */
  std::vector<std::shared_ptr<CustomFee>> mCustomFees;

  /**
   * The key which can pause and unpause the new token. If nullptr, the token cannot be paused.
   */
  std::shared_ptr<Key> mPauseKey = nullptr;

  /**
   * Specifies whether the token is paused or not. Uninitialized if mPauseKey is not set, \c TRUE if mPauseKey is set
   * and the token is paused, or \c FALSE if mPauseKey is set and the token is not paused.
   */
  std::optional<bool> mPauseStatus;

  /**
   * The ID of the ledger from which this response was returned.
   */
  LedgerId mLedgerId;

  /**
   * Represents the metadata of the token definition.
   */
  std::vector<std::byte> mMetadata;

  /**
   * The key which can change the metadata of a token (token definition and individual NFTs).
   */
  std::shared_ptr<Key> mMetadataKey = nullptr;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_INFO_H_
// Filename: src/sdk/main/include/TokenInfoQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_INFO_QUERY_H_
#define HIERO_SDK_CPP_TOKEN_INFO_QUERY_H_

#include "Query.h"
#include "TokenId.h"

namespace Hiero
{
class TokenInfo;
class TransactionRecord;
}

namespace Hiero
{
/**
 * A query that gets information about a fungible or non-fungible token instance.
 */
class TokenInfoQuery : public Query<TokenInfoQuery, TokenInfo>
{
public:
  /**
   * Set the ID of the token of which to request the info.
   *
   * @param token The ID of the token of which to request the info.
   * @return A reference to this TokenInfoQuery object with the newly-set token ID.
   */
  TokenInfoQuery& setTokenId(const TokenId& tokenId);

  /**
   * Get the ID of the token of which this query is currently configured to get the info.
   *
   * @return The ID of the token for which this query is meant.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

private:
  /**
   * Derived from Executable. Construct a TokenInfo object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a TokenInfo object.
   * @return A TokenInfo object filled with the Response protobuf object's data
   */
  [[nodiscard]] TokenInfo mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this TokenInfoQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this TokenInfoQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenInfoQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this TokenInfoQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the token of which this query should get the info.
   */
  TokenId mTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_INFO_QUERY_H_
// Filename: src/sdk/main/include/TokenKeyValidation.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_KEY_VALIDATION_TYPE_H_
#define HIERO_SDK_CPP_TOKEN_KEY_VALIDATION_TYPE_H_

#include <string_view>
#include <unordered_map>

namespace proto
{
enum TokenKeyValidation : int;
}

namespace Hiero
{
/**
 * Types of validation strategies for token keys.
 */
enum class TokenKeyValidation
{
  /**
   * Currently the default behaviour. It will perform all token key validations.
   */
  FULL_VALIDATION,

  /**
   * Perform no validations at all for all passed token keys.
   */
  NO_VALIDATION
};

/**
 * Map of protobuf TokenKeyValidation to the corresponding TokenKeyValidation.
 */
extern const std::unordered_map<proto::TokenKeyValidation, TokenKeyValidation>
  gProtobufTokenKeyValidationToTokenKeyValidation;

/**
 * Map of TokenKeyValidation to the corresponding protobuf TokenKeyValidation.
 */
extern const std::unordered_map<TokenKeyValidation, proto::TokenKeyValidation>
  gTokenKeyValidationToProtobufTokenKeyValidation;

/**
 * Map of TokenKeyValidation to its corresponding string.
 */
[[maybe_unused]] extern const std::unordered_map<TokenKeyValidation, const char*> gTokenKeyValidationToString;

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_KEY_VALIDATION_TYPE_H_
// Filename: src/sdk/main/include/TokenMintTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_MINT_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_MINT_TRANSACTION_H_

#include "TokenId.h"
#include "Transaction.h"

#include <cstddef>
#include <cstdint>
#include <vector>

namespace proto
{
class TokenMintTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Minting fungible token allows you to increase the total supply of the token. Minting a non-fungible token creates an
 * NFT with its unique metadata for the class of NFTs defined by the token ID. The Supply Key must sign the transaction.
 *
 * If no Supply Key is defined, the transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY. The maximum total supply a
 * token can have is 2^63-1.
 *
 * The amount provided must be in the lowest denomination possible.
 *  - Example: Token A has 2 decimals. In order to mint 100 tokens, one must provide an amount of 10000. In order to
 *             mint 100.55 tokens, one must provide an amount of 10055.
 *
 * The metadata field is specific to NFTs. Once an NFT is minted, the metadata cannot be changed and is immutable.
 *  - You can use the metadata field to add a URI that contains additional information about the token. The metadata
 *    field has a 100-character limit.
 *
 * The serial number for the NFT is returned in the receipt of the transaction.
 *
 * When minting NFTs, do not set the amount. The amount is used for minting fungible tokens only.
 *
 * This transaction accepts zero unit minting operations for fungible tokens (HIP-564)
 *
 * Transaction Signing Requirements:
 *  - Supply key
 *  - Transaction fee payer account key
 */
class TokenMintTransaction : public Transaction<TokenMintTransaction>
{
public:
  TokenMintTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenMint transaction.
   */
  explicit TokenMintTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenMintTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the token to mint.
   *
   * @param tokenId The ID of the token to mint.
   * @return A reference to this TokenMintTransaction with the newly-set token ID.
   */
  TokenMintTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Set the amount of the FUNGIBLE_COMMON token to mint, in the lowest denomination.
   *
   * @param amount The amount of token to mint, in the lowest denomination.
   * @return A reference to this TokenMintTransaction with the newly-set amount.
   */
  TokenMintTransaction& setAmount(const uint64_t& amount);

  /**
   * Set the metadata for the NON_FUNGIBLE_UNIQUE tokens to mint.
   *
   * @param metadata The metadata for the tokens to mint.
   * @return A reference to this TokenMintTransaction with the newly-set metadata.
   */
  TokenMintTransaction& setMetadata(const std::vector<std::vector<std::byte>>& metadata);

  /**
   * Add metadata for a NON_FUNGIBLE_UNIQUE token to this TokenMintTransaction.
   *
   * @param metadata The metadata to add.
   * @return A reference to this TokenMintTransaction with the newly-added metadata.
   */
  TokenMintTransaction& addMetadata(const std::vector<std::byte>& metadata);

  /**
   * Get the ID of the token to mint.
   *
   * @return The ID of the token to mint.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

  /**
   * Get the amount of the FUNGIBLE_COMMON token to mint, in the lowest denomination.
   *
   * @return The amount of the FUNGIBLE_COMMON token to mint, in the lowest denomination.
   */
  [[nodiscard]] inline uint64_t getAmount() const { return mAmount; }

  /**
   * Get the metadata for the NON_FUNGIBLE_UNIQUE tokens to mint.
   *
   * @return The metadata for the NON_FUNGIBLE_UNIQUE tokens to mint.
   */
  [[nodiscard]] inline std::vector<std::vector<std::byte>> getMetadata() const { return mMetadataList; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenMintTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenMintTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenMintTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenMintTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenMintTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenMintTransactionBody protobuf object from this TokenMintTransaction object.
   *
   * @return A pointer to a TokenMintTransactionBody protobuf object filled with this TokenMintTransaction object's
   *         data.
   */
  [[nodiscard]] proto::TokenMintTransactionBody* build() const;

  /**
   * The ID of the token for which to mint additional tokens.
   */
  TokenId mTokenId;

  /**
   * The amount of the token to mint. This is for tokens of type FUNGIBLE_COMMON. The amount provided must be in the
   * lowest denomination possible (i.e. if a token has 2 decimals, a value of 10,000 here will mint 100 tokens).
   */
  uint64_t mAmount = 0ULL;

  /**
   * The metadata of the NFTs to mint. This for tokens of type NON_FUNGIBLE_UNIQUE. Once an NFT is minted, its metadata
   * cannot be changed and is immutable. You can use the metadata field to add a URI that contains additional
   * information about the token. The metadata field has a 100 byte limit.
   */
  std::vector<std::vector<std::byte>> mMetadataList;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_MINT_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenNftAllowance.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_NFT_ALLOWANCE_H_
#define HIERO_SDK_CPP_TOKEN_NFT_ALLOWANCE_H_

#include "AccountId.h"
#include "TokenId.h"

#include <cstddef>
#include <cstdint>
#include <memory>
#include <optional>
#include <vector>

namespace proto
{
class NftAllowance;
class NftRemoveAllowance;
}

namespace Hiero
{
/**
 * An approved allowance of NFT transfers for a spender.
 */
class TokenNftAllowance
{
public:
  TokenNftAllowance() = default;

  /**
   * Construct with a token ID, owner, spender, list of serial numbers, and approval policy.
   *
   * @param tokenId           The ID of the token NFT type that is being approved to be spent.
   * @param owner             The ID of the account approving an allowance of its NFTs.
   * @param spender           The ID of the account being allowed to spend the NFTs.
   * @param serialNumbers     A list serial numbers of the NFT that is being allowed to be spent.
   * @param allowAll          \c TRUE to allow the spender access to all of the owner's NFTs of the designated token ID,
   *                          \c FALSE to revoke the spender's access to all of the owner's NFTs of the designated token
   *                          ID.
   * @param delegatingSpender The ID of the account who has an 'approveForAll' allowance and is granting approval to
   *                          spend an NFT to the spender.
   */
  TokenNftAllowance(const std::optional<TokenId>& tokenId,
                    const std::optional<AccountId>& owner,
                    const std::optional<AccountId>& spender,
                    const std::vector<uint64_t>& serialNumbers,
                    const std::optional<bool>& allowAll = std::optional<bool>(),
                    const std::optional<AccountId>& delegatingSpender = std::optional<AccountId>());

  /**
   * Construct a TokenNftAllowance object from a NftAllowance protobuf object.
   *
   * @param proto The NftAllowance protobuf object from which to construct an TokenNftAllowance object.
   * @return The constructed TokenNftAllowance object.
   */
  [[nodiscard]] static TokenNftAllowance fromProtobuf(const proto::NftAllowance& proto);

  /**
   * Construct a TokenNftAllowance object from a byte array.
   *
   * @param bytes The byte array from which to construct an TokenNftAllowance object.
   * @return The constructed TokenNftAllowance object.
   */
  [[nodiscard]] static TokenNftAllowance fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Validate the checksums of the entity IDs in this TokenNftAllowance.
   *
   * @param client The Client to use to validate the checksums.
   * @throws BadEntityException If the checksums are not valid.
   */
  void validateChecksums(const Client& client) const;

  /**
   * Construct an NftAllowance protobuf object from this TokenNftAllowance object.
   *
   * @return A pointer to a constructed NftAllowance protobuf object filled with this TokenNftAllowance object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::NftAllowance> toProtobuf() const;

  /**
   * Construct an NftRemoveAllowance protobuf object from this TokenNftAllowance object.
   *
   * @return A pointer to a constructed NftRemoveAllowance protobuf object filled with this TokenNftAllowance object's
   *         data.
   */
  [[nodiscard]] std::unique_ptr<proto::NftRemoveAllowance> toRemoveProtobuf() const;

  /**
   * Construct a representative byte array from this TokenNftAllowance object.
   *
   * @return A representative byte array of this TokenNftAllowance object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * The ID of the token that is being approved to be spent.
   */
  std::optional<TokenId> mTokenId;

  /**
   * The ID of the account approving an allowance of its tokens.
   */
  std::optional<AccountId> mOwnerAccountId;

  /**
   * The ID of the account being allowed to spend the tokens.
   */
  std::optional<AccountId> mSpenderAccountId;

  /**
   * The list of serial numbers that are being allowed to be spent.
   */
  std::vector<uint64_t> mSerialNumbers;

  /**
   * Is the spender allowed access to allow of the owner's NFTs?
   */
  std::optional<bool> mApprovedForAll;

  /**
   * The ID of the account who has an 'approveForAll' allowance and is granting approval to spend an NFT to the spender.
   */
  std::optional<AccountId> mDelegatingSpenderAccountId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_NFT_ALLOWANCE_H_
// Filename: src/sdk/main/include/TokenNftInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_NFT_INFO_H_
#define HIERO_SDK_CPP_TOKEN_NFT_INFO_H_

#include "AccountId.h"
#include "LedgerId.h"
#include "NftId.h"

#include <chrono>
#include <cstddef>
#include <memory>
#include <optional>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class TokenNftInfo;
}

namespace Hiero
{
/**
 * Response from a Hiero network when the client sends an TokenNftInfoQuery.
 */
class TokenNftInfo
{
public:
  /**
   * Construct a TokenNftInfo object from a TokenNftInfo protobuf object.
   *
   * @param proto The TokenNftInfo protobuf object from which to construct a TokenNftInfo object.
   * @return The constructed TokenNftInfo object.
   */
  [[nodiscard]] static TokenNftInfo fromProtobuf(const proto::TokenNftInfo& proto);

  /**
   * Construct a TokenNftInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a TokenNftInfo object.
   * @return The constructed TokenNftInfo object.
   */
  [[nodiscard]] static TokenNftInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a TokenNftInfo protobuf object from this TokenNftInfo object.
   *
   * @return A pointer to the created TokenNftInfo protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::TokenNftInfo> toProtobuf() const;

  /**
   * Construct a representative byte array from this TokenNftInfo object.
   *
   * @return The byte array representing this TokenNftInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this TokenNftInfo object.
   *
   * @return The string representation of this TokenNftInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this TokenNftInfo to an output stream.
   *
   * @param os   The output stream.
   * @param info The TokenNftInfo to print.
   * @return The output stream with this TokenNftInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const TokenNftInfo& info);

  /**
   * The ID of the NFT.
   */
  NftId mNftId;

  /**
   * The current owner of the NFT.
   */
  AccountId mAccountId;

  /**
   * The effective consensus timestamp at which the NFT was minted.
   */
  std::chrono::system_clock::time_point mCreationTime;

  /**
   * The unique metadata of the NFT.
   */
  std::vector<std::byte> mMetadata;

  /**
   * The ID of the ledger from which this response was returned.
   */
  LedgerId mLedgerId;

  /**
   * The corresponding spender account if an allowance is granted for the NFT.
   */
  std::optional<AccountId> mSpenderId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_NFT_INFO_H_
// Filename: src/sdk/main/include/TokenNftInfoQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_NFT_INFO_QUERY_H_
#define HIERO_SDK_CPP_TOKEN_NFT_INFO_QUERY_H_

#include "NftId.h"
#include "Query.h"

namespace Hiero
{
class TokenNftInfo;
class TransactionRecord;
}

namespace Hiero
{
/**
 * A query that returns information about a non-fungible token (NFT). You request the info for an NFT by specifying the
 * NFT ID.
 *
 * Only when a spender is set on an explicit NFT ID of a token, the spender ID is returned for the respective NFT. If
 * mApproveTokenNftAllowanceAllSerials is used to approve all NFTs for a given token class and no NFT ID is specified,
 * the spender ID for all the serial numbers of that token will not be returned.
 */
class TokenNftInfoQuery : public Query<TokenNftInfoQuery, TokenNftInfo>
{
public:
  /**
   * Set the ID of the NFT of which to request the info.
   *
   * @param nft The ID of the NFT of which to request the info.
   * @return A reference to this TokenNftInfoQuery object with the newly-set NFT ID.
   */
  TokenNftInfoQuery& setNftId(const NftId& nft);

  /**
   * Get the ID of the NFT of which this query is currently configured to get the info.
   *
   * @return The ID of the NFT for which this query is meant.
   */
  [[nodiscard]] inline NftId getNftId() const { return mNftId; }

private:
  /**
   * Derived from Executable. Construct a TokenNftInfo object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a TokenNftInfo object.
   * @return A TokenNftInfo object filled with the Response protobuf object's data
   */
  [[nodiscard]] TokenNftInfo mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this TokenNftInfoQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this TokenNftInfoQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenNftInfoQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this TokenNftInfoQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the NFT of which this query should get the info.
   */
  NftId mNftId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_NFT_INFO_QUERY_H_
// Filename: src/sdk/main/include/TokenNftTransfer.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_NFT_TRANSFER_H_
#define HIERO_SDK_CPP_TOKEN_NFT_TRANSFER_H_

#include "AccountId.h"
#include "NftId.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class NftTransfer;
}

namespace Hiero
{
/**
 * A sender account, a receiver account, and the serial number of an NFT of a Token with NON_FUNGIBLE_UNIQUE type. When
 * minting NFTs the sender will be the default AccountID instance (0.0.0) and when burning NFTs, the receiver will be
 * the default AccountID instance.
 */
class TokenNftTransfer
{
public:
  TokenNftTransfer() = default;

  /**
   * Construct with an nft ID, sender account ID, receiver account ID, and approval.
   *
   * @param nftId The ID of the NFT.
   * @param sender The ID of the account sending the NFT.
   * @param receiver The ID of the account receiving the NFT.
   * @param approved \c TRUE if this is an approved allowance NFT transfer, otherwise \c FALSE.
   */
  TokenNftTransfer(NftId nftId, AccountId sender, AccountId receiver, bool approved);

  /**
   * Construct a TokenNftTransfer object from an NftTransfer protobuf object and a TokenId object.
   *
   * @param proto   The NftTransfer protobuf object from which to construct an TokenNftTransfer object.
   * @param tokenId The ID of the token.
   * @return The constructed TokenNftTransfer object.
   */
  [[nodiscard]] static TokenNftTransfer fromProtobuf(const proto::NftTransfer& proto, const TokenId& tokenId);

  /**
   * Construct a TokenNftTransfer object from a byte array.
   *
   * @param bytes The byte array from which to construct a TokenNftTransfer object.
   * @return The constructed TokenNftTransfer object.
   */
  [[nodiscard]] static TokenNftTransfer fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Validate the checksums of the entities associated with this TokenNftTransfer.
   *
   * @param client The Client to use to validate the checksums.
   * @throws BadEntityException If any of the checksums are not valid.
   */
  void validateChecksums(const Client& client) const;

  /**
   * Construct a NftTransfer protobuf object from this TokenNftTransfer object.
   *
   * @return A pointer to the created NftTransfer protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::NftTransfer> toProtobuf() const;

  /**
   * Construct a representative byte array from this TokenNftTransfer object.
   *
   * @return The byte array representing this TokenNftTransfer object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this TokenNftTransfer object.
   *
   * @return The string representation of this TokenNftTransfer object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this TokenNftTransfer to an output stream.
   *
   * @param os       The output stream.
   * @param transfer The TokenNftTransfer to print.
   * @return The output stream with this TokenNftTransfer written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const TokenNftTransfer& transfer);

  /**
   * The ID of the NFT.
   */
  NftId mNftId;

  /**
   * The account ID of the sender.
   */
  AccountId mSenderAccountId;

  /**
   * The account ID of the receiver.
   */
  AccountId mReceiverAccountId;

  /**
   * If \c TRUE then the transfer is expected to be an approved allowance and the senderAccountID is expected to be the
   * owner.
   */
  bool mIsApproval = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_NFT_TRANSFER_H_
// Filename: src/sdk/main/include/TokenPauseTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_PAUSE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_PAUSE_TRANSACTION_H_

#include "TokenId.h"
#include "Transaction.h"

namespace proto
{
class TokenPauseTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A token pause transaction prevents the token from being involved in any kind of operation. The token's pause key is
 * required to sign the transaction. This is a key that is specified during the creation of a token. If a token has no
 * pause key, you will not be able to pause the token. If the pause key was not set during the creation of a token, you
 * will not be able to update the token to add this key.
 *
 * The following operations cannot be performed when a token is paused and will result in a TOKEN_IS_PAUSED status:
 *  - Updating the token
 *  - Transferring the token
 *  - Transferring any other token where it has its paused key in a custom fee schedule
 *  - Deleting the token
 *  - Minting or burning a token
 *  - Freezing or unfreezing an account that holds the token
 *  - Enabling or disabling KYC
 *  - Associating or disassociating a token
 *  - Wiping a token
 *
 * Once a token is paused, token status will update to paused. To verify if the token's status has been updated to
 * paused, you can request the token info via the SDK or use the token info mirror node query. If the token is not
 * paused the token status will be unpaused. The token status for tokens that do not have an assigned pause key will
 * state PauseNotApplicable.
 *
 * Transaction Signing Requirements:
 *  - The pause key of the token.
 *  - Transaction fee payer account key.
 */
class TokenPauseTransaction : public Transaction<TokenPauseTransaction>
{
public:
  TokenPauseTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenPause transaction.
   */
  explicit TokenPauseTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenPauseTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the tokens to pause.
   *
   * @param tokenId The ID of the tokens to pause.
   * @return A reference to this TokenPauseTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenPauseTransaction is frozen.
   */
  TokenPauseTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Get the ID of the tokens to pause.
   *
   * @return The ID of the tokens to pause.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenPauseTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenPauseTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenPauseTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenPauseTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenPauseTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenPauseTransactionBody protobuf object from this TokenPauseTransaction object.
   *
   * @return A pointer to a TokenPauseTransactionBody protobuf object filled with this TokenPauseTransaction object's
   *         data.
   */
  [[nodiscard]] proto::TokenPauseTransactionBody* build() const;

  /**
   * The ID of the token to pause.
   */
  TokenId mTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_PAUSE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenRejectFlow.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_REJECT_FLOW_H_
#define HIERO_SDK_CPP_TOKEN_REJECT_FLOW_H_

#include "AccountId.h"
#include "NftId.h"
#include "TokenDissociateTransaction.h"
#include "TokenId.h"
#include "TokenRejectTransaction.h"
#include "TransactionResponse.h"

namespace Hiero
{
class Client;
class PrivateKey;
}

namespace Hiero
{
/**
 * Reject undesired token(s) and dissociate in a single flow.
 */
class TokenRejectFlow
{
public:
  /**
   * The transaction used to reject tokens.
   */
  TokenRejectTransaction tokenRejectTransaction;

  /**
   * The transaction used to dissociate tokens.
   */
  TokenDissociateTransaction tokenDissociateTransaction;

  /**
   * Execute the Transactions in this flow (TokenRejectTransaction and TokenDissociateTransaction).
   *
   * @param client The Client to use to submit these Transactions.
   * @return The TransactionResponse object of the flow.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionResponse execute(const Client& client);

  /**
   * Execute the Transactions in this flow (TokenRejectTransaction and TokenDissociateTransaction) with timeout.
   *
   * @param client  The Client to use to submit these Transactions.
   * @param timeout The desired timeout for the execution of these Transactions.
   * @return The TransactionResponse object of the flow.
   * @throws MaxAttemptsExceededException If this Executable attempts to execute past the number of allowable attempts.
   * @throws PrecheckStatusException      If this Executable fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionResponse execute(const Client& client, const std::chrono::system_clock::duration& timeout);

  /**
   * Set the PrivateKey to be used for signing the transactions.
   *
   * @param privateKey A shared pointer to the `PrivateKey` object.
   */
  void setReceiverPrivateKey(const std::shared_ptr<PrivateKey>& privateKey) { mReceiverPrivateKey = privateKey; }

private:
  /**
   * The PrivateKey with which to sign the transactions.
   */
  std::shared_ptr<PrivateKey> mReceiverPrivateKey = nullptr;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_REJECT_FLOW_H_
// Filename: src/sdk/main/include/TokenRejectTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_REJECT_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_REJECT_TRANSACTION_H_

#include "AccountId.h"
#include "NftId.h"
#include "TokenId.h"
#include "Transaction.h"

namespace proto
{
class TokenRejectTransactionBody;
class TransactionBody;
class TokenReference;
}

namespace Hiero
{
/**
 * Reject undesired token(s).Transfer one or more token balances held by the requesting account to the treasury for each
 * token type. Each transfer SHALL be one of the following:
 * - A single non-fungible/unique token.
 * - The full balance held for a fungible/common token type.
 *
 * A single tokenReject transaction SHALL support a maximum of 10 transfers.
 *
 * Transaction Record Effects:
 * - Each successful transfer from `payer` to `treasury` SHALL be recorded in `token_transfer_list` for the transaction
 * record.
 */
class TokenRejectTransaction : public Transaction<TokenRejectTransaction>
{
public:
  TokenRejectTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenReject transaction.
   */
  explicit TokenRejectTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenRejectTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Get the account holding tokens to be rejected.
   *
   * @return Optional containing the account Id of the owner.
   */
  [[nodiscard]] std::optional<AccountId> getOwner() const { return mOwner; };

  /**
   * Get the list of fungible tokens to be rejected.
   *
   * @return A vector of TokenId objects.
   */
  [[nodiscard]] const std::vector<TokenId>& getFts() const { return mFts; };

  /**
   * Get the list of non-fungible tokens to be rejected.
   *
   * @return A vector of NftId objects.
   */
  [[nodiscard]] const std::vector<NftId>& getNfts() const { return mNfts; };

  /**
   * Set a new account holding tokens to be rejected.
   *
   * @param owner Account Id of the account.
   * @return A reference to this TokenRejectTransaction with the newly-set owner.
   */
  TokenRejectTransaction& setOwner(const AccountId& owner);

  /**
   * Set a new fungible tokens list of tokens to be rejected.
   *
   * @param fts List of token ids.
   * @return A reference to this TokenRejectTransaction with the newly-set tokens list.
   */
  TokenRejectTransaction& setFts(const std::vector<TokenId>& fts);

  /**
   * Set a new non-fungible tokens list of tokens to be rejected.
   *
   * @param nfts List of nft ids.
   * @return A reference to this TokenRejectTransaction with the newly-set nfts list.
   */
  TokenRejectTransaction& setNfts(const std::vector<NftId>& nfts);

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenRejectTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenRejectTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenRejectTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenRejectTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenRejectTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenRejectTransactionBody protobuf object from this TokenRejectTransaction object.
   *
   * @return A pointer to a TokenRejectTransactionBody protobuf object filled with this TokenRejectTransaction object's
   *         data.
   */
  [[nodiscard]] proto::TokenRejectTransactionBody* build() const;

  /**
   * An account holding the tokens to be rejected.
   * If set, this account MUST sign this transaction.
   * If not set, the payer for this transaction SHALL be the account rejecting tokens.
   */
  std::optional<AccountId> mOwner;

  /**
   * On success each rejected token serial number or balance SHALL be transferred from
   * the requesting account to the treasury account for that token type.
   * After rejection the requesting account SHALL continue to be associated with the token.
   * if dissociation is desired then a separate TokenDissociate transaction MUST be submitted to remove the association.
   *
   * A list of one or more fungible token rejections.
   */
  std::vector<TokenId> mFts;

  /**
   * A list of one or more non-fungible token rejections.
   */
  std::vector<NftId> mNfts;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_REJECT_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenRelationship.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_RELATIONSHIP_H_
#define HIERO_SDK_CPP_TOKEN_RELATIONSHIP_H_

#include "TokenId.h"

#include <iostream>
#include <optional>
#include <string>

#include <basic_types.pb.h>

namespace proto
{
class TokenRelationship;
}

namespace Hiero
{
/**
 * Represents the relationship between an account and a token.
 *
 * This class encapsulates information about the account's relationship with a specific token,
 * including the token ID, symbol, balance, KYC status, freeze status, and whether the relationship is created
 * implicitly.
 */
class TokenRelationship
{
public:
  TokenRelationship() = default;

  /**
   * Constructor for TokenRelationship.
   *
   * @param tokenId The unique token ID.
   * @param symbol The symbol of the token.
   * @param balance The balance of the account in the smallest denomination for fungible common tokens,
   *                or the number of NFTs held by the account for non-fungible unique tokens.
   * @param decimals The token decimals
   * @param kycStatus The KYC status of the account (optional).
   * @param freezeStatus The freeze status of the account (optional).
   * @param automaticAssociation Specifies if the relationship is created implicitly.
   */
  TokenRelationship(const TokenId& tokenId,
                    const std::string& symbol,
                    uint64_t balance,
                    uint32_t decimals,
                    int kycStatus,
                    int freezeStatus,
                    bool automaticAssociation);

  /**
   * Construct a TokenRelationship object from a TokenRelationship protobuf object.
   *
   * @param proto The TokenRelationship protobuf object from which to construct a TokenRelationship
   * object.
   * @return The constructed TokenRelationship object.
   */
  [[nodiscard]] static TokenRelationship fromProtobuf(const proto::TokenRelationship& proto);

  /**
   * Construct a TokenRelationship protobuf object from this TokenRelationship object.
   *
   * @return A pointer to the created TokenRelationship protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::TokenRelationship> toProtobuf() const;

  /**
   * Converts the TokenRelationship object to a string representation.
   *
   * @return A string representation of the TokenRelationship.
   */
  std::string toString() const;

  /**
   *  The unique token ID.
   */
  TokenId mTokenId;

  /**
   * The symbol of the token.
   */
  std::string mSymbol;

  /**
   * The balance of the account.
   */
  uint64_t mBalance;

  /**
   * The token decimals.
   */
  uint32_t mDecimals;

  /**
   * The KYC status of the account (optional).
   */
  std::optional<bool> mKycStatus;

  /**
   * The freeze status of the account (optional).
   */
  std::optional<bool> mFreezeStatus;

  /**
   * Specifies if the relationship is created implicitly.
   */
  bool mAutomaticAssociation;

private:
  /**
   * Sets the KYC status based on the provided int.
   *
   * @param kycStatus The int representation of KYC status (1 - GRANTED, 2 - REVOKED, or 0 - NOT_APPLICABLE).
   * @throws std::invalid_argument if the provided int is not a valid KYC status.
   */
  void setKycStatus(int kycStatusString);

  /**
   * Sets the freeze status based on the provided int.
   *
   * @param freezeStatus The string representation of freeze status (1 - FROZEN, 2 - UNFROZEN, or 0 - NOT_APPLICABLE).
   * @throws std::invalid_argument if the provided int is not a valid freeze status.
   */
  void setFreezeStatus(int freezeStatus);

  /**
   * Get the KYC status of the token.
   *
   * This method converts the internal KYC status to the corresponding protobuf enum value.
   *
   * @return The protobuf enum value representing the KYC status.
   */
  proto::TokenKycStatus getKycStatus() const;

  /**
   * Get the freeze status of the token.
   *
   * This method converts the internal freeze status to the corresponding protobuf enum value.
   *
   * @return The protobuf enum value representing the freeze status.
   */
  proto::TokenFreezeStatus getFreezeStatus() const;
};
} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_RELATIONSHIP_H_
// Filename: src/sdk/main/include/TokenRevokeKycTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_REVOKE_KYC_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_REVOKE_KYC_TRANSACTION_H_

#include "AccountId.h"
#include "TokenId.h"
#include "Transaction.h"

#include <optional>
#include <vector>

namespace proto
{
class TokenRevokeKycTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Revokes the KYC flag to the Hiero account for the given Hiero token. This transaction must be signed by the token's
 * KYC Key. If this key is not set, you can submit a TokenUpdateTransaction to provide the token with this key.
 *
 *  - If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
 *  - If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
 *  - If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
 *  - If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
 *  - If an Association between the provided token and account is not found, the transaction will resolve to
 *    TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
 *  - If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
 *
 * Once executed, the account is marked as KYC Revoked.
 *
 * Transaction Signing Requirements:
 *  - KYC key.
 *  - Transaction fee payer account key.
 */
class TokenRevokeKycTransaction : public Transaction<TokenRevokeKycTransaction>
{
public:
  TokenRevokeKycTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenRevokeKyc transaction.
   */
  explicit TokenRevokeKycTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenRevokeKycTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the account to have its KYC revoked for this token.
   *
   * @param accountId The ID of the account to have its KYC revoked for this token.
   * @return A reference to this TokenRevokeKycTransaction object with the newly-set account ID.
   * @throws IllegalStateException If this TokenRevokeKycTransaction is frozen.
   */
  TokenRevokeKycTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set the ID of the token for which the account has revoked KYC.
   *
   * @param tokenId The ID of the token for which the account has revoked KYC.
   * @return A reference to this TokenRevokeKycTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenRevokeKycTransaction is frozen.
   */
  TokenRevokeKycTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Get the ID of the account to have its KYC revoked for this token.
   *
   * @return The ID of the account to have its KYC revoked for this token.
   */
  [[nodiscard]] inline AccountId getAccountId() const { return mAccountId; }

  /**
   * Get the ID of the token for which the account has revoked KYC.
   *
   * @return The ID of the token for which the account has revoked KYC.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenRevokeKycTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenRevokeKycTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenRevokeKycTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenRevokeKycTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenRevokeKycTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenRevokeKycTransactionBody protobuf object from this TokenRevokeKycTransaction object.
   *
   * @return A pointer to a TokenRevokeKycTransactionBody protobuf object filled with this TokenRevokeKycTransaction
   *         object's data.
   */
  [[nodiscard]] proto::TokenRevokeKycTransactionBody* build() const;

  /**
   * The ID of the account to have its KYC revoked for this token.
   */
  AccountId mAccountId;

  /**
   * The ID of the token for which the account has revoked KYC.
   */
  TokenId mTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_REVOKE_KYC_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenSupplyType.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_SUPPLY_TYPE_H_
#define HIERO_SDK_CPP_TOKEN_SUPPLY_TYPE_H_

#include <string_view>
#include <unordered_map>

namespace proto
{
enum TokenSupplyType : int;
}

namespace Hiero
{
/**
 * Possible token supply types (IWA Compatibility). Indicates how many tokens can have during its lifetime.
 */
enum class TokenSupplyType
{
  /**
   * Indicates that tokens have an upper bound of std::numeric_limit<uint64_t>::max().
   */
  INFINITE,
  /**
   * Indicates that tokens have an upper bound of maxSupply, provided on token creation.
   */
  FINITE
};

/**
 * Map of protobuf TokenSupplyTypes to the corresponding TokenSupplyType.
 */
extern const std::unordered_map<proto::TokenSupplyType, TokenSupplyType> gProtobufTokenSupplyTypeToTokenSupplyType;

/**
 * Map of TokenSupplyTypes to the corresponding protobuf TokenSupplyType.
 */
extern const std::unordered_map<TokenSupplyType, proto::TokenSupplyType> gTokenSupplyTypeToProtobufTokenSupplyType;

/**
 * Map of TokenSupplyType to its corresponding string.
 */
[[maybe_unused]] extern const std::unordered_map<TokenSupplyType, const char*> gTokenSupplyTypeToString;

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_SUPPLY_TYPE_H_
// Filename: src/sdk/main/include/TokenTransfer.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_TRANSFER_H_
#define HIERO_SDK_CPP_TOKEN_TRANSFER_H_

#include "AccountId.h"
#include "TokenId.h"

#include <cstddef>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class AccountAmount;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * A token ID and list of amounts representing the transferred out (negative) or into (positive) amounts, represented
 * in the lowest denomination of the token.
 */
class TokenTransfer
{
public:
  TokenTransfer() = default;

  /**
   * Construct with a token ID, account ID, amount, and approval.
   *
   * @param tokenId    The ID of the token involved with this TokenTransfer.
   * @param accountId  The ID of the account to/from which the token is being transferred.
   * @param amount     The amount of the token being transferred.
   * @param isApproved \c TRUE if this transfer is approved, otherwise \c FALSE.
   */
  TokenTransfer(TokenId tokenId, AccountId accountId, int64_t amount, bool isApproved);

  /**
   * Construct with a token ID, account ID, amount, expected decimals of the token, and approval.
   *
   * @param tokenId    The ID of the token involved with this TokenTransfer.
   * @param accountId  The ID of the account to/from which the token is being transferred.
   * @param amount     The amount of the token being transferred.
   * @param isApproved \c TRUE if this transfer is approved, otherwise \c FALSE.
   */
  TokenTransfer(TokenId tokenId, AccountId accountId, int64_t amount, uint32_t decimals, bool isApproved);

  /**
   * Construct a TokenTransfer object from an AccountAmount protobuf object, a TokenId object, and the number of
   * expected decimals.
   *
   * @param proto    The AccountAmount protobuf object from which to construct the TokenTransfer object.
   * @param tokenId  The ID of the token.
   * @param decimals The number of expected decimals.
   * @return The constructed TokenTransfer object.
   */
  [[nodiscard]] static TokenTransfer fromProtobuf(const proto::AccountAmount& proto,
                                                  const TokenId& tokenId,
                                                  uint32_t expectedDecimals);

  /**
   * Construct a TokenTransfer object from a byte array.
   *
   * @param bytes The byte array from which to construct a TokenTransfer object.
   * @return The constructed TokenTransfer object.
   */
  [[nodiscard]] static TokenTransfer fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Validate the checksums of the entities in this TokenTransfer.
   *
   * @param client The Client to use to validate the checksums.
   * @throws BadEntityException If a checksum of one of the entities is not valid.
   */
  void validateChecksums(const Client& client) const;

  /**
   * Construct an AccountAmount protobuf object from this TokenTransfer object.
   *
   * @return A pointer to the constructed AccountAmount protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::AccountAmount> toProtobuf() const;

  /**
   * Construct a representative byte array from this TokenTransfer object.
   *
   * @return The byte array representing this TokenTransfer object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this TokenTransfer object.
   *
   * @return The string representation of this TokenTransfer object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this TokenTransfer to an output stream.
   *
   * @param os       The output stream.
   * @param transfer The TokenTransfer to print.
   * @return The output stream with this TokenTransfer written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const TokenTransfer& transfer);

  /**
   * The ID of the token being transferred.
   */
  TokenId mTokenId;

  /**
   * The ID of the account to/from which the token is being transferred.
   */
  AccountId mAccountId;

  /**
   * The amount of the token to transfer.
   */
  int64_t mAmount = 0LL;

  /**
   * The expected decimals of the transfer amount.
   */
  uint32_t mExpectedDecimals = 0U;

  /**
   * If \c TRUE then the transfer is expected to be an approved allowance.
   */
  bool mIsApproval = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_TRANSFER_H_
// Filename: src/sdk/main/include/TokenType.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_TYPE_H_
#define HIERO_SDK_CPP_TOKEN_TYPE_H_

#include <string_view>
#include <unordered_map>

namespace proto
{
enum TokenType : int;
}

namespace Hiero
{
/**
 * Possible token types (IWA Compatibility).
 *
 * Apart from fungible and non-fungible, tokens can have either a common or unique representation. This distinction
 * might seem subtle, but it is important when considering how tokens can be traced and if they can have isolated and
 * unique properties.
 */
enum class TokenType
{
  /**
   * Interchangeable value with one another, where any quantity of them has the same value as another equal quantity if
   * they are in the same class. Share a single set of properties, not distinct from one another. Simply represented as
   * a balance or quantity to a given Hiero account.
   */
  FUNGIBLE_COMMON,
  /**
   * Unique, not interchangeable with other tokens of the same type as they typically have different values.
   * Individually traced and can carry unique properties (e.g. serial number).
   */
  NON_FUNGIBLE_UNIQUE
};

/**
 * Map of protobuf TokenTypes to the corresponding TokenType.
 */
extern const std::unordered_map<proto::TokenType, TokenType> gProtobufTokenTypeToTokenType;

/**
 * Map of TokenTypes to the corresponding protobuf TokenType.
 */
extern const std::unordered_map<TokenType, proto::TokenType> gTokenTypeToProtobufTokenType;

/**
 * Map of TokenType to its corresponding string.
 */
[[maybe_unused]] extern const std::unordered_map<TokenType, const char*> gTokenTypeToString;

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_TYPE_H_
// Filename: src/sdk/main/include/TokenUnfreezeTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_UNFREEZE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_UNFREEZE_TRANSACTION_H_

#include "AccountId.h"
#include "TokenId.h"
#include "Transaction.h"

namespace proto
{
class TokenUnfreezeAccountTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Unfreezes transfers of the specified token for the account. The transaction must be signed by the token's freeze key.
 *
 *  - If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
 *  - If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
 *  - If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
 *  - If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
 *  - If an Association between the provided token and account is not found, the transaction will resolve to
 *    TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
 *  - If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
 *
 * Once executed the Account is marked as Unfrozen and will be able to receive or send tokens. The operation is
 * idempotent.
 *
 * Transaction Signing Requirements:
 *  - Freeze key.
 *  - Transaction fee payer account key.
 */
class TokenUnfreezeTransaction : public Transaction<TokenUnfreezeTransaction>
{
public:
  TokenUnfreezeTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenUnfreeze transaction.
   */
  explicit TokenUnfreezeTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenUnfreezeTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the account to be unfrozen for the specified token.
   *
   * @param accountId The ID of the account to be unfrozen for the specified token.
   * @return A reference to this TokenUnfreezeTransaction object with the newly-set account ID.
   * @throws IllegalStateException If this TokenUnfreezeTransaction is frozen.
   */
  TokenUnfreezeTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set the ID of the token to be unfrozen for the specified account.
   *
   * @param tokenId The ID of the token to be unfrozen for the specified account.
   * @return A reference to this TokenUnfreezeTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenUnfreezeTransaction is frozen.
   */
  TokenUnfreezeTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Get the ID of the account to be unfrozen for the specified token.
   *
   * @return The ID of the account to be unfrozen for the specified token.
   */
  [[nodiscard]] inline AccountId getAccountId() const { return mAccountId; }

  /**
   * Get the ID of the token to be unfrozen for the specified account.
   *
   * @return The ID of the token to be unfrozen for the specified account.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenUnfreezeTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenUnfreezeTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenUnfreezeTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenUnfreezeTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenUnfreezeTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenUnfreezeAccountTransactionBody protobuf object from this TokenUnfreezeTransaction object.
   *
   * @return A pointer to a TokenUnfreezeAccountTransactionBody protobuf object filled with this
   *         TokenUnfreezeTransaction object's data.
   */
  [[nodiscard]] proto::TokenUnfreezeAccountTransactionBody* build() const;

  /**
   * The ID of the account to be unfrozen for the specified token.
   */
  AccountId mAccountId;

  /**
   * The ID of the token to be unfrozen for the specified account.
   */
  TokenId mTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_UNFREEZE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenUnpauseTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_UNPAUSE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_UNPAUSE_TRANSACTION_H_

#include "TokenId.h"
#include "Transaction.h"

namespace proto
{
class TokenUnpauseTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A token unpause transaction is a transaction that unpauses the token that was previously disabled from participating
 * in transactions. The token's pause key is required to sign the transaction. Once the unpause transaction is submitted
 * the token pause status is updated to unpause.
 *
 * Transaction Signing Requirements:
 *  - The pause key of the token.
 *  - Transaction fee payer account key.
 */
class TokenUnpauseTransaction : public Transaction<TokenUnpauseTransaction>
{
public:
  TokenUnpauseTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenUnpause transaction.
   */
  explicit TokenUnpauseTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenUnpauseTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the token to unpause.
   *
   * @param tokenId The ID of the token to unpause.
   * @return A reference to this TokenUnpauseTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenUnpauseTransaction is frozen.
   */
  TokenUnpauseTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Get the ID of the token to unpause.
   *
   * @return The ID of the token to unpause.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenUnpauseTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenUnpauseTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenUnpauseTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenUnpauseTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenUnpauseTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenUnpauseTransactionBody protobuf object from this TokenUnpauseTransaction object.
   *
   * @return A pointer to a TokenUnpauseTransactionBody protobuf object filled with this TokenUnpauseTransaction
   *         object's data.
   */
  [[nodiscard]] proto::TokenUnpauseTransactionBody* build() const;

  /**
   * The ID of the token to unpause.
   */
  TokenId mTokenId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_UNPAUSE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenUpdateNftsTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_UPDATE_NFTS_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_UPDATE_NFTS_TRANSACTION_H_

#include "AccountId.h"
#include "TokenId.h"
#include "Transaction.h"

#include <chrono>
#include <memory>

namespace proto
{
class TokenUpdateNftsTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * At consensus, updates an already created Non Fungible Token to the given values.
 *
 * If no value is given for a field, that field is left unchanged.
 * Only certain fields such as metadata can be updated.
 *
 * Updating the metadata of an NFT does not affect its ownership or transferability.
 * This operation is intended for updating attributes of individual NFTs in a collection.
 *
 * Transaction Signing Requirements
 *  - To update metadata of an NFT, the metadata_key of the token should sign the transaction.
 */
class TokenUpdateNftsTransaction : public Transaction<TokenUpdateNftsTransaction>
{
public:
  TokenUpdateNftsTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenUpdate transaction.
   */
  explicit TokenUpdateNftsTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenUpdateNftsTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the token to update.
   *
   * @param tokenId The ID of the token to update.
   * @return A reference to this TokenUpdateNftsTransaction with the newly-set token ID.
   */
  TokenUpdateNftsTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Set the token serials.
   *
   * @param serials The vector of serials.
   * @return A reference to this TokenUpdateNftsTransaction with the newly-set token serials.
   */
  TokenUpdateNftsTransaction& setSerials(const std::vector<uint64_t>& serials);

  /**
   * Set the new metadata for the tokens.
   *
   * @param metadata The new metadata for the tokens.
   * @return A reference to this TokenUpdateNftsTransaction with the newly-set token metadata.
   */
  TokenUpdateNftsTransaction& setMetadata(const std::vector<std::byte>& metadata);

  /**
   * Get the ID of the token to update.
   *
   * @return The ID of the token to update.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

  /**
   * Get the serials for the token.
   *
   * @return The serials for the token. Returns empty vector if serials are not set.
   */
  [[nodiscard]] inline std::vector<uint64_t> getSerials() const { return mSerials; }

  /**
   * Get the new metadata for the tokens.
   *
   * @return The new metadata for the tokens. Returns uninitialized if no new symbol has been set.
   */
  [[nodiscard]] inline std::vector<std::byte> getMetadata() const { return mMetadata; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenUpdateNftsTransaction's data
   * to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenUpdateNftsTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenUpdateNftsTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenUpdateNftsTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenUpdateNftsTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenUpdateNftsTransactionBody protobuf object from this TokenUpdateNftsTransaction object.
   *
   * @return A pointer to a TokenUpdateNftsTransactionBody protobuf object filled with this TokenUpdateNftsTransaction
   * object's data.
   */
  [[nodiscard]] proto::TokenUpdateNftsTransactionBody* build() const;

  /**
   * The token for which to update NFTs.
   */
  TokenId mTokenId;

  /**
   * The list of serial numbers to be updated.
   */
  std::vector<uint64_t> mSerials;

  /**
   * The new metadata of the NFT(s)
   */
  std::vector<std::byte> mMetadata;
};

}
// namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_UPDATE_NFTS_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenUpdateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_UPDATE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_UPDATE_TRANSACTION_H_

#include "AccountId.h"
#include "Key.h"
#include "TokenId.h"
#include "TokenKeyValidation.h"
#include "Transaction.h"

#include <chrono>
#include <memory>
#include <optional>
#include <string>

namespace proto
{
class TokenUpdateTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that updates the properties of an existing token. The admin key must sign this transaction to update
 * any of the token properties. The admin key can update existing keys, but cannot add new keys if they were not set
 * during the creation of the token. If no value is given for a field, that field is left unchanged. For an immutable
 * token (that is, a token created without an admin key), only the expiry may be updated. Setting any other field, in
 * that case, will cause the transaction status to resolve to TOKEN_IS_IMMUTABlE.
 *
 * Transaction Signing Requirements
 *  - Admin key is required to sign to update any token properties.
 *  - Updating the admin key requires the new admin key to sign.
 *  - If a new treasury account is set, the new treasury key is required to sign.
 *  - The account that is paying for the transaction fee.
 */
class TokenUpdateTransaction : public Transaction<TokenUpdateTransaction>
{
public:
  TokenUpdateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenUpdate transaction.
   */
  explicit TokenUpdateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenUpdateTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the token to update.
   *
   * @param tokenId The ID of the token to update.
   * @return A reference to this TokenUpdateTransaction with the newly-set token ID.
   */
  TokenUpdateTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Set a new name for the token.
   *
   * @param name The new name for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set token name.
   */
  TokenUpdateTransaction& setTokenName(std::string_view name);

  /**
   * Set a new symbol for the token.
   *
   * @param symbol The new symbol for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set token symbol.
   */
  TokenUpdateTransaction& setTokenSymbol(std::string_view symbol);

  /**
   * Set the ID of a new treasury account, which will receive all of the tokens from the old treasury account.
   *
   * @param accountId The ID of the new treasury account for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set treasury account ID.
   */
  TokenUpdateTransaction& setTreasuryAccountId(const AccountId& accountId);

  /**
   * Set a new admin key for the token.
   *
   * @param key The new admin key for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set admin key.
   */
  TokenUpdateTransaction& setAdminKey(const std::shared_ptr<Key>& key);

  /**
   * Set a new KYC key for the token.
   *
   * @param key The new KYC key for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set KYC key.
   */
  TokenUpdateTransaction& setKycKey(const std::shared_ptr<Key>& key);

  /**
   * Set a new freeze key for the token.
   *
   * @param key The new freeze key for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set freeze key.
   */
  TokenUpdateTransaction& setFreezeKey(const std::shared_ptr<Key>& key);

  /**
   * Set a new wipe key for the token.
   *
   * @param key The new wipe key for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set wipe key.
   */
  TokenUpdateTransaction& setWipeKey(const std::shared_ptr<Key>& key);

  /**
   * Set a new supply key for the token.
   *
   * @param key The new supply key for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set supply key.
   */
  TokenUpdateTransaction& setSupplyKey(const std::shared_ptr<Key>& key);

  /**
   * Set the ID of a new auto-renew account for the token.
   *
   * @param accountId The ID of the new auto-renew account for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set auto-renew account ID.
   */
  TokenUpdateTransaction& setAutoRenewAccountId(const AccountId& accountId);

  /**
   * Set a new auto-renew period for the token.
   *
   * @param period The new auto-renew period for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set auto-renew period.
   */
  TokenUpdateTransaction& setAutoRenewPeriod(const std::chrono::system_clock::duration& period);

  /**
   * Set a new expiration time for the token.
   *
   * @param expiration The new expiration time for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set expiration time.
   */
  TokenUpdateTransaction& setExpirationTime(const std::chrono::system_clock::time_point& expiration);

  /**
   * Set a new memo for the token.
   *
   * @param memo The new memo for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set memo.
   */
  TokenUpdateTransaction& setTokenMemo(std::string_view memo);

  /**
   * Set a new fee schedule key for the token.
   *
   * @param key The new fee schedule key for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set fee schedule key.
   */
  TokenUpdateTransaction& setFeeScheduleKey(const std::shared_ptr<Key>& key);

  /**
   * Set a new pause key for the token.
   *
   * @param key The new pause key for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set pause key.
   */
  TokenUpdateTransaction& setPauseKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired metadata for the token.
   *
   * @param metadata The desired metadata for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set metadata.
   */
  TokenUpdateTransaction& setMetadata(const std::vector<std::byte>& metadata);

  /**
   * Set a new metadata key for the token.
   *
   * @param key The new metadata key for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set metadata key.
   */
  TokenUpdateTransaction& setMetadataKey(const std::shared_ptr<Key>& key);

  /**
   * Set the token verification mode for the token.
   *
   * @param mode The new verification mode for the token.
   * @return A reference to this TokenUpdateTransaction with the newly-set verification mode.
   */
  TokenUpdateTransaction& setTokenVerificationMode(TokenKeyValidation mode);

  /**
   * Get the ID of the token to update.
   *
   * @return The ID of the token to update.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

  /**
   * Get the new name for the token.
   *
   * @return The new name for the token. Returns uninitialized if no new name has been set.
   */
  [[nodiscard]] inline std::optional<std::string> getTokenName() const { return mTokenName; }

  /**
   * Get the new symbol for the token.
   *
   * @return The new symbol for the token. Returns uninitialized if no new symbol has been set.
   */
  [[nodiscard]] inline std::optional<std::string> getTokenSymbol() const { return mTokenSymbol; }

  /**
   * Get the ID of the new treasury account for the supply of tokens.
   *
   * @return The ID of the new treasury account for the supply of tokens. Returns uninitialized if no new treasury
   *         account has been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getTreasuryAccountId() const { return mTreasuryAccountId; }

  /**
   * Get the new admin key for the token.
   *
   * @return The new admin key for the token. Returns nullptr if no new admin key has been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getAdminKey() const { return mAdminKey; }

  /**
   * Get the new KYC key for the token.
   *
   * @return The new KYC key for the token. Returns nullptr if no new KYC key has been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getKycKey() const { return mKycKey; }

  /**
   * Get the new freeze key for the token.
   *
   * @return The new freeze key for the token. Returns nullptr if no new freeze key has been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getFreezeKey() const { return mFreezeKey; }

  /**
   * Get the new wipe key for the token.
   *
   * @return The new wipe key for the token. Returns nullptr if no new wipe key has been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getWipeKey() const { return mWipeKey; }

  /**
   * Get the new supply key for the token.
   *
   * @return The new supply key for the token. Returns nullptr if no new supply key has been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getSupplyKey() const { return mSupplyKey; }

  /**
   * Get the ID of the new auto-renew account for the token.
   *
   * @return The ID of the new auto-renew account for the token. Returns uninitialized if no new auto-renew account
   *         ID has been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getAutoRenewAccountId() const { return mAutoRenewAccountId; }

  /**
   * Get the new auto-renew period for the token.
   *
   * @return The new auto-renew period for the token. Returns uninitialized if no new auto-renew period has been set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::duration> getAutoRenewPeriod() const
  {
    return mAutoRenewPeriod;
  }

  /**
   * Get the new expiration time for the token.
   *
   * @return The new expiration time for the token. Returns uninitialized if no new expiration time has been set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::time_point> getExpirationTime() const
  {
    return mExpirationTime;
  }

  /**
   * Get the new memo for the token.
   *
   * @return The new memo for the token. Returns uninitialized if no new memo has been set.
   */
  [[nodiscard]] inline std::optional<std::string> getTokenMemo() const { return mTokenMemo; }

  /**
   * Get the new fee schedule key for the token.
   *
   * @return The new fee schedule key for the token. Returns nullptr if no new fee schedule key has been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getFeeScheduleKey() const { return mFeeScheduleKey; }

  /**
   * Get the new pause key for the token.
   *
   * @return The new pause key for the token. Returns nullptr if no new pause key has been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getPauseKey() const { return mPauseKey; }

  /**
   * Get the new metadata key for the token.
   *
   * @return The new metadata key for the token. Returns nullptr if no new metadata key has been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getMetadataKey() const { return mMetadataKey; }

  /**
   * Get the token verification mode for the token.
   *
   * @return The token verification mode for the token.
   */
  [[nodiscard]] inline TokenKeyValidation getTokenVerificationMode() const { return mKeyVerificationMode; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenUpdateTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenUpdateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenUpdateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenUpdateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenUpdateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenUpdateTransactionBody protobuf object from this TokenUpdateTransaction object.
   *
   * @return A pointer to a TokenUpdateTransactionBody protobuf object filled with this TokenUpdateTransaction object's
   *         data.
   */
  [[nodiscard]] proto::TokenUpdateTransactionBody* build() const;

  /**
   * The ID of the token to update.
   */
  TokenId mTokenId;

  /**
   * The new publicly visible name of the token. The token name is specified as a string of UTF-8 characters in Unicode.
   * UTF-8 encoding of this Unicode cannot contain the 0 byte (NUL). The token name is not unique. Maximum of 100
   * characters.
   */
  std::optional<std::string> mTokenName;

  /**
   * The new publicly visible token symbol. The token symbol is specified as a string of UTF-8 characters in Unicode.
   * UTF-8 encoding of this Unicode cannot contain the 0 byte (NUL). The token symbol is not unique. Maximum of 100
   * characters.
   */
  std::optional<std::string> mTokenSymbol;

  /**
   * The new account which will act as a treasury for the token. If the provided treasury account does not exist or is
   * deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the token balance held in the
   * previous treasury account is transferred to the new one.
   */
  std::optional<AccountId> mTreasuryAccountId;

  /**
   * The new admin key for the token.
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The new KYC key for the token.
   */
  std::shared_ptr<Key> mKycKey = nullptr;

  /**
   * The new freeze key for the token.
   */
  std::shared_ptr<Key> mFreezeKey = nullptr;

  /**
   * The new wipe key for the token.
   */
  std::shared_ptr<Key> mWipeKey = nullptr;

  /**
   * The new supply key for the token.
   */
  std::shared_ptr<Key> mSupplyKey = nullptr;

  /**
   * The ID of the new account which will be automatically charged to renew the token's expiration, at the interval
   * specified in by token's auto renew period.
   */
  std::optional<AccountId> mAutoRenewAccountId;

  /**
   * The new interval at which the auto-renew account will be charged to extend the token's expiry.
   */
  std::optional<std::chrono::system_clock::duration> mAutoRenewPeriod;

  /**
   * The new expiration time of the token. Expiration time can be updated even if the admin key is not set. If the
   * provided expiration time is earlier than the current token expiration time, the transaction will resolved to
   * INVALID_EXPIRATION_TIME.
   */
  std::optional<std::chrono::system_clock::time_point> mExpirationTime;

  /**
   * The new memo associated with the token (UTF-8 encoding max 100 bytes).
   */
  std::optional<std::string> mTokenMemo;

  /**
   * The new fee schedule key for the token.
   */
  std::shared_ptr<Key> mFeeScheduleKey = nullptr;

  /**
   * The new pause key for the token.
   */
  std::shared_ptr<Key> mPauseKey = nullptr;

  /**
   * Metadata of the updated token.
   */
  std::vector<std::byte> mMetadata;

  /**
   * The new metadata key of the token. The metadata key has the ability to
   * change the metadata of a token (token definition, partition definition,
   * and individual NFTs). If the Token does not currently have a Metadata key,
   * the transaction will resolve to TOKEN_HAS_NO_METADATA_KEY.
   */
  std::shared_ptr<Key> mMetadataKey = nullptr;

  /**
   * Determines whether the system should check the validity of the passed keys for update.
   * Defaults to FULL_VALIDATION
   */
  TokenKeyValidation mKeyVerificationMode = TokenKeyValidation::FULL_VALIDATION;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_UPDATE_TRANSACTION_H_
// Filename: src/sdk/main/include/TokenWipeTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOKEN_WIPE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOKEN_WIPE_TRANSACTION_H_

#include "AccountId.h"
#include "TokenId.h"
#include "Transaction.h"

#include <cstdint>
#include <vector>

namespace proto
{
class TokenWipeAccountTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Wipes the provided amount of fungible or non-fungible tokens from the specified Hiero account. This transaction does
 * not delete tokens from the treasury account. This transaction must be signed by the token's Wipe Key. Wiping an
 * account's tokens burns the tokens and decreases the total supply.
 *
 *  - If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
 *  - If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
 *  - If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
 *  - If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
 *  - If an Association between the provided token and the account is not found, the transaction will resolve to
 *    TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
 *  - If Wipe Key is not present in the Token, the transaction results in TOKEN_HAS_NO_WIPE_KEY.
 *  - If the provided account is the token's Treasury Account, the transaction results in
 *    CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT.
 *
 * On success, tokens are removed from the account and the total supply of the token is decreased by the wiped amount.
 * The amount provided is in the lowest denomination possible.
 *  - Example: Token A has 2 decimals. In order to wipe 100 tokens from an account, one must provide an amount of 10000.
 *             In order to wipe 100.55 tokens, one must provide an amount of 10055.
 *
 * This transaction accepts zero-unit token wipe operations for fungible tokens (HIP-564).
 *
 * Transaction Signing Requirements:
 *  - Wipe key.
 *  - Transaction fee payer account key.
 */
class TokenWipeTransaction : public Transaction<TokenWipeTransaction>
{
public:
  TokenWipeTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a TokenWipe transaction.
   */
  explicit TokenWipeTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TokenWipeTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the token to wipe.
   *
   * @param tokenId The ID of the token to wipe.
   * @return A reference to this TokenWipeTransaction object with the newly-set token ID.
   * @throws IllegalStateException If this TokenWipeTransaction is frozen.
   */
  TokenWipeTransaction& setTokenId(const TokenId& tokenId);

  /**
   * Set the ID of the account from which to wipe the token(s).
   *
   * @param accountId The ID of the account from which to wipe the token(s).
   * @return A reference to this TokenWipeTransaction object with the newly-set account ID.
   * @throws IllegalStateException If this TokenWipeTransaction is frozen.
   */
  TokenWipeTransaction& setAccountId(const AccountId& accountId);

  /**
   * Set the amount of FUNGIBLE_COMMON tokens to wipe from the account. This should be in the lowest denomination
   * possible.
   *
   * @param amount The amount of FUNGIBLE_COMMON tokens to wipe from the account.
   * @return A reference to this TokenWipeTransaction object with the newly-set amount.
   * @throws IllegalStateException If this TokenWipeTransaction is frozen.
   */
  TokenWipeTransaction& setAmount(uint64_t amount);

  /**
   * Set the serial numbers of NON_FUNGIBLE_UNIQUE tokens to wipe from the account.
   *
   * @param serialNumbers The serial numbers of NON_FUNGIBLE_UNIQUE tokens to wipe from the account.
   * @return A reference to this TokenWipeTransaction object with the newly-set serial numbers.
   * @throws IllegalStateException If this TokenWipeTransaction is frozen.
   */
  TokenWipeTransaction& setSerialNumbers(const std::vector<uint64_t>& serialNumbers);

  /**
   * Get the ID of the token to wipe.
   *
   * @return The ID of the token to wipe.
   */
  [[nodiscard]] inline TokenId getTokenId() const { return mTokenId; }

  /**
   * Get the ID of the account from which to wipe the token(s).
   *
   * @return The ID of the account from which to wipe the token(s).
   */
  [[nodiscard]] inline AccountId getAccountId() const { return mAccountId; }

  /**
   * Get the amount of FUNGIBLE_COMMON tokens to wipe from the account.
   *
   * @return The amount of FUNGIBLE_COMMON tokens to wipe from the account.
   */
  [[nodiscard]] inline uint64_t getAmount() const { return mAmount; }

  /**
   * Get the serial numbers of the NON_FUNGIBLE_UNIQUE tokens to wipe from the account.
   *
   * @return The serial numbers of the NON_FUNGIBLE_UNIQUE tokens to wipe from the account.
   */
  [[nodiscard]] inline std::vector<uint64_t> getSerialNumbers() const { return mSerialNumbers; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TokenWipeTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TokenWipeTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TokenWipeTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TokenWipeTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TokenWipeTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a TokenWipeAccountTransactionBody protobuf object from this TokenWipeTransaction object.
   *
   * @return A pointer to a TokenWipeAccountTransactionBody protobuf object filled with this TokenWipeTransaction
   *         object's data.
   */
  [[nodiscard]] proto::TokenWipeAccountTransactionBody* build() const;

  /**
   * The ID of the token to wipe from the account.
   */
  TokenId mTokenId;

  /**
   * The ID of the account from which to wipe the tokens.
   */
  AccountId mAccountId;

  /**
   * Applicable to tokens of type FUNGIBLE_COMMON. The amount of tokens to wipe from the specified account. Amount must
   * be a positive non-zero number in the lowest denomination possible and not bigger than the token balance of the
   * account.
   */
  uint64_t mAmount = 0ULL;

  /**
   * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. THe list of serial numbers to be wiped from the account.
   */
  std::vector<uint64_t> mSerialNumbers;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOKEN_WIPE_TRANSACTION_H_
// Filename: src/sdk/main/include/TopicCreateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_CREATE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOPIC_CREATE_TRANSACTION_H_

#include "AccountId.h"
#include "CustomFixedFee.h"
#include "Defaults.h"
#include "Key.h"
#include "Transaction.h"

#include <chrono>
#include <memory>
#include <optional>
#include <string>
#include <string_view>

namespace proto
{
class ConsensusCreateTopicTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that creates a new topic recognized by the Hiero network. The newly generated topic can be referenced
 * by its topic ID. The topic ID is used to identify a unique topic to which to submit messages. You can obtain the new
 * topic ID by requesting the receipt of the transaction. All messages within a topic are sequenced with respect to one
 * another and are provided a unique sequence number.
 *
 * You can also create a private topic where only authorized parties can submit messages to that topic. To create a
 * private topic you would need to set the mSubmitKey of the transaction. The mSubmitKey value is then shared with the
 * authorized parties and is required to successfully submit messages to the private topic.
 *
 * Transaction Signing Requirements:
 *  - If an admin key is specified, the admin key must sign the transaction.
 *  - If an admin key is not specified, the topic is immutable.
 *  - If an auto-renew account is specified, that account must also sign this transaction.
 */
class TopicCreateTransaction : public Transaction<TopicCreateTransaction>
{
public:
  TopicCreateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ConsensusCreateTopic transaction.
   */
  explicit TopicCreateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TopicCreateTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the desired memo for the new topic.
   *
   * @param memo The desired memo for the new topic.
   * @return A reference to this TopicCreateTransaction object with the newly-set memo.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& setMemo(std::string_view memo);

  /**
   * Set the desired admin key for the new topic.
   *
   * @param key The desired admin key for the new topic.
   * @return A reference to this TopicCreateTransaction object with the newly-set admin key.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& setAdminKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired submit key for the new topic.
   *
   * @param key The desired submit key for the new topic.
   * @return A reference to this TopicCreateTransaction object with the newly-set submit key.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& setSubmitKey(const std::shared_ptr<Key>& key);

  /**
   * Set the desired auto-renew period for the new topic.
   *
   * @param autoRenew The desired auto-renew period for the new topic.
   * @return A reference to this TopicCreateTransaction object with the newly-set auto-renew period.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& setAutoRenewPeriod(const std::chrono::system_clock::duration& autoRenew);

  /**
   * Set the ID of the desired auto-renew account for the new topic.
   *
   * @param accountId The ID of the desired auto-renew account for the new topic.
   * @return A reference to this TopicCreateTransaction object with the newly-set auto-renew account ID.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& setAutoRenewAccountId(const AccountId& accountId);

  /**
   * Set the fee schedule key for the new topic.
   *
   * @param key The key that controls fee schedule updates.
   * @return A reference to this TopicCreateTransaction object with the newly-set fee schedule key.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& setFeeScheduleKey(const std::shared_ptr<Key>& key);

  /**
   * Set the list of keys exempt from paying custom fees.
   *
   * @param keys The list of keys that will not be charged custom fees when submitting messages to this topic.
   * @return A reference to this TopicCreateTransaction object with the newly-set exempt keys.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& setFeeExemptKeys(const std::vector<std::shared_ptr<Key>>& keys);

  /**
   * Add a key to the list of keys exempt from paying custom fees.
   *
   * @param key The key to be added to the exempt list.
   * @return A reference to this TopicCreateTransaction object with the newly-added exempt key.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& addFeeExemptKey(const std::shared_ptr<Key>& key);

  /**
   * Set the list of custom fixed fees for this topic.
   *
   * @param fees The list of custom fixed fees.
   * @return A reference to this TopicCreateTransaction object with the newly-set custom fees.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& setCustomFixedFees(const std::vector<CustomFixedFee>& fees);

  /**
   * Add a custom fixed fee to this topic.
   *
   * @param fee The custom fixed fee to be added.
   * @return A reference to this TopicCreateTransaction object with the newly-added fee.
   * @throws IllegalStateException If this TopicCreateTransaction is frozen.
   */
  TopicCreateTransaction& addCustomFixedFee(const CustomFixedFee& fee);

  /**
   * Get the desired memo of the new topic.
   *
   * @return The desired memo of the new topic.
   */
  [[nodiscard]] inline std::string getMemo() const { return mMemo; }

  /**
   * Get the desired admin key for the new topic.
   *
   * @return The desired admin key for the new topic.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getAdminKey() const { return mAdminKey; }

  /**
   * Get the desired submit key for the new topic.
   *
   * @return The desired submit key for the new topic.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getSubmitKey() const { return mSubmitKey; }

  /**
   * Get the desired fee schedule key for the new topic.
   *
   * @return The fee schedule key for the new topic.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getFeeScheduleKey() const { return mFeeScheduleKey; }

  /**
   * Get the list of fee-exempt keys for the new topic.
   *
   * @return The list of fee-exempt keys.
   */
  [[nodiscard]] inline std::vector<std::shared_ptr<Key>> getFeeExemptKeys() const { return mFeeExemptKeys; }

  /**
   * Get the list of custom fixed fees for the new topic.
   *
   * @return The list of custom fixed fees.
   */
  [[nodiscard]] inline std::vector<CustomFixedFee> getCustomFixedFees() const { return mCustomFixedFees; }

  /**
   * Get the desired auto-renew period for the new topic.
   *
   * @return The desired auto-renew period for the new topic.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getAutoRenewPeriod() const { return mAutoRenewPeriod; }

  /**
   * Get the ID of the desired auto-renew account for the new topic.
   *
   * @return The ID of the desired auto-renew account for the new topic. Returns uninitialized if the auto-renew account
   *         has not been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getAutoRenewAccountId() const { return mAutoRenewAccountId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TopicCreateTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TopicCreateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TopicCreateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TopicCreateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TopicCreateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ConsensusCreateTopicTransactionBody protobuf object from this TopicCreateTransaction object.
   *
   * @return A pointer to a ConsensusCreateTopicTransactionBody protobuf object filled with this TopicCreateTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ConsensusCreateTopicTransactionBody* build() const;

  /**
   * The publicly visible memo for the new topic.
   */
  std::string mMemo;

  /**
   * The key used for access control to update or delete the new topic. Anyone can increase the topic's mExpirationTime
   * via a TopicUpdateTransaction regardless of the mAdminKey. If no mAdminKey is specified, TopicUpdateTransaction may
   * only be used to extend the topic's mExpirationTime, and TopicDeleteTransaction is disallowed.
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The key that must sign to submit a message to the new topic (via a TopicMessageSubmitTransaction). If nullptr, all
   * message submissions are allowed on this topic.
   */
  std::shared_ptr<Key> mSubmitKey = nullptr;

  /**
   * The amount of time by which to attempt to extend the new topic's lifetime automatically at its expiration time.
   */
  std::chrono::system_clock::duration mAutoRenewPeriod = DEFAULT_AUTO_RENEW_PERIOD;

  /**
   * The account that should be charged to extend the lifetime of the new topic at its expiration time.
   */
  std::optional<AccountId> mAutoRenewAccountId;

  /**
   * Access control for update or delete of custom fees.
   * If set, subsequent `consensus_update_topic` transactions signed with this
   * key MAY update or delete the custom fees for this topic.
   * If not set, the custom fees for this topic SHALL BE immutable.
   * If not set when the topic is created, this field CANNOT be set via update.
   * If set when the topic is created, this field MAY be changed via update.
   */
  std::shared_ptr<Key> mFeeScheduleKey = nullptr;

  /**
   * A set of keys.
   * Keys in this list are permitted to submit messages to this topic without
   * paying custom fees associated with this topic.
   * If a submit transaction is signed by _any_ key included in this set,
   * custom fees SHALL NOT be charged for that transaction.
   * This field MUST NOT contain more than 10 keys.
   * fee_exempt_key_list SHALL NOT contain any duplicate keys.
   * fee_exempt_key_list MAY contain keys for accounts that are inactive,
   * deleted, or non-existent.
   * If fee_exempt_key_list is unset in this transaction, there SHALL NOT be
   * any fee-exempt keys.  In particular, the following keys SHALL NOT be
   * implicitly or automatically added to this list:
   * `adminKey`, `submitKey`, `fee_schedule_key`.
   */
  std::vector<std::shared_ptr<Key>> mFeeExemptKeys;

  /**
   * A set of custom fee definitions.
   * These are fees to be assessed for each submit to this topic.
   * Each fee defined in this set SHALL be evaluated for
   * each message submitted to this topic, and the resultant
   * total assessed fees SHALL be charged.
   * Custom fees defined here SHALL be assessed in addition to the base
   * network and node fees.
   * custom_fees list SHALL NOT contain more than
   * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
   */
  std::vector<CustomFixedFee> mCustomFixedFees;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOPIC_CREATE_TRANSACTION_H_
// Filename: src/sdk/main/include/TopicDeleteTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_DELETE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOPIC_DELETE_TRANSACTION_H_

#include "TopicId.h"
#include "Transaction.h"

#include <optional>

namespace proto
{
class ConsensusDeleteTopicTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that deletes a topic from the Hiero network. Once a topic is deleted, the topic cannot be recovered to
 * receive messages and all submitMessage calls will fail. Older messages can still be accessed, even after the topic is
 * deleted, via the mirror node.
 *
 * Transaction Signing Requirements:
 *  - If the adminKey was set upon the creation of the topic, the adminKey is required to sign to successfully delete
 *    the topic.
 *  - If no adminKey was set upon the creating of the topic, you cannot delete the topic and will receive an
 *    UNAUTHORIZED error.
 */
class TopicDeleteTransaction : public Transaction<TopicDeleteTransaction>
{
public:
  TopicDeleteTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ConsensusDeleteTopic transaction.
   */
  explicit TopicDeleteTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TopicDeleteTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the topic to delete.
   *
   * @param topicId The ID of the topic to delete.
   * @return A reference to this TopicDeleteTransaction object with the newly-set topic ID.
   * @throws IllegalStateException If this TopicDeleteTransaction is frozen.
   */
  TopicDeleteTransaction& setTopicId(const TopicId& topicId);

  /**
   * Get the ID of the topic this TopicDeleteTransaction is currently configured to delete.
   *
   * @return The ID of the topic this TopicDeleteTransaction is currently configured to delete. Uninitialized if no
   *         topic ID has been set.
   */
  [[nodiscard]] inline std::optional<TopicId> getTopicId() const { return mTopicId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TopicDeleteTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TopicDeleteTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TopicDeleteTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TopicDeleteTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TopicDeleteTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ConsensusDeleteTopicTransactionBody protobuf object from this TopicDeleteTransaction object.
   *
   * @return A pointer to a ConsensusDeleteTopicTransactionBody protobuf object filled with this TopicDeleteTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ConsensusDeleteTopicTransactionBody* build() const;

  /**
   * The ID of the topic to delete.
   */
  std::optional<TopicId> mTopicId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOPIC_DELETE_TRANSACTION_H_
// Filename: src/sdk/main/include/TopicId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_ID_H_
#define HIERO_SDK_CPP_TOPIC_ID_H_

#include <cstddef>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class TopicID;
}

namespace Hiero
{
class Client;
}

namespace Hiero
{
/**
 * The ID for a topic on Hiero.
 */
class TopicId
{
public:
  TopicId() = default;

  /**
   * Construct with a topic number.
   *
   * @param num The topic number.
   */
  explicit TopicId(uint64_t num);

  /**
   * Construct with a shard, realm, a topic number, and optionally a checksum.
   *
   * @param shard    The shard number.
   * @param realm    The realm number.
   * @param num      The topic number.
   * @param checksum The checksum.
   */
  explicit TopicId(uint64_t shard, uint64_t realm, uint64_t num, std::string_view checksum = "");

  /**
   * Compare this TopicId to another TopicId and determine if they represent the same topic.
   *
   * @param other The other TopicId with which to compare this TopicId.
   * @return \c TRUE if this TopicId is the same as the input TopicId, otherwise \c FALSE.
   */
  bool operator==(const TopicId& other) const;

  /**
   * Construct a TopicId object from a string of the form "<shard>.<realm>.<num>".
   *
   * @param id The topic ID string from which to construct.
   * @return The constructed TopicId object.
   * @throws std::invalid_argument If the input string is malformed.
   */
  [[nodiscard]] static TopicId fromString(std::string_view id);

  /**
   * Construct a TopicId from a Solidity address.
   *
   * @param address The Solidity address from which to create a TopicId, as a string.
   * @return The constructed TopicId object.
   * @throws std::invalid_argument If a Solidity address cannot be realized from the input string.
   */
  [[nodiscard]] static TopicId fromSolidityAddress(std::string_view address);

  /**
   * Construct a TopicId from a TopicId protobuf object.
   *
   * @param proto The TopicId protobuf object from which to create a TopicId object.
   * @return The constructed TopicId object.
   */
  [[nodiscard]] static TopicId fromProtobuf(const proto::TopicID& proto);

  /**
   * Construct a TopicId object from a representative byte array.
   *
   * @param bytes The byte array from which to construct a TopicId object.
   * @return The constructed TopicId object.
   */
  [[nodiscard]] static TopicId fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Verify the checksum of this TopicId using the input Client's network.
   *
   * @param client The Client with which to validate this TopicId's checksum.
   * @throws BadEntityException If the checksum of this TopicId is invalid.
   */
  void validateChecksum(const Client& client) const;

  /**
   * Construct a TopicID protobuf object from this TopicId object.
   *
   * @return A pointer to the created TopicId protobuf object filled with this TopicId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::TopicID> toProtobuf() const;

  /**
   * Get the Solidity address representation of this TopicId (Long-Zero address form).
   *
   * @return The Solidity address representation of this TopicId.
   */
  [[nodiscard]] std::string toSolidityAddress() const;

  /**
   * Get the string representation of this TopicId object.
   *
   * @return The string representation of this TopicId.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Get the string representation of this TopicId object with the checksum.
   *
   * @param client The Client with which to generate the checksum.
   * @return The string representation of this TopicId object with the checksum.
   */
  [[nodiscard]] std::string toStringWithChecksum([[maybe_unused]] const Client& client) const;

  /**
   * Get a byte array representation of this TopicId object.
   *
   * @return A byte array representation of this TopicId object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Get the checksum of this ContractId.
   *
   * @return The checksum of this ContractId.
   */
  [[nodiscard]] inline std::string getChecksum() const { return mChecksum; }

  /**
   * The shard number.
   */
  uint64_t mShardNum = 0ULL;

  /**
   * The realm number.
   */
  uint64_t mRealmNum = 0ULL;

  /**
   * The topic number.
   */
  uint64_t mTopicNum = 0ULL;

private:
  /**
   * The checksum of this TopicIds.
   */
  mutable std::string mChecksum;
};

} // namespace Hiero

namespace std
{
template<>
struct hash<Hiero::TopicId>
{
  /**
   * Operator override to enable use of TopicId as map key
   */
  size_t operator()(const Hiero::TopicId& id) const { return hash<string>()(id.toString()); }
};

} // namespace std

#endif // HIERO_SDK_CPP_TOPIC_ID_H_
// Filename: src/sdk/main/include/TopicInfo.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_INFO_H_
#define HIERO_SDK_CPP_TOPIC_INFO_H_

#include "AccountId.h"
#include "CustomFixedFee.h"
#include "Key.h"
#include "LedgerId.h"
#include "TopicId.h"

#include <chrono>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <optional>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class ConsensusGetTopicInfoResponse;
}

namespace Hiero
{
/**
 * Response from a Hiero network when the client sends an TopicInfoQuery.
 */
class TopicInfo
{
public:
  /**
   * Construct a TopicInfo object from a ConsensusGetTopicInfoResponse protobuf object.
   *
   * @param proto The ConsensusGetTopicInfoResponse protobuf object from which to construct a TopicInfo object.
   * @return The constructed TopicInfo object.
   */
  [[nodiscard]] static TopicInfo fromProtobuf(const proto::ConsensusGetTopicInfoResponse& proto);

  /**
   * Construct a TopicInfo object from a byte array.
   *
   * @param bytes The byte array from which to construct a TopicInfo object.
   * @return The constructed TopicInfo object.
   */
  [[nodiscard]] static TopicInfo fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a ConsensusGetTopicInfoResponse protobuf object from this TopicInfo object.
   *
   * @return A pointer to the created ConsensusGetTopicInfoResponse protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::ConsensusGetTopicInfoResponse> toProtobuf() const;

  /**
   * Construct a representative byte array from this TopicInfo object.
   *
   * @return The byte array representing this TopicInfo object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this TopicInfo object.
   *
   * @return The string representation of this TopicInfo object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this TopicInfo to an output stream.
   *
   * @param os   The output stream.
   * @param info The TopicInfo to print.
   * @return The output stream with this TopicInfo written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const TopicInfo& info);

  /**
   * The ID of the topic.
   */
  TopicId mTopicId;

  /**
   * The publicly visible memo for the new topic.
   */
  std::string mMemo;

  /**
   * The SHA384 running hash of [previousRunningHash, topicId, consensusTimestamp, sequenceNumber, message].
   */
  std::vector<std::byte> mRunningHash;

  /**
   * The sequence number (which starts at one for the first message) of messages on the topic.
   */
  uint64_t mSequenceNumber = 0ULL;

  /**
   * The timestamp at which the topic will expire.
   */
  std::chrono::system_clock::time_point mExpirationTime = std::chrono::system_clock::now();

  /**
   * The key used for access control to update or delete the topic. Nullptr if there is no admin key for the topic.
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The key that must sign to submit a message to the new topic (via a TopicMessageSubmitTransaction). Nullptr if there
   * is no submit key for the topic.
   */
  std::shared_ptr<Key> mSubmitKey = nullptr;

  /**
   * The amount of time by which to attempt to extend the topic's lifetime automatically at its expiration time.
   */
  std::optional<std::chrono::system_clock::duration> mAutoRenewPeriod;

  /**
   * The ID of the account that should be charged to extend the lifetime of the new topic at its expiration time.
   */
  std::optional<AccountId> mAutoRenewAccountId;

  /**
   * The ID of the ledger from which this response was returned.
   */
  LedgerId mLedgerId;

  /**
   * Access control for update or delete of custom fees.
   * If set, subsequent `consensus_update_topic` transactions signed with this
   * key MAY update or delete the custom fees for this topic.
   * If not set, the custom fees for this topic SHALL BE immutable.
   * If not set when the topic is created, this field CANNOT be set via update.
   * If set when the topic is created, this field MAY be changed via update.
   */
  std::shared_ptr<Key> mFeeScheduleKey = nullptr;

  /**
   * A set of keys.
   * Keys in this list are permitted to submit messages to this topic without
   * paying custom fees associated with this topic.
   * If a submit transaction is signed by _any_ key included in this set,
   * custom fees SHALL NOT be charged for that transaction.
   * This field MUST NOT contain more than 10 keys.
   * fee_exempt_key_list SHALL NOT contain any duplicate keys.
   * fee_exempt_key_list MAY contain keys for accounts that are inactive,
   * deleted, or non-existent.
   * If fee_exempt_key_list is unset in this transaction, there SHALL NOT be
   * any fee-exempt keys.  In particular, the following keys SHALL NOT be
   * implicitly or automatically added to this list:
   * `adminKey`, `submitKey`, `fee_schedule_key`.
   */
  std::vector<std::shared_ptr<Key>> mFeeExemptKeys;

  /**
   * A set of custom fee definitions.
   * These are fees to be assessed for each submit to this topic.
   * Each fee defined in this set SHALL be evaluated for
   * each message submitted to this topic, and the resultant
   * total assessed fees SHALL be charged.
   * Custom fees defined here SHALL be assessed in addition to the base
   * network and node fees.
   * custom_fees list SHALL NOT contain more than
   * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
   */
  std::vector<CustomFixedFee> mCustomFixedFees;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOPIC_INFO_H_
// Filename: src/sdk/main/include/TopicInfoQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_INFO_QUERY_H_
#define HIERO_SDK_CPP_TOPIC_INFO_QUERY_H_

#include "Query.h"
#include "TopicId.h"

namespace Hiero
{
class TopicInfo;
class TransactionRecord;
}

namespace Hiero
{
/**
 * A query that gets information about a topic instance.
 */
class TopicInfoQuery : public Query<TopicInfoQuery, TopicInfo>
{
public:
  /**
   * Set the ID of the topic of which to request the info.
   *
   * @param topic The ID of the topic of which to request the info.
   * @return A reference to this TopicInfoQuery object with the newly-set topic ID.
   */
  TopicInfoQuery& setTopicId(const TopicId& topicId);

  /**
   * Get the ID of the topic of which this query is currently configured to get the info.
   *
   * @return The ID of the topic for which this query is meant.
   */
  [[nodiscard]] inline TopicId getTopicId() const { return mTopicId; }

private:
  /**
   * Derived from Executable. Construct a TopicInfo object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a TopicInfo object.
   * @return A TopicInfo object filled with the Response protobuf object's data
   */
  [[nodiscard]] TopicInfo mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this TopicInfoQuery's data to a Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this TopicInfoQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TopicInfoQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Query. Build a Query protobuf object with this TopicInfoQuery's data, with the input QueryHeader
   * protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the topic of which this query should get the info.
   */
  TopicId mTopicId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOPIC_INFO_QUERY_H_
// Filename: src/sdk/main/include/TopicMessage.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_MESSAGE_H_
#define HIERO_SDK_CPP_TOPIC_MESSAGE_H_

#include "TopicMessageChunk.h"
#include "TransactionId.h"

#include <chrono>
#include <cstddef>
#include <vector>

namespace com::hedera::mirror::api::proto
{
class ConsensusTopicResponse;
}

namespace Hiero
{
/**
 * The message of a topic.
 */
class TopicMessage
{
public:
  TopicMessage() = default;

  /**
   * Construct with the consensus timestamp of the last message received, the topic message, the last running hash, the
   * last sequence number, the chunks that make up the message, and the transaction ID.
   *
   * @param lastConsensusTimestamp The consensus timestamp of the last message received.
   * @param message                The topic message.
   * @param lastRunningHash        The last running hash of the topic.
   * @param lastSequenceNumber     The last sequence number of the topic.
   * @param chunks                 The chunks that make up the message.
   * @param transactionId          The ID of the transaction.
   */
  TopicMessage(const std::chrono::system_clock::time_point& lastConsensusTimestamp,
               const std::vector<std::byte>& message,
               const std::vector<std::byte>& lastRunningHash,
               uint64_t lastSequenceNumber,
               const std::vector<TopicMessageChunk>& chunks,
               TransactionId transactionId);

  /**
   * Create a TopicMessage from a single ConsensusTopicResponse protobuf object.
   *
   * @param proto The ConsensusTopicResponse protobuf object from which to create a TopicMessage.
   * @return The constructed TopicMessage object.
   */
  [[nodiscard]] static TopicMessage ofSingle(const com::hedera::mirror::api::proto::ConsensusTopicResponse& proto);

  /**
   * Create a TopicMessage from numerous ConsensusTopicResponse protobuf objects.
   *
   * @param protos The ConsensusTopicResponse protobuf objects from which to create a TopicMessage.
   * @return The constructed TopicMessage object.
   */
  [[nodiscard]] static TopicMessage ofMany(
    const std::vector<com::hedera::mirror::api::proto::ConsensusTopicResponse>& protos);

  /**
   * The consensus timestamp of the full TopicMessage.
   */
  std::chrono::system_clock::time_point mConsensusTimestamp;

  /**
   * The content of this TopicMessage.
   */
  std::vector<std::byte> mContents;

  /**
   * The running hash of the topic that received the message.
   */
  std::vector<std::byte> mRunningHash;

  /**
   * The sequence number of this TopicMessage.
   */
  uint64_t mSequenceNumber = 0ULL;

  /**
   * This TopicMessage's chunks, if it was divided into chunks.
   */
  std::vector<TopicMessageChunk> mChunks;

  /**
   * The ID of the corresponding transaction.
   */
  TransactionId mTransactionId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOPIC_MESSAGE_H_
// Filename: src/sdk/main/include/TopicMessageChunk.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_MESSAGE_CHUNK_H_
#define HIERO_SDK_CPP_TOPIC_MESSAGE_CHUNK_H_

#include "TransactionId.h"

#include <chrono>
#include <cstddef>
#include <vector>

namespace com::hedera::mirror::api::proto
{
class ConsensusTopicResponse;
}

namespace Hiero
{
/**
 * A chunk of a topic message.
 */
class TopicMessageChunk
{
public:
  TopicMessageChunk() = default;

  /**
   * Construct from a ConsensusTopicResponse protobuf object.
   *
   * @param proto The ConsensusTopicResponse protobuf object.
   */
  explicit TopicMessageChunk(const com::hedera::mirror::api::proto::ConsensusTopicResponse& proto);

  /**
   * The consensus timestamp of this topic message chunk.
   */
  std::chrono::system_clock::time_point mConsensusTimestamp;

  /**
   * The size of this chunk's content.
   */
  uint64_t mContentSize = 0ULL;

  /**
   * The running hash of this chunk.
   */
  std::vector<std::byte> mRunningHash;

  /**
   * The sequence number of this chunk.
   */
  uint64_t mSequenceNumber = 0ULL;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOPIC_MESSAGE_CHUNK_H_
// Filename: src/sdk/main/include/TopicMessageQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_MESSAGE_QUERY_H_
#define HIERO_SDK_CPP_TOPIC_MESSAGE_QUERY_H_

#include <chrono>
#include <functional>
#include <memory>

namespace grpc
{
class Status;
}

namespace Hiero
{
class Client;
class SubscriptionHandle;
class TopicId;
class TopicMessage;
}

namespace Hiero
{
/**
 * Subscribe to a topic ID's messages from a mirror node. You will receive all messages for the specified topic or
 * within the defined start and end time.
 */
class TopicMessageQuery
{
public:
  TopicMessageQuery();
  ~TopicMessageQuery();

  /**
   * Copy constructor and assignment operator only copy fields, they do not copy subscription processing.
   */
  TopicMessageQuery(const TopicMessageQuery&);
  TopicMessageQuery& operator=(const TopicMessageQuery&);
  TopicMessageQuery(TopicMessageQuery&&) noexcept;
  TopicMessageQuery& operator=(TopicMessageQuery&&) noexcept;

  /**
   * Subscribe to messages sent on this topic ID set in this TopicMessageQuery.
   *
   * @param client The Client to use which contains the correct network to subscribe.
   * @param onNext The function to call when a message is received.
   * @return The SubscriptionHandle for this TopicMessageQuery.
   */
  std::shared_ptr<SubscriptionHandle> subscribe(const Client& client,
                                                const std::function<void(const TopicMessage&)>& onNext);

  /**
   * Set the ID of the topic from which to get messages.
   *
   * @param topicId The ID of the topic from which to get messages.
   * @return A reference to this TopicMessageQuery object with the newly-set topic ID.
   */
  TopicMessageQuery& setTopicId(const TopicId& topicId);

  /**
   * Set the start time which defines the earliest point from which messages are received.
   *
   * @param start The time which defines the earliest point from which messages are received.
   * @return A reference to this TopicMessageQuery object with the newly-set start time.
   */
  TopicMessageQuery& setStartTime(const std::chrono::system_clock::time_point& start);

  /**
   * Set the end time which defines the latest point from which messages are received.
   *
   * @param end The time which defines the latest point from which messages are received.
   * @return A reference to this TopicMessageQuery object with the newly-set end time.
   */
  TopicMessageQuery& setEndTime(const std::chrono::system_clock::time_point& end);

  /**
   * Set the maximum number of messages to return.
   *
   * @param limit The maximum number of messages to return.
   * @return A reference to this TopicMessageQuery object with the newly-set message limit.
   */
  TopicMessageQuery& setLimit(uint64_t limit);

  /**
   * Set the maximum amount of attempts to try and retrieve messages.
   *
   * @param attempts The maximum amount of attempts to try and retrieve messages.
   * @return A reference to this TopicMessageQuery object with the newly-set maximum attempt amount.
   */
  TopicMessageQuery& setMaxAttempts(uint32_t attempts);

  /**
   * Set the maximum amount of time to wait between submission attempts.
   *
   * @param backoff The maximum amount of time to wait between submission attempts.
   * @return A reference to this TopicMessageQuery object with the newly-set maximum backoff.
   */
  TopicMessageQuery& setMaxBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Set the function to run if there's an error with gRPC communication.
   *
   * @param func The function to run in case of errors.
   * @return A reference to this TopicMessageQuery object with the newly-set error handler.
   */
  TopicMessageQuery& setErrorHandler(const std::function<void(grpc::Status)>& func);

  /**
   * Set the function to run if after an error, a retry should occur. \c TRUE is used to indicate a retry should occur.
   *
   * @param func The function to run to determine if a retry should occur.
   * @return A reference to this TopicMessageQuery object with the newly-set retry handler.
   */
  TopicMessageQuery& setRetryHandler(const std::function<bool(grpc::Status)>& func);

  /**
   * Set the function to run upon completion of the RPC.
   *
   * @param func The function to run upon completion of the RPC.
   * @return A reference to this TopicMessageQuery object with the newly-set completion handler.
   */
  TopicMessageQuery& setCompletionHandler(const std::function<void(void)>& func);

  /**
   * Get the ID of the topic from which to get messages.
   *
   * @return The ID of the topic from which to get messages.
   */
  [[nodiscard]] TopicId getTopicId() const;

  /**
   * Get the start time which defines the earliest point from which messages are received.
   *
   * @return The start time which defines the earliest point from which messages are received.
   */
  [[nodiscard]] std::chrono::system_clock::time_point getStartTime() const;

  /**
   * Get the end time which defines the latest point from which messages are received.
   *
   * @return The end time which defines the latest point from which messages are received.
   */
  [[nodiscard]] std::chrono::system_clock::time_point getEndTime() const;

  /**
   * Get the maximum number of messages to return.
   *
   * @return The maximum number of messages to return.
   */
  [[nodiscard]] uint64_t getLimit() const;

  /**
   * Get the maximum amount of attempts to try and retrieve messages.
   *
   * @return The maximum amount of attempts to try and retrieve messages.
   */
  [[nodiscard]] uint32_t getMaxAttempts() const;

  /**
   * Get the maximum amount of time to wait between submission attempts.
   *
   * @return The maximum amount of time to wait between submission attempts.
   */
  [[nodiscard]] std::chrono::system_clock::duration getMaxBackoff() const;

private:
  /**
   * Implementation object used to hide implementation details and internal headers.
   */
  struct TopicMessageQueryImpl;
  std::unique_ptr<TopicMessageQueryImpl> mImpl;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOPIC_MESSAGE_QUERY_H_
// Filename: src/sdk/main/include/TopicMessageSubmitTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_MESSAGE_SUBMIT_TRANSACTION_H_
#define HIERO_SDK_CPP_TOPIC_MESSAGE_SUBMIT_TRANSACTION_H_

#include "ChunkedTransaction.h"
#include "CustomFeeLimit.h"
#include "TopicId.h"
#include "TransactionId.h"

#include <cstddef>
#include <string_view>
#include <vector>

namespace proto
{
class ConsensusSubmitMessageTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that submits a topic message to the Hiero network. To access the messages submitted to a topic ID,
 * subscribe to the topic via a mirror node. The mirror node will publish the ordered messages to subscribers. Once the
 * transaction is successfully executed, the receipt of the transaction will include the topic's updated sequence number
 * and topic running hash.
 *
 * Transaction Signing Requirements:
 *  - Anyone can submit a message to a public topic.
 *  - The submit key is required to sign the transaction for a private topic.
 */
class TopicMessageSubmitTransaction : public ChunkedTransaction<TopicMessageSubmitTransaction>
{
public:
  TopicMessageSubmitTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ConsensusSubmitMessage transaction.
   */
  explicit TopicMessageSubmitTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TopicMessageSubmitTransaction(
    const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the topic to which to submit a message.
   *
   * @param topicId The ID of the topic to which to submit a message.
   * @return A reference to this TopicMessageSubmitTransaction object with the newly-set topic ID.
   * @throws IllegalStateException If this TopicMessageSubmitTransaction is frozen.
   */
  TopicMessageSubmitTransaction& setTopicId(const TopicId& topicId);

  /**
   * Set the message to submit.
   *
   * @param message The message to submit.
   * @return A reference to this TopicMessageSubmitTransaction object with the newly-set message.
   * @throws IllegalStateException If this TopicMessageSubmitTransaction is frozen.
   */
  TopicMessageSubmitTransaction& setMessage(const std::vector<std::byte>& message);
  TopicMessageSubmitTransaction& setMessage(std::string_view message);

  /**
   * Set the maximum custom fees that the user is willing to pay for the transaction.
   *
   * @param customFeeLimits The list of maximum custom fees.
   * @return A reference to this derived Transaction object with the newly-set custom fee limits.
   * @throws IllegalStateException If this Transaction is frozen.
   */
  TopicMessageSubmitTransaction& setCustomFeeLimits(const std::vector<CustomFeeLimit>& customFeeLimits);

  /**
   * Add a maximum custom fee that the user is willing to pay for the transaction.
   *
   * @param customFeeLimit The custom fee limit to be added.
   * @return A reference to this derived Transaction object with the newly-added custom fee limit.
   * @throws IllegalStateException If this Transaction is frozen.
   */
  TopicMessageSubmitTransaction& addCustomFeeLimit(const CustomFeeLimit& customFeeLimit);

  /**
   * Clear all maximum custom fees that the user is willing to pay for the transaction.
   *
   * @return A reference to this derived Transaction object with cleared custom fee limits.
   * @throws IllegalStateException If this Transaction is frozen.
   */
  TopicMessageSubmitTransaction& clearCustomFeeLimits();

  /**
   * Get the ID of the topic to which to submit a message.
   *
   * @return The ID of the topic to which to submit a message.
   */
  [[nodiscard]] inline TopicId getTopicId() const { return mTopicId; }

  /**
   * Get the message to submit.
   *
   * @return The message to submit.
   */
  [[nodiscard]] inline std::vector<std::byte> getMessage() const { return getData(); }

  /**
   * Get the maximum custom fees that the user is willing to pay for the transaction.
   *
   * @return A vector containing the current custom fee limits.
   */
  [[nodiscard]] std::vector<CustomFeeLimit> getCustomFeeLimits() const;

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TopicMessageSubmitTransaction's
   * data to a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TopicMessageSubmitTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TopicMessageSubmitTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TopicMessageSubmitTransaction protobuf representation to the
   * Transaction protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Derived from ChunkedTransaction. Build and add this TopicMessageSubmitTransaction's chunked protobuf representation
   * to the TransactionBody protobuf object.
   *
   * @param chunk The chunk number.
   * @param total The total number of chunks being created.
   * @param body  The TransactionBody protobuf object to which to add the chunked data.
   */
  void addToChunk(uint32_t chunk, uint32_t total, proto::TransactionBody& body) const override;

  /**
   * Initialize this TopicMessageSubmitTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ConsensusSubmitMessageTransactionBody protobuf object from this TopicMessageSubmitTransaction object.
   * Optionally, build this TopicMessageSubmitTransaction for a specific chunk.
   *
   * @param chunk The chunk number for which to build this TopicMessageSubmitTransaction. The default value (-1)
   *              indicates to build for all chunks (i.e. build with all data).
   * @return A pointer to a ConsensusSubmitMessageTransactionBody protobuf object filled with this
   *         TopicMessageSubmitTransaction object's data.
   */
  [[nodiscard]] proto::ConsensusSubmitMessageTransactionBody* build(int chunk = -1) const;

  /**
   * The ID of the topic to which to send a message.
   */
  TopicId mTopicId;

  /**
   * A list of maximum custom fees that the users are willing to pay.
   * This field is OPTIONAL.
   * If left empty, the users are accepting to pay any custom fee.
   * If used with a transaction type that does not support custom fee limits, the transaction will fail.
   */
  std::vector<CustomFeeLimit> mCustomFeeLimits;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOPIC_MESSAGE_SUBMIT_TRANSACTION_H_
// Filename: src/sdk/main/include/TopicUpdateTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TOPIC_UPDATE_TRANSACTION_H_
#define HIERO_SDK_CPP_TOPIC_UPDATE_TRANSACTION_H_

#include "AccountId.h"
#include "CustomFixedFee.h"
#include "Key.h"
#include "TopicId.h"
#include "Transaction.h"

#include <chrono>
#include <memory>
#include <optional>
#include <string>
#include <string_view>

namespace proto
{
class ConsensusUpdateTopicTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * A transaction that updates the properties of an existing topic. This includes the topic memo, admin key, submit key,
 * auto-renew account, and auto-renew period.
 *
 * Transaction Signing Requirements:
 *  - If an admin key is updated, the transaction must be signed by the pre-update admin key and post-update admin key.
 *  - If an admin key was set during the creation of the topic, the admin key must sign the transaction to update any
 *    of the topic's properties.
 *  - If no adminKey was defined during the creation of the topic, you can only extend the expirationTime.
 */
class TopicUpdateTransaction : public Transaction<TopicUpdateTransaction>
{
public:
  TopicUpdateTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a ConsensusUpdateTopic transaction.
   */
  explicit TopicUpdateTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TopicUpdateTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Set the ID of the topic to update.
   *
   * @param topicId The ID of the topic to update.
   * @return A reference to this TopicUpdateTransaction object with the newly-set topic ID.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setTopicId(const TopicId& topicId);

  /**
   * Set a new memo for the topic.
   *
   * @param memo The new memo for the topic.
   * @return A reference to this TopicUpdateTransaction object with the newly-set memo.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setMemo(std::string_view memo);

  /**
   * Set a new expiration time for the topic.
   *
   * @param expiry The new expiration time for the topic.
   * @return A reference to this TopicUpdateTransaction object with the newly-set expiration time.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setExpirationTime(const std::chrono::system_clock::time_point& expiry);

  /**
   * Set a new admin key for the topic.
   *
   * @param key The new admin key for the topic.
   * @return A reference to this TopicUpdateTransaction object with the newly-set admin key.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setAdminKey(const std::shared_ptr<Key>& key);

  /**
   * Set a new submit key for the topic.
   *
   * @param key The new submit key for the topic.
   * @return A reference to this TopicUpdateTransaction object with the newly-set submit key.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setSubmitKey(const std::shared_ptr<Key>& key);

  /**
   * Set a new auto-renew period for the topic.
   *
   * @param autoRenew The new auto-renew period for the topic.
   * @return A reference to this TopicUpdateTransaction object with the newly-set auto-renew period.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setAutoRenewPeriod(const std::chrono::system_clock::duration& autoRenew);

  /**
   * Set the ID of a new auto-renew account for the topic.
   *
   * @param accountId The ID of the new auto-renew account for the topic.
   * @return A reference to this TopicUpdateTransaction object with the newly-set auto-renew account ID.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setAutoRenewAccountId(const AccountId& accountId);

  /**
   * Set the new fee schedule key for the topic.
   *
   * @param key The new fee schedule key.
   * @return A reference to this TopicUpdateTransaction object with the newly-set fee schedule key.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setFeeScheduleKey(const std::shared_ptr<Key>& key);

  /**
   * Set the list of fee-exempt keys for the topic.
   *
   * @param keys The list of fee-exempt keys.
   * @return A reference to this TopicUpdateTransaction object with the newly-set fee-exempt keys.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setFeeExemptKeys(const std::vector<std::shared_ptr<Key>>& keys);

  /**
   * Add a key to the list of fee-exempt keys for the topic.
   *
   * @param key The key to add to the exempt list.
   * @return A reference to this TopicUpdateTransaction object with the newly-added exempt key.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& addFeeExemptKey(const std::shared_ptr<Key>& key);

  /**
   * Set the custom fixed fees for the topic.
   *
   * @param fees The new custom fixed fees.
   * @return A reference to this TopicUpdateTransaction object with the newly-set custom fixed fees.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& setCustomFixedFees(const std::vector<CustomFixedFee>& fees);

  /**
   * Add a custom fixed fee to the topic.
   *
   * @param fee The custom fixed fee to add.
   * @return A reference to this TopicUpdateTransaction object with the newly-added custom fixed fee.
   * @throws IllegalStateException If this TopicUpdateTransaction is frozen.
   */
  TopicUpdateTransaction& addCustomFixedFee(const CustomFixedFee& fee);

  /**
   * Clear the memo for the topic.
   *
   * @return A reference to this TokenUpdateTransaction with the newly-cleared memo.
   */
  TopicUpdateTransaction& clearTopicMemo();

  /**
   * Clear the admin key for the topic.
   *
   * @return A reference to this TokenUpdateTransaction with the newly-cleared admin key.
   */
  TopicUpdateTransaction& clearAdminKey();

  /**
   * Clear the submit key for the topic.
   *
   * @return A reference to this TokenUpdateTransaction with the newly-cleared submit key.
   */
  TopicUpdateTransaction& clearSubmitKey();

  /**
   * Clear the auto-renew account for the topic.
   *
   * @return A reference to this TokenUpdateTransaction with the newly-cleared auto-renew account ID.
   */
  TopicUpdateTransaction& clearAutoRenewAccountId();

  /**
   * Get the ID of the topic to update.
   *
   * @return The ID of the topic to update.
   */
  [[nodiscard]] inline TopicId getTopicId() const { return mTopicId; }

  /**
   * Get the new memo for the topic.
   *
   * @return The new memo for the topic. Returns uninitialized if the memo has not been set.
   */
  [[nodiscard]] inline std::optional<std::string> getMemo() const { return mMemo; }

  /**
   * Get the new expiration time for the topic.
   *
   * @return The new expiration time for the topic. Returns uninitialized if the expiration time has not been set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::time_point> getExpirationTime() const
  {
    return mExpirationTime;
  }

  /**
   * Get the new admin key for the topic.
   *
   * @return The new admin key for the topic. Returns nullptr if the submit key has not been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getAdminKey() const { return mAdminKey; }

  /**
   * Get the new submit key for the topic.
   *
   * @return The new submit key for the topic. Returns nullptr if the submit key has not been set.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getSubmitKey() const { return mSubmitKey; }

  /**
   * Get the desired fee schedule key for the new topic.
   *
   * @return The fee schedule key for the new topic.
   */
  [[nodiscard]] inline std::shared_ptr<Key> getFeeScheduleKey() const { return mFeeScheduleKey; }

  /**
   * Get the list of fee-exempt keys for the new topic.
   *
   * @return The list of fee-exempt keys.
   */
  [[nodiscard]] inline std::vector<std::shared_ptr<Key>> getFeeExemptKeys() const { return mFeeExemptKeys; }

  /**
   * Get the list of custom fixed fees for the new topic.
   *
   * @return The list of custom fixed fees.
   */
  [[nodiscard]] inline std::vector<CustomFixedFee> getCustomFixedFees() const { return mCustomFixedFees; }

  /**
   * Get the new auto-renew period for the topic.
   *
   * @return The new auto-renew period for the topic. Returns uninitialized if the auto-renew period has not been set.
   */
  [[nodiscard]] inline std::optional<std::chrono::system_clock::duration> getAutoRenewPeriod() const
  {
    return mAutoRenewPeriod;
  }

  /**
   * Get the ID of the new auto-renew account for the topic.
   *
   * @return The ID of the new auto-renew account for the topic. Returns uninitialized if the auto-renew account has not
   *         been set.
   */
  [[nodiscard]] inline std::optional<AccountId> getAutoRenewAccountId() const { return mAutoRenewAccountId; }

private:
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TopicUpdateTransaction's data to
   * a Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TopicUpdateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TopicUpdateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TopicUpdateTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TopicUpdateTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a ConsensusUpdateTopicTransactionBody protobuf object from this TopicUpdateTransaction object.
   *
   * @return A pointer to a ConsensusUpdateTopicTransactionBody protobuf object filled with this TopicUpdateTransaction
   *         object's data.
   */
  [[nodiscard]] proto::ConsensusUpdateTopicTransactionBody* build() const;

  /**
   * The ID of the topic to update.
   */
  TopicId mTopicId;

  /**
   * The new publicly visible memo for the topic.
   */
  std::optional<std::string> mMemo;

  /**
   * The new expiration time for the topic.
   */
  std::optional<std::chrono::system_clock::time_point> mExpirationTime;

  /**
   * The new key to be used for access control to update or delete the topic.
   */
  std::shared_ptr<Key> mAdminKey = nullptr;

  /**
   * The new key that must sign to submit a message to the topic (via a TopicMessageSubmitTransaction).
   */
  std::shared_ptr<Key> mSubmitKey = nullptr;

  /**
   * The new amount of time by which to attempt to extend the topic's lifetime automatically at its expiration time.
   */
  std::optional<std::chrono::system_clock::duration> mAutoRenewPeriod;

  /**
   * The ID of the new account that should be charged to extend the lifetime of the topic at its expiration time.
   */
  std::optional<AccountId> mAutoRenewAccountId;

  /**
   * Access control for update or delete of custom fees.
   * If set, subsequent `consensus_update_topic` transactions signed with this
   * key MAY update or delete the custom fees for this topic.
   * If not set, the custom fees for this topic SHALL BE immutable.
   * If not set when the topic is created, this field CANNOT be set via update.
   * If set when the topic is created, this field MAY be changed via update.
   */
  std::shared_ptr<Key> mFeeScheduleKey = nullptr;

  /**
   * A set of keys.
   * Keys in this list are permitted to submit messages to this topic without
   * paying custom fees associated with this topic.
   * If a submit transaction is signed by _any_ key included in this set,
   * custom fees SHALL NOT be charged for that transaction.
   * This field MUST NOT contain more than 10 keys.
   * fee_exempt_key_list SHALL NOT contain any duplicate keys.
   * fee_exempt_key_list MAY contain keys for accounts that are inactive,
   * deleted, or non-existent.
   * If fee_exempt_key_list is unset in this transaction, there SHALL NOT be
   * any fee-exempt keys.  In particular, the following keys SHALL NOT be
   * implicitly or automatically added to this list:
   * `adminKey`, `submitKey`, `fee_schedule_key`.
   */
  std::vector<std::shared_ptr<Key>> mFeeExemptKeys;

  /**
   * A set of custom fee definitions.
   * These are fees to be assessed for each submit to this topic.
   * Each fee defined in this set SHALL be evaluated for
   * each message submitted to this topic, and the resultant
   * total assessed fees SHALL be charged.
   * Custom fees defined here SHALL be assessed in addition to the base
   * network and node fees.
   * custom_fees list SHALL NOT contain more than
   * `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
   */
  std::vector<CustomFixedFee> mCustomFixedFees;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TOPIC_UPDATE_TRANSACTION_H_
// Filename: src/sdk/main/include/Transaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSACTION_H_
#define HIERO_SDK_CPP_TRANSACTION_H_

#include "AccountId.h"
#include "Executable.h"
#include "Hbar.h"
#include "TransactionId.h"

#include <chrono>
#include <functional>
#include <map>
#include <memory>
#include <string>
#include <utility>
#include <variant>
#include <vector>

namespace Hiero
{
class PrivateKey;
class TransactionResponse;
class ScheduleCreateTransaction;
class WrappedTransaction;
}

namespace proto
{
class SchedulableTransactionBody;
class SignedTransaction;
class Transaction;
class TransactionBody;
class TransactionResponse;
}

namespace Hiero
{
/**
 * Base class for all transactions that can be submitted to a Hiero network.
 *
 * @tparam SdkRequestType The SDK request type.
 */
template<typename SdkRequestType>
class Transaction
  : public Executable<SdkRequestType, proto::Transaction, proto::TransactionResponse, TransactionResponse>
{
public:
  /**
   * Construct a Transaction derived class from a byte array. The bytes can be a protobuf encoded TransactionList,
   * Transaction, or TransactionBody. Since C++ return types must be known at compile time and the type of Transaction
   * to create may not be known at compile time, a WrappedTransaction is used to encompass all possible Transactions in
   * a std::variant. Usage of this return type would look like the following:
   *
   * std::vector<std::byte> bytes = {...};
   *                                                                    The Transaction type here doesn't matter and is
   *                                           vvvvvvvvvvvvvvvvvvvvvvvv an unfortunate, ugly byproduct of this approach.
   * const WrappedTransaction tx = Transaction<AccountCreateTransaction>::fromBytes(bytes);
   *
   * switch (tx.getTransactionType())
   * {
   *    case TransactionType::ACCOUNT_CREATE_TRANSACTION:
   *    {
   *        AccountCreateTransaction* accountCreateTransaction = tx.getTransaction<AccountCreateTransaction>();
   *        ** do stuff with tx here **
   *        break;
   *    }
   *    case TransactionType::TRANSFER_TRANSACTION:
   *    {
   *        TransferTransaction* transferTransaction = tx.getTransaction<TransferTransaction>();
   *        ** do stuff with tx here **
   *        break;
   *    }
   *    ...
   * }
   *
   * @param bytes The bytes from which to construct a Transaction.
   * @return A WrappedTransaction which contains the deserialized Transaction.
   * @throws std::invalid_argument If unable to construct a Transaction from the input bytes.
   */
  [[nodiscard]] static WrappedTransaction fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a representative byte array from this Transaction object.
   *
   * @return The byte array representing this Transaction object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Sign this Transaction with the given PrivateKey. Signing a Transaction with a key that has already been used to
   * sign will be ignored.
   *
   * @param key The PrivateKey with which to sign this Transaction.
   * @return A reference to this derived Transaction object with the signature.
   * @throws IllegalStateException If this Transaction object is not frozen.
   * @throws std::invalid_argument If the signing key is not set.
   */
  SdkRequestType& sign(const std::shared_ptr<PrivateKey>& key);

  /**
   * Sign this Transaction with a given PublicKey and a signing callback. Signing a Transaction with a key that has
   * already been used to sign will be ignored.
   *
   * @param key    The PublicKey with which to sign this Transaction.
   * @param signer The callback function to use to sign this Transaction.
   * @return A reference to this derived Transaction object with the signature.
   * @throws IllegalStateException If this Transaction object is not frozen.
   */
  SdkRequestType& signWith(const std::shared_ptr<PublicKey>& key,
                           const std::function<std::vector<std::byte>(const std::vector<std::byte>&)>& signer);

  /**
   * Sign this Transaction with a configured Client. This will freeze this Transaction if it is not already frozen.
   *
   * @param client The Client with which to sign this Transaction.
   * @return A reference to this derived Transaction object with the client signature.
   * @throws UninitializedException If the input Client operator has not been initialized.
   */
  SdkRequestType& signWithOperator(const Client& client);

  /**
   * Add a signature to this Transaction.
   *
   * @param publicKey The associated PublicKey of the PrivateKey that generated the signature.
   * @param signature The signature to add.
   * @return A reference to this derived Transaction object with the newly-added signature.
   * @throws IllegalStateException If there is not exactly one node account ID set or if this Transaction is not frozen.
   */
  virtual SdkRequestType& addSignature(const std::shared_ptr<PublicKey>& publicKey,
                                       const std::vector<std::byte>& signature);

  /**
   * Get the signatures of each potential Transaction protobuf object this Transaction may send.
   *
   * @return The map of node account IDs to their PublicKeys and signatures.
   */
  [[nodiscard]] virtual std::map<AccountId, std::map<std::shared_ptr<PublicKey>, std::vector<std::byte>>>
  getSignatures() const;

  /**
   * Freeze this Transaction.
   *
   * @return A reference to this derived Transaction object, now frozen.
   * @throws IllegalStateException If this Transaction's TransactionId and node account IDs have not been manually set.
   */
  SdkRequestType& freeze();

  /**
   * Freeze this transaction with a Client. The Client's operator will be used to generate a transaction ID, and the
   * Client's network will be used to generate a list of node account IDs.
   *
   * @param client A pointer to the Client with which to freeze this Transaction.
   * @return A reference to this derived Transaction object, now frozen.
   * @throws UninitializedException If the input Client operator has not been initialized.
   */
  SdkRequestType& freezeWith(const Client* client);

  /**
   * Put this Transaction in a ScheduleCreateTransaction.
   *
   * @return This Transaction put in a ScheduleCreateTransaction.
   * @throws IllegalStateException If this Transaction has node account IDs already set.
   */
  [[nodiscard]] ScheduleCreateTransaction schedule() const;

  /**
   * Get the SHA384 hash of this Transaction.
   *
   * @return The SHA384 hash of this Transaction.
   * @throws IllegalStateException If this Transaction is not frozen.
   */
  [[nodiscard]] virtual std::vector<std::byte> getTransactionHash() const;

  /**
   * Get the SHA384 hash of each potential Transaction protobuf object this Transaction may send.
   *
   * @return The map of node account IDs to the SHA384 hash of their Transaction.
   * @throws IllegalStateException If this Transaction is not frozen.
   */
  [[nodiscard]] virtual std::map<AccountId, std::vector<std::byte>> getTransactionHashPerNode() const;

  /**
   * Require that this Transaction has exactly one node account ID set.
   *
   * @throws IllegalStateException If there is not exactly one node account ID set.
   */
  void requireOneNodeAccountId() const;

  /**
   * Set the ID for this Transaction.
   *
   * @param id The desired transaction ID for this Transaction.
   * @return A reference to this derived Transaction object with the newly-set transaction ID.
   * @throws IllegalStateException If this Transaction is frozen.
   */
  SdkRequestType& setTransactionId(const TransactionId& id);

  /**
   * Derived from Executable. Set the desired account IDs of nodes to which this Transaction will be submitted. This is
   * not different from Executable::setNodeAccountIds() other than it checks to make sure the Transaction isn't frozen
   * and throws if it is.
   *
   * @param nodeAccountIds The desired list of account IDs of nodes to submit this Transaction.
   * @return A reference to this Executable derived class with the newly-set node account IDs.
   * @throws IllegalStateException If this Transaction is frozen.
   */
  SdkRequestType& setNodeAccountIds(std::vector<AccountId> nodeAccountIds) override;

  /**
   * Set the maximum transaction fee willing to be paid to execute this Transaction.
   *
   * @param fee The desired maximum transaction fee willing to be paid to execute this Transaction.
   * @return A reference to this derived Transaction object with the newly-set maximum transaction fee.
   * @throws IllegalStateException If this Transaction is frozen.
   */
  SdkRequestType& setMaxTransactionFee(const Hbar& fee);

  /**
   * Set the length of time that this Transaction will remain valid.
   *
   * @param duration The desired length of time to keep this Transaction valid.
   * @return A reference to this derived Transaction object with the newly-set valid duration.
   * @throws IllegalStateException If this Transaction is frozen.
   */
  SdkRequestType& setValidTransactionDuration(const std::chrono::system_clock::duration& duration);

  /**
   * Set the memo for this Transaction.
   *
   * @param memo The desired memo for this Transaction.
   * @return A reference to this derived Transaction object with the newly-set memo.
   * @throws IllegalStateException If this Transaction is frozen.
   */
  SdkRequestType& setTransactionMemo(const std::string& memo);

  /**
   * Set the transaction ID regeneration policy for this Transaction.
   *
   * @param regenerate \c TRUE if it is desired for this Transaction to regenerate a transaction ID upon receiving a
   *                   TRANSACTION_EXPIRED response from the network after submission, otherwise \c FALSE.
   * @return A reference to this derived Transaction object with the newly-set transaction ID regeneration policy.
   * @throws IllegalStateException If this Transaction is frozen.
   */
  SdkRequestType& setRegenerateTransactionIdPolicy(bool regenerate);

  /**
   * Get the ID of this Transaction.
   *
   * @return The ID of this Transaction.
   * @throws IllegalStateException If no TransactionId has been generated or set yet.
   */
  [[nodiscard]] TransactionId getTransactionId() const;

  /**
   * Get the maximum transaction fee willing to be paid to execute this Transaction. If not set manually, this
   * Transaction will use the max transaction fee set in the Client used to submit this Transaction upon execution.
   * If a Client max transaction fee has not been set, then the default max transaction fee will be used.
   *
   * @return The maximum transaction fee willing to be paid.
   */
  [[nodiscard]] Hbar getMaxTransactionFee() const;

  /**
   * Get the default maximum transaction fee. This can change between Transactions depending on their cost.
   *
   * @return The default maximum transaction fee.
   */
  [[nodiscard]] Hbar getDefaultMaxTransactionFee() const;

  /**
   * Get the desired length of time for this Transaction to remain valid upon submission. If not set manually,
   * DEFAULT_TRANSACTION_VALID_DURATION will be used.
   *
   * @return The length of time this Transaction will remain valid.
   */
  [[nodiscard]] std::chrono::system_clock::duration getValidTransactionDuration() const;

  /**
   * Get the memo for this Transaction.
   *
   * @return The memo for this Transaction.
   */
  [[nodiscard]] std::string getTransactionMemo() const;

  /**
   * Get the desired transaction ID regeneration policy of this Transaction.
   *
   * @return \c TRUE if this Transaction should regenerate its transaction ID upon receipt of a TRANSACTION_EXPIRED
   *         response from the network, \c FALSE if this Transaction shouldn't regenerate its transaction ID, and
   *         uninitialized if this Transaction will follow the default behavior.
   */
  [[nodiscard]] std::optional<bool> getRegenerateTransactionIdPolicy() const;

protected:
  /**
   * Dummy transaction and account IDs used to assist in deserializing incomplete Transactions.
   */
  static inline const AccountId DUMMY_ACCOUNT_ID = AccountId(0ULL, 0ULL, 0ULL);
  static inline const TransactionId DUMMY_TRANSACTION_ID =
    TransactionId::withValidStart(DUMMY_ACCOUNT_ID, std::chrono::system_clock::time_point());

  Transaction();
  ~Transaction();
  Transaction(const Transaction&);
  Transaction& operator=(const Transaction&);
  Transaction(Transaction&&) noexcept;
  Transaction& operator=(Transaction&&) noexcept;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param txBody The TransactionBody protobuf object from which to construct.
   */
  explicit Transaction(const proto::TransactionBody& txBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   * Assuming the input map isn't empty, this Transaction will set its values based on the values in the first
   * TransactionId -> [AccountId, proto::Transaction] mapping and ignore the rest.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit Transaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Derived from Executable. Construct a Transaction protobuf object from this Transaction, based on the node account
   * ID at the given index.
   *
   * @param index The index of the node account ID that's associated with the Node being used to execute this
   *              Transaction.
   * @return A Transaction protobuf object filled with this Transaction's data, based on the node account ID at the
   *         given index.
   */
  [[nodiscard]] proto::Transaction makeRequest(unsigned int index) const override;

  /**
   * Build all Transaction protobuf objects for this Transaction, each going to a different previously-selected node.
   */
  void buildAllTransactions() const;

  /**
   * Update mSourceTransactionBody. This will update all fields of mSourceTransactionBody except the transaction ID and
   * the node account ID.
   *
   * @param client A pointer to the Client that will sign and submit this Transaction.
   */
  void updateSourceTransactionBody(const Client* client) const;

  /**
   * Regenerate the SignedTransaction protobuf objects for this Transaction.
   *
   * @param client A pointer to the Client to use to regenerate the SignedTransaction protobuf objects.
   */
  virtual void regenerateSignedTransactions(const Client* client) const;

  /**
   * Add a Transaction or SignedTransaction protobuf object to this Transaction's Transaction or SignedTransaction
   * protobuf object list, respectively. If a Transaction protobuf object is being added, it will also parse a
   * SignedTransaction protobuf object from the Transaction protobuf object and add that SignedTransaction protobuf
   * object to this Transaction's SignedTransaction protobuf object list.
   *
   * @param transaction The Transaction or SignedTransaction protobuf object to add to this Transaction.
   */
  void addTransaction(const proto::Transaction& transaction) const;
  void addTransaction(const proto::SignedTransaction& transaction) const;

  /**
   * Add a SignedTransaction protobuf object created from the input TransactionBody protobuf object for each node
   * account ID of this Transaction. It is expected that every field in the input TransactionBody protobuf object is
   * valid except the node account ID field, which will be filled by the function.
   *
   * @param transaction The TransactionBody protobuf object from which to construct the SignedTransaction protobuf
   *                    objects.
   */
  void addSignedTransactionForEachNode(proto::TransactionBody transactionBody) const;

  /**
   * Clear the SignedTransaction and Transaction protobuf objects held by this Transaction.
   */
  virtual void clearTransactions() const;

  /**
   * Check and make sure this Transaction isn't frozen.
   *
   * @throws IllegalStateException If this Transaction is frozen.
   */
  void requireNotFrozen() const;

  /**
   * Is this Transaction frozen?
   *
   * @return \c TRUE if this Transaction is frozen, otherwise \c FALSE.
   */
  [[nodiscard]] bool isFrozen() const;

  /**
   * Set the default maximum transaction fee for this Transaction.
   *
   * @param fee The default maximum transaction fee for this Transaction.
   */
  void setDefaultMaxTransactionFee(const Hbar& fee);

  /**
   * Get the signatures of the Transaction protobuf object at the specified offset.
   *
   * @param offset The offset at which to grab the signatures.
   * @return The map of node account IDs to their PublicKeys and signatures for the specified offset.
   */
  [[nodiscard]] std::map<AccountId, std::map<std::shared_ptr<PublicKey>, std::vector<std::byte>>> getSignaturesInternal(
    size_t offset = 0ULL) const;

  /**
   * Get the Transaction protobuf object located at the given index in the Transaction protobuf object list.
   *
   * @param index The index at which to get the Transaction protobuf object.
   * @return The Transaction protobuf object located at the given index.
   */
  [[nodiscard]] proto::Transaction getTransactionProtobufObject(unsigned int index) const;

  /**
   * Get the source TransactionBody protobuf object from which this Transaction constructed itself.
   *
   * @return The source TransactionBody protobuf object from which this Transaction constructed itself.
   */
  [[nodiscard]] proto::TransactionBody getSourceTransactionBody() const;

  /**
   * Get the ID of this Transaction.
   *
   * @return The ID of this Transaction.
   */
  [[nodiscard]] virtual TransactionId getCurrentTransactionId() const;

private:
  friend class PrivateKey;

  /**
   * Build and add the derived Transaction's protobuf representation to the Transaction protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  virtual void addToBody(proto::TransactionBody& body) const = 0;

  /**
   * Verify that all the checksums in this Transaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This Transaction's checksums are not valid.
   */
  virtual void validateChecksums(const Client& client) const = 0;

  /**
   * Derived from Executable. Construct a TransactionResponse object from a TransactionResponse protobuf object.
   *
   * @param response The TransactionResponse protobuf object from which to construct a TransactionResponse object.
   * @return A TransactionResponse object filled with the TransactionResponse protobuf object's data.
   */
  [[nodiscard]] TransactionResponse mapResponse(const proto::TransactionResponse& response) const override;

  /**
   * Derived from Executable. Get the status response code for a submitted Transaction from a TransactionResponse
   * protobuf object.
   *
   * @param response The TransactionResponse protobuf object from which to grab the Transaction status response code.
   * @return The Transaction status response code of the input TransactionResponse protobuf object.
   */
  [[nodiscard]] Status mapResponseStatus(const proto::TransactionResponse& response) const override;

  /**
   * Derived from Executable. Determine the ExecutionStatus of this Transaction after being submitted.
   *
   * @param status   The response status from the network.
   * @param client   The Client that submitted this Transaction.
   * @param response The TransactionResponse protobuf object received from the network in response to submitting this
   *                 Transaction.
   * @return The status of the submitted Transaction.
   */
  [[nodiscard]]
  typename Executable<SdkRequestType, proto::Transaction, proto::TransactionResponse, TransactionResponse>::
    ExecutionStatus
    determineStatus(Status status,
                    const Client& client,
                    [[maybe_unused]] const proto::TransactionResponse& response) override;

  /**
   * Derived from Executable. Perform any needed actions for this Transaction when it is being submitted.
   *
   * @param client The Client being used to submit this Transaction.
   * @throws UninitializedException If the client doesn't have an AccountId from which to generate a TransactionId.
   */
  void onExecute(const Client& client) override;

  /**
   * Derived from Executable. Get the ID of this Transaction.
   *
   * @return The ID of this Transaction.
   */
  [[nodiscard]] std::optional<TransactionId> getTransactionIdInternal() const override;

  /**
   * Build a Transaction protobuf object from the SignedTransaction protobuf object at the specified index.
   *
   * @param index The index in the Transaction's SignedTransaction list from which the Transaction protobuf object
   *              should be built.
   */
  void buildTransaction(unsigned int index) const;

  /**
   * Determine if a PublicKey has already signed this Transaction.
   *
   * @param publicKey The PublicKey that could have already signed this Transaction.
   * @return \c TRUE if the input PublicKey has already signed this Transaction, otherwise \c FALSE.
   */
  [[nodiscard]] bool keyAlreadySigned(const std::shared_ptr<PublicKey>& publicKey) const;

  /**
   * Add a PublicKey and a signer function to this Transaction, and optionally the PrivateKey from which the signer
   * function was generated.
   *
   * @param publicKey  The PublicKey to add.
   * @param signer     The singer function to add.
   * @param privateKey The PrivateKey to add.
   * @return A reference to this derived Transaction object with the newly-set "signature(s)".
   */
  SdkRequestType& signInternal(const std::shared_ptr<PublicKey>& publicKey,
                               const std::function<std::vector<std::byte>(const std::vector<std::byte>&)>& signer,
                               const std::shared_ptr<PrivateKey>& privateKey = nullptr);

  /**
   * Implementation object used to hide implementation details and internal headers.
   */
  struct TransactionImpl;
  std::unique_ptr<TransactionImpl> mImpl;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TRANSACTION_H_// Filename: src/sdk/main/include/TransactionFeeSchedule.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSACTION_FEE_SCHEDULE_H_
#define HIERO_SDK_CPP_TRANSACTION_FEE_SCHEDULE_H_

#include "FeeData.h"
#include "RequestType.h"

#include <cstddef>
#include <string>
#include <vector>

namespace proto
{
class TransactionFeeSchedule;
}

namespace Hiero
{
/**
 * The fees for a specific transaction or query based on the fee data.
 */
class TransactionFeeSchedule
{
public:
  /**
   * Construct a TransactionFeeSchedule object from a TransactionFeeSchedule protobuf object.
   *
   * @param proto The TransactionFeeSchedule protobuf object from which to construct an TransactionFeeSchedule object.
   * @return The constructed TransactionFeeSchedule object.
   */
  [[nodiscard]] static TransactionFeeSchedule fromProtobuf(const proto::TransactionFeeSchedule& proto);

  /**
   * Construct a TransactionFeeSchedule object from a byte array.
   *
   * @param bytes The byte array from which to construct an TransactionFeeSchedule object.
   * @return The constructed TransactionFeeSchedule object.
   */
  [[nodiscard]] static TransactionFeeSchedule fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a TransactionFeeSchedule protobuf object from this TransactionFeeSchedule object.
   *
   * @return A pointer to the created TransactionFeeSchedule protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::TransactionFeeSchedule> toProtobuf() const;

  /**
   * Construct a representative byte array from this TransactionFeeSchedule object.
   *
   * @return The byte array representing this TransactionFeeSchedule object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this TransactionFeeSchedule object.
   *
   * @return The string representation of this TransactionFeeSchedule object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Set the request type.
   *
   * @param type The request type to set.
   * @return A reference to this TransactionFeeSchedule with the newly-set request type.
   */
  inline TransactionFeeSchedule& setRequestType(RequestType type)
  {
    mRequestType = type;
    return *this;
  }

  /**
   * Add a fee to this TransactionFeeSchedule.
   *
   * @param fee The fee to add.
   * @return A reference to this TransactionFeeSchedule with the newly-added fee.
   */
  inline TransactionFeeSchedule& addFee(const FeeData& fee)
  {
    mFees.push_back(fee);
    return *this;
  }

  /**
   * Get the request type.
   *
   * @return The request type.
   */
  [[nodiscard]] inline RequestType getRequestType() const { return mRequestType; }

  /**
   * Get the fees.
   *
   * @return The fees.
   */
  [[nodiscard]] inline std::vector<FeeData> getFees() const { return mFees; }

private:
  /**
   * The request to which this fee schedule applies.
   */
  RequestType mRequestType;

  /**
   * The resource price coefficients.
   */
  std::vector<FeeData> mFees;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TRANSACTION_FEE_SCHEDULE_H_
// Filename: src/sdk/main/include/TransactionId.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSACTION_ID_H_
#define HIERO_SDK_CPP_TRANSACTION_ID_H_

#include "AccountId.h"

#include <chrono>
#include <cstddef>
#include <functional>
#include <future>
#include <string>
#include <string_view>
#include <vector>

namespace proto
{
class TransactionID;
}

namespace Hiero
{
class Client;
class TransactionReceipt;
class TransactionRecord;
}

namespace Hiero
{
/**
 * The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file
 * right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by
 * the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster
 * by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the
 * transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The
 * other transactions will not take effect. So this could make the transaction take effect faster, if any given node
 * might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much
 * if the transaction is sent to N nodes.
 *
 * Applicable to Scheduled Transactions:
 *  - The ID of a Scheduled Transaction has transactionValidStart and accountIDs inherited from the
 *    ScheduleCreate transaction that created it. That is to say that they are equal
 *  - The scheduled property is true for Scheduled Transactions
 *  - transactionValidStart, accountID and scheduled properties should be omitted
 */
class TransactionId
{
public:
  TransactionId() = default;

  /**
   * Generate a new TransactionId.
   *
   * @param accountId The ID of the account to be charged for the execution of the transaction with which this ID will
   *                  be associated.
   * @param start     The valid start time for the transaction.
   * @return A generated TransactionId to be used for any transaction submitted by the account with the input ID.
   */
  [[nodiscard]] static TransactionId withValidStart(const AccountId& accountId,
                                                    const std::chrono::system_clock::time_point& start);

  /**
   * Generate a new TransactionId.
   *
   * @param accountId The ID of the account to be charged for the execution of the transaction with which this ID will
   *                  be associated.
   * @return A generated TransactionId to be used for any transaction submitted by the account with the input ID.
   */
  [[nodiscard]] static TransactionId generate(const AccountId& accountId);

  /**
   * Construct a TransactionId object from a TransactionID protobuf object.
   *
   * @param proto The TransactionID protobuf object from which to construct a TransactionId object.
   * @return The constructed TransactionId object.
   */
  [[nodiscard]] static TransactionId fromProtobuf(const proto::TransactionID& proto);

  /**
   * Construct a TransactionId object from a string of the form "<account>@<seconds>.<nanos>[?scheduled][/nonce]".
   *
   * @param id The transaction ID string from which to construct.
   * @return The constructed TransactionId object.
   * @throws std::invalid_argument If the input string is malformed.
   */
  [[nodiscard]] static TransactionId fromString(std::string_view id);

  /**
   * Construct a TransactionId object from a byte array.
   *
   * @param bytes The byte array from which to construct a TransactionId object.
   * @return The constructed TransactionId object.
   */
  [[nodiscard]] static TransactionId fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Fetch the TransactionReceipt of the transaction this ID represents.
   *
   * @param client The Client to use to fetch the TransactionReceipt.
   * @return The fetched TransactionReceipt.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If the TransactionReceiptQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionReceipt getReceipt(const Client& client) const;

  /**
   * Fetch the TransactionReceipt of the transaction this ID represents with a specified timeout.
   *
   * @param client  The Client to use to fetch the TransactionReceipt.
   * @param timeout The desired timeout for the execution of the TransactionReceiptQuery.
   * @return The fetched TransactionReceipt.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If the TransactionReceiptQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionReceipt getReceipt(const Client& client, const std::chrono::system_clock::duration& timeout) const;

  /**
   * Fetch the TransactionReceipt of the transaction this ID represents asynchronously.
   *
   * @param client The Client to use to fetch the TransactionReceipt.
   * @return The future of the fetched TransactionReceipt.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If the TransactionReceiptQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<TransactionReceipt> getReceiptAsync(const Client& client) const;

  /**
   * Fetch the TransactionReceipt of the transaction this ID represents asynchronously with a specified timeout.
   *
   * @param client  The Client to use to fetch the TransactionReceipt.
   * @param timeout The desired timeout for the execution of the TransactionReceiptQuery.
   * @return The future of the fetched TransactionReceipt.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If the TransactionReceiptQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<TransactionReceipt> getReceiptAsync(const Client& client,
                                                  const std::chrono::system_clock::duration& timeout) const;

  /**
   * Fetch the TransactionReceipt of the transaction this ID represents asynchronously and consume the response and/or
   * exception with a callback.
   *
   * @param client   The Client to use to fetch the TransactionReceipt.
   * @param callback The callback that should consume the response/exception.
   */
  void getReceiptAsync(const Client& client,
                       const std::function<void(const TransactionReceipt&, const std::exception&)>& callback) const;

  /**
   * Fetch the TransactionReceipt of the transaction this ID represents asynchronously with a specific timeout and
   * consume the response and/or exception with a callback.
   *
   * @param client   The Client to use to fetch the TransactionReceipt.
   * @param timeout  The desired timeout for the execution of the TransactionReceiptQuery.
   * @param callback The callback that should consume the response/exception.
   */
  void getReceiptAsync(const Client& client,
                       const std::chrono::system_clock::duration& timeout,
                       const std::function<void(const TransactionReceipt&, const std::exception&)>& callback) const;

  /**
   * Fetch the TransactionReceipt of the transaction this ID represents asynchronously and consume the response and/or
   * exception with separate callbacks.
   *
   * @param client            The Client to use to fetch the TransactionReceipt.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void getReceiptAsync(const Client& client,
                       const std::function<void(const TransactionReceipt&)>& responseCallback,
                       const std::function<void(const std::exception&)>& exceptionCallback) const;

  /**
   * Fetch the TransactionReceipt of the transaction this ID represents asynchronously with a specific timeout and
   * consume the response and/or exception with separate callbacks.
   *
   * @param client            The Client to use to fetch the TransactionReceipt.
   * @param timeout           The desired timeout for the execution of the TransactionReceiptQuery.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void getReceiptAsync(const Client& client,
                       const std::chrono::system_clock::duration& timeout,
                       const std::function<void(const TransactionReceipt&)>& responseCallback,
                       const std::function<void(const std::exception&)>& exceptionCallback) const;

  /**
   * Fetch the TransactionRecord of the transaction this ID represents.
   *
   * @param client The Client to use to fetch the TransactionRecord.
   * @return The fetched TransactionRecord.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If the TransactionRecordQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionRecord getRecord(const Client& client) const;

  /**
   * Fetch the TransactionRecord of the transaction this ID represents with a specified timeout.
   *
   * @param client  The Client to use to fetch the TransactionRecord.
   * @param timeout The desired timeout for the execution of the TransactionRecordQuery.
   * @return The fetched TransactionRecord.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If the TransactionReceiptQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionRecord getRecord(const Client& client, const std::chrono::system_clock::duration& timeout) const;

  /**
   * Fetch the TransactionRecord of the transaction this ID represents asynchronously.
   *
   * @param client The Client to use to fetch the TransactionRecord.
   * @return The future of the fetched TransactionRecord.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If the TransactionRecordQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<TransactionRecord> getRecordAsync(const Client& client) const;

  /**
   * Fetch the TransactionRecord of the transaction this ID represents asynchronously with a specified timeout.
   *
   * @param client  The Client to use to fetch the TransactionRecord.
   * @param timeout The desired timeout for the execution of the TransactionRecordQuery.
   * @return The future of the fetched TransactionRecord.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If the TransactionRecordQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<TransactionRecord> getRecordAsync(const Client& client,
                                                const std::chrono::system_clock::duration& timeout) const;

  /**
   * Fetch the TransactionRecord of the transaction this ID represents asynchronously and consume the response and/or
   * exception with a callback.
   *
   * @param client   The Client to use to fetch the TransactionRecord.
   * @param callback The callback that should consume the response/exception.
   */
  void getRecordAsync(const Client& client,
                      const std::function<void(const TransactionRecord&, const std::exception&)>& callback) const;

  /**
   * Fetch the TransactionRecord of the transaction this ID represents asynchronously with a specific timeout and
   * consume the response and/or exception with a callback.
   *
   * @param client   The Client to use to fetch the TransactionRecord.
   * @param timeout  The desired timeout for the execution of the TransactionRecordQuery.
   * @param callback The callback that should consume the response/exception.
   */
  void getRecordAsync(const Client& client,
                      const std::chrono::system_clock::duration& timeout,
                      const std::function<void(const TransactionRecord&, const std::exception&)>& callback) const;

  /**
   * Fetch the TransactionRecord of the transaction this ID represents asynchronously and consume the response and/or
   * exception with separate callbacks.
   *
   * @param client            The Client to use to fetch the TransactionRecord.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void getRecordAsync(const Client& client,
                      const std::function<void(const TransactionRecord&)>& responseCallback,
                      const std::function<void(const std::exception&)>& exceptionCallback) const;

  /**
   * Fetch the TransactionRecord of the transaction this ID represents asynchronously with a specific timeout and
   * consume the response and/or exception with separate callbacks.
   *
   * @param client            The Client to use to fetch the TransactionRecord.
   * @param timeout           The desired timeout for the execution of the TransactionRecordQuery.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   */
  void getRecordAsync(const Client& client,
                      const std::chrono::system_clock::duration& timeout,
                      const std::function<void(const TransactionRecord&)>& responseCallback,
                      const std::function<void(const std::exception&)>& exceptionCallback) const;

  /**
   * Compare this TransactionId to another TransactionId and determine if they represent the same Transaction.
   *
   * @param other The other TransactionId with which to compare this TransactionId.
   * @return \c TRUE if this TransactionId is the same as the input TransactionId, otherwise \c FALSE.
   */
  bool operator==(const TransactionId& other) const;

  /**
   * Compare this TransactionId to another TransactionId and determine if they represent different Transactions.
   *
   * @param other The other TransactionId with which to compare this TransactionId.
   * @return \c TRUE if this TransactionId is different from the input TransactionId, otherwise \c FALSE.
   */
  bool operator!=(const TransactionId& other) const;

  /**
   * Construct a TransactionID protobuf object from this TransactionId object.
   *
   * @return A pointer to the created TransactionID protobuf object filled with this TransactionId object's data.
   */
  [[nodiscard]] std::unique_ptr<proto::TransactionID> toProtobuf() const;

  /**
   * Get a string representation of this TransactionId object.
   *
   * @return A string representation of this TransactionId.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Get a string representation of this TransactionId object with the account ID checksum.
   *
   * @param client The Client with which to generate the checksum.
   * @return A string representation of this TransactionId with the account ID checksum.
   */
  [[nodiscard]] std::string toStringWithChecksum(const Client& client) const;

  /**
   * Get a byte array representation of this TransactionId object.
   *
   * @return A byte array representation of this TransactionId object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Set if this ID represents a scheduled transaction.
   *
   * @param scheduled \c TRUE if this ID represents a scheduled transaction, otherwise \c FALSE.
   * @return A reference to this TransactionId with the newly-set scheduled.
   */
  TransactionId& setScheduled(bool scheduled);

  /**
   * Set this TransactionId's nonce value.
   *
   * @param nonce The desired nonce value for this TransactionId.
   * @return A reference to this TransactionId with the newly-set nonce.
   */
  TransactionId& setNonce(int nonce);

  /**
   * Get if this ID represents a scheduled transaction.
   *
   * @return \c TRUE if this ID represents a scheduled transaction, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool getScheduled() const { return mScheduled; }

  /**
   * Get this TransactionId's nonce value.
   *
   * @return The nonce value for of TransactionId.
   */
  [[nodiscard]] inline int getNonce() const { return mNonce; }

  /**
   * The time at which the transaction associated with this TransactionId is considered "valid".
   *
   * When a transaction is submitted there is additionally a validDuration (defaults to 120s) and together they define a
   * time window in which the transaction may be processed.
   */
  std::chrono::system_clock::time_point mValidTransactionTime;

  /**
   * The ID of the account that is paying for this transaction associated with this TransactionId.
   */
  AccountId mAccountId;

private:
  /**
   * Construct with an AccountId and a valid transaction start time.
   *
   * @param accountId      The AccountId with which to construct the TransactionId.
   * @param validStartTime The valid start time with which to construct the Transactionid.
   */
  TransactionId(AccountId accountId, const std::chrono::system_clock::time_point& validStartTime);

  /**
   * Get the string with the timestamp, scheduled, and nonce.
   *
   * @return The string with this TransactionId's timestamp, scheduled, and nonce.
   */
  [[nodiscard]] std::string getTimestampScheduleNonceString() const;

  /**
   * Is this the ID of a scheduled transaction?
   */
  bool mScheduled = false;

  /**
   * The nonce value of this child transaction (0 if not a child transaction).
   */
  int mNonce = 0;
};

} // namespace Hiero

namespace std
{
template<>
struct hash<Hiero::TransactionId>
{
  /**
   * Operator override to enable use of TransactionId as map key.
   */
  size_t operator()(const Hiero::TransactionId& id) const { return hash<string>()(id.toString()); }
};

template<>
struct less<Hiero::TransactionId>
{
  /**
   * Operator override to enable use of TransactionId in a std::map, which requires fair ordering.
   */
  bool operator()(const Hiero::TransactionId& lhs, const Hiero::TransactionId& rhs) const
  {
    return lhs.toString() < rhs.toString();
  }
};

} // namespace std

#endif // HIERO_SDK_CPP_TRANSACTION_ID_H_
// Filename: src/sdk/main/include/TransactionReceipt.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSACTION_RECEIPT_H_
#define HIERO_SDK_CPP_TRANSACTION_RECEIPT_H_

#include "AccountId.h"
#include "ContractId.h"
#include "ExchangeRates.h"
#include "FileId.h"
#include "ScheduleId.h"
#include "Status.h"
#include "TokenId.h"
#include "TopicId.h"
#include "TransactionId.h"

#include <cstddef>
#include <memory>
#include <optional>
#include <ostream>
#include <string>
#include <vector>

namespace proto
{
class TransactionGetReceiptResponse;
class TransactionReceipt;
}

namespace Hiero
{
/**
 * The summary of a transaction's result so far. If the transaction has not reached consensus, this result will be
 * necessarily incomplete.
 */
class TransactionReceipt
{
public:
  /**
   * Construct a TransactionReceipt object from a TransactionGetReceiptResponse protobuf object.
   *
   * @param proto         The TransactionGetReceiptResponse protobuf object from which to construct a TransactionReceipt
   *                      object.
   * @param transactionId The ID of the transaction to which the constructed TransactionReceipt will correspond.
   * @return The constructed TransactionReceipt object.
   */
  [[nodiscard]] static TransactionReceipt fromProtobuf(const proto::TransactionGetReceiptResponse& proto,
                                                       const TransactionId& transactionId);

  /**
   * Construct a TransactionReceipt object from a TransactionReceipt protobuf object.
   *
   * @param proto         The TransactionReceipt protobuf object from which to construct a TransactionReceipt object.
   * @param transactionId The ID of the transaction to which the constructed TransactionReceipt will correspond.
   * @return The constructed TransactionReceipt object.
   */
  [[nodiscard]] static TransactionReceipt fromProtobuf(const proto::TransactionReceipt& proto,
                                                       const TransactionId& transactionId = TransactionId());

  /**
   * Construct a TransactionReceipt object from a byte array.
   *
   * @param bytes The byte array from which to construct a TransactionReceipt object.
   * @return The constructed TransactionReceipt object.
   */
  [[nodiscard]] static TransactionReceipt fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a TransactionReceipt protobuf object from this TransactionReceipt object.
   *
   * @return A pointer to the created TransactionReceipt protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::TransactionReceipt> toProtobuf() const;

  /**
   * Construct a representative byte array from this TransactionReceipt object.
   *
   * @return The byte array representing this TransactionReceipt object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this TransactionReceipt object.
   *
   * @return The string representation of this TransactionReceipt object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this TransactionReceipt to an output stream.
   *
   * @param os      The output stream.
   * @param receipt The TransactionReceipt to print.
   * @return The output stream with this TransactionReceipt written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const TransactionReceipt& receipt);

  /**
   * Validate the status and throw if it is not a Status::SUCCESS.
   *
   * @throws ReceiptStatusException If the status is not a Status::SUCCESS.
   */
  void validateStatus() const;

  /**
   * The ID of the transaction to which this TransactionReceipt corresponds.
   */
  TransactionId mTransactionId;

  /**
   * The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if the associated
   * transaction did not have a valid payer signature.
   */
  Status mStatus = Status::UNKNOWN;

  /**
   * In the receipt of a CryptoCreate, the ID of the newly created account.
   */
  std::optional<AccountId> mAccountId;

  /**
   * In the receipt of a FileCreate, the ID of the newly created file.
   */
  std::optional<FileId> mFileId;

  /**
   * In the receipt of a ContractCreate, the ID of the newly created contract.
   */
  std::optional<ContractId> mContractId;

  /**
   * The exchange rates in effect when the transaction reached consensus.
   */
  ExchangeRates mExchangeRates;

  /**
   * In the receipt of a ConsensusCreateTopic, the ID of the newly created topic.
   */
  std::optional<TopicId> mTopicId;

  /**
   * In the receipt of a ConsensusSubmitMessage, the new sequence number of the topic that received the message.
   */
  std::optional<uint64_t> mTopicSequenceNumber;

  /**
   * In the receipt of a ConsensusSubmitMessage, the new running hash of the topic that received the message.  This
   * 48-byte field is the output of a particular SHA-384 digest whose input data are determined by the value of the
   * mTopicRunningHashVersion below. The bytes of each uint64_t or uint32_t are to be in Big-Endian format.
   *
   * IF the mTopicRunningHashVersion is '0' or '1', then the input data to the SHA-384 digest are, in order:
   * ---
   * 1. The previous running hash of the topic (48 bytes)
   * 2. The topic's shard (8 bytes)
   * 3. The topic's realm (8 bytes)
   * 4. The topic's number (8 bytes)
   * 5. The number of seconds since the epoch before the ConsensusSubmitMessage reached
   *    consensus (8 bytes)
   * 6. The number of nanoseconds since 5. before the ConsensusSubmitMessage reached
   *    consensus (4 bytes)
   * 7. The topicSequenceNumber from above (8 bytes)
   * 8. The message bytes from the ConsensusSubmitMessage (variable).
   *
   * IF the mTopicRunningHashVersion is '2', then the input data to the SHA-384 digest are, in order:
   * ---
   * 1. The previous running hash of the topic (48 bytes)
   * 2. The topicRunningHashVersion below (8 bytes)
   * 3. The topic's shard (8 bytes)
   * 4. The topic's realm (8 bytes)
   * 5. The topic's number (8 bytes)
   * 6. The number of seconds since the epoch before the ConsensusSubmitMessage reached
   *    consensus (8 bytes)
   * 7. The number of nanoseconds since 6. before the ConsensusSubmitMessage reached
   *    consensus (4 bytes)
   * 8. The topicSequenceNumber from above (8 bytes)
   * 9. The output of the SHA-384 digest of the message bytes from the
   *    consensusSubmitMessage (48 bytes)
   *
   * Otherwise, IF the mTopicRunningHashVersion is '3', then the input data to the SHA-384 digest are, in order:
   * ---
   * 1.  The previous running hash of the topic (48 bytes)
   * 2.  The topicRunningHashVersion below (8 bytes)
   * 3.  The payer account's shard (8 bytes)
   * 4.  The payer account's realm (8 bytes)
   * 5.  The payer account's number (8 bytes)
   * 6.  The topic's shard (8 bytes)
   * 7.  The topic's realm (8 bytes)
   * 8.  The topic's number (8 bytes)
   * 9.  The number of seconds since the epoch before the ConsensusSubmitMessage reached consensus (8 bytes)
   * 10. The number of nanoseconds since 9. before the ConsensusSubmitMessage reached consensus (4 bytes)
   * 11. The topicSequenceNumber from above (8 bytes)
   * 12. The output of the SHA-384 digest of the message bytes from the consensusSubmitMessage (48 bytes)
   */
  std::optional<std::vector<std::byte>> mTopicRunningHash;

  /**
   * In the receipt of a ConsensusSubmitMessage, the version of the SHA-384 digest used to update the running hash.
   */
  std::optional<uint64_t> mTopicRunningHashVersion;

  /**
   * In the receipt of a TokenCreate, the ID of the newly created token.
   */
  std::optional<TokenId> mTokenId;

  /**
   * In the receipt of a TokenMint, TokenWipe, TokenBurn. For FUNGIBLE_COMMON tokens, this is the current total supply
   * of the token. For NON_FUNGIBLE_UNIQUE tokens, this is the total number of NFTs issued for a given token ID.
   */
  std::optional<uint64_t> mNewTotalSupply;

  /**
   * In the receipt of a ScheduleCreate, the ID of the newly created scheduled entity.
   */
  std::optional<ScheduleId> mScheduleId;

  /**
   * In the receipt of a ScheduleCreate or ScheduleSign that resolves to Status::SUCCESS, the TransactionId that should
   * be used to query for the receipt or record of the relevant schedule transaction.
   */
  std::optional<TransactionId> mScheduledTransactionId;

  /**
   * In the receipt of a TokenMint, for tokens of type NON_FUNGIBLE_COMMON, these are the serial numbers of the
   * newly-created NFTs.
   */
  std::vector<uint64_t> mSerialNumbers;

  /**
   * The receipts of processing all transactions with the given ID, in consensus time order.
   */
  std::vector<TransactionReceipt> mDuplicates;

  /**
   * The receipts (if any) of all child transactions spawned by the transaction with the given top-level id, in
   * consensus order. Always empty if the top-level status is UNKNOWN.
   */
  std::vector<TransactionReceipt> mChildren;

  /**
   * In the receipt of a NodeCreate, NodeUpdate, NodeDelete, the id of the newly created node.
   * An affected node identifier.
   * This value SHALL be set following a `createNode` transaction.
   * This value SHALL be set following a `updateNode` transaction.
   * This value SHALL be set following a `deleteNode` transaction.
   * This value SHALL NOT be set following any other transaction.
   */
  std::optional<uint64_t> mNodeId;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TRANSACTION_RECEIPT_H_
// Filename: src/sdk/main/include/TransactionReceiptQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSACTION_RECEIPT_QUERY_H_
#define HIERO_SDK_CPP_TRANSACTION_RECEIPT_QUERY_H_

#include "Query.h"
#include "TransactionId.h"

#include <optional>

namespace Hiero
{
class TransactionReceipt;
}

namespace Hiero
{
/**
 * Get the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus, then information
 * about whether it succeeded or failed will be available until the end of the receipt period. Before and after the
 * receipt period, and for a transaction that was never submitted, the receipt is unknown. This query is free (the
 * payment field is left empty). No State proof is available for this response
 */
class TransactionReceiptQuery : public Query<TransactionReceiptQuery, TransactionReceipt>
{
public:
  /**
   * Set the ID of the transaction of which to request the receipt.
   *
   * @param transactionId The ID of the desired transaction of which to request the receipt.
   * @return A reference to this TransactionReceiptQuery object with the newly-set transaction ID.
   */
  TransactionReceiptQuery& setTransactionId(const TransactionId& transactionId);

  /**
   * Set the child transaction retrieval policy for this TransactionReceiptQuery.
   *
   * @param children \c TRUE if this TransactionReceiptQuery should get the receipts of any child transactions,
   *                 otherwise \c FALSE.
   * @return A reference to this TransactionReceiptQuery object with the newly-set child transaction retrieval policy.
   */
  TransactionReceiptQuery& setIncludeChildren(bool children);

  /**
   * Set the duplicate transaction retrieval policy for this TransactionReceiptQuery.
   *
   * @param duplicates \c TRUE if this TransactionReceiptQuery should get the receipts of any duplicate transactions,
   *                   otherwise \c FALSE.
   * @return A reference to this TransactionReceiptQuery object with the newly-set duplicate transaction retrieval
   *         policy.
   */
  TransactionReceiptQuery& setIncludeDuplicates(bool duplicates);

  /**
   * Get the ID of the transaction of which this query is currently configured to get the receipt.
   *
   * @return The ID of the transaction for which this query is meant. Returns uninitialized if a value has not yet been
   *         set.
   */
  [[nodiscard]] inline std::optional<TransactionId> getTransactionId() const { return mTransactionId; }

  /**
   * Get the child transaction retrieval policy for this TransactionReceiptQuery.
   *
   * @return \c TRUE if this TransactionReceiptQuery is currently configured to get the receipts of any child
   *         transactions, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool getIncludeChildren() const { return mIncludeChildren; }

  /**
   * Get the duplicate transaction retrieval policy for this TransactionReceiptQuery.
   *
   * @return \c TRUE if this TransactionReceiptQuery is currently configured to get the receipts of any duplicate
   *         transactions, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool getIncludeDuplicates() const { return mIncludeDuplicates; }

private:
  /**
   * Derived from Executable. Construct a TransactionReceipt object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a TransactionReceipt object.
   * @return A TransactionReceipt object filled with the Response protobuf object's data
   */
  [[nodiscard]] TransactionReceipt mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this TransactionReceiptQuery's data to a
   * Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this TopicUpdateTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TopicUpdateTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Executable. Determine the ExecutionStatus of this TransactionReceiptQuery after being submitted.
   *
   * @param status   The response status from the network.
   * @param client   The Client that submitted this TransactionReceiptQuery.
   * @param response The Response protobuf object received from the network in response to submitting this
   *                 TransactionReceiptQuery.
   * @return The status of the submitted TransactionReceiptQuery.
   */
  [[nodiscard]]
  typename Executable<TransactionReceiptQuery, proto::Query, proto::Response, TransactionReceipt>::ExecutionStatus
  determineStatus(Status status,
                  [[maybe_unused]] const Client& client,
                  [[maybe_unused]] const proto::Response& response) override;
  /**
   * Derived from Query. Build a Query protobuf object with this TransactionReceiptQuery's data, with the input
   * QueryHeader protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * Derived from Query. Does this TransactionReceiptQuery require payment?
   *
   * @return \c FALSE, TransactionReceiptQuery is free.
   */
  [[nodiscard]] inline bool isPaymentRequired() const override { return false; }

  /**
   * The ID of the transaction of which this query should get the receipt.
   */
  std::optional<TransactionId> mTransactionId;

  /**
   * Should the receipts of any children transactions be retrieved as well?
   */
  bool mIncludeChildren = false;

  /**
   * Should the receipts of any duplicates transactions be retrieved as well?
   */
  bool mIncludeDuplicates = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TRANSACTION_RECEIPT_QUERY_H_
// Filename: src/sdk/main/include/TransactionRecord.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSACTION_RECORD_H_
#define HIERO_SDK_CPP_TRANSACTION_RECORD_H_

#include "AccountId.h"
#include "AssessedCustomFee.h"
#include "ContractFunctionResult.h"
#include "EvmAddress.h"
#include "Hbar.h"
#include "HbarTransfer.h"
#include "PendingAirdropRecord.h"
#include "PublicKey.h"
#include "TokenAssociation.h"
#include "TokenNftTransfer.h"
#include "TokenTransfer.h"
#include "TransactionId.h"
#include "TransactionReceipt.h"

#include <cstddef>
#include <memory>
#include <optional>
#include <ostream>
#include <string>
#include <utility>
#include <vector>

namespace proto
{
class TransactionGetRecordResponse;
class TransactionRecord;
}

namespace Hiero
{
/**
 * The complete record for a transaction on Hiero that has reached consensus. This is not-free to request and is
 * available for 1 hour after a transaction reaches consensus. A TransactionReceipt can be thought of as a light-weight
 * record which is free to ask for if you just need what it contains. A receipt however lasts for only 180 seconds.
 */
class TransactionRecord
{
public:
  /**
   * Construct a TransactionRecord object from a TransactionGetRecordResponse protobuf object.
   *
   * @param proto The TransactionGetRecordResponse protobuf object from which to construct a TransactionRecord object.
   * @return The constructed TransactionRecord object.
   */
  [[nodiscard]] static TransactionRecord fromProtobuf(const proto::TransactionGetRecordResponse& proto);

  /**
   * Construct a TransactionRecord object from a TransactionRecord protobuf object.
   *
   * @param proto The TransactionRecord protobuf object from which to construct a TransactionRecord object.
   * @return The constructed TransactionRecord object.
   */
  [[nodiscard]] static TransactionRecord fromProtobuf(const proto::TransactionRecord& proto);

  /**
   * Construct a TransactionRecord object from a byte array.
   *
   * @param bytes The byte array from which to construct a TransactionRecord object.
   * @return The constructed TransactionRecord object.
   */
  [[nodiscard]] static TransactionRecord fromBytes(const std::vector<std::byte>& bytes);

  /**
   * Construct a TransactionRecord protobuf object from this TransactionRecord object.
   *
   * @return A pointer to the created TransactionRecord protobuf object.
   */
  [[nodiscard]] std::unique_ptr<proto::TransactionRecord> toProtobuf() const;

  /**
   * Construct a representative byte array from this TransactionRecord object.
   *
   * @return The byte array representing this TransactionRecord object.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const;

  /**
   * Construct a string representation of this TransactionRecord object.
   *
   * @return The string representation of this TransactionRecord object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this TransactionRecord to an output stream.
   *
   * @param os     The output stream.
   * @param record The TransactionRecord to print.
   * @return The output stream with this TransactionRecord written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const TransactionRecord& record);

  /**
   * The status (reach consensus, or failed, or is unknown) and the ID of any new account/file/instance created.
   */
  std::optional<TransactionReceipt> mReceipt;

  /**
   * The hash of the transaction that executed (not the hash of any transaction that failed for having a duplicate
   * transaction ID).
   */
  std::vector<std::byte> mTransactionHash;

  /**
   * The consensus timestamp (or uninitialized if the transaction hasn't reached consensus yet).
   */
  std::optional<std::chrono::system_clock::time_point> mConsensusTimestamp;

  /**
   * The ID of the transaction this record represents.
   */
  std::optional<TransactionId> mTransactionId;

  /**
   * The memo that was submitted as part of the transaction (max 100 bytes).
   */
  std::string mMemo;

  /**
   * The actual transaction fee charged, not the original transaction fee value from TransactionBody.
   */
  uint64_t mTransactionFee;

  /**
   * The result of the executed smart contract function or the result of the executed smart contract constructor.
   */
  std::optional<ContractFunctionResult> mContractFunctionResult;

  /**
   * All Hbar transfers as a result of this transaction, such as fees, or transfers performed by the transaction, or by
   * a smart contract it calls, or by the creation of threshold records that it triggers.
   */
  std::vector<HbarTransfer> mHbarTransferList;

  /**
   * All fungible token transfers as a result of this transaction.
   */
  std::vector<TokenTransfer> mTokenTransferList;

  /**
   * All NFT transfers as a result of this transaction.
   */
  std::vector<TokenNftTransfer> mNftTransferList;

  /**
   * The reference to the scheduled transaction ID that this TransactionRecord represents.
   */
  std::optional<ScheduleId> mScheduleRef;

  /**
   * All custom fees that were assessed during a CryptoTransfer, and must be paid if the transaction status resolved to
   * SUCCESS.
   */
  std::vector<AssessedCustomFee> mAssessedCustomFees;

  /**
   * All token associations implicitly created while handling this transaction.
   */
  std::vector<TokenAssociation> mAutomaticTokenAssociations;

  /**
   * In the record of an internal transaction, the consensus timestamp of the user transaction that spawned it.
   */
  std::optional<std::chrono::system_clock::time_point> mParentConsensusTimestamp;

  /**
   * In the record of an AccountCreateTransaction triggered by a user transaction with a (previously unused) alias, the
   * new account's alias.
   */
  std::shared_ptr<PublicKey> mAlias;

  /**
   * In the record of an EthereumTransaction, the KECCAK-256 hash of the ethereumData.
   */
  std::optional<std::vector<std::byte>> mEthereumHash;

  /**
   * The list of accounts with the corresponding staking rewards paid as a result of a transaction.
   */
  std::vector<HbarTransfer> mPaidStakingRewards;

  /**
   * In the record of a PrngTransaction with no range, a pseudorandom 384-bit string.
   */
  std::vector<std::byte> mPrngBytes;

  /**
   * In the record of a PrngTransaction with a range, the pseudorandom 32-bit number.
   */
  std::optional<int> mPrngNumber;

  /**
   * The new default EVM address of the account created by transaction with which this TransactionRecord is
   * associated. This field is populated only when the EVM address is not specified in the related transaction body.
   */
  std::optional<EvmAddress> mEvmAddress;

  /**
   * The records of processing all child transactions spawned by the transaction with the given top-level ID, in
   * consensus order. Always empty if the top-level status is UNKNOWN.
   */
  std::vector<TransactionRecord> mChildren;

  /**
   * The records of processing all consensus transaction with the same ID as the distinguished record, in chronological
   * order.
   */
  std::vector<TransactionRecord> mDuplicates;

  /**
   * A list of pending token airdrops.
   * Each pending airdrop represents a single requested transfer from a
   * sending account to a recipient account. These pending transfers are
   * issued unilaterally by the sending account, and MUST be claimed by the
   * recipient account before the transfer MAY complete.
   * A sender MAY cancel a pending airdrop before it is claimed.
   * An airdrop transaction SHALL emit a pending airdrop when the recipient has no
   * available automatic association slots available or when the recipient
   * has set `receiver_sig_required`.
   */
  std::vector<PendingAirdropRecord> mPendingAirdropRecords;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TRANSACTION_RECORD_H_
// Filename: src/sdk/main/include/TransactionRecordQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSACTION_RECORD_QUERY_H_
#define HIERO_SDK_CPP_TRANSACTION_RECORD_QUERY_H_

#include "Query.h"
#include "TransactionId.h"

#include <optional>

namespace Hiero
{
class TransactionRecord;
}

namespace Hiero
{
/**
 * Get the record for a transaction. If the transaction requested a record, then the record lasts for one hour, and a
 * state proof is available for it. If the transaction created an account, file, or smart contract instance, then the
 * record will contain the ID for what it created. If the transaction called a smart contract function, then the record
 * contains the result of that call. If the transaction was a cryptocurrency transfer, then the record includes the
 * TransferList which gives the details of that transfer. If the transaction didn't return anything that should be in
 * the record, then the results field will be set to nothing.
 */
class TransactionRecordQuery : public Query<TransactionRecordQuery, TransactionRecord>
{
public:
  /**
   * Set the ID of the transaction of which to request the record.
   *
   * @param transactionId The ID of the desired transaction of which to request the record.
   * @return A reference to this TransactionRecordQuery object with the newly-set transaction ID.
   */
  TransactionRecordQuery& setTransactionId(const TransactionId& transactionId);

  /**
   * Set the child transaction retrieval policy for this TransactionRecordQuery.
   *
   * @param children \c TRUE if this TransactionRecordQuery should get the receipts of any child transactions,
   *                 otherwise \c FALSE.
   * @return A reference to this TransactionRecordQuery object with the newly-set child transaction retrieval policy.
   */
  TransactionRecordQuery& setIncludeChildren(bool children);

  /**
   * Set the duplicate transaction retrieval policy for this TransactionRecordQuery.
   *
   * @param duplicates \c TRUE if this TransactionRecordQuery should get the receipts of any duplicate transactions,
   *                   otherwise \c FALSE.
   * @return A reference to this TransactionRecordQuery object with the newly-set duplicate transaction retrieval
   *         policy.
   */
  TransactionRecordQuery& setIncludeDuplicates(bool duplicates);

  /**
   * Get the ID of the transaction of which this query is currently configured to get the record.
   *
   * @return The ID of the transaction for which this query is meant. Returns uninitialized if a value has not yet been
   *         set.
   */
  [[nodiscard]] inline std::optional<TransactionId> getTransactionId() const { return mTransactionId; }

  /**
   * Get the child transaction retrieval policy for this TransactionRecordQuery.
   *
   * @return \c TRUE if this TransactionRecordQuery is currently configured to get the records of any child
   *         transactions, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool getIncludeChildren() const { return mIncludeChildren; }

  /**
   * Get the duplicate transaction retrieval policy for this TransactionRecordQuery.
   *
   * @return \c TRUE if this TransactionRecordQuery is currently configured to get the records of any duplicate
   *         transactions, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool getIncludeDuplicates() const { return mIncludeDuplicates; }

private:
  /**
   * Derived from Executable. Construct a TransactionRecord object from a Response protobuf object.
   *
   * @param response The Response protobuf object from which to construct a TransactionRecord object.
   * @return A TransactionRecord object filled with the Response protobuf object's data
   */
  [[nodiscard]] TransactionRecord mapResponse(const proto::Response& response) const override;

  /**
   * Derived from Executable. Submit a Query protobuf object which contains this TransactionRecordQuery's data to a
   * Node.
   *
   * @param request  The Query protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Query& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::Response* response) const override;

  /**
   * Derived from Query. Verify that all the checksums in this TransactionRecordQuery are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TransactionRecordQuery's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Executable. Determine the ExecutionStatus of this TransactionRecordQuery after being submitted.
   *
   * @param status   The response status of the previous attempt.
   * @param client   The Client that attempted to submit this TransactionRecordQuery.
   * @param response The Response protobuf object received from the network in response to submitting this request.
   * @return The status of the submitted request.
   */
  [[nodiscard]]
  typename Executable<TransactionRecordQuery, proto::Query, proto::Response, TransactionRecord>::ExecutionStatus
  determineStatus(Status status,
                  [[maybe_unused]] const Client& client,
                  [[maybe_unused]] const proto::Response& response) override;
  /**
   * Derived from Query. Build a Query protobuf object with this TransactionRecordQuery's data, with the input
   * QueryHeader protobuf object.
   *
   * @param header A pointer to the QueryHeader protobuf object to add to the Query protobuf object.
   * @return The constructed Query protobuf object.
   */
  [[nodiscard]] proto::Query buildRequest(proto::QueryHeader* header) const override;

  /**
   * Derived from Query. Get the ResponseHeader protobuf object from the input Response protobuf object.
   *
   * @param response The Response protobuf object from which to get the ResponseHeader protobuf object.
   * @return The ResponseHeader protobuf object of the input Response protobuf object for this derived Query.
   */
  [[nodiscard]] proto::ResponseHeader mapResponseHeader(const proto::Response& response) const override;

  /**
   * The ID of the transaction of which this query should get the record.
   */
  std::optional<TransactionId> mTransactionId;

  /**
   * Should the records of any children transactions be retrieved as well?
   */
  bool mIncludeChildren = false;

  /**
   * Should the records of any duplicates transactions be retrieved as well?
   */
  bool mIncludeDuplicates = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TRANSACTION_RECORD_QUERY_H_
// Filename: src/sdk/main/include/TransactionResponse.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSACTION_RESPONSE_H_
#define HIERO_SDK_CPP_TRANSACTION_RESPONSE_H_

#include "AccountId.h"
#include "TransactionId.h"

#include <chrono>
#include <cstddef>
#include <cstdint>
#include <functional>
#include <future>
#include <string>
#include <vector>

namespace Hiero
{
class Client;
class TransactionReceipt;
class TransactionReceiptQuery;
class TransactionRecord;
class TransactionRecordQuery;
}

namespace Hiero
{
/**
 * When the client sends the node a transaction of any kind, the node replies with this, which simply says that the
 * transaction passed the pre-check (so the node will submit it to the network) or it failed (so it won't). To learn the
 * consensus result, the client should later obtain a receipt (free), or can buy a more detailed record (not free).
 */
class TransactionResponse
{
public:
  TransactionResponse() = default;

  /**
   * Construct with a node account ID, transaction ID, and transaction hash.
   *
   * @param nodeId The ID of the node account to which this TransactionResponse's corresponding Transaction was sent.
   * @param transactionId The ID of this TransactionResponse's corresponding Transaction.
   * @param hash The hash of this TransactionResponse's corresponding Transaction.
   */
  TransactionResponse(AccountId nodeId, TransactionId transactionId, std::vector<std::byte> hash);

  /**
   * Get a TransactionReceipt for this TransactionResponse's corresponding Transaction.
   *
   * @param client The Client to use to submit a TransactionReceiptQuery.
   * @return A TransactionReceipt object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionReceiptQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionReceipt is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionReceipt getReceipt(const Client& client) const;

  /**
   * Get a TransactionReceipt for this TransactionResponse's corresponding Transaction with a specified timeout.
   *
   * @param client  The Client to use to submit a TransactionReceiptQuery.
   * @param timeout The desired timeout for the execution of the TransactionReceiptQuery.
   * @return A TransactionReceipt object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionReceiptQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionReceipt is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  TransactionReceipt getReceipt(const Client& client, const std::chrono::system_clock::duration& timeout) const;

  /**
   * Construct a TransactionReceiptQuery for this TransactionResponse's corresponding Transaction.
   *
   * @return The constructed TransactionReceiptQuery.
   */
  [[nodiscard]] TransactionReceiptQuery getReceiptQuery() const;

  /**
   * Get a TransactionReceipt for this TransactionResponse's corresponding Transaction asynchronously.
   *
   * @param client The Client to use to submit a TransactionReceiptQuery.
   * @return A TransactionReceipt object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionReceiptQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionReceipt is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<TransactionReceipt> getReceiptAsync(const Client& client) const;

  /**
   * Get a TransactionReceipt for this TransactionResponse's corresponding Transaction asynchronously with a specified
   * timeout.
   *
   * @param client  The Client to use to submit a TransactionReceiptQuery.
   * @param timeout The desired timeout for the execution of the TransactionReceiptQuery.
   * @return A TransactionReceipt object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionReceiptQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionReceipt is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<TransactionReceipt> getReceiptAsync(const Client& client,
                                                  const std::chrono::system_clock::duration& timeout) const;

  /**
   * Get a TransactionReceipt for this TransactionResponse's corresponding Transaction asynchronously and consume the
   * response and/or exception with a callback.
   *
   * @param client   The Client to use to submit a TransactionReceiptQuery.
   * @param callback The callback that should consume the response/exception.
   * @return A TransactionReceipt object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionReceiptQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionReceipt is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  void getReceiptAsync(const Client& client,
                       const std::function<void(const TransactionReceipt&, const std::exception&)>& callback) const;

  /**
   * Get a TransactionReceipt for this TransactionResponse's corresponding Transaction asynchronously with a specified
   * timeout and consume the response and/or exception with a callback.
   *
   * @param client   The Client to use to submit a TransactionReceiptQuery.
   * @param timeout  The desired timeout for the execution of the TransactionReceiptQuery.
   * @param callback The callback that should consume the response/exception.
   * @return A TransactionReceipt object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionReceiptQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionReceipt is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  void getReceiptAsync(const Client& client,
                       const std::chrono::system_clock::duration& timeout,
                       const std::function<void(const TransactionReceipt&, const std::exception&)>& callback) const;

  /**
   * Get a TransactionReceipt for this TransactionResponse's corresponding Transaction asynchronously and consume the
   * response and/or exception with a callback.
   *
   * @param client            The Client to use to submit a TransactionReceiptQuery.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   * @return A TransactionReceipt object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionReceiptQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionReceipt is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  void getReceiptAsync(const Client& client,
                       const std::function<void(const TransactionReceipt&)>& responseCallback,
                       const std::function<void(const std::exception&)>& exceptionCallback) const;

  /**
   * Get a TransactionReceipt for this TransactionResponse's corresponding Transaction asynchronously with a specified
   * timeout and consume the response and/or exception with a callback.
   *
   * @param client            The Client to use to submit a TransactionReceiptQuery.
   * @param timeout           The desired timeout for the execution of the TransactionReceiptQuery.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   * @return A TransactionReceipt object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionReceiptQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionReceiptQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionReceipt is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  void getReceiptAsync(const Client& client,
                       const std::chrono::system_clock::duration& timeout,
                       const std::function<void(const TransactionReceipt&)>& responseCallback,
                       const std::function<void(const std::exception&)>& exceptionCallback) const;

  /**
   * Get a TransactionRecord for this TransactionResponse's corresponding Transaction.
   *
   * @param client The Client to use to submit a TransactionRecordQuery.
   * @return A TransactionRecord object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionRecordQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  [[nodiscard]] TransactionRecord getRecord(const Client& client) const;

  /**
   * Get a TransactionRecord for this TransactionResponse's corresponding Transaction with a specified timeout.
   *
   * @param client  The Client to use to submit a TransactionRecordQuery.
   * @param timeout The desired timeout for the execution of the TransactionRecordQuery.
   * @return A TransactionRecord object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionRecordQuery fails its pre-check.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  [[nodiscard]] TransactionRecord getRecord(const Client& client,
                                            const std::chrono::system_clock::duration& timeout) const;

  /**
   * Construct a TransactionRecordQuery for this TransactionResponse's corresponding Transaction.
   *
   * @return The constructed TransactionRecordQuery.
   */
  [[nodiscard]] TransactionRecordQuery getRecordQuery() const;

  /**
   * Get a TransactionRecord for this TransactionResponse's corresponding Transaction asynchronously.
   *
   * @param client The Client to use to submit a TransactionRecordQuery.
   * @return A TransactionRecord object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionRecordQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionRecord is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<TransactionRecord> getRecordAsync(const Client& client) const;

  /**
   * Get a TransactionRecord for this TransactionResponse's corresponding Transaction asynchronously with a specified
   * timeout.
   *
   * @param client  The Client to use to submit a TransactionRecordQuery.
   * @param timeout The desired timeout for the execution of the TransactionRecordQuery.
   * @return A TransactionRecord object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionRecordQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionRecord is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  std::future<TransactionRecord> getRecordAsync(const Client& client,
                                                const std::chrono::system_clock::duration& timeout) const;

  /**
   * Get a TransactionRecord for this TransactionResponse's corresponding Transaction asynchronously and consume the
   * response and/or exception with a callback.
   *
   * @param client   The Client to use to submit a TransactionRecordQuery.
   * @param callback The callback that should consume the response/exception.
   * @return A TransactionRecord object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionRecordQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionRecord is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  void getRecordAsync(const Client& client,
                      const std::function<void(const TransactionRecord&, const std::exception&)>& callback) const;

  /**
   * Get a TransactionRecord for this TransactionResponse's corresponding Transaction asynchronously with a specified
   * timeout and consume the response and/or exception with a callback.
   *
   * @param client   The Client to use to submit a TransactionRecordQuery.
   * @param timeout  The desired timeout for the execution of the TransactionRecordQuery.
   * @param callback The callback that should consume the response/exception.
   * @return A TransactionRecord object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionRecordQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionRecord is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  void getRecordAsync(const Client& client,
                      const std::chrono::system_clock::duration& timeout,
                      const std::function<void(const TransactionRecord&, const std::exception&)>& callback) const;

  /**
   * Get a TransactionRecord for this TransactionResponse's corresponding Transaction asynchronously and consume the
   * response and/or exception with a callback.
   *
   * @param client            The Client to use to submit a TransactionRecordQuery.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   * @return A TransactionRecord object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionRecordQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionRecord is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  void getRecordAsync(const Client& client,
                      const std::function<void(const TransactionRecord&)>& responseCallback,
                      const std::function<void(const std::exception&)>& exceptionCallback) const;

  /**
   * Get a TransactionRecord for this TransactionResponse's corresponding Transaction asynchronously with a specified
   * timeout and consume the response and/or exception with a callback.
   *
   * @param client            The Client to use to submit a TransactionRecordQuery.
   * @param timeout           The desired timeout for the execution of the TransactionRecordQuery.
   * @param responseCallback  The callback that should consume the response.
   * @param exceptionCallback The callback that should consume the exception.
   * @return A TransactionRecord object containing data about this TransactionResponse's corresponding Transaction.
   * @throws MaxAttemptsExceededException If the TransactionRecordQuery attempts to execute past the number of
   *                                      allowable attempts.
   * @throws PrecheckStatusException      If this TransactionRecordQuery fails its pre-check.
   * @throws ReceiptStatusException       If the retrieved TransactionRecord is not successful, and this
   *                                      TransactionResponse is configured to throw.
   * @throws UninitializedException       If the input Client has not yet been initialized.
   */
  void getRecordAsync(const Client& client,
                      const std::chrono::system_clock::duration& timeout,
                      const std::function<void(const TransactionRecord&)>& responseCallback,
                      const std::function<void(const std::exception&)>& exceptionCallback) const;

  /**
   * Construct a string representation of this TransactionResponse object.
   *
   * @return The string representation of this TransactionResponse object.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Write this TransactionResponse to an output stream.
   *
   * @param os       The output stream.
   * @param response The TransactionResponse to print.
   * @return The output stream with this TransactionResponse written to it.
   */
  friend std::ostream& operator<<(std::ostream& os, const TransactionResponse& response);

  /**
   * Set this TransactionResponse's TransactionReceipt validation policy.
   *
   * @param validate \c TRUE if this TransactionResponse should throw if it retrieves a TransactionReceipt that does not
   *                 have a successful status (i.e. Status::SUCCESS), otherwise \c FALSE.
   */
  TransactionResponse& setValidateStatus(bool validate);

  /**
   * Get this TransactionResponse's TransactionReceipt validation policy.
   *
   * @return \c TRUE if this TransactionResponse should throw if it retrieves a TransactionReceipt that does not have a
   *         successful status (i.e. Status::SUCCESS), otherwise \c FALSE.
   */
  [[nodiscard]] inline bool getValidateStatus() const { return mValidateStatus; }

  /**
   * The ID of node to which this TransactionResponse's corresponding Transaction was sent.
   */
  AccountId mNodeId;

  /**
   * The hash of this TransactionResponse's corresponding Transaction.
   */
  std::vector<std::byte> mTransactionHash;

  /**
   * The ID of this TransactionResponse's corresponding Transaction.
   */
  TransactionId mTransactionId;

private:
  /**
   * Did this TransactionResponse's corresponding Transaction have a successful pre-check?
   */
  bool mValidateStatus = true;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TRANSACTION_RESPONSE_H_
// Filename: src/sdk/main/include/TransactionType.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSACTION_TYPE_H_
#define HIERO_SDK_CPP_TRANSACTION_TYPE_H_

namespace Hiero
{
/**
 * Enumeration of all transaction types.
 */
enum TransactionType : int
{
  UNKNOWN_TRANSACTION = -1,
  ACCOUNT_ALLOWANCE_APPROVE_TRANSACTION,
  ACCOUNT_ALLOWANCE_DELETE_TRANSACTION,
  ACCOUNT_CREATE_TRANSACTION,
  ACCOUNT_DELETE_TRANSACTION,
  ACCOUNT_UPDATE_TRANSACTION,
  CONTRACT_CREATE_TRANSACTION,
  CONTRACT_DELETE_TRANSACTION,
  CONTRACT_EXECUTE_TRANSACTION,
  CONTRACT_UPDATE_TRANSACTION,
  ETHEREUM_TRANSACTION,
  FILE_APPEND_TRANSACTION,
  FILE_CREATE_TRANSACTION,
  FILE_DELETE_TRANSACTION,
  FILE_UPDATE_TRANSACTION,
  FREEZE_TRANSACTION,
  NODE_CREATE_TRANSACTION,
  NODE_DELETE_TRANSACTION,
  NODE_UPDATE_TRANSACTION,
  PRNG_TRANSACTION,
  SCHEDULE_CREATE_TRANSACTION,
  SCHEDULE_DELETE_TRANSACTION,
  SCHEDULE_SIGN_TRANSACTION,
  SYSTEM_DELETE_TRANSACTION,
  SYSTEM_UNDELETE_TRANSACTION,
  TOKEN_AIRDROP_TRANSACTION,
  TOKEN_ASSOCIATE_TRANSACTION,
  TOKEN_BURN_TRANSACTION,
  TOKEN_CANCEL_AIRDROP_TRANSACTION,
  TOKEN_CLAIM_AIRDROP_TRANSACTION,
  TOKEN_CREATE_TRANSACTION,
  TOKEN_DELETE_TRANSACTION,
  TOKEN_DISSOCIATE_TRANSACTION,
  TOKEN_FEE_SCHEDULE_UPDATE_TRANSACTION,
  TOKEN_FREEZE_TRANSACTION,
  TOKEN_GRANT_KYC_TRANSACTION,
  TOKEN_MINT_TRANSACTION,
  TOKEN_PAUSE_TRANSACTION,
  TOKEN_REJECT_TRANSACTION,
  TOKEN_REVOKE_KYC_TRANSACTION,
  TOKEN_UNFREEZE_TRANSACTION,
  TOKEN_UNPAUSE_TRANSACTION,
  TOKEN_UPDATE_NFTS_TRANSACTION,
  TOKEN_UPDATE_TRANSACTION,
  TOKEN_WIPE_TRANSACTION,
  TOPIC_CREATE_TRANSACTION,
  TOPIC_DELETE_TRANSACTION,
  TOPIC_MESSAGE_SUBMIT_TRANSACTION,
  TOPIC_UPDATE_TRANSACTION,
  TRANSFER_TRANSACTION
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TRANSACTION_TYPE_H_
// Filename: src/sdk/main/include/TransferTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_TRANSFER_TRANSACTION_H_
#define HIERO_SDK_CPP_TRANSFER_TRANSACTION_H_

#include "HbarTransfer.h"
#include "TokenNftTransfer.h"
#include "TokenTransfer.h"
#include "Transaction.h"

#include <unordered_map>
#include <vector>

namespace proto
{
class CryptoTransferTransactionBody;
}

namespace Hiero
{
class AccountId;
class EvmAddress;
class NftId;
class TokenId;
}

namespace Hiero
{
/**
 * Transfers cryptocurrency among two or more accounts by making the desired adjustments to their balances. Each
 * transfer list can specify up to 10 adjustments. Each negative amount is withdrawn from the corresponding account (a
 * sender), and each positive one is added to the corresponding account (a receiver). The amounts list must sum to zero.
 * Each amount is a number of tinybars (there are 100,000,000 tinybars in one hbar). If any sender account fails to
 * have sufficient hbars, then the entire transaction fails, and none of those transfers occur, though the transaction
 * fee is still charged. This transaction must be signed by the keys for all the sending accounts, and for any receiving
 * accounts that have mReceiverSigRequired == \c TRUE. The signatures are in the same order as the accounts, skipping
 * those accounts that don't need a signature.
 */
class TransferTransaction : public Transaction<TransferTransaction>
{
public:
  TransferTransaction() = default;

  /**
   * Construct from a TransactionBody protobuf object.
   *
   * @param transactionBody The TransactionBody protobuf object from which to construct.
   * @throws std::invalid_argument If the input TransactionBody does not represent a CryptoTransfer transaction.
   */
  explicit TransferTransaction(const proto::TransactionBody& transactionBody);

  /**
   * Construct from a map of TransactionIds to node account IDs and their respective Transaction protobuf objects.
   *
   * @param transactions The map of TransactionIds to node account IDs and their respective Transaction protobuf
   *                     objects.
   */
  explicit TransferTransaction(const std::map<TransactionId, std::map<AccountId, proto::Transaction>>& transactions);

  /**
   * Add an Hbar transfer to be submitted as part of this TransferTransaction.
   *
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The amount of Hbar to transfer.
   * @return A reference to this TransferTransaction object with the newly-added Hbar transfer.
   * @throws IllegalStateException If this TransferTransaction is frozen.
   */
  TransferTransaction& addHbarTransfer(const AccountId& accountId, const Hbar& amount);

  /**
   * Add an Hbar transfer to be submitted as part of this TransferTransaction.
   *
   * @param evmAddress The EVM address associated with this transfer.
   * @param amount     The amount of Hbar to transfer.
   * @return A reference to this TransferTransaction object with the newly-added Hbar transfer.
   * @throws IllegalStateException If this TransferTransaction is frozen.
   */
  TransferTransaction& addHbarTransfer(const EvmAddress& evmAddress, const Hbar& amount);

  /**
   * Add a token transfer to be submitted as part of this TransferTransaction.
   *
   * @param tokenId   The ID of the token associated with this transfer.
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The number of tokens to transfer.
   * @return A reference to this TransferTransaction object with the newly-added token transfer.
   * @throws IllegalStateException If this TransferTransaction is frozen.
   */
  TransferTransaction& addTokenTransfer(const TokenId& tokenId, const AccountId& accountId, const int64_t& amount);

  /**
   * Add an NFT transfer to be submitted as part of this TransferTransaction.
   *
   * @param nftId             The ID of the NFT associated with this transfer.
   * @param senderAccountId   The ID of the account sending the NFT.
   * @param receiverAccountId The ID of the receiving sending the NFT.
   * @return A reference to this TransferTransaction object with the newly-added NFT transfer.
   * @throws IllegalStateException If this TransferTransaction is frozen.
   */
  TransferTransaction& addNftTransfer(const NftId& nftId,
                                      const AccountId& senderAccountId,
                                      const AccountId& receiverAccountId);

  /**
   * Add a token transfer with decimals to be submitted as part of this TransferTransaction.
   *
   * @param tokenId   The ID of the token associated with this transfer.
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The number of tokens to transfer.
   * @param decimals  The number of decimals in the transfer amount.
   * @return A reference to this TransferTransaction object with the newly-added token transfer.
   * @throws IllegalStateException If this TransferTransaction is frozen.
   * @throws std::invalid_argument If decimals does not match previously set decimals for this token.
   */
  TransferTransaction& addTokenTransferWithDecimals(const TokenId& tokenId,
                                                    const AccountId& accountId,
                                                    const int64_t& amount,
                                                    uint32_t decimals);

  /**
   * Add an approved Hbar transfer to be submitted as part of this TransferTransaction.
   *
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The amount of Hbar to transfer.
   * @return A reference to this TransferTransaction object with the newly-added approved Hbar transfer.
   * @throws IllegalStateException If this TransferTransaction is frozen.
   */
  TransferTransaction& addApprovedHbarTransfer(const AccountId& accountId, const Hbar& amount);

  /**
   * Add an approved token transfer to be submitted as part of this TransferTransaction.
   *
   * @param tokenId   The ID of the token associated with this transfer.
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The number of tokens to transfer.
   * @return A reference to this TransferTransaction object with the newly-added approved token transfer.
   * @throws IllegalStateException If this TransferTransaction is frozen.
   */
  TransferTransaction& addApprovedTokenTransfer(const TokenId& tokenId,
                                                const AccountId& accountId,
                                                const int64_t& amount);

  /**
   * Add an approved NFT transfer to be submitted as part of this TransferTransaction.
   *
   * @param nftId             The ID of the NFT associated with this transfer.
   * @param senderAccountId   The ID of the account sending the NFT.
   * @param receiverAccountId The ID of the receiving sending the NFT.
   * @return A reference to this TransferTransaction object with the newly-added approved NFT transfer.
   * @throws IllegalStateException If this TransferTransaction is frozen.
   */
  TransferTransaction& addApprovedNftTransfer(const NftId& nftId,
                                              const AccountId& senderAccountId,
                                              const AccountId& receiverAccountId);

  /**
   * Add an approved token transfer with decimals to be submitted as part of this TransferTransaction.
   *
   * @param tokenId   The ID of the token associated with this transfer.
   * @param accountId The ID of the account associated with this transfer.
   * @param amount    The number of tokens to transfer.
   * @param decimals  The number of decimals in the transfer amount.
   * @return A reference to this TransferTransaction object with the newly-added approved token transfer.
   * @throws IllegalStateException If this TransferTransaction is frozen.
   * @throws std::invalid_argument If decimals does not match previously set decimals for this token.
   */
  TransferTransaction& addApprovedTokenTransferWithDecimals(const TokenId& tokenId,
                                                            const AccountId& accountId,
                                                            const int64_t& amount,
                                                            uint32_t decimals);

  /**
   * Get all Hbar transfers that have been added to this TransferTransaction.
   *
   * @return The map of Hbar transfers.
   */
  [[nodiscard]] std::unordered_map<AccountId, Hbar> getHbarTransfers() const;

  /**
   * Get all token transfers that have been added to this TransferTransaction.
   *
   * @return The map of token transfers.
   */
  [[nodiscard]] std::unordered_map<TokenId, std::unordered_map<AccountId, int64_t>> getTokenTransfers() const;

  /**
   * Get all NFT transfers that have been added to this TransferTransaction.
   *
   * @return The map of NFT transfers.
   */
  [[nodiscard]] std::unordered_map<TokenId, std::vector<TokenNftTransfer>> getNftTransfers() const;

  /**
   * Get the expected decimals for token transfers that have been added to this TransferTransaction.
   *
   * @return The map of expected decimals.
   */
  [[nodiscard]] std::unordered_map<TokenId, uint32_t> getTokenIdDecimals() const;

private:
  /**
   * Allow Queries to create Transaction protobuf objects from TransferTransactions (to use as payments).
   */
  template<typename SdkRequestType, typename SdkResponseType>
  friend class Query;
  friend class WrappedTransaction;

  /**
   * Derived from Executable. Submit a Transaction protobuf object which contains this TransferTransaction's data to a
   * Node.
   *
   * @param request  The Transaction protobuf object to submit.
   * @param node     The Node to which to submit the request.
   * @param deadline The deadline for submitting the request.
   * @param response Pointer to the ProtoResponseType object that gRPC should populate with the response information
   *                 from the gRPC server.
   * @return The gRPC status of the submission.
   */
  [[nodiscard]] grpc::Status submitRequest(const proto::Transaction& request,
                                           const std::shared_ptr<internal::Node>& node,
                                           const std::chrono::system_clock::time_point& deadline,
                                           proto::TransactionResponse* response) const override;

  /**
   * Derived from Transaction. Verify that all the checksums in this TransferTransaction are valid.
   *
   * @param client The Client that should be used to validate the checksums.
   * @throws BadEntityException This TransferTransaction's checksums are not valid.
   */
  void validateChecksums(const Client& client) const override;

  /**
   * Derived from Transaction. Build and add the TransferTransaction protobuf representation to the Transaction
   * protobuf object.
   *
   * @param body The TransactionBody protobuf object being built.
   */
  void addToBody(proto::TransactionBody& body) const override;

  /**
   * Initialize this TransferTransaction from its source TransactionBody protobuf object.
   */
  void initFromSourceTransactionBody();

  /**
   * Build a CryptoTransferTransactionBody protobuf object from this TransferTransaction object.
   *
   * @return A pointer to a CryptoTransferTransactionBody protobuf object filled with this TransferTransaction object's
   *         data.
   */
  [[nodiscard]] proto::CryptoTransferTransactionBody* build() const;

  /**
   * Add an Hbar transfer to the Hbar transfers list.
   *
   * @param accountId The ID of the account doing the transfer.
   * @param amount    The amount to transfer.
   * @param approved  \c TRUE if this is an approved allowance transfer, otherwise \c FALSE.
   */
  void doHbarTransfer(const AccountId& accountId, const Hbar& amount, bool approved);

  /**
   * Add a token transfer to the token transfers list.
   *
   * @param transfer The token transfer to add.
   */
  void doTokenTransfer(const TokenTransfer& transfer);

  /**
   * Add an NFT transfer to the NFT transfers list.
   *
   * @param nftId The ID of the NFT.
   * @param sender The ID of the account sending the NFT.
   * @param receiver The ID of the account receiving the NFT.
   * @param approved \c TRUE if this is an approved allowance NFT transfer, otherwise \c FALSE.
   */
  void doNftTransfer(const NftId& nftId, const AccountId& sender, const AccountId& receiver, bool approved);

  /**
   * The desired Hbar balance adjustments.
   */
  std::vector<HbarTransfer> mHbarTransfers;

  /**
   * The desired token adjustments.
   */
  std::vector<TokenTransfer> mTokenTransfers;

  /**
   * The desired NFT adjustments.
   */
  std::vector<TokenNftTransfer> mNftTransfers;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_TRANSFER_TRANSACTION_H_
// Filename: src/sdk/main/include/WrappedTransaction.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_UNKNOWN_TRANSACTION_H_
#define HIERO_SDK_CPP_UNKNOWN_TRANSACTION_H_

#include "AccountAllowanceApproveTransaction.h"
#include "AccountAllowanceDeleteTransaction.h"
#include "AccountCreateTransaction.h"
#include "AccountDeleteTransaction.h"
#include "AccountUpdateTransaction.h"
#include "ContractCreateTransaction.h"
#include "ContractDeleteTransaction.h"
#include "ContractExecuteTransaction.h"
#include "ContractUpdateTransaction.h"
#include "EthereumTransaction.h"
#include "FileAppendTransaction.h"
#include "FileCreateTransaction.h"
#include "FileDeleteTransaction.h"
#include "FileUpdateTransaction.h"
#include "FreezeTransaction.h"
#include "NodeCreateTransaction.h"
#include "NodeDeleteTransaction.h"
#include "NodeUpdateTransaction.h"
#include "PrngTransaction.h"
#include "ScheduleCreateTransaction.h"
#include "ScheduleDeleteTransaction.h"
#include "ScheduleSignTransaction.h"
#include "SystemDeleteTransaction.h"
#include "SystemUndeleteTransaction.h"
#include "TokenAirdropTransaction.h"
#include "TokenAssociateTransaction.h"
#include "TokenBurnTransaction.h"
#include "TokenCancelAirdropTransaction.h"
#include "TokenClaimAirdropTransaction.h"
#include "TokenCreateTransaction.h"
#include "TokenDeleteTransaction.h"
#include "TokenDissociateTransaction.h"
#include "TokenFeeScheduleUpdateTransaction.h"
#include "TokenFreezeTransaction.h"
#include "TokenGrantKycTransaction.h"
#include "TokenMintTransaction.h"
#include "TokenPauseTransaction.h"
#include "TokenRejectTransaction.h"
#include "TokenRevokeKycTransaction.h"
#include "TokenUnfreezeTransaction.h"
#include "TokenUnpauseTransaction.h"
#include "TokenUpdateNftsTransaction.h"
#include "TokenUpdateTransaction.h"
#include "TokenWipeTransaction.h"
#include "TopicCreateTransaction.h"
#include "TopicDeleteTransaction.h"
#include "TopicMessageSubmitTransaction.h"
#include "TopicUpdateTransaction.h"
#include "TransactionType.h"
#include "TransferTransaction.h"

#include <variant>

namespace proto
{
class SchedulableTransactionBody;
class TransactionBody;
}

namespace Hiero
{
/**
 * Helper class to hold a Transaction variant.
 */
class WrappedTransaction
{
public:
  /**
   * Helper alias to use to consolidate space and provide clarity.
   */
  using AnyPossibleTransaction = std::variant<AccountAllowanceApproveTransaction,
                                              AccountAllowanceDeleteTransaction,
                                              AccountCreateTransaction,
                                              AccountDeleteTransaction,
                                              AccountUpdateTransaction,
                                              ContractCreateTransaction,
                                              ContractDeleteTransaction,
                                              ContractExecuteTransaction,
                                              ContractUpdateTransaction,
                                              EthereumTransaction,
                                              FileAppendTransaction,
                                              FileCreateTransaction,
                                              FileDeleteTransaction,
                                              FileUpdateTransaction,
                                              FreezeTransaction,
                                              NodeCreateTransaction,
                                              NodeDeleteTransaction,
                                              NodeUpdateTransaction,
                                              PrngTransaction,
                                              ScheduleCreateTransaction,
                                              ScheduleDeleteTransaction,
                                              ScheduleSignTransaction,
                                              SystemDeleteTransaction,
                                              SystemUndeleteTransaction,
                                              TokenAirdropTransaction,
                                              TokenAssociateTransaction,
                                              TokenBurnTransaction,
                                              TokenCancelAirdropTransaction,
                                              TokenClaimAirdropTransaction,
                                              TokenCreateTransaction,
                                              TokenDeleteTransaction,
                                              TokenDissociateTransaction,
                                              TokenFeeScheduleUpdateTransaction,
                                              TokenFreezeTransaction,
                                              TokenGrantKycTransaction,
                                              TokenMintTransaction,
                                              TokenPauseTransaction,
                                              TokenRejectTransaction,
                                              TokenRevokeKycTransaction,
                                              TokenUnfreezeTransaction,
                                              TokenUnpauseTransaction,
                                              TokenUpdateNftsTransaction,
                                              TokenUpdateTransaction,
                                              TokenWipeTransaction,
                                              TopicCreateTransaction,
                                              TopicDeleteTransaction,
                                              TopicMessageSubmitTransaction,
                                              TopicUpdateTransaction,
                                              TransferTransaction>;

  WrappedTransaction() = default;

  /**
   * Construct with a transaction.
   *
   * @param transaction The transaction to wrap.
   */
  explicit WrappedTransaction(AnyPossibleTransaction transaction);

  /**
   * Construct a WrappedTransaction object from a TransactionBody protobuf object.
   *
   * @param proto The TransactionBody protobuf object from which to construct a WrappedTransaction object.
   * @return The constructed WrappedTransaction object.
   * @throws std::invalid_argument If the input TransactionBody doesn't contain a valid Transaction.
   */
  [[nodiscard]] static WrappedTransaction fromProtobuf(const proto::TransactionBody& proto);

  /**
   * Construct a WrappedTransaction object from a SchedulableTransactionBody protobuf object.
   *
   * @param proto The SchedulableTransactionBody protobuf object from which to construct a WrappedTransaction object.
   * @return The constructed WrappedTransaction object.
   * @throws std::invalid_argument If the input SchedulableTransactionBody doesn't contain a Transaction.
   */
  [[nodiscard]] static WrappedTransaction fromProtobuf(const proto::SchedulableTransactionBody& proto);

  /**
   * Construct a TransactionBody protobuf object from this WrappedTransaction object.
   *
   * @return A pointer to the created TransactionBody protobuf object.
   * @throws UninitializedException If no Transaction is contained within this WrappedTransaction.
   */
  [[nodiscard]] std::unique_ptr<proto::TransactionBody> toProtobuf() const;

  /**
   * Construct a SchedulableTransactionBody protobuf object from this WrappedTransaction object.
   *
   * @return A pointer to the created SchedulableTransactionBody protobuf object.
   * @throws UninitializedException If no Transaction is contained within this WrappedTransaction.
   */
  [[nodiscard]] std::unique_ptr<proto::SchedulableTransactionBody> toSchedulableProtobuf() const;

  /**
   * Set the transaction to wrap.
   *
   * @param transaction The transaction to wrap.
   * @return A reference to this WrappedTransaction with the newly-set transaction.
   */
  WrappedTransaction& setTransaction(const AnyPossibleTransaction& transaction);

  /**
   * Get the type of wrapped transaction.
   *
   * @return The type of wrapped transaction.
   */
  [[nodiscard]] inline TransactionType getTransactionType() const
  {
    return static_cast<TransactionType>(mTransaction.index());
  }

  /**
   * Get a pointer to the wrapped transaction.
   *
   * @return A pointer to the wrapped transaction. Returns nullptr if the TransactionType is unknown or uninitialized.
   */
  // clang-format off
  template<typename T> inline T* getTransaction() { return std::get_if<T>(&mTransaction); }
  template<typename T> inline const T* getTransaction() const { return std::get_if<T>(&mTransaction); }
  // clang-format on

private:
  /**
   * The actual wrapped transaction.
   */
  AnyPossibleTransaction mTransaction;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_UNKNOWN_TRANSACTION_H_
// Filename: src/sdk/main/include/exceptions/BadEntityIdException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_BAD_ENTITY_ID_EXCEPTION_H_
#define HIERO_SDK_CPP_BAD_ENTITY_ID_EXCEPTION_H_

#include <exception>
#include <string>
#include <string_view>

namespace Hiero
{
/**
 * Exception that is thrown when a key could not be realized from a given input.
 */
class BadEntityIdException : public std::exception
{
public:
  /**
   * Construct with an entity, its expected checksum, and its calculated checksum.
   *
   * @param shard              The shard of the entity.
   * @param realm              The realm of the entity.
   * @param num                The num of the entity.
   * @param expectedChecksum   The checksum against which the calculated checksum was validated.
   * @param calculatedChecksum The checksum that was calculated of the input entity.
   */
  explicit BadEntityIdException(uint64_t shard,
                                uint64_t realm,
                                uint64_t num,
                                std::string_view expectedChecksum,
                                std::string_view calculatedChecksum)
    : mError(std::string("Expected checksum ") + expectedChecksum.data() + " for entity " + std::to_string(shard) +
             '.' + std::to_string(realm) + '.' + std::to_string(num) + " does not match its calculated checksum " +
             calculatedChecksum.data())
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

private:
  /**
   * Descriptive error message.
   */
  std::string mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_BAD_ENTITY_ID_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/BadKeyException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_BAD_KEY_EXCEPTION_H_
#define HIERO_SDK_CPP_BAD_KEY_EXCEPTION_H_

#include <exception>
#include <string_view>

namespace Hiero
{
/**
 * Exception that is thrown when a key could not be realized from a given input.
 */
class BadKeyException : public std::exception
{
public:
  /**
   * Construct with a message.
   *
   * @param msg The error message to further describe this exception.
   */
  explicit BadKeyException(std::string_view msg)
    : mError(msg)
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

private:
  /**
   * Descriptive error message.
   */
  std::string_view mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_BAD_KEY_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/BadMnemonicException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_BAD_MNEMONIC_EXCEPTION_H_
#define HIERO_SDK_CPP_BAD_MNEMONIC_EXCEPTION_H_

#include <exception>
#include <string_view>

namespace Hiero
{
/**
 * Exception that is thrown when a key could not be realized from a given input.
 */
class BadMnemonicException : public std::exception
{
public:
  /**
   * Construct with a message.
   *
   * @param msg The error message to further describe this exception.
   */
  explicit BadMnemonicException(std::string_view msg)
    : mError(msg)
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

private:
  /**
   * Descriptive error message.
   */
  std::string_view mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_BAD_MNEMONIC_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/IllegalStateException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_ILLEGAL_STATE_EXCEPTION_H_
#define HIERO_SDK_CPP_ILLEGAL_STATE_EXCEPTION_H_

#include <exception>
#include <string_view>

namespace Hiero
{
/**
 * Exception that is thrown when an action is attempted when an object is not in the correct state for said action.
 */
class IllegalStateException : public std::exception
{
public:
  /**
   * Construct with a message.
   *
   * @param msg The error message to further describe this exception.
   */
  explicit IllegalStateException(std::string_view msg)
    : mError(msg)
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

private:
  /**
   * Descriptive error message.
   */
  std::string_view mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_ILLEGAL_STATE_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/MaxAttemptsExceededException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_MAX_ATTEMPTS_EXCEEDED_EXCEPTION_H_
#define HIERO_SDK_CPP_MAX_ATTEMPTS_EXCEEDED_EXCEPTION_H_

#include <exception>
#include <string_view>

namespace Hiero
{
/**
 * Exception that is thrown when a processing exceeds its maximum number of attempts to submit a request to a network.
 */
class MaxAttemptsExceededException : public std::exception
{
public:
  /**
   * Construct with a message.
   *
   * @param msg The error message to further describe this exception.
   */
  explicit MaxAttemptsExceededException(std::string_view msg)
    : mError(msg)
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

private:
  /**
   * Descriptive error message.
   */
  std::string_view mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_MAX_ATTEMPTS_EXCEEDED_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/MaxQueryPaymentExceededException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_MAX_QUERY_PAYMENT_EXCEEDED_EXCEPTION_H_
#define HIERO_SDK_CPP_MAX_QUERY_PAYMENT_EXCEEDED_EXCEPTION_H_

#include <exception>
#include <string_view>

namespace Hiero
{
/**
 * Exception that is thrown when the cost to execute a Query is larger than the maximum allowed amount.
 */
class MaxQueryPaymentExceededException : public std::exception
{
public:
  /**
   * Construct with a message.
   *
   * @param msg The error message to further describe this exception.
   */
  explicit MaxQueryPaymentExceededException(std::string_view msg)
    : mError(msg)
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

private:
  /**
   * Descriptive error message.
   */
  std::string_view mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_MAX_QUERY_PAYMENT_EXCEEDED_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/OpenSSLException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_OPENSSL_EXCEPTION_H_
#define HIERO_SDK_CPP_OPENSSL_EXCEPTION_H_

#include <exception>
#include <string_view>

namespace Hiero
{
/**
 * Exception that encompasses all unrecoverable OpenSSL errors.
 */
class OpenSSLException : public std::exception
{
public:
  /**
   * Construct with a message.
   *
   * @param msg The error message to further describe this exception.
   */
  explicit OpenSSLException(std::string_view msg)
    : mError(msg)
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

private:
  /**
   * Descriptive error message.
   */
  std::string_view mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_OPENSSL_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/PrecheckStatusException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_PRECHECK_STATUS_EXCEPTION_H_
#define HIERO_SDK_CPP_PRECHECK_STATUS_EXCEPTION_H_

#include "Status.h"
#include "TransactionId.h"

#include <exception>
#include <optional>
#include <string_view>

namespace Hiero
{
/**
 * Exception that is thrown when a request has failed its pre-check.
 */
class PrecheckStatusException : public std::exception
{
public:
  /**
   * Construct with the ID of the transaction that failed and its status.
   *
   * @param transactionId The ID of the transaction that failed.
   * @param status        The status of the transaction.
   */
  explicit PrecheckStatusException(Status status,
                                   const std::optional<TransactionId>& transactionId = std::optional<TransactionId>())
    : mTransactionId(transactionId)
    , mStatus(status)
    , mError(((transactionId.has_value()) ? "Hiero transaction " + transactionId->toString() + ' ' : "") +
             "failed precheck with status " + gStatusToString.at(mStatus))
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

  /**
   * The ID of the transaction that failed. This can be uninitialized if a query fails pre-check without an associated
   * payment transaction.
   */
  std::optional<TransactionId> mTransactionId;

  /**
   * The status of the failed transaction.
   */
  Status mStatus = Status::OK;

  /**
   * Descriptive error message.
   */
  std::string mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_PRECHECK_STATUS_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/ReceiptStatusException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_RECEIPT_STATUS_EXCEPTION_H_
#define HIERO_SDK_CPP_RECEIPT_STATUS_EXCEPTION_H_

#include "Status.h"
#include "TransactionId.h"

#include <exception>
#include <string>
#include <string_view>

namespace Hiero
{
/**
 * Exception that is thrown when a TransactionReceipt contains a non-successful status (i.e. not Status::SUCCESS) and it
 * is configured to do so.
 */
class ReceiptStatusException : public std::exception
{
public:
  /**
   * Construct with the ID of the transaction that failed and its status.
   *
   * @param transactionId The ID of the transaction that failed.
   * @param status        The status of the transaction.
   */
  explicit ReceiptStatusException(const TransactionId& transactionId, Status status)
    : mTransactionId(transactionId)
    , mStatus(status)
    , mError("receipt for transaction " + mTransactionId.toString() + " raised status " + gStatusToString.at(mStatus))
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.c_str(); };

  /**
   * The ID of the transaction that failed.
   */
  TransactionId mTransactionId;

  /**
   * The status of the failed transaction.
   */
  Status mStatus = Status::OK;

  /**
   * Descriptive error message.
   */
  std::string mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_RECEIPT_STATUS_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/UninitializedException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_UNINITIALIZED_EXCEPTION_H_
#define HIERO_SDK_CPP_UNINITIALIZED_EXCEPTION_H_

#include <exception>
#include <string_view>

namespace Hiero
{
/**
 * Exception that encompasses all unrecoverable OpenSSL errors.
 */
class UninitializedException : public std::exception
{
public:
  /**
   * Construct with a message.
   *
   * @param msg The error message to further describe this exception.
   */
  explicit UninitializedException(std::string_view msg)
    : mError(msg)
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

private:
  /**
   * Descriptive error message.
   */
  std::string_view mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_UNINITIALIZED_EXCEPTION_H_
// Filename: src/sdk/main/include/exceptions/UnsupportedOperationException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_UNSUPPORTED_OPERATION_EXCEPTION_H_
#define HIERO_SDK_CPP_UNSUPPORTED_OPERATION_EXCEPTION_H_

#include <exception>
#include <string_view>

namespace Hiero
{
/**
 * Exception that encompasses trying to execute any unsupported operation.
 */
class UnsupportedOperationException : public std::exception
{
public:
  /**
   * Construct with a message.
   *
   * @param msg The error message to further describe this exception.
   */
  explicit UnsupportedOperationException(std::string_view msg)
    : mError(msg)
  {
  }

  /**
   * Get the descriptor message for this error.
   *
   * @return The descriptor message for this error.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.data(); };

private:
  /**
   * Descriptive error message.
   */
  std::string_view mError;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_UNSUPPORTED_OPERATION_EXCEPTION_H_
// Filename: src/sdk/main/include/impl/ASN1ECKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_ASN1_EC_KEY_H_
#define HIERO_SDK_CPP_IMPL_ASN1_EC_KEY_H_

#include "ASN1Object.h"

namespace Hiero::internal::asn1
{
constexpr size_t EC_KEY_LENGTH = 32; // bytes
// more than this would be a malicious attempt
constexpr size_t MAX_ENCRYPTED_KEY_LENGHT = 160; // bytes ~ 320 characters

/**
 * @class ASN1Key
 * ASN.1 key object.
 */
class ASN1ECKey : public ASN1Object
{
public:
  /**
   * Get the key value associated with the ASN.1 key.
   *
   * @return The key as a vector of bytes.
   */
  virtual std::vector<std::byte> getKey() const = 0;

protected:
  /**
   * Decode ASN.1 data representing an Elliptic Curve Key.
   *
   * This method decodes basic ASN.1 data, extracting key data and storing it in the `asn1KeyData` map.
   * EC Keys in ASN1 format always follow a common structure:
   *
   *   ECKey ::= SEQUENCE {
   *   version INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1) OPTIONAL,
   *   key STRING_DATA,
   *   parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
   *   otherKey [1] STRING_DATA OPTIONAL
   *   }
   *
   * @param bytes The ASN.1-encoded data representing the Elliptic Curve Key.
   */
  virtual void decode(const std::vector<std::byte>& bytes);

  /**
   * Get the value associated with the given ASN.1 tag.
   *
   * @param tag The ASN.1 tag.
   * @return The value associated with the tag as a vector of bytes.
   */
  virtual const std::vector<std::byte> get(const std::byte tag) const;

  /**
   * A map to store ASN.1 key data with their associated tags.
   */
  std::unordered_map<std::byte, std::vector<std::byte>> asn1KeyData;
};

} // namespace Hiero::internal:asn1

#endif // HIERO_SDK_CPP_IMPL_ASN1_EC_KEY_H_
// Filename: src/sdk/main/include/impl/ASN1ECPrivateKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_ASN1_EC_PRIVATE_KEY_H_
#define HIERO_SDK_CPP_IMPL_ASN1_EC_PRIVATE_KEY_H_

#include "ASN1ECKey.h"

namespace Hiero::internal::asn1
{
// The ASN.1 algorithm identifier prefix bytes for an ECDSAsecp256k1PrivateKey.
const std::vector<std::byte> ASN1_PRK_PREFIX_BYTES = { std::byte(0x30), std::byte(0x2E), std::byte(0x02),
                                                       std::byte(0x01), std::byte(0x01), std::byte(0x04),
                                                       std::byte(0x20) };

// The ASN.1 algorithm identifier suffix bytes for an ECDSAsecp256k1KeyPrivateKey.
const std::vector<std::byte> ASN1_PRK_SUFFIX_BYTES = { std::byte(0xA0), std::byte(0x07), std::byte(0x06),
                                                       std::byte(0x05), std::byte(0x2B), std::byte(0x81),
                                                       std::byte(0x04), std::byte(0x00), std::byte(0x0A) };

// PEM Format prefix/suffix string ECDSA
constexpr std::string_view PEM_ECPRK_PREFIX_STRING = "-----BEGIN EC PRIVATE KEY-----";
constexpr std::string_view PEM_ECPRK_SUFFIX_STRING = "-----END EC PRIVATE KEY-----";

/**
 * @class ASN1Key
 * @brief ASN.1 key object.
 */
class ASN1ECPrivateKey : public ASN1ECKey
{
public:
  /**
   * @brief Constructor for ASN.1 key from a vector of bytes.
   *
   * @param bytes The vector of bytes containing the ASN.1 key data.
   */
  ASN1ECPrivateKey(const std::vector<std::byte>& bytes);

  /**
   * @brief Get the key value associated with the ASN.1 key.
   *
   * @return The key as a vector of bytes.
   */
  std::vector<std::byte> getKey() const override;

private:
  /**
   * @brief Constructor for ASN.1 key.
   */
  ASN1ECPrivateKey() = default;
};

} // namespace Hiero::internal:asn1

#endif // HIERO_SDK_CPP_IMPL_ASN1_EC_PRIVATE_KEY_H_
// Filename: src/sdk/main/include/impl/ASN1ECPublicKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_ASN1_EC_PUBLIC_KEY_H_
#define HIERO_SDK_CPP_IMPL_ASN1_EC_PUBLIC_KEY_H_

#include "ASN1ECKey.h"

namespace Hiero::internal::asn1
{
/**
 * @brief The ASN.1 algorithm identifier prefix bytes for a compressed
 * ECDSA secp256k1 public key.
 * @details
 * Byte sequence: 3036301006072A8648CE3D020106052B8104000A0322
 */
const std::vector<std::byte> ASN1_CPUBK_PREFIX_BYTES = {
  std::byte(0x30), std::byte(0x36), std::byte(0x30), std::byte(0x10), std::byte(0x06), std::byte(0x07),
  std::byte(0x2A), std::byte(0x86), std::byte(0x48), std::byte(0xCE), std::byte(0x3D), std::byte(0x02),
  std::byte(0x01), std::byte(0x06), std::byte(0x05), std::byte(0x2B), std::byte(0x81), std::byte(0x04),
  std::byte(0x00), std::byte(0x0A), std::byte(0x03), std::byte(0x22)
};

/**
 * @brief The ASN.1 algorithm identifier prefix bytes for an uncompressed
 * ECDSA secp256k1 public key.
 * @details
 * Byte sequence: 3056301006072A8648CE3D020106052B8104000A0342
 */
const std::vector<std::byte> ASN1_UPUBK_PREFIX_BYTES = {
  std::byte(0x30), std::byte(0x56), std::byte(0x30), std::byte(0x10), std::byte(0x06), std::byte(0x07),
  std::byte(0x2A), std::byte(0x86), std::byte(0x48), std::byte(0xCE), std::byte(0x3D), std::byte(0x02),
  std::byte(0x01), std::byte(0x06), std::byte(0x05), std::byte(0x2B), std::byte(0x81), std::byte(0x04),
  std::byte(0x00), std::byte(0x0A), std::byte(0x03), std::byte(0x42)
};

// PEM Format prefix/suffix string
constexpr std::string_view PEM_ECPUBK_PREFIX_STRING = "-----BEGIN EC PUBLIC KEY-----";
constexpr std::string_view PEM_ECPUBK_SUFFIX_STRING = "-----END EC PUBLIC KEY-----";

/**
 * @class ASN1ECPublicKey
 * @brief ASN.1 elliptic curve public key object.
 */
class ASN1ECPublicKey : public ASN1ECKey
{
public:
  /**
   * @brief Constructor for ASN.1 elliptic curve public key from a vector of bytes.
   * @param bytes The vector of bytes containing the ASN.1 key data.
   */
  ASN1ECPublicKey(const std::vector<std::byte>& bytes);

  /**
   * @brief Get the key value associated with the ASN.1 elliptic curve public key.
   * @return The key as a vector of bytes.
   */
  std::vector<std::byte> getKey() const override;

private:
  /**
   * @brief Constructor for ASN.1 elliptic curve public key.
   */
  ASN1ECPublicKey() = default;

  /**
   * @brief Populate X and Y coordinates from the ASN.1 key bytes.
   */
  void populateXYcoords();

  std::vector<std::byte> ecXcoord; ///< X coordinate of the elliptic curve public key.
  std::vector<std::byte> ecYcoord; ///< Y coordinate of the elliptic curve public key.
};

} // namespace Hiero::internal:asn1

#endif // HIERO_SDK_CPP_IMPL_ASN1_EC_PUBLIC_KEY_H_
// Filename: src/sdk/main/include/impl/ASN1ED25519PrivateKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_ASN1_ED25519_PRIVATE_KEY_H_
#define HIERO_SDK_CPP_IMPL_ASN1_ED25519_PRIVATE_KEY_H_

#include "ASN1ECKey.h"

namespace Hiero::internal::asn1
{
// The ASN.1 algorithm identifier prefix bytes for an EC ED25519PrivateKey
const std::vector<std::byte> ASN1_EDPRK_PREFIX_BYTES = {
  std::byte(0x30), std::byte(0x2E), std::byte(0x02), std::byte(0x01), std::byte(0x00), std::byte(0x30),
  std::byte(0x05), std::byte(0x06), std::byte(0x03), std::byte(0x2B), std::byte(0x65), std::byte(0x70),
  std::byte(0x04), std::byte(0x22), std::byte(0x04), std::byte(0x20)
};

// PEM Format prefix/suffix string EC ED25519 Key
constexpr std::string_view PEM_EDPRK_PREFIX_STRING = "-----BEGIN PRIVATE KEY-----";
constexpr std::string_view PEM_EDPRK_SUFFIX_STRING = "-----END PRIVATE KEY-----";

/**
 * @class ASN1Key
 * @brief ASN.1 key object.
 */
class ASN1ED25519PrivateKey : public ASN1ECKey
{
public:
  /**
   * @brief Constructor for ASN.1 key from a vector of bytes.
   *
   * @param bytes The vector of bytes containing the ASN.1 key data.
   */
  ASN1ED25519PrivateKey(const std::vector<std::byte>& bytes);

  /**
   * @brief Get the key value associated with the ASN.1 key.
   *
   * @return The key as a vector of bytes.
   */
  std::vector<std::byte> getKey() const override;

private:
  /**
   * @brief Constructor for ASN.1 key.
   */
  ASN1ED25519PrivateKey() = default;
};

} // namespace Hiero::internal:asn1

#endif // HIERO_SDK_CPP_IMPL_ASN1_ED25519_PRIVATE_KEY_H_
// Filename: src/sdk/main/include/impl/ASN1ED25519PublicKey.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_ASN1_ED25519_PUBLIC_KEY_H_
#define HIERO_SDK_CPP_IMPL_ASN1_ED25519_PUBLIC_KEY_H_

#include "ASN1ECKey.h"

namespace Hiero::internal::asn1
{
/**
 * The prefix bytes of a DER-encoded ED25519PublicKey.
 */
static inline const std::vector<std::byte> ASN1_EDPBK_PREFIX_BYTES = {
  std::byte(0x30), std::byte(0x2A), std::byte(0x30), std::byte(0x05), std::byte(0x06), std::byte(0x03),
  std::byte(0x2B), std::byte(0x65), std::byte(0x70), std::byte(0x03), std::byte(0x21), std::byte(0x00)
};

// PEM Format prefix/suffix string
constexpr std::string_view PEM_ECPBK_PREFIX_STRING = "-----BEGIN PUBLIC KEY-----";
constexpr std::string_view PEM_ECPBK_SUFFIX_STRING = "-----END PUBLIC KEY-----";

/**
 * @class ASN1ED25519PublicKey
 * @brief ASN.1 elliptic curve public key object.
 */
class ASN1ED25519PublicKey : public ASN1ECKey
{
public:
  /**
   * @brief Constructor for ASN.1 elliptic curve public key from a vector of bytes.
   * @param bytes The vector of bytes containing the ASN.1 key data.
   */
  ASN1ED25519PublicKey(const std::vector<std::byte>& bytes);

  /**
   * @brief Get the key value associated with the ASN.1 elliptic curve public key.
   * @return The key as a vector of bytes.
   */
  std::vector<std::byte> getKey() const override;

private:
  /**
   * @brief Constructor for ASN.1 elliptic curve public key.
   */
  ASN1ED25519PublicKey() = default;
};

} // namespace Hiero::internal:asn1

#endif // HIERO_SDK_CPP_IMPL_ASN1_ED25519_PUBLIC_KEY_H_
// Filename: src/sdk/main/include/impl/ASN1Object.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_ASN1_OBJECT_H_
#define HIERO_SDK_CPP_IMPL_ASN1_OBJECT_H_

#include <iostream>
#include <unordered_map>
#include <vector>

namespace Hiero::internal::asn1
{

/**
 * Constants for ASN.1 standard.
 */
constexpr std::byte INTEGER = std::byte(0x02);
constexpr std::byte BIT_STRING = std::byte(0x03);
constexpr std::byte OCTET_STRING = std::byte(0x04);
constexpr std::byte OBJECT_IDENTIFIER = std::byte(0x06);
constexpr std::byte SEQUENCE = std::byte(0x30);

/**
 * @class ASN1Object
 * Abstract base class for ASN.1 objects.
 */
class ASN1Object
{
protected:
  /**
   * Get the ASN.1 object's value in bytes.
   *
   * @param tag The ASN.1 tag of the object.
   * @return The object's value in bytes.
   */
  virtual const std::vector<std::byte> get(const std::byte tag) const = 0;

  /**
   * Decode the ASN.1 object from a vector of bytes.
   *
   * @param data The vector of bytes containing the ASN.1 object's data.
   */
  virtual void decode(const std::vector<std::byte>& data) = 0;
};

} // namespace Hiero::internal::asn1

#endif // HIERO_SDK_CPP_IMPL_ASN1_OBJECT_H_// Filename: src/sdk/main/include/impl/BaseNetwork.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_BASE_NETWORK_H_
#define HIERO_SDK_CPP_IMPL_BASE_NETWORK_H_

#include "AccountId.h"
#include "BaseNode.h"
#include "Defaults.h"
#include "LedgerId.h"
#include "TLSBehavior.h"

#include <chrono>
#include <memory>
#include <mutex>
#include <string>
#include <string_view>
#include <unordered_map>
#include <unordered_set>

namespace Hiero::internal
{
template<typename NetworkType, typename KeyType, typename NodeType>
class BaseNetwork
{
public:
  /**
   * Set the NodeTypes in this BaseNetwork. It shutdowns and removes any NodeType from this BaseNetwork if the input
   * network doesn't contain its representation. It will then add any new NodeTypes that don't already exist in this
   * BaseNetwork.
   *
   * @param network The map of addresses to their keys that represent NodeTypes to add to this BaseNetwork.
   * @return A reference to this derived BaseNetwork object with the newly-set NodeTypes.
   */
  NetworkType& setNetwork(const std::unordered_map<std::string, KeyType>& network);

  /**
   * Increase the backoff of the input NodeType.
   *
   * @param node The NodeType of which to increase the backoff.
   */
  void increaseBackoff(const std::shared_ptr<NodeType>& node);

  /**
   * Decrease the backoff of the input NodeType.
   *
   * @param node The NodeType of which to decrease the backoff.
   */
  void decreaseBackoff(const std::shared_ptr<NodeType>& node) const;

  /**
   * Get the list of all proxies at a specified key.
   *
   * @return The list of all proxies at a specified key.
   */
  [[nodiscard]] std::vector<std::shared_ptr<NodeType>> getNodeProxies(const KeyType& key);

  /**
   * Close the connects on this BaseNetwork.
   */
  void close() const;

  /**
   * Set the maximum number of times to try to use a NodeType to submit a request. Once the NodeType exceeds this number
   * of submission attempts that have returned a bad gRPC status, that NodeType will be permanently removed from this
   * BaseNetwork.
   *
   * @param attempts The maximum number of times a NodeType can be retried.
   * @return A reference to this derived BaseNetwork object with the newly-set maximum node attempts.
   */
  NetworkType& setMaxNodeAttempts(unsigned int attempts);

  /**
   * Set the minimum amount of time to backoff from a NodeType after a bad gRPC status is received.
   *
   * @param backoff The minimum backoff time to use for a NodeType after a bad gRPC status is received.
   * @return A reference to this derived BaseNetwork object with the newly-set minimum backoff.
   */
  NetworkType& setMinNodeBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Set the maximum amount of time to backoff from a NodeType after a bad gRPC status is received.
   *
   * @param backoff The maximum backoff time to use for a NodeType after a bad gRPC status is received.
   * @return A reference to this derived BaseNetwork object with the newly-set maximum backoff.
   */
  NetworkType& setMaxNodeBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Set the minimum amount of time to wait before readmitting NodeTypes as "healthy".
   *
   * @param time The minimum amount of time to wait before readmitting NodeTypes as "healthy".
   * @return A reference to this derived BaseNetwork object with the newly-set minimum node readmit time.
   */
  NetworkType& setMinNodeReadmitTime(const std::chrono::system_clock::duration& time);

  /**
   * Set the maximum amount of time to wait before readmitting NodeTypes as "healthy".
   *
   * @param time The maximum amount of time to wait before readmitting NodeTypes as "healthy".
   * @return A reference to this derived BaseNetwork object with the newly-set maximum node readmit time.
   */
  NetworkType& setMaxNodeReadmitTime(const std::chrono::system_clock::duration& time);

  /**
   * Set the amount of time to allow gRPC connections on this BaseNetwork to close gracefully before forcibly
   * terminating them.
   *
   * @param timeout The amount of time to allow gRPC connections on this BaseNetwork to close gracefully.
   * @return A reference to this derived BaseNetwork object with the newly-set close timeout.
   */
  NetworkType& setCloseTimeout(const std::chrono::system_clock::duration& timeout);

  /**
   * Set the ledger ID of this BaseNetwork.
   *
   * @param ledgerId The ledger ID to set.
   * @return A reference to this derived BaseNetwork object with the newly-set ledger ID.
   */
  virtual NetworkType& setLedgerId(const LedgerId& ledgerId);

  /**
   * Get the transport security policy of this BaseNetwork.
   *
   * @return The transport security policy of this BaseNetwork.
   */
  [[nodiscard]] inline TLSBehavior isTransportSecurity() const { return mTransportSecurity; }

  /**
   * Get the maximum number of times to try to use a NodeType before removing it from this BaseNetwork.
   *
   * @return The maximum number of times to try to use a NodeType before removing it from this BaseNetwork.
   */
  [[nodiscard]] inline unsigned int getMaxNodeAttempts() const { return mMaxNodeAttempts; }

  /**
   * Get the minimum amount of time to backoff from a NodeType after a bad gRPC status is received.
   *
   * @return The minimum amount of time to backoff from a NodeType after a bad gRPC status is received.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getMinNodeBackoff() const { return mMinNodeBackoff; }

  /**
   * Get the maximum amount of time to backoff from a NodeType after a bad gRPC status is received.
   *
   * @return The maximum amount of time to backoff from a NodeType after a bad gRPC status is received.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getMaxNodeBackoff() const { return mMaxNodeBackoff; }

  /**
   * Get the minimum amount of time to wait before readmitting NodeTypes as "healthy".
   *
   * @return The minimum amount of time to wait before readmitting NodeTypes as "healthy".
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getMinNodeReadmitTime() const { return mMinNodeReadmitTime; }

  /**
   * Get the maximum amount of time to wait before readmitting NodeTypes as "healthy".
   *
   * @return The maximum amount of time to wait before readmitting NodeTypes as "healthy".
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getMaxNodeReadmitTime() const { return mMaxNodeReadmitTime; }

  /**
   * Get the amount of time to allow gRPC connections on this BaseNetwork to close gracefully before forcibly
   * terminating them.
   *
   * @return The amount of time to allow gRPC connections on this BaseNetwork to close gracefully before forcibly
   *         terminating them.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getCloseTimeout() const { return mCloseTimeout; }

  /**
   * Get the ledger ID of this Network.
   *
   * @return The ledger ID of this Network.
   */
  [[nodiscard]] inline LedgerId getLedgerId() const { return mLedgerId; }

protected:
  ~BaseNetwork() = default;

  /**
   * Get a number of the most healthy nodes on this BaseNetwork. "Healthy"-ness is determined by sort order; the lower
   * index nodes in the returned vector are considered the most healthy.
   *
   * This will also remove any nodes which have hit or exceeded mMaxNodeAttempts permanently from the BaseNetwork.
   *
   * @param count The number of nodes to get.
   * @return A list of pointers to the healthiest BaseNodes on this BaseNetwork.
   */
  [[nodiscard]] std::vector<std::shared_ptr<NodeType>> getNumberOfMostHealthyNodes(unsigned int count);

  /**
   * Set the transport security policy.
   *
   * @param tls The transport security policy to set.
   */
  void setTransportSecurityInternal(TLSBehavior tls);

  /**
   * Get the map of KeyTypes to their NodeTypes on this BaseNetwork.
   *
   * @return The map of KeyTypes to their NodeTypes on this BaseNetwork.
   */
  [[nodiscard]] inline const std::unordered_map<KeyType, std::unordered_set<std::shared_ptr<NodeType>>>&
  getNetworkInternal() const
  {
    return mNetwork;
  }
  [[nodiscard]] inline std::unordered_map<KeyType, std::unordered_set<std::shared_ptr<NodeType>>> getNetworkInternal()
  {
    return mNetwork;
  }

  /**
   * Get the list of NodeTypes on this BaseNetwork.
   *
   * @return The list of NodeTypes on this BaseNetwork.
   */
  [[nodiscard]] inline const std::unordered_set<std::shared_ptr<NodeType>>& getNodes() const { return mNodes; }
  [[nodiscard]] inline std::unordered_set<std::shared_ptr<NodeType>>& getNodes() { return mNodes; }

  /**
   * Get this BaseNetwork's mutex.
   *
   * @return This BaseNetwork's mutex.
   */
  [[nodiscard]] inline std::shared_ptr<std::mutex> getLock() const { return mMutex; }

private:
  /**
   * Create a NodeType for this BaseNetwork based on a network entry.
   *
   * @param address The address of the NodeType.
   * @param key     The key for the NodeType.
   * @return A pointer to the created NodeType.
   */
  [[nodiscard]] virtual std::shared_ptr<NodeType> createNodeFromNetworkEntry(
    std::string_view address,
    [[maybe_unused]] const KeyType& key) const = 0;

  /**
   * Readmit nodes from the mNodes list to the mHealthyNodes list when the time has passed the mEarliestReadmitTime.
   * While readmitting nodes, mEarliestReadmitTime will be updated to a new value. This value is either the value of
   * the node with the smallest readmission time from now, or mMinNodeReadmitTime or mMaxNodeReadmitTime.
   */
  void readmitNodes();

  /**
   * Remove a BaseNode from this BaseNetwork.
   *
   * @param node A pointer to the BaseNode to remove.
   */
  void removeNodeFromNetwork(const std::shared_ptr<NodeType>& node);

  /**
   * Map of node identifiers (KeyTypes) to their NodeTypes.
   */
  std::unordered_map<KeyType, std::unordered_set<std::shared_ptr<NodeType>>> mNetwork;

  /**
   * The list of all nodes on this BaseNetwork.
   */
  std::unordered_set<std::shared_ptr<NodeType>> mNodes;

  /**
   * The list of current healthy nodes on this BaseNetwork.
   */
  std::unordered_set<std::shared_ptr<NodeType>> mHealthyNodes;

  /**
   * The transport security policy of this BaseNetwork.
   */
  TLSBehavior mTransportSecurity = TLSBehavior::REQUIRE;

  /**
   * The maximum number of times to try to use a NodeType to submit a request. Once the NodeType exceeds this number of
   * submission attempts that have returned a bad gRPC status, that NodeType will be permanently removed from this
   * BaseNetwork.
   */
  unsigned int mMaxNodeAttempts = DEFAULT_MAX_NODE_ATTEMPTS;

  /**
   * The minimum amount of time to wait to use a NodeType after it has received a bad gRPC status.
   */
  std::chrono::system_clock::duration mMinNodeBackoff = DEFAULT_MIN_NODE_BACKOFF;

  /**
   * The maximum amount of time to wait to use a NodeType after it has received a bad gRPC status.
   */
  std::chrono::system_clock::duration mMaxNodeBackoff = DEFAULT_MAX_NODE_BACKOFF;

  /**
   * The minimum time to wait before attempting to readmit nodes.
   */
  std::chrono::system_clock::duration mMinNodeReadmitTime = DEFAULT_MIN_NODE_BACKOFF;

  /**
   * The maximum time to wait before attempting to readmit nodes.
   */
  std::chrono::system_clock::duration mMaxNodeReadmitTime = DEFAULT_MAX_NODE_BACKOFF;

  /**
   * The earliest time that a node should be readmitted.
   */
  std::chrono::system_clock::time_point mEarliestReadmitTime = std::chrono::system_clock::now();

  /**
   * The timeout for closing either a single node when setting a new network, or closing the entire network.
   */
  std::chrono::system_clock::duration mCloseTimeout = DEFAULT_CLOSE_TIMEOUT;

  /**
   * The ledger ID of the network.
   */
  LedgerId mLedgerId;

  /**
   * The mutex for this BaseNetwork, kept inside a std::shared_ptr to keep BaseNetwork copyable/movable.
   */
  std::shared_ptr<std::mutex> mMutex = std::make_shared<std::mutex>();
};

} // namespace Hiero::internal

#endif // HIERO_SDK_CPP_IMPL_BASE_NETWORK_H_
// Filename: src/sdk/main/include/impl/BaseNode.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_BASE_NODE_H_
#define HIERO_SDK_CPP_IMPL_BASE_NODE_H_

#include <basic_types.pb.h> // This is needed for Windows to build for some reason.

#include "BaseNodeAddress.h"
#include "Defaults.h"

#include <chrono>
#include <grpcpp/channel.h>
#include <grpcpp/security/credentials.h>
#include <mutex>

namespace Hiero::internal
{
template<typename NodeType, typename KeyType>
class BaseNode
{
public:
  /**
   * Get this BaseNode's key.
   *
   * @return This BaseNode's key.
   */
  [[nodiscard]] virtual KeyType getKey() const = 0;

  /**
   * Close this BaseNode's connection to its remote node.
   */
  void close();

  /**
   * Increase the backoff of this BaseNode.
   */
  void increaseBackoff();

  /**
   * Decrease the backoff of this BaseNode.
   */
  void decreaseBackoff();

  /**
   * Is this BaseNode currently considered healthy?
   *
   * @return \c TRUE if this BaseNode is healthy, otherwise \c FALSE.
   */
  [[nodiscard]] bool isHealthy() const;

  /**
   * Has this BaseNode failed to connect to its remote node?
   *
   * @return \c TRUE if this BaseNode has failed to connect to its remote node, otherwise \c FALSE.
   */
  [[nodiscard]] bool channelFailedToConnect();

  /**
   * Get the remaining amount of time this BaseNode has in its backoff.
   *
   * @return The remaining amount of time this BaseNode has in its backoff.
   */
  [[nodiscard]] std::chrono::system_clock::duration getRemainingTimeForBackoff() const;

  /**
   * Set the minimum amount of time for this BaseNode to backoff after a bad gRPC status is received.
   *
   * @param backoff The minimum backoff time for this BaseNode after a bad gRPC status is received.
   * @return A reference to this derived BaseNode object with the newly-set minimum backoff.
   */
  NodeType& setMinNodeBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Set the maximum amount of time for this BaseNode to backoff after a bad gRPC status is received.
   *
   * @param backoff The maximum backoff time for this BaseNode after a bad gRPC status is received.
   * @return A reference to this derived BaseNode object with the newly-set minimum backoff.
   */
  NodeType& setMaxNodeBackoff(const std::chrono::system_clock::duration& backoff);

  /**
   * Get this BaseNode's BaseNodeAddress.
   *
   * @return address The BaseNodeAddress of this BaseNode.
   */
  [[nodiscard]] inline BaseNodeAddress getAddress() const
  {
    std::unique_lock lock(*mMutex);
    return mAddress;
  }

  /**
   * Get the minimum amount of time for this BaseNode to backoff after a bad gRPC status is received.
   *
   * @return The minimum amount of time for this BaseNode to backoff after a bad gRPC status is received.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getMinNodeBackoff() const
  {
    std::unique_lock lock(*mMutex);
    return mMinNodeBackoff;
  }

  /**
   * Get the maximum amount of time for this BaseNode to backoff after a bad gRPC status is received.
   *
   * @return The maximum amount of time for this BaseNode to backoff after a bad gRPC status is received.
   */
  [[nodiscard]] inline std::chrono::system_clock::duration getMaxNodeBackoff() const
  {
    std::unique_lock lock(*mMutex);
    return mMaxNodeBackoff;
  }

  /**
   * Get the number of times this BaseNode has received a bad gRPC status when attempting to submit a request.
   *
   * @return The number of times this BaseNode has received a bad gRPC status.
   */
  [[nodiscard]] inline unsigned int getBadGrpcStatusCount() const
  {
    std::unique_lock lock(*mMutex);
    return mBadGrpcStatusCount;
  }

  /**
   * Get the time at which this BaseNode will be considered "healthy".
   *
   * @return The time at which this BaseNode will be considered "healthy".
   */
  [[nodiscard]] inline std::chrono::system_clock::time_point getReadmitTime() const
  {
    std::unique_lock lock(*mMutex);
    return mReadmitTime;
  }

  /**
   * Get this BaseNode's mutex.
   *
   * @return This BaseNode's mutex.
   */
  [[nodiscard]] inline std::shared_ptr<std::mutex> getLock() const { return mMutex; }

protected:
  ~BaseNode() = default;

  /**
   * Construct with a BaseNodeAddress.
   *
   * @param address The BaseNodeAddress of this BaseNode.
   */
  explicit BaseNode(BaseNodeAddress address);

  /**
   * Set the BaseNodeAddress of this BaseNode. This will also close this BaseNode's current connection.
   *
   * @param address The BaseNodeAddress to set.
   */
  NodeType& setAddress(const BaseNodeAddress& address);

  /**
   * Get this BaseNode's gRPC channel. Creates and initializes a new channel if one isn't already created.
   *
   * @return A pointer to this BaseNode's gRPC channel.
   */
  [[nodiscard]] std::shared_ptr<grpc::Channel> getChannel();

private:
  /**
   * How often to query for the state of the channel when determining if this BaseNode has connected to its remote node.
   */
  static constexpr auto GET_STATE_INTERVAL = std::chrono::milliseconds(50);

  /**
   * How long to try and let the channel connect before calling the connection a failure.
   */
  static constexpr auto GET_STATE_TIMEOUT = std::chrono::seconds(10);

  /**
   * Get the TLS credentials for this BaseNode's gRPC channel.
   *
   * @return A pointer to the TLS credentials for this BaseNode's gRPC channel.
   */
  [[nodiscard]] virtual std::shared_ptr<grpc::ChannelCredentials> getTlsChannelCredentials() const;

  /**
   * Initialize the stubs in this derived BaseNode with this BaseNode's gRPC channel.
   */
  virtual void initializeStubs()
  { // Intentionally unimplemented, derived BaseNodes that don't use stubs require no functionality.
  }

  /**
   * Close the stubs in this derived BaseNode.
   */
  virtual void closeStubs()
  { // Intentionally unimplemented, derived BaseNodes that don't use stubs require no functionality.
  }

  /**
   * Get the authority of this BaseNode.
   *
   * @return The authority of this BaseNode.
   */
  [[nodiscard]] virtual inline std::string getAuthority() const { return "127.0.0.1"; }

  /**
   * Close this BaseNode's channel and any stubs using that channel.
   */
  void closeChannel();

  /**
   * The address of this BaseNode.
   */
  BaseNodeAddress mAddress;

  /**
   * Pointer to the gRPC channel used to communicate with the gRPC server living on the remote node.
   */
  std::shared_ptr<grpc::Channel> mChannel = nullptr;

  /**
   * The minimum amount of time to wait to use this BaseNode after it has received a bad gRPC status.
   */
  std::chrono::system_clock::duration mMinNodeBackoff = DEFAULT_MIN_NODE_BACKOFF;

  /**
   * The maximum amount of time to wait to use this BaseNode after it has received a bad gRPC status.
   */
  std::chrono::system_clock::duration mMaxNodeBackoff = DEFAULT_MAX_NODE_BACKOFF;

  /**
   * The current amount of time to wait to use this BaseNode after it has received a bad gRPC status. This will increase
   * exponentially until mMaxNodeBackoff is reached.
   */
  std::chrono::system_clock::duration mCurrentBackoff = DEFAULT_MIN_NODE_BACKOFF;

  /**
   * The time at which this BaseNode will be considered "healthy".
   */
  std::chrono::system_clock::time_point mReadmitTime = std::chrono::system_clock::now();

  /**
   * The number of times this BaseNode has received a bad gRPC status.
   */
  unsigned int mBadGrpcStatusCount = 0U;

  /**
   * Is the gRPC channel being utilized by this BaseNode to communicate with its remote node initialized?
   */
  bool mIsConnected = false;

  /**
   * The mutex for this BaseNode, kept inside a std::shared_ptr to keep BaseNetwork copyable/movable.
   */
  std::shared_ptr<std::mutex> mMutex = std::make_shared<std::mutex>();
};

} // namespace Hiero::internal

#endif // HIERO_SDK_CPP_IMPL_BASE_NODE_H_
// Filename: src/sdk/main/include/impl/BaseNodeAddress.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_BASE_NODE_ADDRESS_H_
#define HIERO_SDK_CPP_IMPL_BASE_NODE_ADDRESS_H_

#include <string>
#include <string_view>

namespace Hiero::internal
{
class BaseNodeAddress
{
public:
  /**
   * Port numbers for various node types and security.
   */
  static constexpr unsigned int PORT_MIRROR_PLAIN = 5600U;
  static constexpr unsigned int PORT_MIRROR_TLS = 443U;
  static constexpr unsigned int PORT_NODE_PLAIN = 50211U;
  static constexpr unsigned int PORT_NODE_TLS = 50212U;

  /**
   * Construct with values for name, address, and port.
   *
   * @param name    The name with which to construct.
   * @param address The address with which to construct.
   * @param port    The port with which to construct.
   */
  explicit BaseNodeAddress(std::string_view name, std::string_view address, unsigned int port);

  /**
   * Construct a BaseNodeAddress from an address string that contains the IP and port.
   *
   * @param address The address of the BaseNodeAddress.
   * @return The constructed BaseNodeAddress.
   * @throws std::invalid_argument If the provided address is malformed.
   */
  [[nodiscard]] static BaseNodeAddress fromString(std::string_view address);

  /**
   * Compare this BaseNodeAddress to another BaseNodeAddress and determine if they represent the same node address.
   *
   * @param other The other BaseNodeAddress with which to compare this BaseNodeAddress.
   * @return \c TRUE if this BaseNodeAddress is the same as the input BaseNodeAddress, otherwise \c FALSE.
   */
  bool operator==(const BaseNodeAddress& other) const;

  /**
   * Create a copy of this BaseNodeAddress but using TLS.
   *
   * @return The copy of this BoseNodeAddress using TLS.
   */
  [[nodiscard]] BaseNodeAddress toSecure() const;

  /**
   * Create a copy of this BaseNodeAddress but not using TLS.
   *
   * @return The copy of this BoseNodeAddress not using TLS.
   */
  [[nodiscard]] BaseNodeAddress toInsecure() const;

  /**
   * Get the string representation of this BaseNodeAddress.
   *
   * @return The string representation of this BaseNodeAddress.
   */
  [[nodiscard]] std::string toString() const;

  /**
   * Is this BaseNodeAddress in process?
   *
   * @return \c TRUE if this BaseNodeAddress is in process, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool isInProcess() const { return !mName.empty(); }

  /**
   * Is this BaseNodeAddress using transport security?
   *
   * @param \c TRUE if this BaseNodeAddress is using TLS, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool isTransportSecurity() const
  {
    return (mPort == PORT_NODE_TLS) || (mPort == PORT_MIRROR_TLS);
  }

  /**
   * Get the name of this BaseNodeAddress.
   *
   * @return The name of this BaseNodeAddress.
   */
  [[nodiscard]] inline std::string getName() const { return mName; }

  /**
   * Get the IP address of this BaseNodeAddress.
   *
   * @return The IP address of this BaseNodeAddress.
   */
  [[nodiscard]] inline std::string getAddress() const { return mAddress; }

  /**
   * Get the port of this BaseNodeAddress.
   *
   * @return The port of this BaseNodeAddress.
   */
  [[nodiscard]] inline unsigned int getPort() const { return mPort; }

private:
  /**
   * The name of the address. This is used for "in-process" addresses.
   */
  std::string mName;

  /**
   * The IP address.
   */
  std::string mAddress;

  /**
   * The port.
   */
  unsigned int mPort = 0U;
};

} // namespace Hiero::internal

namespace std
{
template<>
struct hash<Hiero::internal::BaseNodeAddress>
{
  /**
   * Operator override to enable use of BaseNodeAddress as map key.
   */
  size_t operator()(const Hiero::internal::BaseNodeAddress& address) const
  {
    return hash<string>()(address.toString());
  }
};

} // namespace std

#endif // HIERO_SDK_CPP_IMPL_BASE_NODE_ADDRESS_H_
// Filename: src/sdk/main/include/impl/DerivationPathUtils.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_DERIVATION_PATH_UTILS_H_
#define HIERO_SDK_CPP_IMPL_DERIVATION_PATH_UTILS_H_

#include <cstddef>
#include <cstdint>
#include <vector>

/**
 * Utility functions dealing with wallet derivation paths, as described in BIP32, BIP44, and SLIP10.
 */
namespace Hiero::internal::DerivationPathUtils
{
/**
 * Check if an index falls into the "unhardened" or "hardened" category.
 * Unhardened: [0, 2147483647]; Hardened: [2147483648, UINT32_MAX]
 *
 * @param index The index to check.
 * @return \c TRUE if the index is in the hardened range, otherwise \c FALSE.
 */
bool isHardenedChildIndex(uint32_t index);

/**
 * Convert an index into its hardened counterpart (e.g. 0 -> 2147483648, 1-> 2147483649, etc.).
 *
 * @param index The index of which to get the hardened counterpart.
 * @return The hardened index.
 * @throws std::invalid_argument If the index is already hardened.
 */
uint32_t getHardenedIndex(uint32_t index);

/**
 * Converts a uint32_t index into a big endian byte array (direct implementation of ser32 function from BIP 32)
 *
 * @param childIndex The index to convert to a big endian byte array.
 * @return The big endian byte array representing the child index.
 */
std::vector<std::byte> indexToBigEndianArray(uint32_t childIndex);

}; // namespace Hiero::internal::DerivationPathUtils

#endif // HIERO_SDK_CPP_IMPL_DERIVATION_PATH_UTILS_H_
// Filename: src/sdk/main/include/impl/DurationConverter.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_DURATION_CONVERTER_H_
#define HIERO_SDK_CPP_IMPL_DURATION_CONVERTER_H_

#include <chrono>
#include <memory>

namespace proto
{
class Duration;
}

namespace Hiero::internal::DurationConverter
{
/**
 * Get the duration in seconds represented by a Duration protobuf object.
 *
 * @param duration The Duration protobuf object from which to get the duration.
 * @return The duration in seconds of the input Duration protobuf object.
 */
std::chrono::seconds fromProtobuf(const proto::Duration& duration);

/**
 * Create a Duration protobuf object from a generic duration.
 *
 * @param duration The duration object from which to create a Duration protobuf object.
 * @return A pointer to the created Duration protobuf object.
 */
proto::Duration* toProtobuf(const std::chrono::system_clock::duration& duration);

} // namespace Hiero::internal::DurationConverter

#endif // HIERO_SDK_CPP_IMPL_DURATION_CONVERTER_H_
// Filename: src/sdk/main/include/impl/EntityIdHelper.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_ENTITY_ID_HELPER_H_
#define HIERO_SDK_CPP_IMPL_ENTITY_ID_HELPER_H_

#include <charconv>
#include <cstddef>
#include <stdexcept>
#include <string>
#include <string_view>
#include <vector>

namespace Hiero
{
class Client;
class LedgerId;
}

namespace Hiero::internal::EntityIdHelper
{
/**
 * The length of a Solidity address in bytes.
 */
constexpr unsigned int SOLIDITY_ADDRESS_LEN = 20;

/**
 * The length of a hex-encoded Solidity address.
 */
constexpr unsigned int SOLIDITY_ADDRESS_LEN_HEX = SOLIDITY_ADDRESS_LEN * 2;

/**
 * Create an EntityType from a Solidity address byte array.
 *
 * @tparam EntityType The type of entity to create.
 * @param address The Solidity address byte array from which to construct the EntityType.
 * @return The constructed EntityType.
 * @throws std::invalid_argument If the input byte array is not a valid Solidity address.
 */
template<typename EntityType>
[[nodiscard]] EntityType fromSolidityAddress(const std::vector<std::byte>& address);

/**
 * Convert a string to a number type. E.g. "123" will return 123.
 *
 * @param str The string to convert.
 * @return The number type contained in the string.
 */
template<typename T = uint64_t>
[[nodiscard]] T getNum(std::string_view str)
{
  T num;
  if (auto result = std::from_chars(str.data(), str.data() + str.size(), num);
      result.ec != std::errc() || result.ptr != str.data() + str.size())
  {
    throw std::invalid_argument("Input entity ID string is malformed");
  }

  return num;
}

/**
 * Get the shard from an entity ID.
 *
 * @param id The ID of the entity from which to grab the shard number.
 * @return The shard number of the input entity ID.
 * @throws std::invalid_argument If the shard number is unable to be realized from the input entity ID.
 */
[[nodiscard]] uint64_t getShardNum(std::string_view id);

/**
 * Get the realm from an entity ID.
 *
 * @param id The ID of the entity from which to grab the realm number.
 * @return The realm number of the input entity ID.
 * @throws std::invalid_argument If the realm number is unable to be realized from the input entity ID.
 */
[[nodiscard]] uint64_t getRealmNum(std::string_view id);

/**
 * Get the number from an entity ID.
 *
 * @param id The ID of the entity from which to grab the entity number.
 * @return The entity number of the input entity ID.
 * @throws std::invalid_argument If the entity number is unable to be realized from the input entity ID.
 */
[[nodiscard]] uint64_t getEntityNum(std::string_view id);

/**
 * Get the number from an entity ID as a string.
 *
 * @param id The ID of the entity from which to grab the entity number.
 * @return The entity number of the input entity ID as a string.
 * @throws std::invalid_argument If the entity number is unable to be realized from the input entity ID.
 */
[[nodiscard]] std::string_view getEntityNumStr(std::string_view id);

/**
 * Get the checksum from an entity ID.
 *
 * @param id The ID of the entity from which to grab the checksum.
 * @return The checksum of the input entity ID. Returns an empty string if there is no checksum.
 */
[[nodiscard]] std::string_view getChecksum(std::string_view id);

/**
 * Generate the checksum of a Hiero address for a particular ledger.
 *
 * @param address  The Hiero address from which to generate a checksum.
 * @param ledgerId The ID for which the checksum should be generated.
 */
[[nodiscard]] std::string checksum(std::string_view address, const LedgerId& ledgerId);

/**
 * Decode a Solidity address contained in a string to a byte array.
 *
 * @param address The Solidity address to decode.
 * @return The bytes of the Solidity address.
 * @throws std::invalid_argument If a Solidity address cannot be realized from the input string.
 */
[[nodiscard]] std::vector<std::byte> decodeSolidityAddress(std::string_view address);

/**
 * Get the string representation of an entity, optionally with a checksum.
 *
 * @param shard    The shard of the entity.
 * @param realm    The realm of the entity.
 * @param num      The number of the entity.
 * @param checksum The checksum of the entity.
 * @return The string representation of an entity.
 */
[[nodiscard]] std::string toString(uint64_t shard, uint64_t realm, uint64_t num, std::string_view checksum = "");

/**
 * Get the Solidity address of an entity.
 *
 * @param shard The shard of the entity.
 * @param realm The realm of the entity.
 * @param num   The number of the entity.
 * @return The Solidity address of the entity, in a string.
 * @throws std::invalid_argument If the shard number is too large (value must be able to fit in 4 bytes).
 */
[[nodiscard]] std::string toSolidityAddress(uint64_t shard, uint64_t realm, uint64_t num);

/**
 * Validate the checksum of an entity.
 *
 * @param shard            The shard of the entity.
 * @param realm            The realm of the entity.
 * @param num              The number of the entity.
 * @param client           The Client to use to validate the checksum.
 * @param expectedChecksum The checksum to validate.
 * @throws BadEntityException If the checksum of the entity doesn't match up with the expected checksum.
 */
void validate(uint64_t shard, uint64_t realm, uint64_t num, const Client& client, std::string_view expectedChecksum);

} // namespace Hiero::internal::EntityIdHelper

#endif // HIERO_SDK_CPP_IMPL_ENTITY_ID_HELPER_H_
// Filename: src/sdk/main/include/impl/HexConverter.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_HEX_CONVERTER_H_
#define HIERO_SDK_CPP_IMPL_HEX_CONVERTER_H_

#include <string>
#include <string_view>
#include <vector>

namespace Hiero::internal::HexConverter
{
/**
 * Convert an array of bytes to a hex string.
 *
 * @param bytes The bytes from which to get the hex string.
 * @return A string containing the hex values of the input byte array.
 * @throws OpenSSLException If OpenSSL is unable to convert the input bytes to hex.
 */
std::string bytesToHex(const std::vector<std::byte>& bytes);

/**
 * Convert a hex string to the array of bytes it represents.
 *
 * @param hex The hex string to convert to a byte array.
 * @return The byte array containing the values of the input hex string.
 * @throws OpenSSLException If OpenSSL is unable to convert the input string to a byte array.
 */
std::vector<std::byte> hexToBytes(std::string_view hex);

/**
 * Convert a Base64-encoded string to a hexadecimal string.
 *
 * This function takes a Base64-encoded string as input and returns a hexadecimal
 * string.
 *
 * @param base64 The Base64-encoded string to convert.
 * @return The hexadecimal representation of the input.
 */
std::string base64ToHex(std::string_view base64);

} // namespace Hiero::internal::HexConverter

#endif // HIERO_SDK_CPP_IMPL_HEX_CONVERTER_H_
// Filename: src/sdk/main/include/impl/HieroCertificateVerifier.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_HIERO_CERTIFICATE_VERIFIER_H_
#define HIERO_SDK_CPP_IMPL_HIERO_CERTIFICATE_VERIFIER_H_

#include <grpcpp/security/credentials.h>
#include <string>

namespace Hiero::internal
{
/**
 * Custom TLS verifier which checks if node TLS cert chain matches the expected hash
 */
class HieroCertificateVerifier : public grpc::experimental::ExternalCertificateVerifier
{
public:
  /**
   * Construct with a node certificate chain hash.
   *
   * @param certificateHash The claimed hash of the node certificate chain.
   */
  explicit HieroCertificateVerifier(std::vector<std::byte> certificateHash);

private:
  /**
   * The hash of the certificate chain for the node, from the address book.
   */
  std::vector<std::byte> mExpectedHash;

  /**
   * The verification logic that will be performed after the TLS handshake completes.
   *
   * @param request     The verification information associated with this request.
   * @param callback    Callback for asynchronous requests. This is unused since the SDK does all requests
   *                    synchronously.
   * @param sync_status Pointer to the gRPC status that should be updated to indicate the success or the failure of the
   *                    check.
   * @return \c TRUE because all checks are done synchronously.
   */
  bool Verify(grpc::experimental::TlsCustomVerificationCheckRequest* request,
              std::function<void(grpc::Status)> callback,
              grpc::Status* sync_status) override;

  /**
   * Cancels a verification request previously started via Verify(). Used when the connection attempt times out or is
   * cancelled while an async verification request is pending. The impl should abort whatever async operation it is
   * waiting for and quickly invoke the callback that was passed to Verify() with a status indicating the cancellation.
   *
   * @param request A pointer to the verification information associated with this request.
   */
  [[maybe_unused]] void Cancel(grpc::experimental::TlsCustomVerificationCheckRequest* request) override
  { // Intentionally unimplemented
  }
};

} // namespace Hiero::internal

#endif // HIERO_SDK_CPP_IMPL_HIERO_CERTIFICATE_VERIFIER_H_
// Filename: src/sdk/main/include/impl/HttpClient.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_HTTP_CLIENT_H_
#define HIERO_SDK_CPP_IMPL_HTTP_CLIENT_H_

#ifndef CPPHTTPLIB_OPENSSL_SUPPORT
#define CPPHTTPLIB_OPENSSL_SUPPORT
#endif

#include <httplib.h>
#include <string>
#include <string_view>

namespace Hiero::internal::HttpClient
{
/**
 * Fetches data from the specified URL using the provided RPC method.
 * @param url       The URL to fetch data from.
 * @param rpcMethod The RPC method.
 * @return The response data as a string.
 */
[[nodiscard]] std::string invokeRPC(std::string_view url, std::string_view rpcMethod);

/**
 * Create a GET or POST request. Can be further extended for supporting other HTTP methods or handle more advanced
 * scenarios as needed.
 * @param url         The URL to which to submit the request.
 * @param httpMethod  The HTTP method.
 * @param requestBody The HTTP request body.
 * @return The response data as a string.
 */
[[nodiscard]] std::string invokeREST(std::string_view url,
                                     std::string_view httpMethod = "GET",
                                     std::string_view requestBody = "");

} // namespace Hiero::internal

#endif // HIERO_SDK_CPP_IMPL_HTTP_CLIENT_H_// Filename: src/sdk/main/include/impl/MirrorNetwork.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_MIRROR_NETWORK_H_
#define HIERO_SDK_CPP_IMPL_MIRROR_NETWORK_H_

#include "BaseNetwork.h"
#include "BaseNodeAddress.h"

#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

namespace Hiero::internal
{
class MirrorNode;
}

namespace Hiero::internal
{
class MirrorNetwork : public BaseNetwork<MirrorNetwork, BaseNodeAddress, MirrorNode>
{
public:
  /**
   * Construct a MirrorNetwork that is pre-configured for Hiero Mainnet access.
   *
   * @return A MirrorNetwork object that is set-up to communicate with the Hiero Mainnet.
   */
  [[nodiscard]] static MirrorNetwork forMainnet();

  /**
   * Construct a MirrorNetwork that is pre-configured for Hiero Testnet access.
   *
   * @return A MirrorNetwork object that is set-up to communicate with the Hiero Testnet.
   */
  [[nodiscard]] static MirrorNetwork forTestnet();

  /**
   * Construct a MirrorNetwork that is pre-configured for Hiero Previewnet access.
   *
   * @return A MirrorNetwork object that is set-up to communicate with the Hiero Previewnet.
   */
  [[nodiscard]] static MirrorNetwork forPreviewnet();

  /**
   * Construct a MirrorNetwork that is pre-configured for a custom network.
   *
   * @param nodeList The list of MirrorNode addresses for the custom network.
   * @return A MirrorNetwork object that is set-up to communicate with a specific node addresses.
   */
  [[nodiscard]] static MirrorNetwork forNetwork(const std::vector<std::string>& networkMap);

  /**
   * Set the MirrorNodes in the MirrorNetwork. This will put the input addresses into a map of addresses to
   * BaseNodeAddresses, and then feed it to BaseNetwork::setNetwork.
   *
   * @param network The network to set for this MirrorNetwork.
   * @return A reference to this MirrorNetwork object with the newly-set network.
   */
  MirrorNetwork& setNetwork(const std::vector<std::string>& network);

  /**
   * Get the addresses of the MirrorNodes in this MirrorNetwork.
   *
   * @return The addresses of the MirrorNodes in this MirrorNetwork.
   */
  [[nodiscard]] std::vector<std::string> getNetwork() const;

  /**
   * Get a pointer to the next MirrorNode.
   *
   * @return A pointer to the next MirrorNode.
   */
  [[nodiscard]] std::shared_ptr<MirrorNode> getNextMirrorNode() const;

private:
  /**
   * Derived from BaseNetwork. Create a MirrorNode for this MirrorNetwork based on a network entry.
   *
   * @param address The address of the MirrorNode.
   * @param key     The key for the MirrorNode. This is unused.
   * @return A pointer to the created MirrorNode.
   */
  [[nodiscard]] std::shared_ptr<MirrorNode> createNodeFromNetworkEntry(std::string_view address,
                                                                       const BaseNodeAddress& /*key*/) const override;
};

} // namespace Hiero::internal

#endif // HIERO_SDK_CPP_IMPL_MIRROR_NETWORK_H_
// Filename: src/sdk/main/include/impl/MirrorNode.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_MIRROR_NODE_H_
#define HIERO_SDK_CPP_IMPL_MIRROR_NODE_H_

#include <mirror/consensus_service.grpc.pb.h>
#include <mirror/mirror_network_service.grpc.pb.h>

#include "BaseNode.h"

#include <memory>
#include <string_view>

namespace Hiero::internal
{
class BaseNodeAddress;
}

namespace Hiero::internal
{
/**
 * Internal utility class used to represent a mirror node on a Hiero network.
 */
class MirrorNode : public BaseNode<MirrorNode, BaseNodeAddress>
{
public:
  /**
   * Construct with the address of the MirrorNode.
   *
   * @param address The address of the MirrorNode.
   */
  explicit MirrorNode(const BaseNodeAddress& address);

  /**
   * Construct with the address of the MirrorNode as a string.
   *
   * @param address The address of the MirrorNode as a string.
   */
  explicit MirrorNode(std::string_view address);

  /**
   * Derived from BaseNode. Get this MirrorNode's key, which is its BaseNodeAddress.
   *
   * @return This MirrorNode's key, which is its BaseNodeAddress.
   */
  [[nodiscard]] inline BaseNodeAddress getKey() const override { return getAddress(); }

  /**
   * Get a pointer to the ConsensusService stub used by this MirrorNode.
   *
   * @return A pointer ot the ConsensusService stub used by this MirrorNode.
   */
  [[nodiscard]] std::shared_ptr<com::hedera::mirror::api::proto::ConsensusService::Stub> getConsensusServiceStub() const
  {
    return mConsensusStub;
  }

  /**
   * Get a pointer to the NetworkService stub used by this MirrorNode.
   *
   * @return A pointer ot the NetworkService stub used by this MirrorNode.
   */
  [[nodiscard]] std::shared_ptr<com::hedera::mirror::api::proto::NetworkService::Stub> getNetworkServiceStub() const
  {
    return mNetworkStub;
  }

private:
  /**
   * Derived from BaseNode. Get the authority of this MirrorNode.
   *
   * @return There is no MirrorNode authority, so returns an empty string;
   */
  [[nodiscard]] inline std::string getAuthority() const override { return {}; }

  /**
   * Derived from BaseNode. Initialize the stubs in this MirrorNode with this MirrorNode's gRPC channel.
   */
  void initializeStubs() override;

  /**
   * Derived from BaseNode. Close the stubs in this MirrorNode.
   */
  void closeStubs() override;

  /**
   * Pointer to the gRPC stub used to communicate with the consensus service living on the remote mirror node.
   */
  std::shared_ptr<com::hedera::mirror::api::proto::ConsensusService::Stub> mConsensusStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the network service living on the remote mirror node.
   */
  std::shared_ptr<com::hedera::mirror::api::proto::NetworkService::Stub> mNetworkStub = nullptr;
};

} // namespace Hiero::internal

#endif // HIERO_SDK_CPP_IMPL_MIRROR_NODE_H_
// Filename: src/sdk/main/include/impl/MirrorNodeContractCallQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_MIRROR_NODE_CONTRACT_CALL_QUERY_H_
#define HIERO_SDK_CPP_MIRROR_NODE_CONTRACT_CALL_QUERY_H_

#include "impl/MirrorNodeContractQuery.h"

namespace Hiero
{
class MirrorNodeContractCallQuery : public MirrorNodeContractQuery
{
public:
  /**
   * Executes the Mirror Node query.
   *
   * @param client The Client object used for network access.
   * @return The result of the execution in string format.
   */
  [[nodiscard]] std::string execute(const Client& client) override;
};
} // namespace Hiero

#endif // HIERO_SDK_CPP_MIRROR_NODE_CONTRACT_CALL_QUERY_H_// Filename: src/sdk/main/include/impl/MirrorNodeContractEstimateGasQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_MIRROR_NODE_CONTRACT_ESTIMATE_GAS_QUERY_H_
#define HIERO_SDK_CPP_MIRROR_NODE_CONTRACT_ESTIMATE_GAS_QUERY_H_

#include "impl/MirrorNodeContractQuery.h"

namespace Hiero
{
class MirrorNodeContractEstimateGasQuery : public MirrorNodeContractQuery
{
public:
  /**
   * Executes the Mirror Node query.
   *
   * @param client The Client object used for network access.
   * @return The result of the execution in string format.
   */
  [[nodiscard]] std::string execute(const Client& client) override;
};
} // namespace Hiero

#endif // HIERO_SDK_CPP_MIRROR_NODE_CONTRACT_ESTIMATE_GAS_QUERY_H_// Filename: src/sdk/main/include/impl/MirrorNodeContractQuery.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_MIRROR_NODE_CONTRACT_QUERY_H_
#define HIERO_SDK_CPP_MIRROR_NODE_CONTRACT_QUERY_H_

#include "AccountId.h"
#include "Client.h"
#include "ContractFunctionParameters.h"
#include "ContractId.h"
#include "impl/HexConverter.h"

#include <cstdint>
#include <optional>
#include <string>
#include <vector>

#include <nlohmann/json.hpp>

using json = nlohmann::json;

namespace Hiero
{
/**
 * MirrorNodeContractQuery returns a result from EVM execution such as cost-free execution of read-only smart
 * contract queries, gas estimation, and transient simulation of read-write operations.
 */
class MirrorNodeContractQuery
{
public:
  /**
   * Gets the contract ID of the contract for the Mirror Node call.
   *
   * @return The contract ID as an optional string.
   */
  std::optional<ContractId> getContractId() const { return mContractId; }

  /**
   * Sets the contract ID of the contract for the Mirror Node call.
   *
   * @param id The contract ID.
   * @return Reference to the updated object.
   */
  MirrorNodeContractQuery& setContractId(const ContractId& id);

  /**
   * Gets the EVM address of the contract for the Mirror Node call.
   *
   * @return The contract EVM address as an optional string.
   */
  std::optional<std::string> getContractEvmAddress() const { return mContractEvmAddress; }

  /**
   * Sets the EVM address of the contract for the Mirror Node call.
   *
   * @param address The contract EVM address.
   * @return Reference to the updated object.
   */
  MirrorNodeContractQuery& setContractEvmAddress(const std::string& address);

  /**
   * Gets the sender account ID for the Mirror Node call.
   *
   * @return The sender account ID as an optional string.
   */
  std::optional<AccountId> getSender() const { return mSender; }

  /**
   * Sets the sender account ID for the Mirror Node call.
   *
   * @param id The sender account ID.
   * @return Reference to the updated object.
   */
  MirrorNodeContractQuery& setSender(const AccountId& id);

  /**
   * Gets the sender's EVM address for the Mirror Node call.
   *
   * @return The sender's EVM address as an optional string.
   */
  std::optional<std::string> getSenderEvmAddress() const { return mSenderEvmAddress; }

  /**
   * Sets the sender's EVM address for the Mirror Node call.
   *
   * @param address The sender's EVM address.
   * @return Reference to the updated object.
   */
  MirrorNodeContractQuery& setSenderEvmAddress(const std::string& address);

  /**
   * Gets the call data for the Mirror Node call.
   *
   * @return The call data as a vector of bytes.
   */
  std::vector<std::byte> getCallData() const { return mCallData; }

  /**
   * Sets the call data for the Mirror Node call.
   *
   * @param data The call data as a vector of bytes.
   * @return Reference to the updated object.
   */
  MirrorNodeContractQuery& setFunction(const std::string& functionName,
                                       std::optional<ContractFunctionParameters>& parameters);

  /**
   * Gets the value sent to the contract in the Mirror Node call.
   *
   * @return The value as a 64-bit integer.
   */
  int64_t getValue() const { return mValue; }

  /**
   * Sets the value sent to the contract in the Mirror Node call.
   *
   * @param val The value as a 64-bit integer.
   * @return Reference to the updated object.
   */
  MirrorNodeContractQuery& setValue(int64_t val);

  /**
   * Gets the gas limit for the Mirror Node call.
   *
   * @return The gas limit as a 64-bit integer.
   */
  int64_t getGasLimit() const { return mGasLimit; }

  /**
   * Sets the gas limit for the Mirror Node call.
   *
   * @param limit The gas limit as a 64-bit integer.
   * @return Reference to the updated object.
   */
  MirrorNodeContractQuery& setGasLimit(int64_t limit);

  /**
   * Gets the gas price for the Mirror Node call.
   *
   * @return The gas price as a 64-bit integer.
   */
  int64_t getGasPrice() const { return mGasPrice; }

  /**
   * Sets the gas price for the Mirror Node call.
   *
   * @param price The gas price as a 64-bit integer.
   * @return Reference to the updated object.
   */
  MirrorNodeContractQuery& setGasPrice(int64_t price);

  /**
   * Gets the block number used for the Mirror Node call.
   *
   * @return The block number as a 64-bit unsigned integer.
   */
  uint64_t getBlockNumber() const { return mBlockNumber; }

  /**
   * Sets the block number used for the Mirror Node call.
   *
   * @param number The block number as a 64-bit unsigned integer.
   * @return Reference to the updated object.
   */
  MirrorNodeContractQuery& setBlockNumber(uint64_t number);

  /**
   * Gets the value of estimate.
   *
   * @return A boolean indicating whether the contract call should be estimated.
   */
  bool getEstimate() const { return mEstimate; }

  /**
   * Sets the value if the call should be estimated.
   *
   * @param estimate A boolean indicating whether the contract call should be estimated.
   */
  MirrorNodeContractQuery& setEstimate(bool estimate);

  /**
   * Serializes the query object to a JSON representation.
   *
   * @return A JSON object representing the state of the object.
   */
  json toJson() const;

  /**
   * Executes the Mirror Node query.
   *
   * @param client The Client object used for network access.
   * @return The result of the execution in string format.
   */
  [[nodiscard]] virtual std::string execute(const Client& client) = 0;

protected:
  /**
   * Populates the EVM addresses using the Mirror Node.
   *
   * @param client The Client object used for network access.
   * @return A reference to the modified AccountId object.
   * @throws IllegalStateException if mAccountNum is empty or if the account does not exist in the Mirror Network.
   */
  void populateContractEvmAddress(const Client& client);

  /**
   * The contract ID  of the contract for the Mirror Node call.
   */
  std::optional<ContractId> mContractId;

  /**
   * The EVM address of the contract for the Mirror Node call.
   */
  std::optional<std::string> mContractEvmAddress;

  /**
   * The sender account ID for the Mirror Node call.
   */
  std::optional<AccountId> mSender;

  /**
   * The sender's EVM address for the Mirror Node call.
   */
  std::optional<std::string> mSenderEvmAddress;

  /**
   * The call data for the Mirror Node call.
   */
  std::vector<std::byte> mCallData;

  /**
   * The value sent to the contract for the Mirror Node call.
   */
  int64_t mValue = 0;

  /**
   * The gas limit sent to the contract for the Mirror Node call.
   */
  int64_t mGasLimit = 0;

  /**
   * The gas price sent to the contract for the Mirror Node call.
   */
  int64_t mGasPrice = 0;

  /**
   * The block number sent to the contract for the Mirror Node call.
   */
  uint64_t mBlockNumber = 0;

  /**
   * Should contract call be estimated
   */
  bool mEstimate = false;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_MIRROR_NODE_CONTRACT_QUERY_H_
// Filename: src/sdk/main/include/impl/MirrorNodeGateway.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_MIRRORNODEGATEWAY_H
#define HIERO_SDK_CPP_MIRRORNODEGATEWAY_H

#include "impl/HttpClient.h"
#include "impl/MirrorNodeRouter.h"

#include <string_view>

#include <nlohmann/json.hpp>

namespace Hiero::internal::MirrorNodeGateway
{
/**
 * Perform a mirror node query.
 *
 * This function constructs a URL based on the provided mirror node URL, query type,
 * and parameters. It then sends a REST request to the constructed URL using an
 * HttpClient, retrieves the response, and parses it into a JSON object.
 *
 * @param mirrorNodeUrl The mirror node URL.
 * @param params A vector of strings representing parameters for the query.
 * @param queryType The type of the query.
 * @param requestBody Body for the request if one is set.
 * @param requestType Type of the request if one is set.
 * @return A JSON object representing the response of the mirror node query.
 * @throws IllegalStateException If an error occurs during the mirror node query or JSON parsing.
 */
nlohmann::json MirrorNodeQuery(std::string_view mirrorNodeUrl,
                               const std::vector<std::string>& params,
                               std::string_view queryType,
                               std::string_view requestBody = "",
                               std::string_view requestType = "GET");

/**
 * Replaces all occurrences of a substring in a string.
 *
 * This function replaces all occurrences of the substring specified by 'search'
 * with the string specified by 'replace' in the original string.
 *
 * @param original The original string to be modified.
 * @param search The substring to search for.
 * @param replace The string to replace the occurrences of 'search'.
 */
void replaceParameters(std::string& original, std::string_view search, std::string_view replace);

/**
 * Builds a URL based on a mirror node URL, query type, and parameters.
 *
 * This function constructs a URL by combining a mirror node URL, a query type,
 * and a list of parameters. It replaces occurrences of "$" in the route with
 * the provided parameters.
 *
 * @param mirrorNodeUrl The mirror node URL.
 * @param queryType The type of the query.
 * @param params A vector of strings representing parameters.
 * @return The constructed URL.
 */
std::string buildUrlForNetwork(std::string_view mirrorNodeUrl,
                               std::string_view queryType,
                               const std::vector<std::string>& params,
                               std::string_view requestType);
} // namespace Hiero::internal::MirrorNodeGateway
#endif // HIERO_SDK_CPP_MIRRORNODEGATEWAY_H// Filename: src/sdk/main/include/impl/MirrorNodeRouter.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_MIRRORNODEROUTER_H
#define HIERO_SDK_CPP_MIRRORNODEROUTER_H

#include <string>
#include <string_view>
#include <unordered_map>

/**
 * Namespace for the internal classes related to the Mirror Node Gateway.
 */
namespace Hiero::internal::MirrorNodeGateway
{
/**
 * Represents different mirror node query types.
 */
static const std::string& ACCOUNT_INFO_QUERY = "accountInfoQuery";
static const std::string& CONTRACT_INFO_QUERY = "contractInfoQuery";
static const std::string& TOKEN_RELATIONSHIPS_QUERY = "tokenRelationshipsQuery";
static const std::string& TOKEN_BALANCES_QUERY = "tokenBalancesQuery";

/**
 * Class responsible for routing requests to different mirror node routes.
 */
class MirrorNodeRouter
{
public:
  /**
   * Retrieves the route for a specific mirror node query type.
   *
   * @param queryType The type of the mirror node query (e.g., "accountInfoQuery").
   * @return A string view representing the route for the specified mirror node query.
   */
  [[nodiscard]] std::string getRoute(std::string_view queryType) const;

private:
  /**
   * Internal mapping of mirror node query types to their respective routes.
   */
  const std::unordered_map<std::string, std::string> routes = {
    {ACCOUNT_INFO_QUERY,         "/api/v1/accounts/$"       },
    { CONTRACT_INFO_QUERY,       "/api/v1/contracts/$"      },
    { TOKEN_RELATIONSHIPS_QUERY, "/api/v1/accounts/$/tokens"},
    { TOKEN_BALANCES_QUERY,      "/api/v1/tokens/$/balances"}
  };
};

} // namespace Hiero::internal::MirrorNodeGateway

#endif // HIERO_SDK_CPP_MIRRORNODEROUTER_H
// Filename: src/sdk/main/include/impl/Network.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_NETWORK_H_
#define HIERO_SDK_CPP_IMPL_NETWORK_H_

#include "BaseNetwork.h"

#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

namespace Hiero
{
namespace internal
{
class Node;
enum class TLSBehavior;
}

class AccountId;
class LedgerId;
class NodeAddress;
class NodeAddressBook;
}

namespace Hiero::internal
{
class Network : public BaseNetwork<Network, AccountId, Node>
{
public:
  /**
   * Construct a Network that is pre-configured for Hiero Mainnet access.
   *
   * @return A Network object that is set-up to communicate with the Hiero Mainnet.
   */
  [[nodiscard]] static Network forMainnet();

  /**
   * Construct a Network that is pre-configured for Hiero Testnet access.
   *
   * @return A Network object that is set-up to communicate with the Hiero Testnet.
   */
  [[nodiscard]] static Network forTestnet();

  /**
   * Construct a Network that is pre-configured for Hiero Previewnet access.
   *
   * @return A Network object that is set-up to communicate with the Hiero Previewnet.
   */
  [[nodiscard]] static Network forPreviewnet();

  /**
   * Construct a custom Network from a map of node addresses to their corresponding AccountId.
   *
   * @param network The map with string representation of node addresses with their corresponding AccountIds.
   * @return A Network object that is set-up to communicate with the custom network.
   */
  [[nodiscard]] static Network forNetwork(const std::unordered_map<std::string, AccountId>& network);

  /**
   * Construct a network map from a NodeAddressBook with a specific port for the endpoints.
   *
   * @param addressBook The NodeAddressBook from which to construct the network map.
   * @param port        The desired port.
   * @return A network map that contains the nodes in the input NodeAddressBook.
   */
  [[nodiscard]] static std::unordered_map<std::string, AccountId> getNetworkFromAddressBook(
    const NodeAddressBook& addressBook,
    unsigned int port);

  /**
   * Derived from BaseNetwork. Set the ledger ID of this Network.
   *
   * @param ledgerId The ledger ID to set.
   * @return A reference to this Network object with the newly-set ledger ID.
   */
  Network& setLedgerId(const LedgerId& ledgerId) override;

  /**
   * Set this Network's certificate verification policy.
   *
   * @param verify \c TRUE if this Network should verify remote node certificates, otherwise \c FALSE.
   * @return A reference to this Network object with the newly-set certificate verification policy.
   */
  Network& setVerifyCertificates(bool verify);

  /**
   * Set this Network's transport security policy.
   *
   * @param tls The transport security policy to set.
   * @return A reference to this Network object with the newly-set transport security policy.
   * @throws UninitializedException If TLS is required and a Node on this Network wasn't initialized with a certificate
   *                                hash.
   */
  Network& setTransportSecurity(TLSBehavior tls);

  /**
   * Set the maximum number of nodes to be returned for each request.
   *
   * @param max The maximum number of nodes to be returned for each request.
   * @return A reference to this Network object with the newly-set maximum nodes per request.
   */
  Network& setMaxNodesPerRequest(unsigned int max);

  /**
   * Are certificates being verified?
   *
   * @return A boolean value indicating if the certificates are being verified.
   */
  [[nodiscard]] bool isVerifyCertificates() const { return mVerifyCertificates; }

  /**
   * Get a list of node account IDs on which to execute. This will pick 1/3 of the available nodes sorted by health and
   * expected delay from the network.
   *
   * @return A list of AccountIds that are running nodes on which should be executed.
   */
  [[nodiscard]] unsigned int getNumberOfNodesForRequest() const;

  /**
   * Get a list of node account IDs on which to execute. This will pick 1/3 of the available nodes sorted by health and
   * expected delay from the network.
   *
   * @return A list of AccountIds that are running nodes on which should be executed.
   */
  [[nodiscard]] std::vector<AccountId> getNodeAccountIdsForExecute();

  /**
   * Get a map of this Network, mapping the Node addresses to their AccountIds.
   *
   * @return A map of this Network, mapping the Node addresses to their AccountIds.
   */
  [[nodiscard]] std::unordered_map<std::string, AccountId> getNetwork() const;

private:
  /**
   * Construct with a network map.
   *
   * @param network A map of node addresses to the AccountIds that run those nodes.
   */
  explicit Network(const std::unordered_map<std::string, AccountId>& network);

  /**
   * Construct a Network object configured to communicate with the network represented by the input LedgerId.
   *
   * @param ledgerId The LedgerId of the Network object to construct.
   * @return The constructed Network object.
   */
  [[nodiscard]] static Network getNetworkForLedgerId(const LedgerId& ledgerId);

  /**
   * Get a map of AccountIds to NodeAddresses from a local file for a network based on the input LedgerId.
   *
   * @param ledgerId The LedgerId of the network of which to get the address book.
   * @return The map of node addresses and AccountIds of the Nodes that exist on the network represented by the input
   *         LedgerId.
   */
  [[nodiscard]] static NodeAddressBook getAddressBookForLedgerId(const LedgerId& ledgerId);

  /**
   * Derived from BaseNetwork. Create a Node for this Network based on a network entry.
   *
   * @param address The address of the Node.
   * @param key     The key for the Node.
   * @return A pointer to the created Node.
   */
  [[nodiscard]] std::shared_ptr<Node> createNodeFromNetworkEntry(std::string_view address,
                                                                 const AccountId& key) const override;

  /**
   * Set the ledger ID of this Network. In addition, update the Nodes on this Network with their address book entry
   * contained in the input map.
   *
   * @param ledgerId    The new LedgerId of the Network.
   * @param addressBook The NodeAddressBook with which to update this Network's Node's address book entry.
   */
  Network& setLedgerIdInternal(const LedgerId& ledgerId, const NodeAddressBook& addressBook);

  /**
   * The maximum number of nodes to be returned for each request.
   */
  unsigned int mMaxNodesPerRequest = 0U;

  /**
   * Should the Nodes on this Network verify remote node certificates?
   */
  bool mVerifyCertificates = true;
};

} // namespace Hiero::internal

#endif // HIERO_SDK_CPP_IMPL_NETWORK_H_
// Filename: src/sdk/main/include/impl/Node.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_NODE_H_
#define HIERO_SDK_CPP_IMPL_NODE_H_

#include <address_book_service.grpc.pb.h>
#include <consensus_service.grpc.pb.h>
#include <crypto_service.grpc.pb.h>
#include <file_service.grpc.pb.h>
#include <freeze_service.grpc.pb.h>
#include <network_service.grpc.pb.h>
#include <schedule_service.grpc.pb.h>
#include <smart_contract_service.grpc.pb.h>
#include <token_service.grpc.pb.h>
#include <util_service.grpc.pb.h>

#include "AccountId.h"
#include "BaseNode.h"

#include <cstddef>
#include <memory>
#include <string_view>
#include <vector>

namespace Hiero::internal
{
class BaseNodeAddress;
}

namespace Hiero::internal
{
/**
 * Internal utility class used to represent a node on a Hiero network.
 */
class Node : public BaseNode<Node, AccountId>
{
public:
  /**
   * Construct with the AccountId that's running this Node and the address of the Node.
   *
   * @param accountId The AccountId that runs the remote node represented by this Node.
   * @param address   The address of the Node.
   */
  explicit Node(AccountId accountId, const BaseNodeAddress& address);

  /**
   * Construct with the AccountId that's running this Node and the address of the Node as a string.
   *
   * @param accountId The AccountId that runs the remote node represented by this Node.
   * @param address   The address of the Node as a string.
   */
  explicit Node(const AccountId& accountId, std::string_view address);

  /**
   * Submit a Query protobuf to the remote node with which this Node is communicating.
   *
   * @param funcEnum The enumeration specifying which gRPC function to call for this specific Query.
   * @param query    The Query protobuf object to send.
   * @param deadline The deadline for submitting this Query.
   * @param response Pointer to the Response protobuf object to fill with the gRPC server's response.
   * @return The gRPC status response of the function call from the gRPC server.
   */
  grpc::Status submitQuery(proto::Query::QueryCase funcEnum,
                           const proto::Query& query,
                           const std::chrono::system_clock::time_point& deadline,
                           proto::Response* response);

  /**
   * Submit a Transaction protobuf to the remote node with which this Node is communicating.
   *
   * @param funcEnum    The enumeration specifying which gRPC function to call for this specific Transaction.
   * @param transaction The Transaction protobuf object to send.
   * @param deadline    The deadline for submitting this Transaction.
   * @param response    Pointer to the TransactionResponse protobuf object to fill with the gRPC server's response.
   * @return The gRPC status response of the function call from the gRPC server.
   */
  grpc::Status submitTransaction(proto::TransactionBody::DataCase funcEnum,
                                 const proto::Transaction& transaction,
                                 const std::chrono::system_clock::time_point& deadline,
                                 proto::TransactionResponse* response);

  /**
   * Construct an insecure version of this Node. This will close the Node's current connection.
   *
   * @return A reference to this Node, now using an insecure connection.
   */
  Node& toInsecure();

  /**
   * Construct a secure version of this Node. This will close the Node's current connection.
   *
   * @return A reference to this Node, now using a secure connection.
   */
  Node& toSecure();

  /**
   * Set the node certificate hash of this Node.
   *
   * @param hash The node certificate hash to set.
   * @return A reference to this Node with the newly-set node certificate hash.
   */
  Node& setNodeCertificateHash(const std::vector<std::byte>& hash);

  /**
   * Set the certificate verification policy of this Node.
   *
   * @param verify \c TRUE if this Node should verify certificates, otherwise \c FALSE.
   * @return A reference to this Node with the newly-set certificate verification policy.
   */
  Node& setVerifyCertificates(bool verify);

  /**
   * Derived from BaseNode. Get this Node's key, which is its AccountId.
   *
   * @return This Node's key, which is its AccountId.
   */
  [[nodiscard]] inline AccountId getKey() const override { return getAccountId(); };

  /**
   * Get the AccountId of this Node.
   *
   * @return The AccountId of this Node.
   */
  [[nodiscard]] inline AccountId getAccountId() const
  {
    std::unique_lock lock(*getLock());
    return mAccountId;
  };

  /**
   * Get the node certificate hash of this Node.
   *
   * @return The node certificate hash of this Node.
   */
  [[nodiscard]] inline std::vector<std::byte> getNodeCertificateHash() const
  {
    std::unique_lock lock(*getLock());
    return mNodeCertificateHash;
  }

  /**
   * Get the certificate verification policy of this Node.
   *
   * @return \c TRUE if this Node is currently configured to verify certificates, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool getVerifyCertificates() const
  {
    std::unique_lock lock(*getLock());
    return mVerifyCertificates;
  }

private:
  /**
   * Construct from another Node and a BaseNodeAddress.
   *
   * @param node    The Node from which to construct.
   * @param address The address of the Node.
   */
  explicit Node(const Node& node, const BaseNodeAddress& address);

  /**
   * Derived from BaseNode. Get the TLS credentials of this Node's gRPC channel.
   *
   * @return A pointer to the TLS credentials for this Node's gRPC channel.
   */
  [[nodiscard]] std::shared_ptr<grpc::ChannelCredentials> getTlsChannelCredentials() const override;

  /**
   * Derived from BaseNode. Initialize the stubs in this Node with this Node's gRPC channel.
   */
  void initializeStubs() override;

  /**
   * Derived from BaseNode. Close the stubs in this Node.
   */
  void closeStubs() override;

  /**
   * Pointer to the gRPC stub used to communicate with the consensus service living on the remote node.
   */
  std::unique_ptr<proto::ConsensusService::Stub> mConsensusStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the cryptography service living on the remote node.
   */
  std::unique_ptr<proto::CryptoService::Stub> mCryptoStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the file service living on the remote node.
   */
  std::unique_ptr<proto::FileService::Stub> mFileStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the freeze service living on the remote node.
   */
  std::unique_ptr<proto::FreezeService::Stub> mFreezeStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the network service living on the remote node.
   */
  std::unique_ptr<proto::NetworkService::Stub> mNetworkStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the schedule service living on the remote node.
   */
  std::unique_ptr<proto::ScheduleService::Stub> mScheduleStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the smart contract service living on the remote node.
   */
  std::unique_ptr<proto::SmartContractService::Stub> mSmartContractStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the token service living on the remote node.
   */
  std::unique_ptr<proto::TokenService::Stub> mTokenStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the utility service living on the remote node.
   */
  std::unique_ptr<proto::UtilService::Stub> mUtilStub = nullptr;

  /**
   * Pointer to the gRPC stub used to communicate with the address book service living on the remote node.
   */
  std::unique_ptr<proto::AddressBookService::Stub> mAddressBookStub = nullptr;

  /**
   * The AccountId that runs the remote node represented by this Node.
   */
  AccountId mAccountId;

  /**
   * The node certificate hash of this Node.
   */
  std::vector<std::byte> mNodeCertificateHash;

  /**
   * Should this Node verify the certificates coming from the remote node?
   */
  bool mVerifyCertificates = false;
};

} // namespace Hiero::internal

#endif // HIERO_SDK_CPP_IMPL_NODE_H_
// Filename: src/sdk/main/include/impl/PrivateKeyImpl.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_PRIVATE_KEY_IMPL_H_
#define HIERO_SDK_CPP_IMPL_PRIVATE_KEY_IMPL_H_

#include "PrivateKey.h"
#include "impl/openssl_utils/EVP_PKEY.h"

#include <memory>
#include <vector>

namespace Hiero
{
/**
 * The implementation of the PrivateKey object.
 */
struct PrivateKey::PrivateKeyImpl
{
  /**
   * The wrapped OpenSSL key object.
   */
  internal::OpenSSLUtils::EVP_PKEY mKey;

  /**
   * The chain code. If this is empty, then this PrivateKey will not support derivation.
   */
  std::vector<std::byte> mChainCode;

  /**
   * A pointer to the PublicKey object that corresponds to this PrivateKey.
   */
  std::shared_ptr<PublicKey> mPublicKey = nullptr;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_IMPL_PRIVATE_KEY_IMPL_H_
// Filename: src/sdk/main/include/impl/PublicKeyImpl.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_PUBLIC_KEY_IMPL_H_
#define HIERO_SDK_CPP_IMPL_PUBLIC_KEY_IMPL_H_

#include "PublicKey.h"
#include "impl/openssl_utils/EVP_PKEY.h"

namespace Hiero
{
/**
 * The implementation of the PublicKey object.
 */
struct PublicKey::PublicKeyImpl
{
  /**
   * The wrapped OpenSSL key object.
   */
  internal::OpenSSLUtils::EVP_PKEY mKey;
};
} // namespace Hiero

#endif // HIERO_SDK_CPP_IMPL_PUBLIC_KEY_IMPL_H_
// Filename: src/sdk/main/include/impl/RLPItem.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_RLP_ITEM_H_
#define HIERO_SDK_CPP_IMPL_RLP_ITEM_H_

#include <cstddef>
#include <string_view>
#include <vector>

namespace Hiero
{
/**
 * Helper class used to hold RLP data and do RLP serialization for Ethereum data and transactions.
 */
class RLPItem
{
public:
  /**
   * Enumeration of possible RLP items. An RLPItem is defined as follows:
   *  - A value (i.e. a string or byte array) is an item
   *  - A list of items is an item
   */
  enum class RLPType
  {
    VALUE_TYPE,
    LIST_TYPE
  };

  RLPItem() = default;

  /**
   * Construct with a specified RLPType.
   *
   * @param type The type of RLPItem to set.
   */
  explicit RLPItem(RLPType type);

  /**
   * Construct with a specified RLPItem value.
   *
   * @param value The value of the RLPItem to set.
   */
  explicit RLPItem(std::vector<std::byte> value);
  explicit RLPItem(std::string_view value);

  /*
   * Get the raw byte-representation of a number.
   *
   * @param num The number of which to get the byte-representation.
   * @return The byte-representation of the input number.
   */
  static std::vector<std::byte> encodeBinary(size_t num);

  /*
   * Encode a number to its byte-representation, given an offset.
   *
   * @param num    The number to encode.
   * @param offset The offset of the length.
   * @return The byte-encoding of the number.
   */
  static std::vector<std::byte> encodeLength(size_t num, unsigned char offset);

  /**
   * Clear this RLPItem.
   */
  void clear();

  /**
   * Assign the value of this RLPItem.
   *
   * @param value The value to assign to this RLPItem.
   */
  void assign(const std::vector<std::byte>& value);
  void assign(std::string_view value);

  /**
   * Set the type of this RLPItem. This will clear values if a different type is set.
   *
   * @param type The RLPType to assign to this RLPItem.
   */
  void setType(RLPType type);

  /**
   * Determine if this RLPItem is a certain type.
   *
   * @param type The type to which to compare this RLPItem.
   * @return \c TRUE if this RLPItem is input type, otherwise \c FALSE.
   */
  [[nodiscard]] inline bool isType(RLPType type) const { return mType == type; }

  /**
   * Get the value of this RLPItem.
   *
   * @return The value of this RLPItem. Returns empty if this RLPItem is of RLPType::LIST_TYPE.
   */
  [[nodiscard]] inline std::vector<std::byte> getValue() const { return mValue; }

  /**
   * Get the RLPItem values of this RLPItem.
   *
   * @return The RLPItems of this RLPItem. Returns empty if this RLPItem is of RLPType::VALUE_TYPE.
   */
  [[nodiscard]] inline std::vector<RLPItem> getValues() const { return mValues; }

  /**
   * Add a value to this RLPItem's values.
   *
   * @param value The RLPItem to add to this RLPItem.
   */
  void pushBack(const RLPItem& value);
  void pushBack(const std::vector<std::byte>& value);
  void pushBack(std::string_view value);

  /**
   * Get the total size in bytes of this RLPItem. This will be either the size of mValue, or the size of all the
   * RLPItems in mValues added together, depending on the type of this RLPItem.
   *
   * @return The size of this RLPItem, in bytes.
   */
  [[nodiscard]] size_t size() const;

  /**
   * Encode this RLPItem to a byte array.
   *
   * @return This RLPItem RLP-encoded to a byte array.
   */
  [[nodiscard]] std::vector<std::byte> write() const;

  /**
   * Decode a byte array to to this RLPItem.
   *
   * @param bytes The byte array to decode.
   * @throws std::invalid_argument If the input byte array is malformed and cannot be decoded.
   */
  void read(const std::vector<std::byte>& bytes);

private:
  /**
   * Decode a byte array and put its values in this RLPItem. Helper function used by 'read()'.
   *
   * @param bytes The byte array to decode.
   * @param index The index to begin decoding.
   */
  void decodeBytes(const std::vector<std::byte>& bytes, long& index);

  /**
   * The type of RLPItem this RLPItem is.
   */
  RLPType mType = RLPType::VALUE_TYPE;

  /**
   * The value of this RLPItem.
   */
  std::vector<std::byte> mValue;

  /**
   * The list of values of this RLPItem.
   */
  std::vector<RLPItem> mValues;
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_IMPL_RLP_ITEM_H_
// Filename: src/sdk/main/include/impl/TLSBehavior.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_TLS_BEHAVIOR_H_
#define HIERO_SDK_CPP_IMPL_TLS_BEHAVIOR_H_

namespace Hiero::internal
{
/**
 * Enum representing different modes of network communication.
 */
enum class TLSBehavior
{
  /**
   * Communicate only in the clear
   */
  DISABLE,
  /**
   * Require TLS connection
   */
  REQUIRE
};

} // namespace Hiero::internal

#endif // HIERO_SDK_CPP_IMPL_TLS_BEHAVIOR_H_
// Filename: src/sdk/main/include/impl/TimestampConverter.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_TIMESTAMP_CONVERTER_H_
#define HIERO_SDK_CPP_IMPL_TIMESTAMP_CONVERTER_H_

#include <chrono>
#include <memory>
#include <string>

namespace proto
{
class Timestamp;
class TimestampSeconds;
}

namespace Hiero::internal::TimestampConverter
{
/**
 * Get the time point represented by a Timestamp protobuf object.
 *
 * @param timestamp The Timestamp protobuf from which to get the time point.
 * @return The time point represented by the input Timestamp protobuf.
 */
std::chrono::system_clock::time_point fromProtobuf(const proto::Timestamp& timestamp);

/**
 * Get the time point represented by a TimestampSeconds protobuf object.
 *
 * @param timestamp The TimestampSeconds protobuf from which to get the time point.
 * @return The time point represented by the input TimestampSeconds protobuf.
 */
std::chrono::system_clock::time_point fromProtobuf(const proto::TimestampSeconds& timestamp);

/**
 * Create a Timestamp protobuf object from a time point.
 *
 * @param duration The duration object from which to create a Timestamp protobuf object.
 * @return A pointer to the created Timestamp protobuf object.
 */
proto::Timestamp* toProtobuf(const std::chrono::system_clock::time_point& time);

/**
 * Create a TimestampSeconds protobuf object from a time point.
 *
 * @param duration The duration object from which to create a TimestampSeconds protobuf object.
 * @return A pointer to the created TimestampSeconds protobuf object.
 */
proto::TimestampSeconds* toSecondsProtobuf(const std::chrono::system_clock::time_point& time);

/**
 * Convert an epoch timestamp to a string representation of the form "<seconds>.<nanoseconds>".
 *
 * @param timestamp The timestamp of which to get the the string representation.
 * @return The string representation of the input timestamp.
 */
[[nodiscard]] std::string toString(const std::chrono::system_clock::time_point& timestamp);

} // namespace Hiero::internal::TimestampConverter

#endif // HIERO_SDK_CPP_IMPL_TIMESTAMP_CONVERTER_H_
// Filename: src/sdk/main/include/impl/Utilities.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_UTILITIES_H_
#define HIERO_SDK_CPP_IMPL_UTILITIES_H_

#include <array>
#include <cstddef>
#include <string>
#include <string_view>
#include <vector>

#include <nlohmann/json.hpp>

namespace Hiero::internal::Utilities
{
/**
 * Reinterpret a pointer to a pointer of a different type.
 *
 * @param input The pointer to reinterpret.
 * @param A pointer to the same input, reinterpreted as a different type.
 */
template<typename ReturnType, typename InputType>
[[nodiscard]] ReturnType* toTypePtr(InputType* input)
{
  return reinterpret_cast<ReturnType*>(input);
}

template<typename ReturnType, typename InputType>
[[nodiscard]] const ReturnType* toTypePtr(const InputType* input)
{
  return reinterpret_cast<const ReturnType*>(input);
}

/**
 * Swap the endianness of an integral value.
 *
 * @param value The value of which to convert the endianness.
 * @return The value with the converted endianness.
 */
template<typename T>
[[nodiscard]] T swapEndianness(T value)
{
  static_assert(std::is_integral_v<T>, "swapEndianness works only with integral types");

  constexpr size_t numBytes = sizeof(T);
  union EndiannessUnion
  {
    T val;
    std::array<std::byte, numBytes> bytes;
  };

  EndiannessUnion src;
  EndiannessUnion dst;

  src.val = value;

  for (size_t i = 0; i < numBytes; ++i)
  {
    dst.bytes[i] = src.bytes[numBytes - i - 1];
  }

  return dst.val;
}

/**
 * Get the bytes (in big endian) that represent an integral type.
 *
 * @tparam T  The type of integer of which to get the bytes.
 * @param val The value of which to get the bytes.
 * @return An array of bytes that represents the input value.
 */
template<typename T>
[[nodiscard]] std::vector<std::byte> getBytes(const T& val)
{
  // Only allow integral types
  static_assert(std::is_integral_v<T>, "getBytes works only with integral types");

  std::vector<std::byte> bytes(sizeof(T));
  auto byte = internal::Utilities::toTypePtr<std::byte>(&val);
  for (size_t i = 0; i < sizeof(T); ++i)
  {
    bytes[sizeof(T) - i - 1] = *byte++;
  }

  return bytes;
}

/**
 * Determine if a byte array is the prefix of another.
 *
 * @param bytes  The bytes in which to look for the prefix.
 * @param prefix The prefix bytes to find in the byte array.
 * @return \c TRUE If prefix is a prefix of bytes, otherwise \c FALSE.
 */
[[nodiscard]] bool isPrefixOf(const std::vector<std::byte>& bytes, const std::vector<std::byte>& prefix);

/**
 * Remove a certain number of bytes from the beginning of a byte vector.
 *
 * @param bytes The bytes from which to remove the prefix.
 * @param num   The number of bytes to remove.
 * @return The byte vector with the removed prefix bytes.
 */
[[nodiscard]] std::vector<std::byte> removePrefix(const std::vector<std::byte>& bytes, long num);

/**
 * Concatenate byte vectors together (in the order of the arguments).
 *
 * @param vectors The byte vectors to concatenate together.
 * @return A byte vector containing the input byte vectors concatenated into one.
 */
[[nodiscard]] std::vector<std::byte> concatenateVectors(const std::vector<std::vector<std::byte>>& vectors);

/**
 * Convert a string to a byte vector.
 *
 * @param str The string to convert.
 * @return The byte vector representing the input string.
 */
[[nodiscard]] std::vector<std::byte> stringToByteVector(std::string_view str);

/**
 * Convert a string to a byte.
 *
 * @param str The string to convert.
 * @return The byte representing the string.
 */
[[nodiscard]] std::byte stringToByte(std::string_view str);

/**
 * Convert a byte vector to a string.
 *
 * @param bytes The byte vector to convert to a string.
 * @return The string that represent of the byte vector.
 */
[[nodiscard]] std::string byteVectorToString(const std::vector<std::byte>& bytes);

/**
 * Get a random number between the two input inclusive bounds.
 *
 * @param lowerBound The lower bound of the random number.
 * @param upperBound The upper bound of the random number.
 * @return A random number between the two bounds.
 * @throws std::invalid_argument If lowerBound is greater than or equal to upperBound.
 */
[[nodiscard]] unsigned int getRandomNumber(unsigned int lowerBound, unsigned int upperBound);

/**
 * Reads and parses a JSON file.
 *
 * This function reads the contents of a JSON file located at the specified path,
 * parses it, and returns a JSON object.
 *
 * @param path The path to the JSON file.
 * @return A JSON object representing the contents of the file.
 * @throws std::invalid_argument if the file cannot be found or if the contents
 *         are not valid JSON.
 */
[[nodiscard]] nlohmann::json fromConfigFile(std::string_view path);

} // namespace Hiero::internal::Utilities

#endif // HIERO_SDK_CPP_IMPL_UTILITIES_H_
// Filename: src/sdk/main/include/impl/openssl_utils/BIGNUM.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_BIGNUM_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_BIGNUM_H_

#include "exceptions/OpenSSLException.h"
#include "impl/HexConverter.h"
#include "impl/openssl_utils/BN_CTX.h"
#include "impl/openssl_utils/OpenSSLObjectWrapper.h"
#include "impl/openssl_utils/OpenSSLUtils.h"

#include <openssl/bn.h>
#include <string_view>
#include <vector>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL BIGNUM object.
 */
class BIGNUM : public OpenSSLObjectWrapper<::BIGNUM>
{
public:
  /**
   * Construct with the input BIGNUM, its BN_clear_free deleter, and its BN_dup copier.
   *
   * @param bignum The BIGNUM OpenSSL object to wrap.
   */
  explicit BIGNUM(::BIGNUM* bignum)
    : OpenSSLObjectWrapper(bignum, &BN_clear_free, &BN_dup)
  {
  }

  /**
   * Create a new BIGNUM from a hex string.
   *
   * @param hexString A string representing the BIGNUM.
   * @return A newly constructed BIGNUM.
   */
  [[nodiscard]] static BIGNUM fromHex(std::string_view hexString)
  {
    ::BIGNUM* bigNum = nullptr;
    if (BN_hex2bn(&bigNum, hexString.data()) <= 0)
    {
      throw OpenSSLException(getErrorMessage("BN_hex2bn"));
    }

    return BIGNUM(bigNum);
  }

  /**
   * Create a new BIGNUM from a bytes vector.
   *
   * @param bytes The vector of bytes representing the BIGNUM.
   * @return A newly constructed BIGNUM.
   */
  [[nodiscard]] static BIGNUM fromBytes(const std::vector<std::byte>& bytes)
  {
    return fromHex(HexConverter::bytesToHex(bytes));
  }

  /**
   * Add another BIGNUM to this one, and take the modulo of the sum.
   *
   * @param other  The other BIGNUM to add to this one.
   * @param modulo The modulo to take the sum to.
   * @return The modular sum.
   */
  [[nodiscard]] BIGNUM modularAdd(const BIGNUM& other, const BIGNUM& modulo) const
  {
    BN_CTX context(BN_CTX_secure_new());
    if (!context)
    {
      throw OpenSSLException(getErrorMessage("BN_CTX_secure_new"));
    }

    BIGNUM result(BN_secure_new());
    if (!result)
    {
      throw OpenSSLException(getErrorMessage("BN_secure_new"));
    }

    if (BN_mod_add(result.get(), get(), other.get(), modulo.get(), context.get()) <= 0)
    {
      throw OpenSSLException(getErrorMessage("BN_mod_add"));
    }

    return result;
  }

  /**
   * Get a vector of bytes representing this BIGNUM.
   *
   * @return The byte vector representing this BIGNUM.
   */
  [[nodiscard]] std::vector<std::byte> toBytes() const
  {
    char* hex = BN_bn2hex(get());
    const std::string hexString(hex);
    OPENSSL_free(hex);

    return HexConverter::hexToBytes(hexString);
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_BIGNUM_H_
// Filename: src/sdk/main/include/impl/openssl_utils/BN_CTX.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_BN_CTX_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_BN_CTX_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/bn.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL BN_CTX object.
 */
class BN_CTX : public OpenSSLObjectWrapper<::BN_CTX>
{
public:
  /**
   * No custom copier provided by OpenSSL for BN_CTX, so copying is disallowed.
   */
  ~BN_CTX() override = default;
  BN_CTX(const BN_CTX&) = delete;
  BN_CTX& operator=(const BN_CTX&) = delete;
  BN_CTX(BN_CTX&&) = default;
  BN_CTX& operator=(BN_CTX&&) = default;

  /**
   * Construct with the input BN_CTX and its BN_CTX_free deleter function.
   *
   * @param bnCtx The BN_CTX OpenSSL object to wrap.
   */
  explicit BN_CTX(::BN_CTX* bnCtx)
    : OpenSSLObjectWrapper(bnCtx, &BN_CTX_free)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_BN_CTX_H_// Filename: src/sdk/main/include/impl/openssl_utils/ECDSA_SIG.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_ECDSA_SIG_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_ECDSA_SIG_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/ecdsa.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL ECDSA_SIG object.
 */
class ECDSA_SIG : public OpenSSLObjectWrapper<::ECDSA_SIG>
{
public:
  /**
   * No custom copier provided by OpenSSL for ECDSA_SIG.
   */
  ~ECDSA_SIG() override = default;
  ECDSA_SIG(const ECDSA_SIG&) = delete;
  ECDSA_SIG& operator=(const ECDSA_SIG&) = delete;
  ECDSA_SIG(ECDSA_SIG&&) = default;
  ECDSA_SIG& operator=(ECDSA_SIG&&) = default;

  /**
   * Construct with the input ECDSA_SIG and its ECDSA_SIG_free deleter function.
   *
   * @param ecdsaSig The ECDSA_SIG OpenSSL object to wrap.
   */
  explicit ECDSA_SIG(::ECDSA_SIG* ecdsaSig)
    : OpenSSLObjectWrapper(ecdsaSig, &ECDSA_SIG_free)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_ECDSA_SIG_H_
// Filename: src/sdk/main/include/impl/openssl_utils/EC_GROUP.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EC_GROUP_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EC_GROUP_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/ec.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL EC_GROUP object.
 */
class EC_GROUP : public OpenSSLObjectWrapper<::EC_GROUP>
{
public:
  /**
   * Construct with the input EC_GROUP, its EC_GROUP_free deleter, and its EC_GROUP_dup copier.
   *
   * @param ecGroup The EC_GROUP OpenSSL object to wrap.
   */
  explicit EC_GROUP(::EC_GROUP* ecGroup)
    : OpenSSLObjectWrapper(ecGroup, &EC_GROUP_free, &EC_GROUP_dup)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EC_GROUP_H_// Filename: src/sdk/main/include/impl/openssl_utils/EC_POINT.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EC_POINT_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EC_POINT_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/ec.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL EC_POINT object.
 */
class EC_POINT : public OpenSSLObjectWrapper<::EC_POINT>
{
public:
  /**
   * No custom copier provided by OpenSSL for EC_POINT.
   */
  ~EC_POINT() override = default;
  EC_POINT(const EC_POINT&) = delete;
  EC_POINT& operator=(const EC_POINT&) = delete;
  EC_POINT(EC_POINT&&) = default;
  EC_POINT& operator=(EC_POINT&&) = default;

  /**
   * Construct with the input EC_POINT and its EC_POINT_free deleter function.
   *
   * @param ecPoint The EC_POINT OpenSSL object to wrap.
   */
  explicit EC_POINT(::EC_POINT* ecPoint)
    : OpenSSLObjectWrapper(ecPoint, &EC_POINT_free)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EC_POINT_H_
// Filename: src/sdk/main/include/impl/openssl_utils/EVP_MD.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_MD_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_MD_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/evp.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL EVP_MD object.
 */
class EVP_MD : public OpenSSLObjectWrapper<::EVP_MD>
{
public:
  /**
   * No custom copier provided by OpenSSL for EVP_MD.
   */
  ~EVP_MD() override = default;
  EVP_MD(const EVP_MD&) = delete;
  EVP_MD& operator=(const EVP_MD&) = delete;
  EVP_MD(EVP_MD&&) = default;
  EVP_MD& operator=(EVP_MD&&) = default;

  /**
   * Construct with the input EVP_MD and its EVP_MD_free deleter function.
   *
   * @param evpMd The EVP_MD OpenSSL object to wrap.
   */
  explicit EVP_MD(::EVP_MD* evpMd)
    : OpenSSLObjectWrapper(evpMd, &EVP_MD_free)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_MD_H_
// Filename: src/sdk/main/include/impl/openssl_utils/EVP_MD_CTX.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_MD_CTX_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_MD_CTX_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/evp.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL EVP_MD_CTX object.
 */
class EVP_MD_CTX : public OpenSSLObjectWrapper<::EVP_MD_CTX>
{
public:
  /**
   * No custom copier provided by OpenSSL for EVP_MD_CTX.
   */
  ~EVP_MD_CTX() override = default;
  EVP_MD_CTX(const EVP_MD_CTX&) = delete;
  EVP_MD_CTX& operator=(const EVP_MD_CTX&) = delete;
  EVP_MD_CTX(EVP_MD_CTX&&) = default;
  EVP_MD_CTX& operator=(EVP_MD_CTX&&) = default;

  /**
   * Construct with the input EVP_MD_CTX and its EVP_MD_CTX_free deleter function.
   *
   * @param evpMdCtx The EVP_MD_CTX OpenSSL object to wrap.
   */
  explicit EVP_MD_CTX(::EVP_MD_CTX* evpMdCtx)
    : OpenSSLObjectWrapper(evpMdCtx, &EVP_MD_CTX_free)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_MD_CTX_H_
// Filename: src/sdk/main/include/impl/openssl_utils/EVP_PKEY.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_PKEY_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_PKEY_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/evp.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL EVP_PKEY object.
 */
class EVP_PKEY : public OpenSSLObjectWrapper<::EVP_PKEY, decltype(&EVP_PKEY_dup)>
{
public:
  EVP_PKEY() = default;

  /**
   * Construct with the input EVP_PKEY, its EVP_PKEY_free deleter function, and its EVP_PKEY_dup copier function.
   *
   * @param evpPkey The EVP_PKEY OpenSSL object to wrap.
   */
  explicit EVP_PKEY(::EVP_PKEY* evpPkey)
    : OpenSSLObjectWrapper(evpPkey, &EVP_PKEY_free, &EVP_PKEY_dup)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_PKEY_H_
// Filename: src/sdk/main/include/impl/openssl_utils/EVP_PKEY_CTX.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_PKEY_CTX_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_PKEY_CTX_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/evp.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL EVP_PKEY_CTX object.
 */
class EVP_PKEY_CTX : public OpenSSLObjectWrapper<::EVP_PKEY_CTX>
{
public:
  /**
   * Construct with the input EVP_PKEY_CTX, its EVP_PKEY_CTX_free deleter function, and its EVP_PKEY_CTX_dup copier
   * function.
   *
   * @param evpPkeyCtx The EVP_PKEY_CTX OpenSSL object to wrap.
   */
  explicit EVP_PKEY_CTX(::EVP_PKEY_CTX* evpPkeyCtx)
    : OpenSSLObjectWrapper(evpPkeyCtx, &EVP_PKEY_CTX_free, &EVP_PKEY_CTX_dup)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_EVP_PKEY_CTX_H_
// Filename: src/sdk/main/include/impl/openssl_utils/OSSL_DECODER_CTX.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OSSL_DECODER_CTX_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OSSL_DECODER_CTX_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/decoder.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL OSSL_DECODER_CTX object.
 */
class OSSL_DECODER_CTX : public OpenSSLObjectWrapper<::OSSL_DECODER_CTX>
{
public:
  /**
   * No custom copier provided by OpenSSL for OSSL_LIB_CTX.
   */
  ~OSSL_DECODER_CTX() override = default;
  OSSL_DECODER_CTX(const OSSL_DECODER_CTX&) = delete;
  OSSL_DECODER_CTX& operator=(const OSSL_DECODER_CTX&) = delete;
  OSSL_DECODER_CTX(OSSL_DECODER_CTX&&) = default;
  OSSL_DECODER_CTX& operator=(OSSL_DECODER_CTX&&) = default;

  /**
   * Construct with the input OSSL_DECODER_CTX and its OSSL_DECODER_CTX_free deleter function.
   *
   * @param osslDecoderCtx The OSSL_DECODER_CTX OpenSSL object to wrap.
   */
  explicit OSSL_DECODER_CTX(::OSSL_DECODER_CTX* osslDecoderCtx)
    : OpenSSLObjectWrapper(osslDecoderCtx, &OSSL_DECODER_CTX_free)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OSSL_DECODER_CTX_H_
// Filename: src/sdk/main/include/impl/openssl_utils/OSSL_LIB_CTX.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OSSL_LIB_CTX_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OSSL_LIB_CTX_H_

#include "impl/openssl_utils/OpenSSLObjectWrapper.h"

#include <openssl/crypto.h>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Wrapper class for the OpenSSL OSSL_LIB_CTX object.
 */
class OSSL_LIB_CTX : public OpenSSLObjectWrapper<::OSSL_LIB_CTX>
{
public:
  /**
   * No custom copier provided by OpenSSL for OSSL_LIB_CTX.
   */
  ~OSSL_LIB_CTX() override = default;
  OSSL_LIB_CTX(const OSSL_LIB_CTX&) = delete;
  OSSL_LIB_CTX& operator=(const OSSL_LIB_CTX&) = delete;
  OSSL_LIB_CTX(OSSL_LIB_CTX&&) = default;
  OSSL_LIB_CTX& operator=(OSSL_LIB_CTX&&) = default;

  /**
   * Construct with the input OSSL_LIB_CTX and its OSSL_LIB_CTX_free deleter function.
   *
   * @param osslLibCtx The OSSL_LIB_CTX OpenSSL object to wrap.
   */
  explicit OSSL_LIB_CTX(::OSSL_LIB_CTX* osslLibCtx)
    : OpenSSLObjectWrapper(osslLibCtx, &OSSL_LIB_CTX_free)
  {
  }
};

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OSSL_LIB_CTX_H_
// Filename: src/sdk/main/include/impl/openssl_utils/OpenSSLObjectWrapper.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OPENSSL_OBJECT_WRAPPER_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OPENSSL_OBJECT_WRAPPER_H_

#include <functional>
#include <memory>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * Templated base wrapper class to be used for OpenSSL objects that require custom deleter and copier functions.
 *
 * @tparam ObjectType The type of OpenSSL object this class should wrap.
 * @tparam CopierFunc The copier type (function signature) for the OpenSSL object.
 */
template<typename ObjectType, typename CopierFunc = std::function<ObjectType*(const ObjectType*)>>
class OpenSSLObjectWrapper
{
public:
  virtual ~OpenSSLObjectWrapper() = default;

  /**
   * Copy constructor.
   *
   * @param other The OpenSSLObjectWrapper object to copy.
   */
  OpenSSLObjectWrapper(const OpenSSLObjectWrapper& other)
    : mObject({ other.mCopier(other.mObject.get()), other.mObject.get_deleter() })
    , mCopier(other.mCopier)
  {
  }

  /**
   * Copy assignment operator.
   *
   * @param other The OpenSSLObjectWrapper object to copy.
   */
  OpenSSLObjectWrapper& operator=(const OpenSSLObjectWrapper& other)
  {
    if (this != &other)
    {
      mObject = { other.mCopier(other.mObject.get()), other.mObject.get_deleter() };
      mCopier = other.mCopier;
    }

    return *this;
  }

  OpenSSLObjectWrapper(OpenSSLObjectWrapper&&) noexcept = default;
  OpenSSLObjectWrapper& operator=(OpenSSLObjectWrapper&&) noexcept = default;

  /**
   * Get the wrapped OpenSSL object.
   *
   * @return A pointer to the wrapped OpenSSL object. nullptr if no object exists.
   */
  [[nodiscard]] ObjectType* get() { return mObject.get(); }
  [[nodiscard]] const ObjectType* get() const { return mObject.get(); }

  /**
   * Release ownership of the wrapped OpenSSL object. This will cause memory leaks if ownership has not already been
   * taken by another object.
   */
  void release() { mObject.release(); }

  /**
   * Determine if this OpenSSLObjectWrapper has a valid OpenSSL object.
   *
   * @return \c TRUE if there exists an OpenSSL object, otherwise \c FALSE.
   */
  [[nodiscard]] explicit operator bool() const { return mObject != nullptr; }

protected:
  OpenSSLObjectWrapper() = default;

  /**
   * Construct with values for the object, its custom deleter, and optionally a custom copier.
   *
   * @param object  The OpenSSL object to wrap.
   * @param deleter The deleter function for the OpenSSL object.
   * @param copier  The copier function for the OpenSSL object.
   */
  OpenSSLObjectWrapper(ObjectType* object,
                       const std::function<void(ObjectType*)>& deleter,
                       const CopierFunc& copier = CopierFunc())
    : mObject({ object, deleter })
    , mCopier(copier)
  {
  }

private:
  /**
   * Pointer to the OpenSSL object with its associated deleter.
   */
  std::unique_ptr<ObjectType, std::function<void(ObjectType*)>> mObject = { nullptr,
                                                                            std::function<void(ObjectType*)>() };

  /**
   * The copier function to use to copy the wrapped OpenSSL object.
   */
  CopierFunc mCopier;
};

} // namespace Hiero::internal::Utils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OPENSSL_OBJECT_WRAPPER_H_
// Filename: src/sdk/main/include/impl/openssl_utils/OpenSSLUtils.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OPENSSL_UTILS_H_
#define HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OPENSSL_UTILS_H_

#include <string>
#include <string_view>
#include <vector>

namespace Hiero::internal::OpenSSLUtils
{
/**
 * The size of a SHA256 hash (in bytes).
 */
constexpr const size_t SHA256_HASH_SIZE = 32ULL;
/**
 * The size of a SHA384 hash (in bytes).
 */
constexpr const size_t SHA384_HASH_SIZE = 48ULL;
/**
 * The size of a KECCAK256 hash (in bytes)
 */
constexpr size_t KECCAK256_HASH_SIZE = 32ULL;
/**
 * The size of a SHA512 hash (in bytes).
 */
constexpr const size_t SHA512_HMAC_HASH_SIZE = 64ULL;
/**
 * The size of an OpenSSL error message.
 */
constexpr const size_t ERROR_MSG_SIZE = 256ULL;

/**
 * Computes the SHA256 hash of a byte array.
 *
 * @param data The byte array of which to compute the hash.
 * @return The SHA256 hash of the data.
 */
[[nodiscard]] std::vector<std::byte> computeSHA256(const std::vector<std::byte>& data);

/**
 * Compute the SHA384 hash of a byte array.
 *
 * @param data The byte array of which to compute the hash.
 * @return The SHA384 hash of the data.
 */
[[nodiscard]] std::vector<std::byte> computeSHA384(const std::vector<std::byte>& data);

/**
 * Compute the KECCAK256 hash of a byte array.
 *
 * @param data The byte array of which to compute the hash.
 * @return The KECCAK256 hash of the data.
 */
[[nodiscard]] std::vector<std::byte> computeKECCAK256(const std::vector<std::byte>& data);

/**
 * Compute the HMAC-SHA512 hash of a key and data.
 *
 * @param key  The key input to the hash function.
 * @param data The data input to the hash function.
 * @return The HMAC-SHA512 hash of the data and key.
 * @throws OpenSSLException If OpenSSL is unable to compute the HMAC-SHA512 hash of the given inputs.
 */
[[nodiscard]] std::vector<std::byte> computeSHA512HMAC(const std::vector<std::byte>& key,
                                                       const std::vector<std::byte>& data);

/**
 * Gets an error message for an OpenSSL error. Includes as much detail as possible.
 *
 * @param functionName The name of the OpenSSL function which caused the error.
 * @return An error string.
 */
[[nodiscard]] std::string getErrorMessage(std::string_view functionName);

/**
 * Get a vector of random bytes.
 *
 * @param count The number of random bytes to generate. Must be positive.
 * @return The vector of random bytes.
 * @throws std::invalid_argument If the input count is negative.
 * @throws OpenSSLException If OpenSSL is unable to generate random bytes.
 */
[[nodiscard]] std::vector<std::byte> getRandomBytes(int count);

} // namespace Hiero::internal::OpenSSLUtils

#endif // HIERO_SDK_CPP_IMPL_OPENSSL_UTILS_OPENSSL_UTILS_H_
// Filename: src/sdk/tests/integration/BaseIntegrationTest.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_SDK_CPP_BASE_INTEGRATION_TEST_H_
#define HIERO_SDK_CPP_BASE_INTEGRATION_TEST_H_

#include "AccountId.h"
#include "Client.h"
#include "ED25519PrivateKey.h"
#include "PrivateKey.h"

#include <gtest/gtest.h>
#include <string>

namespace Hiero
{

class BaseIntegrationTest : public testing::Test
{
protected:
  [[nodiscard]] inline const Client& getTestClient() const { return mClient; }
  [[nodiscard]] inline const std::vector<std::byte>& getTestFileContent() const { return mFileContent; }
  [[nodiscard]] inline const std::string& getTestSmartContractBytecode() const { return mTestContractBytecodeHex; }

  void setTestClientOperator(const AccountId& accountId, const std::shared_ptr<PrivateKey>& privateKey);
  void setDefaultTestClientOperator();
  void SetUp() override;

private:
  Client mClient;
  std::vector<std::byte> mFileContent;
  const AccountId mDefaultTestAccountId = AccountId::fromString("0.0.2");
  const std::shared_ptr<PrivateKey> mDefaultTestPrivateKey = ED25519PrivateKey::fromString(
    "302e020100300506032b65700422042091132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137");
  const std::string mTestContractBytecodeHex =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b8101908080"
    "51604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081"
    "118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001"
    "610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b50604052505060"
    "0080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b82805460018160011615610100"
    "0203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001"
    "018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b61"
    "01a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080"
    "fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b61"
    "00ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b820183602082011115"
    "61008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f0160208091040260"
    "20016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec61"
    "01a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561013857818101"
    "5183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a03191681526020019150"
    "5b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b"
    "505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f60026000196101008789161502019095"
    "1694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283"
    "529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050"
    "505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106102915780"
    "5160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be57825182559160200191906001019061"
    "02a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084"
    "964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";
};

} // namespace Hiero

#endif // HIERO_SDK_CPP_BASE_INTEGRATION_TEST_H_// Filename: src/tck/include/TckServer.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_TCK_SERVER_H_
#define HIERO_TCK_CPP_TCK_SERVER_H_

#include <functional>
#include <httplib.h>
#include <nlohmann/json_fwd.hpp>
#include <string>
#include <unordered_map>

namespace Hiero::TCK
{
/**
 * Class encompassing all HTTP and JSON processing of TCK requests.
 */
class TckServer
{
public:
  /**
   * The default port on which to listen for HTTP requests from the TCK.
   */
  [[maybe_unused]] constexpr static const int DEFAULT_HTTP_PORT = 8544;

  /**
   * Methods involve taking JSON parameters, doing a function, then returning the status of the execution in another
   * JSON object.
   */
  using MethodHandle = std::function<nlohmann::json(const nlohmann::json&)>;

  /**
   * Notifications involve taking JSON parameters, doing a function, and then reporting nothing back.
   */
  using NotificationHandle = std::function<void(const nlohmann::json&)>;

  /**
   * Construct a TckServer with the default HTTP port.
   */
  TckServer();

  /**
   * Construct a TckServer with a port on which to listen for JSON requests.
   *
   * @param port The port on which to listen for JSON requests.
   */
  explicit TckServer(int port);

  /**
   * Add a JSON RPC method function.
   *
   * @param name The name of the function.
   * @param func The function to run.
   */
  void add(const std::string& name, const MethodHandle& func);

  /**
   * Add a JSON RPC notification function.
   *
   * @param name The name of the function.
   * @param func The function to run.
   */
  void add(const std::string& name, const NotificationHandle& func);

  /**
   * Start listening for HTTP requests. All JSON RPC functions should be added before this is called.
   */
  void startServer();

  /**
   * Create a method handle for the input method. The created method handles creating the method inputs from the
   * provided JSON.
   *
   * @tparam ParamsType The parameters to pass into to method.
   * @param  method     The method of which to get the handle.
   * @return The handle for the method.
   */
  template<typename ParamsType>
  MethodHandle getHandle(nlohmann::json (*method)(const ParamsType&));

  /**
   * Create a notification handle for the input notification. The created notification handles creating the notification
   * inputs from the provided JSON.
   *
   * @tparam ParamsType   The parameters to pass into to notification.
   * @param  notification The notification of which to get the handle.
   * @return The handle for the notification.
   */
  template<typename ParamsType>
  [[maybe_unused]] NotificationHandle getHandle(void (*notification)(const ParamsType&));

private:
  /**
   * Handle an HTTP request sent from a client.
   *
   * @param request  The HTTP request to process.
   * @param response The HTTP response to fill out.
   */
  void handleHttpRequest(const httplib::Request& request, httplib::Response& response);

  /**
   * Handle a JSON request sent from the JSON RPC client.
   *
   * @param request The JSON request to handle.
   * @return The response to the request.
   */
  std::string handleJsonRequest(const std::string& request);

  /**
   * Handle a single JSON request.
   *
   * @param request The JSON request to handle.
   * @return The JSON response.
   */
  [[nodiscard]] nlohmann::json handleSingleRequest(const nlohmann::json& request);

  /**
   * Set up the handler for the HTTP server.
   */
  void setupHttpHandler();

  /**
   * Map of function names to their corresponding methods.
   */
  std::unordered_map<std::string, MethodHandle> mMethods;

  /**
   * Map of function names to their corresponding notifications.
   */
  std::unordered_map<std::string, NotificationHandle> mNotifications;

  /**
   * The HTTP server to use to receive JSON requests.
   */
  httplib::Server mHttpServer;

  /**
   * The port on which to listen for JSON requests.
   */
  int mPort = DEFAULT_HTTP_PORT;
};

} // namespace Hiero::TCK

#endif // HIERO_TCK_CPP_TCK_SERVER_H_
// Filename: src/tck/include/account/AccountService.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_ACCOUNT_SERVICE_H_
#define HIERO_TCK_CPP_ACCOUNT_SERVICE_H_

#include <nlohmann/json_fwd.hpp>

namespace Hiero::TCK::AccountService
{
/**
 * Forward declarations.
 */
struct ApproveAllowanceParams;
struct CreateAccountParams;
struct DeleteAccountParams;
struct DeleteAllowanceParams;
struct UpdateAccountParams;

/**
 * Approve an allowance to an account.
 *
 * @param params The parameters to use to approve the allowance.
 * @return A JSON response containing the status of the allowance approval.
 */
nlohmann::json approveAllowance(const ApproveAllowanceParams& params);

/**
 * Delete an allowance from an account.
 *
 * @param params The parameters to use to delete the allowance.
 * @return A JSON response containing the status of the allowance deletion.
 */
nlohmann::json deleteAllowance(const DeleteAllowanceParams& params);

/**
 * Create an account.
 *
 * @param params The parameters to use to create an account.
 * @return A JSON response containing the created account ID and the status of the account creation.
 */
nlohmann::json createAccount(const CreateAccountParams& params);

/**
 * Delete an account.
 *
 * @param params The parameters to use to delete an account.
 * @return A JSON response containing the status of the account deletion.
 */
nlohmann::json deleteAccount(const DeleteAccountParams& params);

/**
 * Update an account.
 *
 * @param params The parameters to use to update an account.
 * @return A JSON response containing the status of the account update.
 */
nlohmann::json updateAccount(const UpdateAccountParams& params);

} // namespace Hiero::TCK::AccountService

#endif // HIERO_TCK_CPP_ACCOUNT_SERVICE_H_
// Filename: src/tck/include/account/params/ApproveAllowanceParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_APPROVE_ALLOWANCE_PARAMS_H_
#define HIERO_TCK_CPP_APPROVE_ALLOWANCE_PARAMS_H_

#include "account/params/allowance/AllowanceParams.h"
#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::AccountService
{
/**
 * Struct to hold the arguments for a `approveAllowance` JSON-RPC method call.
 */
struct ApproveAllowanceParams
{
  /**
   * The allowances to approve.
   */
  std::vector<AllowanceParams> mAllowances;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert ApproveAllowanceParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::ApproveAllowanceParams>
{
  /**
   * Convert a JSON object to a ApproveAllowanceParams.
   *
   * @param jsonFrom The JSON object with which to fill the ApproveAllowanceParams.
   * @param params   The ApproveAllowanceParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::ApproveAllowanceParams& params)
  {
    params.mAllowances = Hiero::TCK::getRequiredJsonParameter<std::vector<Hiero::TCK::AccountService::AllowanceParams>>(
      jsonFrom, "allowances");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_APPROVE_ALLOWANCE_PARAMS_H_
// Filename: src/tck/include/account/params/CreateAccountParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_CREATE_ACCOUNT_PARAMS_H_
#define HIERO_TCK_CPP_CREATE_ACCOUNT_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <cstdint>
#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::AccountService
{
/**
 * Struct to hold the arguments for a `createAccount` JSON-RPC method call.
 */
struct CreateAccountParams
{
  /**
   * The desired key for the account.
   */
  std::optional<std::string> mKey;

  /**
   * The desired initial balance for the account.
   */
  std::optional<std::string> mInitialBalance;

  /**
   * Should the new account require a receiver signature?
   */
  std::optional<bool> mReceiverSignatureRequired;

  /**
   * The desired amount of time in seconds to renew the new account.
   */
  std::optional<std::string> mAutoRenewPeriod;

  /**
   * The desired memo for the new account.
   */
  std::optional<std::string> mMemo;

  /**
   * The desired maximum number of automatic token associations for the account.
   */
  std::optional<int32_t> mMaxAutoTokenAssociations;

  /**
   * The ID of the desired account to which the new account should stake.
   */
  std::optional<std::string> mStakedAccountId;

  /**
   * The ID of the desired node to which the new account should stake.
   */
  std::optional<std::string> mStakedNodeId;

  /**
   * Should the new account decline staking rewards?
   */
  std::optional<bool> mDeclineStakingReward;

  /**
   * The desired alias for the new account.
   */
  std::optional<std::string> mAlias;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert CreateAccountParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::CreateAccountParams>
{
  /**
   * Convert a JSON object to a CreateAccountParams.
   *
   * @param jsonFrom The JSON object with which to fill the CreateAccountParams.
   * @param params   The CreateAccountParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::CreateAccountParams& params)
  {
    params.mKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "key");
    params.mInitialBalance = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "initialBalance");
    params.mReceiverSignatureRequired =
      Hiero::TCK::getOptionalJsonParameter<bool>(jsonFrom, "receiverSignatureRequired");
    params.mAutoRenewPeriod = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "autoRenewPeriod");
    params.mMemo = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "memo");
    params.mMaxAutoTokenAssociations =
      Hiero::TCK::getOptionalJsonParameter<int32_t>(jsonFrom, "maxAutoTokenAssociations");
    params.mStakedAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "stakedAccountId");
    params.mStakedNodeId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "stakedNodeId");
    params.mDeclineStakingReward = Hiero::TCK::getOptionalJsonParameter<bool>(jsonFrom, "declineStakingReward");
    params.mAlias = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "alias");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_CREATE_ACCOUNT_PARAMS_H_
// Filename: src/tck/include/account/params/DeleteAccountParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_DELETE_ACCOUNT_PARAMS_H_
#define HIERO_TCK_CPP_DELETE_ACCOUNT_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::AccountService
{
/**
 * Struct to hold the arguments for a `deleteAccount` JSON-RPC method call.
 */
struct DeleteAccountParams
{
  /**
   * The ID of the account to delete.
   */
  std::optional<std::string> mDeleteAccountId;

  /**
   * The ID of the account to which to transfer remaining balances.
   */
  std::optional<std::string> mTransferAccountId;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert DeleteAccountParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::DeleteAccountParams>
{
  /**
   * Convert a JSON object to a DeleteAccountParams.
   *
   * @param jsonFrom The JSON object with which to fill the DeleteAccountParams.
   * @param params   The DeleteAccountParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::DeleteAccountParams& params)
  {
    params.mDeleteAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "deleteAccountId");
    params.mTransferAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "transferAccountId");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_DELETE_ACCOUNT_PARAMS_H_
// Filename: src/tck/include/account/params/DeleteAllowanceParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_DELETE_ALLOWANCE_PARAMS_H_
#define HIERO_TCK_CPP_DELETE_ALLOWANCE_PARAMS_H_

#include "account/params/allowance/RemoveAllowanceParams.h"
#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::AccountService
{
/**
 * Struct to hold the arguments for a `deleteAllowance` JSON-RPC method call.
 */
struct DeleteAllowanceParams
{
  /**
   * The allowances to delete.
   */
  std::vector<RemoveAllowanceParams> mAllowances;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert DeleteAllowanceParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::DeleteAllowanceParams>
{
  /**
   * Convert a JSON object to a DeleteAllowanceParams.
   *
   * @param jsonFrom The JSON object with which to fill the DeleteAllowanceParams.
   * @param params   The DeleteAllowanceParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::DeleteAllowanceParams& params)
  {
    params.mAllowances =
      Hiero::TCK::getRequiredJsonParameter<std::vector<Hiero::TCK::AccountService::RemoveAllowanceParams>>(
        jsonFrom, "allowances");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_DELETE_ALLOWANCE_PARAMS_H_
// Filename: src/tck/include/account/params/UpdateAccountParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_UPDATE_ACCOUNT_PARAMS_H_
#define HIERO_TCK_CPP_UPDATE_ACCOUNT_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <cstdint>
#include <nlohmann/json_fwd.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::AccountService
{
/**
 * Struct to hold the arguments for an `updateAccount` JSON-RPC method call.
 */
struct UpdateAccountParams
{
  /**
   * The ID of the account to update.
   */
  std::optional<std::string> mAccountId;

  /**
   * The desired new key for the account.
   */
  std::optional<std::string> mKey;

  /**
   * The desired new amount of time in seconds to renew the account.
   */
  std::optional<std::string> mAutoRenewPeriod;

  /**
   * The new expiration time to which to extend this account.
   */
  std::optional<std::string> mExpirationTime;

  /**
   * Should the account now require a receiver signature?
   */
  std::optional<bool> mReceiverSignatureRequired;

  /**
   * The desired new memo for the account.
   */
  std::optional<std::string> mMemo;

  /**
   * The desired new maximum number of automatic token associations for the account.
   */
  std::optional<int32_t> mMaxAutoTokenAssociations;

  /**
   * The ID of the new desired account to which the account should stake.
   */
  std::optional<std::string> mStakedAccountId;

  /**
   * The ID of the new desired node to which the account should stake.
   */
  std::optional<std::string> mStakedNodeId;

  /**
   * Should the account now decline staking rewards?
   */
  std::optional<bool> mDeclineStakingReward;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert UpdateAccountParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::UpdateAccountParams>
{
  /**
   * Convert a JSON object to a UpdateAccountParams.
   *
   * @param jsonFrom The JSON object with which to fill the UpdateAccountParams.
   * @param params   The UpdateAccountParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::UpdateAccountParams& params)
  {
    params.mAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "accountId");
    params.mKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "key");
    params.mAutoRenewPeriod = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "autoRenewPeriod");
    params.mExpirationTime = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "expirationTime");
    params.mReceiverSignatureRequired =
      Hiero::TCK::getOptionalJsonParameter<bool>(jsonFrom, "receiverSignatureRequired");
    params.mMemo = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "memo");
    params.mMaxAutoTokenAssociations =
      Hiero::TCK::getOptionalJsonParameter<int32_t>(jsonFrom, "maxAutoTokenAssociations");
    params.mStakedAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "stakedAccountId");
    params.mStakedNodeId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "stakedNodeId");
    params.mDeclineStakingReward = Hiero::TCK::getOptionalJsonParameter<bool>(jsonFrom, "declineStakingReward");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_UPDATE_ACCOUNT_PARAMS_H_
// Filename: src/tck/include/account/params/allowance/AllowanceParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_ALLOWANCE_PARAMS_H_
#define HIERO_TCK_CPP_ALLOWANCE_PARAMS_H_

#include "account/params/allowance/HbarAllowanceParams.h"
#include "account/params/allowance/NftAllowanceParams.h"
#include "account/params/allowance/TokenAllowanceParams.h"
#include "json/JsonErrorType.h"
#include "json/JsonRpcException.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::AccountService
{
/**
 * Struct that contains the parameters of an allowance.
 */
struct AllowanceParams
{
  /**
   * The ID of the owner account granting the allowance.
   */
  std::string mOwnerAccountId;

  /**
   * The ID of the spender account being granted the allowance.
   */
  std::string mSpenderAccountId;

  /**
   * The Hbar allowance information.
   */
  std::optional<HbarAllowanceParams> mHbar;

  /**
   * The token allowance information.
   */
  std::optional<TokenAllowanceParams> mToken;

  /**
   * The NFT allowance information.
   */
  std::optional<NftAllowanceParams> mNft;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert AllowanceParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::AllowanceParams>
{
  /**
   * Convert a JSON object to a AllowanceParams.
   *
   * @param jsonFrom The JSON object with which to fill the AllowanceParams.
   * @param params   The AllowanceParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::AllowanceParams& params)
  {
    params.mOwnerAccountId = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "ownerAccountId");
    params.mSpenderAccountId = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "spenderAccountId");
    params.mHbar =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::AccountService::HbarAllowanceParams>(jsonFrom, "hbar");
    params.mToken =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::AccountService::TokenAllowanceParams>(jsonFrom, "token");
    params.mNft = Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::AccountService::NftAllowanceParams>(jsonFrom, "nft");

    // Only one allowance type should be allowed.
    if ((!params.mHbar.has_value() || params.mToken.has_value() || params.mNft.has_value()) &&
        (params.mHbar.has_value() || !params.mToken.has_value() || params.mNft.has_value()) &&
        (params.mHbar.has_value() || params.mToken.has_value() || !params.mNft.has_value()))
    {
      throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                         "invalid parameters: only one type of allowance SHALL be provided.");
    }
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_ALLOWANCE_PARAMS_H_
// Filename: src/tck/include/account/params/allowance/HbarAllowanceParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_HBAR_ALLOWANCE_PARAMS_H_
#define HIERO_TCK_CPP_HBAR_ALLOWANCE_PARAMS_H_

#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <string>

namespace Hiero::TCK::AccountService
{
/**
 * Struct that contains the parameters of an Hbar allowance.
 */
struct HbarAllowanceParams
{
  /**
   * The amount of Hbar to allowance.
   */
  std::string mAmount;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert HbarAllowanceParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::HbarAllowanceParams>
{
  /**
   * Convert a JSON object to a HbarAllowanceParams.
   *
   * @param jsonFrom The JSON object with which to fill the HbarAllowanceParams.
   * @param params   The HbarAllowanceParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::HbarAllowanceParams& params)
  {
    params.mAmount = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "amount");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_HBAR_ALLOWANCE_PARAMS_H_
// Filename: src/tck/include/account/params/allowance/NftAllowanceParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_NFT_ALLOWANCE_PARAMS_H_
#define HIERO_TCK_CPP_NFT_ALLOWANCE_PARAMS_H_

#include "json/JsonErrorType.h"
#include "json/JsonRpcException.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>
#include <vector>

namespace Hiero::TCK::AccountService
{
/**
 * Struct that contains the parameters of an NFT allowance.
 */
struct NftAllowanceParams
{
  /**
   * The ID of the token being allowanced.
   */
  std::string mTokenId;

  /**
   * The serial numbers of the NFTs to allowance.
   */
  std::optional<std::vector<std::string>> mSerialNumbers;

  /**
   * Should the spender be allowed access to all the owner's NFTs of the specified token ID, current and future?
   */
  std::optional<bool> mApprovedForAll;

  /**
   * The ID of the spender account who already has approvedForAll privileges and is granting an allowance to
   * another account.
   */
  std::optional<std::string> mDelegateSpenderAccountId;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert NftAllowanceParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::NftAllowanceParams>
{
  /**
   * Convert a JSON object to a NftAllowanceParams.
   *
   * @param jsonFrom The JSON object with which to fill the NftAllowanceParams.
   * @param params   The NftAllowanceParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::NftAllowanceParams& params)
  {
    params.mTokenId = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mSerialNumbers = Hiero::TCK::getOptionalJsonParameter<std::vector<std::string>>(jsonFrom, "serialNumbers");
    params.mApprovedForAll = Hiero::TCK::getOptionalJsonParameter<bool>(jsonFrom, "approvedForAll");
    params.mDelegateSpenderAccountId =
      Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "delegateSpenderAccountId");

    if (params.mSerialNumbers.has_value() == params.mApprovedForAll.has_value())
    {
      throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                         "invalid parameters: only one of serialNumbers and approvedForAll MUST be "
                                         "provided.");
    }
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_NFT_ALLOWANCE_PARAMS_H_
// Filename: src/tck/include/account/params/allowance/RemoveAllowanceParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_REMOVE_ALLOWANCE_PARAMS_H_
#define HIERO_TCK_CPP_REMOVE_ALLOWANCE_PARAMS_H_

#include "json/JsonErrorType.h"
#include "json/JsonRpcException.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <string>

namespace Hiero::TCK::AccountService
{
/**
 * Struct that contains the parameters to remove an allowance.
 */
struct RemoveAllowanceParams
{
  /**
   * The ID of the owner account removing the allowance.
   */
  std::string mOwnerAccountId;

  /**
   * The ID of the token of which to remove the allowance.
   */
  std::string mTokenId;

  /**
   * The serial numbers of the tokens of which to remove the allowance
   */
  std::vector<std::string> mSerialNumbers;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert RemoveAllowanceParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::RemoveAllowanceParams>
{
  /**
   * Convert a JSON object to a RemoveAllowanceParams.
   *
   * @param jsonFrom The JSON object with which to fill the RemoveAllowanceParams.
   * @param params   The RemoveAllowanceParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::RemoveAllowanceParams& params)
  {
    params.mOwnerAccountId = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "ownerAccountId");
    params.mTokenId = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mSerialNumbers = Hiero::TCK::getRequiredJsonParameter<std::vector<std::string>>(jsonFrom, "serialNumbers");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_REMOVE_ALLOWANCE_PARAMS_H_
// Filename: src/tck/include/account/params/allowance/TokenAllowanceParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_TOKEN_ALLOWANCE_PARAMS_H_
#define HIERO_TCK_CPP_TOKEN_ALLOWANCE_PARAMS_H_

#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <string>

namespace Hiero::TCK::AccountService
{
/**
 * Struct that contains the parameters of a token allowance.
 */
struct TokenAllowanceParams
{
  /**
   * The ID of the token being allowanced.
   */
  std::string mTokenId;

  /**
   * The amount of the token to allowance.
   */
  std::string mAmount;
};

} // namespace Hiero::TCK::AccountService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert TokenAllowanceParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::AccountService::TokenAllowanceParams>
{
  /**
   * Convert a JSON object to a TokenAllowanceParams.
   *
   * @param jsonFrom The JSON object with which to fill the TokenAllowanceParams.
   * @param params   The TokenAllowanceParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::AccountService::TokenAllowanceParams& params)
  {
    params.mTokenId = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mAmount = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "amount");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_ALLOWANCE_PARAMS_H_
// Filename: src/tck/include/common/CommonTransactionParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_COMMON_TRANSACTION_PARAMS_H_
#define HIERO_TCK_CPP_COMMON_TRANSACTION_PARAMS_H_

#include "json/JsonUtils.h"

#include <Client.h>
#include <Hbar.h>
#include <PrivateKey.h>
#include <Transaction.h>
#include <TransactionId.h>

#include <chrono>
#include <cstdint>
#include <nlohmann/json_fwd.hpp>
#include <optional>
#include <string>
#include <vector>

namespace Hiero::TCK
{
/**
 * Struct the contains the common parameters of a Transaction.
 */
struct CommonTransactionParams
{
  /**
   * Function that fills a Transaction with the parameters present in this CommonTransactionParams.
   *
   * @tparam T           The type of Transaction being filled out.
   * @param  transaction The Transaction to fill out.
   * @param  client      The Client being used to submit this Transaction.
   */
  template<typename T>
  void fillOutTransaction(Transaction<T>& transaction, const Client& client) const
  {
    if (mTransactionId.has_value())
    {
      transaction.setTransactionId(TransactionId::fromString(mTransactionId.value()));
    }

    if (mMaxTransactionFee.has_value())
    {
      transaction.setMaxTransactionFee(Hbar::fromTinybars(mMaxTransactionFee.value()));
    }

    if (mValidTransactionDuration.has_value())
    {
      transaction.setValidTransactionDuration(std::chrono::seconds(mValidTransactionDuration.value()));
    }

    if (mMemo.has_value())
    {
      transaction.setTransactionMemo(mMemo.value());
    }

    if (mRegenerateTransactionId.has_value())
    {
      transaction.setRegenerateTransactionIdPolicy(mRegenerateTransactionId.value());
    }

    if (mSigners.has_value())
    {
      transaction.freezeWith(&client);
      std::for_each(mSigners->cbegin(),
                    mSigners->cend(),
                    [&transaction](const std::string& key) { transaction.sign(PrivateKey::fromStringDer(key)); });
    }
  }

  /**
   * The ID of the transaction.
   */
  std::optional<std::string> mTransactionId;

  /**
   * The maximum amount willing to be paid to execute the transaction.
   */
  std::optional<int64_t> mMaxTransactionFee;

  /**
   * The length of time for which the transaction is valid.
   */
  std::optional<int64_t> mValidTransactionDuration;

  /**
   * The memo of the transaction.
   */
  std::optional<std::string> mMemo;

  /**
   * If expired, should the transaction regenerate it's transaction ID?
   */
  std::optional<bool> mRegenerateTransactionId;

  /**
   * The list of DER-encoded hex strings of private keys to sign the transaction.
   */
  std::optional<std::vector<std::string>> mSigners;
};

} // namespace Hiero::TCK

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert CommonTransactionParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::CommonTransactionParams>
{
  /**
   * Convert a JSON object to a CommonTransactionParams.
   *
   * @param jsonFrom The JSON object with which to fill the CommonTransactionParams.
   * @param params   The CommonTransactionParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::CommonTransactionParams& params)
  {
    params.mTransactionId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "transactionId");
    params.mMaxTransactionFee = Hiero::TCK::getOptionalJsonParameter<int64_t>(jsonFrom, "maxTransactionFee");
    params.mValidTransactionDuration =
      Hiero::TCK::getOptionalJsonParameter<int64_t>(jsonFrom, "validTransactionDuration");
    params.mMemo = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "memo");
    params.mRegenerateTransactionId = Hiero::TCK::getOptionalJsonParameter<bool>(jsonFrom, "regenerateTransactionId");
    params.mSigners = Hiero::TCK::getOptionalJsonParameter<std::vector<std::string>>(jsonFrom, "signers");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_COMMON_TRANSACTION_PARAMS_H_
// Filename: src/tck/include/json/JsonErrorType.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_JSON_ERROR_TYPE_H_
#define HIERO_TCK_CPP_JSON_ERROR_TYPE_H_

namespace Hiero::TCK
{
/**
 * Enum used to describe an error seen while handling a JSON RPC request.
 */
enum class JsonErrorType : short
{
  /**
   * Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.
   */
  PARSE_ERROR = -32700,
  /**
   * The JSON sent is not a valid request object.
   */
  INVALID_REQUEST = -32600,
  /**
   * The method does not exist/is not available.
   */
  METHOD_NOT_FOUND = -32601,
  /**
   * Invalid method parameter(s).
   */
  INVALID_PARAMS = -32602,
  /**
   * Internal JSON-RPC error.
   */
  INTERNAL_ERROR = -32603,
  /**
   * The Hiero C++ SDK failed to execute the JSON request.
   */
  HIERO_ERROR = -32001
};

} // namespace Hiero::TCK

#endif // HIERO_TCK_CPP_JSON_ERROR_TYPE_H_
// Filename: src/tck/include/json/JsonRpcException.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_JSON_RPC_EXCEPTION_H_
#define HIERO_TCK_CPP_JSON_RPC_EXCEPTION_H_

#include "json/JsonErrorType.h"

#include <nlohmann/json.hpp>
#include <stdexcept>
#include <string>
#include <string_view>

namespace Hiero::TCK
{
/**
 * An exception thrown when there is any issue parsing/executing JSON RPC calls.
 */
class JsonRpcException : public std::exception
{
public:
  /**
   * Construct with an error code and an error message.
   *
   * @param code    The error code.
   * @param message The error message.
   */
  JsonRpcException(JsonErrorType code, std::string_view message) noexcept;

  /**
   * Construct with an error code, an error message, and additional JSON data.
   *
   * @param code    The error code.
   * @param message The error message.
   * @param data    The additional JSON data.
   */
  JsonRpcException(JsonErrorType code, std::string_view message, nlohmann::json data) noexcept;

  /**
   * Derived from std::exception. Get the full error message as a C-string.
   *
   * @return The full error message as a C-string.
   */
  [[nodiscard]] const char* what() const noexcept override { return mError.c_str(); }

  /**
   * Get the error code.
   *
   * @return The error code.
   */
  [[nodiscard]] inline JsonErrorType getCode() const noexcept { return mCode; }

  /**
   * Get the error message.
   *
   * @return The error message.
   */
  [[nodiscard]] inline std::string getMessage() const noexcept { return mMessage; }

  /**
   * Get the additional JSON data.
   *
   * @return The additional JSON data.
   */
  [[nodiscard]] inline nlohmann::json getData() const noexcept { return mData; }

private:
  /**
   * The error code.
   */
  JsonErrorType mCode;

  /**
   * The error message.
   */
  std::string mMessage;

  /**
   * The additional JSON data.
   */
  nlohmann::json mData;

  /**
   * The full error message.
   */
  std::string mError;
};

} // namespace Hiero::TCK

#endif // HIERO_TCK_CPP_JSON_RPC_EXCEPTION_H_
// Filename: src/tck/include/json/JsonUtils.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_JSON_UTILS_H_
#define HIERO_TCK_CPP_JSON_UTILS_H_

#include "json/JsonErrorType.h"
#include "json/JsonRpcException.h"

#include <nlohmann/json_fwd.hpp>
#include <optional>
#include <string>
#include <string_view>

namespace Hiero::TCK
{
/**
 * Get a required parameter from a JSON object.
 *
 * @tparam T    The C++ type of parameter to get.
 * @param  json The JSON from which to get the parameter.
 * @param  name The name of the parameter to get.
 * @return The parameter as the specified type.
 * @throws JsonRpcException If the parameter doesn't exist or is not the specified type.
 */
template<typename T>
T getRequiredJsonParameter(const nlohmann::json& json, std::string_view name)
{
  if (!json.contains(name))
  {
    throw JsonRpcException(JsonErrorType::INVALID_PARAMS, "invalid parameters: " + std::string(name) + " is required");
  }

  try
  {
    return json[name].get<T>();
  }
  catch (const nlohmann::json::type_error& err)
  {
    throw JsonRpcException(JsonErrorType::INVALID_PARAMS, "invalid parameters: " + std::string(err.what()));
  }
}

/**
 * Get an optional parameter from a JSON object.
 *
 * @tparam T    The C++ type of parameter to get.
 * @param  json The JSON from which to get the parameter.
 * @param  name The name of the parameter to get.
 * @return The parameter as the specified type, std::nullopt if the parameter doesn't exist.
 * @throws JsonRpcException If the parameter doesn't exist or is not the specified type.
 */
template<typename T>
std::optional<T> getOptionalJsonParameter(const nlohmann::json& json, std::string_view name)
{
  if (!json.contains(name))
  {
    return std::optional<T>(std::nullopt);
  }

  try
  {
    return json[name].get<T>();
  }
  catch (const nlohmann::json::type_error& err)
  {
    throw JsonRpcException(JsonErrorType::INVALID_PARAMS, "invalid parameters: " + std::string(err.what()));
  }
}

/**
 * Does a JSON request have a particular key of a particular type?
 *
 * @param request The JSON request used to determine whether it contains the key.
 * @param key     The key for which to check.
 * @param type    The type of the key.
 * @return \c TRUE if the JSON request contains the key with the type, otherwise \c FALSE.
 */
bool hasKeyType(const nlohmann::json& request, std::string_view key, nlohmann::json::value_t type);

/**
 * Does a JSON request have a valid ID parameter?
 *
 * @param request The JSON request used to determine whether it contains a valid ID.
 * @return \c TRUE if the JSON request has a valid ID, otherwise \c FALSE.
 */
bool hasValidId(const nlohmann::json& request);

} // namespace Hiero::TCK

#endif // HIERO_TCK_CPP_JSON_UTILS_H_
// Filename: src/tck/include/key/KeyService.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_KEY_SERVICE_H_
#define HIERO_TCK_CPP_KEY_SERVICE_H_

#include <Key.h>

#include <memory>
#include <nlohmann/json_fwd.hpp>
#include <string>
#include <unordered_map>

namespace Hiero::TCK::KeyService
{
/**
 * Forward declarations.
 */
struct GenerateKeyParams;

/**
 * Enumeration of the possible types of Keys the SDK server can generate.
 */
enum class KeyType : unsigned char
{
  ED25519_PRIVATE_KEY_TYPE,
  ED25519_PUBLIC_KEY_TYPE,
  ECDSA_SECP256k1_PRIVATE_KEY_TYPE,
  ECDSA_SECP256k1_PUBLIC_KEY_TYPE,
  LIST_KEY_TYPE,
  THRESHOLD_KEY_TYPE,
  EVM_ADDRESS_KEY_TYPE,
  KEY_TYPE_SIZE [[maybe_unused]]
};

/**
 * Map of KeyTypes to their string representation.
 */
extern const std::unordered_map<std::string, KeyType> gStringToKeyType;

/**
 * Map of KeyType string representations to KeyType.
 */
extern const std::unordered_map<KeyType, std::string> gKeyTypeToString;

/**
 * Generate a Key.
 *
 * @param params The parameters to use to generate a key.
 * @return The JSON object which contains the generated key.
 */
nlohmann::json generateKey(const GenerateKeyParams& params);

/**
 * Generate a Key from a key hex string. The string must be either the DER-encoding of an ED25519 or ECDSAsecp256k1
 * private or public key, or the serialized Key protobuf of a KeyList or ThresholdKey.
 *
 * @param key The hex string from which to get the Key.
 * @return The Key of the input hex string.
 */
std::shared_ptr<Key> getHieroKey(const std::string& key);

} // namespace Hiero::TCK::KeyService

#endif // HIERO_TCK_CPP_KEY_SERVICE_H_
// Filename: src/tck/include/key/params/GenerateKeyParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_GENERATE_KEY_PARAMS_H_
#define HIERO_TCK_CPP_GENERATE_KEY_PARAMS_H_

#include "key/KeyService.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <vector>

namespace Hiero::TCK::KeyService
{
/**
 * Struct to hold the arguments for a `generateKey` JSON-RPC method call.
 */
struct GenerateKeyParams
{
  /**
   *The type of Key to generate.
   */
  KeyType mType = KeyType::KEY_TYPE_SIZE;

  /**
   * For ED25519Public and ECDSAsecp256k1Public types, the DER-encoded hex string private key from which to generate the
   * public key. No value means a random ED25519Public or ECDSAsecp256k1Public will be generated, respectively. For
   * EvmAddress, the DER-encoded hex string of an ECDSAsecp256k1Private or ECDSAsecp256k1Public from which to generate
   * the EVM address. An ECDSAsecp256k1Private will first generate its respective ECDSAsecp256k1Public, and then
   * generate the EVM address from that public key. No value means a random EVM address will be generated.
   */
  std::optional<std::string> mFromKey;

  /**
   * Required for Threshold types. The number of keys that must sign for a threshold key.
   */
  std::optional<int> mThreshold;

  /**
   * Required for List and Threshold types. Specify the keys to be generated and put in the List or Threshold.
   */
  std::optional<std::vector<GenerateKeyParams>> mKeys;
};

} // namespace Hiero::TCK::KeyService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert GenerateKeyParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::KeyService::GenerateKeyParams>
{
  /**
   * Convert a JSON object to a GenerateKeyParams.
   *
   * @param jsonFrom The JSON object with which to fill the GenerateKeyParams.
   * @param params   The GenerateKeyParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::KeyService::GenerateKeyParams& params)
  {
    params.mType =
      Hiero::TCK::KeyService::gStringToKeyType.at(Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "type"));
    params.mFromKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "fromKey");
    params.mThreshold = Hiero::TCK::getOptionalJsonParameter<int>(jsonFrom, "threshold");
    params.mKeys =
      Hiero::TCK::getOptionalJsonParameter<std::vector<Hiero::TCK::KeyService::GenerateKeyParams>>(jsonFrom, "keys");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_GENERATE_KEY_PARAMS_H_
// Filename: src/tck/include/sdk/SdkClient.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_SDK_CLIENT_H_
#define HIERO_TCK_CPP_SDK_CLIENT_H_

#include <Client.h>

#include <chrono>
#include <nlohmann/json_fwd.hpp>

namespace Hiero::TCK::SdkClient
{
/**
 * Forward declarations.
 */
struct ResetParams;
struct SetupParams;

/**
 * The default amount of time the SdkClient should wait for a gRPC request.
 */
constexpr static std::chrono::seconds DEFAULT_TCK_REQUEST_TIMEOUT = std::chrono::seconds(30);

/**
 * Reset the SDK client.
 *
 * @return The JSON response.
 */
nlohmann::json reset(const ResetParams& params);

/**
 * Setup the SDK client.
 *
 * @param operatorAccountId  The ID of the operator account to use.
 * @param operatorPrivateKey The private key of the operator to use.
 * @param nodeIp             The IP of the node with which the Client should communicate.
 * @param nodeAccountId      The ID of the node account running the node with which this Client should communicate.
 * @param mirrorNetworkIp    The IP of the mirror node with which the Client should communicate.
 * @return The JSON response.
 */
nlohmann::json setup(const SetupParams& params);

/**
 * Get the Hiero C++ SDK client this SdkClient is using to execute requests.
 *
 * @return Reference to the Hiero C++ SDK client this SdkClient is using to execute requests.
 */
[[nodiscard]] const Client& getClient();

} // namespace Hiero::TCK::SdkClient

#endif // HIERO_TCK_CPP_SDK_CLIENT_H_
// Filename: src/tck/include/sdk/params/ResetParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_RESET_PARAMS_H_
#define HIERO_TCK_CPP_RESET_PARAMS_H_

#include <nlohmann/json_fwd.hpp>

namespace Hiero::TCK::SdkClient
{
/**
 * Struct to hold the arguments for a `reset` JSON-RPC method call. It takes no arguments
 */
struct ResetParams
{
};

} // namespace Hiero::TCK::SdkClient

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert ResetParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::SdkClient::ResetParams>
{
  /**
   * Convert a JSON object to a ResetParams.
   *
   * @param jsonFrom The JSON object with which to fill the ResetParams.
   * @param params   The ResetParams to fill with the JSON object.
   */
  static void from_json(const json&, Hiero::TCK::SdkClient::ResetParams&) {}
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_RESET_PARAMS_H_
// Filename: src/tck/include/sdk/params/SetupParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_SETUP_PARAMS_H_
#define HIERO_TCK_CPP_SETUP_PARAMS_H_

#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::SdkClient
{
/**
 * Struct to hold the arguments for a `setup` JSON-RPC method call.
 */
struct SetupParams
{
  /**
   * The ID of the operator account.
   */
  std::string operatorAccountId;

  /**
   * The private key of the operator account.
   */
  std::string operatorPrivateKey;

  /**
   * The IP of the consensus node. Required for local network configurations.
   */
  std::optional<std::string> nodeIp;

  /**
   * The ID of the node account. Required for local network configurations.
   */
  std::optional<std::string> nodeAccountId;

  /**
   * The IP of the mirror node. Required for local network configurations.
   */
  std::optional<std::string> mirrorNetworkIp;
};

} // namespace Hiero::TCK::SdkClient

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert SetupParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::SdkClient::SetupParams>
{
  /**
   * Convert a JSON object to a SetupParams.
   *
   * @param jsonFrom The JSON object with which to fill the SetupParams.
   * @param params   The SetupParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::SdkClient::SetupParams& params)
  {
    params.operatorAccountId = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "operatorAccountId");
    params.operatorPrivateKey = Hiero::TCK::getRequiredJsonParameter<std::string>(jsonFrom, "operatorPrivateKey");
    params.nodeIp = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "nodeIp");
    params.nodeAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "nodeAccountId");
    params.mirrorNetworkIp = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "mirrorNetworkIp");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_SETUP_PARAMS_H_
// Filename: src/tck/include/token/CustomFeeSerializer.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_CUSTOM_FEE_SERIALIZER_H_
#define HIERO_TCK_CPP_CUSTOM_FEE_SERIALIZER_H_

#include "json/JsonRpcException.h"

#include <AccountId.h>
#include <CustomFee.h>
#include <CustomFeeBase.h>
#include <CustomFixedFee.h>
#include <CustomFractionalFee.h>
#include <CustomRoyaltyFee.h>
#include <impl/EntityIdHelper.h>

#include <nlohmann/json.hpp>
#include <stdexcept>

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert CustomFee arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<std::shared_ptr<Hiero::CustomFee>>
{
  /**
   * Convert a CustomFee to a JSON object.
   *
   * @param jsonTo The JSON object to fill with the CustomFee.
   * @param fee    The CustomFee with which to fill the JSON object.
   */
  static void to_json(json& jsonTo, const std::shared_ptr<Hiero::CustomFee>& fee)
  {
    jsonTo["feeCollectorAccountId"] = fee->getFeeCollectorAccountId().toString();
    jsonTo["feeCollectorsExempt"] = fee->getAllCollectorsAreExempt();

    if (const std::shared_ptr<Hiero::CustomFixedFee> fixedFee = std::dynamic_pointer_cast<Hiero::CustomFixedFee>(fee);
        fixedFee)
    {
      jsonTo["fixedFee"] = {
        {"amount", fixedFee->getAmount()}
      };
      if (fixedFee->getDenominatingTokenId().has_value())
      {
        jsonTo["fixedFee"]["denominatingTokenId"] = fixedFee->getDenominatingTokenId()->toString();
      }
    }

    else if (const std::shared_ptr<Hiero::CustomFractionalFee> fractionalFee =
               std::dynamic_pointer_cast<Hiero::CustomFractionalFee>(fee);
             fractionalFee)
    {
      std::string assessmentMethod = Hiero::gFeeAssessmentMethodToString.at(fractionalFee->getAssessmentMethod());
      std::transform(assessmentMethod.begin(),
                     assessmentMethod.end(),
                     assessmentMethod.begin(),
                     [](unsigned char c) { return std::tolower(c); });
      jsonTo["fractionalFee"] = {
        {"numerator",         fractionalFee->getNumerator()    },
        { "denominator",      fractionalFee->getDenominator()  },
        { "minimumAmount",    fractionalFee->getMinimumAmount()},
        { "maximumAmount",    fractionalFee->getMaximumAmount()},
        { "assessmentMethod", assessmentMethod                 }
      };
    }

    else
    {
      const std::shared_ptr<Hiero::CustomRoyaltyFee> royaltyFee =
        std::dynamic_pointer_cast<Hiero::CustomRoyaltyFee>(fee);

      jsonTo["royaltyFee"] = {
        {"numerator",    royaltyFee->getNumerator()  },
        { "denominator", royaltyFee->getDenominator()}
      };

      if (royaltyFee->getFallbackFee().has_value())
      {
        jsonTo["royaltyFee"]["fallbackFee"] = {
          {"amount", royaltyFee->getFallbackFee()->getAmount()}
        };
        if (royaltyFee->getFallbackFee()->getDenominatingTokenId().has_value())
        {
          jsonTo["royaltyFee"]["fallbackFee"]["denominatingTokenId"] =
            royaltyFee->getFallbackFee()->getDenominatingTokenId()->toString();
        }
      }
    }
  }

  /**
   * Convert a JSON object to a CustomFee.
   *
   * @param jsonFrom The JSON object with which to fill the CustomFee.
   * @param fee      The CustomFee to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, std::shared_ptr<Hiero::CustomFee>& fee)
  {
    if (!jsonFrom.contains("feeCollectorAccountId"))
    {
      throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                         "invalid parameters: feeCollectorAccountId is REQUIRED.");
    }

    if (!jsonFrom["feeCollectorAccountId"].is_string())
    {
      throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                         "invalid parameters: feeCollectorAccountId MUST be a string.");
    }

    const Hiero::AccountId feeCollectorAccountId =
      Hiero::AccountId::fromString(jsonFrom["feeCollectorAccountId"].get<std::string>());

    if (!jsonFrom.contains("feeCollectorsExempt"))
    {
      throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                         "invalid parameters: feeCollectorsExempt is REQUIRED.");
    }

    if (!jsonFrom["feeCollectorsExempt"].is_boolean())
    {
      throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                         "invalid parameters: feeCollectorsExempt MUST be a boolean.");
    }

    const bool feeCollectorsExempt = jsonFrom["feeCollectorsExempt"].get<bool>();

    if (jsonFrom.contains("fixedFee"))
    {
      auto fixedFee = std::make_shared<Hiero::CustomFixedFee>();
      fixedFee->setFeeCollectorAccountId(feeCollectorAccountId);
      fixedFee->setAllCollectorsAreExempt(feeCollectorsExempt);

      if (!jsonFrom["fixedFee"].contains("amount"))
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: amount is REQUIRED for fixedFee fee types.");
      }

      if (!jsonFrom["fixedFee"]["amount"].is_string())
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: amount MUST be a string.");
      }

      try
      {
        fixedFee->setAmount(
          Hiero::internal::EntityIdHelper::getNum<int64_t>(jsonFrom["fixedFee"]["amount"].get<std::string>()));
      }
      catch (const std::invalid_argument&)
      {
        fixedFee->setAmount(Hiero::internal::EntityIdHelper::getNum(jsonFrom["fixedFee"]["amount"].get<std::string>()));
      }

      if (jsonFrom["fixedFee"].contains("denominatingTokenId"))
      {
        if (!jsonFrom["fixedFee"]["denominatingTokenId"].is_string())
        {
          throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                             "invalid parameters: denominatingTokenId MUST be a string.");
        }

        fixedFee->setDenominatingTokenId(
          Hiero::TokenId::fromString(jsonFrom["fixedFee"]["denominatingTokenId"].get<std::string>()));
      }

      fee = fixedFee;
    }

    else if (jsonFrom.contains("fractionalFee"))
    {
      auto fractionalFee = std::make_shared<Hiero::CustomFractionalFee>();
      fractionalFee->setFeeCollectorAccountId(feeCollectorAccountId);
      fractionalFee->setAllCollectorsAreExempt(feeCollectorsExempt);

      if (!jsonFrom["fractionalFee"].contains("numerator"))
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: numerator is REQUIRED for fractionalFee fee types.");
      }

      if (!jsonFrom["fractionalFee"]["numerator"].is_string())
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: numerator MUST be a string.");
      }

      try
      {
        fractionalFee->setNumerator(
          Hiero::internal::EntityIdHelper::getNum<int64_t>(jsonFrom["fractionalFee"]["numerator"].get<std::string>()));
      }
      catch (const std::invalid_argument&)
      {
        fractionalFee->setNumerator(
          Hiero::internal::EntityIdHelper::getNum(jsonFrom["fractionalFee"]["numerator"].get<std::string>()));
      }

      if (!jsonFrom["fractionalFee"].contains("denominator"))
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: denominator is REQUIRED for fractionalFee fee types.");
      }

      if (!jsonFrom["fractionalFee"]["denominator"].is_string())
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: denominator MUST be a string.");
      }

      try
      {
        fractionalFee->setDenominator(Hiero::internal::EntityIdHelper::getNum<int64_t>(
          jsonFrom["fractionalFee"]["denominator"].get<std::string>()));
      }
      catch (const std::invalid_argument&)
      {
        fractionalFee->setDenominator(
          Hiero::internal::EntityIdHelper::getNum(jsonFrom["fractionalFee"]["denominator"].get<std::string>()));
      }

      if (!jsonFrom["fractionalFee"].contains("minimumAmount"))
      {
        throw Hiero::TCK::JsonRpcException(
          Hiero::TCK::JsonErrorType::INVALID_PARAMS,
          "invalid parameters: minimumAmount is REQUIRED for fractionalFee fee types.");
      }

      if (!jsonFrom["fractionalFee"]["minimumAmount"].is_string())
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: minimumAmount MUST be a string.");
      }

      try
      {
        fractionalFee->setMinimumAmount(Hiero::internal::EntityIdHelper::getNum<int64_t>(
          jsonFrom["fractionalFee"]["minimumAmount"].get<std::string>()));
      }
      catch (const std::invalid_argument&)
      {
        fractionalFee->setMinimumAmount(
          Hiero::internal::EntityIdHelper::getNum(jsonFrom["fractionalFee"]["minimumAmount"].get<std::string>()));
      }

      if (!jsonFrom["fractionalFee"].contains("maximumAmount"))
      {
        throw Hiero::TCK::JsonRpcException(
          Hiero::TCK::JsonErrorType::INVALID_PARAMS,
          "invalid parameters: maximumAmount is REQUIRED for fractionalFee fee types.");
      }

      if (!jsonFrom["fractionalFee"]["maximumAmount"].is_string())
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: maximumAmount MUST be a string.");
      }

      try
      {
        fractionalFee->setMaximumAmount(Hiero::internal::EntityIdHelper::getNum<int64_t>(
          jsonFrom["fractionalFee"]["maximumAmount"].get<std::string>()));
      }
      catch (const std::invalid_argument&)
      {
        fractionalFee->setMaximumAmount(
          Hiero::internal::EntityIdHelper::getNum(jsonFrom["fractionalFee"]["maximumAmount"].get<std::string>()));
      }

      if (!jsonFrom["fractionalFee"].contains("assessmentMethod"))
      {
        throw Hiero::TCK::JsonRpcException(
          Hiero::TCK::JsonErrorType::INVALID_PARAMS,
          "invalid parameters: assessmentMethod is REQUIRED for fractionalFee fee types.");
      }

      if (!jsonFrom["fractionalFee"]["assessmentMethod"].is_string())
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: assessmentMethod MUST be a string.");
      }

      std::string assessmentMethod = jsonFrom["fractionalFee"]["assessmentMethod"].get<std::string>();
      std::transform(assessmentMethod.begin(),
                     assessmentMethod.end(),
                     assessmentMethod.begin(),
                     [](unsigned char c) { return std::toupper(c); });
      fractionalFee->setAssessmentMethod(Hiero::gStringToFeeAssessmentMethod.at(assessmentMethod));

      fee = fractionalFee;
    }

    else if (jsonFrom.contains("royaltyFee"))
    {
      auto royaltyFee = std::make_shared<Hiero::CustomRoyaltyFee>();
      royaltyFee->setFeeCollectorAccountId(feeCollectorAccountId);
      royaltyFee->setAllCollectorsAreExempt(feeCollectorsExempt);

      if (!jsonFrom["royaltyFee"].contains("numerator"))
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: numerator is REQUIRED for royaltyFee fee types.");
      }

      if (!jsonFrom["royaltyFee"]["numerator"].is_string())
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: numerator MUST be a string.");
      }

      try
      {
        royaltyFee->setNumerator(
          Hiero::internal::EntityIdHelper::getNum<int64_t>(jsonFrom["royaltyFee"]["numerator"].get<std::string>()));
      }
      catch (const std::invalid_argument&)
      {
        royaltyFee->setNumerator(
          Hiero::internal::EntityIdHelper::getNum(jsonFrom["royaltyFee"]["numerator"].get<std::string>()));
      }

      if (!jsonFrom["royaltyFee"].contains("denominator"))
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: denominator is REQUIRED for royaltyFee fee types.");
      }

      if (!jsonFrom["royaltyFee"]["denominator"].is_string())
      {
        throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                           "invalid parameters: denominator MUST be a string.");
      }

      try
      {
        royaltyFee->setDenominator(
          Hiero::internal::EntityIdHelper::getNum<int64_t>(jsonFrom["royaltyFee"]["denominator"].get<std::string>()));
      }
      catch (const std::invalid_argument&)
      {
        royaltyFee->setDenominator(
          Hiero::internal::EntityIdHelper::getNum(jsonFrom["royaltyFee"]["denominator"].get<std::string>()));
      }

      if (jsonFrom["royaltyFee"].contains("fallbackFee"))
      {
        Hiero::CustomFixedFee fallbackFee;

        if (!jsonFrom["royaltyFee"]["fallbackFee"].contains("amount"))
        {
          throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                             "invalid parameters: amount is REQUIRED for a fallback fee.");
        }

        if (!jsonFrom["royaltyFee"]["fallbackFee"]["amount"].is_string())
        {
          throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                             "invalid parameters: amount MUST be a string.");
        }

        try
        {
          fallbackFee.setAmount(Hiero::internal::EntityIdHelper::getNum(
            jsonFrom["royaltyFee"]["fallbackFee"]["amount"].get<std::string>()));
        }
        catch (const std::invalid_argument&)
        {
          fallbackFee.setAmount(Hiero::internal::EntityIdHelper::getNum<int64_t>(
            jsonFrom["royaltyFee"]["fallbackFee"]["amount"].get<std::string>()));
        }

        if (jsonFrom["royaltyFee"]["fallbackFee"].contains("denominatingTokenId"))
        {
          if (!jsonFrom["royaltyFee"]["fallbackFee"]["denominatingTokenId"].is_string())
          {
            throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                               "invalid parameters: denominatingTokenId MUST be a string.");
          }

          fallbackFee.setDenominatingTokenId(Hiero::TokenId::fromString(
            jsonFrom["royaltyFee"]["fallbackFee"]["denominatingTokenId"].get<std::string>()));
        }

        royaltyFee->setFallbackFee(fallbackFee);
      }

      fee = royaltyFee;
    }

    else
    {
      throw Hiero::TCK::JsonRpcException(Hiero::TCK::JsonErrorType::INVALID_PARAMS,
                                         "invalid parameters: fee MUST contain one of fixedFee, fractionalFee, or "
                                         "royaltyFee.");
    }
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_CUSTOM_FEE_PARAMS_H_
// Filename: src/tck/include/token/TokenService.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_TOKEN_SERVICE_H_
#define HIERO_TCK_CPP_TOKEN_SERVICE_H_

#include <nlohmann/json_fwd.hpp>

namespace Hiero::TCK::TokenService
{
/**
 * Forward declarations.
 */
struct AssociateTokenParams;
struct BurnTokenParams;
struct CreateTokenParams;
struct DeleteTokenParams;
struct DissociateTokenParams;
struct FreezeTokenParams;
struct GrantTokenKycParams;
struct MintTokenParams;
struct PauseTokenParams;
struct RevokeTokenKycParams;
struct UnfreezeTokenParams;
struct UnpauseTokenParams;
struct UpdateTokenFeeScheduleParams;
struct UpdateTokenParams;

/**
 * Associate an account with tokens.
 *
 * @param params The parameters to use to associate the account and tokens.
 * @return A JSON response containing the status of the token association.
 */
nlohmann::json associateToken(const AssociateTokenParams& params);

/**
 * Burn a token.
 *
 * @param params The parameters to use to burn a token.
 * @return A JSON response containing the status of the token burn and the new total supply of the token.
 */
nlohmann::json burnToken(const BurnTokenParams& params);

/**
 * Create a token.
 *
 * @param params The parameters to use to create a token.
 * @return A JSON response containing the created token ID and the status of the token creation.
 */
nlohmann::json createToken(const CreateTokenParams& params);

/**
 * Delete a token.
 *
 * @param params The parameters to use to delete a token.
 * @return A JSON response containing the status of the token deletion.
 */
nlohmann::json deleteToken(const DeleteTokenParams& params);

/**
 * Dissociate an account from tokens.
 *
 * @param params The parameters to use to dissociate the account.
 * @return A JSON response containing the status of the account dissociation.
 */
nlohmann::json dissociateToken(const DissociateTokenParams& params);

/**
 * Freeze a token on an account.
 *
 * @params The parameters to use to freeze a token.
 * @return A JSON response containing the status of the token freeze.
 */
nlohmann::json freezeToken(const FreezeTokenParams& params);

/**
 * Grant KYC of a token to an account.
 *
 * @param params The parameters to use to grant KYC.
 * @return A JSON response containing the status of the token KYC grant.
 */
nlohmann::json grantTokenKyc(const GrantTokenKycParams& params);

/**
 * Mint a token.
 *
 * @param params The parameters to use to mint a token.
 * @return A JSON response containing the status of the token mint.
 */
nlohmann::json mintToken(const MintTokenParams& params);

/**
 * Pause a token.
 *
 * @param params The parameters to use to pause a token.
 * @return A JSON response containing the status of the token pause.
 */
nlohmann::json pauseToken(const PauseTokenParams& params);

/**
 * Revoke KYC of a token from an account.
 *
 * @param params The parameters to use to revoke KYC.
 * @return A JSON response containing the status of the token KYC revoke.
 */
nlohmann::json revokeTokenKyc(const RevokeTokenKycParams& params);

/**
 * Unfreeze a token from an account.
 *
 * @params The parameters to use to unfreeze a token.
 * @return A JSON response containing the status of the token unfreeze.
 */
nlohmann::json unfreezeToken(const UnfreezeTokenParams& params);

/**
 * Unpause a token.
 *
 * @param params The parameters to use to unpause a token.
 * @return A JSON response containing the status of the token unpause.
 */
nlohmann::json unpauseToken(const UnpauseTokenParams& params);

/**
 * Update the fee schedule of a token.
 *
 * @param params The parameters to use to update a token's fee schedule.
 * @return A JSON response containing the status of the fee schedule update.
 */
nlohmann::json updateTokenFeeSchedule(const UpdateTokenFeeScheduleParams& params);

/**
 * Update a token.
 *
 * @param params The parameters to use to update a token.
 * @ return A JSON response containing the status of the token update.
 */
nlohmann::json updateToken(const UpdateTokenParams& params);

} // namespace Hiero::TCK::TokenService

#endif // HIERO_TCK_CPP_TOKEN_SERVICE_H_
// Filename: src/tck/include/token/params/AssociateTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_ASSOCIATE_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_ASSOCIATE_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>
#include <vector>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for an `associateToken` JSON-RPC method call.
 */
struct AssociateTokenParams
{
  /**
   * The ID of the account with which to associate the tokens.
   */
  std::optional<std::string> mAccountId;

  /**
   * The IDs of the tokens to associate.
   */
  std::optional<std::vector<std::string>> mTokenIds;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert AssociateTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::AssociateTokenParams>
{
  /**
   * Convert a JSON object to a AssociateTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the AssociateTokenParams.
   * @param params   The AssociateTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::AssociateTokenParams& params)
  {
    params.mAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "accountId");
    params.mTokenIds = Hiero::TCK::getOptionalJsonParameter<std::vector<std::string>>(jsonFrom, "tokenIds");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_ASSOCIATE_TOKEN_PARAMS_H_
// Filename: src/tck/include/token/params/BurnTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_BURN_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_BURN_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `burnToken` JSON-RPC method call.
 */
struct BurnTokenParams
{
  /**
   * The ID of the token to burn.
   */
  std::optional<std::string> mTokenId;

  /**
   * The amount of fungible tokens to burn.
   */
  std::optional<std::string> mAmount;

  /**
   * The serial numbers of the NFTs to burn.
   */
  std::optional<std::vector<std::string>> mSerialNumbers;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hedera::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert BurnTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::BurnTokenParams>
{
  /**
   * Convert a JSON object to a BurnTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the BurnTokenParams.
   * @param params   The BurnTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::BurnTokenParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mAmount = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "amount");
    params.mSerialNumbers = Hiero::TCK::getOptionalJsonParameter<std::vector<std::string>>(jsonFrom, "serialNumbers");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_BURN_TOKEN_PARAMS_H_
// Filename: src/tck/include/token/params/CreateTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_CREATE_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_CREATE_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "token/CustomFeeSerializer.h"
#include "json/JsonUtils.h"

#include <CustomFee.h>

#include <cstdint>
#include <memory>
#include <nlohmann/json.hpp>
#include <optional>
#include <string>
#include <vector>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `createToken` JSON-RPC method call.
 */
struct CreateTokenParams
{
  /**
   * The desired name of the token.
   */
  std::optional<std::string> mName;

  /**
   * The desired symbol of the new token.
   */
  std::optional<std::string> mSymbol;

  /**
   * The number of decimal places by which the new token will be divisible.
   */
  std::optional<uint32_t> mDecimals;

  /**
   * The number of tokens to put into circulation upon creation.
   */
  std::optional<std::string> mInitialSupply;

  /**
   * The ID of the account which will act as the new token's treasury and will receive the specified initial supply of
   * the new token.
   */
  std::optional<std::string> mTreasuryAccountId;

  /**
   * The key which can perform update/delete operations on the new token. DER-encoded hex string representation for
   * private or public keys. Keylists and threshold keys are the hex of the serialized protobuf bytes..
   */
  std::optional<std::string> mAdminKey;

  /**
   * The key which can grant/revoke KYC on an account for transactions of the new token. DER-encoded hex string
   * representation for private or public keys. Keylists and threshold keys are the hex of the serialized protobuf
   * bytes.
   */
  std::optional<std::string> mKycKey;

  /**
   * The key which can freeze/unfreeze an account for transactions of the new token. DER-encoded hex string
   * representation for private or public keys. Keylists and threshold keys are the hex of the serialized protobuf
   * bytes.
   */
  std::optional<std::string> mFreezeKey;

  /**
   * The key which can wipe the balance of the new token from an account. DER-encoded hex string representation for
   * private or public keys. Keylists and threshold keys are the hex of the serialized protobuf bytes.
   */
  std::optional<std::string> mWipeKey;

  /**
   * The key which can change the supply of the new token. DER-encoded hex string representation for private or public
   * keys. Keylists and threshold keys are the hex of the serialized protobuf bytes.
   */
  std::optional<std::string> mSupplyKey;

  /**
   * Should accounts initially be frozen with respect to the new token?
   */
  std::optional<bool> mFreezeDefault;

  /**
   * The time at which the new token should expire. Epoch time in seconds.
   */
  std::optional<std::string> mExpirationTime;

  /**
   * The ID of the account that should be charged to renew the new token's expiration.
   */
  std::optional<std::string> mAutoRenewAccountId;

  /**
   * The interval at which the auto renew account will be charged to extend the new token's expiration. Units of
   * seconds.
   */
  std::optional<std::string> mAutoRenewPeriod;

  /**
   * The memo associated with the token.
   */
  std::optional<std::string> mMemo;

  /**
   * The type of the new token. MUST be one of "ft" (fungible token) or "nft" (non-fungible token).
   */
  std::optional<std::string> mTokenType;

  /**
   * The supply type of the new token. MUST be one of "infinite" or "finite".
   */
  std::optional<std::string> mSupplyType;

  /**
   * The maximum amount of the new token that can be in circulation (for fungible types) or minted (for NFTs).
   */
  std::optional<std::string> mMaxSupply;

  /**
   * The key which can change the new token's fee schedule. DER-encoded hex string representation for private or public
   * keys. Keylists and threshold keys are the hex of the serialized protobuf bytes.
   */
  std::optional<std::string> mFeeScheduleKey;

  /**
   * The fees to be assessed during a transfer of the new token.
   */
  std::optional<std::vector<std::shared_ptr<CustomFee>>> mCustomFees;

  /**
   * The key which can pause/unpause the new token. DER-encoded hex string representation for private or public keys.
   * Keylists and threshold keys are the hex of the serialized protobuf bytes.
   */
  std::optional<std::string> mPauseKey;

  /**
   * The metadata of the new token. Hex-encoded bytes of the metadata.
   */
  std::optional<std::string> mMetadata;

  /**
   * The key which can change the metadata of the new token and/or individual NFTs of the new token class. DER-encoded
   * hex string representation for private or public keys. Keylists and threshold keys are the hex of the serialized
   * protobuf bytes.
   */
  std::optional<std::string> mMetadataKey;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert CreateTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::CreateTokenParams>
{
  /**
   * Convert a JSON object to a CreateTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the CreateTokenParams.
   * @param params   The CreateTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::CreateTokenParams& params)
  {
    params.mName = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "name");
    params.mSymbol = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "symbol");
    params.mDecimals = Hiero::TCK::getOptionalJsonParameter<uint32_t>(jsonFrom, "decimals");
    params.mInitialSupply = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "initialSupply");
    params.mTreasuryAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "treasuryAccountId");
    params.mAdminKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "adminKey");
    params.mKycKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "kycKey");
    params.mFreezeKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "freezeKey");
    params.mWipeKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "wipeKey");
    params.mSupplyKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "supplyKey");
    params.mFreezeDefault = Hiero::TCK::getOptionalJsonParameter<bool>(jsonFrom, "freezeDefault");
    params.mExpirationTime = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "expirationTime");
    params.mAutoRenewAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "autoRenewAccountId");
    params.mAutoRenewPeriod = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "autoRenewPeriod");
    params.mMemo = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "memo");
    params.mTokenType = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenType");
    params.mSupplyType = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "supplyType");
    params.mMaxSupply = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "maxSupply");
    params.mFeeScheduleKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "feeScheduleKey");
    params.mCustomFees =
      Hiero::TCK::getOptionalJsonParameter<std::vector<std::shared_ptr<Hiero::CustomFee>>>(jsonFrom, "customFees");
    params.mPauseKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "pauseKey");
    params.mMetadata = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "metadata");
    params.mMetadataKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "metadataKey");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_CREATE_TOKEN_PARAMS_H_
// Filename: src/tck/include/token/params/DeleteTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_DELETE_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_DELETE_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `deleteToken` JSON-RPC method call.
 */
struct DeleteTokenParams
{
  /**
   * The ID of the token to delete.
   */
  std::optional<std::string> mTokenId;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert DeleteTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::DeleteTokenParams>
{
  /**
   * Convert a JSON object to a DeleteTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the DeleteTokenParams.
   * @param params   The DeleteTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::DeleteTokenParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_DELETE_TOKEN_PARAMS_H_
// Filename: src/tck/include/token/params/DissociateTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_DISSOCIATE_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_DISSOCIATE_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `dissociateToken` JSON-RPC method call.
 */
struct DissociateTokenParams
{
  /**
   * The ID of the account from which to dissociate the token.
   */
  std::optional<std::string> mAccountId;

  /**
   * The IDs of the tokens to dissociate.
   */
  std::optional<std::vector<std::string>> mTokenIds;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert DissociateTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::DissociateTokenParams>
{
  /**
   * Convert a JSON object to a DissociateTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the DissociateTokenParams.
   * @param params   The DissociateTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::DissociateTokenParams& params)
  {
    params.mAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "accountId");
    params.mTokenIds = Hiero::TCK::getOptionalJsonParameter<std::vector<std::string>>(jsonFrom, "tokenIds");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_DISSOCIATE_TOKEN_PARAMS_H_
// Filename: src/tck/include/token/params/FreezeTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_FREEZE_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_FREEZE_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `freezeToken` JSON-RPC method call.
 */
struct FreezeTokenParams
{
  /**
   * The ID of the token to freeze.
   */
  std::optional<std::string> mTokenId;

  /**
   * The ID of the account to freeze.
   */
  std::optional<std::string> mAccountId;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hedera::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert FreezeTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::FreezeTokenParams>
{
  /**
   * Convert a JSON object to a FreezeTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the FreezeTokenParams.
   * @param params   The FreezeTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::FreezeTokenParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "accountId");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_FREEZE_TOKEN_PARAMS_H_
// Filename: src/tck/include/token/params/GrantTokenKycParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_GRANT_TOKEN_KYC_PARAMS_H_
#define HIERO_TCK_CPP_GRANT_TOKEN_KYC_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `grantTokenKyc` JSON-RPC method call.
 */
struct GrantTokenKycParams
{
  /**
   * The ID of the token of which to grant KYC.
   */
  std::optional<std::string> mTokenId;

  /**
   * The ID of the account to which to grant KYC.
   */
  std::optional<std::string> mAccountId;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hedera::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert GrantTokenKycParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::GrantTokenKycParams>
{
  /**
   * Convert a JSON object to a GrantTokenKycParams.
   *
   * @param jsonFrom The JSON object with which to fill the GrantTokenKycParams.
   * @param params   The GrantTokenKycParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::GrantTokenKycParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "accountId");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_GRANT_TOKEN_KYC_PARAMS_H_// Filename: src/tck/include/token/params/MintTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_MINT_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_MINT_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `mintToken` JSON-RPC method call.
 */
struct MintTokenParams
{
  /**
   * The ID of the token to mint.
   */
  std::optional<std::string> mTokenId;

  /**
   * The amount of fungible tokens to mint.
   */
  std::optional<std::string> mAmount;

  /**
   * The metadata for the NFTs to mint, as hex strings.
   */
  std::optional<std::vector<std::string>> mMetadata;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hedera::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert MintTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::MintTokenParams>
{
  /**
   * Convert a JSON object to a MintTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the MintTokenParams.
   * @param params   The MintTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::MintTokenParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mAmount = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "amount");
    params.mMetadata = Hiero::TCK::getOptionalJsonParameter<std::vector<std::string>>(jsonFrom, "metadata");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_MINT_TOKEN_PARAMS_H_
// Filename: src/tck/include/token/params/PauseTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_PAUSE_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_PAUSE_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `pauseToken` JSON-RPC method call.
 */
struct PauseTokenParams
{
  /**
   * The ID of the token to pause.
   */
  std::optional<std::string> mTokenId;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert PauseTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::PauseTokenParams>
{
  /**
   * Convert a JSON object to a PauseTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the PauseTokenParams.
   * @param params   The PauseTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::PauseTokenParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_PAUSE_TOKEN_PARAMS_H_
// Filename: src/tck/include/token/params/RevokeTokenKycParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_REVOKE_TOKEN_KYC_PARAMS_H_
#define HIERO_TCK_CPP_REVOKE_TOKEN_KYC_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `revokeTokenKyc` JSON-RPC method call.
 */
struct RevokeTokenKycParams
{
  /**
   * The ID of the token of which to grant KYC.
   */
  std::optional<std::string> mTokenId;

  /**
   * The ID of the account to which to grant KYC.
   */
  std::optional<std::string> mAccountId;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hedera::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert RevokeTokenKycParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::RevokeTokenKycParams>
{
  /**
   * Convert a JSON object to a RevokeTokenKycParams.
   *
   * @param jsonFrom The JSON object with which to fill the RevokeTokenKycParams.
   * @param params   The RevokeTokenKycParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::RevokeTokenKycParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "accountId");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_REVOKE_TOKEN_KYC_PARAMS_H_// Filename: src/tck/include/token/params/UnfreezeTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_UNFREEZE_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_UNFREEZE_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `unfreezeToken` JSON-RPC method call.
 */
struct UnfreezeTokenParams
{
  /**
   * The ID of the token to freeze.
   */
  std::optional<std::string> mTokenId;

  /**
   * The ID of the account to freeze.
   */
  std::optional<std::string> mAccountId;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hedera::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert UnfreezeTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::UnfreezeTokenParams>
{
  /**
   * Convert a JSON object to a UnfreezeTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the UnfreezeTokenParams.
   * @param params   The UnfreezeTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::UnfreezeTokenParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "accountId");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_UNFREEZE_TOKEN_PARAMS_H_
// Filename: src/tck/include/token/params/UnpauseTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_UNPAUSE_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_UNPAUSE_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `unpauseToken` JSON-RPC method call.
 */
struct UnpauseTokenParams
{
  /**
   * The ID of the token to unpause.
   */
  std::optional<std::string> mTokenId;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert UnpauseTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::UnpauseTokenParams>
{
  /**
   * Convert a JSON object to a UnpauseTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the UnpauseTokenParams.
   * @param params   The PauseTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::UnpauseTokenParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_UNPAUSE_TOKEN_PARAMS_H_// Filename: src/tck/include/token/params/UpdateTokenFeeScheduleParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_UPDATE_TOKEN_FEE_SCHEDULE_PARAMS_H_
#define HIERO_TCK_CPP_UPDATE_TOKEN_FEE_SCHEDULE_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "token/CustomFeeSerializer.h"
#include "json/JsonUtils.h"

#include <CustomFee.h>

#include <memory>
#include <nlohmann/json.hpp>
#include <optional>
#include <string>
#include <vector>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `updateTokenFeeSchedule` JSON-RPC method call.
 */
struct UpdateTokenFeeScheduleParams
{
  /**
   * The ID of the token of which to update the fee schedule.
   */
  std::optional<std::string> mTokenId;

  /**
   * The desired new fees to assess for the token.
   */
  std::optional<std::vector<std::shared_ptr<CustomFee>>> mCustomFees;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert UpdateTokenFeeScheduleParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::UpdateTokenFeeScheduleParams>
{
  /**
   * Convert a JSON object to a UpdateTokenFeeScheduleParams.
   *
   * @param jsonFrom The JSON object with which to fill the UpdateTokenFeeScheduleParams.
   * @param params   The UpdateTokenFeeScheduleParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::UpdateTokenFeeScheduleParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mCustomFees =
      Hiero::TCK::getOptionalJsonParameter<std::vector<std::shared_ptr<Hiero::CustomFee>>>(jsonFrom, "customFees");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_UPDATE_TOKEN_FEE_SCHEDULE_PARAMS_H_
// Filename: src/tck/include/token/params/UpdateTokenParams.h
// SPDX-License-Identifier: Apache-2.0
#ifndef HIERO_TCK_CPP_UPDATE_TOKEN_PARAMS_H_
#define HIERO_TCK_CPP_UPDATE_TOKEN_PARAMS_H_

#include "common/CommonTransactionParams.h"
#include "token/CustomFeeSerializer.h"
#include "json/JsonUtils.h"

#include <nlohmann/json.hpp>
#include <optional>
#include <string>

namespace Hiero::TCK::TokenService
{
/**
 * Struct to hold the arguments for a `updateToken` JSON-RPC method call.
 */
struct UpdateTokenParams
{
  /**
   * The ID of the token to update.
   */
  std::optional<std::string> mTokenId;

  /**
   * The desired new symbol of the token.
   */
  std::optional<std::string> mSymbol;

  /**
   * The desired new name of the token.
   */
  std::optional<std::string> mName;

  /**
   * The ID of the desired new treasury account of the token.
   */
  std::optional<std::string> mTreasuryAccountId;

  /**
   * The desired new admin key of the token.
   */
  std::optional<std::string> mAdminKey;

  /**
   * The desired new KYC key of the token.
   */
  std::optional<std::string> mKycKey;

  /**
   * The desired new freeze key of the token.
   */
  std::optional<std::string> mFreezeKey;

  /**
   * The desired new wipe key of the token.
   */
  std::optional<std::string> mWipeKey;

  /**
   * The desired new supply key of the token.
   */
  std::optional<std::string> mSupplyKey;

  /**
   * The ID of the desired account to now pay auto-renewal fees.
   */
  std::optional<std::string> mAutoRenewAccountId;

  /**
   * The desired new interval of time for which to charge the auto-renew account to renew the token.
   *
   */
  std::optional<std::string> mAutoRenewPeriod;

  /**
   * The desired new expiration time of the token.
   */
  std::optional<std::string> mExpirationTime;

  /**
   * The desired new memo of the token.
   */
  std::optional<std::string> mMemo;

  /**
   * The desired new fee schedule key of the token.
   */
  std::optional<std::string> mFeeScheduleKey;

  /**
   * The desired new pause key of the token.
   */
  std::optional<std::string> mPauseKey;

  /**
   * The desired new metadata of the token.
   */
  std::optional<std::string> mMetadata;

  /**
   * The desired new metadata key of the token.
   */
  std::optional<std::string> mMetadataKey;

  /**
   * Any parameters common to all transaction types.
   */
  std::optional<CommonTransactionParams> mCommonTxParams;
};

} // namespace Hiero::TCK::TokenService

namespace nlohmann
{
/**
 * JSON serializer template specialization required to convert UpdateTokenParams arguments properly.
 */
template<>
struct [[maybe_unused]] adl_serializer<Hiero::TCK::TokenService::UpdateTokenParams>
{
  /**
   * Convert a JSON object to a UpdateTokenParams.
   *
   * @param jsonFrom The JSON object with which to fill the UpdateTokenParams.
   * @param params   The UpdateTokenParams to fill with the JSON object.
   */
  static void from_json(const json& jsonFrom, Hiero::TCK::TokenService::UpdateTokenParams& params)
  {
    params.mTokenId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "tokenId");
    params.mSymbol = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "symbol");
    params.mName = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "name");
    params.mTreasuryAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "treasuryAccountId");
    params.mAdminKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "adminKey");
    params.mKycKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "kycKey");
    params.mFreezeKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "freezeKey");
    params.mWipeKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "wipeKey");
    params.mSupplyKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "supplyKey");
    params.mAutoRenewAccountId = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "autoRenewAccountId");
    params.mAutoRenewPeriod = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "autoRenewPeriod");
    params.mExpirationTime = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "expirationTime");
    params.mMemo = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "memo");
    params.mFeeScheduleKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "feeScheduleKey");
    params.mPauseKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "pauseKey");
    params.mMetadata = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "metadata");
    params.mMetadataKey = Hiero::TCK::getOptionalJsonParameter<std::string>(jsonFrom, "metadataKey");
    params.mCommonTxParams =
      Hiero::TCK::getOptionalJsonParameter<Hiero::TCK::CommonTransactionParams>(jsonFrom, "commonTransactionParams");
  }
};

} // namespace nlohmann

#endif // HIERO_TCK_CPP_UPDATE_TOKEN_PARAMS_H_
