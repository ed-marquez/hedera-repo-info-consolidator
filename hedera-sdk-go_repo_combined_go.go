// Filename: account_allowance_adjust_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// Deprecated
type AccountAllowanceAdjustTransaction struct {
	Transaction
	hbarAllowances  []*HbarAllowance
	tokenAllowances []*TokenAllowance
	nftAllowances   []*TokenNftAllowance
}

func NewAccountAllowanceAdjustTransaction() *AccountAllowanceAdjustTransaction {
	tx := AccountAllowanceAdjustTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func (tx *AccountAllowanceAdjustTransaction) _AdjustHbarAllowance(ownerAccountID *AccountID, id AccountID, amount Hbar) *AccountAllowanceAdjustTransaction {
	tx._RequireNotFrozen()
	tx.hbarAllowances = append(tx.hbarAllowances, &HbarAllowance{
		SpenderAccountID: &id,
		OwnerAccountID:   ownerAccountID,
		Amount:           amount.AsTinybar(),
	})

	return tx
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) AddHbarAllowance(id AccountID, amount Hbar) *AccountAllowanceAdjustTransaction {
	return tx._AdjustHbarAllowance(nil, id, amount)
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) GrantHbarAllowance(ownerAccountID AccountID, id AccountID, amount Hbar) *AccountAllowanceAdjustTransaction {
	return tx._AdjustHbarAllowance(&ownerAccountID, id, amount)
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) RevokeHbarAllowance(ownerAccountID AccountID, id AccountID, amount Hbar) *AccountAllowanceAdjustTransaction {
	return tx._AdjustHbarAllowance(&ownerAccountID, id, amount.Negated())
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) GetHbarAllowances() []*HbarAllowance {
	return tx.hbarAllowances
}

func (tx *AccountAllowanceAdjustTransaction) _AdjustTokenAllowance(tokenID TokenID, ownerAccountID *AccountID, accountID AccountID, amount int64) *AccountAllowanceAdjustTransaction {
	tx._RequireNotFrozen()
	tokenApproval := TokenAllowance{
		TokenID:          &tokenID,
		SpenderAccountID: &accountID,
		OwnerAccountID:   ownerAccountID,
		Amount:           amount,
	}

	tx.tokenAllowances = append(tx.tokenAllowances, &tokenApproval)
	return tx
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) AddTokenAllowance(tokenID TokenID, accountID AccountID, amount int64) *AccountAllowanceAdjustTransaction {
	return tx._AdjustTokenAllowance(tokenID, nil, accountID, amount)
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) GrantTokenAllowance(tokenID TokenID, ownerAccountID AccountID, accountID AccountID, amount int64) *AccountAllowanceAdjustTransaction {
	return tx._AdjustTokenAllowance(tokenID, &ownerAccountID, accountID, amount)
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) RevokeTokenAllowance(tokenID TokenID, ownerAccountID AccountID, accountID AccountID, amount uint64) *AccountAllowanceAdjustTransaction {
	return tx._AdjustTokenAllowance(tokenID, &ownerAccountID, accountID, -int64(amount))
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) GetTokenAllowances() []*TokenAllowance {
	return tx.tokenAllowances
}

func (tx *AccountAllowanceAdjustTransaction) _AdjustTokenNftAllowance(nftID NftID, ownerAccountID *AccountID, accountID AccountID) *AccountAllowanceAdjustTransaction {
	tx._RequireNotFrozen()

	for _, t := range tx.nftAllowances {
		if t.TokenID.String() == nftID.TokenID.String() {
			if t.SpenderAccountID.String() == accountID.String() {
				b := false
				for _, s := range t.SerialNumbers {
					if s == nftID.SerialNumber {
						b = true
					}
				}
				if !b {
					t.SerialNumbers = append(t.SerialNumbers, nftID.SerialNumber)
				}
				return tx
			}
		}
	}

	tx.nftAllowances = append(tx.nftAllowances, &TokenNftAllowance{
		TokenID:          &nftID.TokenID,
		SpenderAccountID: &accountID,
		OwnerAccountID:   ownerAccountID,
		SerialNumbers:    []int64{nftID.SerialNumber},
		AllSerials:       false,
	})
	return tx
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) AddTokenNftAllowance(nftID NftID, accountID AccountID) *AccountAllowanceAdjustTransaction {
	return tx._AdjustTokenNftAllowance(nftID, nil, accountID)
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) GrantTokenNftAllowance(nftID NftID, ownerAccountID AccountID, accountID AccountID) *AccountAllowanceAdjustTransaction {
	return tx._AdjustTokenNftAllowance(nftID, &ownerAccountID, accountID)
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) RevokeTokenNftAllowance(nftID NftID, ownerAccountID AccountID, accountID AccountID) *AccountAllowanceAdjustTransaction {
	return tx._AdjustTokenNftAllowance(nftID, &ownerAccountID, accountID)
}

func (tx *AccountAllowanceAdjustTransaction) _AdjustTokenNftAllowanceAllSerials(tokenID TokenID, ownerAccountID *AccountID, spenderAccount AccountID, allSerials bool) *AccountAllowanceAdjustTransaction {
	for _, t := range tx.nftAllowances {
		if t.TokenID.String() == tokenID.String() {
			if t.SpenderAccountID.String() == spenderAccount.String() {
				t.SerialNumbers = []int64{}
				t.AllSerials = true
				return tx
			}
		}
	}

	tx.nftAllowances = append(tx.nftAllowances, &TokenNftAllowance{
		TokenID:          &tokenID,
		SpenderAccountID: &spenderAccount,
		OwnerAccountID:   ownerAccountID,
		SerialNumbers:    []int64{},
		AllSerials:       allSerials,
	})
	return tx
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) AddAllTokenNftAllowance(tokenID TokenID, spenderAccount AccountID) *AccountAllowanceAdjustTransaction {
	return tx._AdjustTokenNftAllowanceAllSerials(tokenID, nil, spenderAccount, true)
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) GrantTokenNftAllowanceAllSerials(ownerAccountID AccountID, tokenID TokenID, spenderAccount AccountID) *AccountAllowanceAdjustTransaction {
	return tx._AdjustTokenNftAllowanceAllSerials(tokenID, &ownerAccountID, spenderAccount, true)
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) RevokeTokenNftAllowanceAllSerials(ownerAccountID AccountID, tokenID TokenID, spenderAccount AccountID) *AccountAllowanceAdjustTransaction {
	return tx._AdjustTokenNftAllowanceAllSerials(tokenID, &ownerAccountID, spenderAccount, false)
}

// Deprecated
func (tx *AccountAllowanceAdjustTransaction) GetTokenNftAllowances() []*TokenNftAllowance {
	return tx.nftAllowances
}

func (tx *AccountAllowanceAdjustTransaction) Sign(
	privateKey PrivateKey,
) *AccountAllowanceAdjustTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

func (tx *AccountAllowanceAdjustTransaction) SignWithOperator(
	client *Client,
) (*AccountAllowanceAdjustTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

func (tx *AccountAllowanceAdjustTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *AccountAllowanceAdjustTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

func (tx *AccountAllowanceAdjustTransaction) Freeze() (*AccountAllowanceAdjustTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *AccountAllowanceAdjustTransaction) FreezeWith(client *Client) (*AccountAllowanceAdjustTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this AccountAllowanceAdjustTransaction.
func (tx *AccountAllowanceAdjustTransaction) SetMaxTransactionFee(fee Hbar) *AccountAllowanceAdjustTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *AccountAllowanceAdjustTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *AccountAllowanceAdjustTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this AccountAllowanceAdjustTransaction.
func (tx *AccountAllowanceAdjustTransaction) SetTransactionMemo(memo string) *AccountAllowanceAdjustTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this AccountAllowanceAdjustTransaction.
func (tx *AccountAllowanceAdjustTransaction) SetTransactionValidDuration(duration time.Duration) *AccountAllowanceAdjustTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *AccountAllowanceAdjustTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this AccountAllowanceAdjustTransaction.
func (tx *AccountAllowanceAdjustTransaction) SetTransactionID(transactionID TransactionID) *AccountAllowanceAdjustTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountAllowanceAdjustTransaction.
func (tx *AccountAllowanceAdjustTransaction) SetNodeAccountIDs(nodeID []AccountID) *AccountAllowanceAdjustTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

func (tx *AccountAllowanceAdjustTransaction) SetMaxRetry(count int) *AccountAllowanceAdjustTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

func (tx *AccountAllowanceAdjustTransaction) AddSignature(publicKey PublicKey, signature []byte) *AccountAllowanceAdjustTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

func (tx *AccountAllowanceAdjustTransaction) SetMaxBackoff(max time.Duration) *AccountAllowanceAdjustTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

func (tx *AccountAllowanceAdjustTransaction) SetMinBackoff(min time.Duration) *AccountAllowanceAdjustTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

// ----------- Overridden functions ----------------

func (tx *AccountAllowanceAdjustTransaction) getName() string {
	return "AccountAllowanceAdjustTransaction"
}

func (tx *AccountAllowanceAdjustTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	for _, ap := range tx.hbarAllowances {
		if ap.SpenderAccountID != nil {
			if err := ap.SpenderAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.OwnerAccountID != nil {
			if err := ap.OwnerAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	for _, ap := range tx.tokenAllowances {
		if ap.SpenderAccountID != nil {
			if err := ap.SpenderAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.TokenID != nil {
			if err := ap.TokenID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.OwnerAccountID != nil {
			if err := ap.OwnerAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	for _, ap := range tx.nftAllowances {
		if ap.SpenderAccountID != nil {
			if err := ap.SpenderAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.TokenID != nil {
			if err := ap.TokenID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.OwnerAccountID != nil {
			if err := ap.OwnerAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	return nil
}

func (tx *AccountAllowanceAdjustTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{}
}

func (tx *AccountAllowanceAdjustTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{}, nil
}

func (tx *AccountAllowanceAdjustTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: account_allowance_adjust_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

import (
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

func TestUnitAccountAllowanceAdjustTransactionGet(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerate()
	require.NoError(t, err)
	key2, err := PrivateKeyGenerate()
	require.NoError(t, err)

	nodeAccountIDs := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 123})
	tokenID := TokenID{Token: 3}
	NftID := NftID{tokenID, 1}
	tx, err := NewAccountAllowanceAdjustTransaction().
		AddHbarAllowance(nodeAccountIDs[0], HbarFromTinybar(1)).
		AddTokenAllowance(tokenID, nodeAccountIDs[0], 1).
		AddTokenNftAllowance(NftID, nodeAccountIDs[0]).
		SetTransactionID(transactionID).SetNodeAccountIDs(nodeAccountIDs).
		SetMaxTransactionFee(HbarFromTinybar(100)).SetRegenerateTransactionID(true).
		SetTransactionMemo("go sdk unit test").SetTransactionValidDuration(time.Second * 120).
		SetMaxRetry(1).SetMaxBackoff(time.Second * 120).SetMinBackoff(time.Second * 1).
		Freeze()
	sign, err := key2.SignTransaction(&tx.Transaction)
	require.NoError(t, err)
	tx.AddSignature(key.PublicKey(), sign)
	tx.AddSignature(key2.PublicKey(), sign)

	expectedHbarAllowances := []*HbarAllowance{
		{
			SpenderAccountID: &nodeAccountIDs[0],
			OwnerAccountID:   nil,
			Amount:           1,
		},
	}

	expectedTokenAllowances := []*TokenAllowance{
		{
			TokenID:          &tokenID,
			SpenderAccountID: &nodeAccountIDs[0],
			OwnerAccountID:   nil,
			Amount:           1,
		},
	}

	expectedTokenNftAllowances := []*TokenNftAllowance{
		{
			TokenID:          &tokenID,
			SpenderAccountID: &nodeAccountIDs[0],
			OwnerAccountID:   nil,
			SerialNumbers:    []int64{1},
			AllSerials:       false,
		},
	}

	require.NoError(t, err)
	require.Equal(t, expectedHbarAllowances, tx.GetHbarAllowances())
	require.Equal(t, expectedTokenAllowances, tx.GetTokenAllowances())
	require.Equal(t, expectedTokenNftAllowances, tx.GetTokenNftAllowances())
	require.Equal(t, transactionID, tx.GetTransactionID())
	require.Equal(t, nodeAccountIDs, tx.GetNodeAccountIDs())
	require.Equal(t, HbarFromTinybar(100), tx.GetMaxTransactionFee())
	require.Equal(t, true, tx.GetRegenerateTransactionID())
	require.Equal(t, "go sdk unit test", tx.GetTransactionMemo())
	require.Equal(t, time.Second*120, tx.GetTransactionValidDuration())
	require.Equal(t, 1, tx.GetMaxRetry())
	require.Equal(t, time.Second*120, tx.GetMaxBackoff())
	require.Equal(t, time.Second*1, tx.GetMinBackoff())
	require.Equal(t, fmt.Sprint("AccountAllowanceAdjustTransaction"), tx.getName())
}

func TestUnitAccountAllowanceAdjustTransactionGrantHbarAllowance(t *testing.T) {
	t.Parallel()

	tx := NewAccountAllowanceAdjustTransaction().
		GrantHbarAllowance(AccountID{Account: 3}, AccountID{Account: 4}, HbarFromTinybar(1))
	expectedHbarAllowances := []*HbarAllowance{
		{
			SpenderAccountID: &AccountID{Account: 4},
			OwnerAccountID:   &AccountID{Account: 3},
			Amount:           1,
		},
	}
	require.Equal(t, expectedHbarAllowances, tx.GetHbarAllowances())
}
func TestUnitAccountAllowanceAdjustTransactionRevokeHbarAllowance(t *testing.T) {
	t.Parallel()

	tx := NewAccountAllowanceAdjustTransaction().
		RevokeHbarAllowance(AccountID{Account: 3}, AccountID{Account: 4}, HbarFromTinybar(1))
	expectedHbarAllowances := []*HbarAllowance{
		{
			SpenderAccountID: &AccountID{Account: 4},
			OwnerAccountID:   &AccountID{Account: 3},
			Amount:           -1,
		},
	}
	require.Equal(t, expectedHbarAllowances, tx.GetHbarAllowances())
}

func TestUnitAccountAllowanceAdjustTransactionGrantTokenAllowance(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 3}
	tx := NewAccountAllowanceAdjustTransaction().
		GrantTokenAllowance(tokenID, AccountID{Account: 3}, AccountID{Account: 4}, 1)
	expectedTokenAllowances := []*TokenAllowance{
		{
			TokenID:          &tokenID,
			SpenderAccountID: &AccountID{Account: 4},
			OwnerAccountID:   &AccountID{Account: 3},
			Amount:           1,
		},
	}
	require.Equal(t, expectedTokenAllowances, tx.GetTokenAllowances())
}

func TestUnitAccountAllowanceAdjustTransactionRevokeTokenAllowance(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 3}
	tx := NewAccountAllowanceAdjustTransaction().
		RevokeTokenAllowance(tokenID, AccountID{Account: 3}, AccountID{Account: 4}, 1)
	expectedTokenAllowances := []*TokenAllowance{
		{
			TokenID:          &tokenID,
			SpenderAccountID: &AccountID{Account: 4},
			OwnerAccountID:   &AccountID{Account: 3},
			Amount:           -1,
		},
	}
	require.Equal(t, expectedTokenAllowances, tx.GetTokenAllowances())
}

func TestUnitAccountAllowanceAdjustTransactionGrantTokenNftAllowance(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 3}
	NftID := NftID{tokenID, 1}
	tx := NewAccountAllowanceAdjustTransaction().
		GrantTokenNftAllowance(NftID, AccountID{Account: 3}, AccountID{Account: 4})
	expectedTokenNftAllowances := []*TokenNftAllowance{
		{
			SpenderAccountID:  &AccountID{Account: 4},
			OwnerAccountID:    &AccountID{Account: 3},
			TokenID:           &tokenID,
			SerialNumbers:     []int64{1},
			AllSerials:        false,
			DelegatingSpender: nil,
		},
	}
	require.Equal(t, expectedTokenNftAllowances, tx.GetTokenNftAllowances())
}

func TestUnitAccountAllowanceAdjustTransactionRevokeTokenNftAllowance(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 3}
	NftID := NftID{tokenID, 1}
	tx := NewAccountAllowanceAdjustTransaction().
		RevokeTokenNftAllowance(NftID, AccountID{Account: 3}, AccountID{Account: 4})
	expectedTokenNftAllowances := []*TokenNftAllowance{
		{
			SpenderAccountID:  &AccountID{Account: 4},
			OwnerAccountID:    &AccountID{Account: 3},
			TokenID:           &tokenID,
			SerialNumbers:     []int64{1},
			AllSerials:        false,
			DelegatingSpender: nil,
		},
	}
	require.Equal(t, expectedTokenNftAllowances, tx.GetTokenNftAllowances())
}

func TestUnitAccountAllowanceAdjustTransactionAddAllTokenNftAllowance(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 3}
	tx := NewAccountAllowanceAdjustTransaction().
		AddAllTokenNftAllowance(tokenID, AccountID{Account: 3})
	expectedTokenNftAllowances := []*TokenNftAllowance{
		{
			SpenderAccountID:  &AccountID{Account: 3},
			OwnerAccountID:    nil,
			TokenID:           &tokenID,
			SerialNumbers:     []int64{},
			AllSerials:        true,
			DelegatingSpender: nil,
		},
	}
	require.Equal(t, expectedTokenNftAllowances, tx.GetTokenNftAllowances())
}
// Filename: account_allowance_approve_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// AccountAllowanceApproveTransaction
// Creates one or more hbar/token approved allowances <b>relative to the owner account specified in the allowances of
// tx transaction</b>. Each allowance grants a spender the right to transfer a pre-determined amount of the owner's
// hbar/token to any other account of the spender's choice. If the owner is not specified in any allowance, the payer
// of transaction is considered to be the owner for that particular allowance.
// Setting the amount to zero in CryptoAllowance or TokenAllowance will remove the respective allowance for the spender.
//
// (So if account <tt>0.0.X</tt> pays for this transaction and owner is not specified in the allowance,
// then at consensus each spender account will have new allowances to spend hbar or tokens from <tt>0.0.X</tt>).
type AccountAllowanceApproveTransaction struct {
	Transaction
	hbarAllowances  []*HbarAllowance
	tokenAllowances []*TokenAllowance
	nftAllowances   []*TokenNftAllowance
}

// NewAccountAllowanceApproveTransaction
// Creates an AccountAloowanceApproveTransaction which creates
// one or more hbar/token approved allowances relative to the owner account specified in the allowances of
// tx transaction. Each allowance grants a spender the right to transfer a pre-determined amount of the owner's
// hbar/token to any other account of the spender's choice. If the owner is not specified in any allowance, the payer
// of transaction is considered to be the owner for that particular allowance.
// Setting the amount to zero in CryptoAllowance or TokenAllowance will remove the respective allowance for the spender.
//
// (So if account 0.0.X pays for this transaction and owner is not specified in the allowance,
// then at consensus each spender account will have new allowances to spend hbar or tokens from 0.0.X).
func NewAccountAllowanceApproveTransaction() *AccountAllowanceApproveTransaction {
	tx := AccountAllowanceApproveTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _AccountAllowanceApproveTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *AccountAllowanceApproveTransaction {
	accountApproval := make([]*HbarAllowance, 0)
	tokenApproval := make([]*TokenAllowance, 0)
	nftApproval := make([]*TokenNftAllowance, 0)

	for _, ap := range pb.GetCryptoApproveAllowance().GetCryptoAllowances() {
		temp := _HbarAllowanceFromProtobuf(ap)
		accountApproval = append(accountApproval, &temp)
	}

	for _, ap := range pb.GetCryptoApproveAllowance().GetTokenAllowances() {
		temp := _TokenAllowanceFromProtobuf(ap)
		tokenApproval = append(tokenApproval, &temp)
	}

	for _, ap := range pb.GetCryptoApproveAllowance().GetNftAllowances() {
		temp := _TokenNftAllowanceFromProtobuf(ap)
		nftApproval = append(nftApproval, &temp)
	}

	return &AccountAllowanceApproveTransaction{
		Transaction:     tx,
		hbarAllowances:  accountApproval,
		tokenAllowances: tokenApproval,
		nftAllowances:   nftApproval,
	}
}

func (tx *AccountAllowanceApproveTransaction) _ApproveHbarApproval(ownerAccountID *AccountID, id AccountID, amount Hbar) *AccountAllowanceApproveTransaction {
	tx._RequireNotFrozen()
	tx.hbarAllowances = append(tx.hbarAllowances, &HbarAllowance{
		SpenderAccountID: &id,
		Amount:           amount.AsTinybar(),
		OwnerAccountID:   ownerAccountID,
	})

	return tx
}

// AddHbarApproval
// Deprecated - Use ApproveHbarAllowance instead
func (tx *AccountAllowanceApproveTransaction) AddHbarApproval(id AccountID, amount Hbar) *AccountAllowanceApproveTransaction {
	return tx._ApproveHbarApproval(nil, id, amount)
}

// ApproveHbarApproval
// Deprecated - Use ApproveHbarAllowance instead
func (tx *AccountAllowanceApproveTransaction) ApproveHbarApproval(ownerAccountID AccountID, id AccountID, amount Hbar) *AccountAllowanceApproveTransaction {
	return tx._ApproveHbarApproval(&ownerAccountID, id, amount)
}

// ApproveHbarAllowance
// Approves allowance of hbar transfers for a spender.
func (tx *AccountAllowanceApproveTransaction) ApproveHbarAllowance(ownerAccountID AccountID, id AccountID, amount Hbar) *AccountAllowanceApproveTransaction {
	return tx._ApproveHbarApproval(&ownerAccountID, id, amount)
}

// List of hbar allowance records
func (tx *AccountAllowanceApproveTransaction) GetHbarAllowances() []*HbarAllowance {
	return tx.hbarAllowances
}

func (tx *AccountAllowanceApproveTransaction) _ApproveTokenApproval(tokenID TokenID, ownerAccountID *AccountID, accountID AccountID, amount int64) *AccountAllowanceApproveTransaction {
	tx._RequireNotFrozen()
	tokenApproval := TokenAllowance{
		TokenID:          &tokenID,
		SpenderAccountID: &accountID,
		Amount:           amount,
		OwnerAccountID:   ownerAccountID,
	}

	tx.tokenAllowances = append(tx.tokenAllowances, &tokenApproval)
	return tx
}

// Deprecated - Use ApproveTokenAllowance instead
func (tx *AccountAllowanceApproveTransaction) AddTokenApproval(tokenID TokenID, accountID AccountID, amount int64) *AccountAllowanceApproveTransaction {
	return tx._ApproveTokenApproval(tokenID, nil, accountID, amount)
}

// ApproveTokenApproval
// Deprecated - Use ApproveTokenAllowance instead
func (tx *AccountAllowanceApproveTransaction) ApproveTokenApproval(tokenID TokenID, ownerAccountID AccountID, accountID AccountID, amount int64) *AccountAllowanceApproveTransaction {
	return tx._ApproveTokenApproval(tokenID, &ownerAccountID, accountID, amount)
}

// ApproveTokenAllowance
// Approve allowance of fungible token transfers for a spender.
func (tx *AccountAllowanceApproveTransaction) ApproveTokenAllowance(tokenID TokenID, ownerAccountID AccountID, accountID AccountID, amount int64) *AccountAllowanceApproveTransaction {
	return tx._ApproveTokenApproval(tokenID, &ownerAccountID, accountID, amount)
}

// List of token allowance records
func (tx *AccountAllowanceApproveTransaction) GetTokenAllowances() []*TokenAllowance {
	return tx.tokenAllowances
}

func (tx *AccountAllowanceApproveTransaction) _ApproveTokenNftApproval(nftID NftID, ownerAccountID *AccountID, spenderAccountID *AccountID, delegatingSpenderAccountId *AccountID) *AccountAllowanceApproveTransaction {
	tx._RequireNotFrozen()

	for _, t := range tx.nftAllowances {
		if t.TokenID.String() == nftID.TokenID.String() {
			if t.SpenderAccountID.String() == spenderAccountID.String() {
				b := false
				for _, s := range t.SerialNumbers {
					if s == nftID.SerialNumber {
						b = true
					}
				}
				if !b {
					t.SerialNumbers = append(t.SerialNumbers, nftID.SerialNumber)
				}
				return tx
			}
		}
	}

	tx.nftAllowances = append(tx.nftAllowances, &TokenNftAllowance{
		TokenID:           &nftID.TokenID,
		SpenderAccountID:  spenderAccountID,
		SerialNumbers:     []int64{nftID.SerialNumber},
		AllSerials:        false,
		OwnerAccountID:    ownerAccountID,
		DelegatingSpender: delegatingSpenderAccountId,
	})
	return tx
}

// AddTokenNftApproval
// Deprecated - Use ApproveTokenNftAllowance instead
func (tx *AccountAllowanceApproveTransaction) AddTokenNftApproval(nftID NftID, accountID AccountID) *AccountAllowanceApproveTransaction {
	return tx._ApproveTokenNftApproval(nftID, nil, &accountID, nil)
}

// ApproveTokenNftApproval
// Deprecated - Use ApproveTokenNftAllowance instead
func (tx *AccountAllowanceApproveTransaction) ApproveTokenNftApproval(nftID NftID, ownerAccountID AccountID, accountID AccountID) *AccountAllowanceApproveTransaction {
	return tx._ApproveTokenNftApproval(nftID, &ownerAccountID, &accountID, nil)
}

func (tx *AccountAllowanceApproveTransaction) ApproveTokenNftAllowanceWithDelegatingSpender(nftID NftID, ownerAccountID AccountID, spenderAccountId AccountID, delegatingSpenderAccountID AccountID) *AccountAllowanceApproveTransaction {
	tx._RequireNotFrozen()
	return tx._ApproveTokenNftApproval(nftID, &ownerAccountID, &spenderAccountId, &delegatingSpenderAccountID)
}

// ApproveTokenNftAllowance
// Approve allowance of non-fungible token transfers for a spender.
func (tx *AccountAllowanceApproveTransaction) ApproveTokenNftAllowance(nftID NftID, ownerAccountID AccountID, accountID AccountID) *AccountAllowanceApproveTransaction {
	return tx._ApproveTokenNftApproval(nftID, &ownerAccountID, &accountID, nil)
}

func (tx *AccountAllowanceApproveTransaction) _ApproveTokenNftAllowanceAllSerials(tokenID TokenID, ownerAccountID *AccountID, spenderAccount AccountID) *AccountAllowanceApproveTransaction {
	for _, t := range tx.nftAllowances {
		if t.TokenID.String() == tokenID.String() {
			if t.SpenderAccountID.String() == spenderAccount.String() {
				t.SerialNumbers = []int64{}
				t.AllSerials = true
				return tx
			}
		}
	}

	tx.nftAllowances = append(tx.nftAllowances, &TokenNftAllowance{
		TokenID:          &tokenID,
		SpenderAccountID: &spenderAccount,
		SerialNumbers:    []int64{},
		AllSerials:       true,
		OwnerAccountID:   ownerAccountID,
	})
	return tx
}

// AddAllTokenNftApproval
// Approve allowance of non-fungible token transfers for a spender.
// Spender has access to all of the owner's NFT units of type tokenId (currently
// owned and any in the future).
func (tx *AccountAllowanceApproveTransaction) AddAllTokenNftApproval(tokenID TokenID, spenderAccount AccountID) *AccountAllowanceApproveTransaction {
	return tx._ApproveTokenNftAllowanceAllSerials(tokenID, nil, spenderAccount)
}

// ApproveTokenNftAllowanceAllSerials
// Approve allowance of non-fungible token transfers for a spender.
// Spender has access to all of the owner's NFT units of type tokenId (currently
// owned and any in the future).
func (tx *AccountAllowanceApproveTransaction) ApproveTokenNftAllowanceAllSerials(tokenID TokenID, ownerAccountID AccountID, spenderAccount AccountID) *AccountAllowanceApproveTransaction {
	return tx._ApproveTokenNftAllowanceAllSerials(tokenID, &ownerAccountID, spenderAccount)
}

// List of NFT allowance records
func (tx *AccountAllowanceApproveTransaction) GetTokenNftAllowances() []*TokenNftAllowance {
	return tx.nftAllowances
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *AccountAllowanceApproveTransaction) Sign(
	privateKey PrivateKey,
) *AccountAllowanceApproveTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *AccountAllowanceApproveTransaction) SignWithOperator(
	client *Client,
) (*AccountAllowanceApproveTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *AccountAllowanceApproveTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *AccountAllowanceApproveTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *AccountAllowanceApproveTransaction) AddSignature(publicKey PublicKey, signature []byte) *AccountAllowanceApproveTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *AccountAllowanceApproveTransaction) SetGrpcDeadline(deadline *time.Duration) *AccountAllowanceApproveTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *AccountAllowanceApproveTransaction) Freeze() (*AccountAllowanceApproveTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *AccountAllowanceApproveTransaction) FreezeWith(client *Client) (*AccountAllowanceApproveTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// GetMaxTransactionFee returns the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *AccountAllowanceApproveTransaction) GetMaxTransactionFee() Hbar {
	return tx.Transaction.GetMaxTransactionFee()
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *AccountAllowanceApproveTransaction) SetMaxTransactionFee(fee Hbar) *AccountAllowanceApproveTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *AccountAllowanceApproveTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *AccountAllowanceApproveTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this AccountAllowanceApproveTransaction.
func (tx *AccountAllowanceApproveTransaction) SetTransactionMemo(memo string) *AccountAllowanceApproveTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this AccountAllowanceApproveTransaction.
func (tx *AccountAllowanceApproveTransaction) SetTransactionValidDuration(duration time.Duration) *AccountAllowanceApproveTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *AccountAllowanceApproveTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this AccountAllowanceApproveTransaction.
func (tx *AccountAllowanceApproveTransaction) SetTransactionID(transactionID TransactionID) *AccountAllowanceApproveTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountAllowanceApproveTransaction.
func (tx *AccountAllowanceApproveTransaction) SetNodeAccountIDs(nodeID []AccountID) *AccountAllowanceApproveTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *AccountAllowanceApproveTransaction) SetMaxRetry(count int) *AccountAllowanceApproveTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *AccountAllowanceApproveTransaction) SetMaxBackoff(max time.Duration) *AccountAllowanceApproveTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the min back off for this AccountAllowanceApproveTransaction.
func (tx *AccountAllowanceApproveTransaction) SetMinBackoff(min time.Duration) *AccountAllowanceApproveTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *AccountAllowanceApproveTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *AccountAllowanceApproveTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *AccountAllowanceApproveTransaction) getName() string {
	return "AccountAllowanceApproveTransaction"
}
func (tx *AccountAllowanceApproveTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	for _, ap := range tx.hbarAllowances {
		if ap.SpenderAccountID != nil {
			if err := ap.SpenderAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.OwnerAccountID != nil {
			if err := ap.OwnerAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	for _, ap := range tx.tokenAllowances {
		if ap.SpenderAccountID != nil {
			if err := ap.SpenderAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.TokenID != nil {
			if err := ap.TokenID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.OwnerAccountID != nil {
			if err := ap.OwnerAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	for _, ap := range tx.nftAllowances {
		if ap.SpenderAccountID != nil {
			if err := ap.SpenderAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.TokenID != nil {
			if err := ap.TokenID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.OwnerAccountID != nil {
			if err := ap.OwnerAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	return nil
}

func (tx *AccountAllowanceApproveTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionID:            tx.transactionID._ToProtobuf(),
		TransactionFee:           tx.transactionFee,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		Memo:                     tx.Transaction.memo,
		Data: &services.TransactionBody_CryptoApproveAllowance{
			CryptoApproveAllowance: tx.buildProtoBody(),
		},
	}
}

func (tx *AccountAllowanceApproveTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_CryptoApproveAllowance{
			CryptoApproveAllowance: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *AccountAllowanceApproveTransaction) buildProtoBody() *services.CryptoApproveAllowanceTransactionBody {
	body := &services.CryptoApproveAllowanceTransactionBody{
		CryptoAllowances: make([]*services.CryptoAllowance, 0),
		TokenAllowances:  make([]*services.TokenAllowance, 0),
		NftAllowances:    make([]*services.NftAllowance, 0),
	}

	for _, ap := range tx.hbarAllowances {
		body.CryptoAllowances = append(body.CryptoAllowances, ap._ToProtobuf())
	}

	for _, ap := range tx.tokenAllowances {
		body.TokenAllowances = append(body.TokenAllowances, ap._ToProtobuf())
	}

	for _, ap := range tx.nftAllowances {
		body.NftAllowances = append(body.NftAllowances, ap._ToProtobuf())
	}

	return body
}

func (tx *AccountAllowanceApproveTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetCrypto().ApproveAllowances,
	}
}

func (tx *AccountAllowanceApproveTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: account_allowance_approve_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

var tokenID1 = TokenID{Token: 1}
var tokenID2 = TokenID{Token: 141}
var serialNumber1 = int64(3)
var serialNumber2 = int64(4)
var nftID1 = tokenID2.Nft(serialNumber1)
var nftID2 = tokenID2.Nft(serialNumber2)
var owner = AccountID{Account: 10}
var spenderAccountID1 = AccountID{Account: 7}
var spenderAccountID2 = AccountID{Account: 7890}
var nodeAccountID = []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
var hbarAmount = HbarFromTinybar(100)
var tokenAmount = int64(101)

func TestUnitAccountAllowanceApproveTransaction(t *testing.T) {
	t.Parallel()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountAllowanceApproveTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		ApproveHbarAllowance(owner, spenderAccountID1, hbarAmount).
		ApproveTokenAllowance(tokenID1, owner, spenderAccountID1, tokenAmount).
		ApproveTokenNftAllowance(nftID1, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID2).
		AddAllTokenNftApproval(tokenID1, spenderAccountID1).
		Freeze()
	require.NoError(t, err)

	data := transaction.build()

	switch d := data.Data.(type) {
	case *services.TransactionBody_CryptoApproveAllowance:
		require.Equal(t, d.CryptoApproveAllowance.CryptoAllowances, []*services.CryptoAllowance{
			{
				Spender: spenderAccountID1._ToProtobuf(),
				Owner:   owner._ToProtobuf(),
				Amount:  hbarAmount.AsTinybar(),
			},
		})
		require.Equal(t, d.CryptoApproveAllowance.NftAllowances, []*services.NftAllowance{
			{
				TokenId:           tokenID2._ToProtobuf(),
				Spender:           spenderAccountID1._ToProtobuf(),
				Owner:             owner._ToProtobuf(),
				SerialNumbers:     []int64{serialNumber1, serialNumber2},
				ApprovedForAll:    &wrapperspb.BoolValue{Value: false},
				DelegatingSpender: nil,
			},
			{
				TokenId:           tokenID2._ToProtobuf(),
				Spender:           spenderAccountID2._ToProtobuf(),
				Owner:             owner._ToProtobuf(),
				SerialNumbers:     []int64{serialNumber2},
				ApprovedForAll:    &wrapperspb.BoolValue{Value: false},
				DelegatingSpender: nil,
			},
			{
				TokenId:           tokenID1._ToProtobuf(),
				Spender:           spenderAccountID1._ToProtobuf(),
				Owner:             nil,
				SerialNumbers:     []int64{},
				ApprovedForAll:    &wrapperspb.BoolValue{Value: true},
				DelegatingSpender: nil,
			},
		})
		require.Equal(t, d.CryptoApproveAllowance.TokenAllowances, []*services.TokenAllowance{
			{
				TokenId: tokenID1._ToProtobuf(),
				Owner:   owner._ToProtobuf(),
				Spender: spenderAccountID1._ToProtobuf(),
				Amount:  tokenAmount,
			},
		})
	}
}
func TestUnitvalidateNetworkOnIDs(t *testing.T) {
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountAllowanceApproveTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		ApproveHbarAllowance(owner, spenderAccountID1, hbarAmount).
		ApproveTokenAllowance(tokenID1, owner, spenderAccountID1, tokenAmount).
		ApproveTokenNftAllowance(nftID1, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID2).
		AddAllTokenNftApproval(tokenID1, spenderAccountID1).
		Freeze()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)

	e := transaction.validateNetworkOnIDs(client)
	require.NoError(t, e)
}
func TestUnitAccountAllowanceApproveTransactionGet(t *testing.T) {
	t.Parallel()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountAllowanceApproveTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		ApproveHbarAllowance(owner, spenderAccountID1, hbarAmount).
		ApproveTokenAllowance(tokenID1, owner, spenderAccountID1, tokenAmount).
		ApproveTokenNftAllowance(nftID1, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID2).
		AddAllTokenNftApproval(tokenID1, spenderAccountID1).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetTokenNftAllowances()
	transaction.GetHbarAllowances()
	transaction.GetTokenAllowances()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
}

func TestUnitAccountAllowanceApproveTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountAllowanceApproveTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetTokenNftAllowances()
	transaction.GetHbarAllowances()
	transaction.GetTokenAllowances()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
}

func TestUnitAccountAllowanceApproveTransactionFromProtobuf(t *testing.T) {
	t.Parallel()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	tx, err := NewAccountAllowanceApproveTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		ApproveHbarAllowance(owner, spenderAccountID1, hbarAmount).
		ApproveTokenAllowance(tokenID1, owner, spenderAccountID1, tokenAmount).
		ApproveTokenNftAllowance(nftID1, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID2).
		Freeze()
	require.NoError(t, err)

	txFromProto := _AccountAllowanceApproveTransactionFromProtobuf(tx.Transaction, tx.build())
	require.Equal(t, tx, txFromProto)
}

func TestUnitAccountAllowanceApproveTransactionScheduleProtobuf(t *testing.T) {
	t.Parallel()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	tx, err := NewAccountAllowanceApproveTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		ApproveHbarAllowance(owner, spenderAccountID1, hbarAmount).
		ApproveTokenAllowance(tokenID1, owner, spenderAccountID1, tokenAmount).
		ApproveTokenNftAllowance(nftID1, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID1).
		ApproveTokenNftAllowance(nftID2, owner, spenderAccountID2).
		Freeze()
	require.NoError(t, err)

	expected := &services.SchedulableTransactionBody{
		TransactionFee: 200000000,
		Data: &services.SchedulableTransactionBody_CryptoApproveAllowance{
			CryptoApproveAllowance: &services.CryptoApproveAllowanceTransactionBody{
				CryptoAllowances: []*services.CryptoAllowance{
					{
						Owner:   &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 10}},
						Spender: &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 7}},
						Amount:  100,
					},
				},
				NftAllowances: []*services.NftAllowance{
					{
						TokenId:           &services.TokenID{TokenNum: 141},
						Owner:             &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 10}},
						Spender:           &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 7}},
						SerialNumbers:     []int64{3, 4},
						ApprovedForAll:    &wrapperspb.BoolValue{Value: false},
						DelegatingSpender: nil,
					},
					{
						TokenId:           &services.TokenID{TokenNum: 141},
						Owner:             &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 10}},
						Spender:           &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 7890}},
						SerialNumbers:     []int64{4},
						ApprovedForAll:    &wrapperspb.BoolValue{Value: false},
						DelegatingSpender: nil,
					},
				},
				TokenAllowances: []*services.TokenAllowance{
					{
						TokenId: &services.TokenID{TokenNum: 1},
						Owner:   &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 10}},
						Spender: &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 7}},
						Amount:  101,
					},
				},
			},
		},
	}
	actual, err := tx.buildScheduled()
	require.NoError(t, err)
	require.Equal(t, expected.String(), actual.String())
}
// Filename: account_allowance_delete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// AccountAllowanceDeleteTransaction
// Deletes one or more non-fungible approved allowances from an owner's account. This operation
// will remove the allowances granted to one or more specific non-fungible token serial numbers. Each owner account
// listed as wiping an allowance must sign the transaction. Hbar and fungible token allowances
// can be removed by setting the amount to zero in CryptoApproveAllowance.
type AccountAllowanceDeleteTransaction struct {
	Transaction
	hbarWipe  []*HbarAllowance
	tokenWipe []*TokenAllowance
	nftWipe   []*TokenNftAllowance
}

// NewAccountAllowanceDeleteTransaction
// Creates AccountAllowanceDeleteTransaction whoch deletes one or more non-fungible approved allowances from an owner's account. This operation
// will remove the allowances granted to one or more specific non-fungible token serial numbers. Each owner account
// listed as wiping an allowance must sign the transaction. Hbar and fungible token allowances
// can be removed by setting the amount to zero in CryptoApproveAllowance.
func NewAccountAllowanceDeleteTransaction() *AccountAllowanceDeleteTransaction {
	tx := AccountAllowanceDeleteTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _AccountAllowanceDeleteTransactionFromProtobuf(transaction Transaction, pb *services.TransactionBody) *AccountAllowanceDeleteTransaction {
	nftWipe := make([]*TokenNftAllowance, 0)

	for _, ap := range pb.GetCryptoDeleteAllowance().GetNftAllowances() {
		temp := _TokenNftWipeAllowanceProtobuf(ap)
		nftWipe = append(nftWipe, &temp)
	}

	return &AccountAllowanceDeleteTransaction{
		Transaction: transaction,
		nftWipe:     nftWipe,
	}
}

// Deprecated
func (tx *AccountAllowanceDeleteTransaction) DeleteAllHbarAllowances(ownerAccountID *AccountID) *AccountAllowanceDeleteTransaction {
	tx._RequireNotFrozen()
	tx.hbarWipe = append(tx.hbarWipe, &HbarAllowance{
		OwnerAccountID: ownerAccountID,
	})

	return tx
}

// Deprecated
func (tx *AccountAllowanceDeleteTransaction) GetAllHbarDeleteAllowances() []*HbarAllowance {
	return tx.hbarWipe
}

// Deprecated
func (tx *AccountAllowanceDeleteTransaction) DeleteAllTokenAllowances(tokenID TokenID, ownerAccountID *AccountID) *AccountAllowanceDeleteTransaction {
	tx._RequireNotFrozen()
	tokenApproval := TokenAllowance{
		TokenID:        &tokenID,
		OwnerAccountID: ownerAccountID,
	}

	tx.tokenWipe = append(tx.tokenWipe, &tokenApproval)
	return tx
}

// Deprecated
func (tx *AccountAllowanceDeleteTransaction) GetAllTokenDeleteAllowances() []*TokenAllowance {
	return tx.tokenWipe
}

// DeleteAllTokenNftAllowances
// The non-fungible token allowance/allowances to remove.
func (tx *AccountAllowanceDeleteTransaction) DeleteAllTokenNftAllowances(nftID NftID, ownerAccountID *AccountID) *AccountAllowanceDeleteTransaction {
	tx._RequireNotFrozen()

	for _, t := range tx.nftWipe {
		if t.TokenID.String() == nftID.TokenID.String() {
			if t.OwnerAccountID.String() == ownerAccountID.String() {
				b := false
				for _, s := range t.SerialNumbers {
					if s == nftID.SerialNumber {
						b = true
					}
				}
				if !b {
					t.SerialNumbers = append(t.SerialNumbers, nftID.SerialNumber)
				}
				return tx
			}
		}
	}

	tx.nftWipe = append(tx.nftWipe, &TokenNftAllowance{
		TokenID:        &nftID.TokenID,
		OwnerAccountID: ownerAccountID,
		SerialNumbers:  []int64{nftID.SerialNumber},
		AllSerials:     false,
	})
	return tx
}

// GetAllTokenNftDeleteAllowances
// Get the non-fungible token allowance/allowances that will be removed.
func (tx *AccountAllowanceDeleteTransaction) GetAllTokenNftDeleteAllowances() []*TokenNftAllowance {
	return tx.nftWipe
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *AccountAllowanceDeleteTransaction) Sign(
	privateKey PrivateKey,
) *AccountAllowanceDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *AccountAllowanceDeleteTransaction) SignWithOperator(
	client *Client,
) (*AccountAllowanceDeleteTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *AccountAllowanceDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *AccountAllowanceDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *AccountAllowanceDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *AccountAllowanceDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *AccountAllowanceDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *AccountAllowanceDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *AccountAllowanceDeleteTransaction) Freeze() (*AccountAllowanceDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *AccountAllowanceDeleteTransaction) FreezeWith(client *Client) (*AccountAllowanceDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this AccountAllowanceDeleteTransaction.
func (tx *AccountAllowanceDeleteTransaction) SetMaxTransactionFee(fee Hbar) *AccountAllowanceDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *AccountAllowanceDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *AccountAllowanceDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this AccountAllowanceDeleteTransaction.
func (tx *AccountAllowanceDeleteTransaction) SetTransactionMemo(memo string) *AccountAllowanceDeleteTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this AccountAllowanceDeleteTransaction.
func (tx *AccountAllowanceDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *AccountAllowanceDeleteTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *AccountAllowanceDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this AccountAllowanceDeleteTransaction.
func (tx *AccountAllowanceDeleteTransaction) SetTransactionID(transactionID TransactionID) *AccountAllowanceDeleteTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountAllowanceDeleteTransaction.
func (tx *AccountAllowanceDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *AccountAllowanceDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *AccountAllowanceDeleteTransaction) SetMaxRetry(count int) *AccountAllowanceDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *AccountAllowanceDeleteTransaction) SetMaxBackoff(max time.Duration) *AccountAllowanceDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the min back off for this AccountAllowanceDeleteTransaction.
func (tx *AccountAllowanceDeleteTransaction) SetMinBackoff(min time.Duration) *AccountAllowanceDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *AccountAllowanceDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *AccountAllowanceDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *AccountAllowanceDeleteTransaction) getName() string {
	return "AccountAllowanceDeleteTransaction"
}

func (tx *AccountAllowanceDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	for _, ap := range tx.nftWipe {
		if ap.TokenID != nil {
			if err := ap.TokenID.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if ap.OwnerAccountID != nil {
			if err := ap.OwnerAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	return nil
}

func (tx *AccountAllowanceDeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionID:            tx.transactionID._ToProtobuf(),
		TransactionFee:           tx.transactionFee,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		Memo:                     tx.Transaction.memo,
		Data: &services.TransactionBody_CryptoDeleteAllowance{
			CryptoDeleteAllowance: tx.buildProtoBody(),
		},
	}
}

func (tx *AccountAllowanceDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_CryptoDeleteAllowance{
			CryptoDeleteAllowance: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *AccountAllowanceDeleteTransaction) buildProtoBody() *services.CryptoDeleteAllowanceTransactionBody {
	body := &services.CryptoDeleteAllowanceTransactionBody{}
	nftWipe := make([]*services.NftRemoveAllowance, 0)

	for _, ap := range tx.nftWipe {
		nftWipe = append(nftWipe, ap._ToWipeProtobuf())
	}

	body.NftAllowances = nftWipe
	return body
}

func (tx *AccountAllowanceDeleteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetCrypto().DeleteAllowances,
	}
}

func (this *AccountAllowanceDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return this.buildScheduled()
}
// Filename: account_allowance_delete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
	protobuf "google.golang.org/protobuf/proto"
	"testing"
	"time"
)

func TestUnitAccountAllowanceDeleteTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewAccountAllowanceDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		DeleteAllTokenNftAllowances(token.Nft(4), &account).
		DeleteAllTokenNftAllowances(token.Nft(5), &account).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		DeleteAllHbarAllowances(&account).
		DeleteAllTokenAllowances(token, &account).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)
	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytesI, err := TransactionFromBytes(byt)
	txFromBytes, ok := txFromBytesI.(AccountAllowanceDeleteTransaction)
	require.True(t, ok)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetAllTokenNftDeleteAllowances()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetAllHbarDeleteAllowances()
	transaction.GetAllTokenDeleteAllowances()
	transaction.getName()
	txFromBytes.AddSignature(newKey.PublicKey(), sig)
}

func TestUnitAccountAllowanceDeleteTransactionMock(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 3}}
	transactionID := TransactionIDGenerate(AccountID{Account: 3})

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewAccountAllowanceDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		DeleteAllTokenNftAllowances(token.Nft(4), &AccountID{Account: 3}).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitAccountAllowanceDeleteTransactionSetNothing(t *testing.T) {
	t.Parallel()

	token := TokenID{Token: 3}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountAllowanceDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		DeleteAllTokenNftAllowances(token.Nft(4), &AccountID{Account: 3}).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetAllTokenNftDeleteAllowances()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
}
// Filename: account_balance.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

type AccountBalance struct {
	Hbars Hbar
	// Deprecated: Use `AccountBalance.Tokens` instead
	Token         map[TokenID]uint64
	Tokens        TokenBalanceMap
	TokenDecimals TokenDecimalMap
}

func _AccountBalanceFromProtobuf(pb *services.CryptoGetAccountBalanceResponse) AccountBalance { //nolint
	if pb == nil {
		return AccountBalance{}
	}
	var tokens map[TokenID]uint64
	if pb.TokenBalances != nil { //nolint
		tokens = make(map[TokenID]uint64, len(pb.TokenBalances)) //nolint
		for _, token := range pb.TokenBalances {                 //nolint
			if t := _TokenIDFromProtobuf(token.TokenId); t != nil {
				tokens[*t] = token.Balance
			}
		}
	}
	return AccountBalance{
		Hbars:         HbarFromTinybar(int64(pb.Balance)),
		Token:         tokens,
		Tokens:        _TokenBalanceMapFromProtobuf(pb.TokenBalances), //nolint
		TokenDecimals: _TokenDecimalMapFromProtobuf(pb.TokenBalances), //nolint
	}
}

func (balance *AccountBalance) _ToProtobuf() *services.CryptoGetAccountBalanceResponse { //nolint
	return &services.CryptoGetAccountBalanceResponse{
		Balance: uint64(balance.Hbars.AsTinybar()),
	}
}
// Filename: account_balance_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// AccountBalanceQuery gets the balance of a CryptoCurrency account. This returns only the balance, so it is a smaller
// and faster reply than AccountInfoQuery, which returns the balance plus additional information.
type AccountBalanceQuery struct {
	Query
	accountID  *AccountID
	contractID *ContractID
}

// NewAccountBalanceQuery creates an AccountBalanceQuery query which can be used to construct and execute
// an AccountBalanceQuery.
// It is recommended that you use this for creating new instances of an AccountBalanceQuery
// instead of manually creating an instance of the struct.
func NewAccountBalanceQuery() *AccountBalanceQuery {
	header := services.QueryHeader{}
	return &AccountBalanceQuery{
		Query: _NewQuery(false, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *AccountBalanceQuery) SetGrpcDeadline(deadline *time.Duration) *AccountBalanceQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetAccountID sets the AccountID for which you wish to query the balance.
//
// Note: you can only query an Account or Contract but not both -- if a Contract ID or Account ID has already been set,
// it will be overwritten by this _Method.
func (q *AccountBalanceQuery) SetAccountID(accountID AccountID) *AccountBalanceQuery {
	q.accountID = &accountID
	return q
}

// GetAccountID returns the AccountID for which you wish to query the balance.
func (q *AccountBalanceQuery) GetAccountID() AccountID {
	if q.accountID == nil {
		return AccountID{}
	}

	return *q.accountID
}

// SetContractID sets the ContractID for which you wish to query the balance.
//
// Note: you can only query an Account or Contract but not both -- if a Contract ID or Account ID has already been set,
// it will be overwritten by this _Method.
func (q *AccountBalanceQuery) SetContractID(contractID ContractID) *AccountBalanceQuery {
	q.contractID = &contractID
	return q
}

// GetContractID returns the ContractID for which you wish to query the balance.
func (q *AccountBalanceQuery) GetContractID() ContractID {
	if q.contractID == nil {
		return ContractID{}
	}

	return *q.contractID
}

func (q *AccountBalanceQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the query with the provided client
func (q *AccountBalanceQuery) Execute(client *Client) (AccountBalance, error) {
	if client == nil {
		return AccountBalance{}, errNoClientProvided
	}

	err := q.validateNetworkOnIDs(client)
	if err != nil {
		return AccountBalance{}, err
	}

	resp, err := q.Query.execute(client, q)
	if err != nil {
		return AccountBalance{}, err
	}
	return _AccountBalanceFromProtobuf(resp.GetCryptogetAccountBalance()), nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this query.
func (q *AccountBalanceQuery) SetMaxQueryPayment(maxPayment Hbar) *AccountBalanceQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this query.
func (q *AccountBalanceQuery) SetQueryPayment(paymentAmount Hbar) *AccountBalanceQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountBalanceQuery.
func (q *AccountBalanceQuery) SetNodeAccountIDs(accountID []AccountID) *AccountBalanceQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *AccountBalanceQuery) SetMaxRetry(count int) *AccountBalanceQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries. Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *AccountBalanceQuery) SetMaxBackoff(max time.Duration) *AccountBalanceQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *AccountBalanceQuery) SetMinBackoff(min time.Duration) *AccountBalanceQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *AccountBalanceQuery) SetPaymentTransactionID(transactionID TransactionID) *AccountBalanceQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *AccountBalanceQuery) SetLogLevel(level LogLevel) *AccountBalanceQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *AccountBalanceQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetCrypto().CryptoGetBalance,
	}
}

func (q *AccountBalanceQuery) getName() string {
	return "AccountBalanceQuery"
}

func (q *AccountBalanceQuery) buildProtoBody() *services.CryptoGetAccountBalanceQuery {
	pb := services.CryptoGetAccountBalanceQuery{Header: &services.QueryHeader{}}

	if q.accountID != nil {
		pb.BalanceSource = &services.CryptoGetAccountBalanceQuery_AccountID{
			AccountID: q.accountID._ToProtobuf(),
		}
	}

	if q.contractID != nil {
		pb.BalanceSource = &services.CryptoGetAccountBalanceQuery_ContractID{
			ContractID: q.contractID._ToProtobuf(),
		}
	}
	return &pb
}
func (q *AccountBalanceQuery) buildQuery() *services.Query {
	pb := q.buildProtoBody()

	return &services.Query{
		Query: &services.Query_CryptogetAccountBalance{
			CryptogetAccountBalance: pb,
		},
	}
}

func (q *AccountBalanceQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.accountID != nil {
		if err := q.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if q.contractID != nil {
		if err := q.contractID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *AccountBalanceQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetCryptogetAccountBalance()
}
// Filename: account_balance_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationAccountBalanceQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewAccountBalanceQuery().
		SetAccountID(env.OriginalOperatorID).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountBalanceQueryCanGetTokenBalance(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	balance, err := NewAccountBalanceQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.Client.GetOperatorAccountID()).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, balance, balance)
	// TODO: assert.Equal(t, uint64(1000000), balance.Tokens.Get(*tokenID))
	// TODO: assert.Equal(t, uint64(3), balance.TokenDecimals.Get(*tokenID))
	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationAccountBalanceQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	balance := NewAccountBalanceQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.Client.GetOperatorAccountID())

	cost, err := balance.GetCost(env.Client)
	require.NoError(t, err)

	_, err = balance.SetMaxQueryPayment(cost).
		Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountBalanceQuerySetBigMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	balance := NewAccountBalanceQuery().
		SetMaxQueryPayment(NewHbar(10000)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.Client.GetOperatorAccountID())

	cost, err := balance.GetCost(env.Client)
	require.NoError(t, err)

	_, err = balance.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountBalanceQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	balance := NewAccountBalanceQuery().
		SetMaxQueryPayment(HbarFromTinybar(1)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.Client.GetOperatorAccountID())

	_, err := balance.GetCost(env.Client)
	require.NoError(t, err)

	_, err = balance.Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountBalanceQueryCanSetQueryPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	balance := NewAccountBalanceQuery().
		SetMaxQueryPayment(NewHbar(10000)).
		SetQueryPayment(NewHbar(0)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.OperatorID)

	cost, err := balance.GetCost(env.Client)
	require.NoError(t, err)

	_, err = balance.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountBalanceQueryCostCanSetPaymentOneTinybar(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	balance := NewAccountBalanceQuery().
		SetMaxQueryPayment(NewHbar(10000)).
		SetQueryPayment(NewHbar(0)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.Client.GetOperatorAccountID())

	_, err := balance.GetCost(env.Client)
	require.NoError(t, err)

	_, err = balance.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountBalanceQueryNoAccountIDError(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewAccountBalanceQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	assert.True(t, err.Error() == "exceptional precheck status INVALID_ACCOUNT_ID")

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestIntegrationAccountBalanceQueryWorksWithHollowAccountAlias(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)

	// Extract the ECDSA public key public key
	publicKey := privateKey.PublicKey()
	// Extract the Ethereum public address
	aliasAccountId := *publicKey.ToAccountID(0, 0)
	evmAddress := publicKey.ToEvmAddress()

	evmAddressAccount, err := AccountIDFromEvmPublicAddress(evmAddress)
	require.NoError(t, err)

	// Transfer tokens using the `TransferTransaction` to the Etherum Account Address
	tx, err := NewTransferTransaction().AddHbarTransfer(evmAddressAccount, NewHbar(4)).
		AddHbarTransfer(env.OperatorID, NewHbar(-4)).Execute(env.Client)
	require.NoError(t, err)

	// Get the child receipt or child record to return the Hedera Account ID for the new account that was created
	_, err = tx.SetIncludeChildren(true).SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	_, err = NewAccountBalanceQuery().SetAccountID(aliasAccountId).Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountBalanceQueryCanConnectToMainnetTls(t *testing.T) {
	t.Parallel()
	client := ClientForMainnet()
	client.SetTransportSecurity(true)

	succeededOnce := false
	for address, accountID := range client.GetNetwork() {

		if !strings.HasSuffix(address, ":50212") {
			t.Errorf("Expected entry key to end with ':50212', but got %s", address)
		}

		accountIDs := []AccountID{accountID}
		_, err := NewAccountBalanceQuery().
			SetNodeAccountIDs(accountIDs).
			SetAccountID(accountID).
			Execute(client)
		if err == nil {
			succeededOnce = true
		}
	}
	assert.True(t, succeededOnce)
}
// Filename: account_balance_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitAccountBalanceQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	balanceQuery := NewAccountBalanceQuery().
		SetAccountID(accountID)

	err = balanceQuery.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitAccountBalanceQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	balanceQuery := NewAccountBalanceQuery().
		SetAccountID(accountID)

	err = balanceQuery.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitAccountBalanceQueryGet(t *testing.T) {
	t.Parallel()

	spenderAccountID1 := AccountID{Account: 7}

	balance := NewAccountBalanceQuery().
		SetAccountID(spenderAccountID1).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}})

	balance.GetAccountID()
	balance.GetNodeAccountIDs()
	balance.GetPaymentTransactionID()
}

func TestUnitAccountBalanceQuerySetNothing(t *testing.T) {
	t.Parallel()

	balance := NewAccountBalanceQuery()

	balance.GetAccountID()
	balance.GetNodeAccountIDs()
	balance.GetPaymentTransactionID()
}

func TestUnitAccountBalanceQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	contract := ContractID{Contract: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewAccountBalanceQuery().
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetAccountID(account).
		SetContractID(contract).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3))

	err = query.validateNetworkOnIDs(client)

	require.NoError(t, err)
	query.GetNodeAccountIDs()
	query.GetMaxBackoff()
	query.GetMinBackoff()
	query.getName()
	query.GetAccountID()
	query.GetContractID()

	_AccountBalanceFromProtobuf(nil)
	bal := AccountBalance{Hbars: NewHbar(2)}
	bal._ToProtobuf()
}

func TestUnitAccountBalanceQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{
		{
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 0},
						AccountID: &services.AccountID{ShardNum: 0, RealmNum: 0, Account: &services.AccountID_AccountNum{
							AccountNum: 1800,
						}},
						Balance: 2000,
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 0},
						AccountID: &services.AccountID{ShardNum: 0, RealmNum: 0, Account: &services.AccountID_AccountNum{
							AccountNum: 1800,
						}},
						Balance: 2000,
					},
				},
			},
		},
	}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewAccountBalanceQuery().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAccountID(AccountID{Account: 1800}).
		SetContractID(ContractID{Contract: 3})

	_, err := query.Execute(client)
	require.NoError(t, err)
}

func TestUnitAccountBalanceQueryNoClient(t *testing.T) {
	t.Parallel()

	_, err := NewAccountBalanceQuery().
		Execute(nil)

	require.ErrorContains(t, err, "client` must be provided and have an _Operator")
}
// Filename: account_create_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"strings"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// AccountCreateTransaction creates a new account. After the account is created, the AccountID for it is in the receipt,
// or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically
// generate records for large transfers into it or out of it, which each last for 25 hours. Records are generated for
// any transfer that exceeds the thresholds given here. This account is charged hbar for each record generated, so the
// thresholds are useful for limiting Record generation to happen only for large transactions.
//
// The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0 and realm 0,
// with a null key. Future versions of the API will support multiple realms and multiple shards.
type AccountCreateTransaction struct {
	Transaction
	proxyAccountID                *AccountID
	key                           Key
	initialBalance                uint64
	autoRenewPeriod               *time.Duration
	memo                          string
	receiverSignatureRequired     bool
	maxAutomaticTokenAssociations int32
	stakedAccountID               *AccountID
	stakedNodeID                  *int64
	declineReward                 bool
	alias                         []byte
}

// NewAccountCreateTransaction creates an AccountCreateTransaction transaction which can be used to construct and
// execute a Crypto Create Transaction.
func NewAccountCreateTransaction() *AccountCreateTransaction {
	tx := AccountCreateTransaction{
		Transaction: _NewTransaction(),
	}

	tx.SetAutoRenewPeriod(7890000 * time.Second)
	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _AccountCreateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *AccountCreateTransaction {
	key, _ := _KeyFromProtobuf(pb.GetCryptoCreateAccount().GetKey())
	renew := _DurationFromProtobuf(pb.GetCryptoCreateAccount().GetAutoRenewPeriod())

	var stakedNodeID *int64
	if pb.GetCryptoCreateAccount().GetStakedNodeId() != 0 {
		nodeId := pb.GetCryptoCreateAccount().GetStakedNodeId()
		stakedNodeID = &nodeId
	}
	var stakeAccountID *AccountID
	if pb.GetCryptoCreateAccount().GetStakedAccountId() != nil {
		stakeAccountID = _AccountIDFromProtobuf(pb.GetCryptoCreateAccount().GetStakedAccountId())
	}

	body := AccountCreateTransaction{
		Transaction:                   tx,
		key:                           key,
		initialBalance:                pb.GetCryptoCreateAccount().InitialBalance,
		autoRenewPeriod:               &renew,
		memo:                          pb.GetCryptoCreateAccount().GetMemo(),
		receiverSignatureRequired:     pb.GetCryptoCreateAccount().ReceiverSigRequired,
		maxAutomaticTokenAssociations: pb.GetCryptoCreateAccount().MaxAutomaticTokenAssociations,
		stakedAccountID:               stakeAccountID,
		stakedNodeID:                  stakedNodeID,
		declineReward:                 pb.GetCryptoCreateAccount().GetDeclineReward(),
	}

	if pb.GetCryptoCreateAccount().GetAlias() != nil {
		body.alias = pb.GetCryptoCreateAccount().GetAlias()
	}

	return &body
}

// SetKey sets the key that must sign each transfer out of the account. If RecieverSignatureRequired is true, then it
// must also sign any transfer into the account.
func (tx *AccountCreateTransaction) SetKey(key Key) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.key = key
	return tx
}

// GetKey returns the key that must sign each transfer out of the account.
func (tx *AccountCreateTransaction) GetKey() (Key, error) {
	return tx.key, nil
}

// SetInitialBalance sets the initial number of Hbar to put into the account
func (tx *AccountCreateTransaction) SetInitialBalance(initialBalance Hbar) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.initialBalance = uint64(initialBalance.AsTinybar())
	return tx
}

// GetInitialBalance returns the initial number of Hbar to put into the account
func (tx *AccountCreateTransaction) GetInitialBalance() Hbar {
	return HbarFromTinybar(int64(tx.initialBalance))
}

// SetMaxAutomaticTokenAssociations
// Set the maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
// and up to a maximum value of 1000.
func (tx *AccountCreateTransaction) SetMaxAutomaticTokenAssociations(max int32) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.maxAutomaticTokenAssociations = max
	return tx
}

// GetMaxAutomaticTokenAssociations returns the maximum number of tokens that an Account can be implicitly associated with.
func (tx *AccountCreateTransaction) GetMaxAutomaticTokenAssociations() int32 {
	return tx.maxAutomaticTokenAssociations
}

// SetAutoRenewPeriod sets the time duration for when account is charged to extend its expiration date. When the account
// is created, the payer account is charged enough hbars so that the new account will not expire for the next
// auto renew period. When it reaches the expiration time, the new account will then be automatically charged to
// renew for another auto renew period. If it does not have enough hbars to renew for that long, then the  remaining
// hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires,
// then it is deleted.
func (tx *AccountCreateTransaction) SetAutoRenewPeriod(autoRenewPeriod time.Duration) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = &autoRenewPeriod
	return tx
}

// GetAutoRenewPeriod returns the time duration for when account is charged to extend its expiration date.
func (tx *AccountCreateTransaction) GetAutoRenewPeriod() time.Duration {
	if tx.autoRenewPeriod != nil {
		return *tx.autoRenewPeriod
	}

	return time.Duration(0)
}

// Deprecated
// SetProxyAccountID sets the ID of the account to which this account is proxy staked. If proxyAccountID is not set,
// is an invalid account, or is an account that isn't a _Node, then this account is automatically proxy staked to a _Node
// chosen by the _Network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking ,
// or if it is not currently running a _Node, then it will behave as if proxyAccountID was not set.
func (tx *AccountCreateTransaction) SetProxyAccountID(id AccountID) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.proxyAccountID = &id
	return tx
}

// Deprecated
func (tx *AccountCreateTransaction) GetProxyAccountID() AccountID {
	if tx.proxyAccountID == nil {
		return AccountID{}
	}

	return *tx.proxyAccountID
}

// SetAccountMemo Sets the memo associated with the account (UTF-8 encoding max 100 bytes)
func (tx *AccountCreateTransaction) SetAccountMemo(memo string) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo
	return tx
}

// GetAccountMemo Gets the memo associated with the account (UTF-8 encoding max 100 bytes)
func (tx *AccountCreateTransaction) GetAccountMemo() string {
	return tx.memo
}

// SetStakedAccountID Set the account to which this account will stake.
func (tx *AccountCreateTransaction) SetStakedAccountID(id AccountID) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.stakedAccountID = &id
	return tx
}

// GetStakedAccountID returns the account to which this account will stake.
func (tx *AccountCreateTransaction) GetStakedAccountID() AccountID {
	if tx.stakedAccountID != nil {
		return *tx.stakedAccountID
	}

	return AccountID{}
}

// SetStakedNodeID Set the node to which this account will stake
func (tx *AccountCreateTransaction) SetStakedNodeID(id int64) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.stakedNodeID = &id
	return tx
}

// GetStakedNodeID returns the node to which this account will stake
func (tx *AccountCreateTransaction) GetStakedNodeID() int64 {
	if tx.stakedNodeID != nil {
		return *tx.stakedNodeID
	}

	return 0
}

// SetDeclineStakingReward If set to true, the account declines receiving a staking reward. The default value is false.
func (tx *AccountCreateTransaction) SetDeclineStakingReward(decline bool) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.declineReward = decline
	return tx
}

// GetDeclineStakingReward returns true if the account declines receiving a staking reward.
func (tx *AccountCreateTransaction) GetDeclineStakingReward() bool {
	return tx.declineReward
}

func (tx *AccountCreateTransaction) SetAlias(evmAddress string) *AccountCreateTransaction {
	tx._RequireNotFrozen()

	evmAddress = strings.TrimPrefix(evmAddress, "0x")
	evmAddressBytes, _ := hex.DecodeString(evmAddress)

	tx.alias = evmAddressBytes
	return tx
}

func (tx *AccountCreateTransaction) GetAlias() []byte {
	return tx.alias
}

// SetReceiverSignatureRequired sets the receiverSigRequired flag. If the receiverSigRequired flag is set to true, then
// all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false,
// then only transfers out have to be signed by it. This transaction must be signed by the
// payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the
// keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.
func (tx *AccountCreateTransaction) SetReceiverSignatureRequired(required bool) *AccountCreateTransaction {
	tx.receiverSignatureRequired = required
	return tx
}

// GetReceiverSignatureRequired returns the receiverSigRequired flag.
func (tx *AccountCreateTransaction) GetReceiverSignatureRequired() bool {
	return tx.receiverSignatureRequired
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *AccountCreateTransaction) Sign(
	privateKey PrivateKey,
) *AccountCreateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *AccountCreateTransaction) SignWithOperator(
	client *Client,
) (*AccountCreateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *AccountCreateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *AccountCreateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *AccountCreateTransaction) AddSignature(publicKey PublicKey, signature []byte) *AccountCreateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *AccountCreateTransaction) SetGrpcDeadline(deadline *time.Duration) *AccountCreateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *AccountCreateTransaction) Freeze() (*AccountCreateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *AccountCreateTransaction) FreezeWith(client *Client) (*AccountCreateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// GetMaxTransactionFee returns the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *AccountCreateTransaction) GetMaxTransactionFee() Hbar {
	return tx.Transaction.GetMaxTransactionFee()
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *AccountCreateTransaction) SetMaxTransactionFee(fee Hbar) *AccountCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *AccountCreateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *AccountCreateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this AccountCreateTransaction.
func (tx *AccountCreateTransaction) SetTransactionMemo(memo string) *AccountCreateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this AccountCreateTransaction.
func (tx *AccountCreateTransaction) SetTransactionValidDuration(duration time.Duration) *AccountCreateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *AccountCreateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this AccountCreateTransaction.
func (tx *AccountCreateTransaction) SetTransactionID(transactionID TransactionID) *AccountCreateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountCreateTransaction.
func (tx *AccountCreateTransaction) SetNodeAccountIDs(nodeID []AccountID) *AccountCreateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *AccountCreateTransaction) SetMaxRetry(count int) *AccountCreateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *AccountCreateTransaction) SetMaxBackoff(max time.Duration) *AccountCreateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *AccountCreateTransaction) SetMinBackoff(min time.Duration) *AccountCreateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *AccountCreateTransaction) SetLogLevel(level LogLevel) *AccountCreateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *AccountCreateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *AccountCreateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *AccountCreateTransaction) getName() string {
	return "AccountCreateTransaction"
}

func (tx *AccountCreateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.proxyAccountID != nil {
		if tx.proxyAccountID != nil {
			if err := tx.proxyAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	return nil
}

func (tx *AccountCreateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionID:            tx.transactionID._ToProtobuf(),
		TransactionFee:           tx.transactionFee,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		Memo:                     tx.Transaction.memo,
		Data: &services.TransactionBody_CryptoCreateAccount{
			CryptoCreateAccount: tx.buildProtoBody(),
		},
	}
}
func (tx *AccountCreateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_CryptoCreateAccount{
			CryptoCreateAccount: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *AccountCreateTransaction) buildProtoBody() *services.CryptoCreateTransactionBody {
	body := &services.CryptoCreateTransactionBody{
		InitialBalance:                tx.initialBalance,
		ReceiverSigRequired:           tx.receiverSignatureRequired,
		Memo:                          tx.memo,
		MaxAutomaticTokenAssociations: tx.maxAutomaticTokenAssociations,
		DeclineReward:                 tx.declineReward,
		Alias:                         tx.alias,
	}

	if tx.key != nil {
		body.Key = tx.key._ToProtoKey()
	}

	if tx.autoRenewPeriod != nil {
		body.AutoRenewPeriod = _DurationToProtobuf(*tx.autoRenewPeriod)
	}

	if tx.stakedAccountID != nil {
		body.StakedId = &services.CryptoCreateTransactionBody_StakedAccountId{StakedAccountId: tx.stakedAccountID._ToProtobuf()}
	} else if tx.stakedNodeID != nil {
		body.StakedId = &services.CryptoCreateTransactionBody_StakedNodeId{StakedNodeId: *tx.stakedNodeID}
	}

	return body
}

func (tx *AccountCreateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetCrypto().CreateAccount,
	}
}

func (tx *AccountCreateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: account_create_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationAccountCreateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		SetMaxAutomaticTokenAssociations(100).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tx, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionCanFreezeModify(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(1)

	assert.Equal(t, HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetMaxTransactionFee(NewHbar(2)).
		SetInitialBalance(newBalance).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tx, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetMaxTransactionFee(NewHbar(1)).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx = tx.SetAccountID(accountID)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "transaction is immutable; it has at least one signature or has been explicitly frozen", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionNoKey(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status KEY_REQUIRED received for transaction %s", resp.TransactionID), err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionAddSignature(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(*receipt.AccountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)
	updateBytes, err := tx.ToBytes()
	require.NoError(t, err)

	sig1, err := newKey.SignTransaction(&tx.Transaction)
	require.NoError(t, err)

	tx2, err := TransactionFromBytes(updateBytes)
	require.NoError(t, err)

	if newTx, ok := tx2.(AccountDeleteTransaction); ok {
		resp, err = newTx.AddSignature(newKey.PublicKey(), sig1).Execute(env.Client)
		require.NoError(t, err)
	}

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func DisabledTestIntegrationAccountCreateTransactionSetProxyAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	resp, err = NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		SetProxyAccountID(accountID).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID2 := *receipt.AccountID

	info, err := NewAccountInfoQuery().
		SetAccountID(accountID2).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, accountID.String(), info.ProxyAccountID.String())

	tx, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionNetwork(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	env.Client.SetAutoValidateChecksums(true)

	accountIDString, err := accountID.ToStringWithChecksum(ClientForMainnet())
	require.NoError(t, err)
	accountID, err = AccountIDFromString(accountIDString)
	require.NoError(t, err)

	_, err = NewAccountDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	assert.Error(t, err)

	env.Client.SetAutoValidateChecksums(false)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionWithAliasFromAdminKey(t *testing.T) {
	// Tests the third row of this table
	// https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	adminKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)

	evmAddress := adminKey.PublicKey().ToEvmAddress()

	// Create the admin account
	_, err = NewAccountCreateTransaction().
		SetKey(adminKey).
		Execute(env.Client)
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(adminKey).
		SetAlias(evmAddress).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	info, err := NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(env.Client)
	require.NoError(t, err)

	assert.NotEmpty(t, info.AccountID)
	assert.Equal(t, evmAddress, info.ContractAccountID)
	assert.Equal(t, adminKey.PublicKey(), info.Key)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionWithAliasFromAdminKeyWithReceiverSigRequired(t *testing.T) {
	// Tests the fourth row of this table
	// https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	adminKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)

	evmAddress := adminKey.PublicKey().ToEvmAddress()

	// Create the admin account
	_, err = NewAccountCreateTransaction().
		SetKey(adminKey).
		Execute(env.Client)
	require.NoError(t, err)

	frozenTxn, err := NewAccountCreateTransaction().
		SetReceiverSignatureRequired(true).
		SetKey(adminKey).
		SetAlias(evmAddress).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err := frozenTxn.Sign(adminKey).Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	info, err := NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(env.Client)
	require.NoError(t, err)

	assert.NotEmpty(t, info.AccountID)
	assert.Equal(t, evmAddress, info.ContractAccountID)
	assert.Equal(t, adminKey.PublicKey(), info.Key)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionWithAliasFromAdminKeyWithReceiverSigRequiredWithoutSignature(t *testing.T) {
	// Tests the fourth row of this table
	// https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	adminKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)

	evmAddress := adminKey.PublicKey().ToEvmAddress()

	// Create the admin account
	_, err = NewAccountCreateTransaction().
		SetKey(adminKey).
		Execute(env.Client)
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetReceiverSignatureRequired(true).
		SetKey(adminKey).
		SetAlias(evmAddress).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_SIGNATURE", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionWithAlias(t *testing.T) {
	// Tests the fifth row of this table
	// https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	adminKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Create the admin account
	_, err = NewAccountCreateTransaction().
		SetKey(adminKey).
		Execute(env.Client)
	require.NoError(t, err)

	key, err := PrivateKeyGenerateEcdsa()
	evmAddress := key.PublicKey().ToEvmAddress()

	tx, err := NewAccountCreateTransaction().
		SetKey(adminKey).
		SetAlias(evmAddress).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err := tx.
		Sign(key).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	info, err := NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(env.Client)
	require.NoError(t, err)

	assert.NotEmpty(t, info.AccountID)
	assert.Equal(t, evmAddress, info.ContractAccountID)
	assert.Equal(t, adminKey.PublicKey(), info.Key)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionWithAliasWithoutSignature(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	adminKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Create the admin account
	_, err = NewAccountCreateTransaction().
		SetKey(adminKey).
		Execute(env.Client)
	require.NoError(t, err)

	key, err := PrivateKeyGenerateEcdsa()
	evmAddress := key.PublicKey().ToEvmAddress()

	resp, err := NewAccountCreateTransaction().
		SetKey(adminKey).
		SetAlias(evmAddress).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_SIGNATURE", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionWithAliasWithReceiverSigRequired(t *testing.T) {
	// Tests the sixth row of this table
	// https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	adminKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Create the admin account
	_, err = NewAccountCreateTransaction().
		SetKey(adminKey).
		Execute(env.Client)
	require.NoError(t, err)

	key, err := PrivateKeyGenerateEcdsa()
	evmAddress := key.PublicKey().ToEvmAddress()

	frozenTxn, err := NewAccountCreateTransaction().
		SetReceiverSignatureRequired(true).
		SetKey(adminKey).
		SetAlias(evmAddress).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err := frozenTxn.
		Sign(key).
		Sign(adminKey).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	info, err := NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(env.Client)
	require.NoError(t, err)

	assert.NotEmpty(t, info.AccountID)
	assert.Equal(t, evmAddress, info.ContractAccountID)
	assert.Equal(t, adminKey.PublicKey(), info.Key)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountCreateTransactionWithAliasWithReceiverSigRequiredWithoutSignature(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	adminKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Create the admin account
	_, err = NewAccountCreateTransaction().
		SetKey(adminKey).
		Execute(env.Client)
	require.NoError(t, err)

	key, err := PrivateKeyGenerateEcdsa()
	evmAddress := key.PublicKey().ToEvmAddress()

	frozenTxn, err := NewAccountCreateTransaction().
		SetReceiverSignatureRequired(true).
		SetKey(adminKey).
		SetAlias(evmAddress).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err := frozenTxn.
		Sign(key).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_SIGNATURE", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationSerializeTransactionWithoutNodeAccountIdDeserialiseAndExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	transactionOriginal := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance)

	require.NoError(t, err)
	resp, _ := transactionOriginal.ToBytes()

	txFromBytes, err := TransactionFromBytes(resp)
	require.NoError(t, err)

	transaction := txFromBytes.(AccountCreateTransaction)
	_, err = transaction.
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)

	require.NoError(t, err)
}
// Filename: account_create_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitAccountCreateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	createAccount := NewAccountCreateTransaction().
		SetProxyAccountID(accountID)

	err = createAccount.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitAccountCreateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	createAccount := NewAccountCreateTransaction().
		SetProxyAccountID(accountID)

	err = createAccount.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitAccountCreateTransactionMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		status.New(codes.Unavailable, "node is UNAVAILABLE").Err(),
		status.New(codes.Internal, "Received RST_STREAM with code 0").Err(),
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_COST_ANSWER,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_RECEIPT_NOT_FOUND,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
						AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
							AccountNum: 234,
						}},
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	tran := TransactionIDGenerate(AccountID{Account: 3})

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}, {Account: 4}}).
		SetKey(newKey).
		SetTransactionID(tran).
		SetInitialBalance(newBalance).
		SetMaxAutomaticTokenAssociations(100).
		Execute(client)
	require.NoError(t, err)

	receipt, err := resp.GetReceipt(client)
	require.NoError(t, err)
	require.Equal(t, receipt.AccountID, &AccountID{Account: 234})
}

func TestUnitAccountCreateTransactionGet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}

	key, err := PrivateKeyGenerateEd25519()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKey(key).
		SetAccountMemo("").
		SetReceiverSignatureRequired(true).
		SetMaxAutomaticTokenAssociations(2).
		SetAutoRenewPeriod(60 * time.Second).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetAccountMemo()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxAutomaticTokenAssociations()
	transaction.GetRegenerateTransactionID()
	transaction.GetKey()
	transaction.GetInitialBalance()
	transaction.GetAutoRenewPeriod()
	transaction.GetReceiverSignatureRequired()
}

func TestUnitAccountCreateTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetAccountMemo()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxAutomaticTokenAssociations()
	transaction.GetProxyAccountID()
	transaction.GetRegenerateTransactionID()
	transaction.GetKey()
	transaction.GetInitialBalance()
	transaction.GetAutoRenewPeriod()
	transaction.GetReceiverSignatureRequired()
}

func TestUnitAccountCreateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	stackedAccountID := AccountID{Account: 5}

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	alias := "5c562e90feaf0eebd33ea75d21024f249d451417"

	transaction, err := NewAccountCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKey(key).
		SetInitialBalance(NewHbar(3)).
		SetAccountMemo("ty").
		SetReceiverSignatureRequired(true).
		SetMaxAutomaticTokenAssociations(2).
		SetStakedAccountID(stackedAccountID).
		SetDeclineStakingReward(true).
		SetAutoRenewPeriod(60 * time.Second).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetAlias(alias).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetCryptoCreateAccount()
	require.Equal(t, proto.Key.String(), key._ToProtoKey().String())
	require.Equal(t, proto.InitialBalance, uint64(NewHbar(3).AsTinybar()))
	require.Equal(t, proto.Memo, "ty")
	require.Equal(t, proto.ReceiverSigRequired, true)
	require.Equal(t, proto.MaxAutomaticTokenAssociations, int32(2))
	require.Equal(t, proto.StakedId.(*services.CryptoCreateTransactionBody_StakedAccountId).StakedAccountId.String(),
		stackedAccountID._ToProtobuf().String())
	require.Equal(t, proto.DeclineReward, true)
	require.Equal(t, proto.AutoRenewPeriod.String(), _DurationToProtobuf(60*time.Second).String())
	require.Equal(t, hex.EncodeToString(proto.Alias), alias)
}

func TestUnitAccountCreateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	alias := "5c562e90feaf0eebd33ea75d21024f249d451417"

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	trx, err := NewAccountCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKey(key).
		SetInitialBalance(NewHbar(3)).
		SetAccountMemo("ty").
		SetReceiverSignatureRequired(true).
		SetMaxAutomaticTokenAssociations(2).
		SetStakedAccountID(account).
		SetStakedNodeID(4).
		SetDeclineStakingReward(true).
		SetAutoRenewPeriod(60 * time.Second).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		SetAlias(alias).
		Freeze()
	require.NoError(t, err)

	trx.validateNetworkOnIDs(client)
	_, err = trx.Schedule()
	require.NoError(t, err)
	trx.GetTransactionID()
	trx.GetNodeAccountIDs()
	trx.GetMaxRetry()
	trx.GetMaxTransactionFee()
	trx.GetMaxBackoff()
	trx.GetMinBackoff()
	trx.GetRegenerateTransactionID()
	byt, err := trx.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := key.SignTransaction(&trx.Transaction)
	require.NoError(t, err)

	_, err = trx.GetTransactionHash()
	require.NoError(t, err)
	trx.GetMaxTransactionFee()
	trx.GetTransactionMemo()
	trx.GetRegenerateTransactionID()
	trx.GetStakedAccountID()
	trx.GetStakedNodeID()
	trx.GetDeclineStakingReward()
	trx.GetAlias()
	_, err = trx.GetSignatures()
	require.NoError(t, err)
	trx.getName()
	switch b := txFromBytes.(type) {
	case AccountCreateTransaction:
		b.AddSignature(key.PublicKey(), sig)
	}
}
// Filename: account_delete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// AccountDeleteTransaction
// Mark an account as deleted, moving all its current hbars to another account. It will remain in
// the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a
// deleted account can still have its expiration extended in the normal way.
type AccountDeleteTransaction struct {
	Transaction
	transferAccountID *AccountID
	deleteAccountID   *AccountID
}

func _AccountDeleteTransactionFromProtobuf(transaction Transaction, pb *services.TransactionBody) *AccountDeleteTransaction {
	return &AccountDeleteTransaction{
		Transaction:       transaction,
		transferAccountID: _AccountIDFromProtobuf(pb.GetCryptoDelete().GetTransferAccountID()),
		deleteAccountID:   _AccountIDFromProtobuf(pb.GetCryptoDelete().GetDeleteAccountID()),
	}
}

// NewAccountDeleteTransaction creates AccountDeleteTransaction which marks an account as deleted, moving all its current hbars to another account. It will remain in
// the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a
// deleted account can still have its expiration extended in the normal way.
func NewAccountDeleteTransaction() *AccountDeleteTransaction {
	tx := AccountDeleteTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

// SetNodeAccountID sets the _Node AccountID for this AccountDeleteTransaction.
func (tx *AccountDeleteTransaction) SetAccountID(accountID AccountID) *AccountDeleteTransaction {
	tx._RequireNotFrozen()
	tx.deleteAccountID = &accountID
	return tx
}

// GetAccountID returns the AccountID which will be deleted.
func (tx *AccountDeleteTransaction) GetAccountID() AccountID {
	if tx.deleteAccountID == nil {
		return AccountID{}
	}

	return *tx.deleteAccountID
}

// SetTransferAccountID sets the AccountID which will receive all remaining hbars.
func (tx *AccountDeleteTransaction) SetTransferAccountID(transferAccountID AccountID) *AccountDeleteTransaction {
	tx._RequireNotFrozen()
	tx.transferAccountID = &transferAccountID
	return tx
}

// GetTransferAccountID returns the AccountID which will receive all remaining hbars.
func (tx *AccountDeleteTransaction) GetTransferAccountID() AccountID {
	if tx.transferAccountID == nil {
		return AccountID{}
	}

	return *tx.transferAccountID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *AccountDeleteTransaction) Sign(
	privateKey PrivateKey,
) *AccountDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *AccountDeleteTransaction) SignWithOperator(
	client *Client,
) (*AccountDeleteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *AccountDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *AccountDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *AccountDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *AccountDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *AccountDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *AccountDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *AccountDeleteTransaction) Freeze() (*AccountDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *AccountDeleteTransaction) FreezeWith(client *Client) (*AccountDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *AccountDeleteTransaction) SetMaxTransactionFee(fee Hbar) *AccountDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *AccountDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *AccountDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this AccountDeleteTransaction.
func (tx *AccountDeleteTransaction) SetTransactionMemo(memo string) *AccountDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this AccountDeleteTransaction.
func (tx *AccountDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *AccountDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *AccountDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this AccountDeleteTransaction.
func (tx *AccountDeleteTransaction) SetTransactionID(transactionID TransactionID) *AccountDeleteTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountDeleteTransaction.
func (tx *AccountDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *AccountDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *AccountDeleteTransaction) SetMaxRetry(count int) *AccountDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries. Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *AccountDeleteTransaction) SetMaxBackoff(max time.Duration) *AccountDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// GetMaxBackoff returns the maximum amount of time to wait between retries.
func (tx *AccountDeleteTransaction) SetMinBackoff(min time.Duration) *AccountDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *AccountDeleteTransaction) SetLogLevel(level LogLevel) *AccountDeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *AccountDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *AccountDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *AccountDeleteTransaction) getName() string {
	return "AccountDeleteTransaction"
}
func (tx *AccountDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.deleteAccountID != nil {
		if err := tx.deleteAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.transferAccountID != nil {
		if err := tx.transferAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *AccountDeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_CryptoDelete{
			CryptoDelete: tx.buildProtoBody(),
		},
	}
}

func (tx *AccountDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_CryptoDelete{
			CryptoDelete: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *AccountDeleteTransaction) buildProtoBody() *services.CryptoDeleteTransactionBody {
	body := &services.CryptoDeleteTransactionBody{}

	if tx.transferAccountID != nil {
		body.TransferAccountID = tx.transferAccountID._ToProtobuf()
	}

	if tx.deleteAccountID != nil {
		body.DeleteAccountID = tx.deleteAccountID._ToProtobuf()
	}

	return body
}

func (tx *AccountDeleteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetCrypto().ApproveAllowances,
	}
}

func (tx *AccountDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: account_delete_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationAccountDeleteTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := receipt.AccountID
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(*accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransactionID(TransactionIDGenerate(*accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx = tx.Sign(newKey)

	assert.True(t, newKey.PublicKey().VerifyTransaction(tx.Transaction))
	assert.False(t, env.Client.GetOperatorPublicKey().VerifyTransaction(tx.Transaction))

	resp, err = tx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountDeleteTransactionNoTransferAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := receipt.AccountID
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(*accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.Sign(newKey).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status ACCOUNT_ID_DOES_NOT_EXIST received for transaction %s", resp.TransactionID), err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountDeleteTransactionNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.Sign(newKey).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status ACCOUNT_ID_DOES_NOT_EXIST received for transaction %s", resp.TransactionID), err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountDeleteTransactionNoSigning(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := receipt.AccountID
	require.NoError(t, err)

	acc := *accountID

	resp, err = NewAccountDeleteTransaction().
		SetAccountID(acc).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_SIGNATURE", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountDeleteTransactionCannotDeleteWithPendingAirdrops(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create ft and nft
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftSerials := receipt.SerialNumbers

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver).
		AddTokenTransfer(tokenID, receiver, 100).
		AddTokenTransfer(tokenID, env.OperatorID, -100).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// verify the pending airdrop record
	assert.Equal(t, 3, len(record.PendingAirdropRecords))

	// Try to delete the sender
	accountDeleteResp, err := NewAccountDeleteTransaction().
		SetAccountID(env.OperatorID).
		SetTransferAccountID(receiver).
		Execute(env.Client)
	receipt, err = accountDeleteResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "ACCOUNT_HAS_PENDING_AIRDROPS")
}
// Filename: account_delete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/require"
)

func TestUnitAccountDeleteTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	deleteAccount := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(accountID)

	err = deleteAccount.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitAccountDeleteTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	deleteAccount := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(accountID)

	err = deleteAccount.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitAccountDeleteTransactionGet(t *testing.T) {
	t.Parallel()

	spenderAccountID1 := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTransferAccountID(spenderAccountID1).
		SetAccountID(spenderAccountID1).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetTransferAccountID()
	transaction.GetAccountID()
}

func TestUnitAccountDeleteTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetTransferAccountID()
	transaction.GetAccountID()
}

func TestUnitAccountDeleteTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	spenderAccountID1 := AccountID{Account: 7}
	transferAccountID := AccountID{Account: 8}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTransferAccountID(transferAccountID).
		SetAccountID(spenderAccountID1).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetCryptoDelete()
	require.Equal(t, proto.TransferAccountID.String(), transferAccountID._ToProtobuf().String())
	require.Equal(t, proto.DeleteAccountID.String(), spenderAccountID1._ToProtobuf().String())
}

func TestUnitAccountDeleteTransactionTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 3
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewAccountDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAccountID(account).
		SetTransferAccountID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetTransferAccountID()
	transaction.getName()
	switch b := txFromBytes.(type) {
	case AccountDeleteTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitAccountDeleteTransactionTransactionMock(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 3}}
	transactionID := TransactionIDGenerate(AccountID{Account: 3})

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewAccountDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAccountID(AccountID{Account: 3}).
		Execute(client)
	require.NoError(t, err)
}
// Filename: account_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/pkg/errors"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// AccountID is the ID for a Hedera account
type AccountID struct {
	Shard           uint64
	Realm           uint64
	Account         uint64
	AliasKey        *PublicKey
	AliasEvmAddress *[]byte
	checksum        *string
}

type _AccountIDs struct { //nolint
	accountIDs []AccountID
}

// AccountIDFromString constructs an AccountID from a string formatted as
// `Shard.Realm.Account` (for example "0.0.3")
func AccountIDFromString(data string) (AccountID, error) {
	shard, realm, num, checksum, alias, aliasEvmAddress, err := _AccountIDFromString(data)
	if err != nil {
		return AccountID{}, err
	}

	if num == -1 {
		if alias != nil {
			return AccountID{
				Shard:           uint64(shard),
				Realm:           uint64(realm),
				Account:         0,
				AliasKey:        alias,
				AliasEvmAddress: nil,
				checksum:        checksum,
			}, nil
		}

		return AccountID{
			Shard:           uint64(shard),
			Realm:           uint64(realm),
			Account:         0,
			AliasKey:        nil,
			AliasEvmAddress: aliasEvmAddress,
			checksum:        checksum,
		}, nil
	}

	return AccountID{
		Shard:           uint64(shard),
		Realm:           uint64(realm),
		Account:         uint64(num),
		AliasKey:        nil,
		AliasEvmAddress: nil,
		checksum:        checksum,
	}, nil
}

// AccountIDFromEvmAddress constructs an AccountID from a string formatted as 0.0.<evm address>
func AccountIDFromEvmAddress(shard uint64, realm uint64, aliasEvmAddress string) (AccountID, error) {
	temp, err := hex.DecodeString(aliasEvmAddress)
	if err != nil {
		return AccountID{}, err
	}
	return AccountID{
		Shard:           shard,
		Realm:           realm,
		Account:         0,
		AliasEvmAddress: &temp,
		checksum:        nil,
	}, nil
}

// Returns an AccountID with EvmPublic address for the use of HIP-583
func AccountIDFromEvmPublicAddress(s string) (AccountID, error) {
	return AccountIDFromString(s)
}

// AccountIDFromSolidityAddress constructs an AccountID from a string
// representation of a _Solidity address
func AccountIDFromSolidityAddress(s string) (AccountID, error) {
	shard, realm, account, err := _IdFromSolidityAddress(s)
	if err != nil {
		return AccountID{}, err
	}

	return AccountID{
		Shard:    shard,
		Realm:    realm,
		Account:  account,
		checksum: nil,
	}, nil
}

// Verify that the client has a valid checksum.
func (id *AccountID) ValidateChecksum(client *Client) error {
	if id.AliasKey != nil {
		return errors.New("Account ID contains alias key, unable to validate")
	}
	if !id._IsZero() && client != nil {
		var tempChecksum _ParseAddressResult
		var err error
		tempChecksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Account))
		if err != nil {
			return err
		}
		err = _ChecksumVerify(tempChecksum.status)
		if err != nil {
			return err
		}
		if id.checksum == nil {
			return errChecksumMissing
		}
		if tempChecksum.correctChecksum != *id.checksum {
			networkName := NetworkNameOther
			if client.network.ledgerID != nil {
				networkName, _ = client.network.ledgerID.ToNetworkName()
			}
			return errors.New(fmt.Sprintf("network mismatch or wrong checksum given, given checksum: %s, correct checksum %s, network: %s",
				*id.checksum,
				tempChecksum.correctChecksum,
				networkName))
		}
	}

	return nil
}

// Deprecated - use ValidateChecksum instead
func (id *AccountID) Validate(client *Client) error {
	return id.ValidateChecksum(client)
}

// String returns the string representation of an AccountID in
// `Shard.Realm.Account` (for example "0.0.3")
func (id AccountID) String() string {
	if id.AliasKey != nil {
		return fmt.Sprintf("%d.%d.%s", id.Shard, id.Realm, id.AliasKey.String())
	} else if id.AliasEvmAddress != nil {
		return fmt.Sprintf("%d.%d.%s", id.Shard, id.Realm, hex.EncodeToString(*id.AliasEvmAddress))
	}

	return fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Account)
}

// ToStringWithChecksum returns the string representation of an AccountID in
// `Shard.Realm.Account-checksum` (for example "0.0.3-sdaf")
func (id AccountID) ToStringWithChecksum(client *Client) (string, error) {
	if id.AliasKey != nil {
		return "", errors.New("Account ID contains alias key, unable get checksum")
	}
	if client.GetNetworkName() == nil && client.GetLedgerID() == nil {
		return "", errNetworkNameMissing
	}
	var checksum _ParseAddressResult
	var err error
	if client.network.ledgerID != nil {
		checksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Account))
	}
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%d.%d.%d-%s", id.Shard, id.Realm, id.Account, checksum.correctChecksum), nil
}

// GetChecksum Retrieve just the checksum
func (id AccountID) GetChecksum() *string {
	return id.checksum
}

// ToSolidityAddress returns the string representation of the AccountID as a
// _Solidity address.
func (id AccountID) ToSolidityAddress() string {
	return _IdToSolidityAddress(id.Shard, id.Realm, id.Account)
}

func (id AccountID) _ToProtobuf() *services.AccountID {
	resultID := &services.AccountID{
		ShardNum: int64(id.Shard),
		RealmNum: int64(id.Realm),
	}
	if id.AliasKey != nil {
		data, _ := protobuf.Marshal(id.AliasKey._ToProtoKey())
		resultID.Account = &services.AccountID_Alias{
			Alias: data,
		}

		return resultID
	} else if id.AliasEvmAddress != nil {
		resultID.Account = &services.AccountID_Alias{
			Alias: *id.AliasEvmAddress,
		}

		return resultID
	}

	resultID.Account = &services.AccountID_AccountNum{
		AccountNum: int64(id.Account),
	}

	return resultID
}

// UnmarshalJSON implements the encoding.JSON interface.
func (id *AccountID) UnmarshalJSON(data []byte) error {
	accountID, err := AccountIDFromString(strings.Replace(string(data), "\"", "", 2))

	if err != nil {
		return err
	}

	*id = accountID

	return nil
}

func _AccountIDFromProtobuf(accountID *services.AccountID) *AccountID {
	if accountID == nil {
		return nil
	}
	resultAccountID := &AccountID{
		Shard: uint64(accountID.ShardNum),
		Realm: uint64(accountID.RealmNum),
	}

	switch t := accountID.Account.(type) {
	case *services.AccountID_Alias:
		pb := services.Key{}
		_ = protobuf.Unmarshal(t.Alias, &pb)
		initialKey, err := _KeyFromProtobuf(&pb)
		if err != nil && t.Alias != nil {
			resultAccountID.Account = 0
			resultAccountID.AliasEvmAddress = &t.Alias
			return resultAccountID
		}
		if evm, ok := pb.Key.(*services.Key_ECDSASecp256K1); ok && len(evm.ECDSASecp256K1) == 20 {
			resultAccountID.Account = 0
			resultAccountID.AliasEvmAddress = &evm.ECDSASecp256K1
			return resultAccountID
		}
		switch t2 := initialKey.(type) {
		case PublicKey:
			resultAccountID.Account = 0
			resultAccountID.AliasKey = &t2
			return resultAccountID
		default:
			return &AccountID{}
		}
	case *services.AccountID_AccountNum:
		resultAccountID.Account = uint64(t.AccountNum)
		resultAccountID.AliasKey = nil
		return resultAccountID
	default:
		return &AccountID{}
	}
}

// IsZero returns true if this AccountID is the zero-value
func (id AccountID) IsZero() bool {
	return id._IsZero()
}

func (id AccountID) _IsZero() bool {
	return id.Shard == 0 && id.Realm == 0 && id.Account == 0 && id.AliasKey == nil
}

// Equals returns true if this AccountID and the given AccountID are identical
func (id AccountID) Equals(other AccountID) bool {
	return id._Equals(other)
}

func (id AccountID) _Equals(other AccountID) bool {
	initialAlias := ""
	otherAlias := ""
	if id.AliasKey != nil && other.AliasKey != nil {
		initialAlias = id.AliasKey.String()
		otherAlias = other.AliasKey.String()
	}

	return id.Shard == other.Shard && id.Realm == other.Realm && id.Account == other.Account && initialAlias == otherAlias
}

// ToBytes returns the wire-format encoding of AccountID
func (id AccountID) ToBytes() []byte {
	data, err := protobuf.Marshal(id._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// AccountIDFromBytes converts wire-format encoding to Account ID
func AccountIDFromBytes(data []byte) (AccountID, error) {
	if data == nil {
		return AccountID{}, errByteArrayNull
	}
	pb := services.AccountID{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return AccountID{}, err
	}

	return *_AccountIDFromProtobuf(&pb), nil
}

type PopulateType int

const (
	Account PopulateType = iota
	EvmAddress
)

func (id *AccountID) _MirrorNodeRequest(client *Client, populateType string) (map[string]interface{}, error) {
	if client.mirrorNetwork == nil || len(client.GetMirrorNetwork()) == 0 {
		return nil, errors.New("mirror node is not set")
	}

	mirrorUrl := client.GetMirrorNetwork()[0]
	index := strings.Index(mirrorUrl, ":")
	if index == -1 {
		return nil, errors.New("invalid mirrorUrl format")
	}
	mirrorUrl = mirrorUrl[:index]

	var url string
	protocol := "https"
	port := ""

	if client.GetLedgerID().String() == "" {
		protocol = "http"
		port = ":5551"
	}

	if populateType == "account" {
		url = fmt.Sprintf("%s://%s%s/api/v1/accounts/%s", protocol, mirrorUrl, port, hex.EncodeToString(*id.AliasEvmAddress))
	} else {
		url = fmt.Sprintf("%s://%s%s/api/v1/accounts/%s", protocol, mirrorUrl, port, id.String())
	}

	resp, err := http.Get(url) // #nosec
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result, nil
}

// PopulateAccount gets the actual `Account` field of the `AccountId` from the Mirror Node.
// Should be used after generating `AccountId.FromEvmAddress()` because it sets the `Account` field to `0`
// automatically since there is no connection between the `Account` and the `evmAddress`
func (id *AccountID) PopulateAccount(client *Client) error {
	result, err := id._MirrorNodeRequest(client, "account")
	if err != nil {
		return err
	}

	mirrorAccountId, ok := result["account"].(string)
	if !ok {
		return errors.New("unexpected response format")
	}

	numStr := mirrorAccountId[strings.LastIndex(mirrorAccountId, ".")+1:]
	num, err := strconv.ParseInt(numStr, 10, 64)
	if err != nil {
		return err
	}
	id.Account = uint64(num)
	return nil
}

// PopulateEvmAddress gets the actual `AliasEvmAddress` field of the `AccountId` from the Mirror Node.
func (id *AccountID) PopulateEvmAddress(client *Client) error {
	result, err := id._MirrorNodeRequest(client, "evmAddress")
	if err != nil {
		return err
	}

	mirrorEvmAddress, ok := result["evm_address"].(string)
	if !ok {
		return errors.New("unexpected response format")
	}

	mirrorEvmAddress = strings.TrimPrefix(mirrorEvmAddress, "0x")
	asd, err := hex.DecodeString(mirrorEvmAddress)
	if err != nil {
		return err
	}
	id.AliasEvmAddress = &asd
	return nil
}

// Compare returns 0 if the two AccountID are identical, -1 if not.
func (id AccountID) Compare(given AccountID) int {
	if id.Shard > given.Shard { //nolint
		return 1
	} else if id.Shard < given.Shard {
		return -1
	}

	if id.Realm > given.Realm { //nolint
		return 1
	} else if id.Realm < given.Realm {
		return -1
	}

	if id.AliasKey != nil && given.AliasKey != nil {
		if id.AliasKey.String() > given.AliasKey.String() { //nolint
			return 1
		} else if id.AliasKey.String() < given.AliasKey.String() {
			return -1
		}
	}

	if id.AliasEvmAddress != nil && given.AliasEvmAddress != nil {
		originalEvmAddress := hex.EncodeToString(*id.AliasEvmAddress)
		givenEvmAddress := hex.EncodeToString(*given.AliasEvmAddress)
		if originalEvmAddress > givenEvmAddress { //nolint
			return 1
		} else if originalEvmAddress < givenEvmAddress {
			return -1
		}
	}

	if id.Account > given.Account { //nolint
		return 1
	} else if id.Account < given.Account {
		return -1
	} else {
		return 0
	}
}

// Len returns the number of elements in the collection.
func (accountIDs _AccountIDs) Len() int { //nolint
	return len(accountIDs.accountIDs)
}

func (accountIDs _AccountIDs) Swap(i, j int) { //nolint
	accountIDs.accountIDs[i], accountIDs.accountIDs[j] = accountIDs.accountIDs[j], accountIDs.accountIDs[i]
}

func (accountIDs _AccountIDs) Less(i, j int) bool { //nolint
	if accountIDs.accountIDs[i].Compare(accountIDs.accountIDs[j]) < 0 { //nolint
		return true
	}

	return false
}
// Filename: account_id_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestIntegrationAccountIDCanPopulateAccountNumber(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := privateKey.PublicKey()
	evmAddress := publicKey.ToEvmAddress()
	evmAddressAccount, err := AccountIDFromEvmPublicAddress(evmAddress)
	require.NoError(t, err)
	tx, err := NewTransferTransaction().AddHbarTransfer(evmAddressAccount, NewHbar(1)).
		AddHbarTransfer(env.OperatorID, NewHbar(-1)).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := tx.SetIncludeChildren(true).SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	newAccountId := *receipt.Children[0].AccountID
	idMirror, err := AccountIDFromEvmPublicAddress(evmAddress)
	require.NoError(t, err)
	time.Sleep(5 * time.Second)
	error := idMirror.PopulateAccount(env.Client)
	require.NoError(t, error)
	require.Equal(t, newAccountId.Account, idMirror.Account)
}

func TestIntegrationAccountIDCanPopulateAccountAliasEvmAddress(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := privateKey.PublicKey()
	evmAddress := publicKey.ToEvmAddress()
	evmAddressAccount, err := AccountIDFromEvmPublicAddress(evmAddress)
	require.NoError(t, err)
	tx, err := NewTransferTransaction().AddHbarTransfer(evmAddressAccount, NewHbar(1)).
		AddHbarTransfer(env.OperatorID, NewHbar(-1)).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := tx.SetIncludeChildren(true).SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	newAccountId := *receipt.Children[0].AccountID
	time.Sleep(5 * time.Second)
	error := newAccountId.PopulateEvmAddress(env.Client)
	require.NoError(t, error)
	require.Equal(t, evmAddress, hex.EncodeToString(*newAccountId.AliasEvmAddress))
}

func TestIntegrationAccountIDCanPopulateAccountAliasEvmAddressWithMirror(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := privateKey.PublicKey()
	evmAddress := publicKey.ToEvmAddress()
	evmAddressAccount, err := AccountIDFromEvmPublicAddress(evmAddress)
	require.NoError(t, err)
	tx, err := NewTransferTransaction().AddHbarTransfer(evmAddressAccount, NewHbar(1)).
		AddHbarTransfer(env.OperatorID, NewHbar(-1)).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := tx.SetIncludeChildren(true).SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	newAccountId := *receipt.Children[0].AccountID
	time.Sleep(5 * time.Second)
	error := newAccountId.PopulateEvmAddress(env.Client)
	require.NoError(t, error)
	require.Equal(t, evmAddress, hex.EncodeToString(*newAccountId.AliasEvmAddress))
}

func TestIntegrationAccountIDCanPopulateAccountAliasEvmAddressWithNoMirror(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	env.Client.mirrorNetwork = nil
	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := privateKey.PublicKey()
	evmAddress := publicKey.ToEvmAddress()
	evmAddressAccount, err := AccountIDFromEvmPublicAddress(evmAddress)
	require.NoError(t, err)
	tx, err := NewTransferTransaction().AddHbarTransfer(evmAddressAccount, NewHbar(1)).
		AddHbarTransfer(env.OperatorID, NewHbar(-1)).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := tx.SetIncludeChildren(true).SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	newAccountId := *receipt.Children[0].AccountID
	env.Client.mirrorNetwork = nil
	time.Sleep(5 * time.Second)
	error := newAccountId.PopulateEvmAddress(env.Client)
	require.Error(t, error)
}

func TestIntegrationAccountIDCanPopulateAccountAliasEvmAddressWithMirrorAndNoEvmAddress(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	env.Client.mirrorNetwork = nil
	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := privateKey.PublicKey()
	evmAddress := publicKey.ToEvmAddress()
	evmAddressAccount, err := AccountIDFromEvmPublicAddress(evmAddress)
	require.NoError(t, err)
	tx, err := NewTransferTransaction().AddHbarTransfer(evmAddressAccount, NewHbar(1)).
		AddHbarTransfer(env.OperatorID, NewHbar(-1)).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := tx.SetIncludeChildren(true).SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	newAccountId := *receipt.Children[0].AccountID
	env.Client.mirrorNetwork = nil
	time.Sleep(5 * time.Second)
	error := newAccountId.PopulateAccount(env.Client)
	require.Error(t, error)
}
// Filename: account_id_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitAccountIDChecksumFromString(t *testing.T) {
	t.Parallel()

	id, err := AccountIDFromString("0.0.123-rmkyk")
	require.NoError(t, err)
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	id.ToStringWithChecksum(client)
	id.GetChecksum()
	sol := id.ToSolidityAddress()
	AccountIDFromSolidityAddress(sol)
	err = id.Validate(client)
	require.Error(t, err)
	evmID, err := AccountIDFromEvmAddress(0, 0, "ace082947b949651c703ff0f02bc1541")
	require.NoError(t, err)
	pb := evmID._ToProtobuf()
	_AccountIDFromProtobuf(pb)

	idByte := id.ToBytes()
	AccountIDFromBytes(idByte)

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	alias := key.ToAccountID(0, 0)
	pb = alias._ToProtobuf()
	_AccountIDFromProtobuf(pb)

	require.NoError(t, err)
	assert.Equal(t, id.Account, uint64(123))
}

func TestUnitAccountIDChecksumToString(t *testing.T) {
	t.Parallel()

	id := AccountID{
		Shard:   50,
		Realm:   150,
		Account: 520,
	}
	assert.Equal(t, "50.150.520", id.String())
}

func TestUnitAccountIDFromStringAlias(t *testing.T) {
	t.Parallel()

	key, err := GeneratePrivateKey()
	require.NoError(t, err)
	id, err := AccountIDFromString("0.0." + key.PublicKey().String())
	require.NoError(t, err)
	id2 := key.ToAccountID(0, 0)

	assert.Equal(t, id.String(), id2.String())
}

func TestUnitChecksum(t *testing.T) {
	t.Parallel()

	id, err := LedgerIDFromString("01")
	require.NoError(t, err)
	ad1, err := _ChecksumParseAddress(id, "0.0.3")
	require.NoError(t, err)
	id, err = LedgerIDFromString("10")
	require.NoError(t, err)
	ad2, err := _ChecksumParseAddress(id, "0.0.3")
	require.NoError(t, err)

	require.NotEqual(t, ad1.correctChecksum, ad2.correctChecksum)
}

func TestUnitAccountIDEvm(t *testing.T) {
	t.Parallel()

	id, err := AccountIDFromString("0.0.0011223344556677889900112233445566778899")
	require.NoError(t, err)

	require.Equal(t, id.String(), "0.0.0011223344556677889900112233445566778899")
}

func TestUnitAccountIDPopulateFailForWrongMirrorHost(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.SetLedgerID(*NewLedgerIDTestnet())
	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := privateKey.PublicKey()
	evmAddress := publicKey.ToEvmAddress()
	evmAddressAccountID, err := AccountIDFromEvmPublicAddress(evmAddress)
	require.NoError(t, err)
	err = evmAddressAccountID.PopulateAccount(client)
	require.Error(t, err)
}

func TestUnitAccountIDPopulateFailWithNoMirror(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.mirrorNetwork = nil
	client.SetLedgerID(*NewLedgerIDTestnet())
	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := privateKey.PublicKey()
	evmAddress := publicKey.ToEvmAddress()
	evmAddressAccountID, err := AccountIDFromEvmPublicAddress(evmAddress)
	require.NoError(t, err)
	err = evmAddressAccountID.PopulateAccount(client)
	require.Error(t, err)
}

func TestUnitAccountIDPopulateEvmFailForWrongMirrorHost(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.SetLedgerID(*NewLedgerIDTestnet())
	id, err := AccountIDFromString("0.0.3")
	require.NoError(t, err)
	err = id.PopulateEvmAddress(client)
	require.Error(t, err)
}

func TestUnitAccountIDPopulateEvmFailWithNoMirror(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.mirrorNetwork = nil
	client.SetLedgerID(*NewLedgerIDTestnet())
	id, err := AccountIDFromString("0.0.3")
	require.NoError(t, err)
	err = id.PopulateEvmAddress(client)
	require.Error(t, err)
}

func TestUnitAccountIDPopulateEvmFailWithNoMirrorNetwork(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.mirrorNetwork = nil
	client.SetLedgerID(*NewLedgerIDTestnet())
	id, err := AccountIDFromString("0.0.3")
	require.NoError(t, err)
	err = id.PopulateEvmAddress(client)
	require.Error(t, err)
}
// Filename: account_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// AccountInfo is info about the account returned from an AccountInfoQuery
type AccountInfo struct {
	AccountID         AccountID
	ContractAccountID string
	IsDeleted         bool
	// Deprecated
	ProxyAccountID                 AccountID
	ProxyReceived                  Hbar
	Key                            Key
	Balance                        Hbar
	GenerateSendRecordThreshold    Hbar
	GenerateReceiveRecordThreshold Hbar
	ReceiverSigRequired            bool
	ExpirationTime                 time.Time
	AutoRenewPeriod                time.Duration
	LiveHashes                     []*LiveHash
	TokenRelationships             []*TokenRelationship
	AccountMemo                    string
	OwnedNfts                      int64
	MaxAutomaticTokenAssociations  uint32
	AliasKey                       *PublicKey
	LedgerID                       LedgerID
	// Deprecated
	HbarAllowances []HbarAllowance
	// Deprecated
	NftAllowances []TokenNftAllowance
	// Deprecated
	TokenAllowances []TokenAllowance
	EthereumNonce   int64
	StakingInfo     *StakingInfo
}

func _AccountInfoFromProtobuf(pb *services.CryptoGetInfoResponse_AccountInfo) (AccountInfo, error) {
	if pb == nil {
		return AccountInfo{}, errParameterNull
	}

	pubKey, err := _KeyFromProtobuf(pb.Key)
	if err != nil {
		return AccountInfo{}, err
	}
	liveHashes := make([]*LiveHash, len(pb.LiveHashes))

	if pb.LiveHashes != nil {
		for i, liveHash := range pb.LiveHashes {
			singleRelationship, err := _LiveHashFromProtobuf(liveHash)
			if err != nil {
				return AccountInfo{}, err
			}
			liveHashes[i] = &singleRelationship
		}
	}

	accountID := AccountID{}
	if pb.AccountID != nil {
		accountID = *_AccountIDFromProtobuf(pb.AccountID)
	}

	var alias *PublicKey
	if len(pb.Alias) != 0 {
		pbKey := services.Key{}
		_ = protobuf.Unmarshal(pb.Alias, &pbKey)
		initialKey, _ := _KeyFromProtobuf(&pbKey)
		switch t2 := initialKey.(type) { //nolint
		case PublicKey:
			alias = &t2
		}
	}

	var stakingInfo StakingInfo
	if pb.StakingInfo != nil {
		stakingInfo = _StakingInfoFromProtobuf(pb.StakingInfo)
	}

	var tokenRelationships []*TokenRelationship
	if pb.TokenRelationships != nil { // nolint
		tokenRelationships = _TokenRelationshipsFromProtobuf(pb.TokenRelationships) // nolint
	}

	return AccountInfo{
		AccountID:                      accountID,
		ContractAccountID:              pb.ContractAccountID,
		IsDeleted:                      pb.Deleted,
		ProxyReceived:                  HbarFromTinybar(pb.ProxyReceived),
		Key:                            pubKey,
		Balance:                        HbarFromTinybar(int64(pb.Balance)),
		GenerateSendRecordThreshold:    HbarFromTinybar(int64(pb.GenerateSendRecordThreshold)),    // nolint
		GenerateReceiveRecordThreshold: HbarFromTinybar(int64(pb.GenerateReceiveRecordThreshold)), // nolint
		ReceiverSigRequired:            pb.ReceiverSigRequired,
		ExpirationTime:                 _TimeFromProtobuf(pb.ExpirationTime),
		AccountMemo:                    pb.Memo,
		AutoRenewPeriod:                _DurationFromProtobuf(pb.AutoRenewPeriod),
		LiveHashes:                     liveHashes,
		TokenRelationships:             tokenRelationships,
		OwnedNfts:                      pb.OwnedNfts,
		MaxAutomaticTokenAssociations:  uint32(pb.MaxAutomaticTokenAssociations),
		AliasKey:                       alias,
		LedgerID:                       LedgerID{pb.LedgerId},
		EthereumNonce:                  pb.EthereumNonce,
		StakingInfo:                    &stakingInfo,
	}, nil
}

func (info AccountInfo) _ToProtobuf() *services.CryptoGetInfoResponse_AccountInfo {
	liveHashes := make([]*services.LiveHash, len(info.LiveHashes))

	for i, liveHash := range info.LiveHashes {
		singleRelationship := liveHash._ToProtobuf()
		liveHashes[i] = singleRelationship
	}

	var alias []byte
	if info.AliasKey != nil {
		alias, _ = protobuf.Marshal(info.AliasKey._ToProtoKey())
	}

	body := &services.CryptoGetInfoResponse_AccountInfo{
		AccountID:                      info.AccountID._ToProtobuf(),
		ContractAccountID:              info.ContractAccountID,
		Deleted:                        info.IsDeleted,
		ProxyReceived:                  info.ProxyReceived.tinybar,
		Key:                            info.Key._ToProtoKey(),
		Balance:                        uint64(info.Balance.tinybar),
		GenerateSendRecordThreshold:    uint64(info.GenerateSendRecordThreshold.tinybar),
		GenerateReceiveRecordThreshold: uint64(info.GenerateReceiveRecordThreshold.tinybar),
		ReceiverSigRequired:            info.ReceiverSigRequired,
		ExpirationTime:                 _TimeToProtobuf(info.ExpirationTime),
		AutoRenewPeriod:                _DurationToProtobuf(info.AutoRenewPeriod),
		LiveHashes:                     liveHashes,
		Memo:                           info.AccountMemo,
		OwnedNfts:                      info.OwnedNfts,
		MaxAutomaticTokenAssociations:  int32(info.MaxAutomaticTokenAssociations),
		Alias:                          alias,
		LedgerId:                       info.LedgerID.ToBytes(),
		EthereumNonce:                  info.EthereumNonce,
	}

	if info.StakingInfo != nil {
		body.StakingInfo = info.StakingInfo._ToProtobuf()
	}

	return body
}

// ToBytes returns the serialized bytes of an AccountInfo
func (info AccountInfo) ToBytes() []byte {
	data, err := protobuf.Marshal(info._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// AccountInfoFromBytes returns an AccountInfo from byte array
func AccountInfoFromBytes(data []byte) (AccountInfo, error) {
	if data == nil {
		return AccountInfo{}, errByteArrayNull
	}
	pb := services.CryptoGetInfoResponse_AccountInfo{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return AccountInfo{}, err
	}

	info, err := _AccountInfoFromProtobuf(&pb)
	if err != nil {
		return AccountInfo{}, err
	}

	return info, nil
}
// Filename: account_info_flow.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// AccountInfoFlowVerifySignature Verifies signature using AccountInfoQuery
func AccountInfoFlowVerifySignature(client *Client, accountID AccountID, message []byte, signature []byte) (bool, error) {
	info, err := NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(client)

	if err != nil {
		return false, err
	}

	if key, ok := info.Key.(PublicKey); ok {
		return key.Verify(message, signature), nil
	}

	return false, nil
}

// AccountInfoFlowVerifyTransaction Verifies transaction using AccountInfoQuery
func AccountInfoFlowVerifyTransaction(client *Client, accountID AccountID, tx Transaction, _ []byte) (bool, error) {
	info, err := NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(client)

	if err != nil {
		return false, err
	}

	if key, ok := info.Key.(PublicKey); ok {
		return key.VerifyTransaction(tx), nil
	}

	return false, nil
}
// Filename: account_info_flow_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationVerifySignatureFlowCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(10)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	//verify, err := AccountInfoFlowVerifySignature(env.Client, accountID, newKey.PublicKey())
	//require.NoError(t, err)
	//
	//assert.True(t, verify)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationVerifySignatureFlowKeyList(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	keys := make([]PrivateKey, 3)
	pubKeys := make([]PublicKey, 3)

	for i := range keys {
		newKey, err := PrivateKeyGenerateEd25519()
		assert.NoError(t, err)

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	thresholdPublicKeys := KeyListWithThreshold(2).
		AddAllPublicKeys(pubKeys)

	newBalance := NewHbar(2)
	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(thresholdPublicKeys).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	//verify, err := AccountInfoFlowVerifySignature(env.Client, accountID, pubKeys[0])
	//require.NoError(t, err)
	//
	//assert.True(t, verify)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(keys[0]).
		Sign(keys[1]).
		Sign(keys[2]).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: account_info_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// AccountInfoQuery
// Get all the information about an account, including the balance. This does not get the list of
// account records.
type AccountInfoQuery struct {
	Query
	accountID *AccountID
}

// NewAccountInfoQuery
// Creates an AccountInfoQuery which retrieves all the information about an account, including the balance. This does not get the list of
// account records.
func NewAccountInfoQuery() *AccountInfoQuery {
	header := services.QueryHeader{}
	return &AccountInfoQuery{
		Query: _NewQuery(true, &header),
	}
}

func (q *AccountInfoQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *AccountInfoQuery) Execute(client *Client) (AccountInfo, error) {
	resp, err := q.execute(client, q)

	if err != nil {
		return AccountInfo{}, err
	}

	return _AccountInfoFromProtobuf(resp.GetCryptoGetInfo().AccountInfo)
}

// SetGrpcDeadline When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *AccountInfoQuery) SetGrpcDeadline(deadline *time.Duration) *AccountInfoQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetAccountID sets the AccountID for this AccountInfoQuery.
func (q *AccountInfoQuery) SetAccountID(accountID AccountID) *AccountInfoQuery {
	q.accountID = &accountID
	return q
}

// GetAccountID returns the AccountID for this AccountInfoQuery.
func (q *AccountInfoQuery) GetAccountID() AccountID {
	if q.accountID == nil {
		return AccountID{}
	}

	return *q.accountID
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountInfoQuery.
func (q *AccountInfoQuery) SetNodeAccountIDs(accountID []AccountID) *AccountInfoQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetQueryPayment sets the Hbar payment to pay the _Node a fee for handling this query
func (q *AccountInfoQuery) SetQueryPayment(queryPayment Hbar) *AccountInfoQuery {
	q.queryPayment = queryPayment
	return q
}

// SetMaxQueryPayment sets the maximum payment allowable for this query.
func (q *AccountInfoQuery) SetMaxQueryPayment(queryMaxPayment Hbar) *AccountInfoQuery {
	q.maxQueryPayment = queryMaxPayment
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *AccountInfoQuery) SetMaxRetry(count int) *AccountInfoQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries. Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *AccountInfoQuery) SetMaxBackoff(max time.Duration) *AccountInfoQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *AccountInfoQuery) SetMinBackoff(min time.Duration) *AccountInfoQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *AccountInfoQuery) SetPaymentTransactionID(transactionID TransactionID) *AccountInfoQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *AccountInfoQuery) SetLogLevel(level LogLevel) *AccountInfoQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *AccountInfoQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetCrypto().GetAccountInfo,
	}
}

func (q *AccountInfoQuery) getName() string {
	return "AccountInfoQuery"
}

func (q *AccountInfoQuery) buildQuery() *services.Query {
	pbQuery := services.Query_CryptoGetInfo{
		CryptoGetInfo: &services.CryptoGetInfoQuery{
			Header: q.pbHeader,
		},
	}

	if q.accountID != nil {
		pbQuery.CryptoGetInfo.AccountID = q.accountID._ToProtobuf()
	}

	return &services.Query{
		Query: &pbQuery,
	}
}

func (q *AccountInfoQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.accountID != nil {
		if err := q.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *AccountInfoQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetCryptoGetInfo()
}
// Filename: account_info_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationAccountInfoQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)
	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	info, err := NewAccountInfoQuery().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, accountID, info.AccountID)
	assert.Equal(t, false, info.IsDeleted)
	assert.Equal(t, newKey.PublicKey(), info.Key)
	assert.Equal(t, newBalance.tinybar, info.Balance.tinybar)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	//err = CloseIntegrationTestEnv(env, nil)
	//require.NoError(t, err)
}

func TestIntegrationAccountInfoQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)
	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	accountInfo := NewAccountInfoQuery().
		SetAccountID(accountID).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := accountInfo.GetCost(env.Client)
	require.NoError(t, err)

	info, err := accountInfo.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, accountID, info.AccountID)
	assert.Equal(t, false, info.IsDeleted)
	assert.Equal(t, newKey.PublicKey(), info.Key)
	assert.Equal(t, newBalance.tinybar, info.Balance.tinybar)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountInfoQueryInsufficientFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)
	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	accountInfo := NewAccountInfoQuery().
		SetAccountID(accountID).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	_, err = accountInfo.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_TX_FEE", err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountInfoQuerySetBigMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)
	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	accountInfo := NewAccountInfoQuery().
		SetAccountID(accountID).
		SetMaxQueryPayment(NewHbar(1000000)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	_, err = accountInfo.GetCost(env.Client)
	require.NoError(t, err)

	info, err := accountInfo.SetQueryPayment(NewHbar(1)).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, accountID, info.AccountID)
	assert.Equal(t, false, info.IsDeleted)
	assert.Equal(t, newKey.PublicKey(), info.Key)
	assert.Equal(t, newBalance.tinybar, info.Balance.tinybar)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountInfoQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)
	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	accountInfo := NewAccountInfoQuery().
		SetAccountID(accountID).
		SetMaxQueryPayment(HbarFromTinybar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := accountInfo.GetCost(env.Client)
	require.NoError(t, err)

	_, err = accountInfo.Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "cost of AccountInfoQuery ("+cost.String()+") without explicit payment is greater than the max query payment of 1 tℏ", err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountInfoQueryNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewAccountInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_ACCOUNT_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestIntegrationAccountInfoQueryTokenRelationshipInfo(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)
	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetMaxAutomaticTokenAssociations(10).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetFreezeKey(newKey).
			SetWipeKey(newKey).
			SetKycKey(newKey).
			SetSupplyKey(newKey).
			SetMetadataKey(newKey).
			SetFreezeDefault(true)
	})

	require.NoError(t, err)

	associateTxn, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = associateTxn.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewAccountInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(accountID).
		Execute(env.Client)
	assert.NoError(t, err)

	assert.Equal(t, accountID, info.AccountID)
	assert.Equal(t, 1, len(info.TokenRelationships))
	assert.Equal(t, true, *info.TokenRelationships[0].FreezeStatus)
	assert.Equal(t, false, *info.TokenRelationships[0].KycStatus)
	assert.Equal(t, uint64(0), info.TokenRelationships[0].Balance)
	assert.Equal(t, "F", info.TokenRelationships[0].Symbol)
	assert.Equal(t, tokenID, info.TokenRelationships[0].TokenID)
	assert.Equal(t, false, info.TokenRelationships[0].AutomaticAssociation)

	unfreezeTxn, err := NewTokenUnfreezeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		FreezeWith(env.Client)

	require.NoError(t, err)
	resp, err = unfreezeTxn.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	kycUpdateTxn, err := NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		FreezeWith(env.Client)

	require.NoError(t, err)
	resp, err = kycUpdateTxn.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewAccountInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(accountID).
		Execute(env.Client)
	assert.NoError(t, err)

	assert.Equal(t, accountID, info.AccountID)
	assert.Equal(t, 1, len(info.TokenRelationships))
	assert.Equal(t, false, *info.TokenRelationships[0].FreezeStatus)
	assert.Equal(t, true, *info.TokenRelationships[0].KycStatus)
	assert.Equal(t, uint64(0), info.TokenRelationships[0].Balance)
	assert.Equal(t, "F", info.TokenRelationships[0].Symbol)
	assert.Equal(t, tokenID, info.TokenRelationships[0].TokenID)
	assert.Equal(t, false, info.TokenRelationships[0].AutomaticAssociation)
}

func TestIntegrationAccountInfoQueryTokenRelationshipsLength(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)
	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetMaxAutomaticTokenAssociations(10).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	firstTokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetFreezeKey(newKey).
			SetWipeKey(newKey).
			SetKycKey(newKey).
			SetSupplyKey(newKey).
			SetMetadataKey(newKey).
			SetDecimals(3)
	})
	require.NoError(t, err)

	associateTxn, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(firstTokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = associateTxn.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewAccountInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(accountID).
		Execute(env.Client)
	assert.NoError(t, err)

	assert.Equal(t, 1, len(info.TokenRelationships))
	assert.Equal(t, uint32(3), info.TokenRelationships[0].Decimals)

	secondTokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetFreezeKey(newKey).
			SetWipeKey(newKey).
			SetKycKey(newKey).
			SetSupplyKey(newKey).
			SetMetadataKey(newKey)
	})
	require.NoError(t, err)

	associateTxn, err = NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(secondTokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = associateTxn.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewAccountInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(accountID).
		Execute(env.Client)
	assert.NoError(t, err)

	assert.Equal(t, 2, len(info.TokenRelationships))
	// the new token should be first in the list
	assert.Equal(t, uint32(18), info.TokenRelationships[0].Decimals)

	dissociateTxn, err := NewTokenDissociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(secondTokenID, firstTokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = dissociateTxn.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewAccountInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(accountID).
		Execute(env.Client)
	assert.NoError(t, err)

	assert.Equal(t, accountID, info.AccountID)
	assert.Equal(t, 0, len(info.TokenRelationships))
}
// Filename: account_info_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
)

func TestUnitAccountInfoQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	infoQuery := NewAccountInfoQuery().
		SetAccountID(accountID)

	err = infoQuery.validateNetworkOnIDs(client)
	require.NoError(t, err)
}
func TestAccountInfoQuery_Get(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	deadline := time.Duration(time.Minute)
	accountId := AccountID{Account: 3, checksum: &checksum}
	transactionID := TransactionIDGenerate(accountId)
	query := NewAccountInfoQuery().
		SetAccountID(accountId).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(10)).
		SetNodeAccountIDs([]AccountID{{Account: 3}, {Account: 4}}).
		SetMaxRetry(5).
		SetMaxBackoff(10 * time.Second).
		SetMinBackoff(1 * time.Second).
		SetPaymentTransactionID(transactionID).
		SetGrpcDeadline(&deadline)
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)
	require.Equal(t, accountId, query.GetAccountID())
	require.Equal(t, NewHbar(2), query.GetQueryPayment())
	require.Equal(t, NewHbar(10), query.GetMaxQueryPayment())
	require.Equal(t, []AccountID{{Account: 3}, {Account: 4}}, query.GetNodeAccountIDs())
	require.Equal(t, 5, query.GetMaxRetryCount())
	require.Equal(t, 10*time.Second, query.GetMaxBackoff())
	require.Equal(t, 1*time.Second, query.GetMinBackoff())
	require.Equal(t, transactionID, query.GetPaymentTransactionID())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}

func TestUnitAccountInfoQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	infoQuery := NewAccountInfoQuery().
		SetAccountID(accountID)

	err = infoQuery.validateNetworkOnIDs(client)
	require.Error(t, err)
	if err != nil {
		require.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitAccountInfoQuerySetNothing(t *testing.T) {
	t.Parallel()

	balance := NewAccountInfoQuery()

	require.Equal(t, AccountID{}, balance.GetAccountID())
	require.Equal(t, []AccountID{}, balance.GetNodeAccountIDs())
	require.Equal(t, 250*time.Millisecond, balance.GetMinBackoff())
	require.Equal(t, 8*time.Second, balance.GetMaxBackoff())
	require.Equal(t, 10, balance.GetMaxRetryCount())
	require.Equal(t, TransactionID{}, balance.GetPaymentTransactionID())
	require.Equal(t, Hbar{}, balance.GetQueryPayment())
	require.Equal(t, Hbar{}, balance.GetMaxQueryPayment())
}

func Test_AccountInfoQueryMapStatusError(t *testing.T) {
	t.Parallel()

	response := services.Response{
		Response: &services.Response_CryptoGetInfo{
			CryptoGetInfo: &services.CryptoGetInfoResponse{
				Header: &services.ResponseHeader{
					NodeTransactionPrecheckCode: services.ResponseCodeEnum(StatusInvalidAccountID),
					ResponseType:                services.ResponseType_COST_ANSWER,
				},
			},
		},
	}

	query := NewAccountInfoQuery()
	actualError := query.mapStatusError(query, &response)

	expectedError := ErrHederaPreCheckStatus{
		Status: StatusInvalidAccountID,
	}

	require.Equal(t, expectedError, actualError)
}

func TestUnitAccountInfoQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_CryptoGetInfo{
				CryptoGetInfo: &services.CryptoGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewAccountInfoQuery().
		SetAccountID(AccountID{Account: 1234}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMaxQueryPayment(NewHbar(1))

	cost, err := query.GetCost(client)
	require.NoError(t, err)
	require.Equal(t, HbarFromTinybar(2), cost)
}
// Filename: account_info_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

// The function checks the conversation methods on the AccountInfo struct. We check wether it is correctly converted to protobuf and back.
func TestUnitAccountInfoToBytes(t *testing.T) {
	t.Parallel()

	accInfoOriginal := *_MockAccountInfo()
	accInfoBytes := accInfoOriginal.ToBytes()

	accInfoFromBytes, err := AccountInfoFromBytes(accInfoBytes)

	require.NoError(t, err)
	require.Equal(t, accInfoOriginal.AccountID, accInfoFromBytes.AccountID)
	require.Equal(t, accInfoOriginal.ContractAccountID, accInfoFromBytes.ContractAccountID)
	require.Equal(t, accInfoOriginal.Key, accInfoFromBytes.Key)
	require.Equal(t, accInfoOriginal.LedgerID, accInfoFromBytes.LedgerID)
}
func _MockAccountInfo() *AccountInfo {
	privateKey, _ := PrivateKeyFromString(mockPrivateKey)
	accountID, _ := AccountIDFromString("0.0.123-esxsf")
	accountID.checksum = nil

	return &AccountInfo{
		AccountID:                      accountID,
		ContractAccountID:              "",
		IsDeleted:                      false,
		ProxyReceived:                  Hbar{},
		Key:                            privateKey.PublicKey(),
		Balance:                        HbarFromTinybar(100000000000),
		GenerateSendRecordThreshold:    Hbar{},
		GenerateReceiveRecordThreshold: Hbar{},
		ReceiverSigRequired:            false,
		ExpirationTime:                 time.Date(2222, 2, 2, 2, 2, 2, 2, time.Now().UTC().Location()),
		AutoRenewPeriod:                time.Duration(time.Duration(5).Seconds()),
		LiveHashes:                     nil,
		AccountMemo:                    "",
		OwnedNfts:                      0,
		MaxAutomaticTokenAssociations:  0,
		AliasKey:                       nil,
		LedgerID:                       *NewLedgerIDTestnet(),
		EthereumNonce:                  0,
		StakingInfo:                    nil,
	}

}
// Filename: account_records_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// AccountRecordsQuery gets all of the records for an account for any transfers into it and out of
// it, that were above the threshold, during the last 25 hours.
type AccountRecordsQuery struct {
	Query
	accountID *AccountID
}

// NewAccountRecordsQuery creates an AccountRecordsQuery Query which can be used to construct and execute
// an AccountRecordsQuery.
//
// It is recommended that you use this for creating new instances of an AccountRecordQuery
// instead of manually creating an instance of the struct.
func NewAccountRecordsQuery() *AccountRecordsQuery {
	header := services.QueryHeader{}
	return &AccountRecordsQuery{
		Query: _NewQuery(true, &header),
	}
}

// SetGrpcDeadline When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *AccountRecordsQuery) SetGrpcDeadline(deadline *time.Duration) *AccountRecordsQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetAccountID sets the account ID for which the records should be retrieved.
func (q *AccountRecordsQuery) SetAccountID(accountID AccountID) *AccountRecordsQuery {
	q.accountID = &accountID
	return q
}

// GetAccountID returns the account ID for which the records will be retrieved.
func (q *AccountRecordsQuery) GetAccountID() AccountID {
	if q.accountID == nil {
		return AccountID{}
	}

	return *q.accountID
}

func (q *AccountRecordsQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *AccountRecordsQuery) Execute(client *Client) ([]TransactionRecord, error) {
	resp, err := q.Query.execute(client, q)
	records := make([]TransactionRecord, 0)

	if err != nil {
		return records, err
	}

	for _, element := range resp.GetCryptoGetAccountRecords().Records {
		record := _TransactionRecordFromProtobuf(&services.TransactionGetRecordResponse{TransactionRecord: element}, nil)
		records = append(records, record)
	}

	return records, err
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *AccountRecordsQuery) SetMaxQueryPayment(maxPayment Hbar) *AccountRecordsQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *AccountRecordsQuery) SetQueryPayment(paymentAmount Hbar) *AccountRecordsQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountRecordsQuery.
func (q *AccountRecordsQuery) SetNodeAccountIDs(accountID []AccountID) *AccountRecordsQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *AccountRecordsQuery) SetMaxRetry(count int) *AccountRecordsQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *AccountRecordsQuery) SetMaxBackoff(max time.Duration) *AccountRecordsQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

func (q *AccountRecordsQuery) SetMinBackoff(min time.Duration) *AccountRecordsQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *AccountRecordsQuery) SetPaymentTransactionID(transactionID TransactionID) *AccountRecordsQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *AccountRecordsQuery) SetLogLevel(level LogLevel) *AccountRecordsQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *AccountRecordsQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetCrypto().GetAccountRecords,
	}
}

func (q *AccountRecordsQuery) getName() string {
	return "AccountRecordsQuery"
}

func (q *AccountRecordsQuery) buildQuery() *services.Query {
	pb := services.Query_CryptoGetAccountRecords{
		CryptoGetAccountRecords: &services.CryptoGetAccountRecordsQuery{
			Header: q.pbHeader,
		},
	}

	if q.accountID != nil {
		pb.CryptoGetAccountRecords.AccountID = q.accountID._ToProtobuf()
	}

	return &services.Query{
		Query: &pb,
	}
}

func (q *AccountRecordsQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.accountID != nil {
		if err := q.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *AccountRecordsQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetCryptoGetAccountRecords()
}
// Filename: account_records_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationAccountRecordQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	account := *receipt.AccountID

	_, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddHbarTransfer(account, NewHbar(1)).
		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(-1)).
		Execute(env.Client)
	require.NoError(t, err)

	recordsQuery, err := NewAccountRecordsQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(env.Client.GetOperatorAccountID()).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, 1, len(recordsQuery))

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountRecordQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	account := *receipt.AccountID

	_, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddHbarTransfer(account, NewHbar(1)).
		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(-1)).
		Execute(env.Client)
	require.NoError(t, err)

	records := NewAccountRecordsQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(env.Client.GetOperatorAccountID())

	cost, err := records.GetCost(env.Client)
	require.NoError(t, err)

	recordsQuery, err := records.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, 1, len(recordsQuery))

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountRecordQuerySetBigMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	account := *receipt.AccountID

	_, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddHbarTransfer(account, NewHbar(1)).
		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(-1)).
		Execute(env.Client)
	require.NoError(t, err)

	records := NewAccountRecordsQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(env.Client.GetOperatorAccountID()).
		SetQueryPayment(NewHbar(10)).
		SetMaxQueryPayment(NewHbar(100000))

	_, err = records.GetCost(env.Client)
	require.NoError(t, err)

	recordsQuery, err := records.Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, 1, len(recordsQuery))

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountRecordQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	account := *receipt.AccountID

	_, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddHbarTransfer(account, NewHbar(1)).
		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(-1)).
		Execute(env.Client)
	require.NoError(t, err)

	records := NewAccountRecordsQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(env.Client.GetOperatorAccountID()).
		SetMaxQueryPayment(HbarFromTinybar(1))

	cost, err := records.GetCost(env.Client)
	require.NoError(t, err)

	_, err = records.Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "cost of AccountRecordsQuery ("+cost.String()+") without explicit payment is greater than the max query payment of 1 tℏ", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountRecordQueryInsufficientFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	account := *receipt.AccountID

	_, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddHbarTransfer(account, NewHbar(1)).
		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(-1)).
		Execute(env.Client)
	require.NoError(t, err)

	records := NewAccountRecordsQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(env.Client.GetOperatorAccountID())

	_, err = records.GetCost(env.Client)
	require.NoError(t, err)

	_, err = records.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_TX_FEE", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountRecordQueryNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewAccountRecordsQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_ACCOUNT_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: account_records_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitAccountRecordQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	recordQuery := NewAccountRecordsQuery().
		SetAccountID(accountID)

	err = recordQuery.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitAccountRecordQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	recordQuery := NewAccountRecordsQuery().
		SetAccountID(accountID)

	err = recordQuery.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitAccountRecordsQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_CryptoGetAccountRecords{
				CryptoGetAccountRecords: &services.CryptoGetAccountRecordsResponse{
					Header:    &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
					AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 1800}},
				},
			},
		},
		&services.Response{
			Response: &services.Response_CryptoGetAccountRecords{
				CryptoGetAccountRecords: &services.CryptoGetAccountRecordsResponse{
					Header:    &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
					AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 1800}},
				},
			},
		},
		&services.Response{
			Response: &services.Response_CryptoGetAccountRecords{
				CryptoGetAccountRecords: &services.CryptoGetAccountRecordsResponse{
					Header:    &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 1},
					AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 1800}},
					Records: []*services.TransactionRecord{
						{
							TransactionHash:    []byte{1},
							ConsensusTimestamp: &services.Timestamp{Nanos: 12313123, Seconds: 2313},
							TransactionID: &services.TransactionID{
								TransactionValidStart: &services.Timestamp{Nanos: 12313123, Seconds: 2313},
								AccountID:             &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 1800}},
								Scheduled:             false,
								Nonce:                 0,
							},
							Memo:           "",
							TransactionFee: 0,
						},
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewAccountRecordsQuery().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAccountID(AccountID{Account: 1800}).
		SetMaxQueryPayment(NewHbar(1))

	_, err := query.GetCost(client)
	require.NoError(t, err)
	recordsQuery, err := query.Execute(client)
	require.NoError(t, err)

	require.Equal(t, len(recordsQuery), 1)
	require.Equal(t, recordsQuery[0].TransactionID.AccountID.Account, uint64(1800))
}

func TestUnitAccountRecordsQueryGet(t *testing.T) {
	t.Parallel()

	spenderAccountID1 := AccountID{Account: 7}

	balance := NewAccountRecordsQuery().
		SetAccountID(spenderAccountID1).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(10)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}})

	balance.GetAccountID()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitAccountRecordsQuerySetNothing(t *testing.T) {
	t.Parallel()

	balance := NewAccountRecordsQuery()

	balance.GetAccountID()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitAccountRecordsQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 3
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewAccountRecordsQuery().
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetAccountID(account).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3)).
		SetGrpcDeadline(&grpc)

	err = query.validateNetworkOnIDs(client)

	require.NoError(t, err)
	query.GetNodeAccountIDs()
	query.GetMaxBackoff()
	query.GetMinBackoff()
	query.getName()
	query.GetAccountID()
}
// Filename: account_stakers_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// AccountStakersQuery gets all of the accounts that are proxy staking to this account. For each of  them, the amount
// currently staked will be given. This is not yet implemented, but will be in a future version of the API.
type AccountStakersQuery struct {
	Query
	accountID *AccountID
}

// NewAccountStakersQuery creates an AccountStakersQuery query which can be used to construct and execute
// an AccountStakersQuery.
//
// It is recommended that you use this for creating new instances of an AccountStakersQuery
// instead of manually creating an instance of the struct.
func NewAccountStakersQuery() *AccountStakersQuery {
	header := services.QueryHeader{}
	return &AccountStakersQuery{
		Query: _NewQuery(true, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *AccountStakersQuery) SetGrpcDeadline(deadline *time.Duration) *AccountStakersQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetAccountID sets the Account ID for which the stakers should be retrieved
func (q *AccountStakersQuery) SetAccountID(accountID AccountID) *AccountStakersQuery {
	q.accountID = &accountID
	return q
}

// GetAccountID returns the AccountID for this AccountStakersQuery.
func (q *AccountStakersQuery) GetAccountID() AccountID {
	if q.accountID == nil {
		return AccountID{}
	}

	return *q.accountID
}

func (q *AccountStakersQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *AccountStakersQuery) Execute(client *Client) ([]Transfer, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return []Transfer{}, err
	}

	var stakers = make([]Transfer, len(resp.GetCryptoGetProxyStakers().Stakers.ProxyStaker))

	// TODO: This is wrong, q _Method shold return `[]ProxyStaker` not `[]Transfer`
	for i, element := range resp.GetCryptoGetProxyStakers().Stakers.ProxyStaker {
		id := _AccountIDFromProtobuf(element.AccountID)
		accountID := AccountID{}

		if id == nil {
			accountID = *id
		}

		stakers[i] = Transfer{
			AccountID: accountID,
			Amount:    HbarFromTinybar(element.Amount),
		}
	}

	return stakers, err
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *AccountStakersQuery) SetMaxQueryPayment(maxPayment Hbar) *AccountStakersQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *AccountStakersQuery) SetQueryPayment(paymentAmount Hbar) *AccountStakersQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountStakersQuery.
func (q *AccountStakersQuery) SetNodeAccountIDs(accountID []AccountID) *AccountStakersQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *AccountStakersQuery) SetMaxRetry(count int) *AccountStakersQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *AccountStakersQuery) SetMaxBackoff(max time.Duration) *AccountStakersQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *AccountStakersQuery) SetMinBackoff(min time.Duration) *AccountStakersQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *AccountStakersQuery) SetPaymentTransactionID(transactionID TransactionID) *AccountStakersQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *AccountStakersQuery) SetLogLevel(level LogLevel) *AccountStakersQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *AccountStakersQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetCrypto().GetStakersByAccountID,
	}
}

func (q *AccountStakersQuery) getName() string {
	return "AccountStakersQuery"
}

func (q *AccountStakersQuery) buildQuery() *services.Query {
	pb := services.Query_CryptoGetProxyStakers{
		CryptoGetProxyStakers: &services.CryptoGetStakersQuery{
			Header: q.pbHeader,
		},
	}

	if q.accountID != nil {
		pb.CryptoGetProxyStakers.AccountID = q.accountID._ToProtobuf()
	}

	return &services.Query{
		Query: &pb,
	}
}

func (q *AccountStakersQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.accountID != nil {
		if err := q.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *AccountStakersQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetCryptoGetProxyStakers()
}
// Filename: account_stakers_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationAccountStakersQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewAccountStakersQuery().
		SetAccountID(env.Client.GetOperatorAccountID()).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetQueryPayment(HbarFromTinybar(25)).
		Execute(env.Client)
	assert.Error(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountStakersQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	accountStakers := NewAccountStakersQuery().
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.Client.GetOperatorAccountID())

	cost, err := accountStakers.GetCost(env.Client)
	assert.Error(t, err)

	_, err = accountStakers.SetQueryPayment(cost).Execute(env.Client)
	assert.Error(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountStakersQuerySetBigMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	accountStakers := NewAccountStakersQuery().
		SetMaxQueryPayment(NewHbar(100000)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.Client.GetOperatorAccountID())

	cost, err := accountStakers.GetCost(env.Client)
	assert.Error(t, err)

	_, err = accountStakers.SetQueryPayment(cost).Execute(env.Client)
	assert.Error(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountStakersQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	accountStakers := NewAccountStakersQuery().
		SetMaxQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.Client.GetOperatorAccountID())

	cost, err := accountStakers.GetCost(env.Client)
	assert.Error(t, err)

	_, err = accountStakers.SetQueryPayment(cost).Execute(env.Client)
	assert.Error(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountStakersQueryInsufficientFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	accountStakers := NewAccountStakersQuery().
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(env.Client.GetOperatorAccountID())

	_, err := accountStakers.GetCost(env.Client)
	assert.Error(t, err)

	_, err = accountStakers.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status NOT_SUPPORTED", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountStakersQueryNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewAccountStakersQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status NOT_SUPPORTED", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: account_stakers_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitAccountStakersQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	stackersQuery := NewAccountStakersQuery().
		SetAccountID(accountID)

	err = stackersQuery.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitAccountStakersQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	stackersQuery := NewAccountStakersQuery().
		SetAccountID(accountID)

	err = stackersQuery.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitAccountStakersQueryGet(t *testing.T) {
	t.Parallel()

	spenderAccountID1 := AccountID{Account: 7}

	balance := NewAccountStakersQuery().
		SetAccountID(spenderAccountID1).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(10)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}})

	balance.GetAccountID()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitAccountStakersQuerySetNothing(t *testing.T) {
	t.Parallel()

	balance := NewAccountStakersQuery()

	balance.GetAccountID()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitAccountStakersQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 3
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewAccountStakersQuery().
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetAccountID(account).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3)).
		SetGrpcDeadline(&grpc)

	err = query.validateNetworkOnIDs(client)

	require.NoError(t, err)
	query.GetNodeAccountIDs()
	query.GetMaxBackoff()
	query.GetMinBackoff()
	query.getName()
	query.GetAccountID()
}

func TestUnitAccountStakersQueryQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{
		{
			&services.Response{
				Response: &services.Response_CryptoGetProxyStakers{
					CryptoGetProxyStakers: &services.CryptoGetStakersResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 0},
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptoGetProxyStakers{
					CryptoGetProxyStakers: &services.CryptoGetStakersResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 0},
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptoGetProxyStakers{
					CryptoGetProxyStakers: &services.CryptoGetStakersResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 0},
						Stakers: &services.AllProxyStakers{
							AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 1800}},
						},
					},
				},
			},
		},
	}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewAccountStakersQuery().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAccountID(AccountID{Account: 1800})

	query.GetCost(client)
	_, err := query.Execute(client)
	require.NoError(t, err)
}
// Filename: account_update_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// AccountUpdateTransaction
// Change properties for the given account. Any null field is ignored (left unchanged). This
// transaction must be signed by the existing key for this account. If the transaction is changing
// the key field, then the transaction must be signed by both the old key (from before the change)
// and the new key. The old key must sign for security. The new key must sign as a safeguard to
// avoid accidentally changing to an invalid key, and then having no way to recover.
type AccountUpdateTransaction struct {
	Transaction
	accountID                     *AccountID
	proxyAccountID                *AccountID
	key                           Key
	autoRenewPeriod               *time.Duration
	memo                          string
	receiverSignatureRequired     bool
	expirationTime                *time.Time
	maxAutomaticTokenAssociations int32
	aliasKey                      *PublicKey
	stakedAccountID               *AccountID
	stakedNodeID                  *int64
	declineReward                 bool
}

// NewAccountUpdateTransaction
// Creates AccoutnUppdateTransaction which changes properties for the given account.
// Any null field is ignored (left unchanged).
// This transaction must be signed by the existing key for this account. If the transaction is changing
// the key field, then the transaction must be signed by both the old key (from before the change)
// and the new key. The old key must sign for security. The new key must sign as a safeguard to
// avoid accidentally changing to an invalid key, and then having no way to recover.
func NewAccountUpdateTransaction() *AccountUpdateTransaction {
	tx := AccountUpdateTransaction{
		Transaction: _NewTransaction(),
	}
	tx.SetAutoRenewPeriod(7890000 * time.Second)
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _AccountUpdateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *AccountUpdateTransaction {
	key, _ := _KeyFromProtobuf(pb.GetCryptoUpdateAccount().GetKey())
	var receiverSignatureRequired bool

	switch s := pb.GetCryptoUpdateAccount().GetReceiverSigRequiredField().(type) {
	case *services.CryptoUpdateTransactionBody_ReceiverSigRequired:
		receiverSignatureRequired = s.ReceiverSigRequired // nolint
	case *services.CryptoUpdateTransactionBody_ReceiverSigRequiredWrapper:
		receiverSignatureRequired = s.ReceiverSigRequiredWrapper.Value // nolint
	}

	autoRenew := _DurationFromProtobuf(pb.GetCryptoUpdateAccount().AutoRenewPeriod)
	expiration := _TimeFromProtobuf(pb.GetCryptoUpdateAccount().ExpirationTime)

	stakedNodeID := pb.GetCryptoUpdateAccount().GetStakedNodeId()

	var stakeNodeAccountID *AccountID
	if pb.GetCryptoUpdateAccount().GetStakedAccountId() != nil {
		stakeNodeAccountID = _AccountIDFromProtobuf(pb.GetCryptoUpdateAccount().GetStakedAccountId())
	}

	return &AccountUpdateTransaction{
		Transaction:                   tx,
		accountID:                     _AccountIDFromProtobuf(pb.GetCryptoUpdateAccount().GetAccountIDToUpdate()),
		key:                           key,
		autoRenewPeriod:               &autoRenew,
		memo:                          pb.GetCryptoUpdateAccount().GetMemo().Value,
		receiverSignatureRequired:     receiverSignatureRequired,
		expirationTime:                &expiration,
		maxAutomaticTokenAssociations: pb.GetCryptoUpdateAccount().MaxAutomaticTokenAssociations.GetValue(),
		stakedAccountID:               stakeNodeAccountID,
		stakedNodeID:                  &stakedNodeID,
		declineReward:                 pb.GetCryptoUpdateAccount().GetDeclineReward().GetValue(),
	}
}

// SetKey Sets the new key for the Account
func (tx *AccountUpdateTransaction) SetKey(key Key) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.key = key
	return tx
}

func (tx *AccountUpdateTransaction) GetKey() (Key, error) {
	return tx.key, nil
}

// SetAccountID Sets the account ID which is being updated in tx transaction.
func (tx *AccountUpdateTransaction) SetAccountID(accountID AccountID) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

func (tx *AccountUpdateTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// Deprecated
func (tx *AccountUpdateTransaction) SetAliasKey(alias PublicKey) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.aliasKey = &alias
	return tx
}

// Deprecated
func (tx *AccountUpdateTransaction) GetAliasKey() PublicKey {
	if tx.aliasKey == nil {
		return PublicKey{}
	}

	return *tx.aliasKey
}

func (tx *AccountUpdateTransaction) SetStakedAccountID(id AccountID) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.stakedAccountID = &id
	return tx
}

func (tx *AccountUpdateTransaction) GetStakedAccountID() AccountID {
	if tx.stakedAccountID != nil {
		return *tx.stakedAccountID
	}

	return AccountID{}
}

func (tx *AccountUpdateTransaction) SetStakedNodeID(id int64) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.stakedNodeID = &id
	return tx
}

func (tx *AccountUpdateTransaction) GetStakedNodeID() int64 {
	if tx.stakedNodeID != nil {
		return *tx.stakedNodeID
	}

	return 0
}

func (tx *AccountUpdateTransaction) SetDeclineStakingReward(decline bool) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.declineReward = decline
	return tx
}

func (tx *AccountUpdateTransaction) ClearStakedAccountID() *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.stakedAccountID = &AccountID{Account: 0}
	return tx
}

func (tx *AccountUpdateTransaction) ClearStakedNodeID() *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	*tx.stakedNodeID = -1
	return tx
}

func (tx *AccountUpdateTransaction) GetDeclineStakingReward() bool {
	return tx.declineReward
}

// SetMaxAutomaticTokenAssociations
// Sets the maximum number of tokens that an Account can be implicitly associated with. Up to a 1000
// including implicit and explicit associations.
func (tx *AccountUpdateTransaction) SetMaxAutomaticTokenAssociations(max int32) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.maxAutomaticTokenAssociations = max
	return tx
}

func (tx *AccountUpdateTransaction) GetMaxAutomaticTokenAssociations() int32 {
	return tx.maxAutomaticTokenAssociations
}

// SetReceiverSignatureRequired
// If true, this account's key must sign any transaction depositing into this account (in
// addition to all withdrawals)
func (tx *AccountUpdateTransaction) SetReceiverSignatureRequired(receiverSignatureRequired bool) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.receiverSignatureRequired = receiverSignatureRequired
	return tx
}

func (tx *AccountUpdateTransaction) GetReceiverSignatureRequired() bool {
	return tx.receiverSignatureRequired
}

// Deprecated
// SetProxyAccountID Sets the ID of the account to which this account is proxy staked.
func (tx *AccountUpdateTransaction) SetProxyAccountID(proxyAccountID AccountID) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.proxyAccountID = &proxyAccountID
	return tx
}

// Deprecated
func (tx *AccountUpdateTransaction) GetProxyAccountID() AccountID {
	if tx.proxyAccountID == nil {
		return AccountID{}
	}

	return *tx.proxyAccountID
}

// SetAutoRenewPeriod Sets the duration in which it will automatically extend the expiration period.
func (tx *AccountUpdateTransaction) SetAutoRenewPeriod(autoRenewPeriod time.Duration) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = &autoRenewPeriod
	return tx
}

func (tx *AccountUpdateTransaction) GetAutoRenewPeriod() time.Duration {
	if tx.autoRenewPeriod != nil {
		return *tx.autoRenewPeriod
	}

	return time.Duration(0)
}

// SetExpirationTime sets the new expiration time to extend to (ignored if equal to or before the current one)
func (tx *AccountUpdateTransaction) SetExpirationTime(expirationTime time.Time) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.expirationTime = &expirationTime
	return tx
}

func (tx *AccountUpdateTransaction) GetExpirationTime() time.Time {
	if tx.expirationTime != nil {
		return *tx.expirationTime
	}
	return time.Time{}
}

// SetAccountMemo sets the new memo to be associated with the account (UTF-8 encoding max 100 bytes)
func (tx *AccountUpdateTransaction) SetAccountMemo(memo string) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo

	return tx
}

func (tx *AccountUpdateTransaction) GetAccountMemo() string {
	return tx.memo
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *AccountUpdateTransaction) Sign(
	privateKey PrivateKey,
) *AccountUpdateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *AccountUpdateTransaction) SignWithOperator(
	client *Client,
) (*AccountUpdateTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *AccountUpdateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *AccountUpdateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *AccountUpdateTransaction) AddSignature(publicKey PublicKey, signature []byte) *AccountUpdateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *AccountUpdateTransaction) SetGrpcDeadline(deadline *time.Duration) *AccountUpdateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *AccountUpdateTransaction) Freeze() (*AccountUpdateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *AccountUpdateTransaction) FreezeWith(client *Client) (*AccountUpdateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *AccountUpdateTransaction) SetMaxTransactionFee(fee Hbar) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *AccountUpdateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this AccountUpdateTransaction.
func (tx *AccountUpdateTransaction) SetTransactionMemo(memo string) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this AccountUpdateTransaction.
func (tx *AccountUpdateTransaction) SetTransactionValidDuration(duration time.Duration) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *AccountUpdateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this AccountUpdateTransaction.
func (tx *AccountUpdateTransaction) SetTransactionID(transactionID TransactionID) *AccountUpdateTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this AccountUpdateTransaction.
func (tx *AccountUpdateTransaction) SetNodeAccountIDs(nodeID []AccountID) *AccountUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *AccountUpdateTransaction) SetMaxRetry(count int) *AccountUpdateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *AccountUpdateTransaction) SetMaxBackoff(max time.Duration) *AccountUpdateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *AccountUpdateTransaction) SetMinBackoff(min time.Duration) *AccountUpdateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *AccountUpdateTransaction) SetLogLevel(level LogLevel) *AccountUpdateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *AccountUpdateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *AccountUpdateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *AccountUpdateTransaction) getName() string {
	return "AccountUpdateTransaction"
}

func (tx *AccountUpdateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.proxyAccountID != nil {
		if err := tx.proxyAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *AccountUpdateTransaction) build() *services.TransactionBody {
	body := tx.buildProtoBody()

	pb := services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_CryptoUpdateAccount{
			CryptoUpdateAccount: body,
		},
	}

	body.MaxAutomaticTokenAssociations = &wrapperspb.Int32Value{Value: tx.maxAutomaticTokenAssociations}

	return &pb
}
func (tx *AccountUpdateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_CryptoUpdateAccount{
			CryptoUpdateAccount: tx.buildProtoBody(),
		},
	}, nil
}
func (tx *AccountUpdateTransaction) buildProtoBody() *services.CryptoUpdateTransactionBody {
	body := &services.CryptoUpdateTransactionBody{
		ReceiverSigRequiredField: &services.CryptoUpdateTransactionBody_ReceiverSigRequiredWrapper{
			ReceiverSigRequiredWrapper: &wrapperspb.BoolValue{Value: tx.receiverSignatureRequired},
		},
		Memo:                          &wrapperspb.StringValue{Value: tx.memo},
		DeclineReward:                 &wrapperspb.BoolValue{Value: tx.declineReward},
		MaxAutomaticTokenAssociations: &wrapperspb.Int32Value{Value: tx.maxAutomaticTokenAssociations},
	}

	if tx.autoRenewPeriod != nil {
		body.AutoRenewPeriod = _DurationToProtobuf(*tx.autoRenewPeriod)
	}

	if tx.expirationTime != nil {
		body.ExpirationTime = _TimeToProtobuf(*tx.expirationTime)
	}

	if tx.accountID != nil {
		body.AccountIDToUpdate = tx.accountID._ToProtobuf()
	}

	if tx.key != nil {
		body.Key = tx.key._ToProtoKey()
	}

	if tx.stakedAccountID != nil {
		body.StakedId = &services.CryptoUpdateTransactionBody_StakedAccountId{StakedAccountId: tx.stakedAccountID._ToProtobuf()}
	} else if tx.stakedNodeID != nil {
		body.StakedId = &services.CryptoUpdateTransactionBody_StakedNodeId{StakedNodeId: *tx.stakedNodeID}
	}

	return body
}

func (tx *AccountUpdateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetCrypto().UpdateAccount,
	}
}

func (tx *AccountUpdateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: account_update_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationAccountUpdateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newKey2, err := GeneratePrivateKey()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	tx, err := NewAccountUpdateTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetExpirationTime(time.Now().Add(time.Hour * 24 * 92)).
		SetKey(newKey2.PublicKey()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx.Sign(newKey)
	tx.Sign(newKey2)

	resp, err = tx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewAccountInfoQuery().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, newKey2.PublicKey().String(), info.Key.String())

	txDelete, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		FreezeWith(env.Client)

	require.NoError(t, err)

	txDelete.Sign(newKey2)

	resp, err = txDelete.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)

	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountUpdateTransactionNoSigning(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newKey2, err := GeneratePrivateKey()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	require.NoError(t, err)

	_, err = NewAccountUpdateTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetKey(newKey2.PublicKey()).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewAccountInfoQuery().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, newKey.PublicKey().String(), info.Key.String())

	txDelete, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		FreezeWith(env.Client)

	require.NoError(t, err)

	txDelete.Sign(newKey)

	resp, err = txDelete.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationAccountUpdateTransactionAccountIDNotSet(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewAccountUpdateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Contains(t, err.Error(), "exceptional precheck status ACCOUNT_ID_DOES_NOT_EXIST")
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

// func TestAccountUpdateTransactionAddSignature_Execute(t *testing.T) {
//	env := NewIntegrationTestEnv(t)
//
//	newKey, err := PrivateKeyGenerateEd25519()
//	require.NoError(t, err)
//
//	newKey2, err := GeneratePrivateKey()
//	require.NoError(t, err)
//
//	newBalance := NewHbar(2)
//
//	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)
//
//	resp, err := NewAccountCreateTransaction().
//		SetKey(newKey.PublicKey()).
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetInitialBalance(newBalance).
//		Execute(env.Client)
//
//	require.NoError(t, err)
//
//	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	accountID := *receipt.AccountID
//	require.NoError(t, err)
//
//	tx, err := NewAccountUpdateTransaction().
//		SetAccountID(accountID).
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		SetExpirationTime(time.Now().Add(time.Hour * 24 * 120)).
//		SetTransactionID(TransactionIDGenerate(accountID)).
//		SetKey(newKey2.PublicKey()).
//		FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	updateBytes, err := tx.ToBytes()
//	require.NoError(t, err)
//
//	sig1, err := newKey.SignTransaction(&tx.Transaction)
//	require.NoError(t, err)
//	sig2, err := newKey2.SignTransaction(&tx.Transaction)
//	require.NoError(t, err)
//
//	tx2, err := TransactionFromBytes(updateBytes)
//	require.NoError(t, err)
//
//	switch newTx := tx2.(type) {
//	case AccountUpdateTransaction:
//		resp, err = newTx.AddSignature(newKey.PublicKey(), sig1).AddSignature(newKey2.PublicKey(), sig2).Execute(env.Client)
//		require.NoError(t, err)
//	}
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	info, err := NewAccountInfoQuery().
//		SetAccountID(accountID).
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		SetMaxQueryPayment(NewHbar(1)).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	assert.Equal(t, newKey2.PublicKey().String(), info.Key.String())
//
//	txDelete, err := NewAccountDeleteTransaction().
//		SetAccountID(accountID).
//		SetTransferAccountID(env.Client.GetOperatorAccountID()).
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		FreezeWith(env.Client)
//
//	require.NoError(t, err)
//
//	txDelete.Sign(newKey2)
//
//	resp, err = txDelete.Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//
//	require.NoError(t, err)
//
//	err = CloseIntegrationTestEnv(env, nil)
//	require.NoError(t, err)
//}
// Filename: account_update_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitAccountUpdateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	accountUpdate := NewAccountUpdateTransaction().
		SetProxyAccountID(accountID)

	err = accountUpdate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitAccountUpdateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	accountUpdate := NewAccountUpdateTransaction().
		SetProxyAccountID(accountID)

	err = accountUpdate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitAccountUpdateTransactionMock(t *testing.T) {
	t.Parallel()

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if bod, ok := transactionBody.Data.(*services.TransactionBody_CryptoUpdateAccount); ok {
			require.Equal(t, bod.CryptoUpdateAccount.Memo.Value, "no")
			require.Equal(t, bod.CryptoUpdateAccount.AccountIDToUpdate.GetAccountNum(), int64(123))
			//alias := services.Key{}
			//_ = protobuf.Unmarshal(bod.CryptoUpdateAccount.Alias, &alias)
			//require.Equal(t, hex.EncodeToString(alias.GetEd25519()), "1480272863d39c42f902bc11601a968eaf30ad662694e3044c86d5df46fabfd2")
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	//302a300506032b65700321001480272863d39c42f902bc11601a968eaf30ad662694e3044c86d5df46fabfd2
	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420278184257eb568d0e5fcfc1df99828b039b4776da05855dc5af105996e6200d1")
	require.NoError(t, err)

	tran := TransactionIDGenerate(AccountID{Account: 3})

	_, err = NewAccountUpdateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTransactionID(tran).
		SetAccountMemo("no").
		SetAccountID(AccountID{Account: 123}).
		SetAliasKey(newKey.PublicKey()).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitAccountUpdateTransactionGet(t *testing.T) {
	t.Parallel()

	spenderAccountID1 := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}

	key, err := PrivateKeyGenerateEd25519()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAccountID(spenderAccountID1).
		SetKey(key).
		SetProxyAccountID(spenderAccountID1).
		SetAccountMemo("").
		SetReceiverSignatureRequired(true).
		SetMaxAutomaticTokenAssociations(2).
		SetAutoRenewPeriod(60 * time.Second).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxAutomaticTokenAssociations()
	transaction.GetProxyAccountID()
	transaction.GetRegenerateTransactionID()
	transaction.GetKey()
	transaction.GetAutoRenewPeriod()
	transaction.GetReceiverSignatureRequired()
}

func TestUnitAccountUpdateTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxAutomaticTokenAssociations()
	transaction.GetProxyAccountID()
	transaction.GetRegenerateTransactionID()
	transaction.GetKey()
	transaction.GetAutoRenewPeriod()
	transaction.GetReceiverSignatureRequired()
}

func TestUnitAccountUpdateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	stackedAccountID := AccountID{Account: 5}
	accountID := AccountID{Account: 6}

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewAccountUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKey(key).
		SetAccountID(accountID).
		SetAccountMemo("ty").
		SetReceiverSignatureRequired(true).
		SetMaxAutomaticTokenAssociations(2).
		SetStakedAccountID(stackedAccountID).
		SetDeclineStakingReward(true).
		SetAutoRenewPeriod(60 * time.Second).
		SetExpirationTime(time.Unix(34, 56)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetCryptoUpdateAccount()
	require.Equal(t, proto.AccountIDToUpdate.String(), accountID._ToProtobuf().String())
	require.Equal(t, proto.Key.String(), key._ToProtoKey().String())
	require.Equal(t, proto.Memo.Value, "ty")
	require.Equal(t, proto.ReceiverSigRequiredField.(*services.CryptoUpdateTransactionBody_ReceiverSigRequiredWrapper).ReceiverSigRequiredWrapper.Value, true)
	require.Equal(t, proto.MaxAutomaticTokenAssociations.GetValue(), int32(2))
	require.Equal(t, proto.StakedId.(*services.CryptoUpdateTransactionBody_StakedAccountId).StakedAccountId.String(),
		stackedAccountID._ToProtobuf().String())
	require.Equal(t, proto.DeclineReward.Value, true)
	require.Equal(t, proto.AutoRenewPeriod.String(), _DurationToProtobuf(60*time.Second).String())
	require.Equal(t, proto.ExpirationTime.String(), _TimeToProtobuf(time.Unix(34, 56)).String())
}

func TestUnitAccountUpdateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewAccountUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKey(key).
		SetAccountID(account).
		SetAccountMemo("ty").
		SetReceiverSignatureRequired(true).
		SetMaxAutomaticTokenAssociations(2).
		SetStakedAccountID(account).
		SetStakedNodeID(4).
		SetDeclineStakingReward(true).
		SetAutoRenewPeriod(60 * time.Second).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		SetGrpcDeadline(&grpc).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := key.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetStakedAccountID()
	transaction.GetStakedNodeID()
	transaction.ClearStakedAccountID()
	transaction.ClearStakedNodeID()
	transaction.GetDeclineStakingReward()
	transaction.GetExpirationTime()
	transaction.GetAccountMemo()

	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case *AccountUpdateTransaction:
		b.AddSignature(key.PublicKey(), sig)
	}
}
// Filename: address_book_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"context"
	"io"
	"math"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/hashgraph/hedera-protobufs-go/mirror"
	"google.golang.org/grpc/status"
)

// AddressBookQuery query an address book for its list of nodes
type AddressBookQuery struct {
	attempt     uint64
	maxAttempts uint64
	fileID      *FileID
	limit       int32
}

// Query the mirror node for the address book.
func NewAddressBookQuery() *AddressBookQuery {
	return &AddressBookQuery{
		fileID: nil,
		limit:  0,
	}
}

// SetFileID set the ID of the address book file on the network. Can be either 0.0.101 or 0.0.102.
func (q *AddressBookQuery) SetFileID(id FileID) *AddressBookQuery {
	q.fileID = &id
	return q
}

func (q *AddressBookQuery) GetFileID() FileID {
	if q.fileID == nil {
		return FileID{}
	}

	return *q.fileID
}

// SetLimit
// Set the maximum number of node addresses to receive before stopping.
// If not set or set to zero it will return all node addresses in the database.
func (q *AddressBookQuery) SetLimit(limit int32) *AddressBookQuery {
	q.limit = limit
	return q
}

func (q *AddressBookQuery) GetLimit() int32 {
	return q.limit
}

func (q *AddressBookQuery) SetMaxAttempts(maxAttempts uint64) *AddressBookQuery {
	q.maxAttempts = maxAttempts
	return q
}

func (q *AddressBookQuery) GetMaxAttempts() uint64 {
	return q.maxAttempts
}

func (q *AddressBookQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.fileID != nil {
		if err := q.fileID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *AddressBookQuery) build() *mirror.AddressBookQuery {
	body := &mirror.AddressBookQuery{
		Limit: q.limit,
	}
	if q.fileID != nil {
		body.FileId = q.fileID._ToProtobuf()
	}

	return body
}

// Execute executes the Query with the provided client
func (q *AddressBookQuery) Execute(client *Client) (NodeAddressBook, error) {
	var cancel func()
	var ctx context.Context
	var subClientError error
	err := q.validateNetworkOnIDs(client)
	if err != nil {
		return NodeAddressBook{}, err
	}

	pb := q.build()

	messages := make([]*services.NodeAddress, 0)

	channel, err := client.mirrorNetwork._GetNextMirrorNode()._GetNetworkServiceClient()
	if err != nil {
		return NodeAddressBook{}, err
	}
	ch := make(chan byte, 1)

	go func() {
		var subClient mirror.NetworkService_GetNodesClient
		var err error

		for {
			if err != nil {
				cancel()

				if grpcErr, ok := status.FromError(err); ok { // nolint
					if q.attempt < q.maxAttempts {
						subClient = nil

						delay := math.Min(250.0*math.Pow(2.0, float64(q.attempt)), 8000)
						time.Sleep(time.Duration(delay) * time.Millisecond)
						q.attempt++
					} else {
						subClientError = grpcErr.Err()
						break
					}
				} else if err == io.EOF {
					break
				} else {
					subClientError = err
					break
				}
			}

			if subClient == nil {
				ctx, cancel = context.WithCancel(client.networkUpdateContext)

				subClient, err = (*channel).GetNodes(ctx, pb)
				if err != nil {
					continue
				}
			}

			var resp *services.NodeAddress
			resp, err = subClient.Recv()

			if err != nil {
				continue
			}

			if pb.Limit > 0 {
				pb.Limit--
			}

			messages = append(messages, resp)
		}
		ch <- 1
	}()
	<-ch

	result := make([]NodeAddress, 0)

	for _, k := range messages {
		result = append(result, _NodeAddressFromProtobuf(k))
	}

	return NodeAddressBook{
		NodeAddresses: result,
	}, subClientError
}
// Filename: address_book_query_e2e_test.go
//go:build all || testnets
// +build all testnets

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"os"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestIntegrationAddressBookQueryUpdateAll(t *testing.T) {
	client, err := ClientFromConfig([]byte(`{"network":"previewnet"}`))
	require.NoError(t, err)
	client.SetMirrorNetwork(previewnetMirror)

	previewnet, err := NewAddressBookQuery().
		SetFileID(FileIDForAddressBook()).
		SetMaxAttempts(5).
		Execute(client)
	require.NoError(t, err)
	require.Greater(t, len(previewnet.NodeAddresses), 0)

	client, err = ClientFromConfig([]byte(`{"network":"testnet"}`))
	require.NoError(t, err)
	client.SetMirrorNetwork(testnetMirror)

	testnet, err := NewAddressBookQuery().
		SetFileID(FileIDForAddressBook()).
		SetMaxAttempts(5).
		Execute(client)

	require.NoError(t, err)
	require.Greater(t, len(testnet.NodeAddresses), 0)

	client, err = ClientFromConfig([]byte(`{"network":"mainnet"}`))
	require.NoError(t, err)
	client.SetMirrorNetwork(mainnetMirror)

	mainnet, err := NewAddressBookQuery().
		SetFileID(FileIDForAddressBook()).
		SetMaxAttempts(5).
		Execute(client)
	require.NoError(t, err)
	require.Greater(t, len(mainnet.NodeAddresses), 0)

	filePreviewnet, err := os.OpenFile("addressbook/previewnet.pb", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	require.NoError(t, err)

	fileTestnet, err := os.OpenFile("addressbook/testnet.pb", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	require.NoError(t, err)

	fileMainnet, err := os.OpenFile("addressbook/mainnet.pb", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	require.NoError(t, err)

	_, err = filePreviewnet.Write(previewnet.ToBytes())
	require.NoError(t, err)

	_, err = fileTestnet.Write(testnet.ToBytes())
	require.NoError(t, err)

	_, err = fileMainnet.Write(mainnet.ToBytes())
	require.NoError(t, err)

	err = filePreviewnet.Close()
	require.NoError(t, err)

	err = fileTestnet.Close()
	require.NoError(t, err)

	err = fileMainnet.Close()
	require.NoError(t, err)
}
// Filename: address_book_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

import (
	"testing"

	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

func TestUnitAddressBookQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	file := FileID{File: 3, checksum: &checksum}

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewAddressBookQuery().
		SetFileID(file).
		SetLimit(3).
		SetMaxAttempts(4)

	err = query.validateNetworkOnIDs(client)

	require.NoError(t, err)
	query.GetFileID()
	query.GetLimit()
	query.GetFileID()
}
// Filename: address_books.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
)

var mainnetAddressBookBytes, _ = hex.DecodeString("0ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633435363165336332373863643635306538306334313363613434343233633163336331336366313437356636663639373664353937616534333262343961623432303836623739623834313332363035346238623364636635376438666364373962666330353831383363613234636434633163626335373465643131313765326635623762336336336365376230366439623465666366373337353633376234316665366635336338313162396465363134336633613532393537636466393536373735313230623333373033666635373632313430376162393537356263326433356330643434663039383366633165663633613466663532303966303730633932616631303632393536303163393662636564303634656331393031393730313963363831316334633864643830636234663461633731663961643736653761633839343536666266346630313166393061626432643930353336653832333436353166366265663932376533643564386237626634353930353039383362656361336162656632613964393761663334353737326137373430653936393932373562303138656130646632383661646436636539323365663930386662653736326137356632313131363836326462343464336463613164343462346432653864633130363663353030366262356137643935346164323535643462363033323733343735653531316165623438356430363961303637633061623563323435333863393333633036623561366165666139343030356332393135323133653463636461653663393432663632373266396464353238326436623839306631663230656664323339396364363734393234666135373034366163366461333265373339353161373331313365393166633262376666323965343835316238336666333966383362613965633666303863656664626236636262626666616266646661613931643933306637323030646134383133376333393463626431336537303165636463323631366664323162616436383161613466303031303230333031303030312804320218073a603665396138616263646364653665313134396133656265313766643538643839303538333961383664623732623036613365613230616131373666383638623235343838353261653432336437613963366237636666396537313436323961320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613163343037373135343330336363373263346662373639326333663934323531626465633132333961316637613839373261626539316133353332336662656361363235613766666165363430366338353564633261663231313039303062306466306536653664623736333634646661316666653835656461353637393336653239383562383536333461333261613532613635393964643663333062653166376136633562386635656563616632363231643861343539363832666364326462616164313536316431316633336663636237663535303061633536386431363564626561616365333238366432383934663634313239643738316436633732666437643539396339653164336166346161343333633233623931306661653463343834313634316636313532366164373837656265613533393837343136376539643361373363633066623135363432396431356563373633613664306630363131356137396239616637383364373762393864383330393661613437343366393734303864396531346263663464646666653435393137363838343762343063623864613763613337353235366432623933356430393566653235326661653831666636653337663834643761393064376535373061346638656633633764373636656564613437326630393230313939303135613839303832353961383733633534353466636262646361643265353238646538353435356234303833633764633461646335613938386530636464666463313539643564373132616264353434616137336563303239303839383134633938613434663236666330363434363539633138336533313834616132373266386431646330626661336530613536303438346362303535626134646262356363333339656338306264313164363432646333613730326538633730336162323139333038346439626436336630646665313261343333633235373665616637383163666164383637656637306264613631373638623262656631346635306336633362386230393666303230333031303030312805320218083a606464336233653763643361323537643832373665343635333533363162303138623730303931663438363635653832303031306538316563303539326236396264346265316662643765636435303964303730313364643034313238343266640ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623263636163363561643066633736343561383137626661626334383761643765343133313165376133313938623337666238343264383463333935623366363764366264383438663130633666303363323930653866376461613864303031613834343164633335326131393136306133313933653638623832656466313961653637363933613961333364346362383765373839613130373037313535313565613737326361613862383661353639623931633534353038333564396333353466306461636563393766653737303931623435623134373639386237663836303134323264636432323631653932386465346461633963343264636261666466393663303732333362613330323730373666333763393639653865643330623662356438663530333462653764393263353936663862653836316535316663633361323432626639643862653965326139653865306631353565626366663233656666613763643537633130353432383131643830373736633935383535323666646230656161333465653139353564353131313933393066653837336534633034646564643239313635383834623938623436333038373838616537666334643461613461386663396263323637346261333231343933623632343435356164343130633164653731626339356431643931666130663230313431386137393565333039656166323937623639396266323763396661323736336364353963656230323165313662383230306331303630663238313766643833636663373637313833343839343631653335393932393162333830643665393339626161346231393233326136613237326464653635316638303436666463333464623237366137373764366662326265633332353562326363323434623461663536366231303566333063363530366464616530656233646564646366393437626362396336306530303039383466336234613863366334656434626639306263313933326237663934646333616536623336303030386562393032303430663962303230333031303030312802320218053a603561383634313561303861306138323566336232656237353031303135353230326533313234336665343161303333333834653738633138633131653565386632303964343933623062326664343565303662333734663262363964663564370ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613365333762373663366364356636363232643639323434343464313263363737633339356632623539303266336262393862386138623530353561373037373036636130323863643735303630613264383730326432643862303439343762646366653061386331343161613238343462316530366536363139303031326538623633323661623066613331373937336263376362346432393439663231303861613034633462306339316261613537323866356235363232656337356162663537386131663762343165646532613637656264363963313865353831666466396336303230616330646539636132633331663063363436393030333331316662623563653764623439633738376531613764323761613432356565376238346461376536363933396639633830643065383266636535356530326466633862356337383431386132366161343336353036393837313962616663656366306264343930303061646463666134303537303862646265666262313937343964323264616230303765343464343565613233623130366638383334633135326532353036326434636632346666323533353663376562333732393130353339336662343962616239303461303266306630626234313763643931396433353238393031323865366262666634666163396639306465313138613937346632613664643031653033326137396231373866363066613166636262643032623537303466623436323935633135313930383136333733656464363633356338353639373866316239353033663166373362346230626538616261326564316665656164353939353362663832656664653933613334373161626435356364613362613861363733666262333739393734396662303036643030336630653633663636356333343631643261376232396463386232303462613539613635363638613436616532383738663030643166393439306466396532383066656266343331356561303465616135363861336139666434386336326336336236656364613639303230333031303030312803320218063a606434363430333938303337393230373965636364356134343331316361306463323262353065633839356235366535336431326232396637326463366462613363616665326535623831303466626461303338616635623434376430666231320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393361323135636334613761373232636165396331336162643633366466393963636565633661663964623436623639666135313637313665663530636532343930613938316530396162303139636132636234363831316235623631396431626431643565653666343661343263373737636264656536343261313438346563646635646464333732393634326333386336643433613838353838373434373566353832343434333636346330346466656439623839303435666230383565323563336566636234383431373333656666376335323963313339653639333530633263643739623263386431393637396137313265346538636166643332363735343162383332623365313061303132353564656636396466316539643362386438656166303331316465363764356531326232366464303164626264396433653432643335643964653237313330326530663166363964383763626337616361396538383637653964343238643363616230363636656234393064356662616233306266663366373835643033663230373261343362623962356535343635366135393263623631656166643561356566323834633763616563363666376634373332356363306434633164323766363631643861373438636135303731633036656631333464666639366634303836363838333636643436386132343738303031376530623536616261376661623433623362376330623737393036666165353438326633323831316332393265366231343435346531346238393438303161383661303363633437373934646430643734353237613732653432346564336166613034383939656362396136336632613961653732626537666139383961646630643635613332633835316439383031666334313034386466333335363466633762333137303765633866623830313430666537623761316661313230626131636236363033323463656666623462636332643962623764653063663534633831396632646433626365616465633963323566356531396463396231303230333031303030312806320218093a603365303261363732306334343636353965383633303564353562666565383230623335653635306665636163633535333039373435356532633465303332636339646564313662316262343464336235393262626163623663326266663165360ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303930323539663465336439663066333934323536353438653963373330386231306237333430336363393039346439376164313531623737303631373062393737326365623634643636326563656639303161386437643135643331396135396338623731303731616363643839356237633933363130646336393736663637633465313732396261383337336162376535326133663363386632363534393164646536396436653039393934373065373434353938313133316264393663333665363836353230336662326562643564353065616461666237323633393664656331643931373438393862346539626530346337346433303466656164643963626433323334633362376633333036633939636230633333396663323539363962343164353861326237636663313833326532323664383163313936333939336532323535613038376431363938633033643432313062643634353830363434643039356361373661613137393465646434306331633837623566383261386533396636303365393731313662613034353738653765383033343634393564373835643465663763663737313462396562366635663965306239613934663462373338383436313962393237346434613935656631353735346138396439376566356331613838623664363933653061383065626435333766633963663063613931643163363264393135646537656438313862393532653634633230303239336565386532383461343136613732613365313266633764343233623135386639623439363630636263323436366662656430666564326532346531303266646539343265623463666439346265633436643364393066633038633339666563626130336530636132343634616536363462393739353135626132396531663730326333666537303262653739333739366438656462313761613438633039323930623032343534396630363131663561653233656437653136343432646637643164616432323836633262623039643535323264643365643639386332663032303330313030303128093202180c3a606339373462623938326338313931336237333236643561336639646363343836313261313566376161643032663230376230663130636432303137613666626666353830336537636139626662343730396162323862366230396435623133660ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303962646438653834666164616133353332666334636530316138613137643463336232333266353061393739306532363236383465646334383233653831356131626435623230656365613762663536653239663662623762383331666233626636656663643134373566306238656435666662306231333835623936643136366236323966303339366138666566356630366534626361323565653461313334306565323633613464396262303230643866343732333036663364383836313338646537613031396530353962643061666339303263636261316132313361653264616136306338613031333735356665306134386530333466356234303233613264616465616138386335343836383335336163376137613364663132623266623634313837373465396231346265366561623863633237623838303132616436313632646137346530656562313631333539303566343337333734646162383538366437353061323662626433616332346165643837386334643533653635313037326338373165393464376163633537356339363733383137333461353366656166346437626136626364643234316363363435386336303837643836333032616132353163303466366435366239633332643764393636323437353065643035353738356430373733663433646330393962323863393232383131343865366338316632393766663964313636653030306163303462333132343138363737356663656637356635656261306331303332626631333064663663643761343632313164306466336530353834643932656136373334396438343930353038656234656638386635346338633364343836646538373139663130666139366665623835636337393630373663613738313331386565326439656439303363613133333630343063353961643931613464326636393865393130386165306564623962316362393561643333623139376666623138626431626138623536636265653261616539353835656365323038613165313462343835363436333032303330313030303128083202180b3a603937303834333033333130373866353638326337663332343464383263336233653238316139313837393537386465656163646363326132656265353431616631383831313561643265383338363565356635643234376234613138633165650ab50722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303938383635646566326632616233373663376630663733386331643837613237616330316166643030383632306333356362366562666362623063333330303331393361333838633334366433303233313732373031323139336262373666643330303462383634333132633638396566353231336362623930313130313530396465616239346632366137333265363337393239646134633463623332353137653361646262333831316435306163346337376331666365386236353136303632313566333437303766336537323635353435653538633839343630396532383337366264623737373566653330343339653065313539326664636230633365653163333035373733643037326136623839353765616663653161313162653936356564616666333834333336366362366134346563323561383930313036653632343735363766373662353530666461343832626165633633303764363938656338383834316664363666323366323130653437623861396463626136626134653166613731366462333363383065333038313934393664636235653536303966623665376336313533373962646465643432376539323331623932353463326261663934333630386138366436393861653961336338363339646638383764366636623561373133383564323433333864393131613231326266373166316532616363386231383662393665633865363963383662366430353832313737373661303963396336383935336564623539313635373862356132363362326634363965336230633037656164613731613434376565613766386663316262383037343235353536376237663062643165366166623033353837313863393862343239653234623232393835393666633736636636616633393663613934333464373932366563376433376434623932616635366434356665666638313936303935323234613931366331666665366236363765323535666333616338636363656639323064633034346232353030333133326238373830363734326630323033303130303031320218033a603333373339306438666561313434616663313265383132353461323864616336656138323839333833366163303732656666643835653061373734383538306566323830393636343863356137663864626234636538313437363831353133370ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130306335376564623966663237366530323362323830323163623164383763646631393636623639386366343865346561616137633639323037376365656538636362323339613463393231353937653865383966376363303564336633313331353738393736633465333134343035643461346530336137323431306335633039636135323761643561383562393938363337653732613332653166626330643535343662323436356539653830366332646435303965623035306162356662323730363366643932383135623164643236383965323131316361656236663534396539346139663030663038323164346361366336613631313766356135333363393236336266303734613330643563626566353064316338633233383762636139373265646564613039383362356430613662353764636230303230303036383238623430653430373662343837306232346261643834303536656535326235663432326538383430303238633235303036333832643865396336363132323566346637366561373265333430363037653966633666336332303433333037366131636138636231356564303361633839363664303530376263646536383165346530323331656539663837643131316537623438616338663934643264383432623532646637336635373363633534313439363437393763363236393638666661653734313866336236313039623561306630396533323233663461346435653335303964643235303133386636626331376266366365636531373539343433306466313830613338653930616466326166666266616430633662386331623837663137386130363164636662666638623932633931363664383734633166663561663466626364626665386539643039393337306464663630626537343736333364333665653465623563643531663665336333333965313531653431626462356135636532633863393761306134336233636434636330383138383463383739663964326633373438343238633835373366313763393066336362643032303330313030303128073202180a3a603734306166366266373339653838336338386633333434633961306638623330316533396463393831633531363365306465326133666634326239396534323665643765353662363766343231383530333834356466363266343963396662300ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393133316161333638663933343532323966393762363235396363636166666561323365303063643565616430326533663639366331653731346565333933396461643836306533386266393561323937346639656234386539333433663861616334303565613935356430353332336531313762336231633934383133613361663432666538303832633364343362616631626434643833363765393364623030616436393665363237613130333661653533346630313165616435653536663337613666666534346236623965303939343031313932616435363061303334366234316138313030393566356632643766643332643665656236353562613735386336623532366331323933383661663731393763376135336165363033643632323833323235343936316631366430656661383037396137363835363138383862653733333439323231373935366262636166616562623631333563356662623234383464356234613566646630333336616330326532366331363532633162643865616633306461653164366433656230306637623466616238643634373866653864393565623931316466393636613064656134653532326462373662383936363537306563633561663039353136343234663061663566386565363665333836643536353037313339393731363961633337353733626635326664303538646539356162326666363865363831313161623233343035656139363462326262383864303263306631636165643731656364643465346534303835393438373666646238353030626335356337626130323036366530356162393864396637653034363664393730326562353765653337323266386663633835613735353035666633323632313730323838623738383732336164623937653464653536323063633930656164313338326663643735373138383966656662313165363737316263336636663366656231396337616335343238373864303361393032373035323663336565643234393465666635346531353363613966363839303230333031303030312801320218043a603765616236393661623935343336363538626331346666366234626534643932356364353162323230646632613164356336656531363061646166323961353165363934646533656531383463653232656164386437646239333231383266330ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038326465373330363566333466666332393334306435393439643232323062316534333636656435636637633665626436313663663934313661353365613030313766366262313136626664336633646566636331356237613464646630653434643032666536393536383830353365373961373730653230316263663731393333393030333965653866303836643466613734366337653035363931383330316639623565383465333932363238323830383561373962333232626361306235643835666539373232316132366262646532353863363230663064636561303261623165646431366363343961336632616239323838653364643166333764633462366136663731333366663932653534316337316237306432613266363664353537323561623138626638366430303965633364323466356431326530623565363830326431313531333732643462373634656265636234616638326636343934383565633537623561303164633637393538663561303363636161623763626139333534613137333732633133313662613437633935336161663934393031623366386332346536613361666436373538653766336231343363653264643363623037316232613734633932316365653934396134623561366265383739663163373930613662386436336231393264376565323961393439316664643638396139386330613763336436303332306631623461633264363232396466643934653432663361363034386137366265316562393538633861313837336265386433333861656339666335396162376633373632363738393430326331666435393566313930383735373565306265383237666334633061346662336433393361643734613934396363393836626662363463616264646165353339333566366463353630373464623933643737656133623831366264643662653533343439373237323238393835396666333463653531383630616666623632316431303438376463333834336631663836643534303334613633653438613161306430323033303130303031280a3202180d3a606132656363316232616539386264323862633161303864386633373161306434663734356337363864306337373339363235363265333433623235643833343235656565613765663865613134323935333432623865623738643332656333660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039383735356134303862353332316532363330353230303064366437643461326333613535346435653133383461396362356562663437346165383832633633623438366264303864313434646466316139346365396137643632353139363330303661666461616334353838343666313736343031393566653235333961363536393330656661383534663231343865363865633161303863316334396432303063336633303435666537313437663036643533346334626432363231303063623164643339373339643736306438316130626432306638336632353564323530376434636362313130366235333631386336613934343039633838376361653236326434636565396338363233323134376365633134303465306335376262613733313731333065653339363433383838616633643539386564643832623863363165363561653831613465316135366263303664333937313433613938643431636138376433656634333365663061656162363830313139316233653338343830393638663636623665383836363261663435613965323132393934663638623238386562393637626562393834373863323433653231333663316131353931663036316635626330346232316666326261343862323966313834333130383838373362646665393966386135326539343038393731383536653830346465613630326133313137383663393835363532393633633361333737303332396234303966373466646663373436623232613566383431383931323037316334636538343663396234623332306665646636653962363465326362653338346639613832623661616164346232303930373433316466316133336636393230376135363536303062653831303730643038333239303039393538353961343439386435623539333135626365626566656538303765623061336139343266316364663333363764643434343466646232393838366566636464306265346162653961313838383033393533383735656461333364623732393839663736336230323033303130303031280b3202180e3a603139366237623132303739376364623361396430303362393833643537646131303331303662313733306531376636376532633762616161646234333738396166313639366461313031316232353362636263383630333333383566303332380ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061396462376638626161313236383938666162373839313135613362356438393734346631393765323830343161653039386633653838366336393837313732316531316262306164313166336365393132346161393631643661306463383435663439373635633366616231393935383430323637366635363434363262663238316462613535383837383066303365393035373938653138343236396161613630663761313437323333316532666231646561646438373763383463626362363431636139653563386164366534356263313539636230373966636230643434396364636438643932333963316130343765376234343864613063646361323636313061323566323936643936653734363962363736643461343434353136653761353965383532393361383038366638343063303532383534653032613863623230303264616433353832356265346438336235326661393165386337336666303439373436313438383632373837633131313866393234643331636261633162343466656666323264343336623339373965616466396234336134626661373265313562343735356663616232363065303661323739633362623733626337663136613036306434643532326664343930353830333838616135393564383034343733366535323266363432343931356637383033623735383365303935636466373863333235313936393764653831623839666235303035343735336231613137663961616662303634643834633939326639616231316363626338636231303831346463616635323634616134356632316264656661633832636361636161663335386533313337336565316261346537343032666438613730656130633238636135636337346463343235313063393639636432633435396231656333363838613031656133396139393237313063643232393763393861383462363334386135373738303466646332333464336665313930336532633231653137326461323862353961653665346337653865646438623731633439643730323033303130303031280c3202180f3a603538343661353366343437353239666439636462373830346364333136383865643665656265336236336461326635663231316666626337333731393763663366316366626664613631626537643135313066306539323339383131376637340ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061386365616333363765623166316465356630643965663365616630646639623938343438666532303830383437363536326130363063353163323839373730623463616366653932636236353536393832336539363263326132633966656435336264333663613361313232646531633532356135383266323561346437643632386331613364356264623839333661656365373531306537353534656537303333303235633039326338323865656235373338626530326564393633646138316135393230353633346365393435343537376162383266343066313366316565353565306165373237653233633330323834623166343462393961636534646463356639616337616438386439666132323535393335623234646362613834303036343265313663663235333263306230643638393239303436303837313563343037366634366438346130653066656433366537366363646339363335356537613236313630393435633262353461653236636330306664303832333236333436656565656137646437356639313931316539396462636239396561346163366261303536633333323238643838316438353833316439636338373935393364613137343664643065653935646332623936666539336261666366663263643764393239353864373864663333663230356437313135656439666163346462366634636336306535366135343431646135623562353566613539393939303265393538613662366334346438313064646335363138313234316238376632326630353961363838306538303231373336643031383937646236353434396365383137613233373564303335353163623064653530376336303961306338303330656366346266646562323133633033646161373634613138323162373234333334663731663736386437616563623237373035326137303333373635663037323138303536633738663261383761663138333836643866363161356366636233663262613464643539393135663133643338363334643136393537353730323033303130303031280d320218103a603030306162636435396133306135333838633530306265363832663663613239343034363239356339323735383831633230643334626230643639306564613762333862366262643037613364643166646662366137303434626230396366660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061663062393134323537626637613436353563346135306430636164356530613165343538316564363632336630653837333066373936623866323963353831373862636363363933326331666333316633396566343462383264336334336233393837333733373366656362313239353232386130346664353061313466333634366438346665316634363763616562393864343633653239373565393935623864326531653339663362663661646463323561653335643635643032363038653033343535333739363665326162636534396238313462656164336331623735373137346165333063303062306334336539396238303439366237326433633133316631633665346663646130356632383131376566396532386334333033626534643863376530343264353862383363633132313934356132633635653739363263616139313835393338663337353764663763636139356366303262356533313934346133613631396130616333663165333462396230313364346332323463346631653730666439666433363938336566383661646535313833363263633833323263306637623631613961633735666238326537623836643638626330663039396130396131346361633561316438643338663961386137306363333766663563633362626432373432666664313436323535633137316536613137383038333237316463653066646536383165643439326362353962303739366432373031373538333864633539303831303765336136656133663961343036623364313133306363656333623437393165343962626332333136303362343661623264306639336434336265373561623961346437313065613934306532383561376231353362306361376364646565366439646365306164383335306334316439306332313562393538383531356166613061633333363561653037653831663362626233366264626561633462333162636231616134653832353635623937376639646164383564363236656566396161613965663864376533666230323033303130303031280e320218113a603933653238313031303462326231376230303935326235613431303264333365646230343363623136646533616433643364363832363066353562623065353837333765613539343463333338663763386362383863373833336663383630630ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038633037626533303561643630623930626132646162333962306565373736306531613232663835373532323534306437306230336233663965343837356133613239616230383038386631343466353765623235326534366261353933383564306536643432373031313764613061626331623362383036393463396135303538623836643631646661303665373136373039633838653866656163376333613065316432356663306165626636613866373666636239396638343566653138313436316361623638353862393763336134303237666233373132623134653663303738396465313764343137363435373765353131343137656231363236393265623037616531653733353532333565396262343339303437623663303136313337383265376464366636303464616134363734363631643533393631663436633366616136623765373637363264333733623562353432623739656139363365666266333361633638313938626232623636316366663637363931366566333732616434633236633231366334626334373837633834656333326431383464373763373531383663303963663364396639313433336361393835333131396261623331666136616432366634353365353936643962646563613638613537363962633866656537613533356438306338633666336566623164666232383861623661393739383534623763653833313234656330643130326166663934633362373466396333373839353863323565623933336464353363316538303561313836353464366439313836393930663635373034323966393630663334653862346637666439393732646362666539323430653037346461326433353561356637656639633161663632656635393832613831373435373862396331356334396563353636626461636233306363666365663039636466653730386164343837343234653963316265363533663965653736363065376439343263316566613564613238366531616464616230366139613333663964653934363739356230323033303130303031280f320218123a603934383235313739643163333934303137306233356432363665346366613830643737386335653966356261653764653833666638636334373431663362653336616336336431653761653439373261656466366263316533636632303638390ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030626531376339393634376365633635613434343037623533353835366233633362616566356235346635363561663538623834353662613863376365353335643561633732633631633434633736623363353763386538363438343136333762653130613833636665333963303932343736643064626534643663646364636437323061333062356266656235316130316131386635383263343566366338363939336663663764663138323933356465316438363930363034346463663335313836393335643962643765656137393532333532626562623465663961653066373636316537306134323337616661393839393636383763613438666366633562303064333830376630353462653066613863336266613432353033386265366566323935313634663232663733623765383863393465613962653861613466336132343563383962396431666435313932663761353062393538623265663831303462333666316266386664326366623238633134323138303063316334376534656639386166313530303730636336643639643137653865623932663138613661613161363532363661343935323338643130336638663639356235376563663337333635306130353230303837343537323162656138313536323739363763383037363336356466386334633761376434646438663263333835306331386662613731656236306536653864666264313936653035333766643730623334346563626363353330646663383364613666656466343964353161393034313935303262613964373063643335663163663363303639346532333534663930363466646266353335656232336332376330613433643062373863316638363763363164393836393564386465663762633261313062623636373463323266363661616230613931383133646466323763646238353263353965663739653162396531613037356661366565323761376533373734646266346232363436353432376536643561623931666537663066336137313738346563613138326235303230333031303030312810320218133a603038393039376465663031623037633764393734613537353532353161366161613061666236623332613534353334336432393138653732626164303433323163313131633234643432373538306633626131653236616139643735653632360ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613561643262373634336130346330353564326638636432353131623135313339666334353537353632313338386534396331313962326633393861636131313066363133393662306338363664653530363335323262623835343032373365313366366439346365316536303433386636616662303061616136343631326637313435653962636538626331613533623934313931336161373663396633613238333366616437636632383563376163326433376639396633633263646234396465346431353165363136373835363466323831663534313432346234316661376335316232613936303232383363376433326565303065623833386461313563333861666339366530363164393763656465323231363566663161613935396631633432373562326430393863343035383661353537396662623363623930303732373034313230613861363661353237306634666366643130383663393233363930613335653766643434356533336163303366313339633638363835353635373063646334616166323231303761366331613434323435366137633663373965653034303930653765356434663636626361363063613166343762366466623534336461633363626631396137373139613866353562366638336234613362386136366436303235366430613436353531666137303234626430353633316238613535383038373732353463326632663236386364633333643264626263666237333365396662653233336262396362353961623331613031343862323365386334323638306666313061663463373961346430383334366662373961393364393632393534386561663162623132343639386661656661346364643732343432633033613034623733333433326637343839303361333235633238336434353661623961653932316165376564333339316535643137383765666463323335343061376238356336393161653837306130376639306231316331336233326365343365616564313562333639363835636534393137376363393835303230333031303030312811320218143a603939666162633461646534653636326336653238323366346139366562323134343034383465356136643064333132623730633036386432326236323936333830376332333361343964626239383361376562623330653737303637373261340ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030386434356332316330633935656636356130323964353263393537666430663835663230313233646130333465363136373164646565353437356630373338326136366336366362346463353035303464646664333735383130383364663864313735373733306564386436663336346466346333366132363531353931393535646132303161323430376661386162396232333133383131323235613064613233306662653338306530393061613536656661346632303265633962343832336636353031643936616336393865626632366161636633656532643166333261373231633934376531303736636633356233373364613164383761333661313532653030653731303131373932323832653832356666313731633538333362383835373062666336646138343439653666393566386231323635616235353531393430333135353364316435373666393363343263306361363061616261633463386464313632643831313466326232313531313538336337323533396665353663343939613932396465336134306130643435633137633538396332643739383863653236656166633932613364333762376561303034326434336530336166613632373162323632353561366363636661653533373138323164383165306230356332353062353966306139303734316130653065383861303965643536633562393738306430393566303930366630623831643531323633393832616165303131333663303732643834346131316436646134623261363163363434653161623137663136666634386565323366656465383435326631653432653264333061303739306332356434323036306531643434613637316132656232336431313466363863373165333366313736646235386136386234333030353462633164323938336132336133326561366666393566613763346438653338306562323936653938623739363865636638343534643831376337333765656135646439323165623836633136633762323933303461346137656362653561336131303230333031303030312812320218153a606537396165396337313933643164326263393433383436346338616135663632323461653835323936366134336239383235383833663766373432633533393562643330393935383761393638363662393233396431656666336165353037610ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623035616265326162303066646430366339353565383637313062306530366631613932363234613438616431636263386466633666323231323936326230633330666462643238346133376335613337363538623633633336656138313632353631613865346639343663626535373232633032383830316630663238316337306638643838633763303061326632653239663539376237393938363965643833353664663537633437626539393434613261616666363530663962346262613064626335336463383830666462623639656134353139303564323830323230326638653239633034613736643237616632656237633534383438356266336634363934633930633431383130383838383433373932383438383335663738313637303764336538643736663465363766353738306263663038383133633535656336333961396264363234313738663565623134376435303061663335316539656631623165333432343834636132363064623763636261653438366631336366323635623562316162363838303636303038303533623230633364656463653737316339613038613033323061613963653435316562396439383361376234396361613130393666386164633039383331386463333865306537636566306438653564353537613036373536383561316339653235366132626339646261333232623362623331373263663731343037376263333830663861306134333361386266613766626663353966366230393365633862663665393339376330396231386531383034306331623536363836343733376338666137653239373935663361343538386464613763326261623439353636356363346139623833366532656239306336326133666361663539316662356638313830346337363138306536323666613236343461376465333435313164366334363637643938393337653237373333663464316539313338383333353465353466643733353137323165373666376235366333343833333838663461366238376232386165626562303230333031303030312813320218163a603962343038383566313362366163316337353336393262613366313739303061333838333165363934613061663937343934623834333838323039636235656662646339386136646162623265316337313833393166633133356264616163330ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396463643863306135336539306333353539353734663636323034313137643362353033653530613336643330393766616338343239653663656364333762623534303731383038663265653938323033356638353161306339626532313736333833613232653338633161626131363866333266393035373063623332333363666536323539383736363661663637623531346361656632316662386466366430666364333363663236303662393264646561353533366236303638643836373832653339626435633338343435393931643431396237643165633038353939343132633039343964316332343062333563313464633535323734646261373166666165393336313235613566383139663534313332653234333964346163353539373939366563653835653133646666333336316639313331663536636561633562396635353262343963663666396139616336653564636532646233363934363266393361663830653562353662366538626566613136326130363162346137363839326264633834363437333036633630303835386664643237303332373663326337303434303139386566643766653335343563663261623538306337346366643634343561616637626437663734356363323532656162643236356561626565383632343137313034653639343861353537353666646332323264663061313031353234646531633363303863636630343330313165633766653936346564643834353161313330313437633037333633613335663131666465656638663261326237363137353762343335386666383962373561343864363762646336303930363933653062623836373965636262393366666462336633656439366265633933656634363536653337313661623837636534366361386531323539633866656464653866326631656130663365623263343865393635353164653132333330333435373235663435656436396338353735623531363833616661343732363231383236646232326262326431633466316533363436346139303230333031303030312814320218173a60346630613033333466393737363738313632663830643936376637323139313431333630633062376637663033316233376336396536323137333933336564616434366263626139373636376565373262666435613933346261313532326330")

var testnetAddressBookBytes, _ = hex.DecodeString("0a7f0a0c33342e39342e3130362e363110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a80010a0d35302e31382e3133322e32313110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a81010a0e3133382e39312e3134322e32313910a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a82010a0d33352e3233372e3131392e353510a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a7f0a0a332e3231322e362e313310a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d35322e3136382e37362e32343110a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d33352e3234352e32372e31393310a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a80010a0b35322e32302e31382e383610a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a81010a0c34302e37392e38332e31323410a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a82010a0d33342e38332e3131322e31313610a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35342e37302e3139322e333310a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35322e3138332e34352e363510a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a80010a0b33342e39342e3136302e3410a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e35342e3137362e3139392e31303910a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a82010a0d31332e36342e3138312e31333610a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e33342e3130362e3130322e32313810a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a82010a0d33352e3135352e34392e31343710a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a81010a0c31332e37382e3233382e333210a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a83010a0e33342e3133332e3139372e32333010a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e31342e3235322e32303710a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e3136352e31372e32333110a388031a05302e302e392806320218093a60363938333261373361333630326538643166626535616435386431633236333761316236373264373165653837616631306462363438656239316166623232383235336231663437653537643364346134346666353437623333393461613232")

var previewnetAddressBookBytes, _ = hex.DecodeString("0a890822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a60666664366164613734613361333461393034626561343736303330383666386265663362366265313861626564343463346434306531326662313330623937626436623835356165633564306239306230623863373335346435663362306534420a0a0423e7d09410a38803420a0a0403d3f8ac10a48803420a0a0423e7d09410a48803420a0a042879403010a38803420a0a042879403010a48803420a0a0403d3f8ac10a38803420a0a0423e7d09410a388030a8b0822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a60663064393461636366366466663337323837346339646264386437393932656233313761663530303163613431393661626132363538303963623364323030626139363161353433386333613565643035633833626466396364313135643232420a0a040385d59210a48803420a0a0423c70fb110a38803420a0a0428460bca10a48803420a0a0423c70fb110a48803420a0a0423c70fb110a38803420a0a040385d59210a38803420a0a0428460bca10a388030a8b0822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a60636136373865626362643364633836343866376564303366623539663065323161663637353133656165653531333138653662353439626535616365393036656463316666613236643933613537616365633962653737663430656165656437420a0a0423e1c9c310a38803420a0a04340f698210a48803420a0a0423e1c9c310a48803420a0a04340f698210a38803420a0a04682bf83f10a38803420a0a0423e1c9c310a38803420a0a04682bf83f10a488030a8b0822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a60323437316633666538313430363831666539313931336432636330363366303635653434393061653632666635643534386135616265313331643261663936636265336163323562626532343336366361346638663065373663663934356633420a0a0436f1260110a38803420a0a0423f76d8710a38803420a0a040d58162f10a38803420a0a0423f76d8710a38803420a0a0436f1260110a48803420a0a040d58162f10a48803420a0a0423f76d8710a488030a8b0822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a60663335373837336434313134613161656630336164633662613639656661663236393065323237616263313661366663366535303439613633666264393638383030346231346534363363323065333834333661336132346433313832646438420a0a0436b1337f10a48803420a0a0423eb413310a38803420a0a040d40aa2810a38803420a0a0423eb413310a48803420a0a0423eb413310a38803420a0a040d40aa2810a48803420a0a0436b1337f10a388030a8b0822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a60343933316137383230326435356631306233313537353738356333663433396462363831396264313130303364663762633263653932653239613531376237633231383830646562346330313739353734346235373663643433623834393864420a0a04226af74110a38803420a0a04235359ab10a38803420a0a040d4ee8c010a48803420a0a040d4ee8c010a38803420a0a04226af74110a48803420a0a04235359ab10a48803420a0a04226af74110a388030a8b0822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a60363465303938363135626634303566376564356134303133343436623839633438386366636436626232356134613637366463373765656131316433336437303236383266306136396138303330653863353737376430653432323033373939420a0a043212115d10a38803420a0a04227d173110a38803420a0a041496885910a48803420a0a04227d173110a38803420a0a041496885910a38803420a0a04227d173110a48803420a0a043212115d10a48803")

var mainnetAddressBook, _ = NodeAddressBookFromBytes(mainnetAddressBookBytes)
var testnetAddressBook, _ = NodeAddressBookFromBytes(testnetAddressBookBytes)
var previewnetAddressBook, _ = NodeAddressBookFromBytes(previewnetAddressBookBytes)
// Filename: assessed_custom_fee.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

type AssessedCustomFee struct {
	Amount                int64
	TokenID               *TokenID
	FeeCollectorAccountId *AccountID // nolint
	PayerAccountIDs       []*AccountID
}

func _AssessedCustomFeeFromProtobuf(assessedFee *services.AssessedCustomFee) AssessedCustomFee {
	accountID := _AccountIDFromProtobuf(assessedFee.FeeCollectorAccountId)
	tokenID := _TokenIDFromProtobuf(assessedFee.TokenId)

	payerAccountIds := make([]*AccountID, 0)

	for _, id := range assessedFee.EffectivePayerAccountId {
		payerAccountIds = append(payerAccountIds, _AccountIDFromProtobuf(id))
	}

	return AssessedCustomFee{
		Amount:                assessedFee.Amount,
		TokenID:               tokenID,
		FeeCollectorAccountId: accountID,
		PayerAccountIDs:       payerAccountIds,
	}
}

func (fee *AssessedCustomFee) _ToProtobuf() *services.AssessedCustomFee {
	var tokenID *services.TokenID
	if fee.TokenID != nil {
		tokenID = fee.TokenID._ToProtobuf()
	}

	var accountID *services.AccountID
	if fee.FeeCollectorAccountId != nil {
		accountID = fee.FeeCollectorAccountId._ToProtobuf()
	}

	payerAccountIds := make([]*services.AccountID, len(fee.PayerAccountIDs))

	for _, id := range fee.PayerAccountIDs {
		payerAccountIds = append(payerAccountIds, id._ToProtobuf())
	}

	return &services.AssessedCustomFee{
		Amount:                  fee.Amount,
		TokenId:                 tokenID,
		FeeCollectorAccountId:   accountID,
		EffectivePayerAccountId: payerAccountIds,
	}
}

// ToBytes returns the serialized bytes of a AssessedCustomFee
func (fee *AssessedCustomFee) ToBytes() []byte {
	data, err := protobuf.Marshal(fee._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// AssessedCustomFeeFromBytes returns a AssessedCustomFee from bytes
func AssessedCustomFeeFromBytes(data []byte) (AssessedCustomFee, error) {
	if data == nil {
		return AssessedCustomFee{}, errByteArrayNull
	}
	pb := services.AssessedCustomFee{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return AssessedCustomFee{}, err
	}

	return _AssessedCustomFeeFromProtobuf(&pb), nil
}

// String returns a string representation of a AssessedCustomFee
func (fee AssessedCustomFee) String() string {
	accountIDs := ""
	for _, s := range fee.PayerAccountIDs {
		accountIDs = accountIDs + " " + s.String()
	}
	if fee.TokenID != nil {
		return fmt.Sprintf("feeCollectorAccountID: %s, amount: %d, tokenID: %s, payerAccountIds: %s", fee.FeeCollectorAccountId.String(), fee.Amount, fee.TokenID.String(), accountIDs)
	}

	return fmt.Sprintf("feeCollectorAccountID: %s, amount: %d, payerAccountIds: %s", fee.FeeCollectorAccountId.String(), fee.Amount, accountIDs)
}
// Filename: assessed_custom_fee_unit_test.go
//go:build all || unit
// +build all unit

package hedera

import (
	"testing"

	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// The test checks the conversation methods on the AssessedCustomFee struct. We check wether it is correctly converted to protobuf and back.
func TestUnitassessedCustomFee(t *testing.T) {
	t.Parallel()
	assessedFeeOriginal := _MockAssessedCustomFee()
	assessedFeeBytes := assessedFeeOriginal.ToBytes()
	assessedFeeFromBytes, err := AssessedCustomFeeFromBytes(assessedFeeBytes)
	require.NoError(t, err)
	require.Equal(t, assessedFeeOriginal, assessedFeeFromBytes)
}

func _MockAssessedCustomFee() AssessedCustomFee {
	accountID, _ := AccountIDFromString("0.0.123-esxsf")
	accountID.checksum = nil
	return AssessedCustomFee{
		Amount:                100,
		TokenID:               nil,
		FeeCollectorAccountId: &accountID,
		PayerAccountIDs:       []*AccountID{},
	}
}
// Filename: bip32_utils.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

var hardenedBit uint32 = 0x80000000

// Harden the index
func ToHardenedIndex(index uint32) uint32 {
	return index | hardenedBit
}

// Check if the index is hardened
func IsHardenedIndex(index uint32) bool {
	return (index & hardenedBit) != 0
}
// Filename: channel.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/grpc"
)

type _Channel struct {
	crypto      services.CryptoServiceClient
	file        services.FileServiceClient
	contract    services.SmartContractServiceClient
	topic       services.ConsensusServiceClient
	freeze      services.FreezeServiceClient
	network     services.NetworkServiceClient
	token       services.TokenServiceClient
	schedule    services.ScheduleServiceClient
	util        services.UtilServiceClient
	addressBook services.AddressBookServiceClient
	client      *grpc.ClientConn
}

func _NewChannel(client *grpc.ClientConn) _Channel {
	return _Channel{
		client: client,
	}
}

func (channel _Channel) _GetCrypto() services.CryptoServiceClient {
	if channel.crypto == nil {
		channel.crypto = services.NewCryptoServiceClient(channel.client)
	}

	return channel.crypto
}

func (channel _Channel) _GetFile() services.FileServiceClient {
	if channel.file == nil {
		channel.file = services.NewFileServiceClient(channel.client)
	}

	return channel.file
}

func (channel _Channel) _GetContract() services.SmartContractServiceClient {
	if channel.contract == nil {
		channel.contract = services.NewSmartContractServiceClient(channel.client)
	}

	return channel.contract
}

func (channel _Channel) _GetTopic() services.ConsensusServiceClient {
	if channel.topic == nil {
		channel.topic = services.NewConsensusServiceClient(channel.client)
	}

	return channel.topic
}

func (channel _Channel) _GetFreeze() services.FreezeServiceClient {
	if channel.freeze == nil {
		channel.freeze = services.NewFreezeServiceClient(channel.client)
	}

	return channel.freeze
}

func (channel _Channel) _GetNetwork() services.NetworkServiceClient {
	if channel.network == nil {
		channel.network = services.NewNetworkServiceClient(channel.client)
	}

	return channel.network
}

func (channel _Channel) _GetToken() services.TokenServiceClient {
	if channel.token == nil {
		channel.token = services.NewTokenServiceClient(channel.client)
	}

	return channel.token
}

func (channel _Channel) _GetSchedule() services.ScheduleServiceClient {
	if channel.schedule == nil {
		channel.schedule = services.NewScheduleServiceClient(channel.client)
	}

	return channel.schedule
}

func (channel _Channel) _GetUtil() services.UtilServiceClient {
	if channel.util == nil {
		channel.util = services.NewUtilServiceClient(channel.client)
	}

	return channel.util
}

func (channel _Channel) _GetAddressBook() services.AddressBookServiceClient {
	if channel.addressBook == nil {
		channel.addressBook = services.NewAddressBookServiceClient(channel.client)
	}

	return channel.addressBook
}
// Filename: client.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"context"
	_ "embed"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"time"
)

//go:embed addressbook/mainnet.pb
var mainnetAddress []byte
var mainnetNodes, _ = NodeAddressBookFromBytes(mainnetAddress)

//go:embed addressbook/previewnet.pb
var previewnetAddress []byte
var previewnetNodes, _ = NodeAddressBookFromBytes(previewnetAddress)

//go:embed addressbook/testnet.pb
var testnetAddress []byte
var testnetNodes, _ = NodeAddressBookFromBytes(testnetAddress)

// Client is the Hedera protocol wrapper for the SDK used by all
// transaction and query types.
type Client struct {
	defaultMaxTransactionFee Hbar
	defaultMaxQueryPayment   Hbar

	operator *_Operator

	network                         _Network
	mirrorNetwork                   *_MirrorNetwork
	autoValidateChecksums           bool
	defaultRegenerateTransactionIDs bool
	maxAttempts                     *int

	maxBackoff time.Duration
	minBackoff time.Duration

	requestTimeout             *time.Duration
	defaultNetworkUpdatePeriod time.Duration
	networkUpdateContext       context.Context
	cancelNetworkUpdate        context.CancelFunc
	logger                     Logger
}

// TransactionSigner is a closure or function that defines how transactions will be signed
type TransactionSigner func(message []byte) []byte

type _Operator struct {
	accountID  AccountID
	privateKey *PrivateKey
	publicKey  PublicKey
	signer     TransactionSigner
}

var mainnetMirror = []string{"mainnet-public.mirrornode.hedera.com:443"}
var testnetMirror = []string{"testnet.mirrornode.hedera.com:443"}
var previewnetMirror = []string{"previewnet.mirrornode.hedera.com:443"}

// ClientForNetwork constructs a client given a set of nodes.
func ClientForNetwork(network map[string]AccountID) *Client {
	net := _NewNetwork()
	client := _NewClient(net, []string{}, nil)
	_ = client.SetNetwork(network)
	net._SetLedgerID(*NewLedgerIDMainnet())
	return client
}

// ClientForMainnet returns a preconfigured client for use with the standard
// Hedera mainnet.
// Most users will want to set an _Operator account with .SetOperator so
// transactions can be automatically given TransactionIDs and signed.
func ClientForMainnet() *Client {
	return _NewClient(*_NetworkForMainnet(mainnetNodes._ToMap()), mainnetMirror, NewLedgerIDMainnet())
}

// ClientForTestnet returns a preconfigured client for use with the standard
// Hedera testnet.
// Most users will want to set an _Operator account with .SetOperator so
// transactions can be automatically given TransactionIDs and signed.
func ClientForTestnet() *Client {
	return _NewClient(*_NetworkForTestnet(testnetNodes._ToMap()), testnetMirror, NewLedgerIDTestnet())
}

// ClientForPreviewnet returns a preconfigured client for use with the standard
// Hedera previewnet.
// Most users will want to set an _Operator account with .SetOperator so
// transactions can be automatically given TransactionIDs and signed.
func ClientForPreviewnet() *Client {
	return _NewClient(*_NetworkForPreviewnet(previewnetNodes._ToMap()), previewnetMirror, NewLedgerIDPreviewnet())
}

// newClient takes in a map of _Node addresses to their respective IDS (_Network)
// and returns a Client instance which can be used to
func _NewClient(network _Network, mirrorNetwork []string, ledgerId *LedgerID) *Client {
	ctx, cancel := context.WithCancel(context.Background())
	logger := NewLogger("hedera-sdk-go", LogLevel(os.Getenv("HEDERA_SDK_GO_LOG_LEVEL")))
	var defaultLogger Logger = logger

	client := Client{
		defaultMaxQueryPayment:          NewHbar(1),
		network:                         network,
		mirrorNetwork:                   _NewMirrorNetwork(),
		autoValidateChecksums:           false,
		maxAttempts:                     nil,
		minBackoff:                      250 * time.Millisecond,
		maxBackoff:                      8 * time.Second,
		defaultRegenerateTransactionIDs: true,
		defaultNetworkUpdatePeriod:      24 * time.Hour,
		networkUpdateContext:            ctx,
		cancelNetworkUpdate:             cancel,
		logger:                          defaultLogger,
	}

	client.SetMirrorNetwork(mirrorNetwork)
	if ledgerId != nil {
		client.SetLedgerID(*ledgerId)
	}

	// We can't ask for AddressBook from non existent Mirror node
	if len(mirrorNetwork) > 0 {
		// Update the Addressbook, before the default timeout starts
		client._UpdateAddressBook()
		go client._ScheduleNetworkUpdate(ctx, client.defaultNetworkUpdatePeriod)
	}

	return &client
}

func (client *Client) _UpdateAddressBook() {
	addressbook, err := NewAddressBookQuery().
		SetFileID(FileIDForAddressBook()).
		Execute(client)
	if err == nil && len(addressbook.NodeAddresses) > 0 {
		client.SetNetworkFromAddressBook(addressbook)
	}
}

func (client *Client) _ScheduleNetworkUpdate(ctx context.Context, duration time.Duration) {
	for {
		select {
		case <-ctx.Done():
			return
		case <-time.After(duration):
			client._UpdateAddressBook()
		}
	}
}

// CancelScheduledNetworkUpdate cancels the scheduled network update the network address book
func (client *Client) CancelScheduledNetworkUpdate() {
	client.cancelNetworkUpdate()
}

// SetNetworkUpdatePeriod sets how often the client will update the network address book
func (client *Client) SetNetworkUpdatePeriod(period time.Duration) *Client {
	client.defaultNetworkUpdatePeriod = period
	client.CancelScheduledNetworkUpdate()
	client.networkUpdateContext, client.cancelNetworkUpdate = context.WithCancel(context.Background())
	go client._ScheduleNetworkUpdate(client.networkUpdateContext, period)
	return client
}

// GetNetworkUpdatePeriod returns the current network update period
func (client *Client) GetNetworkUpdatePeriod() time.Duration {
	return client.defaultNetworkUpdatePeriod
}

// ClientForName set up the client for the selected network.
func ClientForName(name string) (*Client, error) {
	switch name {
	case string(NetworkNameTestnet):
		return ClientForTestnet(), nil
	case string(NetworkNamePreviewnet):
		return ClientForPreviewnet(), nil
	case string(NetworkNameMainnet):
		return ClientForMainnet(), nil
	case "local", "localhost":
		network := make(map[string]AccountID)
		network["127.0.0.1:50213"] = AccountID{Account: 3}
		mirror := []string{"127.0.0.1:5600"}
		client := ClientForNetwork(network)
		client.SetMirrorNetwork(mirror)
		return client, nil
	default:
		return &Client{}, fmt.Errorf("%q is not recognized as a valid Hedera _Network", name)
	}
}

type _ConfigOperator struct {
	AccountID  string `json:"accountId"`
	PrivateKey string `json:"privateKey"`
}

// TODO: Implement complete spec: https://gitlab.com/launchbadge/hedera/sdk/python/-/issues/45
type _ClientConfig struct {
	Network       interface{}      `json:"network"`
	MirrorNetwork interface{}      `json:"mirrorNetwork"`
	Operator      *_ConfigOperator `json:"operator"`
}

// ClientFromConfig takes in the byte slice representation of a JSON string or
// document and returns Client based on the configuration.
func ClientFromConfig(jsonBytes []byte) (*Client, error) {
	var clientConfig _ClientConfig
	var client *Client

	err := json.Unmarshal(jsonBytes, &clientConfig)
	if err != nil {
		return nil, err
	}

	network := _NewNetwork()
	networkAddresses := make(map[string]AccountID)

	switch net := clientConfig.Network.(type) {
	case map[string]interface{}:
		for url, inter := range net {
			switch id := inter.(type) {
			case string:
				accountID, err := AccountIDFromString(id)
				if err != nil {
					return client, err
				}
				networkAddresses[url] = accountID
			default:
				return client, errors.New("network is expected to be map of string to string, or string")
			}
		}
		err = network.SetNetwork(networkAddresses)
		if err != nil {
			return &Client{}, err
		}
	case string:
		if len(net) > 0 {
			switch net {
			case string(NetworkNameMainnet):
				network = *_NetworkForMainnet(mainnetNodes._ToMap())
			case string(NetworkNamePreviewnet):
				network = *_NetworkForPreviewnet(previewnetNodes._ToMap())
			case string(NetworkNameTestnet):
				network = *_NetworkForTestnet(testnetNodes._ToMap())
			}
		}
	default:
		return client, errors.New("network is expected to be map of string to string, or string")
	}

	switch mirror := clientConfig.MirrorNetwork.(type) {
	case []interface{}:
		arr := make([]string, len(mirror))
		for i, inter := range mirror {
			switch str := inter.(type) {
			case string:
				arr[i] = str
			default:
				return client, errors.New("mirrorNetwork is expected to be either string or an array of strings")
			}
		}
		client = _NewClient(network, arr, nil)
	case string:
		if len(mirror) > 0 {
			switch mirror {
			case string(NetworkNameMainnet):
				client = _NewClient(network, mainnetMirror, NewLedgerIDMainnet())
			case string(NetworkNameTestnet):
				client = _NewClient(network, testnetMirror, NewLedgerIDTestnet())
			case string(NetworkNamePreviewnet):
				client = _NewClient(network, previewnetMirror, NewLedgerIDPreviewnet())
			}
		}
	case nil:
		client = _NewClient(network, []string{}, nil)
	default:
		return client, errors.New("mirrorNetwork is expected to be a string, an array of strings or nil")
	}

	// if the _Operator is not provided, finish here
	if clientConfig.Operator == nil {
		return client, nil
	}

	operatorID, err := AccountIDFromString(clientConfig.Operator.AccountID)
	if err != nil {
		return client, err
	}

	operatorKey, err := PrivateKeyFromString(clientConfig.Operator.PrivateKey)

	if err != nil {
		return client, err
	}

	operator := _Operator{
		accountID:  operatorID,
		privateKey: &operatorKey,
		publicKey:  operatorKey.PublicKey(),
		signer:     operatorKey.Sign,
	}

	client.operator = &operator

	return client, nil
}

// ClientFromConfigFile takes a filename string representing the path to a JSON encoded
// Client file and returns a Client based on the configuration.
func ClientFromConfigFile(filename string) (*Client, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}

	defer func() {
		err = file.Close()
	}()

	configBytes, err := io.ReadAll(file)
	if err != nil {
		return nil, err
	}

	return ClientFromConfig(configBytes)
}

// Close is used to disconnect the Client from the _Network
func (client *Client) Close() error {
	client.CancelScheduledNetworkUpdate()
	err := client.network._Close()
	if err != nil {
		return err
	}
	err = client.mirrorNetwork._Close()
	if err != nil {
		return err
	}

	return nil
}

// SetNetwork replaces all nodes in this Client with a new set of nodes.
func (client *Client) SetNetwork(network map[string]AccountID) error {
	return client.network.SetNetwork(network)
}

// GetNetwork returns the current set of nodes in this Client.
func (client *Client) GetNetwork() map[string]AccountID {
	return client.network._GetNetwork()
}

// SetMaxNodeReadmitTime The maximum amount of time to wait before attempting to
// reconnect to a node that has been removed from the network.
func (client *Client) SetMaxNodeReadmitTime(readmitTime time.Duration) {
	client.network._SetMaxNodeReadmitPeriod(readmitTime)
}

// GetMaxNodeReadmitTime returns the maximum amount of time to wait before attempting to
// reconnect to a node that has been removed from the network.
func (client *Client) GetMaxNodeReadmitPeriod() time.Duration {
	return client.network._GetMaxNodeReadmitPeriod()
}

// SetMinNodeReadmitTime The minimum amount of time to wait before attempting to
// reconnect to a node that has been removed from the network.
func (client *Client) SetMinNodeReadmitTime(readmitTime time.Duration) {
	client.network._SetMinNodeReadmitPeriod(readmitTime)
}

// GetMinNodeReadmitTime returns the minimum amount of time to wait before attempting to
// reconnect to a node that has been removed from the network.
func (client *Client) GetMinNodeReadmitPeriod() time.Duration {
	return client.network._GetMinNodeReadmitPeriod()
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (client *Client) SetMaxBackoff(max time.Duration) {
	if max.Nanoseconds() < 0 {
		panic("maxBackoff must be a positive duration")
	} else if max.Nanoseconds() < client.minBackoff.Nanoseconds() {
		panic("maxBackoff must be greater than or equal to minBackoff")
	}
	client.maxBackoff = max
}

// GetMaxBackoff returns the maximum amount of time to wait between retries.
func (client *Client) GetMaxBackoff() time.Duration {
	return client.maxBackoff
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (client *Client) SetMinBackoff(min time.Duration) {
	if min.Nanoseconds() < 0 {
		panic("minBackoff must be a positive duration")
	} else if client.maxBackoff.Nanoseconds() < min.Nanoseconds() {
		panic("minBackoff must be less than or equal to maxBackoff")
	}
	client.minBackoff = min
}

// GetMinBackoff returns the minimum amount of time to wait between retries.
func (client *Client) GetMinBackoff() time.Duration {
	return client.minBackoff
}

// SetMaxAttempts sets the maximum number of times to attempt a transaction or query.
func (client *Client) SetMaxAttempts(max int) {
	client.maxAttempts = &max
}

// GetMaxAttempts returns the maximum number of times to attempt a transaction or query.
func (client *Client) GetMaxAttempts() int {
	if client.maxAttempts == nil {
		return -1
	}

	return *client.maxAttempts
}

// SetMaxNodeAttempts sets the maximum number of times to attempt a transaction or query on a single node.
func (client *Client) SetMaxNodeAttempts(max int) {
	client.network._SetMaxNodeAttempts(max)
}

// GetMaxNodeAttempts returns the maximum number of times to attempt a transaction or query on a single node.
func (client *Client) GetMaxNodeAttempts() int {
	return client.network._GetMaxNodeAttempts()
}

// Deprecated: use SetNodeMinBackoff
func (client *Client) SetNodeWaitTime(nodeWait time.Duration) {
	client.network._SetNodeMinBackoff(nodeWait)
}

// Deprecated: use GetNodeMinBackoff
func (client *Client) GetNodeWaitTime() time.Duration {
	return client.network._GetNodeMinBackoff()
}

// SetNodeMinBackoff sets the minimum amount of time to wait between retries on a single node.
func (client *Client) SetNodeMinBackoff(nodeWait time.Duration) {
	client.network._SetNodeMinBackoff(nodeWait)
}

// GetNodeMinBackoff returns the minimum amount of time to wait between retries on a single node.
func (client *Client) GetNodeMinBackoff() time.Duration {
	return client.network._GetNodeMinBackoff()
}

// SetNodeMaxBackoff sets the maximum amount of time to wait between retries on a single node.
func (client *Client) SetNodeMaxBackoff(nodeWait time.Duration) {
	client.network._SetNodeMaxBackoff(nodeWait)
}

// GetNodeMaxBackoff returns the maximum amount of time to wait between retries on a single node.
func (client *Client) GetNodeMaxBackoff() time.Duration {
	return client.network._GetNodeMaxBackoff()
}

// SetMaxNodesPerTransaction sets the maximum number of nodes to try for a single transaction.
func (client *Client) SetMaxNodesPerTransaction(max int) {
	client.network._SetMaxNodesPerTransaction(max)
}

// SetNetwork replaces all _Nodes in the Client with a new set of _Nodes.
// (e.g. for an Address Book update).
func (client *Client) SetMirrorNetwork(mirrorNetwork []string) {
	_ = client.mirrorNetwork._SetNetwork(mirrorNetwork)
}

// GetNetwork returns the mirror network node list.
func (client *Client) GetMirrorNetwork() []string {
	return client.mirrorNetwork._GetNetwork()
}

// SetTransportSecurity sets if transport security should be used to connect to consensus nodes.
// If transport security is enabled all connections to consensus nodes will use TLS, and
// the server's certificate hash will be compared to the hash stored in the NodeAddressBook
// for the given network.
// *Note*: If transport security is enabled, but {@link Client#isVerifyCertificates()} is disabled
// then server certificates will not be verified.
func (client *Client) SetTransportSecurity(tls bool) *Client {
	client.network._SetTransportSecurity(tls)

	return client
}

// SetCertificateVerification sets if server certificates should be verified against an existing address book.
func (client *Client) SetCertificateVerification(verify bool) *Client {
	client.network._SetVerifyCertificate(verify)

	return client
}

// GetCertificateVerification returns if server certificates should be verified against an existing address book.
func (client *Client) GetCertificateVerification() bool {
	return client.network._GetVerifyCertificate()
}

// Deprecated: Use SetLedgerID instead
func (client *Client) SetNetworkName(name NetworkName) {
	ledgerID, _ := LedgerIDFromNetworkName(name)
	client.SetLedgerID(*ledgerID)
}

// Deprecated: Use GetLedgerID instead
func (client *Client) GetNetworkName() *NetworkName {
	name, _ := client.GetLedgerID().ToNetworkName()
	return &name
}

// SetLedgerID sets the ledger ID for the Client.
func (client *Client) SetLedgerID(id LedgerID) {
	client.network._SetLedgerID(id)
}

// GetLedgerID returns the ledger ID for the Client.
func (client *Client) GetLedgerID() *LedgerID {
	return client.network._GetLedgerID()
}

// SetAutoValidateChecksums sets if an automatic entity ID checksum validation should be performed.
func (client *Client) SetAutoValidateChecksums(validate bool) {
	client.autoValidateChecksums = validate
}

// GetAutoValidateChecksums returns if an automatic entity ID checksum validation should be performed.
func (client *Client) GetAutoValidateChecksums() bool {
	return client.autoValidateChecksums
}

// SetDefaultRegenerateTransactionIDs sets if an automatic transaction ID regeneration should be performed.
func (client *Client) SetDefaultRegenerateTransactionIDs(regen bool) {
	client.defaultRegenerateTransactionIDs = regen
}

// GetDefaultRegenerateTransactionIDs returns if an automatic transaction ID regeneration should be performed.
func (client *Client) GetDefaultRegenerateTransactionIDs() bool {
	return client.defaultRegenerateTransactionIDs
}

// SetNodeMinReadmitPeriod sets the minimum amount of time to wait before attempting to
// reconnect to a node that has been removed from the network.
func (client *Client) SetNodeMinReadmitPeriod(period time.Duration) {
	client.network._SetNodeMinReadmitPeriod(period)
}

// SetNodeMaxReadmitPeriod sets the maximum amount of time to wait before attempting to
// reconnect to a node that has been removed from the network.
func (client *Client) SetNodeMaxReadmitPeriod(period time.Duration) {
	client.network._SetNodeMaxReadmitPeriod(period)
}

// GetNodeMinReadmitPeriod returns the minimum amount of time to wait before attempting to
// reconnect to a node that has been removed from the network.
func (client *Client) GetNodeMinReadmitPeriod() time.Duration {
	return client.network._GetNodeMinReadmitPeriod()
}

// GetNodeMaxReadmitPeriod returns the maximum amount of time to wait before attempting to
// reconnect to a node that has been removed from the network.
func (client *Client) GetNodeMaxReadmitPeriod() time.Duration {
	return client.network._GetNodeMaxReadmitPeriod()
}

// SetOperator sets that account that will, by default, be paying for
// transactions and queries built with the client and the associated key
// with which to automatically sign transactions.
func (client *Client) SetOperator(accountID AccountID, privateKey PrivateKey) *Client {
	client.operator = &_Operator{
		accountID:  accountID,
		privateKey: &privateKey,
		publicKey:  privateKey.PublicKey(),
		signer:     privateKey.Sign,
	}

	return client
}

// SetOperatorWith sets that account that will, by default, be paying for
// transactions and queries built with the client, the account's PublicKey
// and a callback that will be invoked when a transaction needs to be signed.
func (client *Client) SetOperatorWith(accountID AccountID, publicKey PublicKey, signer TransactionSigner) *Client {
	client.operator = &_Operator{
		accountID:  accountID,
		privateKey: nil,
		publicKey:  publicKey,
		signer:     signer,
	}

	return client
}

// SetRequestTimeout sets the timeout for all requests made by the client.
func (client *Client) SetRequestTimeout(timeout *time.Duration) {
	client.requestTimeout = timeout
}

// GetRequestTimeout returns the timeout for all requests made by the client.
func (client *Client) GetRequestTimeout() *time.Duration {
	return client.requestTimeout
}

// GetOperatorAccountID returns the ID for the _Operator
func (client *Client) GetOperatorAccountID() AccountID {
	if client.operator != nil {
		return client.operator.accountID
	}

	return AccountID{}
}

// GetOperatorPublicKey returns the Key for the _Operator
func (client *Client) GetOperatorPublicKey() PublicKey {
	if client.operator != nil {
		return client.operator.publicKey
	}

	return PublicKey{}
}

// Ping sends an AccountBalanceQuery to the specified _Node returning nil if no
// problems occur. Otherwise, an error representing the status of the _Node will
// be returned.
func (client *Client) Ping(nodeID AccountID) error {
	_, err := NewAccountBalanceQuery().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetAccountID(client.GetOperatorAccountID()).
		Execute(client)

	return err
}

func (client *Client) PingAll() {
	for _, s := range client.GetNetwork() {
		_ = client.Ping(s)
	}
}

// SetNetworkFromAddressBook replaces all nodes in this Client with the nodes in the Address Book.
func (client *Client) SetNetworkFromAddressBook(addressBook NodeAddressBook) *Client {
	client.network._SetNetworkFromAddressBook(addressBook)
	return client
}

// SetDefaultMaxQueryPayment sets the default maximum payment allowed for queries.
func (client *Client) SetDefaultMaxQueryPayment(defaultMaxQueryPayment Hbar) error {
	if defaultMaxQueryPayment.AsTinybar() < 0 {
		return errors.New("DefaultMaxQueryPayment must be non-negative")
	}

	client.defaultMaxQueryPayment = defaultMaxQueryPayment
	return nil
}

// GetDefaultMaxQueryPayment returns the default maximum payment allowed for queries.
func (client *Client) GetDefaultMaxQueryPayment() Hbar {
	return client.defaultMaxQueryPayment
}

// SetDefaultMaxTransactionFee sets the default maximum fee allowed for transactions.
func (client *Client) SetDefaultMaxTransactionFee(defaultMaxTransactionFee Hbar) error {
	if defaultMaxTransactionFee.AsTinybar() < 0 {
		return errors.New("DefaultMaxTransactionFee must be non-negative")
	}

	client.defaultMaxTransactionFee = defaultMaxTransactionFee
	return nil
}

// GetDefaultMaxTransactionFee returns the default maximum fee allowed for transactions.
func (client *Client) GetDefaultMaxTransactionFee() Hbar {
	return client.defaultMaxTransactionFee
}

func (client *Client) SetLogger(logger Logger) *Client {
	client.logger = logger
	return client
}

func (client *Client) GetLogger() Logger {
	return client.logger
}

func (client *Client) SetLogLevel(level LogLevel) *Client {
	client.logger.SetLevel(level)
	return client
}
// Filename: client_all_test.go
//go:build all || unit || e2e
// +build all unit e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

const testClientJSONWithOperator string = `{
    "network": {
		"35.237.200.180:50211": "0.0.3",
		"35.186.191.247:50211": "0.0.4",
		"35.192.2.25:50211": "0.0.5",
		"35.199.161.108:50211": "0.0.6",
		"35.203.82.240:50211": "0.0.7",
		"35.236.5.219:50211": "0.0.8",
		"35.197.192.225:50211": "0.0.9",
		"35.242.233.154:50211": "0.0.10",
		"35.240.118.96:50211": "0.0.11",
		"35.204.86.32:50211": "0.0.12"
    },
    "operator": {
        "accountId": "0.0.3",
        "privateKey": "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10"
    },
    "mirrorNetwork": "testnet"
}`

const testClientJSONWithoutMirrorNetwork string = `{
    "network": {
		"35.237.200.180:50211": "0.0.3",
		"35.186.191.247:50211": "0.0.4",
		"35.192.2.25:50211": "0.0.5",
		"35.199.161.108:50211": "0.0.6",
		"35.203.82.240:50211": "0.0.7",
		"35.236.5.219:50211": "0.0.8",
		"35.197.192.225:50211": "0.0.9",
		"35.242.233.154:50211": "0.0.10",
		"35.240.118.96:50211": "0.0.11",
		"35.204.86.32:50211": "0.0.12"
    },
    "operator": {
        "accountId": "0.0.3",
        "privateKey": "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10"
    }
}`

const testClientJSONWrongTypeMirror string = `{
    "network": "testnet",
    "operator": {
        "accountId": "0.0.3",
        "privateKey": "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10"
    },
 	"mirrorNetwork": 5
}`

const testClientJSONWrongTypeNetwork string = `{
    "network": 1,
    "operator": {
        "accountId": "0.0.3",
        "privateKey": "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10"
    },
 	"mirrorNetwork": ["testnet.mirrornode.hedera.com:443"]
}`

const testClientJSONWrongAccountIDNetwork string = `{
    "network": {"35.237.200.180:50211": "0.0.3"},
    "operator": {
        "accountId": "wrong",
        "privateKey": "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10"
    },
 	"mirrorNetwork": ["testnet.mirrornode.hedera.com:443"]
}`
// Filename: client_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationClientCanExecuteSerializedTransactionFromAnotherClient(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	client2 := ClientForNetwork(env.Client.GetNetwork())
	client2.SetOperator(env.OperatorID, env.OperatorKey)

	tx, err := NewTransferTransaction().AddHbarTransfer(env.OperatorID, HbarFromTinybar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(1)).SetNodeAccountIDs([]AccountID{{Account: 3}}).FreezeWith(env.Client)
	require.NoError(t, err)
	txBytes, err := tx.ToBytes()
	FromBytes, err := TransactionFromBytes(txBytes)
	require.NoError(t, err)
	txFromBytes, ok := FromBytes.(TransferTransaction)
	require.True(t, ok)
	resp, err := txFromBytes.Execute(client2)
	require.NoError(t, err)
	reciept, err := resp.SetValidateStatus(true).GetReceipt(client2)
	require.NoError(t, err)
	assert.Equal(t, StatusSuccess, reciept.Status)
}

func TestIntegrationClientCanFailGracefullyWhenDoesNotHaveNodeOfAnotherClient(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Get one of the nodes of the network from the original client
	var address string
	for key := range env.Client.GetNetwork() {
		address = key
		break
	}
	// Use that node to create a network for the second client but with a different node account id
	var network = map[string]AccountID{
		address: {Account: 99},
	}

	client2 := ClientForNetwork(network)
	client2.SetOperator(env.OperatorID, env.OperatorKey)

	// Create a transaction with a node using original client
	tx, err := NewTransferTransaction().AddHbarTransfer(env.OperatorID, HbarFromTinybar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(1)).SetNodeAccountIDs([]AccountID{{Account: 3}}).FreezeWith(env.Client)
	require.NoError(t, err)
	txBytes, err := tx.ToBytes()
	FromBytes, err := TransactionFromBytes(txBytes)
	require.NoError(t, err)
	txFromBytes, ok := FromBytes.(TransferTransaction)
	require.True(t, ok)

	// Try to execute it with the second client, which does not have the node
	_, err = txFromBytes.Execute(client2)
	require.Error(t, err)
	require.Equal(t, err.Error(), "Invalid node AccountID was set for transaction: 0.0.3")
}

func DisabledTestIntegrationClientPingAllBadNetwork(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	netwrk := _NewNetwork()
	netwrk.SetNetwork(env.Client.GetNetwork())

	tempClient := _NewClient(netwrk, env.Client.GetMirrorNetwork(), env.Client.GetLedgerID())
	tempClient.SetOperator(env.OperatorID, env.OperatorKey)

	tempClient.SetMaxNodeAttempts(1)
	tempClient.SetMaxNodesPerTransaction(2)
	tempClient.SetMaxAttempts(3)
	net := tempClient.GetNetwork()
	assert.True(t, len(net) > 1)

	keys := make([]string, len(net))
	val := make([]AccountID, len(net))
	i := 0
	for st, n := range net {
		keys[i] = st
		val[i] = n
		i++
	}

	tempNet := make(map[string]AccountID, 2)
	tempNet["in.process.ew:3123"] = val[0]
	tempNet[keys[1]] = val[1]

	err := tempClient.SetNetwork(tempNet)
	require.NoError(t, err)

	tempClient.PingAll()

	net = tempClient.GetNetwork()
	i = 0
	for st, n := range net {
		keys[i] = st
		val[i] = n
		i++
	}

	_, err = NewAccountBalanceQuery().
		SetAccountID(val[0]).
		Execute(tempClient)
	require.NoError(t, err)

	assert.Equal(t, 1, len(tempClient.GetNetwork()))

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: client_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"
	"time"

	"github.com/rs/zerolog"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitClientFromConfig(t *testing.T) {
	t.Parallel()

	client, err := ClientFromConfig([]byte(testClientJSON))
	require.NoError(t, err)

	assert.NotNil(t, client)
	assert.True(t, len(client.network.network) > 0)
	assert.Nil(t, client.operator)
}

func TestUnitClientFromConfigWithOperator(t *testing.T) {
	t.Parallel()

	client, err := ClientFromConfig([]byte(testClientJSONWithOperator))
	require.NoError(t, err)

	assert.NotNil(t, client)

	testOperatorKey, err := PrivateKeyFromString("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10")
	require.NoError(t, err)

	assert.True(t, len(client.network.network) > 0)
	assert.NotNil(t, client.operator)
	assert.Equal(t, testOperatorKey.ed25519PrivateKey.keyData, client.operator.privateKey.ed25519PrivateKey.keyData)
	assert.Equal(t, AccountID{Account: 3}.Account, client.operator.accountID.Account)
}

func TestUnitClientFromConfigWithoutMirrorNetwork(t *testing.T) {
	t.Parallel()

	client, err := ClientFromConfig([]byte(testClientJSONWithoutMirrorNetwork))
	require.NoError(t, err)
	assert.NotNil(t, client)

	assert.True(t, len(client.network.network) > 0)
	assert.True(t, len(client.GetMirrorNetwork()) == 0)
}

func TestUnitClientFromConfigWrongMirrorNetworkType(t *testing.T) {
	t.Parallel()

	_, err := ClientFromConfig([]byte(testClientJSONWrongTypeMirror))
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "mirrorNetwork is expected to be a string, an array of strings or nil", err.Error())
	}
}

func TestUnitClientFromConfigWrongNetworkType(t *testing.T) {
	t.Parallel()

	_, err := ClientFromConfig([]byte(testClientJSONWrongTypeNetwork))
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network is expected to be map of string to string, or string", err.Error())
	}
}

func TestUnitClientFromConfigWrongAccountIDNetworkType(t *testing.T) {
	_, err := ClientFromConfig([]byte(testClientJSONWrongAccountIDNetwork))
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "expected {shard}.{realm}.{num}", err.Error())
	}
}

func TestUnitClientFromCorrectConfigFile(t *testing.T) {
	t.Parallel()

	client, err := ClientFromConfigFile("client-config-with-operator.json")
	assert.NoError(t, err)
	assert.NotNil(t, client)
	assert.NotNil(t, client.operator)
	assert.Equal(t, AccountID{Account: 3}.Account, client.operator.accountID.Account)
	assert.Equal(t, "a608e2130a0a3cb34f86e757303c862bee353d9ab77ba4387ec084f881d420d4", client.operator.privateKey.StringRaw())
}

func TestUnitClientFromMissingConfigFile(t *testing.T) {
	t.Parallel()

	client, err := ClientFromConfigFile("missing.json")
	assert.Error(t, err)
	assert.Nil(t, client)
}

func TestUnitClientSetNetworkExtensive(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	nodes := make(map[string]AccountID, 2)
	nodes["0.testnet.hedera.com:50211"] = AccountID{0, 0, 3, nil, nil, nil}
	nodes["1.testnet.hedera.com:50211"] = AccountID{0, 0, 4, nil, nil, nil}

	err = client.SetNetwork(nodes)
	require.NoError(t, err)
	network := client.GetNetwork()
	assert.Equal(t, 2, len(network))
	assert.Equal(t, network["0.testnet.hedera.com:50211"], AccountID{0, 0, 3, nil, nil, nil})
	assert.Equal(t, network["1.testnet.hedera.com:50211"], AccountID{0, 0, 4, nil, nil, nil})

	nodes = make(map[string]AccountID, 2)
	nodes["0.testnet.hedera.com:50211"] = AccountID{0, 0, 3, nil, nil, nil}
	nodes["1.testnet.hedera.com:50211"] = AccountID{0, 0, 4, nil, nil, nil}
	nodes["2.testnet.hedera.com:50211"] = AccountID{0, 0, 5, nil, nil, nil}

	err = client.SetNetwork(nodes)
	require.NoError(t, err)
	network = client.GetNetwork()
	assert.Equal(t, 3, len(network))
	assert.Equal(t, network["0.testnet.hedera.com:50211"], AccountID{0, 0, 3, nil, nil, nil})
	assert.Equal(t, network["1.testnet.hedera.com:50211"], AccountID{0, 0, 4, nil, nil, nil})
	assert.Equal(t, network["2.testnet.hedera.com:50211"], AccountID{0, 0, 5, nil, nil, nil})

	nodes = make(map[string]AccountID, 1)
	nodes["2.testnet.hedera.com:50211"] = AccountID{0, 0, 5, nil, nil, nil}

	err = client.SetNetwork(nodes)
	require.NoError(t, err)
	network = client.GetNetwork()
	networkMirror := client.GetMirrorNetwork()
	assert.Equal(t, 1, len(network))
	assert.Equal(t, network["2.testnet.hedera.com:50211"], AccountID{0, 0, 5, nil, nil, nil})
	// There is only one mirror address, no matter the transport security
	assert.Equal(t, "nonexistent-mirror-testnet:443", networkMirror[0])

	client.SetTransportSecurity(true)
	client.SetCertificateVerification(true)
	network = client.GetNetwork()
	networkMirror = client.GetMirrorNetwork()
	assert.Equal(t, network["2.testnet.hedera.com:50212"], AccountID{0, 0, 5, nil, nil, nil})
	assert.Equal(t, "nonexistent-mirror-testnet:443", networkMirror[0])

	err = client.Close()
	require.NoError(t, err)
}

func TestUnitClientSetMirrorNetwork(t *testing.T) {
	t.Parallel()

	mirrorNetworkString := "testnet.mirrornode.hedera.com:443"
	mirrorNetwork1String := "testnet1.mirrornode.hedera.com:443"
	defaultNetwork := make([]string, 0)
	defaultNetwork = append(defaultNetwork, mirrorNetworkString)
	client, err := _NewMockClient()
	require.NoError(t, err)
	client.SetMirrorNetwork(defaultNetwork)

	mirrorNetwork := client.GetMirrorNetwork()
	assert.Equal(t, 1, len(mirrorNetwork))
	assert.Equal(t, mirrorNetworkString, mirrorNetwork[0])

	defaultNetworkWithExtraNode := make([]string, 0)
	defaultNetworkWithExtraNode = append(defaultNetworkWithExtraNode, mirrorNetworkString)
	defaultNetworkWithExtraNode = append(defaultNetworkWithExtraNode, mirrorNetwork1String)

	client.SetMirrorNetwork(defaultNetworkWithExtraNode)
	mirrorNetwork = client.GetMirrorNetwork()
	assert.Equal(t, 2, len(mirrorNetwork))
	require.True(t, contains(mirrorNetwork, mirrorNetworkString))
	require.True(t, contains(mirrorNetwork, mirrorNetwork1String))

	defaultNetwork = make([]string, 0)
	defaultNetwork = append(defaultNetwork, mirrorNetwork1String)

	client.SetMirrorNetwork(defaultNetwork)
	mirrorNetwork = client.GetMirrorNetwork()
	assert.Equal(t, 1, len(mirrorNetwork))
	assert.Equal(t, mirrorNetwork1String, mirrorNetwork[0])

	defaultNetwork = make([]string, 0)
	defaultNetwork = append(defaultNetwork, mirrorNetworkString)

	client.SetMirrorNetwork(defaultNetwork)
	mirrorNetwork = client.GetMirrorNetwork()
	assert.Equal(t, 1, len(mirrorNetwork))
	assert.Equal(t, mirrorNetworkString, mirrorNetwork[0])

	client.SetTransportSecurity(true)
	mirrorNetwork = client.GetMirrorNetwork()
	// SetTransportSecurity is deprecated, so the mirror node should not be updated
	assert.Equal(t, mirrorNetworkString, mirrorNetwork[0])

	err = client.Close()
	require.NoError(t, err)
}

func contains(s []string, e string) bool {
	for _, a := range s {
		if a == e {
			return true
		}
	}
	return false
}

func TestUnitClientSetMultipleNetwork(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	nodes := make(map[string]AccountID, 8)
	nodes["0.testnet.hedera.com:50211"] = AccountID{0, 0, 3, nil, nil, nil}
	nodes["34.94.106.61:50211"] = AccountID{0, 0, 3, nil, nil, nil}
	nodes["50.18.132.211:50211"] = AccountID{0, 0, 3, nil, nil, nil}
	nodes["138.91.142.219:50211"] = AccountID{0, 0, 3, nil, nil, nil}

	nodes["1.testnet.hedera.com:50211"] = AccountID{0, 0, 4, nil, nil, nil}
	nodes["35.237.119.55:50211"] = AccountID{0, 0, 4, nil, nil, nil}
	nodes["3.212.6.13:50211"] = AccountID{0, 0, 4, nil, nil, nil}
	nodes["52.168.76.241:50211"] = AccountID{0, 0, 4, nil, nil, nil}

	err = client.SetNetwork(nodes)
	require.NoError(t, err)
	net := client.GetNetwork()

	if val, ok := net["0.testnet.hedera.com:50211"]; ok {
		require.Equal(t, val.String(), "0.0.3")
	}

	if val, ok := net["1.testnet.hedera.com:50211"]; ok {
		require.Equal(t, val.String(), "0.0.4")
	}

	if val, ok := net["50.18.132.211:50211"]; ok {
		require.Equal(t, val.String(), "0.0.3")
	}

	if val, ok := net["3.212.6.13:50211"]; ok {
		require.Equal(t, val.String(), "0.0.4")
	}

}

func TestUnitClientLogger(t *testing.T) {
	client := ClientForTestnet()

	var buf bytes.Buffer
	writer := zerolog.ConsoleWriter{Out: &buf, TimeFormat: time.RFC3339}

	hederaLoger := NewLogger("test", LoggerLevelTrace)

	l := zerolog.New(&writer)
	hederaLoger.logger = &l

	client.SetLogger(hederaLoger)
	client.SetLogLevel(LoggerLevelInfo)

	client.logger.Trace("trace message", "traceKey", "traceValue")
	client.logger.Debug("debug message", "debugKey", "debugValue")
	client.logger.Info("info message", "infoKey", "infoValue")
	client.logger.Warn("warn message", "warnKey", "warnValue")
	client.logger.Error("error message", "errorKey", "errorValue")

	assert.NotContains(t, buf.String(), "trace message")
	assert.NotContains(t, buf.String(), "debug message")
	assert.Contains(t, buf.String(), "info message")
	assert.Contains(t, buf.String(), "warn message")
	assert.Contains(t, buf.String(), "error message")

	buf.Reset()
	client.SetLogLevel(LoggerLevelWarn)
	client.logger.Trace("trace message", "traceKey", "traceValue")
	client.logger.Debug("debug message", "debugKey", "debugValue")
	client.logger.Info("info message", "infoKey", "infoValue")
	client.logger.Warn("warn message", "warnKey", "warnValue")
	client.logger.Error("error message", "errorKey", "errorValue")

	assert.NotContains(t, buf.String(), "trace message")
	assert.NotContains(t, buf.String(), "debug message")
	assert.NotContains(t, buf.String(), "info message")
	assert.Contains(t, buf.String(), "warn message")
	assert.Contains(t, buf.String(), "error message")

	buf.Reset()
	client.SetLogLevel(LoggerLevelTrace)
	client.logger.Trace("trace message", "traceKey", "traceValue")
	client.logger.Debug("debug message", "debugKey", "debugValue")
	client.logger.Info("info message", "infoKey", "infoValue")
	client.logger.Warn("warn message", "warnKey", "warnValue")
	client.logger.Error("error message", "errorKey", "errorValue")

	assert.Contains(t, buf.String(), "trace message")
	assert.Contains(t, buf.String(), "debug message")
	assert.Contains(t, buf.String(), "info message")
	assert.Contains(t, buf.String(), "warn message")
	assert.Contains(t, buf.String(), "error message")

	hl := client.GetLogger()
	assert.Equal(t, hl, hederaLoger)
}
// Filename: contract_bytecode_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ContractBytecodeQuery retrieves the bytecode for a smart contract instance
type ContractBytecodeQuery struct {
	Query
	contractID *ContractID
}

// NewContractBytecodeQuery creates a ContractBytecodeQuery query which can be used to construct and execute a
// Contract Get Bytecode Query.
func NewContractBytecodeQuery() *ContractBytecodeQuery {
	header := services.QueryHeader{}
	return &ContractBytecodeQuery{
		Query: _NewQuery(true, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *ContractBytecodeQuery) SetGrpcDeadline(deadline *time.Duration) *ContractBytecodeQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetContractID sets the contract for which the bytecode is requested
func (q *ContractBytecodeQuery) SetContractID(contractID ContractID) *ContractBytecodeQuery {
	q.contractID = &contractID
	return q
}

// GetContractID returns the contract for which the bytecode is requested
func (q *ContractBytecodeQuery) GetContractID() ContractID {
	if q.contractID == nil {
		return ContractID{}
	}

	return *q.contractID
}

func (q *ContractBytecodeQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *ContractBytecodeQuery) Execute(client *Client) ([]byte, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return []byte{}, err
	}

	return resp.GetContractGetBytecodeResponse().Bytecode, nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *ContractBytecodeQuery) SetMaxQueryPayment(maxPayment Hbar) *ContractBytecodeQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *ContractBytecodeQuery) SetQueryPayment(paymentAmount Hbar) *ContractBytecodeQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this ContractBytecodeQuery.
func (q *ContractBytecodeQuery) SetNodeAccountIDs(accountID []AccountID) *ContractBytecodeQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *ContractBytecodeQuery) SetMaxRetry(count int) *ContractBytecodeQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *ContractBytecodeQuery) SetMaxBackoff(max time.Duration) *ContractBytecodeQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *ContractBytecodeQuery) SetMinBackoff(min time.Duration) *ContractBytecodeQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *ContractBytecodeQuery) SetPaymentTransactionID(transactionID TransactionID) *ContractBytecodeQuery {
	q.paymentTransactionIDs._Clear()._Push(transactionID)._SetLocked(true)
	return q
}

func (q *ContractBytecodeQuery) SetLogLevel(level LogLevel) *ContractBytecodeQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *ContractBytecodeQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetContract().ContractGetBytecode}
}

func (q *ContractBytecodeQuery) getName() string {
	return "ContractBytecodeQuery"
}

func (q *ContractBytecodeQuery) buildQuery() *services.Query {
	pb := services.Query_ContractGetBytecode{
		ContractGetBytecode: &services.ContractGetBytecodeQuery{
			Header: q.pbHeader,
		},
	}

	if q.contractID != nil {
		pb.ContractGetBytecode.ContractID = q.contractID._ToProtobuf()
	}

	return &services.Query{
		Query: &pb,
	}
}

func (q *ContractBytecodeQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.contractID != nil {
		if err := q.contractID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *ContractBytecodeQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetContractGetBytecodeResponse()
}
// Filename: contract_bytecode_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationContractBytecodeQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.FileID)
	fileID := *receipt.FileID

	contractResponse, err := NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := contractResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, contractReceipt.ContractID)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	contractID := *contractReceipt.ContractID

	bytecode, err := NewContractBytecodeQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractID(contractID).
		SetMaxQueryPayment(NewHbar(2)).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, len(bytecode), 798)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractBytecodeQueryGetCostExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey).
		SetContents(smartContractBytecode).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.FileID)
	fileID := *receipt.FileID

	contractResponse, err := NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := contractResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, contractReceipt.ContractID)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	contractID := *contractReceipt.ContractID

	bytecodeQuery := NewContractBytecodeQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		SetContractID(contractID)

	cost, err := bytecodeQuery.GetCost(env.Client)
	require.NoError(t, err)

	bytecode, err := bytecodeQuery.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, len(bytecode), 798)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractBytecodeQuerySetBigMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKeys(env.OperatorKey).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.FileID)
	fileID := *receipt.FileID

	contractResponse, err := NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := contractResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, contractReceipt.ContractID)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	contractID := *contractReceipt.ContractID

	bytecodeQuery := NewContractBytecodeQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(200000)).
		SetContractID(contractID)

	cost, err := bytecodeQuery.GetCost(env.Client)
	require.NoError(t, err)

	bytecode, err := bytecodeQuery.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, len(bytecode), 798)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractBytecodeQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.FileID)
	fileID := *receipt.FileID

	contractResponse, err := NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := contractResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, contractReceipt.ContractID)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	contractID := *contractReceipt.ContractID

	bytecodeQuery := NewContractBytecodeQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(HbarFromTinybar(1)).
		SetContractID(contractID)

	cost, err := bytecodeQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = bytecodeQuery.Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "cost of ContractBytecodeQuery ("+cost.String()+") without explicit payment is greater than the max query payment of 1 tℏ", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractBytecodeQueryInsufficientFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey).
		SetContents(smartContractBytecode).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.FileID)
	fileID := *receipt.FileID

	contractResponse, err := NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := contractResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, contractReceipt.ContractID)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	contractID := *contractReceipt.ContractID

	bytecodeQuery := NewContractBytecodeQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		SetContractID(contractID)

	_, err = bytecodeQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = bytecodeQuery.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_TX_FEE", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractBytecodeQueryNoContractID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	contractResponse, err := NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := contractResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, contractReceipt.ContractID)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	contractID := *contractReceipt.ContractID

	_, err = NewContractBytecodeQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(2)).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_CONTRACT_ID", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: contract_bytecode_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitContractBytecodeQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	contractBytecode := NewContractBytecodeQuery().
		SetContractID(contractID)

	err = contractBytecode.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitContractBytecodeQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	contractBytecode := NewContractBytecodeQuery().
		SetContractID(contractID)

	err = contractBytecode.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitContractBytecodeQueryMock(t *testing.T) {
	t.Parallel()

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")
	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_ContractGetBytecodeResponse{
				ContractGetBytecodeResponse: &services.ContractGetBytecodeResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_ContractGetBytecodeResponse{
				ContractGetBytecodeResponse: &services.ContractGetBytecodeResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_ContractGetBytecodeResponse{
				ContractGetBytecodeResponse: &services.ContractGetBytecodeResponse{
					Header:   &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					Bytecode: smartContractBytecode,
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewContractBytecodeQuery().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetContractID(ContractID{Contract: 3}).
		SetMaxQueryPayment(NewHbar(2))

	_, err := query.GetCost(client)
	require.NoError(t, err)
	bytecode, err := query.Execute(client)
	require.NoError(t, err)

	require.Equal(t, bytes.Compare(bytecode, smartContractBytecode), 0)
}

func TestUnitContractBytecodeQueryGet(t *testing.T) {
	t.Parallel()

	contractID := ContractID{Contract: 7}

	balance := NewContractBytecodeQuery().
		SetContractID(contractID).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(10)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}})

	balance.GetContractID()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitContractBytecodeQuerySetNothing(t *testing.T) {
	t.Parallel()

	balance := NewContractBytecodeQuery()

	balance.GetContractID()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitContractBytecodeQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 3
	contract := ContractID{Contract: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewContractBytecodeQuery().
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetContractID(contract).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3)).
		SetGrpcDeadline(&grpc)

	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)
	query.GetNodeAccountIDs()
	query.GetMaxBackoff()
	query.GetMinBackoff()
	query.getName()
	query.GetContractID()
}
// Filename: contract_call_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ContractCallQuery calls a function of the given smart contract instance, giving it ContractFunctionParameters as its
// inputs. It will consume the entire given amount of gas.
//
// This is performed locally on the particular _Node that the client is communicating with. It cannot change the state of
// the contract instance (and so, cannot spend anything from the instance's Hedera account). It will not have a
// consensus timestamp. It cannot generate a record or a receipt. This is useful for calling getter functions, which
// purely read the state and don't change it. It is faster and cheaper than a ContractExecuteTransaction, because it is
// purely local to a single  _Node.
type ContractCallQuery struct {
	Query
	contractID         *ContractID
	gas                uint64
	maxResultSize      uint64
	functionParameters []byte
	senderID           *AccountID
}

// NewContractCallQuery creates a ContractCallQuery query which can be used to construct and execute a
// Contract Call Local Query.
func NewContractCallQuery() *ContractCallQuery {
	header := services.QueryHeader{}
	query := _NewQuery(true, &header)

	return &ContractCallQuery{
		Query: query,
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *ContractCallQuery) SetGrpcDeadline(deadline *time.Duration) *ContractCallQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetContractID sets the contract instance to call
func (q *ContractCallQuery) SetContractID(contractID ContractID) *ContractCallQuery {
	q.contractID = &contractID
	return q
}

// GetContractID returns the contract instance to call
func (q *ContractCallQuery) GetContractID() ContractID {
	if q.contractID == nil {
		return ContractID{}
	}

	return *q.contractID
}

// SetSenderID
// The account that is the "sender." If not present it is the accountId from the transactionId.
// Typically a different value than specified in the transactionId requires a valid signature
// over either the hedera transaction or foreign transaction data.
func (q *ContractCallQuery) SetSenderID(id AccountID) *ContractCallQuery {
	q.senderID = &id
	return q
}

// GetSenderID returns the AccountID that is the "sender."
func (q *ContractCallQuery) GetSenderID() AccountID {
	if q.senderID == nil {
		return AccountID{}
	}

	return *q.senderID
}

// SetGas sets the amount of gas to use for the call. All of the gas offered will be charged for.
func (q *ContractCallQuery) SetGas(gas uint64) *ContractCallQuery {
	q.gas = gas
	return q
}

// GetGas returns the amount of gas to use for the call.
func (q *ContractCallQuery) GetGas() uint64 {
	return q.gas
}

// Deprecated
func (q *ContractCallQuery) SetMaxResultSize(size uint64) *ContractCallQuery {
	q.maxResultSize = size
	return q
}

// SetFunction sets which function to call, and the ContractFunctionParams to pass to the function
func (q *ContractCallQuery) SetFunction(name string, params *ContractFunctionParameters) *ContractCallQuery {
	if params == nil {
		params = NewContractFunctionParameters()
	}

	q.functionParameters = params._Build(&name)
	return q
}

// SetFunctionParameters sets the function parameters as their raw bytes.
func (q *ContractCallQuery) SetFunctionParameters(byteArray []byte) *ContractCallQuery {
	q.functionParameters = byteArray
	return q
}

// GetFunctionParameters returns the function parameters as their raw bytes.
func (q *ContractCallQuery) GetFunctionParameters() []byte {
	return q.functionParameters
}

func (q *ContractCallQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *ContractCallQuery) Execute(client *Client) (ContractFunctionResult, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return ContractFunctionResult{}, err
	}

	return _ContractFunctionResultFromProtobuf(resp.GetContractCallLocal().FunctionResult), nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *ContractCallQuery) SetMaxQueryPayment(maxPayment Hbar) *ContractCallQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *ContractCallQuery) SetQueryPayment(paymentAmount Hbar) *ContractCallQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this ContractCallQuery.
func (q *ContractCallQuery) SetNodeAccountIDs(accountID []AccountID) *ContractCallQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *ContractCallQuery) SetMaxRetry(count int) *ContractCallQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *ContractCallQuery) SetMaxBackoff(max time.Duration) *ContractCallQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *ContractCallQuery) SetMinBackoff(min time.Duration) *ContractCallQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *ContractCallQuery) SetPaymentTransactionID(transactionID TransactionID) *ContractCallQuery {
	q.paymentTransactionIDs._Clear()._Push(transactionID)._SetLocked(true)
	return q
}

func (q *ContractCallQuery) SetLogLevel(level LogLevel) *ContractCallQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *ContractCallQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetContract().ContractCallLocalMethod,
	}
}

func (q *ContractCallQuery) getName() string {
	return "ContractCallQuery"
}

func (q *ContractCallQuery) buildQuery() *services.Query {
	pb := services.Query_ContractCallLocal{
		ContractCallLocal: &services.ContractCallLocalQuery{
			Header: q.pbHeader,
			Gas:    int64(q.gas),
		},
	}

	if q.contractID != nil {
		pb.ContractCallLocal.ContractID = q.contractID._ToProtobuf()
	}

	if q.senderID != nil {
		pb.ContractCallLocal.SenderId = q.senderID._ToProtobuf()
	}

	if len(q.functionParameters) > 0 {
		pb.ContractCallLocal.FunctionParameters = q.functionParameters
	}

	return &services.Query{
		Query: &pb,
	}
}

func (q *ContractCallQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.contractID != nil {
		if err := q.contractID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if q.senderID != nil {
		if err := q.senderID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *ContractCallQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetContractCallLocal()
}
// Filename: contract_call_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationContractCallQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKeys(env.OperatorKey.PublicKey()).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey.PublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	assert.NotNil(t, contractReceipt.ContractID)

	contractID := *contractReceipt.ContractID

	result, err := NewContractCallQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractID(contractID).
		SetQueryPayment(NewHbar(1)).
		SetGas(100000).
		SetFunction("getMessage", nil).
		SetMaxQueryPayment(NewHbar(5)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, "Hello from Hedera.", result.GetString(0))

	resp, err = NewContractExecuteTransaction().
		SetContractID(contractID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(100000).
		SetFunction("setMessage", NewContractFunctionParameters().AddString("new message")).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	result, err = NewContractCallQuery().
		SetContractID(contractID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(2)).
		SetQueryPayment(NewHbar(1)).
		SetGas(100000).
		SetFunction("getMessage", nil).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, "new message", result.GetString(0))

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCallQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKeys(env.OperatorKey.PublicKey()).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey.PublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	assert.NotNil(t, contractReceipt.ContractID)

	contractID := *contractReceipt.ContractID

	callQuery := NewContractCallQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractID(contractID).
		SetMaxQueryPayment(NewHbar(1)).
		SetGas(200000).
		SetFunction("getMessage", nil)

	cost, err := callQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = callQuery.SetQueryPayment(HbarFromTinybar(cost.tinybar + 10000)).Execute(env.Client)
	require.NoError(t, err)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCallQuerySetMaxPaymentBig(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKeys(env.OperatorKey.PublicKey()).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey.PublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	assert.NotNil(t, contractReceipt.ContractID)

	contractID := *contractReceipt.ContractID

	callQuery := NewContractCallQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractID(contractID).
		SetMaxQueryPayment(NewHbar(20000)).
		SetGas(200000).
		SetFunction("getMessage", nil)

	_, err = callQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = callQuery.SetQueryPayment(NewHbar(1)).Execute(env.Client)
	require.NoError(t, err)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCallQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey.PublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	assert.NotNil(t, contractReceipt.ContractID)

	contractID := *contractReceipt.ContractID

	callQuery := NewContractCallQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractID(contractID).
		SetMaxQueryPayment(HbarFromTinybar(1)).
		SetGas(200000).
		SetFunction("getMessage", nil)

	cost, err := callQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = callQuery.Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "cost of ContractCallQuery ("+cost.String()+") without explicit payment is greater than the max query payment of 1 tℏ", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCallQueryInsufficientFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKeys(env.OperatorKey.PublicKey()).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	assert.NotNil(t, contractReceipt.ContractID)

	contractID := *contractReceipt.ContractID

	callQuery := NewContractCallQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractID(contractID).
		SetMaxQueryPayment(NewHbar(1)).
		SetGas(200000).
		SetFunction("getMessage", nil)

	_, err = callQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = callQuery.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_TX_FEE", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCallQueryNoContractID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewContractCallQuery().
		SetGas(100000).
		SetNodeAccountIDs(env.NodeAccountIDs).
		// test getCost
		SetFunction("getMessage", nil).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_CONTRACT_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCallQueryNoGas(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey.PublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	assert.NotNil(t, contractReceipt.ContractID)

	contractID := *contractReceipt.ContractID

	_, err = NewContractCallQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractID(contractID).
		SetQueryPayment(NewHbar(1)).
		SetFunction("getMessage", nil).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_GAS", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCallQueryNoFunction(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey.PublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("Hello from Hedera.")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	contractReceipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.True(t, contractReceipt.ContractID.Contract > 0)

	assert.NotNil(t, contractReceipt.ContractID)

	contractID := *contractReceipt.ContractID

	_, err = NewContractCallQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractID(contractID).
		SetGas(200000).
		SetQueryPayment(NewHbar(1)).
		// test getCost
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status CONTRACT_REVERT_EXECUTED", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: contract_call_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitContractCallQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	contractCall := NewContractCallQuery().
		SetContractID(contractID)

	err = contractCall.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitContractCallQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	contractCall := NewContractCallQuery().
		SetContractID(contractID)

	err = contractCall.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitMockContractCallQuery(t *testing.T) {
	t.Parallel()

	message := "getMessage"
	params := NewContractFunctionParameters()
	params._Build(&message)

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_ContractCallLocal{
				ContractCallLocal: &services.ContractCallLocalResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY, ResponseType: services.ResponseType_ANSWER_ONLY},
				},
			},
		},
		&services.Response{
			Response: &services.Response_ContractCallLocal{
				ContractCallLocal: &services.ContractCallLocalResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					FunctionResult: &services.ContractFunctionResult{
						ContractID:         &services.ContractID{Contract: &services.ContractID_ContractNum{ContractNum: 123}},
						GasUsed:            75000,
						ContractCallResult: params._Build(&message),
						SignerNonce:        wrapperspb.Int64(0),
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	result, err := NewContractCallQuery().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetContractID(ContractID{Contract: 123}).
		SetQueryPayment(NewHbar(1)).
		SetGas(100000).
		SetFunction(message, nil).
		SetMaxQueryPayment(NewHbar(5)).
		Execute(client)
	require.NoError(t, err)

	require.Equal(t, bytes.Compare(result.ContractCallResult, params._Build(&message)), 0)
	require.Equal(t, result.GasUsed, uint64(75000))
	require.Equal(t, result.ContractID.Contract, uint64(123))
}

func TestUnitContractCallQueryGet(t *testing.T) {
	t.Parallel()

	spenderContractID := ContractID{Contract: 7}

	balance := NewContractCallQuery().
		SetContractID(spenderContractID).
		SetQueryPayment(NewHbar(2)).
		SetGas(100000).
		SetFunction("getMessage", nil).
		SetFunctionParameters([]byte{}).
		SetMaxQueryPayment(NewHbar(10)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}})

	balance.GetContractID()
	balance.GetFunctionParameters()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitContractCallQuerySetNothing(t *testing.T) {
	t.Parallel()

	balance := NewContractCallQuery()

	balance.GetContractID()
	balance.GetFunctionParameters()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}
// Filename: contract_create_flow.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"time"

	"github.com/pkg/errors"
)

type ContractCreateFlow struct {
	Transaction
	bytecode                      []byte
	proxyAccountID                *AccountID
	adminKey                      *Key
	gas                           int64
	initialBalance                int64
	autoRenewPeriod               *time.Duration
	parameters                    []byte
	nodeAccountIDs                []AccountID
	createBytecode                []byte
	appendBytecode                []byte
	autoRenewAccountID            *AccountID
	maxAutomaticTokenAssociations int32
	maxChunks                     *uint64
}

// NewContractCreateFlow creates a new ContractCreateFlow transaction builder object.
func NewContractCreateFlow() *ContractCreateFlow {
	this := ContractCreateFlow{
		Transaction: _NewTransaction(),
	}

	this.SetAutoRenewPeriod(131500 * time.Minute)
	this.SetMaxTransactionFee(NewHbar(20))

	return &this
}

// SetBytecodeWithString sets the bytecode of the contract in hex-encoded string format.
func (tx *ContractCreateFlow) SetBytecodeWithString(bytecode string) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.bytecode, _ = hex.DecodeString(bytecode)
	return tx
}

// SetBytecode sets the bytecode of the contract in raw bytes.
func (tx *ContractCreateFlow) SetBytecode(bytecode []byte) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.bytecode = bytecode
	return tx
}

// GetBytecode returns the hex-encoded bytecode of the contract.
func (tx *ContractCreateFlow) GetBytecode() string {
	return hex.EncodeToString(tx.bytecode)
}

// Sets the state of the instance and its fields can be modified arbitrarily if this key signs a transaction
// to modify it. If this is null, then such modifications are not possible, and there is no administrator
// that can override the normal operation of this smart contract instance. Note that if it is created with no
// admin keys, then there is no administrator to authorize changing the admin keys, so
// there can never be any admin keys for that instance.
func (tx *ContractCreateFlow) SetAdminKey(adminKey Key) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.adminKey = &adminKey
	return tx
}

// GetAdminKey returns the admin key of the contract.
func (tx *ContractCreateFlow) GetAdminKey() Key {
	if tx.adminKey != nil {
		return *tx.adminKey
	}

	return PrivateKey{}
}

// SetGas sets the gas to run the constructor.
func (tx *ContractCreateFlow) SetGas(gas int64) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.gas = gas
	return tx
}

// GetGas returns the gas to run the constructor.
func (tx *ContractCreateFlow) GetGas() int64 {
	return tx.gas
}

// SetInitialBalance sets the initial number of hbars to put into the cryptocurrency account
// associated with and owned by the smart contract.
func (tx *ContractCreateFlow) SetInitialBalance(initialBalance Hbar) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.initialBalance = initialBalance.AsTinybar()
	return tx
}

// GetInitialBalance returns the initial number of hbars to put into the cryptocurrency account
// associated with and owned by the smart contract.
func (tx *ContractCreateFlow) GetInitialBalance() Hbar {
	return HbarFromTinybar(tx.initialBalance)
}

// SetAutoRenewPeriod sets the period that the instance will charge its account every this many seconds to renew.
func (tx *ContractCreateFlow) SetAutoRenewPeriod(autoRenewPeriod time.Duration) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = &autoRenewPeriod
	return tx
}

// GetAutoRenewPeriod returns the period that the instance will charge its account every this many seconds to renew.
func (tx *ContractCreateFlow) GetAutoRenewPeriod() time.Duration {
	if tx.autoRenewPeriod != nil {
		return *tx.autoRenewPeriod
	}

	return time.Duration(0)
}

// Deprecated
func (tx *ContractCreateFlow) SetProxyAccountID(proxyAccountID AccountID) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.proxyAccountID = &proxyAccountID
	return tx
}

// Deprecated
func (tx *ContractCreateFlow) GetProxyAccountID() AccountID {
	if tx.proxyAccountID == nil {
		return AccountID{}
	}

	return *tx.proxyAccountID
}

// Sets the constructor parameters
func (tx *ContractCreateFlow) SetConstructorParameters(params *ContractFunctionParameters) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.parameters = params._Build(nil)
	return tx
}

// Sets the constructor parameters as their raw bytes.
func (tx *ContractCreateFlow) SetConstructorParametersRaw(params []byte) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.parameters = params
	return tx
}

func (tx *ContractCreateFlow) GetConstructorParameters() []byte {
	return tx.parameters
}

// Sets the memo to be associated with this contract.
func (tx *ContractCreateFlow) SetContractMemo(memo string) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.memo = memo
	return tx
}

// Gets the memo to be associated with this contract.
func (tx *ContractCreateFlow) GetContractMemo() string {
	return tx.memo
}

// SetMaxChunks sets the maximum number of chunks that the contract bytecode can be split into.
func (tx *ContractCreateFlow) SetMaxChunks(max uint64) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.maxChunks = &max
	return tx
}

// GetMaxChunks returns the maximum number of chunks that the contract bytecode can be split into.
func (tx *ContractCreateFlow) GetMaxChunks() uint64 {
	if tx.maxChunks == nil {
		return 0
	}

	return *tx.maxChunks
}

// SetAutoRenewAccountID
// An account to charge for auto-renewal of this contract. If not set, or set to an
// account with zero hbar balance, the contract's own hbar balance will be used to
// cover auto-renewal fees.
func (tx *ContractCreateFlow) SetAutoRenewAccountID(id AccountID) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.autoRenewAccountID = &id
	return tx
}

// GetAutoRenewAccountID returns the account to charge for auto-renewal of this contract.
func (tx *ContractCreateFlow) GetAutoRenewAccountID() AccountID {
	if tx.autoRenewAccountID == nil {
		return AccountID{}
	}

	return *tx.autoRenewAccountID
}

// SetMaxAutomaticTokenAssociations
// The maximum number of tokens that this contract can be automatically associated
// with (i.e., receive air-drops from).
func (tx *ContractCreateFlow) SetMaxAutomaticTokenAssociations(max int32) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.maxAutomaticTokenAssociations = max
	return tx
}

// GetMaxAutomaticTokenAssociations returns the maximum number of tokens that this
// contract can be automatically associated with.
func (tx *ContractCreateFlow) GetMaxAutomaticTokenAssociations() int32 {
	return tx.maxAutomaticTokenAssociations
}

func (tx *ContractCreateFlow) splitBytecode() *ContractCreateFlow {
	if len(tx.bytecode) > 2048 {
		tx.createBytecode = tx.bytecode[0:2048]
		tx.appendBytecode = tx.bytecode[2048:]
		return tx
	}

	tx.createBytecode = tx.bytecode
	tx.appendBytecode = []byte{}
	return tx
}

func (tx *ContractCreateFlow) _CreateFileCreateTransaction(client *Client) *FileCreateTransaction {
	if client == nil {
		return &FileCreateTransaction{}
	}
	fileCreateTx := NewFileCreateTransaction().
		SetKeys(client.GetOperatorPublicKey()).
		SetContents(tx.createBytecode)

	if len(tx.nodeAccountIDs) > 0 {
		fileCreateTx.SetNodeAccountIDs(tx.nodeAccountIDs)
	}

	return fileCreateTx
}

func (tx *ContractCreateFlow) _CreateFileAppendTransaction(fileID FileID) *FileAppendTransaction {
	fileAppendTx := NewFileAppendTransaction().
		SetFileID(fileID).
		SetContents(tx.appendBytecode)

	if len(tx.nodeAccountIDs) > 0 {
		fileAppendTx.SetNodeAccountIDs(tx.nodeAccountIDs)
	}
	if tx.maxChunks != nil {
		fileAppendTx.SetMaxChunks(*tx.maxChunks)
	}

	return fileAppendTx
}

func (tx *ContractCreateFlow) _CreateContractCreateTransaction(fileID FileID) *ContractCreateTransaction {
	contractCreateTx := NewContractCreateTransaction().
		SetGas(uint64(tx.gas)).
		SetConstructorParametersRaw(tx.parameters).
		SetInitialBalance(HbarFromTinybar(tx.initialBalance)).
		SetBytecodeFileID(fileID).
		SetContractMemo(tx.memo)

	if len(tx.nodeAccountIDs) > 0 {
		contractCreateTx.SetNodeAccountIDs(tx.nodeAccountIDs)
	}

	if tx.adminKey != nil {
		contractCreateTx.SetAdminKey(*tx.adminKey)
	}

	if tx.proxyAccountID != nil {
		contractCreateTx.SetProxyAccountID(*tx.proxyAccountID)
	}

	if tx.autoRenewPeriod != nil {
		contractCreateTx.SetAutoRenewPeriod(*tx.autoRenewPeriod)
	}

	if tx.autoRenewAccountID != nil {
		contractCreateTx.SetAutoRenewAccountID(*tx.autoRenewAccountID)
	}

	if tx.maxAutomaticTokenAssociations != 0 {
		contractCreateTx.SetMaxAutomaticTokenAssociations(tx.maxAutomaticTokenAssociations)
	}

	return contractCreateTx
}

func (tx *ContractCreateFlow) Execute(client *Client) (TransactionResponse, error) {
	tx.splitBytecode()

	fileCreateResponse, err := tx._CreateFileCreateTransaction(client).Execute(client)
	if err != nil {
		return TransactionResponse{}, err
	}
	fileCreateReceipt, err := fileCreateResponse.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		return TransactionResponse{}, err
	}
	if fileCreateReceipt.FileID == nil {
		return TransactionResponse{}, errors.New("fileID is nil")
	}
	fileID := *fileCreateReceipt.FileID
	if len(tx.appendBytecode) > 0 {
		fileAppendResponse, err := tx._CreateFileAppendTransaction(fileID).Execute(client)
		if err != nil {
			return TransactionResponse{}, err
		}

		_, err = fileAppendResponse.SetValidateStatus(true).GetReceipt(client)
		if err != nil {
			return TransactionResponse{}, err
		}
	}
	contractCreateResponse, err := tx._CreateContractCreateTransaction(fileID).Execute(client)
	if err != nil {
		return TransactionResponse{}, err
	}
	_, err = contractCreateResponse.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		return TransactionResponse{}, err
	}

	return contractCreateResponse, nil
}

// SetNodeAccountIDs sets the node AccountID for this ContractCreateFlow.
func (tx *ContractCreateFlow) SetNodeAccountIDs(nodeID []AccountID) *ContractCreateFlow {
	tx._RequireNotFrozen()
	tx.nodeAccountIDs = nodeID
	return tx
}

// GetNodeAccountIDs returns the node AccountID for this ContractCreateFlow.
func (tx *ContractCreateFlow) GetNodeAccountIDs() []AccountID {
	return tx.nodeAccountIDs
}
// Filename: contract_create_flow_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestIntegrationContractCreateFlowCanExecute(t *testing.T) {
	testContractByteCode := []byte(`608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewContractCreateFlow().
		SetBytecode(testContractByteCode).
		SetAdminKey(env.OperatorKey).
		SetGas(200000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetContractMemo("[e2e::ContractCreateFlow]").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	require.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	resp, err = NewContractExecuteTransaction().
		SetContractID(contractID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetFunction("setMessage", NewContractFunctionParameters().AddString("new message")).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(AccountID{Account: 3}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCreateFlowSmallContractCanExecute(t *testing.T) {
	t.Skip("Possible bug in services is causing this test to behave flaky")

	testContractByteCode := []byte(`6080604052348015600f57600080fd5b50604051601a90603b565b604051809103906000f0801580156035573d6000803e3d6000fd5b50506047565b605c8061009483390190565b603f806100556000396000f3fe6080604052600080fdfea2646970667358221220a20122cbad3457fedcc0600363d6e895f17048f5caa4afdab9e655123737567d64736f6c634300081200336080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122053dfd8835e3dc6fedfb8b4806460b9b7163f8a7248bac510c6d6808d9da9d6d364736f6c63430008120033`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewContractCreateFlow().
		SetBytecode(testContractByteCode).
		SetAdminKey(env.OperatorKey).
		SetGas(100000).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	require.NotNil(t, receipt.ContractID)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCreateFlowGettersAndSetters(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	testContractByteCode := "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033"
	testOperatorKey := env.OperatorKey
	testGas := int64(100000)
	testMemo := "[e2e::ContractCreateFlow]"
	testInitialBalance := HbarFromTinybar(1000000000000000000)
	autoRenewPeriod := 131500 * time.Minute
	testProxyAccountID := AccountID{Account: 3}
	testAutoTokenAssociations := int32(10)
	testMaxChuncks := uint64(4)
	testNodeAccountID := AccountID{Account: 55}

	constructorFuncName := "constructor"
	constructorParams := ContractFunctionParameters{
		function: ContractFunctionSelector{
			function:   &constructorFuncName,
			params:     "wooow",
			paramTypes: []_Solidity{}},
		arguments: []Argument{Argument{
			value:   []byte("hello from hedera"),
			dynamic: false,
		}}}

	createChain := NewContractCreateFlow().
		SetBytecodeWithString(testContractByteCode).
		SetAdminKey(env.OperatorKey).
		SetGas(100000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetContractMemo("[e2e::ContractCreateFlow]").
		SetInitialBalance(testInitialBalance).
		SetProxyAccountID(testProxyAccountID).
		SetConstructorParameters(&constructorParams).
		SetAutoRenewAccountID(testProxyAccountID).
		SetMaxAutomaticTokenAssociations(testAutoTokenAssociations).
		SetMaxChunks(testMaxChuncks).
		SetNodeAccountIDs([]AccountID{testNodeAccountID, testProxyAccountID})

	require.Equal(t, createChain.GetBytecode(), testContractByteCode)
	require.Equal(t, createChain.GetAdminKey(), testOperatorKey)
	require.Equal(t, createChain.GetGas(), testGas)
	require.Equal(t, createChain.GetContractMemo(), testMemo)
	require.Equal(t, createChain.GetInitialBalance(), testInitialBalance)
	require.Equal(t, createChain.GetAutoRenewPeriod(), autoRenewPeriod)
	require.Equal(t, createChain.GetProxyAccountID(), testProxyAccountID)
	require.Equal(t, createChain.GetAutoRenewAccountID(), testProxyAccountID)
	require.Equal(t, createChain.GetMaxAutomaticTokenAssociations(), testAutoTokenAssociations)
	require.Equal(t, createChain.GetMaxChunks(), testMaxChuncks)
	require.Equal(t, createChain.GetNodeAccountIDs(), []AccountID{testNodeAccountID, testProxyAccountID})

}
// Filename: contract_create_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ContractCreateTransaction which is used to start a new smart contract instance.
// After the instance is created, the ContractID for it is in the receipt, and can be retrieved by the Record or with a GetByKey query.
// The instance will run the bytecode, either stored in a previously created file or in the transaction body itself for
// small contracts.
type ContractCreateTransaction struct {
	Transaction
	byteCodeFileID                *FileID
	proxyAccountID                *AccountID
	adminKey                      Key
	gas                           int64
	initialBalance                int64
	autoRenewPeriod               *time.Duration
	parameters                    []byte
	memo                          string
	initcode                      []byte
	autoRenewAccountID            *AccountID
	maxAutomaticTokenAssociations int32
	stakedAccountID               *AccountID
	stakedNodeID                  *int64
	declineReward                 bool
}

// NewContractCreateTransaction creates ContractCreateTransaction which is used to start a new smart contract instance.
// After the instance is created, the ContractID for it is in the receipt, and can be retrieved by the Record or with a GetByKey query.
// The instance will run the bytecode, either stored in a previously created file or in the transaction body itself for
// small contracts.
func NewContractCreateTransaction() *ContractCreateTransaction {
	tx := ContractCreateTransaction{
		Transaction: _NewTransaction(),
	}

	tx.SetAutoRenewPeriod(131500 * time.Minute)
	tx._SetDefaultMaxTransactionFee(NewHbar(20))

	return &tx
}

func _ContractCreateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *ContractCreateTransaction {
	key, _ := _KeyFromProtobuf(pb.GetContractCreateInstance().GetAdminKey())
	autoRenew := _DurationFromProtobuf(pb.GetContractCreateInstance().GetAutoRenewPeriod())
	stakedNodeID := pb.GetContractCreateInstance().GetStakedNodeId()

	var stakeNodeAccountID *AccountID
	if pb.GetContractCreateInstance().GetStakedAccountId() != nil {
		stakeNodeAccountID = _AccountIDFromProtobuf(pb.GetContractCreateInstance().GetStakedAccountId())
	}

	var autoRenewAccountID *AccountID
	if pb.GetContractCreateInstance().AutoRenewAccountId != nil {
		autoRenewAccountID = _AccountIDFromProtobuf(pb.GetContractCreateInstance().GetAutoRenewAccountId())
	}

	return &ContractCreateTransaction{
		Transaction:                   tx,
		byteCodeFileID:                _FileIDFromProtobuf(pb.GetContractCreateInstance().GetFileID()),
		adminKey:                      key,
		gas:                           pb.GetContractCreateInstance().Gas,
		initialBalance:                pb.GetContractCreateInstance().InitialBalance,
		autoRenewPeriod:               &autoRenew,
		parameters:                    pb.GetContractCreateInstance().ConstructorParameters,
		memo:                          pb.GetContractCreateInstance().GetMemo(),
		initcode:                      pb.GetContractCreateInstance().GetInitcode(),
		autoRenewAccountID:            autoRenewAccountID,
		maxAutomaticTokenAssociations: pb.GetContractCreateInstance().MaxAutomaticTokenAssociations,
		stakedAccountID:               stakeNodeAccountID,
		stakedNodeID:                  &stakedNodeID,
		declineReward:                 pb.GetContractCreateInstance().GetDeclineReward(),
	}
}

// SetBytecodeFileID
// If the initcode is large (> 5K) then it must be stored in a file as hex encoded ascii.
func (tx *ContractCreateTransaction) SetBytecodeFileID(byteCodeFileID FileID) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.byteCodeFileID = &byteCodeFileID
	tx.initcode = nil
	return tx
}

// GetBytecodeFileID returns the FileID of the file containing the contract's bytecode.
func (tx *ContractCreateTransaction) GetBytecodeFileID() FileID {
	if tx.byteCodeFileID == nil {
		return FileID{}
	}

	return *tx.byteCodeFileID
}

// SetBytecode
// If it is small then it may either be stored as a hex encoded file or as a binary encoded field as part of the transaction.
func (tx *ContractCreateTransaction) SetBytecode(code []byte) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.initcode = code
	tx.byteCodeFileID = nil
	return tx
}

// GetBytecode returns the bytecode for the contract.
func (tx *ContractCreateTransaction) GetBytecode() []byte {
	return tx.initcode
}

/**
 * Sets the state of the instance and its fields can be modified arbitrarily if this key signs a transaction
 * to modify it. If this is null, then such modifications are not possible, and there is no administrator
 * that can override the normal operation of this smart contract instance. Note that if it is created with no
 * admin keys, then there is no administrator to authorize changing the admin keys, so
 * there can never be any admin keys for that instance.
 */
func (tx *ContractCreateTransaction) SetAdminKey(adminKey Key) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.adminKey = adminKey
	return tx
}

// GetAdminKey returns the key that can sign to modify the state of the instance
// and its fields can be modified arbitrarily if this key signs a transaction
func (tx *ContractCreateTransaction) GetAdminKey() (Key, error) {
	return tx.adminKey, nil
}

// Sets the gas to run the constructor.
func (tx *ContractCreateTransaction) SetGas(gas uint64) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.gas = int64(gas)
	return tx
}

// GetGas returns the gas to run the constructor.
func (tx *ContractCreateTransaction) GetGas() uint64 {
	return uint64(tx.gas)
}

// SetInitialBalance sets the initial number of Hbar to put into the account
func (tx *ContractCreateTransaction) SetInitialBalance(initialBalance Hbar) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.initialBalance = initialBalance.AsTinybar()
	return tx
}

// GetInitialBalance gets the initial number of Hbar in the account
func (tx *ContractCreateTransaction) GetInitialBalance() Hbar {
	return HbarFromTinybar(tx.initialBalance)
}

// SetAutoRenewPeriod sets the time duration for when account is charged to extend its expiration date. When the account
// is created, the payer account is charged enough hbars so that the new account will not expire for the next
// auto renew period. When it reaches the expiration time, the new account will then be automatically charged to
// renew for another auto renew period. If it does not have enough hbars to renew for that long, then the  remaining
// hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires,
// then it is deleted.
func (tx *ContractCreateTransaction) SetAutoRenewPeriod(autoRenewPeriod time.Duration) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = &autoRenewPeriod
	return tx
}

func (tx *ContractCreateTransaction) GetAutoRenewPeriod() time.Duration {
	if tx.autoRenewPeriod != nil {
		return *tx.autoRenewPeriod
	}

	return time.Duration(0)
}

// Deprecated
// SetProxyAccountID sets the ID of the account to which this account is proxy staked. If proxyAccountID is not set,
// is an invalID account, or is an account that isn't a _Node, then this account is automatically proxy staked to a _Node
// chosen by the _Network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking ,
// or if it is not currently running a _Node, then it will behave as if proxyAccountID was not set.
func (tx *ContractCreateTransaction) SetProxyAccountID(proxyAccountID AccountID) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.proxyAccountID = &proxyAccountID
	return tx
}

// Deprecated
func (tx *ContractCreateTransaction) GetProxyAccountID() AccountID {
	if tx.proxyAccountID == nil {
		return AccountID{}
	}

	return *tx.proxyAccountID
}

// SetConstructorParameters Sets the constructor parameters
func (tx *ContractCreateTransaction) SetConstructorParameters(params *ContractFunctionParameters) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.parameters = params._Build(nil)
	return tx
}

// SetConstructorParametersRaw Sets the constructor parameters as their raw bytes.
func (tx *ContractCreateTransaction) SetConstructorParametersRaw(params []byte) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.parameters = params
	return tx
}

// GetConstructorParameters returns the constructor parameters
func (tx *ContractCreateTransaction) GetConstructorParameters() []byte {
	return tx.parameters
}

// SetContractMemo Sets the memo to be associated with this contract.
func (tx *ContractCreateTransaction) SetContractMemo(memo string) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo
	return tx
}

// GetContractMemo returns the memo associated with this contract.
func (tx *ContractCreateTransaction) GetContractMemo() string {
	return tx.memo
}

// SetAutoRenewAccountID
// An account to charge for auto-renewal of this contract. If not set, or set to an
// account with zero hbar balance, the contract's own hbar balance will be used to
// cover auto-renewal fees.
func (tx *ContractCreateTransaction) SetAutoRenewAccountID(id AccountID) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewAccountID = &id
	return tx
}

// GetAutoRenewAccountID returns the account to be used at the end of the auto renewal period
func (tx *ContractCreateTransaction) GetAutoRenewAccountID() AccountID {
	if tx.autoRenewAccountID == nil {
		return AccountID{}
	}

	return *tx.autoRenewAccountID
}

// SetMaxAutomaticTokenAssociations
// The maximum number of tokens that this contract can be automatically associated
// with (i.e., receive air-drops from).
func (tx *ContractCreateTransaction) SetMaxAutomaticTokenAssociations(max int32) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.maxAutomaticTokenAssociations = max
	return tx
}

// GetMaxAutomaticTokenAssociations returns the maximum number of tokens that this contract can be automatically associated
func (tx *ContractCreateTransaction) GetMaxAutomaticTokenAssociations() int32 {
	return tx.maxAutomaticTokenAssociations
}

// SetStakedAccountID sets the account ID of the account to which this contract is staked.
func (tx *ContractCreateTransaction) SetStakedAccountID(id AccountID) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.stakedAccountID = &id
	return tx
}

// GetStakedAccountID returns the account ID of the account to which this contract is staked.
func (tx *ContractCreateTransaction) GetStakedAccountID() AccountID {
	if tx.stakedAccountID != nil {
		return *tx.stakedAccountID
	}

	return AccountID{}
}

// SetStakedNodeID sets the node ID of the node to which this contract is staked.
func (tx *ContractCreateTransaction) SetStakedNodeID(id int64) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.stakedNodeID = &id
	return tx
}

// GetStakedNodeID returns the node ID of the node to which this contract is staked.
func (tx *ContractCreateTransaction) GetStakedNodeID() int64 {
	if tx.stakedNodeID != nil {
		return *tx.stakedNodeID
	}

	return 0
}

// SetDeclineStakingReward sets if the contract should decline to pay the account's staking revenue.
func (tx *ContractCreateTransaction) SetDeclineStakingReward(decline bool) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.declineReward = decline
	return tx
}

// GetDeclineStakingReward returns if the contract should decline to pay the account's staking revenue.
func (tx *ContractCreateTransaction) GetDeclineStakingReward() bool {
	return tx.declineReward
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *ContractCreateTransaction) Sign(
	privateKey PrivateKey,
) *ContractCreateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *ContractCreateTransaction) SignWithOperator(
	client *Client,
) (*ContractCreateTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *ContractCreateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *ContractCreateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *ContractCreateTransaction) AddSignature(publicKey PublicKey, signature []byte) *ContractCreateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *ContractCreateTransaction) SetGrpcDeadline(deadline *time.Duration) *ContractCreateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *ContractCreateTransaction) Freeze() (*ContractCreateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *ContractCreateTransaction) FreezeWith(client *Client) (*ContractCreateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *ContractCreateTransaction) SetMaxTransactionFee(fee Hbar) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *ContractCreateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this ContractCreateTransaction.
func (tx *ContractCreateTransaction) SetTransactionMemo(memo string) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this ContractCreateTransaction.
func (tx *ContractCreateTransaction) SetTransactionValidDuration(duration time.Duration) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *ContractCreateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this ContractCreateTransaction.
func (tx *ContractCreateTransaction) SetTransactionID(transactionID TransactionID) *ContractCreateTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this ContractCreateTransaction.
func (tx *ContractCreateTransaction) SetNodeAccountIDs(nodeID []AccountID) *ContractCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *ContractCreateTransaction) SetMaxRetry(count int) *ContractCreateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *ContractCreateTransaction) SetMaxBackoff(max time.Duration) *ContractCreateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *ContractCreateTransaction) SetMinBackoff(min time.Duration) *ContractCreateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *ContractCreateTransaction) SetLogLevel(level LogLevel) *ContractCreateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *ContractCreateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *ContractCreateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *ContractCreateTransaction) getName() string {
	return "ContractCreateTransaction"
}

func (tx *ContractCreateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.byteCodeFileID != nil {
		if err := tx.byteCodeFileID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.proxyAccountID != nil {
		if err := tx.proxyAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *ContractCreateTransaction) build() *services.TransactionBody {
	pb := services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ContractCreateInstance{
			ContractCreateInstance: tx.buildProtoBody(),
		},
	}

	return &pb
}
func (tx *ContractCreateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_ContractCreateInstance{
			ContractCreateInstance: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *ContractCreateTransaction) buildProtoBody() *services.ContractCreateTransactionBody {
	body := &services.ContractCreateTransactionBody{
		Gas:                           tx.gas,
		InitialBalance:                tx.initialBalance,
		ConstructorParameters:         tx.parameters,
		Memo:                          tx.memo,
		MaxAutomaticTokenAssociations: tx.maxAutomaticTokenAssociations,
		DeclineReward:                 tx.declineReward,
	}

	if tx.autoRenewPeriod != nil {
		body.AutoRenewPeriod = _DurationToProtobuf(*tx.autoRenewPeriod)
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	if tx.byteCodeFileID != nil {
		body.InitcodeSource = &services.ContractCreateTransactionBody_FileID{FileID: tx.byteCodeFileID._ToProtobuf()}
	} else if len(tx.initcode) != 0 {
		body.InitcodeSource = &services.ContractCreateTransactionBody_Initcode{Initcode: tx.initcode}
	}

	if tx.autoRenewAccountID != nil {
		body.AutoRenewAccountId = tx.autoRenewAccountID._ToProtobuf()
	}

	if tx.stakedAccountID != nil {
		body.StakedId = &services.ContractCreateTransactionBody_StakedAccountId{StakedAccountId: tx.stakedAccountID._ToProtobuf()}
	} else if tx.stakedNodeID != nil {
		body.StakedId = &services.ContractCreateTransactionBody_StakedNodeId{StakedNodeId: *tx.stakedNodeID}
	}

	return body
}

func (tx *ContractCreateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetContract().CreateContract,
	}
}

func (tx *ContractCreateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: contract_create_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"testing"
)

func TestIntegrationContractCreateTransactionCanExecute(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(100000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractCreateTransaction_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCreateTransactionNoAdminKey(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(100000).
		SetBytecodeFileID(fileID).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	info, err := NewContractInfoQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractID(contractID).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, info.ContractID, contractID)
	assert.NotNil(t, info.AccountID)
	assert.Equal(t, info.AccountID.String(), contractID.String())
	assert.NotNil(t, info.AdminKey)
	// assert.Equal(t, info.AdminKey.String(), contractID.String())

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: MODIFYING_IMMUTABLE_CONTRACT", err.Error())
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCreateTransactionNoGas(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	_, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetBytecodeFileID(fileID).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		require.ErrorContains(t, err, "exceptional precheck status INSUFFICIENT_GAS")
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCreateTransactionNoBytecodeFileID(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(100000).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_FILE_ID", err.Error())
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractCreateTransactionSetBytecode(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	hexData := `608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`
	hexBytecode, err := hex.DecodeString(hexData)
	require.NoError(t, err)

	resp, err := NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetGas(10000000).
		SetBytecode(hexBytecode).
		Execute(env.Client)
	require.NoError(t, err)
	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	require.NotNil(t, receipt.ContractID)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: contract_create_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"encoding/hex"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitContractCreateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	fileID, err := FileIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	contractCreate := NewContractCreateTransaction().
		SetProxyAccountID(accountID).
		SetBytecodeFileID(fileID)

	err = contractCreate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitContractCreateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	fileID, err := FileIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	contractCreate := NewContractCreateTransaction().
		SetProxyAccountID(accountID).
		SetBytecodeFileID(fileID)

	err = contractCreate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitContractCreateTransactionMock(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420d45e1557156908c967804615af59a000be88c7aa7058bfcbe0f46b16c28f887d")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if bod, ok := transactionBody.Data.(*services.TransactionBody_ContractCreateInstance); ok {
			require.Equal(t, bod.ContractCreateInstance.InitcodeSource.(*services.ContractCreateTransactionBody_FileID).FileID.FileNum, int64(123))
			params := NewContractFunctionParameters().AddString("hello from hedera")
			require.Equal(t, bytes.Compare(bod.ContractCreateInstance.ConstructorParameters, params._Build(nil)), 0)
			require.Equal(t, bod.ContractCreateInstance.Memo, "hedera-sdk-go::TestContractCreateTransaction_Execute")
			require.Equal(t, bod.ContractCreateInstance.Gas, int64(100000))
			require.Equal(t, hex.EncodeToString(bod.ContractCreateInstance.AdminKey.GetEd25519()), key.PublicKey().StringRaw())
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err = NewContractCreateTransaction().
		SetAdminKey(client.GetOperatorPublicKey()).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetGas(100000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(FileID{File: 123}).
		SetContractMemo("hedera-sdk-go::TestContractCreateTransaction_Execute").
		Execute(client)
	require.NoError(t, err)
}

func TestUnitContractCreateTransactionGet(t *testing.T) {
	t.Parallel()

	spenderAccountID1 := AccountID{Account: 7}
	fileID := FileID{File: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewContractCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetGas(21341).
		SetProxyAccountID(spenderAccountID1).
		SetAutoRenewPeriod(60 * time.Second).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetContractMemo("yes").
		SetBytecodeFileID(fileID).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetContractMemo()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetProxyAccountID()
	transaction.GetRegenerateTransactionID()
	transaction.GetAutoRenewPeriod()
	transaction.GetBytecodeFileID()
	transaction.GetContractMemo()
	transaction.GetGas()
}

func TestUnitContractCreateTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewContractCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetContractMemo()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetProxyAccountID()
	transaction.GetRegenerateTransactionID()
	transaction.GetAutoRenewPeriod()
	transaction.GetBytecodeFileID()
	transaction.GetContractMemo()
	transaction.GetGas()
}

func TestUnitContractCreateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	accountID := AccountID{Account: 7}
	fileID := FileID{File: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	transaction, err := NewContractCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(newKey.PublicKey()).
		SetBytecodeFileID(fileID).
		SetGas(500).
		SetInitialBalance(NewHbar(50)).
		SetConstructorParametersRaw([]byte{34}).
		SetContractMemo("yes").
		SetStakedAccountID(accountID).
		SetMaxAutomaticTokenAssociations(3).
		SetAutoRenewPeriod(time.Second * 3).
		SetAutoRenewAccountID(accountID).
		SetDeclineStakingReward(true).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetContractCreateInstance()
	require.Equal(t, proto.AdminKey.String(), newKey._ToProtoKey().String())
	require.Equal(t, proto.GetFileID().String(), fileID._ToProtobuf().String())
	require.Equal(t, proto.Memo, "yes")
	require.Equal(t, proto.StakedId.(*services.ContractCreateTransactionBody_StakedAccountId).StakedAccountId.String(),
		accountID._ToProtobuf().String())
	require.Equal(t, proto.MaxAutomaticTokenAssociations, int32(3))
	require.Equal(t, proto.AutoRenewPeriod.String(), _DurationToProtobuf(time.Second*3).String())
	require.Equal(t, proto.AutoRenewAccountId.String(), accountID._ToProtobuf().String())
	require.Equal(t, proto.DeclineReward, true)
	require.Equal(t, proto.ConstructorParameters, []byte{34})
	require.Equal(t, proto.InitialBalance, NewHbar(50).AsTinybar())
	require.Equal(t, proto.Gas, int64(500))
}

func TestUnitContractCreateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	file := FileID{File: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewContractCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(newKey.PublicKey()).
		SetBytecodeFileID(file).
		SetGas(500).
		SetInitialBalance(NewHbar(50)).
		SetConstructorParametersRaw([]byte{34}).
		SetContractMemo("yes").
		SetStakedAccountID(account).
		SetStakedNodeID(3).
		SetBytecode([]byte{0}).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetStakedAccountID()
	transaction.GetStakedNodeID()
	transaction.GetConstructorParameters()
	transaction.GetBytecode()
	transaction.GetDeclineStakingReward()
	transaction.GetInitialBalance()
	transaction.GetGas()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case ContractCreateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}
// Filename: contract_delete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"

	"time"
)

// ContractDeleteTransaction marks a contract as deleted and transfers its remaining hBars, if any, to a
// designated receiver. After a contract is deleted, it can no longer be called.
type ContractDeleteTransaction struct {
	Transaction
	contractID        *ContractID
	transferContactID *ContractID
	transferAccountID *AccountID
	permanentRemoval  bool
}

// NewContractDeleteTransaction creates ContractDeleteTransaction which marks a contract as deleted and transfers its remaining hBars, if any, to a
// designated receiver. After a contract is deleted, it can no longer be called.
func NewContractDeleteTransaction() *ContractDeleteTransaction {
	tx := ContractDeleteTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _ContractDeleteTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *ContractDeleteTransaction {
	return &ContractDeleteTransaction{
		Transaction:       tx,
		contractID:        _ContractIDFromProtobuf(pb.GetContractDeleteInstance().GetContractID()),
		transferContactID: _ContractIDFromProtobuf(pb.GetContractDeleteInstance().GetTransferContractID()),
		transferAccountID: _AccountIDFromProtobuf(pb.GetContractDeleteInstance().GetTransferAccountID()),
		permanentRemoval:  pb.GetContractDeleteInstance().GetPermanentRemoval(),
	}
}

// Sets the contract ID which will be deleted.
func (tx *ContractDeleteTransaction) SetContractID(contractID ContractID) *ContractDeleteTransaction {
	tx._RequireNotFrozen()
	tx.contractID = &contractID
	return tx
}

// Returns the contract ID which will be deleted.
func (tx *ContractDeleteTransaction) GetContractID() ContractID {
	if tx.contractID == nil {
		return ContractID{}
	}

	return *tx.contractID
}

// Sets the contract ID which will receive all remaining hbars.
func (tx *ContractDeleteTransaction) SetTransferContractID(transferContactID ContractID) *ContractDeleteTransaction {
	tx._RequireNotFrozen()
	tx.transferContactID = &transferContactID
	return tx
}

// Returns the contract ID which will receive all remaining hbars.
func (tx *ContractDeleteTransaction) GetTransferContractID() ContractID {
	if tx.transferContactID == nil {
		return ContractID{}
	}

	return *tx.transferContactID
}

// Sets the account ID which will receive all remaining hbars.
func (tx *ContractDeleteTransaction) SetTransferAccountID(accountID AccountID) *ContractDeleteTransaction {
	tx._RequireNotFrozen()
	tx.transferAccountID = &accountID

	return tx
}

// Returns the account ID which will receive all remaining hbars.
func (tx *ContractDeleteTransaction) GetTransferAccountID() AccountID {
	if tx.transferAccountID == nil {
		return AccountID{}
	}

	return *tx.transferAccountID
}

// SetPermanentRemoval
// If set to true, means this is a "synthetic" system transaction being used to
// alert mirror nodes that the contract is being permanently removed from the ledger.
// IMPORTANT: User transactions cannot set this field to true, as permanent
// removal is always managed by the ledger itself. Any ContractDeleteTransaction
// submitted to HAPI with permanent_removal=true will be rejected with precheck status
// PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION.
func (tx *ContractDeleteTransaction) SetPermanentRemoval(remove bool) *ContractDeleteTransaction {
	tx._RequireNotFrozen()
	tx.permanentRemoval = remove

	return tx
}

// GetPermanentRemoval returns true if this is a "synthetic" system transaction.
func (tx *ContractDeleteTransaction) GetPermanentRemoval() bool {
	return tx.permanentRemoval
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *ContractDeleteTransaction) Sign(
	privateKey PrivateKey,
) *ContractDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *ContractDeleteTransaction) SignWithOperator(
	client *Client,
) (*ContractDeleteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *ContractDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *ContractDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

func (tx *ContractDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *ContractDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *ContractDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *ContractDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *ContractDeleteTransaction) Freeze() (*ContractDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *ContractDeleteTransaction) FreezeWith(client *Client) (*ContractDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *ContractDeleteTransaction) SetMaxTransactionFee(fee Hbar) *ContractDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *ContractDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *ContractDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this ContractDeleteTransaction.
func (tx *ContractDeleteTransaction) SetTransactionMemo(memo string) *ContractDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this ContractDeleteTransaction.
func (tx *ContractDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *ContractDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *ContractDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this ContractDeleteTransaction.
func (tx *ContractDeleteTransaction) SetTransactionID(transactionID TransactionID) *ContractDeleteTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this ContractDeleteTransaction.
func (tx *ContractDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *ContractDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *ContractDeleteTransaction) SetMaxRetry(count int) *ContractDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *ContractDeleteTransaction) SetMaxBackoff(max time.Duration) *ContractDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *ContractDeleteTransaction) SetMinBackoff(min time.Duration) *ContractDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *ContractDeleteTransaction) SetLogLevel(level LogLevel) *ContractDeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *ContractDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *ContractDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *ContractDeleteTransaction) getName() string {
	return "ContractDeleteTransaction"
}
func (tx *ContractDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.contractID != nil {
		if err := tx.contractID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.transferContactID != nil {
		if err := tx.transferContactID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.transferAccountID != nil {
		if err := tx.transferAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *ContractDeleteTransaction) build() *services.TransactionBody {
	pb := services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ContractDeleteInstance{
			ContractDeleteInstance: tx.buildProtoBody(),
		},
	}

	return &pb
}

func (tx *ContractDeleteTransaction) buildProtoBody() *services.ContractDeleteTransactionBody {
	body := &services.ContractDeleteTransactionBody{
		PermanentRemoval: tx.permanentRemoval,
	}

	if tx.contractID != nil {
		body.ContractID = tx.contractID._ToProtobuf()
	}

	if tx.transferContactID != nil {
		body.Obtainers = &services.ContractDeleteTransactionBody_TransferContractID{
			TransferContractID: tx.transferContactID._ToProtobuf(),
		}
	}

	if tx.transferAccountID != nil {
		body.Obtainers = &services.ContractDeleteTransactionBody_TransferAccountID{
			TransferAccountID: tx.transferAccountID._ToProtobuf(),
		}
	}

	return body
}

func (tx *ContractDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_ContractDeleteInstance{
			ContractDeleteInstance: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *ContractDeleteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetContract().DeleteContract,
	}
}

func (tx *ContractDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: contract_delete_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"

	"testing"
)

func TestIntegrationContractDeleteTransactionCanExecute(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractDeleteTransaction_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractDeleteTransactionNoContractID(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractDeleteTransaction_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewContractDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_CONTRACT_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: contract_delete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitContractDeleteTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	contractID, err := ContractIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	contractDelete := NewContractDeleteTransaction().
		SetTransferAccountID(accountID).
		SetContractID(contractID).
		SetTransferContractID(contractID)

	err = contractDelete.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitContractDeleteTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	contractID, err := ContractIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	contractDelete := NewContractDeleteTransaction().
		SetTransferAccountID(accountID).
		SetContractID(contractID).
		SetTransferContractID(contractID)

	err = contractDelete.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitContractDeleteTransactionGet(t *testing.T) {
	t.Parallel()

	spenderAccountID1 := AccountID{Account: 7}
	contractID := ContractID{Contract: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewContractDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetContractID(contractID).
		SetTransferAccountID(spenderAccountID1).
		SetTransferContractID(contractID).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetContractID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransferAccountID()
	transaction.GetTransferContractID()
	transaction.GetRegenerateTransactionID()
}

func TestUnitContractDeleteTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewContractDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetContractID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransferAccountID()
	transaction.GetTransferContractID()
	transaction.GetRegenerateTransactionID()
}

func TestUnitContractDeleteTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	spenderAccountID1 := AccountID{Account: 7}
	contractID := ContractID{Contract: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewContractDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetContractID(contractID).
		SetTransferAccountID(spenderAccountID1).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		SetPermanentRemoval(true).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetContractDeleteInstance()
	require.Equal(t, proto.ContractID.String(), contractID._ToProtobuf().String())
	require.Equal(t, proto.Obtainers.(*services.ContractDeleteTransactionBody_TransferAccountID).TransferAccountID.String(),
		spenderAccountID1._ToProtobuf().String())
	require.Equal(t, proto.PermanentRemoval, true)
}

func TestUnitContractDeleteTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	contract := ContractID{Contract: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewContractDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetContractID(contract).
		SetTransferContractID(contract).
		SetPermanentRemoval(true).
		SetTransferAccountID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetPermanentRemoval()
	transaction.GetTransferAccountID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case ContractDeleteTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitContractDeleteTransactionMock(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 3}}
	transactionID := TransactionIDGenerate(AccountID{Account: 3})

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewContractDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetContractID(ContractID{Contract: 3}).
		Execute(client)
	require.NoError(t, err)
}
// Filename: contract_execute_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"

	"time"
)

// ContractExecuteTransaction calls a function of the given smart contract instance, giving it ContractFuncionParams as
// its inputs. it can use the given amount of gas, and any unspent gas will be refunded to the paying account.
//
// If tx function stores information, it is charged gas to store it. There is a fee in hbars to maintain that storage
// until the expiration time, and that fee is added as part of the transaction fee.
//
// For a cheaper but more limited _Method to call functions, see ContractCallQuery.
type ContractExecuteTransaction struct {
	Transaction
	contractID *ContractID
	gas        int64
	amount     int64
	parameters []byte
}

// NewContractExecuteTransaction creates a ContractExecuteTransaction transaction which can be
// used to construct and execute a Contract Call Transaction.
func NewContractExecuteTransaction() *ContractExecuteTransaction {
	tx := ContractExecuteTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _ContractExecuteTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *ContractExecuteTransaction {
	return &ContractExecuteTransaction{
		Transaction: tx,
		contractID:  _ContractIDFromProtobuf(pb.GetContractCall().GetContractID()),
		gas:         pb.GetContractCall().GetGas(),
		amount:      pb.GetContractCall().GetAmount(),
		parameters:  pb.GetContractCall().GetFunctionParameters(),
	}
}

// SetContractID sets the contract instance to call.
func (tx *ContractExecuteTransaction) SetContractID(contractID ContractID) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	tx.contractID = &contractID
	return tx
}

// GetContractID returns the contract instance to call.
func (tx *ContractExecuteTransaction) GetContractID() ContractID {
	if tx.contractID == nil {
		return ContractID{}
	}

	return *tx.contractID
}

// SetGas sets the maximum amount of gas to use for the call.
func (tx *ContractExecuteTransaction) SetGas(gas uint64) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	tx.gas = int64(gas)
	return tx
}

// GetGas returns the maximum amount of gas to use for the call.
func (tx *ContractExecuteTransaction) GetGas() uint64 {
	return uint64(tx.gas)
}

// SetPayableAmount sets the amount of Hbar sent (the function must be payable if this is nonzero)
func (tx *ContractExecuteTransaction) SetPayableAmount(amount Hbar) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	tx.amount = amount.AsTinybar()
	return tx
}

// GetPayableAmount returns the amount of Hbar sent (the function must be payable if this is nonzero)
func (tx *ContractExecuteTransaction) GetPayableAmount() Hbar {
	return HbarFromTinybar(tx.amount)
}

// SetFunctionParameters sets the function parameters
func (tx *ContractExecuteTransaction) SetFunctionParameters(params []byte) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	tx.parameters = params
	return tx
}

// GetFunctionParameters returns the function parameters
func (tx *ContractExecuteTransaction) GetFunctionParameters() []byte {
	return tx.parameters
}

// SetFunction sets which function to call, and the ContractFunctionParams to pass to the function
func (tx *ContractExecuteTransaction) SetFunction(name string, params *ContractFunctionParameters) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	if params == nil {
		params = NewContractFunctionParameters()
	}

	tx.parameters = params._Build(&name)
	return tx
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *ContractExecuteTransaction) Sign(
	privateKey PrivateKey,
) *ContractExecuteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *ContractExecuteTransaction) SignWithOperator(
	client *Client,
) (*ContractExecuteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *ContractExecuteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *ContractExecuteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *ContractExecuteTransaction) AddSignature(publicKey PublicKey, signature []byte) *ContractExecuteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *ContractExecuteTransaction) SetGrpcDeadline(deadline *time.Duration) *ContractExecuteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *ContractExecuteTransaction) Freeze() (*ContractExecuteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *ContractExecuteTransaction) FreezeWith(client *Client) (*ContractExecuteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *ContractExecuteTransaction) SetMaxTransactionFee(fee Hbar) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *ContractExecuteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this ContractExecuteTransaction.
func (tx *ContractExecuteTransaction) SetTransactionMemo(memo string) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this ContractExecuteTransaction.
func (tx *ContractExecuteTransaction) SetTransactionValidDuration(duration time.Duration) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *ContractExecuteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this ContractExecuteTransaction.
func (tx *ContractExecuteTransaction) SetTransactionID(transactionID TransactionID) *ContractExecuteTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this ContractExecuteTransaction.
func (tx *ContractExecuteTransaction) SetNodeAccountIDs(nodeID []AccountID) *ContractExecuteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *ContractExecuteTransaction) SetMaxRetry(count int) *ContractExecuteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *ContractExecuteTransaction) SetMaxBackoff(max time.Duration) *ContractExecuteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *ContractExecuteTransaction) SetMinBackoff(min time.Duration) *ContractExecuteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *ContractExecuteTransaction) SetLogLevel(level LogLevel) *ContractExecuteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *ContractExecuteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *ContractExecuteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *ContractExecuteTransaction) getName() string {
	return "ContractExecuteTransaction"
}
func (tx *ContractExecuteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.contractID != nil {
		if err := tx.contractID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *ContractExecuteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ContractCall{
			ContractCall: tx.buildProtoBody(),
		},
	}
}

func (tx *ContractExecuteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_ContractCall{
			ContractCall: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *ContractExecuteTransaction) buildProtoBody() *services.ContractCallTransactionBody {
	body := &services.ContractCallTransactionBody{
		Gas:                tx.gas,
		Amount:             tx.amount,
		FunctionParameters: tx.parameters,
	}

	if tx.contractID != nil {
		body.ContractID = tx.contractID._ToProtobuf()
	}

	return body
}

func (tx *ContractExecuteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetContract().ContractCallMethod,
	}
}
func (tx *ContractExecuteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: contract_execute_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationContractExecuteTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033`)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(200000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractDeleteTransaction_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	resp, err = NewContractExecuteTransaction().
		SetContractID(contractID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(200000).
		SetFunction("setMessage", NewContractFunctionParameters().AddString("new message")).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractExecuteTransactionNoContractID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewContractExecuteTransaction().
		SetGas(100000).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetFunction("setMessage", NewContractFunctionParameters().AddString("new message")).
		Execute(env.Client)

	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_CONTRACT_ID received for transaction %s", resp.TransactionID), err.Error())
	}
}

func TestIntegrationContractExecuteTransactionNoGas(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	node_ids := []AccountID{resp.NodeID}

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs(node_ids).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractDeleteTransaction_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	resp, err = NewContractExecuteTransaction().
		SetContractID(contractID).
		SetNodeAccountIDs(node_ids).
		SetFunction("setMessage", NewContractFunctionParameters().AddString("new message")).
		Execute(env.Client)

	assert.Error(t, err)
	if err != nil {
		assert.Contains(t, err.Error(), "INSUFFICIENT_GAS")
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs(node_ids).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs(node_ids).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractExecuteTransactionNoFunction(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractDeleteTransaction_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	resp, err = NewContractExecuteTransaction().
		SetContractID(contractID).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: CONTRACT_REVERT_EXECUTED", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func DisabledTestIntegrationContractExecuteTransactionID(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	transactionID := resp.TransactionID
	assert.NotNil(t, transactionID)

	nodeIDs := make([]AccountID, 1)
	nodeIDs[0] = resp.NodeID

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractDeleteTransaction_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	resp, err = NewContractExecuteTransaction().
		SetContractID(contractID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(100000).
		SetFunction("setMessage", NewContractFunctionParameters().AddString("new message")).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := resp.GetRecord(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, record)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	_, err = record.GetContractExecuteResult()
	require.NoError(t, err)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: contract_execute_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitContractExecuteTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	contractExecute := NewContractExecuteTransaction().
		SetContractID(contractID)

	err = contractExecute.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitContractExecuteTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	contractExecute := NewContractExecuteTransaction().
		SetContractID(contractID)

	err = contractExecute.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitContractExecuteTransactionMock(t *testing.T) {
	t.Parallel()

	params := NewContractFunctionParameters().AddString("new message")

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if bod, ok := transactionBody.Data.(*services.TransactionBody_ContractCall); ok {
			require.Equal(t, bod.ContractCall.ContractID.GetContractNum(), int64(123))
			require.Equal(t, bod.ContractCall.GetGas(), int64(100000))
			message := "setMessage"
			require.Equal(t, bytes.Compare(bod.ContractCall.FunctionParameters, params._Build(&message)), 0)
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewContractExecuteTransaction().
		SetContractID(ContractID{Contract: 123}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetGas(100000).
		SetFunction("setMessage", NewContractFunctionParameters().AddString("new message")).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitContractExecuteTransactionGet(t *testing.T) {
	t.Parallel()

	contractID := ContractID{Contract: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewContractExecuteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetContractID(contractID).
		SetGas(100000).
		SetFunction("setMessage", NewContractFunctionParameters().AddString("new message")).
		SetFunctionParameters([]byte{}).
		SetPayableAmount(NewHbar(1)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetContractID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetFunctionParameters()
	transaction.GetGas()
	transaction.GetRegenerateTransactionID()
	transaction.GetPayableAmount()
}

func TestUnitContractExecuteTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewContractExecuteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetContractID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetFunctionParameters()
	transaction.GetGas()
	transaction.GetRegenerateTransactionID()
	transaction.GetPayableAmount()
}

func TestUnitContractExecuteTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	contractID := ContractID{Contract: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewContractExecuteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetContractID(contractID).
		SetGas(100000).
		SetFunctionParameters([]byte{34}).
		SetPayableAmount(NewHbar(1)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetContractCall()
	require.Equal(t, proto.ContractID.String(), contractID._ToProtobuf().String())
	require.Equal(t, proto.Gas, int64(100000))
	require.Equal(t, proto.Amount, NewHbar(1).AsTinybar())
	require.Equal(t, proto.FunctionParameters, []byte{34})
}

func TestUnitContractExecuteTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	contract := ContractID{Contract: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewContractExecuteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetContractID(contract).
		SetGas(100000).
		SetFunctionParameters([]byte{34}).
		SetPayableAmount(NewHbar(1)).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetGas()

	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case ContractExecuteTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}
// Filename: contract_function_parameters.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common/math"
)

// ContractFunctionParameters is a struct which builds a solidity function call
// Use the builder methods `Add<Type>()` to add a parameter. Not all solidity types
// are supported out of the box, but the most common types are. The larger variants
// of number types require the parameter to be `[]byte`. This is a little unintuitive,
// so here is an example of how to use those larger number variants using
// "github.com/ethereum/go-ethereum/common/math" and "math/big"
// ```
// AddUint88(math.PaddedBigBytes(n, 88 / 8))
// ```
// If you're using `Uint256` specifically you can opt into using
// ```
// AddUin256(math.PaddedBigBytes(math.U256(n), 32))
// ```
type ContractFunctionParameters struct {
	function  ContractFunctionSelector
	arguments []Argument
}

type Argument struct {
	value   []byte
	dynamic bool
}

// Builder for encoding parameters for a Solidity contract constructor/function call.
func NewContractFunctionParameters() *ContractFunctionParameters {
	return &ContractFunctionParameters{
		function:  NewContractFunctionSelector(""),
		arguments: []Argument{},
	}
}

// AddBool adds a bool parameter to the function call
func (contract *ContractFunctionParameters) AddBool(value bool) *ContractFunctionParameters {
	argument := _NewArgument()

	if value {
		argument.value[31] = 1
	} else {
		argument.value[31] = 0
	}

	contract.function.AddBool()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddFunction adds a Solidity function reference and a function selector.
func (contract *ContractFunctionParameters) AddFunction(address string, selector ContractFunctionSelector) (*ContractFunctionParameters, error) {
	if len(address) != 40 {
		return contract, errors.Unwrap(fmt.Errorf("address is required to be 40 characters"))
	}

	argument := _NewArgument()
	argument.dynamic = false

	addressBytes, err := hex.DecodeString(address)
	if err != nil {
		return contract, err
	}

	bytes := make([]byte, 12)
	bytes = append(bytes, addressBytes[0:20]...)

	function := selector._Build(nil)

	bytes = append(bytes, function[0:4]...)
	argument.value = bytes

	contract.function.AddFunction()
	contract.arguments = append(contract.arguments, argument)
	return contract, nil
}

// AddInt8 adds an int8 parameter to the function call
func (contract *ContractFunctionParameters) AddInt8(value int8) *ContractFunctionParameters {
	argument := _NewIntArgument(value)

	argument.value[31] = uint8(value)

	contract.function.AddInt8()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt16 adds an int16 parameter to the function call
func (contract *ContractFunctionParameters) AddInt16(value int16) *ContractFunctionParameters {
	argument := _NewIntArgument(value)

	binary.BigEndian.PutUint16(argument.value[30:32], uint16(value))

	contract.function.AddInt16()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt24 adds an int24 parameter to the function call
func (contract *ContractFunctionParameters) AddInt24(value int32) *ContractFunctionParameters {
	argument := _NewIntArgument(value)

	binary.BigEndian.PutUint32(argument.value[28:32], uint32(value))

	contract.function.AddInt24()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt32 adds an int32 parameter to the function call
func (contract *ContractFunctionParameters) AddInt32(value int32) *ContractFunctionParameters {
	argument := _NewIntArgument(value)

	binary.BigEndian.PutUint32(argument.value[28:32], uint32(value))

	contract.function.AddInt32()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt40 adds an int40 parameter to the function call
func (contract *ContractFunctionParameters) AddInt40(value int64) *ContractFunctionParameters {
	argument := _NewIntArgument(value)

	binary.BigEndian.PutUint64(argument.value[24:32], uint64(value))

	contract.function.AddInt40()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt48 adds an int48 parameter to the function call
func (contract *ContractFunctionParameters) AddInt48(value int64) *ContractFunctionParameters {
	argument := _NewIntArgument(value)

	binary.BigEndian.PutUint64(argument.value[24:32], uint64(value))

	contract.function.AddInt48()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt56 adds an int56 parameter to the function call
func (contract *ContractFunctionParameters) AddInt56(value int64) *ContractFunctionParameters {
	argument := _NewIntArgument(value)

	binary.BigEndian.PutUint64(argument.value[24:32], uint64(value))

	contract.function.AddInt56()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt64 adds an int64 parameter to the function call
func (contract *ContractFunctionParameters) AddInt64(value int64) *ContractFunctionParameters {
	argument := _NewIntArgument(value)

	binary.BigEndian.PutUint64(argument.value[24:32], uint64(value))

	contract.function.AddInt64()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt72 adds an int72 parameter to the function call
func (contract *ContractFunctionParameters) AddInt72(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt72()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt72BigInt adds an int72parameter to the function call
func (contract *ContractFunctionParameters) AddInt72BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt72()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt80 adds an int80 parameter to the function call
func (contract *ContractFunctionParameters) AddInt80(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt80()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt80igInt adds an int80parameter to the function call
func (contract *ContractFunctionParameters) AddInt80BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt80()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt88 adds an int88 parameter to the function call
func (contract *ContractFunctionParameters) AddInt88(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt88()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt88BigInt adds an int88parameter to the function call
func (contract *ContractFunctionParameters) AddIn88BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt88()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt96 adds an int96 parameter to the function call
func (contract *ContractFunctionParameters) AddInt96(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt96()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt96BigInt adds an int96parameter to the function call
func (contract *ContractFunctionParameters) AddInt96BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt96()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt104 adds an int104 parameter to the function call
func (contract *ContractFunctionParameters) AddInt104(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt104()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt104BigInt adds an int104 parameter to the function call
func (contract *ContractFunctionParameters) AddInt104BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt104()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt112 adds an int112 parameter to the function call
func (contract *ContractFunctionParameters) AddInt112(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt112()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt112BigInt adds an int112 parameter to the function call
func (contract *ContractFunctionParameters) AddInt112BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt112()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt120 adds an int120 parameter to the function call
func (contract *ContractFunctionParameters) AddInt120(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt120()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt120BigInt adds an int120parameter to the function call
func (contract *ContractFunctionParameters) AddInt120BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt120()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt128 adds an int128 parameter to the function call
func (contract *ContractFunctionParameters) AddInt128(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt128()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt128BigInt adds an int128parameter to the function call
func (contract *ContractFunctionParameters) AddInt128BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt128()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt136 adds an int136 parameter to the function call
func (contract *ContractFunctionParameters) AddInt136(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt136()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt136BigInt adds an int136 parameter to the function call
func (contract *ContractFunctionParameters) AddInt136BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt136()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt144 adds an int144 parameter to the function call
func (contract *ContractFunctionParameters) AddInt144(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt144()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt144BigInt adds an int144 parameter to the function call
func (contract *ContractFunctionParameters) AddInt144BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt144()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt152 adds an int152 parameter to the function call
func (contract *ContractFunctionParameters) AddInt152(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt152()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt152BigInt adds an int152 parameter to the function call
func (contract *ContractFunctionParameters) AddInt152BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt152()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt160 adds an int160 parameter to the function call
func (contract *ContractFunctionParameters) AddInt160(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt160()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt160BigInt adds an int160 parameter to the function call
func (contract *ContractFunctionParameters) AddInt160BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt160()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt168 adds an int168 parameter to the function call
func (contract *ContractFunctionParameters) AddInt168(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt168()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt168BigInt adds an int168 parameter to the function call
func (contract *ContractFunctionParameters) AddInt168BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt168()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt176 adds an int176 parameter to the function call
func (contract *ContractFunctionParameters) AddInt176(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt176()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt176BigInt adds an int176 parameter to the function call
func (contract *ContractFunctionParameters) AddInt176BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt176()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt184 adds an int184 parameter to the function call
func (contract *ContractFunctionParameters) AddInt184(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt184()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt184BigInt adds an int184 parameter to the function call
func (contract *ContractFunctionParameters) AddInt184BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt184()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt192 adds an int192 parameter to the function call
func (contract *ContractFunctionParameters) AddInt192(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt192()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt192BigInt adds an int192 parameter to the function call
func (contract *ContractFunctionParameters) AddInt192BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt192()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt200 adds an int200 parameter to the function call
func (contract *ContractFunctionParameters) AddInt200(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt200()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt200BigInt adds an int200 parameter to the function call
func (contract *ContractFunctionParameters) AddInt200BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()
	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt200()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt208 adds an int208 parameter to the function call
func (contract *ContractFunctionParameters) AddInt208(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt208()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt208BigInt adds an int208parameter to the function call
func (contract *ContractFunctionParameters) AddInt208BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt208()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt216 adds an int216 parameter to the function call
func (contract *ContractFunctionParameters) AddInt216(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt216()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt216BigInt adds an int216 parameter to the function call
func (contract *ContractFunctionParameters) AddInt216BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt216()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt224 adds an int224 parameter to the function call
func (contract *ContractFunctionParameters) AddInt224(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt224()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt224BigInt adds an int224 parameter to the function call
func (contract *ContractFunctionParameters) AddInt224BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt224()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt232 adds an int232 parameter to the function call
func (contract *ContractFunctionParameters) AddInt232(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt232()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt232BigInt adds an int232 parameter to the function call
func (contract *ContractFunctionParameters) AddInt232BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt232()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt240 adds an int240 parameter to the function call
func (contract *ContractFunctionParameters) AddInt240(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt240()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt240BigInt adds an int240 parameter to the function call
func (contract *ContractFunctionParameters) AddInt240BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt240()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt248 adds an int248 parameter to the function call
func (contract *ContractFunctionParameters) AddInt248(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt248()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt248BigInt adds an int248 parameter to the function call
func (contract *ContractFunctionParameters) AddInt248BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt248()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt256 adds an int256 parameter to the function call
func (contract *ContractFunctionParameters) AddInt256(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddInt256()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt256BigInt adds an int256 parameter to the function call
func (contract *ContractFunctionParameters) AddInt256BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddInt256()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint8 adds a uint8 parameter to the function call
func (contract *ContractFunctionParameters) AddUint8(value uint8) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value[31] = value

	contract.function.AddUint8()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint16 adds a uint16 parameter to the function call
func (contract *ContractFunctionParameters) AddUint16(value uint16) *ContractFunctionParameters {
	argument := _NewArgument()

	binary.BigEndian.PutUint16(argument.value[30:32], value)

	contract.function.AddUint16()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint24 adds a uint24 parameter to the function call
func (contract *ContractFunctionParameters) AddUint24(value uint32) *ContractFunctionParameters {
	argument := _NewArgument()

	binary.BigEndian.PutUint32(argument.value[28:32], value)

	contract.function.AddUint24()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint32 adds a uint32 parameter to the function call
func (contract *ContractFunctionParameters) AddUint32(value uint32) *ContractFunctionParameters {
	argument := _NewArgument()

	binary.BigEndian.PutUint32(argument.value[28:32], value)

	contract.function.AddUint32()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint40 adds a uint40 parameter to the function call
func (contract *ContractFunctionParameters) AddUint40(value uint64) *ContractFunctionParameters {
	argument := _NewArgument()

	binary.BigEndian.PutUint64(argument.value[24:32], value)

	contract.function.AddUint40()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint48 adds a uint48 parameter to the function call
func (contract *ContractFunctionParameters) AddUint48(value uint64) *ContractFunctionParameters {
	argument := _NewArgument()

	binary.BigEndian.PutUint64(argument.value[24:32], value)

	contract.function.AddUint48()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint56 adds a uint56 parameter to the function call
func (contract *ContractFunctionParameters) AddUint56(value uint64) *ContractFunctionParameters {
	argument := _NewArgument()

	binary.BigEndian.PutUint64(argument.value[24:32], value)

	contract.function.AddUint56()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint64 adds a uint64 parameter to the function call
func (contract *ContractFunctionParameters) AddUint64(value uint64) *ContractFunctionParameters {
	argument := _NewArgument()

	binary.BigEndian.PutUint64(argument.value[24:32], value)

	contract.function.AddUint64()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint72 adds a uint72 parameter to the function call
func (contract *ContractFunctionParameters) AddUint72(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint72()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint72BigInt adds a uint72 parameter to the function call
func (contract *ContractFunctionParameters) AddUint72BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint72()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint80 adds a uint80 parameter to the function call
func (contract *ContractFunctionParameters) AddUint80(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint80()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint80BigInt adds a uint80parameter to the function call
func (contract *ContractFunctionParameters) AddUint80BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint80()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint88 adds a uint88 parameter to the function call
func (contract *ContractFunctionParameters) AddUint88(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint88()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint88BigInt adds a uint88parameter to the function call
func (contract *ContractFunctionParameters) AddUint88BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint88()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint96 adds a uint96 parameter to the function call
func (contract *ContractFunctionParameters) AddUint96(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint96()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint96BigInt adds a uint96parameter to the function call
func (contract *ContractFunctionParameters) AddUint96BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint96()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint104 adds a uint104 parameter to the function call
func (contract *ContractFunctionParameters) AddUint104(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint104()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint104BigInt adds a uint104 parameter to the function call
func (contract *ContractFunctionParameters) AddUint104igInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint104()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint112 adds a uint112 parameter to the function call
func (contract *ContractFunctionParameters) AddUint112(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint112()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint112BigInt adds a uint112 parameter to the function call
func (contract *ContractFunctionParameters) AddUint112BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint112()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint120 adds a uint120 parameter to the function call
func (contract *ContractFunctionParameters) AddUint120(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint120()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint120BigInt adds a uint120 parameter to the function call
func (contract *ContractFunctionParameters) AddUint120BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint120()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint128 adds a uint128 parameter to the function call
func (contract *ContractFunctionParameters) AddUint128(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint128()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint128BigInt adds a uint128 parameter to the function call
func (contract *ContractFunctionParameters) AddUint128BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint128()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint136 adds a uint136 parameter to the function call
func (contract *ContractFunctionParameters) AddUint136(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint136()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint136BigInt adds a uint136 parameter to the function call
func (contract *ContractFunctionParameters) AddUint136BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint136()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint144 adds a uint144 parameter to the function call
func (contract *ContractFunctionParameters) AddUint144(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint144()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint144BigInt adds a uint144 parameter to the function call
func (contract *ContractFunctionParameters) AddUint144BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint144()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint152 adds a uint152 parameter to the function call
func (contract *ContractFunctionParameters) AddUint152(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint152()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint152BigInt adds a uint152 parameter to the function call
func (contract *ContractFunctionParameters) AddUint152BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint152()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint160 adds a uint160 parameter to the function call
func (contract *ContractFunctionParameters) AddUint160(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint160()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint160BigInt adds a uint160 parameter to the function call
func (contract *ContractFunctionParameters) AddUint160BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint160()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint168 adds a uint168 parameter to the function call
func (contract *ContractFunctionParameters) AddUint168(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint168()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint168BigInt adds a uint168 parameter to the function call
func (contract *ContractFunctionParameters) AddUint168BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint168()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint176 adds a uint176 parameter to the function call
func (contract *ContractFunctionParameters) AddUint176(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint176()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint176BigInt adds a uint176 parameter to the function call
func (contract *ContractFunctionParameters) AddUint176BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint176()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint184 adds a uint184 parameter to the function call
func (contract *ContractFunctionParameters) AddUint184(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint184()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint184BigInt adds a uint184 parameter to the function call
func (contract *ContractFunctionParameters) AddUint184BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint184()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint192 adds a uint192 parameter to the function call
func (contract *ContractFunctionParameters) AddUint192(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint192()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint192BigInt adds a uint192 parameter to the function call
func (contract *ContractFunctionParameters) AddUint192BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint192()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint200 adds a uint200 parameter to the function call
func (contract *ContractFunctionParameters) AddUint200(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint200()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint200BigInt adds a uint200 parameter to the function call
func (contract *ContractFunctionParameters) AddUint200BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint200()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint208 adds a uint208 parameter to the function call
func (contract *ContractFunctionParameters) AddUint208(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint208()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint208BigInt adds a uint208 parameter to the function call
func (contract *ContractFunctionParameters) AddUint208BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint208()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint216 adds a uint216 parameter to the function call
func (contract *ContractFunctionParameters) AddUint216(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint216()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint216BigInt adds a uint216 parameter to the function call
func (contract *ContractFunctionParameters) AddUint216BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint216()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint224 adds a uint224 parameter to the function call
func (contract *ContractFunctionParameters) AddUint224(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint224()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint224BigInt adds a uint224 parameter to the function call
func (contract *ContractFunctionParameters) AddUint224BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint224()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint232 adds a uint232 parameter to the function call
func (contract *ContractFunctionParameters) AddUint232(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint232()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint232BigInt adds a uint232 parameter to the function call
func (contract *ContractFunctionParameters) AddUint232BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint232()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint240 adds a uint240 parameter to the function call
func (contract *ContractFunctionParameters) AddUint240(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint240()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint240BigInt adds a uint240 parameter to the function call
func (contract *ContractFunctionParameters) AddUint240BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint240()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint248 adds a uint248 parameter to the function call
func (contract *ContractFunctionParameters) AddUint248(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint248()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint248BigInt adds a uint248 parameter to the function call
func (contract *ContractFunctionParameters) AddUint248BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint248()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint256 adds a uint256 parameter to the function call
func (contract *ContractFunctionParameters) AddUint256(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value

	contract.function.AddUint256()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddUint256BigInt adds a uint256 parameter to the function call
func (contract *ContractFunctionParameters) AddUint256BigInt(value *big.Int) *ContractFunctionParameters {
	argument := _NewArgument()

	valueCopy := new(big.Int).Set(value)
	argument.value = math.U256Bytes(valueCopy)

	contract.function.AddUint256()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddInt8Array adds an int8 array parameter to the function call
func (contract *ContractFunctionParameters) AddInt8Array(value []int8) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)*32+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		binary.BigEndian.PutUint32(result[i*32+32+28:i*32+32+32], uint32(v))
	}

	argument.value = result

	contract.function.AddInt32Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddInt16Array adds an int16 array parameter to the function call
func (contract *ContractFunctionParameters) AddInt16Array(value []int16) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)*32+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		binary.BigEndian.PutUint32(result[i*32+32+28:i*32+32+32], uint32(v))
	}

	argument.value = result

	contract.function.AddInt32Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddInt24Array adds an int24 array parameter to the function call
func (contract *ContractFunctionParameters) AddInt24Array(value []int32) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)*32+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		binary.BigEndian.PutUint32(result[i*32+32+28:i*32+32+32], uint32(v))
	}

	argument.value = result

	contract.function.AddInt32Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddInt32Array adds an int32 array parameter to the function call
func (contract *ContractFunctionParameters) AddInt32Array(value []int32) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		binary.BigEndian.PutUint32(result[i*32+32+28:i*32+32+32], uint32(v))
	}

	argument.value = result

	contract.function.AddInt32Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddInt64Array adds an int64 array parameter to the function call
func (contract *ContractFunctionParameters) AddInt64Array(value []int64) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)*32+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		binary.BigEndian.PutUint64(result[i*32+32+24:i*32+32+32], uint64(v))
	}

	argument.value = result

	contract.function.AddInt64Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddInt256Array adds an int256 array parameter to the function call
func (contract *ContractFunctionParameters) AddInt256Array(value [][32]byte) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)*32+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		copy(result[i*32+32:i*32+32+32], v[0:32])
	}

	argument.value = result

	contract.function.AddInt256Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddUint32Array adds a uint32 array parameter to the function call
func (contract *ContractFunctionParameters) AddUint32Array(value []uint32) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)*32+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		binary.BigEndian.PutUint32(result[i*32+32+28:i*32+32+32], v)
	}

	argument.value = result

	contract.function.AddUint32Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddUint64Array adds a uint64 array parameter to the function call
func (contract *ContractFunctionParameters) AddUint64Array(value []uint64) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)*32+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		binary.BigEndian.PutUint64(result[i*32+32+24:i*32+32+32], v)
	}

	argument.value = result

	contract.function.AddUint64Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddUint256Array adds a uint256 array parameter to the function call
func (contract *ContractFunctionParameters) AddUint256Array(value [][32]byte) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)*32+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		copy(result[i*32+32:i*32+32+32], v[0:32])
	}

	argument.value = result

	contract.function.AddUint256Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddAddressArray adds an address array parameter to the function call
func (contract *ContractFunctionParameters) AddAddressArray(value []string) (*ContractFunctionParameters, error) {
	argument := _NewArgument()
	argument.dynamic = true

	result := make([]byte, len(value)*32+32)

	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		if len(v) != 40 {
			return contract, errors.Unwrap(fmt.Errorf("address is required to be 40 characters"))
		}

		addressBytes, err := hex.DecodeString(v)
		if err != nil {
			return contract, err
		}

		copy(result[i*32+32+12:i*32+32+32], addressBytes[0:20])
	}

	argument.value = result

	contract.function.AddAddressArray()
	contract.arguments = append(contract.arguments, argument)
	return contract, nil
}

// AddString ads a string parameter to the function call
func (contract *ContractFunctionParameters) AddString(value string) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	bytes := []byte(value)
	binary.BigEndian.PutUint64(argument.value[24:32], uint64(len(bytes)))
	argument.value = append(argument.value, bytes...)
	argument.value = append(argument.value, make([]byte, 32-len(bytes)%32)...)

	contract.function.AddString()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddBytes adds a bytes parameter to the function call
func (contract *ContractFunctionParameters) AddBytes(value []byte) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	binary.BigEndian.PutUint64(argument.value[24:32], uint64(len(value)))
	argument.value = append(argument.value, value...)
	argument.value = append(argument.value, make([]byte, uint64(32-len(value)%32))...)

	contract.function.AddBytes()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddBytes32 adds a bytes32 parameter to the function call
func (contract *ContractFunctionParameters) AddBytes32(value [32]byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.value = value[:]

	contract.function.AddBytes32()
	contract.arguments = append(contract.arguments, argument)

	return contract
}

// AddAddress adds an address parameter to the function call
func (contract *ContractFunctionParameters) AddAddress(value string) (*ContractFunctionParameters, error) {
	if len(value) != 40 {
		return contract, errors.Unwrap(fmt.Errorf("address is required to be 40 characters"))
	}

	addressBytes, err := hex.DecodeString(value)
	if err != nil {
		return contract, err
	}

	argument := _NewArgument()
	argument.dynamic = false

	bytes := make([]byte, 12)
	bytes = append(bytes, addressBytes...)

	argument.value = bytes

	contract.function.AddAddress()
	contract.arguments = append(contract.arguments, argument)
	return contract, nil
}

// AddBytesArray adds a bytes array parameter to the function call
func (contract *ContractFunctionParameters) AddBytesArray(value [][]byte) *ContractFunctionParameters {
	argument := _NewArgument()

	argument.dynamic = true
	argument.value = bytesArray(value)

	contract.function.AddBytesArray()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddBytes32Array adds a bytes32 array parameter to the function call
func (contract *ContractFunctionParameters) AddBytes32Array(value [][]byte) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true
	// Each item is 32 bytes. The total size should be len(value) * 32 plus 32 bytes for the length header
	result := make([]byte, len(value)*32+32)

	// Write the length of the array into the first 32 bytes
	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	for i, v := range value {
		// Ensure that each byte slice is 32 bytes long.
		var b [32]byte
		copy(b[32-len(v):], v)

		// Then copy into the result
		from := i*32 + 32
		to := (i+1)*32 + 32
		copy(result[from:to], b[:])
	}

	argument.value = result

	contract.function.AddBytes32Array()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

// AddStringArray adds a string array parameter to the function call
func (contract *ContractFunctionParameters) AddStringArray(value []string) *ContractFunctionParameters {
	argument := _NewArgument()
	argument.dynamic = true

	var bytes [][]byte
	for _, s := range value {
		bytes = append(bytes, []byte(s))
	}

	argument.value = bytesArray(bytes)
	contract.function.AddStringArray()
	contract.arguments = append(contract.arguments, argument)
	return contract
}

func (contract *ContractFunctionParameters) _Build(functionName *string) []byte {
	length := uint64(0)

	functionOffset := uint64(0)
	if functionName != nil {
		functionOffset = uint64(4)
	}

	for _, argument := range contract.arguments {
		length += uint64(32)
		if argument.dynamic {
			length += uint64(len(argument.value))
		}
	}

	result := make([]byte, length+functionOffset)
	if functionName != nil {
		copy(result[0:4], contract.function._Build(functionName))
	}

	offset := uint64(len(contract.arguments) * 32)

	for i, argument := range contract.arguments {
		j := uint64(i)
		if argument.dynamic {
			binary.BigEndian.PutUint64(result[(j*32+functionOffset)+24:(j+1)*32+functionOffset], offset)
			copy(result[offset+functionOffset:], argument.value)
			offset += uint64(len(argument.value))
		} else {
			copy(result[j*32+functionOffset:((j+1)*32)+functionOffset], argument.value)
		}
	}

	return result
}

func _NewArgument() Argument {
	return Argument{
		value:   make([]byte, 32),
		dynamic: false,
	}
}

func _NewIntArgument(value interface{}) Argument {
	var val int64
	switch v := value.(type) {
	case int64:
		val = v
	case int32:
		val = int64(v)
	case int16:
		val = int64(v)
	case int8:
		val = int64(v)
	default:
		panic(fmt.Sprintf("unsupported type %T", value))
	}

	if val > 0 {
		return _NewArgument()
	}
	argument := make([]byte, 32)
	for i := range argument {
		argument[i] = 0xff
	}
	return Argument{
		value:   argument,
		dynamic: false,
	}
}

func bytesArray(value [][]byte) []byte {
	// Calculate Length of final result
	length := uint64(0)
	for _, s := range value {
		length += 32 + 32
		sbytes := s
		if len(sbytes)/32 == 0 {
			length += 32
		} else {
			length += uint64(((len(sbytes) / 32) + 1) * 32)
		}
	}

	// Zero initialize final resulting byte array
	result := make([]byte, length+32)

	// Write length of array into the first 32 bytes
	binary.BigEndian.PutUint64(result[24:32], uint64(len(value)))

	// Create array of byte arrays to hold each string value
	// Needed to concat later
	arguments := make([][]byte, len(value))

	// Convert each argument into bytes, and push each argument
	// into the argument list
	for i, s := range value {
		// Get the length of the current argument (again)
		var length uint64
		if len(s)/32 == 0 {
			length = 32
		} else {
			length = uint64(((len(s) / 32) + 1) * 32)
		}

		// Create byte array of correct size
		// Length of value to the nearest 32 byte boundary +
		// 32 bytes to store the length
		bytes := make([]byte, length+32)

		// Write length into first 32 bytes
		binary.BigEndian.PutUint64(bytes[24:32], uint64(len(s)))

		// Copy string as bytes to the rest of the buffer
		copy(bytes[32:], s)

		// Set the argument bytes to be used later
		arguments[i] = bytes
	}

	// Initialize offset to the number of strings
	offset := uint64(len(value) * 32)

	// For each argument, write the offset into result
	// and the argument value (which includes data and length already)
	for i, s := range arguments {
		binary.BigEndian.PutUint64(result[(i+1)*32+24:(i+2)*32], offset)
		copy(result[offset+32:offset+32+uint64(len(s))], s)
		offset += uint64(len(s))
	}

	return result
}
// Filename: contract_function_parameters_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"math/big"
	"reflect"
	"strings"
	"sync"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/stretchr/testify/require"
)

var (
	contractID   ContractID
	deployedOnce sync.Once
	intTypeMap   = map[string]intTypeData{"int256": {(*ContractFunctionParameters).AddInt256,
		func(result *ContractFunctionResult) []byte { return result.GetInt256(0) },
		"returnInt256",
	},
		"int248": {(*ContractFunctionParameters).AddInt248,
			func(result *ContractFunctionResult) []byte { return result.GetInt248(0) },
			"returnInt248",
		},
		"int240": {(*ContractFunctionParameters).AddInt240,
			func(result *ContractFunctionResult) []byte { return result.GetInt240(0) },
			"returnInt240",
		},
		"int232": {(*ContractFunctionParameters).AddInt232,
			func(result *ContractFunctionResult) []byte { return result.GetInt232(0) },
			"returnInt232",
		},
		"int224": {(*ContractFunctionParameters).AddInt224,
			func(result *ContractFunctionResult) []byte { return result.GetInt224(0) },
			"returnInt224",
		},
		"int216": {(*ContractFunctionParameters).AddInt216,
			func(result *ContractFunctionResult) []byte { return result.GetInt216(0) },
			"returnInt216",
		},
		"int208": {(*ContractFunctionParameters).AddInt208,
			func(result *ContractFunctionResult) []byte { return result.GetInt208(0) },
			"returnInt208",
		},
		"int200": {(*ContractFunctionParameters).AddInt200,
			func(result *ContractFunctionResult) []byte { return result.GetInt200(0) },
			"returnInt200",
		},
		"int192": {(*ContractFunctionParameters).AddInt192,
			func(result *ContractFunctionResult) []byte { return result.GetInt192(0) },
			"returnInt192",
		},
		"int184": {(*ContractFunctionParameters).AddInt184,
			func(result *ContractFunctionResult) []byte { return result.GetInt184(0) },
			"returnInt184",
		},
		"int176": {(*ContractFunctionParameters).AddInt176,
			func(result *ContractFunctionResult) []byte { return result.GetInt176(0) },
			"returnInt176",
		},
		"int168": {(*ContractFunctionParameters).AddInt168,
			func(result *ContractFunctionResult) []byte { return result.GetInt168(0) },
			"returnInt168",
		},
		"int160": {(*ContractFunctionParameters).AddInt160,
			func(result *ContractFunctionResult) []byte { return result.GetInt160(0) },
			"returnInt160",
		},
		"int152": {(*ContractFunctionParameters).AddInt152,
			func(result *ContractFunctionResult) []byte { return result.GetInt152(0) },
			"returnInt152",
		},
		"int144": {(*ContractFunctionParameters).AddInt144,
			func(result *ContractFunctionResult) []byte { return result.GetInt144(0) },
			"returnInt144",
		},
		"int136": {(*ContractFunctionParameters).AddInt136,
			func(result *ContractFunctionResult) []byte { return result.GetInt136(0) },
			"returnInt136",
		},
		"int128": {(*ContractFunctionParameters).AddInt128,
			func(result *ContractFunctionResult) []byte { return result.GetInt128(0) },
			"returnInt128",
		},
		"int120": {(*ContractFunctionParameters).AddInt120,
			func(result *ContractFunctionResult) []byte { return result.GetInt120(0) },
			"returnInt120",
		},
		"int112": {(*ContractFunctionParameters).AddInt112,
			func(result *ContractFunctionResult) []byte { return result.GetInt112(0) },
			"returnInt112",
		},
		"int104": {(*ContractFunctionParameters).AddInt104,
			func(result *ContractFunctionResult) []byte { return result.GetInt104(0) },
			"returnInt104",
		},
		"int96": {(*ContractFunctionParameters).AddInt96,
			func(result *ContractFunctionResult) []byte { return result.GetInt96(0) },
			"returnInt96",
		},
		"int88": {(*ContractFunctionParameters).AddInt88,
			func(result *ContractFunctionResult) []byte { return result.GetInt88(0) },
			"returnInt88",
		},
		"int80": {(*ContractFunctionParameters).AddInt80,
			func(result *ContractFunctionResult) []byte { return result.GetInt80(0) },
			"returnInt80",
		},
		"int72": {(*ContractFunctionParameters).AddInt72,
			func(result *ContractFunctionResult) []byte { return result.GetInt72(0) },
			"returnInt72",
		},
		"uint256": {(*ContractFunctionParameters).AddUint256,
			func(result *ContractFunctionResult) []byte { return result.GetUint256(0) },
			"returnUint256",
		},
		"uint248": {(*ContractFunctionParameters).AddUint248,
			func(result *ContractFunctionResult) []byte { return result.GetUint248(0) },
			"returnUint248",
		},
		"uint240": {(*ContractFunctionParameters).AddUint240,
			func(result *ContractFunctionResult) []byte { return result.GetUint240(0) },
			"returnUint240",
		},
		"uint232": {(*ContractFunctionParameters).AddUint232,
			func(result *ContractFunctionResult) []byte { return result.GetUint232(0) },
			"returnUint232",
		},
		"uint224": {(*ContractFunctionParameters).AddUint224,
			func(result *ContractFunctionResult) []byte { return result.GetUint224(0) },
			"returnUint224",
		},
		"uint216": {(*ContractFunctionParameters).AddUint216,
			func(result *ContractFunctionResult) []byte { return result.GetUint216(0) },
			"returnUint216",
		},
		"uint208": {(*ContractFunctionParameters).AddUint208,
			func(result *ContractFunctionResult) []byte { return result.GetUint208(0) },
			"returnUint208",
		},
		"uint200": {(*ContractFunctionParameters).AddUint200,
			func(result *ContractFunctionResult) []byte { return result.GetUint200(0) },
			"returnUint200",
		},
		"uint192": {(*ContractFunctionParameters).AddUint192,
			func(result *ContractFunctionResult) []byte { return result.GetInt192(0) },
			"returnUint192",
		},
		"uint184": {(*ContractFunctionParameters).AddUint184,
			func(result *ContractFunctionResult) []byte { return result.GetUint184(0) },
			"returnUint184",
		},
		"uint176": {(*ContractFunctionParameters).AddUint176,
			func(result *ContractFunctionResult) []byte { return result.GetUint176(0) },
			"returnUint176",
		},
		"uint168": {(*ContractFunctionParameters).AddUint168,
			func(result *ContractFunctionResult) []byte { return result.GetUint168(0) },
			"returnUint168",
		},
		"uint160": {(*ContractFunctionParameters).AddUint160,
			func(result *ContractFunctionResult) []byte { return result.GetUint160(0) },
			"returnUint160",
		},
		"uint152": {(*ContractFunctionParameters).AddUint152,
			func(result *ContractFunctionResult) []byte { return result.GetUint152(0) },
			"returnUint152",
		},
		"uint144": {(*ContractFunctionParameters).AddUint144,
			func(result *ContractFunctionResult) []byte { return result.GetUint144(0) },
			"returnUint144",
		},
		"uint136": {(*ContractFunctionParameters).AddUint136,
			func(result *ContractFunctionResult) []byte { return result.GetUint136(0) },
			"returnUint136",
		},
		"uint128": {(*ContractFunctionParameters).AddUint128,
			func(result *ContractFunctionResult) []byte { return result.GetUint128(0) },
			"returnUint128",
		},
		"uint120": {(*ContractFunctionParameters).AddUint120,
			func(result *ContractFunctionResult) []byte { return result.GetUint120(0) },
			"returnUint120",
		},
		"uint112": {(*ContractFunctionParameters).AddUint112,
			func(result *ContractFunctionResult) []byte { return result.GetUint112(0) },
			"returnUint112",
		},
		"uint104": {(*ContractFunctionParameters).AddUint104,
			func(result *ContractFunctionResult) []byte { return result.GetUint104(0) },
			"returnUint104",
		},
		"uint96": {(*ContractFunctionParameters).AddUint96,
			func(result *ContractFunctionResult) []byte { return result.GetUint96(0) },
			"returnUint96",
		},
		"uint88": {(*ContractFunctionParameters).AddUint88,
			func(result *ContractFunctionResult) []byte { return result.GetUint88(0) },
			"returnUint88",
		},
		"uint80": {(*ContractFunctionParameters).AddUint80,
			func(result *ContractFunctionResult) []byte { return result.GetUint80(0) },
			"returnUint80",
		},
		"uint72": {(*ContractFunctionParameters).AddUint72,
			func(result *ContractFunctionResult) []byte { return result.GetUint72(0) },
			"returnUint72",
		},
	}
)

type intTypeData struct {
	fnAdd     func(parameters *ContractFunctionParameters, value []byte) *ContractFunctionParameters
	fnExtract func(result *ContractFunctionResult) []byte
	fnName    string
}

func intType(t *testing.T, env IntegrationTestEnv, intType string, value string) {
	data, ok := intTypeMap[intType]
	require.True(t, ok)

	valueBigInt, ok := new(big.Int).SetString(value, 10)
	require.True(t, ok)
	valueBigIntCopy := new(big.Int).Set(valueBigInt)

	contractCall, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).
		SetQueryPayment(NewHbar(20)).
		SetFunction(data.fnName, data.fnAdd(NewContractFunctionParameters(), math.U256Bytes(valueBigInt))).
		Execute(env.Client)

	require.NoError(t, err)
	resultBigInt := new(big.Int)
	if strings.Contains(intType, "uint") {
		resultBigInt = new(big.Int).SetBytes(data.fnExtract(&contractCall))
	} else {
		value := new(big.Int).SetBytes(data.fnExtract(&contractCall))
		resultBigInt = math.S256(value)
	}

	require.Equal(t, valueBigIntCopy.String(), resultBigInt.String())
}

func deployContract(env IntegrationTestEnv) (*ContractID, error) {
	var result *ContractID
	var err error

	deployedOnce.Do(func() {
		result, err = performDeploy(env)
		if err == nil {
			contractID = *result
		}
	})
	return result, err
}

func performDeploy(env IntegrationTestEnv) (*ContractID, error) {
	bytecode := []byte(`0x608060405234801561001057600080fd5b50611f83806100206000396000f3fe608060405234801561001057600080fd5b50600436106104805760003560e01c806381dbe13e11610257578063bb6b524311610146578063dbb04ed9116100c3578063e713cda811610087578063e713cda814610df6578063f4e490f514610e19578063f6e877f414610e3a578063f8293f6e14610e60578063ffb8050114610e8257600080fd5b8063dbb04ed914610d2d578063de9fb48414610d56578063e05e91e014610d83578063e066de5014610daa578063e0f53e2414610dd057600080fd5b8063cbd2e6a51161010a578063cbd2e6a514610c9a578063cdb9e4e814610cbf578063d1b10ad71461066d578063d79d4d4014610ce5578063dade0c0b14610d0b57600080fd5b8063bb6b524314610bdc578063bd90536a14610c02578063c503772d14610c2a578063c6c18a1c14610c4a578063c7d8b87e14610c7457600080fd5b8063a1bda122116101d4578063b4e3e7b111610198578063b4e3e7b114610b28578063b834bfe914610b4e578063b8da8d1614610b6f578063b989c7ee14610b95578063ba945bdb14610bb657600080fd5b8063a1bda12214610a9f578063a401d60d14610ac0578063a75761f114610ae6578063aa80ca2e14610733578063b2db404a14610b0757600080fd5b8063923f5edf1161021b578063923f5edf146109f557806394cd7c8014610a1657806398508ba314610a375780639b1794ae14610a58578063a08b9f6714610a7e57600080fd5b806381dbe13e14610978578063827147ce146105cf578063881c8fb71461099357806388b7e6f5146109b9578063909c5b24146109da57600080fd5b806338fa665811610373578063628bc3ef116102f057806372a06b4d116102b457806372a06b4d146108ef578063796a27ea146109105780637d0dc262146109365780637ec32d84146109575780637f8082f71461073357600080fd5b8063628bc3ef1461083f57806364e008c11461086057806368ef4466146108815780636a54715c146108a257806370a5cb81146108c357600080fd5b806344e7b0371161033757806344e7b0371461068957806348d848d0146107d95780634bbc9a67146107f7578063545e21131461081257806359adb2df1461066d57600080fd5b806338fa6658146107335780633b45e6e01461074e5780633e1a27711461076f5780633f396e6714610790578063407b899b146107b857600080fd5b8063129ed5da116104015780632421101f116103c55780632421101f146106895780632ef16e8e146106af5780632f47a40d146106d05780632f6c1bb4146106f157806333520ec31461071257600080fd5b8063129ed5da146105ea57806312cd95a114610610578063189cea8e146106315780631d1145621461065257806322937ea91461066d57600080fd5b80630a958dc8116104485780630a958dc81461054b57806310d545531461056c578063118b84151461058d57806311ec6c90146105ae578063126bc815146105cf57600080fd5b8063017fa10b14610485578063021d88ab146104b357806303745430146104de57806306ac6fe1146104ff57806308123e0914610525575b600080fd5b6104966104933660046117ac565b90565b6040516001600160801b0390911681526020015b60405180910390f35b6104c1610493366004611b97565b6040516bffffffffffffffffffffffff90911681526020016104aa565b6104ec610493366004611333565b604051600c9190910b81526020016104aa565b61050d610493366004611785565b6040516001600160781b0390911681526020016104aa565b610533610493366004611aa9565b60405166ffffffffffffff90911681526020016104aa565b610559610493366004611609565b60405160049190910b81526020016104aa565b61057a6104933660046113d8565b60405160119190910b81526020016104aa565b61059b6104933660046115c7565b604051601e9190910b81526020016104aa565b6105bc61049336600461143b565b60405160139190910b81526020016104aa565b6105dd6104933660046112f8565b6040516104aa9190611d82565b6105f8610493366004611821565b6040516001600160981b0390911681526020016104aa565b61061e6104933660046113f9565b60405160129190910b81526020016104aa565b61063f61049336600461149e565b60405160169190910b81526020016104aa565b610660610493366004610fbd565b6040516104aa9190611c0e565b61067b6104933660046112e0565b6040519081526020016104aa565b610697610493366004610f9a565b6040516001600160a01b0390911681526020016104aa565b6106bd6104933660046115a6565b604051601d9190910b81526020016104aa565b6106de6104933660046116ef565b604051600a9190910b81526020016104aa565b6106ff610493366004611501565b60405160199190910b81526020016104aa565b610720610493366004611522565b604051601a9190910b81526020016104aa565b6107416104933660046110ec565b6040516104aa9190611c95565b61075c6104933660046113b7565b60405160109190910b81526020016104aa565b61077d610493366004611564565b604051601c9190910b81526020016104aa565b61079e610493366004611af8565b60405168ffffffffffffffffff90911681526020016104aa565b6107c661049336600461166c565b60405160079190910b81526020016104aa565b6107e76104933660046112c6565b60405190151581526020016104aa565b61080561049336600461105e565b6040516104aa9190611c5b565b6108256108203660046116ae565b610ea6565b60408051600093840b81529190920b6020820152016104aa565b61084d6104933660046116ce565b60405160099190910b81526020016104aa565b61086e6104933660046114bf565b60405160179190910b81526020016104aa565b61088f61049336600461145c565b60405160149190910b81526020016104aa565b6108b061049336600461164b565b60405160069190910b81526020016104aa565b6108d1610493366004611731565b6040516cffffffffffffffffffffffffff90911681526020016104aa565b6108fd6104933660046116ae565b60405160009190910b81526020016104aa565b61091e610493366004611954565b6040516001600160d81b0390911681526020016104aa565b610944610493366004611543565b604051601b9190910b81526020016104aa565b610965610493366004611585565b60405160029190910b81526020016104aa565b610986610493366004611224565b6040516104aa9190611d2e565b6109a1610493366004611891565b6040516001600160b01b0390911681526020016104aa565b6109c7610493366004611396565b604051600f9190910b81526020016104aa565b6109e8610493366004611173565b6040516104aa9190611ccd565b610a0361049336600461147d565b60405160159190910b81526020016104aa565b610a246104933660046114e0565b60405160189190910b81526020016104aa565b610a45610493366004611354565b604051600d9190910b81526020016104aa565b610a666104933660046118b8565b6040516001600160b81b0390911681526020016104aa565b610a8c610493366004611710565b604051600b9190910b81526020016104aa565b610aad61049336600461141a565b60405160019190910b81526020016104aa565b610ace6104933660046119ec565b6040516001600160f01b0390911681526020016104aa565b610af4610493366004611848565b60405161ffff90911681526020016104aa565b610b1561049336600461162a565b60405160059190910b81526020016104aa565b610b3661049336600461175e565b6040516001600160701b0390911681526020016104aa565b610b5c610493366004611375565b604051600e9190910b81526020016104aa565b610b7d61049336600461186a565b6040516001600160a81b0390911681526020016104aa565b610ba36104933660046115e8565b60405160039190910b81526020016104aa565b610bc46104933660046117d3565b6040516001600160881b0390911681526020016104aa565b610bea610493366004611906565b6040516001600160c81b0390911681526020016104aa565b610c15610c103660046112e0565b610ebe565b604080519283526020830191909152016104aa565b610c38610493366004611b21565b60405160ff90911681526020016104aa565b610c58610493366004611b6c565b6040516affffffffffffffffffffff90911681526020016104aa565b610c82610493366004611a13565b6040516001600160f81b0390911681526020016104aa565b610ca8610493366004611a83565b60405165ffffffffffff90911681526020016104aa565b610ccd61049336600461197b565b6040516001600160e01b0390911681526020016104aa565b610cf361049336600461192d565b6040516001600160d01b0390911681526020016104aa565b610d1e610d19366004611a3a565b610ecd565b6040516104aa93929190611d95565b610d3b610493366004611b42565b60405169ffffffffffffffffffff90911681526020016104aa565b610d69610d64366004611609565b610f0b565b60408051600493840b81529190920b6020820152016104aa565b610d91610493366004611ad0565b60405167ffffffffffffffff90911681526020016104aa565b610db86104933660046119a2565b6040516001600160e81b0390911681526020016104aa565b610dde6104933660046118df565b6040516001600160c01b0390911681526020016104aa565b610e04610493366004611a3a565b60405163ffffffff90911681526020016104aa565b610e2761049336600461168d565b60405160089190910b81526020016104aa565b610e486104933660046117fa565b6040516001600160901b0390911681526020016104aa565b610e6e6104933660046119c9565b60405162ffffff90911681526020016104aa565b610e90610493366004611a5e565b60405164ffffffffff90911681526020016104aa565b60008082610eb5816014611ead565b91509150915091565b60008082610eb5816001611e22565b600080606083610ede600182611ee4565b6040805180820190915260028152614f4b60f01b602082015291945063ffffffff16925090509193909250565b60008082610eb5816001611e63565b80358015158114610f2a57600080fd5b919050565b600082601f830112610f3f578081fd5b813567ffffffffffffffff811115610f5957610f59611f1f565b610f6c601f8201601f1916602001611dcd565b818152846020838601011115610f80578283fd5b816020850160208301379081016020019190915292915050565b600060208284031215610fab578081fd5b8135610fb681611f35565b9392505050565b60006020808385031215610fcf578182fd5b823567ffffffffffffffff811115610fe5578283fd5b8301601f81018513610ff5578283fd5b803561100861100382611dfe565b611dcd565b80828252848201915084840188868560051b8701011115611027578687fd5b8694505b8385101561105257803561103e81611f35565b83526001949094019391850191850161102b565b50979650505050505050565b60006020808385031215611070578182fd5b823567ffffffffffffffff811115611086578283fd5b8301601f81018513611096578283fd5b80356110a461100382611dfe565b80828252848201915084840188868560051b87010111156110c3578687fd5b8694505b83851015611052576110d881610f1a565b8352600194909401939185019185016110c7565b600060208083850312156110fe578182fd5b823567ffffffffffffffff811115611114578283fd5b8301601f81018513611124578283fd5b803561113261100382611dfe565b80828252848201915084840188868560051b8701011115611151578687fd5b8694505b83851015611052578035835260019490940193918501918501611155565b60006020808385031215611185578182fd5b823567ffffffffffffffff8082111561119c578384fd5b818501915085601f8301126111af578384fd5b81356111bd61100382611dfe565b80828252858201915085850189878560051b88010111156111dc578788fd5b875b84811015611215578135868111156111f457898afd5b6112028c8a838b0101610f2f565b85525092870192908701906001016111de565b50909998505050505050505050565b60006020808385031215611236578182fd5b823567ffffffffffffffff8082111561124d578384fd5b818501915085601f830112611260578384fd5b813561126e61100382611dfe565b80828252858201915085850189878560051b880101111561128d578788fd5b875b84811015611215578135868111156112a557898afd5b6112b38c8a838b0101610f2f565b855250928701929087019060010161128f565b6000602082840312156112d7578081fd5b610fb682610f1a565b6000602082840312156112f1578081fd5b5035919050565b600060208284031215611309578081fd5b813567ffffffffffffffff81111561131f578182fd5b61132b84828501610f2f565b949350505050565b600060208284031215611344578081fd5b813580600c0b8114610fb6578182fd5b600060208284031215611365578081fd5b813580600d0b8114610fb6578182fd5b600060208284031215611386578081fd5b813580600e0b8114610fb6578182fd5b6000602082840312156113a7578081fd5b813580600f0b8114610fb6578182fd5b6000602082840312156113c8578081fd5b81358060100b8114610fb6578182fd5b6000602082840312156113e9578081fd5b81358060110b8114610fb6578182fd5b60006020828403121561140a578081fd5b81358060120b8114610fb6578182fd5b60006020828403121561142b578081fd5b81358060010b8114610fb6578182fd5b60006020828403121561144c578081fd5b81358060130b8114610fb6578182fd5b60006020828403121561146d578081fd5b81358060140b8114610fb6578182fd5b60006020828403121561148e578081fd5b81358060150b8114610fb6578182fd5b6000602082840312156114af578081fd5b81358060160b8114610fb6578182fd5b6000602082840312156114d0578081fd5b81358060170b8114610fb6578182fd5b6000602082840312156114f1578081fd5b81358060180b8114610fb6578182fd5b600060208284031215611512578081fd5b81358060190b8114610fb6578182fd5b600060208284031215611533578081fd5b813580601a0b8114610fb6578182fd5b600060208284031215611554578081fd5b813580601b0b8114610fb6578182fd5b600060208284031215611575578081fd5b813580601c0b8114610fb6578182fd5b600060208284031215611596578081fd5b81358060020b8114610fb6578182fd5b6000602082840312156115b7578081fd5b813580601d0b8114610fb6578182fd5b6000602082840312156115d8578081fd5b813580601e0b8114610fb6578182fd5b6000602082840312156115f9578081fd5b81358060030b8114610fb6578182fd5b60006020828403121561161a578081fd5b81358060040b8114610fb6578182fd5b60006020828403121561163b578081fd5b81358060050b8114610fb6578182fd5b60006020828403121561165c578081fd5b81358060060b8114610fb6578182fd5b60006020828403121561167d578081fd5b81358060070b8114610fb6578182fd5b60006020828403121561169e578081fd5b81358060080b8114610fb6578182fd5b6000602082840312156116bf578081fd5b813580820b8114610fb6578182fd5b6000602082840312156116df578081fd5b81358060090b8114610fb6578182fd5b600060208284031215611700578081fd5b813580600a0b8114610fb6578182fd5b600060208284031215611721578081fd5b813580600b0b8114610fb6578182fd5b600060208284031215611742578081fd5b81356cffffffffffffffffffffffffff81168114610fb6578182fd5b60006020828403121561176f578081fd5b81356001600160701b0381168114610fb6578182fd5b600060208284031215611796578081fd5b81356001600160781b0381168114610fb6578182fd5b6000602082840312156117bd578081fd5b81356001600160801b0381168114610fb6578182fd5b6000602082840312156117e4578081fd5b81356001600160881b0381168114610fb6578182fd5b60006020828403121561180b578081fd5b81356001600160901b0381168114610fb6578182fd5b600060208284031215611832578081fd5b81356001600160981b0381168114610fb6578182fd5b600060208284031215611859578081fd5b813561ffff81168114610fb6578182fd5b60006020828403121561187b578081fd5b81356001600160a81b0381168114610fb6578182fd5b6000602082840312156118a2578081fd5b81356001600160b01b0381168114610fb6578182fd5b6000602082840312156118c9578081fd5b81356001600160b81b0381168114610fb6578182fd5b6000602082840312156118f0578081fd5b81356001600160c01b0381168114610fb6578182fd5b600060208284031215611917578081fd5b81356001600160c81b0381168114610fb6578182fd5b60006020828403121561193e578081fd5b81356001600160d01b0381168114610fb6578182fd5b600060208284031215611965578081fd5b81356001600160d81b0381168114610fb6578182fd5b60006020828403121561198c578081fd5b81356001600160e01b0381168114610fb6578182fd5b6000602082840312156119b3578081fd5b81356001600160e81b0381168114610fb6578182fd5b6000602082840312156119da578081fd5b813562ffffff81168114610fb6578182fd5b6000602082840312156119fd578081fd5b81356001600160f01b0381168114610fb6578182fd5b600060208284031215611a24578081fd5b81356001600160f81b0381168114610fb6578182fd5b600060208284031215611a4b578081fd5b813563ffffffff81168114610fb6578182fd5b600060208284031215611a6f578081fd5b813564ffffffffff81168114610fb6578182fd5b600060208284031215611a94578081fd5b813565ffffffffffff81168114610fb6578182fd5b600060208284031215611aba578081fd5b813566ffffffffffffff81168114610fb6578182fd5b600060208284031215611ae1578081fd5b813567ffffffffffffffff81168114610fb6578182fd5b600060208284031215611b09578081fd5b813568ffffffffffffffffff81168114610fb6578182fd5b600060208284031215611b32578081fd5b813560ff81168114610fb6578182fd5b600060208284031215611b53578081fd5b813569ffffffffffffffffffff81168114610fb6578182fd5b600060208284031215611b7d578081fd5b81356affffffffffffffffffffff81168114610fb6578182fd5b600060208284031215611ba8578081fd5b81356bffffffffffffffffffffffff81168114610fb6578182fd5b60008151808452815b81811015611be857602081850181015186830182015201611bcc565b81811115611bf95782602083870101525b50601f01601f19169290920160200192915050565b6020808252825182820181905260009190848201906040850190845b81811015611c4f5783516001600160a01b031683529284019291840191600101611c2a565b50909695505050505050565b6020808252825182820181905260009190848201906040850190845b81811015611c4f578351151583529284019291840191600101611c77565b6020808252825182820181905260009190848201906040850190845b81811015611c4f57835183529284019291840191600101611cb1565b6000602080830181845280855180835260408601915060408160051b8701019250838701855b82811015611d2157603f19888603018452611d0f858351611bc3565b94509285019290850190600101611cf3565b5092979650505050505050565b6000602080830181845280855180835260408601915060408160051b8701019250838701855b82811015611d2157603f19888603018452611d70858351611bc3565b94509285019290850190600101611d54565b602081526000610fb66020830184611bc3565b63ffffffff8416815267ffffffffffffffff83166020820152606060408201526000611dc46060830184611bc3565b95945050505050565b604051601f8201601f1916810167ffffffffffffffff81118282101715611df657611df6611f1f565b604052919050565b600067ffffffffffffffff821115611e1857611e18611f1f565b5060051b60200190565b600080821280156001600160ff1b0384900385131615611e4457611e44611f09565b600160ff1b8390038412811615611e5d57611e5d611f09565b50500190565b60008160040b8360040b82821282647fffffffff03821381151615611e8a57611e8a611f09565b82647fffffffff19038212811615611ea457611ea4611f09565b50019392505050565b600081810b83820b82821282607f03821381151615611ece57611ece611f09565b82607f19038212811615611ea457611ea4611f09565b600063ffffffff83811690831681811015611f0157611f01611f09565b039392505050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114611f4a57600080fd5b5056fea264697066735822122027163c9c7a018e3f491b10f71ff4861efc506503e9f39bd3fc08dc44e99cd34c64736f6c63430008040033`)

	fileCreate, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey.PublicKey()).
		Execute(env.Client)
	if err != nil {
		return nil, err
	}
	fileCreate.SetValidateStatus(true)
	receipt, err := fileCreate.GetReceipt(env.Client)
	if err != nil {
		return nil, err
	}
	fileAppend, err := NewFileAppendTransaction().SetFileID(*receipt.FileID).SetContents(bytecode).Execute(env.Client)
	if err != nil {
		return nil, err
	}
	fileAppend.SetValidateStatus(true)
	_, err = fileAppend.GetReceipt(env.Client)
	if err != nil {
		return nil, err
	}
	contractCreate, err := NewContractCreateTransaction().
		SetBytecodeFileID(*receipt.FileID).
		SetGas(500000).Execute(env.Client)
	if err != nil {
		return nil, err
	}
	contractCreate.SetValidateStatus(true)
	contractReceipt, err := contractCreate.GetReceipt(env.Client)
	if err != nil {
		return nil, err
	}
	return contractReceipt.ContractID, nil
}

func TestUint8Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint8(0)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint8", NewContractFunctionParameters().AddUint8(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint8(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint8Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint8(255)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint8", NewContractFunctionParameters().AddUint8(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint8(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestUint16Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint16(0)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint16", NewContractFunctionParameters().AddUint16(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint16(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint16Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint16(65535)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint16", NewContractFunctionParameters().AddUint16(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint16(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestUint24Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint32(0)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint24", NewContractFunctionParameters().AddUint24(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint24(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint24Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint32(16777215)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint24", NewContractFunctionParameters().AddUint24(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint24(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint32Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint32(0)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint32", NewContractFunctionParameters().AddUint32(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint32(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint32Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint32(4294967295)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint32", NewContractFunctionParameters().AddUint32(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint32(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestUint40Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint64(0)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint40", NewContractFunctionParameters().AddUint40(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint40(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint40Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint64(109951162777)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint40", NewContractFunctionParameters().AddUint40(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint40(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestUint48Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint64(0)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint48", NewContractFunctionParameters().AddUint48(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint48(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint48Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint64(281474976710655)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint48", NewContractFunctionParameters().AddUint48(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint48(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestUint56Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint64(0)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint56", NewContractFunctionParameters().AddUint56(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint56(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint56Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint64(72057594037927935)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint56", NewContractFunctionParameters().AddUint56(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint56(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestUint64Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint64(0)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint64", NewContractFunctionParameters().AddUint64(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint64(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint64Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint64(9223372036854775807)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint64", NewContractFunctionParameters().AddUint64(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint64(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestUint72Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint72", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint72Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint72", "4722366482869645213695")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestUint80Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint80", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint80Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint80", "1208925819614629174706175")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint88Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint88", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint88Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint88", "309485009821345068724781055")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint96Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint96", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint96Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint96", "79228162514264337593543950335")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint104Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint104", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint104Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint104", "20282409603651670423947251286015")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestUint112Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint112", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint112Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint112", "5192296858534827628530496329220095")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint120Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint120", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint120Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint120", "1329227995784915872903807060280344575")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint128Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint128", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint128Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint128", "340282366920938463463374607431768211455")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint136Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint136", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint136Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint136", "87112285931760246646623899502532662132735")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint144Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint144", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint144Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint144", "22300745198530623141535718272648361505980415")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint152Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint152", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint152Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint152", "5708990770823839524233143877797980545530986495")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint160Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint160", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint160Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint160", "1461501637330902918203684832716283019655932542975")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint168Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint168", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint168Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint168", "374144419156711147060143317175368453031918731001855")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint176Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint176", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint176Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint176", "95780971304118053647396689196894323976171195136475135")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint184Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint184", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint184Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint184", "24519928653854221733733552434404946937899825954937634815")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint192Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint192", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint192Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint192", "6277101735386680763835789423207666416102355444464034512895")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint200Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint200", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint200Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint200", "1606938044258990275541962092341162602522202993782792835301375")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint208Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint208", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint208Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint208", "411376139330301510538742295639337626245683966408394965837152255")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint216Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint216", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint216Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint216", "105312291668557186697918027683670432318895095400549111254310977535")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint224Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint224", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint224Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint224", "26959946667150639794667015087019630673637144422540572481103610249215")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint232Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint232", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint232Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint232", "6901746346790563787434755862277025452451108972170386555162524223799295")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint240Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint240", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint240Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint240", "1766847064778384329583297500742918515827483896875618958121606201292619775")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint248Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint248", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint248Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint248", "452312848583266388373324160190187140051835877600158453279131187530910662655")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint256Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint256", "0")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestUint256Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "uint256", "115792089237316195423570985008687907853269984665640564039457584007913129639935")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt8Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int8(-128)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt8", NewContractFunctionParameters().AddInt8(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt8(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestInt8Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int8(127)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt8", NewContractFunctionParameters().AddInt8(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt8(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt16Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int16(-32768)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt16", NewContractFunctionParameters().AddInt16(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt16(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestInt16Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int16(32767)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt16", NewContractFunctionParameters().AddInt16(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt16(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt24Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int32(-8388608)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt24", NewContractFunctionParameters().AddInt24(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt24(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestInt24Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int32(8388607)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt24", NewContractFunctionParameters().AddInt24(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt24(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestInt32Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int32(-2147483648)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt32", NewContractFunctionParameters().AddInt32(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt32(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestInt32Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int32(2147483647)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt32", NewContractFunctionParameters().AddInt32(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt32(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt40Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int64(-549755813888)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt40", NewContractFunctionParameters().AddInt40(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, int64(value), contractCal.GetInt40(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestInt40Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int64(549755813887)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt40", NewContractFunctionParameters().AddInt40(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, int64(value), contractCal.GetInt40(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt48Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int64(-140737488355328)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt48", NewContractFunctionParameters().AddInt48(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, int64(value), contractCal.GetInt48(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestInt48Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int64(140737488355327)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt48", NewContractFunctionParameters().AddInt48(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, int64(value), contractCal.GetInt48(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt56Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int64(-36028797018963968)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt56", NewContractFunctionParameters().AddInt56(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt56(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestInt56Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int64(36028797018963967)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt56", NewContractFunctionParameters().AddInt56(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt56(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt64Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int64(-9223372036854775808)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt64", NewContractFunctionParameters().AddInt64(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt64(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestInt64Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int64(9223372036854775807)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt64", NewContractFunctionParameters().AddInt64(value)).SetMaxQueryPayment(NewHbar(20)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt64(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt72Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int72", "-2361183241434822606848")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt72Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int72", "2361183241434822606847")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt80Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int80", "-604462909807314587353088")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt80Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int80", "604462909807314587353087")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt88Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int88", "-154742504910672534362390528")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt88Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int88", "154742504910672534362390527")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt96Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int96", "-39614081257132168796771975168")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt96Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int96", "39614081257132168796771975167")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt104Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int104", "-10141204801825835211973625643008")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt104Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int104", "10141204801825835211973625643007")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt112Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int112", "-2596148429267413814265248164610048")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt112Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int112", "2596148429267413814265248164610047")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt120Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int120", "-664613997892457936451903530140172288")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt120Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int120", "664613997892457936451903530140172287")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt128Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int128", "-170141183460469231731687303715884105728")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt128Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int128", "170141183460469231731687303715884105727")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt136Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int136", "-43556142965880123323311949751266331066368")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt136Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int136", "43556142965880123323311949751266331066367")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt144Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int144", "-11150372599265311570767859136324180752990208")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt144Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int144", "11150372599265311570767859136324180752990207")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt152Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int152", "-2854495385411919762116571938898990272765493248")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt152Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int152", "2854495385411919762116571938898990272765493247")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt160Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int160", "-730750818665451459101842416358141509827966271488")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt160Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int160", "730750818665451459101842416358141509827966271487")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt168Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int168", "-187072209578355573530071658587684226515959365500928")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt168Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int168", "187072209578355573530071658587684226515959365500927")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt176Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int176", "-47890485652059026823698344598447161988085597568237568")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt176Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int176", "47890485652059026823698344598447161988085597568237567")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt184Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int184", "-12259964326927110866866776217202473468949912977468817408")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt184Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int184", "12259964326927110866866776217202473468949912977468817407")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt192Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int192", "-3138550867693340381917894711603833208051177722232017256448")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt192Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int192", "3138550867693340381917894711603833208051177722232017256447")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt200Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int200", "-803469022129495137770981046170581301261101496891396417650688")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt200Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int200", "803469022129495137770981046170581301261101496891396417650687")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt208Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int208", "-205688069665150755269371147819668813122841983204197482918576128")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt208Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int208", "205688069665150755269371147819668813122841983204197482918576127")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt216Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int216", "-52656145834278593348959013841835216159447547700274555627155488768")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt216Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int216", "52656145834278593348959013841835216159447547700274555627155488767")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt224Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int224", "-13479973333575319897333507543509815336818572211270286240551805124608")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt224Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int224", "13479973333575319897333507543509815336818572211270286240551805124607")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt232Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int232", "-3450873173395281893717377931138512726225554486085193277581262111899648")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt232Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int232", "3450873173395281893717377931138512726225554486085193277581262111899647")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt240Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int240", "-883423532389192164791648750371459257913741948437809479060803100646309888")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt240Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int240", "883423532389192164791648750371459257913741948437809479060803100646309887")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt248Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int248", "-226156424291633194186662080095093570025917938800079226639565593765455331328")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt248Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int248", "226156424291633194186662080095093570025917938800079226639565593765455331327")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt256Min(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int256", "-57896044618658097711785492504343953926634992332820282019728792003956564819968")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestInt256Max(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	intType(t, env, "int256", "57896044618658097711785492504343953926634992332820282019728792003956564819967")
	err := CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestMultipleInt8(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int8(-128)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt8Multiple", NewContractFunctionParameters().AddInt8(value)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetInt8(0))
	require.Equal(t, int8(-108), contractCal.GetInt8(1))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestMultipleInt40(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := int64(549755813885)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnMultipleInt40", NewContractFunctionParameters().AddInt40(value)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, int64(549755813885), contractCal.GetInt40(0))
	require.Equal(t, int64(549755813886), contractCal.GetInt40(1))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestMultipleInt256(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value, ok := new(big.Int).SetString("-123", 10)
	require.True(t, ok)
	valueTwos := math.U256Bytes(value)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnMultipleInt256", NewContractFunctionParameters().AddInt256(valueTwos)).Execute(env.Client)
	require.NoError(t, err)
	value1, ok := new(big.Int).SetString("-123", 10)
	require.True(t, ok)
	value2, ok := new(big.Int).SetString("-122", 10)
	require.True(t, ok)
	require.Equal(t, math.U256Bytes(value1), contractCal.GetInt256(0))
	require.Equal(t, math.U256Bytes(value2), contractCal.GetInt256(1))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestMultipleTypes(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := uint32(4294967295)
	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnMultipleTypeParams", NewContractFunctionParameters().AddUint32(value)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetUint32(0))
	require.Equal(t, uint64(4294967294), contractCal.GetUint64(1))
	require.Equal(t, "OK", contractCal.GetString(2))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestBigInt256(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value, ok := new(big.Int).SetString("-123", 10)
	require.True(t, ok)

	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnInt256", NewContractFunctionParameters().AddInt256BigInt(value)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetBigInt(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestBigUint256(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value, ok := new(big.Int).SetString("123", 10)
	require.True(t, ok)

	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnUint256", NewContractFunctionParameters().AddUint256BigInt(value)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetBigInt(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestMultiplBigInt256(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value, ok := new(big.Int).SetString("-123", 10)
	require.True(t, ok)

	contractCal, err := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnMultipleInt256", NewContractFunctionParameters().AddInt256BigInt(value)).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, contractCal.GetBigInt(0))
	require.Equal(t, new(big.Int).Add(value, big.NewInt(1)), contractCal.GetBigInt(1))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestString(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := "Test"

	contractCal := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnString", NewContractFunctionParameters().AddString(value))
	result, err := contractCal.Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, result.GetString(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestStringArray(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := []string{"Test1", "Test2"}

	contractCal := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnStringArr", NewContractFunctionParameters().AddStringArray(value))
	result, err := contractCal.Execute(env.Client)
	require.NoError(t, err)
	parsedResult, _ := result.GetResult("string[]")
	strArr := parsedResult.([]interface{})[0].([]string)
	require.Equal(t, value[0], strArr[0])
	require.Equal(t, value[1], strArr[1])
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestAddress(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := "1234567890123456789012345678901234567890"
	params, err := NewContractFunctionParameters().AddAddress(value)
	require.NoError(t, err)
	contractCal := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnAddress", params)
	result, err := contractCal.Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, hex.EncodeToString(result.GetAddress(0)))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestAddressArray(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := []string{"1234567890123456789012345678901234567890", "1234567890123456789012345678901234567891"}
	params, err := NewContractFunctionParameters().AddAddressArray(value)
	require.NoError(t, err)
	contractCal := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnAddressArr", params)
	result, err := contractCal.Execute(env.Client)
	require.NoError(t, err)
	addArr, err := result.GetResult("address[]")
	require.NoError(t, err)
	addresses := addArr.([]interface{})[0].([]common.Address)
	require.Equal(t, value[0], strings.TrimPrefix(addresses[0].String(), "0x"))
	require.Equal(t, value[1], strings.TrimPrefix(addresses[1].String(), "0x"))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestBoolean(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := true

	contractCal := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnBoolean", NewContractFunctionParameters().AddBool(value))
	result, err := contractCal.Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, result.GetBool(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestBytes(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := []byte("Test")

	contractCal := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnBytes", NewContractFunctionParameters().AddBytes(value))
	result, err := contractCal.Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, value, result.GetBytes(0))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestBytesArray(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := [][]byte{[]byte("Test1"), []byte("Test2")}

	contractCal := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnBytesArr", NewContractFunctionParameters().AddBytesArray(value))
	result, err := contractCal.Execute(env.Client)
	require.NoError(t, err)
	bytesArrInterface, err := result.GetResult("bytes[]")
	require.NoError(t, err)
	require.Equal(t, value, bytesArrInterface.([]interface{})[0])

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestBytes32(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)
	value := [32]byte{}
	copy(value[:], []byte("Test"))

	contractCal := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).
		SetContractID(contractID).SetFunction("returnBytes32", NewContractFunctionParameters().AddBytes32(value))
	result, err := contractCal.Execute(env.Client)
	require.NoError(t, err)
	require.True(t, reflect.DeepEqual(value[:], result.GetBytes32(0)))
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestBytes32Array(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	deployContract(env)

	value := [][]byte{
		[]byte("Test1"),
		[]byte("Test2"),
	}
	var expected1 [32]byte
	var expected2 [32]byte
	copy(expected1[len(expected1)-len(value[0]):], value[0])
	copy(expected2[len(expected2)-len(value[1]):], value[1])

	contractCal := NewContractCallQuery().SetGas(15000000).SetQueryPayment(NewHbar(12)).SetQueryPayment(NewHbar(11)).
		SetContractID(contractID).SetFunction("returnBytes32Arr", NewContractFunctionParameters().AddBytes32Array(value))
	result, err := contractCal.Execute(env.Client)
	require.NoError(t, err)
	bytes32ArrInterface, err := result.GetResult("bytes32[]")
	require.NoError(t, err)
	require.Equal(t, expected1, bytes32ArrInterface.([]interface{})[0].([][32]byte)[0])
	require.Equal(t, expected2, bytes32ArrInterface.([]interface{})[0].([][32]byte)[1])
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestContractNonces(t *testing.T) {

	env := NewIntegrationTestEnv(t)
	bytecode := []byte(`6080604052348015600f57600080fd5b50604051601a90603b565b604051809103906000f0801580156035573d6000803e3d6000fd5b50506047565b605c8061009483390190565b603f806100556000396000f3fe6080604052600080fdfea2646970667358221220a20122cbad3457fedcc0600363d6e895f17048f5caa4afdab9e655123737567d64736f6c634300081200336080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122053dfd8835e3dc6fedfb8b4806460b9b7163f8a7248bac510c6d6808d9da9d6d364736f6c63430008120033`)
	fileCreate, err := NewFileCreateTransaction().
		SetKeys(env.OperatorKey.PublicKey()).
		SetContents(bytecode).
		Execute(env.Client)
	require.NoError(t, err)
	fileCreate.SetValidateStatus(true)
	receipt, err := fileCreate.GetReceipt(env.Client)
	require.NoError(t, err)
	require.Equal(t, StatusSuccess, receipt.Status)
	contractCreate, err := NewContractCreateTransaction().
		SetAdminKey(env.OperatorKey).
		SetGas(100000).
		SetBytecodeFileID(*receipt.FileID).
		SetContractMemo("[e2e::ContractADeploysContractBInConstructor]").
		Execute(env.Client)
	require.NoError(t, err)
	contractCreate.SetValidateStatus(true)
	record, err := contractCreate.GetRecord(env.Client)
	require.NoError(t, err)
	require.Equal(t, StatusSuccess, record.Receipt.Status)
	require.Equal(t, int64(2), record.CallResult.ContractNonces[0].Nonce)
	require.Equal(t, int64(1), record.CallResult.ContractNonces[1].Nonce)
}
// Filename: contract_function_result.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/binary"
	"fmt"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

// ContractFunctionResult is a struct which allows users to convert between solidity and Go types, and is typically
// returned by `ContractCallQuery` and is present in the transaction records of `ContractExecuteTransaction`.
// Use the methods `Get<Type>()` to get a parameter. Not all solidity types
// are supported out of the box, but the most common types are. The larger variants
// of number types return just the bytes for the integer instead of converting to a big int type.
// To convert those bytes into a usable integer using "github.com/ethereum/go-ethereum/common/math" and "math/big" do the following:
// ```
// contractFunctionResult.GetUint256(<index>)
// bInt := new(big.Int)
// bInt.SetBytes(query.GetUint256(0))
// ```
type ContractFunctionResult struct {
	// ContractID is the smart contract instance whose function was called
	ContractID *ContractID
	// ContractCallResult is the result returned by the function
	ContractCallResult []byte
	// ErrorMessage is the message returned in the case there was an error during smart contract execution
	ErrorMessage string
	// Bloom is the bloom filter for record
	Bloom []byte
	// GasUsed is the amount of gas used to execute the contract function
	GasUsed uint64
	// LogInfo is the log info for events returned by the function
	LogInfo []ContractLogInfo
	// Deprecated
	CreatedContractIDs []ContractID
	// Deprecated
	ContractStateChanges []ContractStateChange
	EvmAddress           ContractID
	GasAvailable         int64
	Amount               Hbar
	FunctionParameters   []byte
	ContractNonces       []*ContractNonceInfo
	SignerNonce          int64
}

// GetBool gets a _Solidity bool from the result at the given index
func (result ContractFunctionResult) GetBool(index uint64) bool {
	return result.GetUint32(index) == 1
}

// GetAddress gets a _Solidity address from the result at the given index
func (result ContractFunctionResult) GetAddress(index uint64) []byte {
	return result.ContractCallResult[(index*32)+12 : (index*32)+32]
}

// GetInt8 gets a _Solidity int8 from the result at the given index
func (result ContractFunctionResult) GetInt8(index uint64) int8 {
	return int8(result.ContractCallResult[index*32+31])
}

// GetInt16 gets a _Solidity int16 from the result at the given index
func (result ContractFunctionResult) GetInt16(index uint64) int16 {
	return int16(binary.BigEndian.Uint16(result.ContractCallResult[index*32+30 : (index+1)*32]))
}

// GetInt24 gets a _Solidity int24 from the result at the given index
func (result ContractFunctionResult) GetInt24(index uint64) int32 {
	return int32(binary.BigEndian.Uint32(result.ContractCallResult[index*32+28 : (index+1)*32]))
}

// GetInt40 gets a _Solidity int40 from the result at the given index
func (result ContractFunctionResult) GetInt40(index uint64) int64 {
	return int64(binary.BigEndian.Uint64(result.ContractCallResult[index*32+24 : (index+1)*32]))
}

// GetInt48 gets a _Solidity int48 from the result at the given index
func (result ContractFunctionResult) GetInt48(index uint64) int64 {
	return int64(binary.BigEndian.Uint64(result.ContractCallResult[index*32+24 : (index+1)*32]))
}

// GetInt56 gets a _Solidity int56 from the result at the given index
func (result ContractFunctionResult) GetInt56(index uint64) int64 {
	return int64(binary.BigEndian.Uint64(result.ContractCallResult[index*32+24 : (index+1)*32]))
}

// GetInt32 gets a _Solidity int32 from the result at the given index
func (result ContractFunctionResult) GetInt32(index uint64) int32 {
	return int32(binary.BigEndian.Uint32(result.ContractCallResult[index*32+28 : (index+1)*32]))
}

// GetInt64 gets a _Solidity int64 from the result at the given index
func (result ContractFunctionResult) GetInt64(index uint64) int64 {
	return int64(binary.BigEndian.Uint64(result.ContractCallResult[index*32+24 : (index+1)*32]))
}

// GetInt72 gets a _Solidity int72 from the result at the given index
func (result ContractFunctionResult) GetInt72(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt80 gets a _Solidity int80 from the result at the given index
func (result ContractFunctionResult) GetInt80(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt88 gets a _Solidity int88 from the result at the given index
func (result ContractFunctionResult) GetInt88(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt96 gets a _Solidity int96 from the result at the given index
func (result ContractFunctionResult) GetInt96(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt104 gets a _Solidity int104 from the result at the given index
func (result ContractFunctionResult) GetInt104(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt112 gets a _Solidity int112 from the result at the given index
func (result ContractFunctionResult) GetInt112(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt120 gets a _Solidity int120 from the result at the given index
func (result ContractFunctionResult) GetInt120(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt128 gets a _Solidity int128 from the result at the given index
func (result ContractFunctionResult) GetInt128(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt136 gets a _Solidity int136 from the result at the given index
func (result ContractFunctionResult) GetInt136(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt144 gets a _Solidity int144 from the result at the given index
func (result ContractFunctionResult) GetInt144(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt152 gets a _Solidity int152 from the result at the given index
func (result ContractFunctionResult) GetInt152(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt160 gets a _Solidity int160 from the result at the given index
func (result ContractFunctionResult) GetInt160(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt168 gets a _Solidity int168 from the result at the given index
func (result ContractFunctionResult) GetInt168(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt176 gets a _Solidity int176 from the result at the given index
func (result ContractFunctionResult) GetInt176(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt184 gets a _Solidity int184 from the result at the given index
func (result ContractFunctionResult) GetInt184(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt192 gets a _Solidity int192 from the result at the given index
func (result ContractFunctionResult) GetInt192(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt200 gets a _Solidity int200 from the result at the given index
func (result ContractFunctionResult) GetInt200(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt208 gets a _Solidity int208 from the result at the given index
func (result ContractFunctionResult) GetInt208(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt216 gets a _Solidity int216 from the result at the given index
func (result ContractFunctionResult) GetInt216(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt224 gets a _Solidity int224 from the result at the given index
func (result ContractFunctionResult) GetInt224(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt232 gets a _Solidity int232 from the result at the given index
func (result ContractFunctionResult) GetInt232(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt240 gets a _Solidity int240 from the result at the given index
func (result ContractFunctionResult) GetInt240(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt248 gets a _Solidity int248 from the result at the given index
func (result ContractFunctionResult) GetInt248(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetInt256 gets a _Solidity int256 from the result at the given index
func (result ContractFunctionResult) GetInt256(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetBigInt gets an _Solidity integer from the result at the given index and returns it as a big.Int
func (result ContractFunctionResult) GetBigInt(index uint64) *big.Int {
	value := new(big.Int).SetBytes(result.ContractCallResult[index*32 : index*32+32])
	fromTwosComplement := math.S256(value)
	return fromTwosComplement
}

// GetUint8 gets a _Solidity uint8 from the result at the given index
func (result ContractFunctionResult) GetUint8(index uint64) uint8 {
	return result.ContractCallResult[index*32+31]
}

// GetUint16 gets a _Solidity uint16 from the result at the given index
func (result ContractFunctionResult) GetUint16(index uint64) uint16 {
	return binary.BigEndian.Uint16(result.ContractCallResult[index*32+30 : (index+1)*32])
}

// GetUint24 gets a _Solidity uint24 from the result at the given index
func (result ContractFunctionResult) GetUint24(index uint64) uint32 {
	return binary.BigEndian.Uint32(result.ContractCallResult[index*32+28 : (index+1)*32])
}

// GetUint32 gets a _Solidity uint32 from the result at the given index
func (result ContractFunctionResult) GetUint32(index uint64) uint32 {
	return binary.BigEndian.Uint32(result.ContractCallResult[index*32+28 : (index+1)*32])
}

// GetUint40 gets a _Solidity uint40 from the result at the given index
func (result ContractFunctionResult) GetUint40(index uint64) uint64 {
	return binary.BigEndian.Uint64(result.ContractCallResult[index*32+24 : (index+1)*32])
}

// GetUint48 gets a _Solidity uint48 from the result at the given index
func (result ContractFunctionResult) GetUint48(index uint64) uint64 {
	return binary.BigEndian.Uint64(result.ContractCallResult[index*32+24 : (index+1)*32])
}

// GetUint56 gets a _Solidity uint56 from the result at the given index
func (result ContractFunctionResult) GetUint56(index uint64) uint64 {
	return binary.BigEndian.Uint64(result.ContractCallResult[index*32+24 : (index+1)*32])
}

// GetUint64 gets a _Solidity uint64 from the result at the given index
func (result ContractFunctionResult) GetUint64(index uint64) uint64 {
	return binary.BigEndian.Uint64(result.ContractCallResult[index*32+24 : (index+1)*32])
}

// GetUint72 gets a _Solidity uint72 from the result at the given index
func (result ContractFunctionResult) GetUint72(index uint64) []byte {
	return result.ContractCallResult[index*32+23 : (index+1)*32]
}

// GetUint80 gets a _Solidity uint80 from the result at the given index
func (result ContractFunctionResult) GetUint80(index uint64) []byte {
	return result.ContractCallResult[index*32+22 : (index+1)*32]
}

// GetUint88 gets a _Solidity uint88 from the result at the given index
func (result ContractFunctionResult) GetUint88(index uint64) []byte {
	return result.ContractCallResult[index*32+21 : (index+1)*32]
}

// GetUint96 gets a _Solidity uint96 from the result at the given index
func (result ContractFunctionResult) GetUint96(index uint64) []byte {
	return result.ContractCallResult[index*32+20 : (index+1)*32]
}

// GetUint104 gets a _Solidity uint104 from the result at the given index
func (result ContractFunctionResult) GetUint104(index uint64) []byte {
	return result.ContractCallResult[index*32+19 : (index+1)*32]
}

// GetUint112 gets a _Solidity uint112 from the result at the given index
func (result ContractFunctionResult) GetUint112(index uint64) []byte {
	return result.ContractCallResult[index*32+18 : (index+1)*32]
}

// GetUint120 gets a _Solidity uint120 from the result at the given index
func (result ContractFunctionResult) GetUint120(index uint64) []byte {
	return result.ContractCallResult[index*32+17 : (index+1)*32]
}

// GetUint128 gets a _Solidity uint128 from the result at the given index
func (result ContractFunctionResult) GetUint128(index uint64) []byte {
	return result.ContractCallResult[index*32+16 : (index+1)*32]
}

// GetUint136 gets a _Solidity uint136 from the result at the given index
func (result ContractFunctionResult) GetUint136(index uint64) []byte {
	return result.ContractCallResult[index*32+15 : (index+1)*32]
}

// GetUint144 gets a _Solidity uint144 from the result at the given index
func (result ContractFunctionResult) GetUint144(index uint64) []byte {
	return result.ContractCallResult[index*32+14 : (index+1)*32]
}

// GetUint152 gets a _Solidity uint152 from the result at the given index
func (result ContractFunctionResult) GetUint152(index uint64) []byte {
	return result.ContractCallResult[index*32+13 : (index+1)*32]
}

// GetUint160 gets a _Solidity uint160 from the result at the given index
func (result ContractFunctionResult) GetUint160(index uint64) []byte {
	return result.ContractCallResult[index*32+12 : (index+1)*32]
}

// GetUint168 gets a _Solidity uint168 from the result at the given index
func (result ContractFunctionResult) GetUint168(index uint64) []byte {
	return result.ContractCallResult[index*32+11 : (index+1)*32]
}

// GetUint176 gets a _Solidity uint176 from the result at the given index
func (result ContractFunctionResult) GetUint176(index uint64) []byte {
	return result.ContractCallResult[index*32+10 : (index+1)*32]
}

// GetUint184 gets a _Solidity uint184 from the result at the given index
func (result ContractFunctionResult) GetUint184(index uint64) []byte {
	return result.ContractCallResult[index*32+9 : (index+1)*32]
}

// GetUint192 gets a _Solidity uint192 from the result at the given index
func (result ContractFunctionResult) GetUint192(index uint64) []byte {
	return result.ContractCallResult[index*32+8 : (index+1)*32]
}

// GetUint200 gets a _Solidity uint200 from the result at the given index
func (result ContractFunctionResult) GetUint200(index uint64) []byte {
	return result.ContractCallResult[index*32+7 : (index+1)*32]
}

// GetUint208 gets a _Solidity uint208 from the result at the given index
func (result ContractFunctionResult) GetUint208(index uint64) []byte {
	return result.ContractCallResult[index*32+6 : (index+1)*32]
}

// GetUint216 gets a _Solidity uint216 from the result at the given index
func (result ContractFunctionResult) GetUint216(index uint64) []byte {
	return result.ContractCallResult[index*32+5 : (index+1)*32]
}

// GetUint224 gets a _Solidity uint224 from the result at the given index
func (result ContractFunctionResult) GetUint224(index uint64) []byte {
	return result.ContractCallResult[index*32+4 : (index+1)*32]
}

// GetUint232 gets a _Solidity uint232 from the result at the given index
func (result ContractFunctionResult) GetUint232(index uint64) []byte {
	return result.ContractCallResult[index*32+3 : (index+1)*32]
}

// GetUint240 gets a _Solidity uint240 from the result at the given index
func (result ContractFunctionResult) GetUint240(index uint64) []byte {
	return result.ContractCallResult[index*32+2 : (index+1)*32]
}

// GetUint248 gets a _Solidity uint248 from the result at the given index
func (result ContractFunctionResult) GetUint248(index uint64) []byte {
	return result.ContractCallResult[index*32+1 : (index+1)*32]
}

// GetUint256 gets a _Solidity uint256 from the result at the given index
func (result ContractFunctionResult) GetUint256(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetBytes32 gets a _Solidity bytes32 from the result at the given index
func (result ContractFunctionResult) GetBytes32(index uint64) []byte {
	return result.ContractCallResult[index*32 : index*32+32]
}

// GetString gets a string from the result at the given index
func (result ContractFunctionResult) GetString(index uint64) string {
	return string(result.GetBytes(index))
}

// GetBytes gets a byte array from the result at the given index
func (result ContractFunctionResult) GetBytes(index uint64) []byte {
	offset := result.GetUint64(index)
	length := binary.BigEndian.Uint64(result.ContractCallResult[offset+24 : offset+32])
	return result.ContractCallResult[offset+32 : offset+32+length]
}

// AsBytes returns the raw bytes of the ContractCallResult
func (result ContractFunctionResult) AsBytes() []byte {
	return result.ContractCallResult
}

// GetResult parses the result of a contract call based on the given types string and returns the result as an interface.
// The "types" string should specify the Ethereum Solidity type of the contract call output.
// This includes types like "uint256", "address", "bool", "string", "string[]", etc.
// The type provided must match the actual type of the data returned by the contract call,
// otherwise the function will fail to unpack and return an error.
// The method returns the parsed result encapsulated in an interface{},
// allowing flexibility to handle various types of contract call results.
// For correct usage, the caller should perform a type assertion on the returned interface{}
// to convert it into the appropriate go type.
func (result ContractFunctionResult) GetResult(types string) (interface{}, error) {
	def := fmt.Sprintf(`[{ "name" : "method", "type": "function", "outputs": [{ "type": "%s" }]}]`, types)
	abi, err := abi.JSON(strings.NewReader(def))
	if err != nil {
		return nil, err
	}
	parsedResult, err := abi.Unpack("method", result.ContractCallResult)
	if err != nil {
		return nil, err
	}
	return parsedResult, nil
}

func extractInt64OrZero(pb *services.ContractFunctionResult) int64 {
	if pb.GetSignerNonce() != nil {
		return pb.SignerNonce.Value
	}
	return 0
}

func _ContractFunctionResultFromProtobuf(pb *services.ContractFunctionResult) ContractFunctionResult {
	infos := make([]ContractLogInfo, len(pb.LogInfo))

	for i, info := range pb.LogInfo {
		infos[i] = _ContractLogInfoFromProtobuf(info)
	}

	createdContractIDs := make([]ContractID, 0)
	for _, id := range pb.CreatedContractIDs { // nolint
		temp := _ContractIDFromProtobuf(id)
		if temp != nil {
			createdContractIDs = append(createdContractIDs, *temp)
		}
	}

	var evm ContractID
	if len(pb.EvmAddress.GetValue()) > 0 {
		evm = ContractID{
			Shard:      0,
			Realm:      0,
			Contract:   0,
			EvmAddress: pb.EvmAddress.GetValue(),
			checksum:   nil,
		}
	}

	var nonces []*ContractNonceInfo
	if len(pb.ContractNonces) > 0 {
		nonces = make([]*ContractNonceInfo, len(pb.ContractNonces))
		for i, nonce := range pb.ContractNonces {
			nonces[i] = _ContractNonceInfoFromProtobuf(nonce)
		}
	}

	result := ContractFunctionResult{
		ContractCallResult: pb.ContractCallResult,
		ErrorMessage:       pb.ErrorMessage,
		Bloom:              pb.Bloom,
		GasUsed:            pb.GasUsed,
		LogInfo:            infos,
		CreatedContractIDs: createdContractIDs,
		EvmAddress:         evm,
		GasAvailable:       pb.Gas,
		Amount:             HbarFromTinybar(pb.Amount),
		FunctionParameters: pb.FunctionParameters,
		ContractNonces:     nonces,
		SignerNonce:        extractInt64OrZero(pb),
	}

	if pb.ContractID != nil {
		result.ContractID = _ContractIDFromProtobuf(pb.ContractID)
	}

	return result
}

func (result ContractFunctionResult) _ToProtobuf() *services.ContractFunctionResult {
	infos := make([]*services.ContractLoginfo, len(result.LogInfo))

	for i, info := range result.LogInfo {
		infos[i] = info._ToProtobuf()
	}

	return &services.ContractFunctionResult{
		ContractID:         result.ContractID._ToProtobuf(),
		ContractCallResult: result.ContractCallResult,
		ErrorMessage:       result.ErrorMessage,
		Bloom:              result.Bloom,
		GasUsed:            result.GasUsed,
		LogInfo:            infos,
		EvmAddress:         &wrapperspb.BytesValue{Value: result.EvmAddress.EvmAddress},
		Gas:                result.GasAvailable,
		Amount:             result.Amount.AsTinybar(),
		FunctionParameters: result.FunctionParameters,
		SignerNonce:        wrapperspb.Int64(result.SignerNonce),
	}
}

// ToBytes returns the protobuf encoded bytes of the ContractFunctionResult
func (result *ContractFunctionResult) ToBytes() []byte {
	data, err := protobuf.Marshal(result._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// ContractFunctionResultFromBytes returns a ContractFunctionResult from the protobuf encoded bytes of a ContractFunctionResult
func ContractFunctionResultFromBytes(data []byte) (ContractFunctionResult, error) {
	if data == nil {
		return ContractFunctionResult{}, errByteArrayNull
	}
	pb := services.ContractFunctionResult{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return ContractFunctionResult{}, err
	}

	return _ContractFunctionResultFromProtobuf(&pb), nil
}
// Filename: contract_function_selector.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"golang.org/x/crypto/sha3"
)

// A selector for a function with a given name.
type ContractFunctionSelector struct {
	function   *string
	params     string
	paramTypes []_Solidity
}

type _Solidity struct {
	ty    argument
	array bool
}

type argument string

const (
	aBool     argument = "bool"
	aString   argument = "string"
	aInt8     argument = "int8"
	aInt16    argument = "int16"
	aInt24    argument = "int24"
	aInt32    argument = "int32"
	aInt40    argument = "int40"
	aInt48    argument = "int48"
	aInt56    argument = "int56"
	aInt64    argument = "int64"
	aInt72    argument = "int72"
	aInt80    argument = "int80"
	aInt88    argument = "int88"
	aInt96    argument = "int96"
	aInt104   argument = "int104"
	aInt112   argument = "int112"
	aInt120   argument = "int120"
	aInt128   argument = "int128"
	aInt136   argument = "int136"
	aInt144   argument = "int144"
	aInt152   argument = "int152"
	aInt160   argument = "int160"
	aInt168   argument = "int168"
	aInt176   argument = "int176"
	aInt184   argument = "int184"
	aInt192   argument = "int192"
	aInt200   argument = "int200"
	aInt208   argument = "int208"
	aInt216   argument = "int216"
	aInt224   argument = "int224"
	aInt232   argument = "int232"
	aInt240   argument = "int240"
	aInt248   argument = "int248"
	aInt256   argument = "int256"
	aUint8    argument = "uint8"
	aUint16   argument = "uint16"
	aUint24   argument = "uint24"
	aUint32   argument = "uint32"
	aUint40   argument = "uint40"
	aUint48   argument = "uint48"
	aUint56   argument = "uint56"
	aUint64   argument = "uint64"
	aUint72   argument = "uint72"
	aUint80   argument = "uint80"
	aUint88   argument = "uint88"
	aUint96   argument = "uint96"
	aUint104  argument = "uint104"
	aUint112  argument = "uint112"
	aUint120  argument = "uint120"
	aUint128  argument = "uint128"
	aUint136  argument = "uint136"
	aUint144  argument = "uint144"
	aUint152  argument = "uint152"
	aUint160  argument = "uint160"
	aUint168  argument = "uint168"
	aUint176  argument = "uint176"
	aUint184  argument = "uint184"
	aUint192  argument = "uint192"
	aUint200  argument = "uint200"
	aUint208  argument = "uint208"
	aUint216  argument = "uint216"
	aUint224  argument = "uint224"
	aUint232  argument = "uint232"
	aUint240  argument = "uint240"
	aUint248  argument = "uint248"
	aUint256  argument = "uint256"
	aBytes    argument = "bytes"
	aBytes32  argument = "bytes32"
	aFunction argument = "function"
	aAddress  argument = "address"
)

// NewContractFunctionSelector starts building a selector for a function with a given name.
func NewContractFunctionSelector(name string) ContractFunctionSelector {
	var function *string

	if name == "" {
		function = nil
	} else {
		function = &name
	}

	return ContractFunctionSelector{
		function:   function,
		params:     "",
		paramTypes: []_Solidity{},
	}
}

// AddParam adds a parameter to the selector.
func (selector *ContractFunctionSelector) _AddParam(ty _Solidity) *ContractFunctionSelector {
	if len(selector.paramTypes) > 0 {
		selector.params += ","
	}

	selector.params += string(ty.ty)
	if ty.array {
		selector.params += "[]"
	}

	selector.paramTypes = append(selector.paramTypes, ty)
	return selector
}

// AddFunction adds a function parameter to the selector.
func (selector *ContractFunctionSelector) AddFunction() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aFunction,
		array: false,
	})
}

// AddAddress adds an address parameter to the selector.
func (selector *ContractFunctionSelector) AddAddress() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aAddress,
		array: false,
	})
}

// AddBool adds a bool parameter to the selector.
func (selector *ContractFunctionSelector) AddBool() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aBool,
		array: false,
	})
}

// AddString adds a string parameter to the selector.
func (selector *ContractFunctionSelector) AddString() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aString,
		array: false,
	})
}

// AddInt8 adds an int8 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt8() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt8,
		array: false,
	})
}

// AddInt16 adds an int16 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt16() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt16,
		array: false,
	})
}

// AddInt24 adds an int24 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt24() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt24,
		array: false,
	})
}

// AddInt32 adds an int32 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt32() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt32,
		array: false,
	})
}

// AddInt40 adds an int40 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt40() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt40,
		array: false,
	})
}

// AddInt48 adds an int48 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt48() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt48,
		array: false,
	})
}

// AddInt56 adds an int56 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt56() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt56,
		array: false,
	})
}

// AddInt64 adds an int64 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt64() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt64,
		array: false,
	})
}

// AddInt72 adds an int72 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt72() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt72,
		array: false,
	})
}

// AddInt80 adds an int80 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt80() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt80,
		array: false,
	})
}

// AddInt88 adds an int88 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt88() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt88,
		array: false,
	})
}

// AddInt96 adds an int96 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt96() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt96,
		array: false,
	})
}

// AddInt104 adds an int104 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt104() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt104,
		array: false,
	})
}

// AddInt112 adds an int112 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt112() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt112,
		array: false,
	})
}

// AddInt120 adds an int120 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt120() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt120,
		array: false,
	})
}

// AddInt128 adds an int128 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt128() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt128,
		array: false,
	})
}

// AddInt136 adds an int136 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt136() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt136,
		array: false,
	})
}

// AddInt144 adds an int144 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt144() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt144,
		array: false,
	})
}

// AddInt152 adds an int152 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt152() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt152,
		array: false,
	})
}

// AddInt160 adds an int160 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt160() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt160,
		array: false,
	})
}

// AddInt168 adds an int168 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt168() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt168,
		array: false,
	})
}

// AddInt176 adds an int176 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt176() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt176,
		array: false,
	})
}

// AddInt184 adds an int184 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt184() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt184,
		array: false,
	})
}

// AddInt192 adds an int192 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt192() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt192,
		array: false,
	})
}

// AddInt200 adds an int200 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt200() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt200,
		array: false,
	})
}

// AddInt208 adds an int208 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt208() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt208,
		array: false,
	})
}

// AddInt216 adds an int216 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt216() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt216,
		array: false,
	})
}

// AddInt224 adds an int224 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt224() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt224,
		array: false,
	})
}

// AddInt232 adds an int232 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt232() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt232,
		array: false,
	})
}

// AddInt240 adds an int240 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt240() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt240,
		array: false,
	})
}

// AddInt248 adds an int248 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt248() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt248,
		array: false,
	})
}

// AddInt256 adds an int256 parameter to the selector.
func (selector *ContractFunctionSelector) AddInt256() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt256,
		array: false,
	})
}

// AddUint8 adds a uint8 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint8() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint8,
		array: false,
	})
}

// AddUint16 adds a uint16 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint16() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint16,
		array: false,
	})
}

// AddUint24 adds a uint24 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint24() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint24,
		array: false,
	})
}

// AddUint32 adds a uint32 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint32() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint32,
		array: false,
	})
}

// AddUint40 adds a uint40 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint40() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint40,
		array: false,
	})
}

// AddUint48 adds a uint48 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint48() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint48,
		array: false,
	})
}

// AddUint56 adds a uint56 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint56() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint56,
		array: false,
	})
}

// AddUint64 adds a uint64 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint64() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint64,
		array: false,
	})
}

// AddUint72 adds a uint72 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint72() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint72,
		array: false,
	})
}

// AddUint80 adds a uint80 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint80() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint80,
		array: false,
	})
}

// AddUint88 adds a uint88 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint88() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint88,
		array: false,
	})
}

// AddUint96 adds a uint96 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint96() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint96,
		array: false,
	})
}

// AddUint104 adds a uint104 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint104() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint104,
		array: false,
	})
}

// AddUint112 adds a uint112 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint112() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint112,
		array: false,
	})
}

// AddUint120 adds a uint120 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint120() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint120,
		array: false,
	})
}

// AddUint128 adds a uint128 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint128() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint128,
		array: false,
	})
}

// AddUint136 adds a uint136 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint136() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint136,
		array: false,
	})
}

// AddUint144 adds a uint144 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint144() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint144,
		array: false,
	})
}

// AddUint152 adds a uint152 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint152() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint152,
		array: false,
	})
}

// AddUint160 adds a uint160 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint160() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint160,
		array: false,
	})
}

// AddUint168 adds a uint168 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint168() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint168,
		array: false,
	})
}

// AddUint176 adds a uint176 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint176() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint176,
		array: false,
	})
}

// AddUint184 adds a uint184 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint184() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint184,
		array: false,
	})
}

// AddUint192 adds a uint192 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint192() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint192,
		array: false,
	})
}

// AddUint200 adds a uint200 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint200() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint200,
		array: false,
	})
}

// AddUint208 adds a uint208 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint208() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint208,
		array: false,
	})
}

// AddUint216 adds a uint216 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint216() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint216,
		array: false,
	})
}

// AddUint224 adds a uint224 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint224() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint224,
		array: false,
	})
}

// AddUint232 adds a uint232 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint232() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint232,
		array: false,
	})
}

// AddUint240 adds a uint240 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint240() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint240,
		array: false,
	})
}

// AddUint248 adds a uint248 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint248() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint248,
		array: false,
	})
}

// AddUint256 adds a uint256 parameter to the selector.
func (selector *ContractFunctionSelector) AddUint256() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint256,
		array: false,
	})
}

// AddBytes adds a bytes parameter to the selector.
func (selector *ContractFunctionSelector) AddBytes() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aBytes,
		array: false,
	})
}

// AddBytes32 adds a bytes32 parameter to the selector.
func (selector *ContractFunctionSelector) AddBytes32() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aBytes32,
		array: false,
	})
}

// AddAddressArray adds an address[] parameter to the selector.
func (selector *ContractFunctionSelector) AddAddressArray() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aAddress,
		array: true,
	})
}

// AddBoolArray adds a bool[] parameter to the selector.
func (selector *ContractFunctionSelector) AddBoolArray() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aBool,
		array: true,
	})
}

// AddStringArray adds a string[] parameter to the selector.
func (selector *ContractFunctionSelector) AddStringArray() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aString,
		array: true,
	})
}

// AddInt8Array adds an int8[] parameter to the selector.
func (selector *ContractFunctionSelector) AddInt8Array() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt8,
		array: true,
	})
}

// AddInt32Array adds an int32[] parameter to the selector.
func (selector *ContractFunctionSelector) AddInt32Array() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt32,
		array: true,
	})
}

// AddInt64Array adds an int64[] parameter to the selector.
func (selector *ContractFunctionSelector) AddInt64Array() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt64,
		array: true,
	})
}

// AddInt256Array adds an int256[] parameter to the selector.
func (selector *ContractFunctionSelector) AddInt256Array() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aInt256,
		array: true,
	})
}

// AddUint8Array adds a uint8[] parameter to the selector.
func (selector *ContractFunctionSelector) AddUint8Array() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint8,
		array: true,
	})
}

// AddUint32Array adds a uint32[] parameter to the selector.
func (selector *ContractFunctionSelector) AddUint32Array() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint32,
		array: true,
	})
}

// AddUint64Array adds a uint64[] parameter to the selector.
func (selector *ContractFunctionSelector) AddUint64Array() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint64,
		array: true,
	})
}

// AddUint256Array adds a uint256[] parameter to the selector.
func (selector *ContractFunctionSelector) AddUint256Array() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aUint256,
		array: true,
	})
}

// AddBytesArray adds a bytes[] parameter to the selector.
func (selector *ContractFunctionSelector) AddBytesArray() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aBytes,
		array: true,
	})
}

// AddBytes32Array adds a bytes32[] parameter to the selector.
func (selector *ContractFunctionSelector) AddBytes32Array() *ContractFunctionSelector {
	return selector._AddParam(_Solidity{
		ty:    aBytes32,
		array: true,
	})
}

// String returns the string representation of the selector.
func (selector *ContractFunctionSelector) String() string {
	function := ""
	if selector.function != nil {
		function = *selector.function
	}

	return function + "(" + selector.params + ")"
}

func (selector *ContractFunctionSelector) _Build(function *string) []byte {
	if function != nil {
		selector.function = function
	} else if selector.function == nil {
		panic("unreachable: function name must be non-nil at this point")
	}

	hash := sha3.NewLegacyKeccak256()
	if _, err := hash.Write([]byte(selector.String())); err != nil {
		panic(err)
	}

	return hash.Sum(nil)[0:4]
}
// Filename: contract_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
	protobuf "google.golang.org/protobuf/proto"
)

// ContractID is the ID for a Hedera smart contract
type ContractID struct {
	Shard      uint64
	Realm      uint64
	Contract   uint64
	EvmAddress []byte
	checksum   *string
}

// ContractIDFromString constructs a ContractID from a string formatted as `Shard.Realm.Contract` (for example "0.0.3")
func ContractIDFromString(data string) (ContractID, error) {
	shard, realm, num, checksum, evm, err := _ContractIDFromString(data)
	if err != nil {
		return ContractID{}, err
	}

	if num == -1 {
		return ContractID{
			Shard:      uint64(shard),
			Realm:      uint64(realm),
			Contract:   0,
			EvmAddress: evm,
			checksum:   checksum,
		}, nil
	}

	return ContractID{
		Shard:      uint64(shard),
		Realm:      uint64(realm),
		Contract:   uint64(num),
		EvmAddress: nil,
		checksum:   checksum,
	}, nil
}

// Verify that the client has a valid checksum.
func (id *ContractID) ValidateChecksum(client *Client) error {
	if !id._IsZero() && client != nil {
		var tempChecksum _ParseAddressResult
		var err error
		if client.network.ledgerID != nil {
			tempChecksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Contract))
		}
		if err != nil {
			return err
		}
		err = _ChecksumVerify(tempChecksum.status)
		if err != nil {
			return err
		}
		if id.checksum == nil {
			return errChecksumMissing
		}
		if tempChecksum.correctChecksum != *id.checksum {
			networkName := NetworkNameOther
			if client.network.ledgerID != nil {
				networkName, _ = client.network.ledgerID.ToNetworkName()
			}
			return errors.New(fmt.Sprintf("network mismatch or wrong checksum given, given checksum: %s, correct checksum %s, network: %s",
				*id.checksum,
				tempChecksum.correctChecksum,
				networkName))
		}
	}

	return nil
}

// Deprecated - use ValidateChecksum instead
func (id *ContractID) Validate(client *Client) error {
	return id.ValidateChecksum(client)
}

// ContractIDFromEvmAddress constructs a ContractID from a string representation of an EVM address
func ContractIDFromEvmAddress(shard uint64, realm uint64, evmAddress string) (ContractID, error) {
	temp, err := hex.DecodeString(evmAddress)
	if err != nil {
		return ContractID{}, err
	}
	return ContractID{
		Shard:      shard,
		Realm:      realm,
		Contract:   0,
		EvmAddress: temp,
		checksum:   nil,
	}, nil
}

// ContractIDFromSolidityAddress constructs a ContractID from a string representation of a _Solidity address
// Does not populate ContractID.EvmAddress
// Deprecated
func ContractIDFromSolidityAddress(s string) (ContractID, error) {
	shard, realm, contract, err := _IdFromSolidityAddress(s)
	if err != nil {
		return ContractID{}, err
	}

	return ContractID{
		Shard:    shard,
		Realm:    realm,
		Contract: contract,
	}, nil
}

// String returns the string representation of a ContractID formatted as `Shard.Realm.Contract` (for example "0.0.3")
func (id ContractID) String() string {
	if len(id.EvmAddress) > 0 {
		temp := hex.EncodeToString(id.EvmAddress)
		return fmt.Sprintf("%d.%d.%s", id.Shard, id.Realm, temp)
	}
	return fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Contract)
}

// ToStringWithChecksum returns the string representation of a ContractID formatted as `Shard.Realm.Contract-Checksum`
func (id ContractID) ToStringWithChecksum(client Client) (string, error) {
	if id.EvmAddress != nil {
		return "", errors.New("EvmAddress doesn't support checksums")
	}
	if client.GetNetworkName() == nil && client.GetLedgerID() == nil {
		return "", errNetworkNameMissing
	}
	var checksum _ParseAddressResult
	var err error
	if client.network.ledgerID != nil {
		checksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Contract))
	}
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%d.%d.%d-%s", id.Shard, id.Realm, id.Contract, checksum.correctChecksum), nil
}

// ToSolidityAddress returns the string representation of the ContractID as a _Solidity address.
func (id ContractID) ToSolidityAddress() string {
	return _IdToSolidityAddress(id.Shard, id.Realm, id.Contract)
}

// PopulateContract gets the actual `Contract` field of the `ContractId` from the Mirror Node.
// Should be used after generating `ContractId.FromEvmAddress()` because it sets the `Contract` field to `0`
// automatically since there is no connection between the `Contract` and the `evmAddress`
func (id *ContractID) PopulateContract(client *Client) error {
	if client.mirrorNetwork == nil || len(client.GetMirrorNetwork()) == 0 {
		return errors.New("mirror node is not set")
	}
	mirrorUrl := client.GetMirrorNetwork()[0]
	index := strings.Index(mirrorUrl, ":")
	if index == -1 {
		return errors.New("invalid mirrorUrl format")
	}
	mirrorUrl = mirrorUrl[:index]
	url := fmt.Sprintf("https://%s/api/v1/contracts/%s", mirrorUrl, hex.EncodeToString(id.EvmAddress))
	if client.GetLedgerID().String() == "" {
		url = fmt.Sprintf("http://%s:5551/api/v1/contracts/%s", mirrorUrl, hex.EncodeToString(id.EvmAddress))
	}

	resp, err := http.Get(url) // #nosec
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return err
	}

	mirrorContractId, ok := result["contract_id"].(string)
	if !ok {
		return errors.New("unexpected response format")
	}

	numStr := mirrorContractId[strings.LastIndex(mirrorContractId, ".")+1:]
	num, err := strconv.ParseInt(numStr, 10, 64)
	if err != nil {
		return err
	}
	id.Contract = uint64(num)
	return nil
}

func (id ContractID) _ToProtobuf() *services.ContractID {
	resultID := services.ContractID{
		ShardNum: int64(id.Shard),
		RealmNum: int64(id.Realm),
	}

	if id.EvmAddress != nil {
		resultID.Contract = &services.ContractID_EvmAddress{EvmAddress: id.EvmAddress}
		return &resultID
	}

	resultID.Contract = &services.ContractID_ContractNum{ContractNum: int64(id.Contract)}

	return &resultID
}

func _ContractIDFromProtobuf(contractID *services.ContractID) *ContractID {
	if contractID == nil {
		return nil
	}
	resultID := ContractID{
		Shard: uint64(contractID.ShardNum),
		Realm: uint64(contractID.RealmNum),
	}

	switch id := contractID.Contract.(type) {
	case *services.ContractID_ContractNum:
		resultID.Contract = uint64(id.ContractNum)
		resultID.EvmAddress = nil
		return &resultID
	case *services.ContractID_EvmAddress:
		resultID.EvmAddress = id.EvmAddress
		resultID.Contract = 0
		return &resultID
	default:
		return &resultID
	}
}

func (id ContractID) _IsZero() bool {
	return id.Shard == 0 && id.Realm == 0 && id.Contract == 0
}

func (id ContractID) _ToProtoKey() *services.Key {
	return &services.Key{Key: &services.Key_ContractID{ContractID: id._ToProtobuf()}}
}

// ToBytes returns a byte array representation of the ContractID
func (id ContractID) ToBytes() []byte {
	data, err := protobuf.Marshal(id._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// ContractIDFromBytes returns a ContractID generated from a byte array
func ContractIDFromBytes(data []byte) (ContractID, error) {
	pb := services.ContractID{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return ContractID{}, err
	}

	return *_ContractIDFromProtobuf(&pb), nil
}
// Filename: contract_id_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestIntegrationContractIDCanPopulateAccountNumber(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	resp, err := NewFileCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetContents(testContractByteCode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	require.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractInfoQuery_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	require.NotNil(t, receipt.ContractID)

	contractID := *receipt.ContractID
	info, err := NewContractInfoQuery().SetContractID(contractID).Execute(env.Client)
	require.NoError(t, err)
	idMirror, err := ContractIDFromEvmAddress(0, 0, info.ContractAccountID)
	require.NoError(t, err)
	time.Sleep(5 * time.Second)
	err = idMirror.PopulateContract(env.Client)
	require.NoError(t, err)
	require.Equal(t, contractID.Contract, idMirror.Contract)
}
// Filename: contract_id_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"fmt"
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnitContractIDChecksumFromString(t *testing.T) {
	t.Parallel()

	id, err := ContractIDFromString("0.0.123-rmkyk")
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	sol := id.ToSolidityAddress()
	ContractIDFromSolidityAddress(sol)
	err = id.Validate(client)
	require.Error(t, err)
	evmID, err := ContractIDFromEvmAddress(0, 0, "ace082947b949651c703ff0f02bc1541")
	require.NoError(t, err)
	pb := evmID._ToProtobuf()
	_ContractIDFromProtobuf(pb)

	idByte := id.ToBytes()
	ContractIDFromBytes(idByte)

	id._ToProtoKey()

	assert.Equal(t, id.Contract, uint64(123))
}

func TestUnitContractIDChecksumToString(t *testing.T) {
	t.Parallel()

	id := AccountID{
		Shard:   50,
		Realm:   150,
		Account: 520,
	}
	assert.Equal(t, "50.150.520", id.String())
}

func TestUnitContractIDFromStringEVM(t *testing.T) {
	t.Parallel()

	id, err := ContractIDFromString("0.0.0011223344556677889900112233445577889900")
	require.NoError(t, err)

	require.Equal(t, "0.0.0011223344556677889900112233445577889900", id.String())
}

func TestUnitContractIDProtobuf(t *testing.T) {
	t.Parallel()

	id, err := ContractIDFromString("0.0.0011223344556677889900112233445577889900")
	require.NoError(t, err)

	pb := id._ToProtobuf()

	decoded, err := hex.DecodeString("0011223344556677889900112233445577889900")
	require.NoError(t, err)

	require.Equal(t, pb, &services.ContractID{
		ShardNum: 0,
		RealmNum: 0,
		Contract: &services.ContractID_EvmAddress{EvmAddress: decoded},
	})

	pbFrom := _ContractIDFromProtobuf(pb)

	require.Equal(t, id, *pbFrom)
}

func TestUnitContractIDEvm(t *testing.T) {
	t.Parallel()

	hexString, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	id, err := ContractIDFromString(fmt.Sprintf("0.0.%s", hexString.PublicKey().String()))
	require.NoError(t, err)
	require.Equal(t, hex.EncodeToString(id.EvmAddress), hexString.PublicKey().String())

	pb := id._ToProtobuf()
	require.Equal(t, pb, &services.ContractID{
		ShardNum: 0,
		RealmNum: 0,
		Contract: &services.ContractID_EvmAddress{EvmAddress: id.EvmAddress},
	})

	id, err = ContractIDFromString("0.0.123")
	require.NoError(t, err)
	require.Equal(t, id.Contract, uint64(123))
	require.Nil(t, id.EvmAddress)

	pb = id._ToProtobuf()
	require.Equal(t, pb, &services.ContractID{
		ShardNum: 0,
		RealmNum: 0,
		Contract: &services.ContractID_ContractNum{ContractNum: 123},
	})
}

func TestUnitContractIDPopulateFailForWrongMirrorHost(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.SetLedgerID(*NewLedgerIDTestnet())
	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := privateKey.PublicKey()
	evmAddress := publicKey.ToEvmAddress()
	evmAddressAccountID, err := ContractIDFromEvmAddress(0, 0, evmAddress)
	require.NoError(t, err)
	err = evmAddressAccountID.PopulateContract(client)
	require.Error(t, err)
}

func TestUnitContractIDPopulateFailWithNoMirror(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.mirrorNetwork = nil
	client.SetLedgerID(*NewLedgerIDTestnet())
	privateKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := privateKey.PublicKey()
	evmAddress := publicKey.ToEvmAddress()
	evmAddressAccountID, err := ContractIDFromEvmAddress(0, 0, evmAddress)
	require.NoError(t, err)
	err = evmAddressAccountID.PopulateContract(client)
	require.Error(t, err)
}
// Filename: contract_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// Current information on the smart contract instance, including its balance.
type ContractInfo struct {
	AccountID                     AccountID
	ContractID                    ContractID
	ContractAccountID             string
	AdminKey                      Key
	ExpirationTime                time.Time
	AutoRenewPeriod               time.Duration
	Storage                       uint64
	ContractMemo                  string
	Balance                       uint64
	TokenRelationships            []*TokenRelationship
	LedgerID                      LedgerID
	AutoRenewAccountID            *AccountID
	MaxAutomaticTokenAssociations int32
	StakingInfo                   *StakingInfo
}

func _ContractInfoFromProtobuf(contractInfo *services.ContractGetInfoResponse_ContractInfo) (ContractInfo, error) {
	if contractInfo == nil {
		return ContractInfo{}, errParameterNull
	}

	var adminKey Key
	var err error
	if contractInfo.GetAdminKey() != nil {
		adminKey, err = _KeyFromProtobuf(contractInfo.GetAdminKey())
		if err != nil {
			return ContractInfo{}, err
		}
	}

	accountID := AccountID{}
	if contractInfo.AccountID != nil {
		accountID = *_AccountIDFromProtobuf(contractInfo.AccountID)
	}

	contractID := ContractID{}
	if contractInfo.ContractID != nil {
		contractID = *_ContractIDFromProtobuf(contractInfo.ContractID)
	}

	var autoRenewAccountID *AccountID
	if contractInfo.AutoRenewAccountId != nil {
		autoRenewAccountID = _AccountIDFromProtobuf(contractInfo.AutoRenewAccountId)
	}

	var stakingInfo StakingInfo
	if contractInfo.StakingInfo != nil {
		stakingInfo = _StakingInfoFromProtobuf(contractInfo.StakingInfo)
	}

	var tokenRelationships []*TokenRelationship
	if contractInfo.TokenRelationships != nil { // nolint
		tokenRelationships = _TokenRelationshipsFromProtobuf(contractInfo.TokenRelationships) // nolint
	}

	return ContractInfo{
		AccountID:                     accountID,
		ContractID:                    contractID,
		ContractAccountID:             contractInfo.ContractAccountID,
		AdminKey:                      adminKey,
		ExpirationTime:                _TimeFromProtobuf(contractInfo.ExpirationTime),
		AutoRenewPeriod:               _DurationFromProtobuf(contractInfo.AutoRenewPeriod),
		Storage:                       uint64(contractInfo.Storage),
		ContractMemo:                  contractInfo.Memo,
		Balance:                       contractInfo.Balance,
		LedgerID:                      LedgerID{contractInfo.LedgerId},
		AutoRenewAccountID:            autoRenewAccountID,
		MaxAutomaticTokenAssociations: contractInfo.MaxAutomaticTokenAssociations,
		StakingInfo:                   &stakingInfo,
		TokenRelationships:            tokenRelationships,
	}, nil
}

func (contractInfo *ContractInfo) _ToProtobuf() *services.ContractGetInfoResponse_ContractInfo {
	body := &services.ContractGetInfoResponse_ContractInfo{
		ContractID:        contractInfo.ContractID._ToProtobuf(),
		AccountID:         contractInfo.AccountID._ToProtobuf(),
		ContractAccountID: contractInfo.ContractAccountID,
		AdminKey:          contractInfo.AdminKey._ToProtoKey(),
		ExpirationTime:    _TimeToProtobuf(contractInfo.ExpirationTime),
		AutoRenewPeriod:   _DurationToProtobuf(contractInfo.AutoRenewPeriod),
		Storage:           int64(contractInfo.Storage),
		Memo:              contractInfo.ContractMemo,
		Balance:           contractInfo.Balance,
		LedgerId:          contractInfo.LedgerID.ToBytes(),
	}

	if contractInfo.AutoRenewAccountID != nil {
		body.AutoRenewAccountId = contractInfo.AutoRenewAccountID._ToProtobuf()
	}

	if contractInfo.StakingInfo != nil {
		body.StakingInfo = contractInfo.StakingInfo._ToProtobuf()
	}

	return body
}

// ToBytes returns a serialized version of the ContractInfo object
func (contractInfo ContractInfo) ToBytes() []byte {
	data, err := protobuf.Marshal(contractInfo._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// ContractInfoFromBytes returns a ContractInfo object deserialized from bytes
func ContractInfoFromBytes(data []byte) (ContractInfo, error) {
	if data == nil {
		return ContractInfo{}, errByteArrayNull
	}
	pb := services.ContractGetInfoResponse_ContractInfo{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return ContractInfo{}, err
	}

	info, err := _ContractInfoFromProtobuf(&pb)
	if err != nil {
		return ContractInfo{}, err
	}

	return info, nil
}
// Filename: contract_info_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ContractInfoQuery retrieves information about a smart contract instance. This includes the account that it uses, the
// file containing its bytecode, and the time when it will expire.
type ContractInfoQuery struct {
	Query
	contractID *ContractID
}

// NewContractInfoQuery creates a ContractInfoQuery query which can be used to construct and execute a
// Contract Get Info Query.
func NewContractInfoQuery() *ContractInfoQuery {
	header := services.QueryHeader{}
	query := _NewQuery(true, &header)

	return &ContractInfoQuery{
		Query: query,
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *ContractInfoQuery) SetGrpcDeadline(deadline *time.Duration) *ContractInfoQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetContractID sets the contract for which information is requested
func (q *ContractInfoQuery) SetContractID(contractID ContractID) *ContractInfoQuery {
	q.contractID = &contractID
	return q
}

func (q *ContractInfoQuery) GetContractID() ContractID {
	if q.contractID == nil {
		return ContractID{}
	}

	return *q.contractID
}

func (q *ContractInfoQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *ContractInfoQuery) Execute(client *Client) (ContractInfo, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return ContractInfo{}, err
	}

	info, err := _ContractInfoFromProtobuf(resp.GetContractGetInfo().ContractInfo)
	if err != nil {
		return ContractInfo{}, err
	}

	return info, nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *ContractInfoQuery) SetMaxQueryPayment(maxPayment Hbar) *ContractInfoQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *ContractInfoQuery) SetQueryPayment(paymentAmount Hbar) *ContractInfoQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this ContractInfoQuery.
func (q *ContractInfoQuery) SetNodeAccountIDs(accountID []AccountID) *ContractInfoQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *ContractInfoQuery) SetMaxRetry(count int) *ContractInfoQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *ContractInfoQuery) SetMaxBackoff(max time.Duration) *ContractInfoQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *ContractInfoQuery) SetMinBackoff(min time.Duration) *ContractInfoQuery {
	q.Query.SetMinBackoff(min)
	return q
}

func (q *ContractInfoQuery) SetPaymentTransactionID(transactionID TransactionID) *ContractInfoQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *ContractInfoQuery) SetLogLevel(level LogLevel) *ContractInfoQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *ContractInfoQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetContract().GetContractInfo,
	}
}

func (q *ContractInfoQuery) getName() string {
	return "ContractInfoQuery"
}

func (q *ContractInfoQuery) buildQuery() *services.Query {
	pb := services.Query_ContractGetInfo{
		ContractGetInfo: &services.ContractGetInfoQuery{
			Header: q.pbHeader,
		},
	}

	if q.contractID != nil {
		pb.ContractGetInfo.ContractID = q.contractID._ToProtobuf()
	}

	return &services.Query{
		Query: &pb,
	}
}

func (q *ContractInfoQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.contractID != nil {
		if err := q.contractID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *ContractInfoQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetContractGetInfo()
}
// Filename: contract_info_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationContractInfoQueryCanExecute(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetContents(testContractByteCode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractInfoQuery_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	info, err := NewContractInfoQuery().
		SetContractID(contractID).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, contractID, info.ContractID)
	assert.Equal(t, env.Client.GetOperatorPublicKey(), info.AdminKey)
	assert.Equal(t, "hedera-sdk-go::TestContractInfoQuery_Execute", info.ContractMemo)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractInfoQueryGetCost(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractInfoQuery_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	contractInfo := NewContractInfoQuery().
		SetContractID(contractID).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := contractInfo.GetCost(env.Client)
	require.NoError(t, err)

	info, err := contractInfo.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, contractID, info.ContractID)
	assert.Equal(t, env.Client.GetOperatorPublicKey(), info.AdminKey)
	assert.Equal(t, "hedera-sdk-go::TestContractInfoQuery_Execute", info.ContractMemo)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractInfoQuerySetBigMaxPayment(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractInfoQuery_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	contractInfo := NewContractInfoQuery().
		SetContractID(contractID).
		SetMaxQueryPayment(NewHbar(100000)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := contractInfo.GetCost(env.Client)
	require.NoError(t, err)

	info, err := contractInfo.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, contractID, info.ContractID)
	assert.Equal(t, env.Client.GetOperatorPublicKey(), info.AdminKey)
	assert.Equal(t, "hedera-sdk-go::TestContractInfoQuery_Execute", info.ContractMemo)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractInfoQuerySetSmallMaxPayment(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractInfoQuery_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	contractInfo := NewContractInfoQuery().
		SetContractID(contractID).
		SetMaxQueryPayment(HbarFromTinybar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := contractInfo.GetCost(env.Client)
	require.NoError(t, err)

	_, err = contractInfo.Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "cost of ContractInfoQuery ("+cost.String()+") without explicit payment is greater than the max query payment of 1 tℏ", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractInfoQueryInsufficientFee(t *testing.T) {
	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractInfoQuery_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	contractInfo := NewContractInfoQuery().
		SetContractID(contractID).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	_, err = contractInfo.GetCost(env.Client)
	require.NoError(t, err)

	_, err = contractInfo.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_TX_FEE", err.Error())
	}

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractInfoQueryNoContractID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewContractInfoQuery().
		SetMaxQueryPayment(NewHbar(2)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_CONTRACT_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: contract_info_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	protobuf "google.golang.org/protobuf/proto"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
)

func TestUnitContractInfoQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	contractInfoQuery := NewContractInfoQuery().
		SetContractID(contractID)

	err = contractInfoQuery.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitContractInfoQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	contractInfoQuery := NewContractInfoQuery().
		SetContractID(contractID)

	err = contractInfoQuery.validateNetworkOnIDs(client)
	require.Error(t, err)
	if err != nil {
		require.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitContractInfoQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_ContractGetInfo{
				ContractGetInfo: &services.ContractGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_ContractGetInfo{
				ContractGetInfo: &services.ContractGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_ContractGetInfo{
				ContractGetInfo: &services.ContractGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					ContractInfo: &services.ContractGetInfoResponse_ContractInfo{
						ContractID:         &services.ContractID{Contract: &services.ContractID_ContractNum{ContractNum: 3}},
						AccountID:          &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 4}},
						ContractAccountID:  "",
						AdminKey:           nil,
						ExpirationTime:     nil,
						AutoRenewPeriod:    nil,
						Storage:            0,
						Memo:               "yes",
						Balance:            0,
						Deleted:            false,
						TokenRelationships: nil,
						LedgerId:           nil,
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewContractInfoQuery().
		SetContractID(ContractID{Contract: 3}).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{{Account: 3}})

	cost, err := query.GetCost(client)
	require.NoError(t, err)
	require.Equal(t, cost, HbarFromTinybar(2))

	result, err := query.Execute(client)
	require.NoError(t, err)

	require.Equal(t, result.ContractID.Contract, uint64(3))
	require.Equal(t, result.AccountID.Account, uint64(4))
	require.Equal(t, result.ContractMemo, "yes")
}

func TestUnitContractInfoQueryGetTransactionIDMock(t *testing.T) {
	t.Skip("Skipping test as it is currently broken with the addition of generating new payment transactions for queries")
	t.Parallel()

	transactionID := TransactionIDGenerate(AccountID{Account: 123})
	call := func(request *services.Query) *services.Response {
		if query, ok := request.Query.(*services.Query_ContractGetInfo); ok {
			paymentTransacction := query.ContractGetInfo.Header.Payment

			require.NotEmpty(t, paymentTransacction.BodyBytes)
			transactionBody := services.TransactionBody{}
			_ = protobuf.Unmarshal(paymentTransacction.BodyBytes, &transactionBody)

			require.NotNil(t, transactionBody.TransactionID)
			tempTransactionID := _TransactionIDFromProtobuf(transactionBody.TransactionID)
			require.Equal(t, transactionID.String(), tempTransactionID.String())
		}

		return &services.Response{
			Response: &services.Response_ContractGetInfo{
				ContractGetInfo: &services.ContractGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					ContractInfo: &services.ContractGetInfoResponse_ContractInfo{
						ContractID:         &services.ContractID{Contract: &services.ContractID_ContractNum{ContractNum: 3}},
						AccountID:          &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 4}},
						ContractAccountID:  "",
						AdminKey:           nil,
						ExpirationTime:     nil,
						AutoRenewPeriod:    nil,
						Storage:            0,
						Memo:               "yes",
						Balance:            0,
						Deleted:            false,
						TokenRelationships: nil,
						LedgerId:           nil,
					},
				},
			},
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)

	result, err := NewContractInfoQuery().
		SetContractID(ContractID{Contract: 3}).
		SetMaxQueryPayment(NewHbar(1)).
		SetPaymentTransactionID(transactionID).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		Execute(client)
	require.NoError(t, err)

	require.Equal(t, result.ContractID.Contract, uint64(3))
	require.Equal(t, result.AccountID.Account, uint64(4))
	require.Equal(t, result.ContractMemo, "yes")

	server.Close()
}

func TestUnitContractInfoQueryGet(t *testing.T) {
	t.Parallel()

	spenderContractID := ContractID{Contract: 7}

	balance := NewContractInfoQuery().
		SetContractID(spenderContractID).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}})

	require.Equal(t, spenderContractID, balance.GetContractID())
	require.Equal(t, []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}, balance.GetNodeAccountIDs())
	require.Equal(t, 250*time.Millisecond, balance.GetMinBackoff())
	require.Equal(t, 8*time.Second, balance.GetMaxBackoff())
	require.Equal(t, 10, balance.GetMaxRetryCount())
	require.Equal(t, TransactionID{}, balance.GetPaymentTransactionID())
	require.Equal(t, HbarFromTinybar(25), balance.GetQueryPayment())
	require.Equal(t, NewHbar(1), balance.GetMaxQueryPayment())

}

func TestUnitContractInfoQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	deadline := time.Second * 3
	contract := ContractID{Contract: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewContractInfoQuery().
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetContractID(contract).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3)).
		SetGrpcDeadline(&deadline)

	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)

	require.Equal(t, nodeAccountID, query.GetNodeAccountIDs())
	require.Equal(t, time.Second*30, query.GetMaxBackoff())
	require.Equal(t, time.Second*10, query.GetMinBackoff())
	require.Equal(t, contract, query.GetContractID())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}
// Filename: contract_log_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ContractLogInfo is the log info for events returned by a function
type ContractLogInfo struct {
	ContractID ContractID
	Bloom      []byte
	Topics     [][]byte
	Data       []byte
}

func _ContractLogInfoFromProtobuf(pb *services.ContractLoginfo) ContractLogInfo {
	if pb == nil {
		return ContractLogInfo{}
	}

	contractID := ContractID{}
	if pb.ContractID != nil {
		contractID = *_ContractIDFromProtobuf(pb.ContractID)
	}

	return ContractLogInfo{
		ContractID: contractID,
		Bloom:      pb.Bloom,
		Topics:     pb.Topic,
		Data:       pb.Data,
	}
}

func (logInfo ContractLogInfo) _ToProtobuf() *services.ContractLoginfo {
	return &services.ContractLoginfo{
		ContractID: logInfo.ContractID._ToProtobuf(),
		Bloom:      logInfo.Bloom,
		Topic:      logInfo.Topics,
		Data:       logInfo.Data,
	}
}
// Filename: contract_nonce_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ContractID is the ID for a Hedera smart contract
type ContractNonceInfo struct {
	ContractID *ContractID
	Nonce      int64
}

func _ContractNonceInfoFromProtobuf(contractNonceInfo *services.ContractNonceInfo) *ContractNonceInfo {
	if contractNonceInfo == nil {
		return nil
	}

	return &ContractNonceInfo{
		ContractID: _ContractIDFromProtobuf(contractNonceInfo.GetContractId()),
		Nonce:      contractNonceInfo.GetNonce(),
	}
}
// Filename: contract_nonce_info_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
)

func TestContractNonceInfoFromProtobuf(t *testing.T) {
	contractID := &ContractID{Shard: 0, Realm: 0, Contract: 123}
	nonce := int64(456)
	protobuf := &services.ContractNonceInfo{
		ContractId: contractID._ToProtobuf(),
		Nonce:      nonce,
	}

	result := _ContractNonceInfoFromProtobuf(protobuf)

	assert.Equal(t, contractID, result.ContractID)
	assert.Equal(t, nonce, result.Nonce)
}

func TestContractNonceInfoFromProtobuf_NilInput(t *testing.T) {
	result := _ContractNonceInfoFromProtobuf(nil)

	assert.Nil(t, result)
}
// Filename: contract_state_change.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

type ContractStateChange struct {
	ContractID     *ContractID
	StorageChanges []*StorageChange
}
// Filename: contract_update_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ContractUpdateTransaction is used to modify a smart contract instance to have the given parameter values. Any nil
// field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is
// needed on this transaction other than for the account paying for the transaction itself. But if any of the other
// fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in
// this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications
// to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed
// that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things
// like the bytecode are immutable. But if there is an admin key, then they can be changed.
//
// For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before
// the bytecode can be changed. This can be used to add flexibility to the management of smart contract behavior. But
// this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its
// bytecode will be immutable.
type ContractUpdateTransaction struct {
	Transaction
	contractID                    *ContractID
	proxyAccountID                *AccountID
	bytecodeFileID                *FileID
	adminKey                      Key
	autoRenewPeriod               *time.Duration
	expirationTime                *time.Time
	memo                          string
	autoRenewAccountID            *AccountID
	maxAutomaticTokenAssociations int32
	stakedAccountID               *AccountID
	stakedNodeID                  *int64
	declineReward                 bool
}

// NewContractUpdateTransaction creates a ContractUpdateTransaction transaction which can be
// used to construct and execute a Contract Update Transaction.
// ContractUpdateTransaction is used to modify a smart contract instance to have the given parameter values. Any nil
// field is ignored (left unchanged). If only the contractInstanceExpirationTime is being modified, then no signature is
// needed on this transaction other than for the account paying for the transaction itself. But if any of the other
// fields are being modified, then it must be signed by the adminKey. The use of adminKey is not currently supported in
// this API, but in the future will be implemented to allow these fields to be modified, and also to make modifications
// to the state of the instance. If the contract is created with no admin key, then none of the fields can be changed
// that need an admin signature, and therefore no admin key can ever be added. So if there is no admin key, then things
// like the bytecode are immutable. But if there is an admin key, then they can be changed.
//
// For example, the admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to agree before
// the bytecode can be changed. This can be used to add flexibility to the management of smart contract behavior. But
// this is optional. If the smart contract is created without an admin key, then such a key can never be added, and its
// bytecode will be immutable.
func NewContractUpdateTransaction() *ContractUpdateTransaction {
	tx := ContractUpdateTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _ContractUpdateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *ContractUpdateTransaction {
	key, _ := _KeyFromProtobuf(pb.GetContractUpdateInstance().AdminKey)
	autoRenew := _DurationFromProtobuf(pb.GetContractUpdateInstance().GetAutoRenewPeriod())
	expiration := _TimeFromProtobuf(pb.GetContractUpdateInstance().GetExpirationTime())
	var memo string

	switch m := pb.GetContractUpdateInstance().GetMemoField().(type) {
	case *services.ContractUpdateTransactionBody_Memo:
		memo = m.Memo // nolint
	case *services.ContractUpdateTransactionBody_MemoWrapper:
		memo = m.MemoWrapper.Value
	}

	stakedNodeID := pb.GetContractUpdateInstance().GetStakedNodeId()

	var stakeNodeAccountID *AccountID
	if pb.GetContractUpdateInstance().GetStakedAccountId() != nil {
		stakeNodeAccountID = _AccountIDFromProtobuf(pb.GetContractUpdateInstance().GetStakedAccountId())
	}

	var autoRenewAccountID *AccountID
	if pb.GetContractUpdateInstance().AutoRenewAccountId != nil {
		autoRenewAccountID = _AccountIDFromProtobuf(pb.GetContractUpdateInstance().GetAutoRenewAccountId())
	}

	return &ContractUpdateTransaction{
		Transaction:                   tx,
		contractID:                    _ContractIDFromProtobuf(pb.GetContractUpdateInstance().GetContractID()),
		adminKey:                      key,
		autoRenewPeriod:               &autoRenew,
		expirationTime:                &expiration,
		memo:                          memo,
		autoRenewAccountID:            autoRenewAccountID,
		maxAutomaticTokenAssociations: pb.GetContractUpdateInstance().MaxAutomaticTokenAssociations.GetValue(),
		stakedAccountID:               stakeNodeAccountID,
		stakedNodeID:                  &stakedNodeID,
		declineReward:                 pb.GetContractUpdateInstance().GetDeclineReward().GetValue(),
	}
}

// SetContractID sets The Contract ID instance to update (this can't be changed on the contract)
func (tx *ContractUpdateTransaction) SetContractID(contractID ContractID) *ContractUpdateTransaction {
	tx.contractID = &contractID
	return tx
}

func (tx *ContractUpdateTransaction) GetContractID() ContractID {
	if tx.contractID == nil {
		return ContractID{}
	}

	return *tx.contractID
}

// Deprecated
func (tx *ContractUpdateTransaction) SetBytecodeFileID(bytecodeFileID FileID) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.bytecodeFileID = &bytecodeFileID
	return tx
}

// Deprecated
func (tx *ContractUpdateTransaction) GetBytecodeFileID() FileID {
	if tx.bytecodeFileID == nil {
		return FileID{}
	}

	return *tx.bytecodeFileID
}

// SetAdminKey sets the key which can be used to arbitrarily modify the state of the instance by signing a
// ContractUpdateTransaction to modify it. If the admin key was never set then such modifications are not possible,
// and there is no administrator that can overrIDe the normal operation of the smart contract instance.
func (tx *ContractUpdateTransaction) SetAdminKey(publicKey PublicKey) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.adminKey = publicKey
	return tx
}

func (tx *ContractUpdateTransaction) GetAdminKey() (Key, error) {
	return tx.adminKey, nil
}

// Deprecated
// SetProxyAccountID sets the ID of the account to which this contract is proxy staked. If proxyAccountID is left unset,
// is an invalID account, or is an account that isn't a _Node, then this contract is automatically proxy staked to a _Node
// chosen by the _Network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking,
// or if it is not currently running a _Node, then it will behave as if proxyAccountID was never set.
func (tx *ContractUpdateTransaction) SetProxyAccountID(proxyAccountID AccountID) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.proxyAccountID = &proxyAccountID
	return tx
}

// Deprecated
func (tx *ContractUpdateTransaction) GetProxyAccountID() AccountID {
	if tx.proxyAccountID == nil {
		return AccountID{}
	}

	return *tx.proxyAccountID
}

// SetAutoRenewPeriod sets the duration for which the contract instance will automatically charge its account to
// renew for.
func (tx *ContractUpdateTransaction) SetAutoRenewPeriod(autoRenewPeriod time.Duration) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = &autoRenewPeriod
	return tx
}

func (tx *ContractUpdateTransaction) GetAutoRenewPeriod() time.Duration {
	if tx.autoRenewPeriod != nil {
		return *tx.autoRenewPeriod
	}

	return time.Duration(0)
}

// SetExpirationTime extends the expiration of the instance and its account to the provIDed time. If the time provIDed
// is the current or past time, then there will be no effect.
func (tx *ContractUpdateTransaction) SetExpirationTime(expiration time.Time) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.expirationTime = &expiration
	return tx
}

func (tx *ContractUpdateTransaction) GetExpirationTime() time.Time {
	if tx.expirationTime != nil {
		return *tx.expirationTime
	}

	return time.Time{}
}

// SetContractMemo sets the memo associated with the contract (max 100 bytes)
func (tx *ContractUpdateTransaction) SetContractMemo(memo string) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo
	// if transaction.pb.GetMemoWrapper() != nil {
	//	transaction.pb.GetMemoWrapper().Value = memo
	// } else {
	//	transaction.pb.MemoField = &services.ContractUpdateTransactionBody_MemoWrapper{
	//		MemoWrapper: &wrapperspb.StringValue{Value: memo},
	//	}
	// }

	return tx
}

// SetAutoRenewAccountID
// An account to charge for auto-renewal of this contract. If not set, or set to an
// account with zero hbar balance, the contract's own hbar balance will be used to
// cover auto-renewal fees.
func (tx *ContractUpdateTransaction) SetAutoRenewAccountID(id AccountID) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewAccountID = &id
	return tx
}

func (tx *ContractUpdateTransaction) GetAutoRenewAccountID() AccountID {
	if tx.autoRenewAccountID == nil {
		return AccountID{}
	}

	return *tx.autoRenewAccountID
}

// SetMaxAutomaticTokenAssociations
// The maximum number of tokens that this contract can be automatically associated
// with (i.e., receive air-drops from).
func (tx *ContractUpdateTransaction) SetMaxAutomaticTokenAssociations(max int32) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.maxAutomaticTokenAssociations = max
	return tx
}

func (tx *ContractUpdateTransaction) GetMaxAutomaticTokenAssociations() int32 {
	return tx.maxAutomaticTokenAssociations
}

func (tx *ContractUpdateTransaction) GetContractMemo() string {
	return tx.memo
}

func (tx *ContractUpdateTransaction) SetStakedAccountID(id AccountID) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.stakedAccountID = &id
	return tx
}

func (tx *ContractUpdateTransaction) GetStakedAccountID() AccountID {
	if tx.stakedAccountID != nil {
		return *tx.stakedAccountID
	}

	return AccountID{}
}

func (tx *ContractUpdateTransaction) SetStakedNodeID(id int64) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.stakedNodeID = &id
	return tx
}

func (tx *ContractUpdateTransaction) GetStakedNodeID() int64 {
	if tx.stakedNodeID != nil {
		return *tx.stakedNodeID
	}

	return 0
}

func (tx *ContractUpdateTransaction) SetDeclineStakingReward(decline bool) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.declineReward = decline
	return tx
}

func (tx *ContractUpdateTransaction) GetDeclineStakingReward() bool {
	return tx.declineReward
}

func (tx *ContractUpdateTransaction) ClearStakedAccountID() *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.stakedAccountID = &AccountID{Account: 0}
	return tx
}

func (tx *ContractUpdateTransaction) ClearStakedNodeID() *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	*tx.stakedNodeID = -1
	return tx
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *ContractUpdateTransaction) Sign(
	privateKey PrivateKey,
) *ContractUpdateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *ContractUpdateTransaction) SignWithOperator(
	client *Client,
) (*ContractUpdateTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *ContractUpdateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *ContractUpdateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *ContractUpdateTransaction) AddSignature(publicKey PublicKey, signature []byte) *ContractUpdateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *ContractUpdateTransaction) SetGrpcDeadline(deadline *time.Duration) *ContractUpdateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *ContractUpdateTransaction) Freeze() (*ContractUpdateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *ContractUpdateTransaction) FreezeWith(client *Client) (*ContractUpdateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *ContractUpdateTransaction) SetMaxTransactionFee(fee Hbar) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *ContractUpdateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this ContractUpdateTransaction.
func (tx *ContractUpdateTransaction) SetTransactionMemo(memo string) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this ContractUpdateTransaction.
func (tx *ContractUpdateTransaction) SetTransactionValidDuration(duration time.Duration) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *ContractUpdateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this ContractUpdateTransaction.
func (tx *ContractUpdateTransaction) SetTransactionID(transactionID TransactionID) *ContractUpdateTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountID sets the _Node AccountID for this ContractUpdateTransaction.
func (tx *ContractUpdateTransaction) SetNodeAccountIDs(nodeID []AccountID) *ContractUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *ContractUpdateTransaction) SetMaxRetry(count int) *ContractUpdateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *ContractUpdateTransaction) SetMaxBackoff(max time.Duration) *ContractUpdateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *ContractUpdateTransaction) SetMinBackoff(min time.Duration) *ContractUpdateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *ContractUpdateTransaction) SetLogLevel(level LogLevel) *ContractUpdateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *ContractUpdateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *ContractUpdateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *ContractUpdateTransaction) getName() string {
	return "ContractUpdateTransaction"
}

func (tx *ContractUpdateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.contractID != nil {
		if err := tx.contractID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.proxyAccountID != nil {
		if err := tx.proxyAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *ContractUpdateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ContractUpdateInstance{
			ContractUpdateInstance: tx.buildProtoBody(),
		},
	}
}

func (tx *ContractUpdateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_ContractUpdateInstance{
			ContractUpdateInstance: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *ContractUpdateTransaction) buildProtoBody() *services.ContractUpdateTransactionBody {
	body := &services.ContractUpdateTransactionBody{
		DeclineReward: &wrapperspb.BoolValue{Value: tx.declineReward},
	}

	if tx.maxAutomaticTokenAssociations != 0 {
		body.MaxAutomaticTokenAssociations = &wrapperspb.Int32Value{Value: tx.maxAutomaticTokenAssociations}
	}

	if tx.expirationTime != nil {
		body.ExpirationTime = _TimeToProtobuf(*tx.expirationTime)
	}

	if tx.autoRenewPeriod != nil {
		body.AutoRenewPeriod = _DurationToProtobuf(*tx.autoRenewPeriod)
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	if tx.contractID != nil {
		body.ContractID = tx.contractID._ToProtobuf()
	}

	if tx.autoRenewAccountID != nil {
		body.AutoRenewAccountId = tx.autoRenewAccountID._ToProtobuf()
	}

	if body.GetMemoWrapper() != nil {
		body.GetMemoWrapper().Value = tx.memo
	} else {
		body.MemoField = &services.ContractUpdateTransactionBody_MemoWrapper{
			MemoWrapper: &wrapperspb.StringValue{Value: tx.memo},
		}
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	if tx.contractID != nil {
		body.ContractID = tx.contractID._ToProtobuf()
	}

	if tx.stakedAccountID != nil {
		body.StakedId = &services.ContractUpdateTransactionBody_StakedAccountId{StakedAccountId: tx.stakedAccountID._ToProtobuf()}
	} else if tx.stakedNodeID != nil {
		body.StakedId = &services.ContractUpdateTransactionBody_StakedNodeId{StakedNodeId: *tx.stakedNodeID}
	}

	return body
}

func (tx *ContractUpdateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetContract().UpdateContract,
	}
}
func (tx *ContractUpdateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: contract_update_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationContractUpdateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Note: this is the bytecode for the contract found in the example for ./examples/_Create_simpleContract
	testContractByteCode := []byte(`608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029`)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(testContractByteCode).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetGas(100000).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("[e2e::ContractCreateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	info, err := NewContractInfoQuery().
		SetContractID(contractID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, info)
	assert.NotNil(t, info, info.Storage)
	assert.NotNil(t, info.ContractID)
	assert.Equal(t, info.ContractID, contractID)
	assert.NotNil(t, info.AccountID)
	assert.Equal(t, info.AccountID.String(), contractID.String())
	assert.NotNil(t, info.AdminKey)
	assert.Equal(t, info.AdminKey.String(), env.Client.GetOperatorPublicKey().String())
	assert.Equal(t, info.Storage, uint64(0x40))
	assert.Equal(t, info.ContractMemo, "[e2e::ContractCreateTransaction]")

	resp, err = NewContractUpdateTransaction().
		SetContractID(contractID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContractMemo("[e2e::ContractUpdateTransaction]").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewContractInfoQuery().
		SetContractID(contractID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, info)
	assert.NotNil(t, info.ContractID)
	assert.Equal(t, info.ContractID, contractID)
	assert.NotNil(t, info.AccountID)
	assert.Equal(t, info.AccountID.String(), contractID.String())
	assert.NotNil(t, info.AdminKey)
	assert.Equal(t, info.AdminKey.String(), env.Client.GetOperatorPublicKey().String())
	assert.Equal(t, info.Storage, uint64(0x40))
	assert.Equal(t, info.ContractMemo, "[e2e::ContractUpdateTransaction]")

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationContractUpdateTransactionNoContractID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewContractUpdateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_CONTRACT_ID received for transaction %s", resp.TransactionID), err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: contract_update_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitContractUpdateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	fileID, err := FileIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	contractInfoQuery := NewContractUpdateTransaction().
		SetContractID(contractID).
		SetProxyAccountID(accountID).
		SetBytecodeFileID(fileID)

	err = contractInfoQuery.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitContractUpdateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	contractID, err := ContractIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	fileID, err := FileIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	contractInfoQuery := NewContractUpdateTransaction().
		SetContractID(contractID).
		SetProxyAccountID(accountID).
		SetBytecodeFileID(fileID)

	err = contractInfoQuery.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitContractUpdateTransactionMock(t *testing.T) {
	t.Parallel()

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if bod, ok := transactionBody.Data.(*services.TransactionBody_ContractUpdateInstance); ok {
			require.Equal(t, bod.ContractUpdateInstance.ContractID.GetContractNum(), int64(3))
			if mem, ok2 := bod.ContractUpdateInstance.MemoField.(*services.ContractUpdateTransactionBody_MemoWrapper); ok2 {
				require.Equal(t, mem.MemoWrapper.GetValue(), "yes")
			}
			require.Equal(t, hex.EncodeToString(bod.ContractUpdateInstance.GetAdminKey().GetEd25519()), "1480272863d39c42f902bc11601a968eaf30ad662694e3044c86d5df46fabfd2")
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	//302a300506032b65700321001480272863d39c42f902bc11601a968eaf30ad662694e3044c86d5df46fabfd2
	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420278184257eb568d0e5fcfc1df99828b039b4776da05855dc5af105996e6200d1")
	require.NoError(t, err)

	tran := TransactionIDGenerate(AccountID{Account: 3})

	_, err = NewContractUpdateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTransactionID(tran).
		SetAdminKey(newKey.PublicKey()).
		SetContractMemo("yes").
		SetContractID(ContractID{Contract: 3}).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitContractUpdateTransactionGet(t *testing.T) {
	t.Parallel()

	contractID := ContractID{Contract: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	transaction, err := NewContractUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetContractID(contractID).
		SetAdminKey(newKey.PublicKey()).
		SetContractMemo("yes").
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetContractID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetAdminKey()
	transaction.GetRegenerateTransactionID()
	transaction.GetContractMemo()
}

func TestUnitContractUpdateTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewContractUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetContractID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetAdminKey()
	transaction.GetRegenerateTransactionID()
	transaction.GetContractMemo()
}

func TestUnitContractUpdateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	contractID := ContractID{Contract: 7}
	accountID := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	transaction, err := NewContractUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetContractID(contractID).
		SetAdminKey(newKey.PublicKey()).
		SetContractMemo("yes").
		SetStakedAccountID(accountID).
		SetMaxAutomaticTokenAssociations(3).
		SetAutoRenewPeriod(time.Second * 3).
		SetExpirationTime(time.Unix(34, 3)).
		SetAutoRenewAccountID(accountID).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetContractUpdateInstance()
	require.Equal(t, proto.AdminKey.String(), newKey._ToProtoKey().String())
	require.Equal(t, proto.ContractID.String(), contractID._ToProtobuf().String())
	require.Equal(t, proto.MemoField.(*services.ContractUpdateTransactionBody_MemoWrapper).MemoWrapper.Value, "yes")
	require.Equal(t, proto.StakedId.(*services.ContractUpdateTransactionBody_StakedAccountId).StakedAccountId.String(),
		accountID._ToProtobuf().String())
	require.Equal(t, proto.MaxAutomaticTokenAssociations.Value, int32(3))
	require.Equal(t, proto.AutoRenewPeriod.String(), _DurationToProtobuf(time.Second*3).String())
	require.Equal(t, proto.ExpirationTime.String(), _TimeToProtobuf(time.Unix(34, 3)).String())
	require.Equal(t, proto.AutoRenewAccountId.String(), accountID._ToProtobuf().String())
}

func TestUnitContractUpdateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	file := FileID{File: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	contract := ContractID{Contract: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewContractUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(newKey.PublicKey()).
		SetBytecodeFileID(file).
		SetContractMemo("yes").
		SetStakedAccountID(account).
		SetStakedNodeID(3).
		SetContractID(contract).
		SetProxyAccountID(account).
		SetDeclineStakingReward(true).
		SetAutoRenewPeriod(time.Second * 30).
		SetExpirationTime(time.Unix(345, 566)).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetStakedAccountID()
	transaction.GetStakedNodeID()
	transaction.GetProxyAccountID()
	transaction.GetBytecodeFileID()
	transaction.GetAutoRenewPeriod()
	transaction.GetAutoRenewAccountID()
	transaction.GetExpirationTime()
	transaction.GetDeclineStakingReward()
	transaction.ClearStakedAccountID()
	transaction.ClearStakedNodeID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case ContractUpdateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}
// Filename: crypto.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"crypto/hmac"
	"crypto/sha512"
	"encoding/binary"
	"encoding/hex"
	"io"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/crypto"
	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
	"golang.org/x/crypto/pbkdf2"
	protobuf "google.golang.org/protobuf/proto"
)

const _Ed25519PrivateKeyPrefix = "302e020100300506032b657004220420"

type Key interface {
	_ToProtoKey() *services.Key
	String() string
}

func KeyFromBytes(bytes []byte) (Key, error) {
	protoKey := &services.Key{}

	err := protobuf.Unmarshal(bytes, protoKey)
	if err != nil {
		return nil, err
	}

	return _KeyFromProtobuf(protoKey)
}

func KeyToBytes(key Key) ([]byte, error) {
	protoKey := key._ToProtoKey()
	return protobuf.Marshal(protoKey)
}

func _KeyFromProtobuf(pbKey *services.Key) (Key, error) {
	if pbKey == nil {
		return PublicKey{}, errParameterNull
	}
	switch key := pbKey.GetKey().(type) {
	case *services.Key_Ed25519:
		return PublicKeyFromBytesEd25519(key.Ed25519)

	case *services.Key_ThresholdKey:
		threshold := int(key.ThresholdKey.GetThreshold())
		keys, err := _KeyListFromProtobuf(key.ThresholdKey.GetKeys())
		if err != nil {
			return nil, err
		}
		keys.threshold = threshold

		return &keys, nil

	case *services.Key_KeyList:
		keys, err := _KeyListFromProtobuf(key.KeyList)
		if err != nil {
			return nil, err
		}

		return &keys, nil

	case *services.Key_ContractID:
		return _ContractIDFromProtobuf(key.ContractID), nil

	case *services.Key_ECDSASecp256K1:
		return PublicKeyFromBytesECDSA(key.ECDSASecp256K1)

	case *services.Key_DelegatableContractId:
		return _DelegatableContractIDFromProtobuf(key.DelegatableContractId), nil

	default:
		return nil, _NewErrBadKeyf("key type not implemented: %v", key)
	}
}

type PrivateKey struct {
	ecdsaPrivateKey   *_ECDSAPrivateKey
	ed25519PrivateKey *_Ed25519PrivateKey
}

type PublicKey struct {
	ecdsaPublicKey   *_ECDSAPublicKey
	ed25519PublicKey *_Ed25519PublicKey
}

/**
 *  SDK needs to provide  a way to set an unusable key such as an Ed25519 all-zeros
 *  key, since it is (presumably) impossible to find the 32-byte string whose SHA-512 hash begins with 32 bytes
 *  of zeros. We recommend using all-zeros to clearly advertise any unusable keys.
 */
func ZeroKey() (PublicKey, error) {
	return PublicKeyFromString("0000000000000000000000000000000000000000000000000000000000000000")
}

// PrivateKeyGenerateEcdsa Generates a new ECDSASecp256K1 key
func PrivateKeyGenerateEcdsa() (PrivateKey, error) {
	key, err := _GenerateECDSAPrivateKey()
	if err != nil {
		return PrivateKey{}, err
	}
	return PrivateKey{
		ecdsaPrivateKey: key,
	}, nil
}

// Deprecated: use `PrivateKeyGenerateEd25519()` instead
func PrivateKeyGenerate() (PrivateKey, error) {
	return PrivateKeyGenerateEd25519()
}

// PrivateKeyGenerateEd25519 Generates a new Ed25519 key
func PrivateKeyGenerateEd25519() (PrivateKey, error) {
	key, err := _GenerateEd25519PrivateKey()
	if err != nil {
		return PrivateKey{}, err
	}
	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

// Deprecated the use of raw bytes for a Ed25519 private key is deprecated; use PrivateKeyFromBytesEd25519() instead.
func PrivateKeyFromBytes(bytes []byte) (PrivateKey, error) {
	key, err := _Ed25519PrivateKeyFromBytes(bytes)
	if err != nil {
		key2, err2 := _ECDSAPrivateKeyFromBytes(bytes)
		if err2 != nil {
			return PrivateKey{}, err2
		}

		return PrivateKey{
			ecdsaPrivateKey: key2,
		}, nil
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

func PrivateKeyFromBytesDer(bytes []byte) (PrivateKey, error) {
	key, err := _Ed25519PrivateKeyFromBytes(bytes)
	if err != nil {
		key2, err2 := _ECDSAPrivateKeyFromBytes(bytes)
		if err2 != nil {
			return PrivateKey{}, err2
		}

		return PrivateKey{
			ecdsaPrivateKey: key2,
		}, nil
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

func PrivateKeyFromBytesEd25519(bytes []byte) (PrivateKey, error) {
	key, err := _Ed25519PrivateKeyFromBytes(bytes)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

func PrivateKeyFromBytesECDSA(bytes []byte) (PrivateKey, error) {
	key, err := _ECDSAPrivateKeyFromBytes(bytes)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ecdsaPrivateKey: key,
	}, nil
}

func PublicKeyFromBytesEd25519(bytes []byte) (PublicKey, error) {
	key, err := _Ed25519PublicKeyFromBytes(bytes)
	if err != nil {
		return PublicKey{}, err
	}

	return PublicKey{
		ed25519PublicKey: key,
	}, nil
}

func PublicKeyFromBytesECDSA(bytes []byte) (PublicKey, error) {
	key, err := _ECDSAPublicKeyFromBytes(bytes)
	if err != nil {
		return PublicKey{}, err
	}

	return PublicKey{
		ecdsaPublicKey: key,
	}, nil
}

// Deprecated the use of raw bytes for a Ed25519 private key is deprecated; use PublicKeyFromBytesEd25519() instead.
func PublicKeyFromBytes(bytes []byte) (PublicKey, error) {
	key, err := _Ed25519PublicKeyFromBytes(bytes)
	if err != nil {
		key2, err2 := _ECDSAPublicKeyFromBytes(bytes)
		if err2 != nil {
			return PublicKey{}, err2
		}

		return PublicKey{
			ecdsaPublicKey: key2,
		}, nil
	}

	return PublicKey{
		ed25519PublicKey: key,
	}, nil
}

func PublicKeyFromBytesDer(bytes []byte) (PublicKey, error) {
	key, err := _Ed25519PublicKeyFromBytes(bytes)
	if err != nil {
		key2, err2 := _ECDSAPublicKeyFromBytes(bytes)
		if err2 != nil {
			return PublicKey{}, err2
		}

		return PublicKey{
			ecdsaPublicKey: key2,
		}, nil
	}

	return PublicKey{
		ed25519PublicKey: key,
	}, nil
}

// Deprecated
// PrivateKeyFromMnemonic recovers an _Ed25519PrivateKey from a valid 24 word length mnemonic phrase and a
// passphrase.
//
// An empty string can be passed for passPhrase If the mnemonic phrase wasn't generated with a passphrase. This is
// required to recover a private key from a mnemonic generated by the Android and iOS wallets.
func PrivateKeyFromMnemonic(mnemonic Mnemonic, passPhrase string) (PrivateKey, error) {
	key, err := _Ed25519PrivateKeyFromMnemonic(mnemonic, passPhrase)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

// The use of raw bytes for a Ed25519 private key is deprecated; use PrivateKeyFromStringEd25519() instead.
func PrivateKeyFromString(s string) (PrivateKey, error) {
	byt, err := hex.DecodeString(s)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKeyFromBytes(byt)
}

// PrivateKeyFromStringDer Creates PrivateKey from hex string with a der prefix
func PrivateKeyFromStringDer(s string) (PrivateKey, error) {
	KeyEd25519, err := _Ed25519PrivateKeyFromString(s)
	if err == nil {
		return PrivateKey{ed25519PrivateKey: KeyEd25519}, nil
	}

	keyECDSA, err := _ECDSAPrivateKeyFromString(s)
	if err == nil {
		return PrivateKey{ecdsaPrivateKey: keyECDSA}, nil
	}

	return PrivateKey{}, errors.New("invalid private key format")
}

func PrivateKeyFromStringEd25519(s string) (PrivateKey, error) {
	key, err := _Ed25519PrivateKeyFromString(s)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

// Deprecated: use PrivateKeyFromStringECDSA() instead
func PrivateKeyFromStringECSDA(s string) (PrivateKey, error) {
	return PrivateKeyFromStringECDSA(s)
}

func PrivateKeyFromStringECDSA(s string) (PrivateKey, error) {
	trimmedKey := strings.TrimPrefix(s, "0x")
	key, err := _ECDSAPrivateKeyFromString(trimmedKey)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ecdsaPrivateKey: key,
	}, nil
}

func PrivateKeyFromSeedEd25519(seed []byte) (PrivateKey, error) {
	key, err := _Ed25519PrivateKeyFromSeed(seed)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

func PrivateKeyFromSeedECDSAsecp256k1(seed []byte) (PrivateKey, error) {
	key, err := _ECDSAPrivateKeyFromSeed(seed)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ecdsaPrivateKey: key,
	}, nil
}

func PrivateKeyFromKeystore(ks []byte, passphrase string) (PrivateKey, error) {
	key, err := _Ed25519PrivateKeyFromKeystore(ks, passphrase)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

// PrivateKeyReadKeystore recovers an _Ed25519PrivateKey from an encrypted _Keystore file.
func PrivateKeyReadKeystore(source io.Reader, passphrase string) (PrivateKey, error) {
	key, err := _Ed25519PrivateKeyReadKeystore(source, passphrase)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

func PrivateKeyFromPem(bytes []byte, passphrase string) (PrivateKey, error) {
	key, err := _Ed25519PrivateKeyFromPem(bytes, passphrase)
	if err != nil {
		key, err := _ECDSAPrivateKeyFromPem(bytes, passphrase)
		if err != nil {
			return PrivateKey{}, err
		}
		return PrivateKey{
			ecdsaPrivateKey: key,
		}, nil
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

func PrivateKeyReadPem(source io.Reader, passphrase string) (PrivateKey, error) {
	// note: Passphrases are currently not supported, but included in the function definition to avoid breaking
	// changes in the future.

	key, err := _Ed25519PrivateKeyReadPem(source, passphrase)
	if err != nil {
		key, err := _ECDSAPrivateKeyReadPem(source, passphrase)
		if err != nil {
			return PrivateKey{}, err
		}
		return PrivateKey{
			ecdsaPrivateKey: key,
		}, nil
	}

	return PrivateKey{
		ed25519PrivateKey: key,
	}, nil
}

// The use of raw bytes for a Ed25519 public key is deprecated; use PublicKeyFromStringEd25519/ECDSA() instead.
func PublicKeyFromString(s string) (PublicKey, error) {
	byt, err := hex.DecodeString(s)
	if err != nil {
		return PublicKey{}, err
	}

	return PublicKeyFromBytes(byt)
}

func PublicKeyFromStringECDSA(s string) (PublicKey, error) {
	key, err := _ECDSAPublicKeyFromString(s)
	if err != nil {
		return PublicKey{}, err
	}

	return PublicKey{
		ecdsaPublicKey: key,
	}, nil
}

func PublicKeyFromStringEd25519(s string) (PublicKey, error) {
	key, err := _Ed25519PublicKeyFromString(s)
	if err != nil {
		return PublicKey{}, err
	}

	return PublicKey{
		ed25519PublicKey: key,
	}, nil
}

func _DeriveEd25519ChildKey(parentKey []byte, chainCode []byte, index uint32) ([]byte, []byte, error) {
	if IsHardenedIndex(index) {
		return nil, nil, errors.New("the index should not be pre-hardened")
	}

	h := hmac.New(sha512.New, chainCode)

	input := make([]byte, 37)

	// 0x00 + parentKey + _Index(BE)
	input[0] = 0

	copy(input[1:37], parentKey)

	binary.BigEndian.PutUint32(input[33:37], index)

	// harden the input
	input[33] |= 128

	if _, err := h.Write(input); err != nil {
		return nil, nil, err
	}

	digest := h.Sum(nil)

	return digest[0:32], digest[32:], nil
}

func _DeriveECDSAChildKey(parentKey []byte, chainCode []byte, index uint32) ([]byte, []byte, error) {
	h := hmac.New(sha512.New, chainCode)

	isHardened := IsHardenedIndex(index)
	input := make([]byte, 37)
	key, err := crypto.ToECDSA(parentKey)
	if err != nil {
		return nil, nil, err
	}

	if isHardened {
		offset := 33 - len(parentKey)
		copy(input[offset:], parentKey)
	} else {
		pubKey := crypto.CompressPubkey(&key.PublicKey)
		copy(input, pubKey)
	}

	binary.BigEndian.PutUint32(input[33:37], index)

	if _, err := h.Write(input); err != nil {
		return nil, nil, err
	}

	i := h.Sum(nil)

	il := new(big.Int)
	il.SetBytes(i[0:32])
	ir := i[32:]

	ki := new(big.Int)
	ki.Add(key.D, il)
	ki.Mod(ki, key.Curve.Params().N)

	return ki.Bytes(), ir, nil
}

func _DeriveLegacyChildKey(parentKey []byte, index int64) ([]byte, error) {
	in := make([]uint8, 8)

	switch switchIndex := index; {
	case switchIndex == int64(0xffffffffff):
		in = []uint8{0, 0, 0, 0xff, 0xff, 0xff, 0xff, 0xff}
	case switchIndex > 0xffffffff:
		return nil, errors.New("derive index is out of range")
	default:
		if switchIndex < 0 {
			for i := 0; i < 4; i++ {
				in[i] = uint8(0xff)
			}
		}

		for i := 4; i < len(in); i++ {
			in[i] = uint8(switchIndex)
		}
	}

	password := make([]uint8, len(parentKey))
	copy(password, parentKey)
	password = append(password, in...)

	salt := []byte{0xFF}

	return pbkdf2.Key(password, salt, 2048, 32, sha512.New), nil
}

func (sk PrivateKey) PublicKey() PublicKey {
	if sk.ecdsaPrivateKey != nil {
		return PublicKey{
			ecdsaPublicKey: sk.ecdsaPrivateKey._PublicKey(),
		}
	}

	if sk.ed25519PrivateKey != nil {
		return PublicKey{
			ed25519PublicKey: sk.ed25519PrivateKey._PublicKey(),
		}
	}

	return PublicKey{}
}

func (sk PrivateKey) ToAccountID(shard uint64, realm uint64) *AccountID {
	return sk.PublicKey().ToAccountID(shard, realm)
}

func (pk PublicKey) ToAccountID(shard uint64, realm uint64) *AccountID {
	temp := pk

	return &AccountID{
		Shard:    shard,
		Realm:    realm,
		Account:  0,
		AliasKey: &temp,
		checksum: nil,
	}
}

// String returns the text-encoded representation of the PrivateKey.
func (sk PrivateKey) String() string {
	if sk.ecdsaPrivateKey != nil {
		return sk.ecdsaPrivateKey._StringDer()
	}

	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._StringDer()
	}

	return ""
}

func (sk PrivateKey) StringRaw() string {
	if sk.ecdsaPrivateKey != nil {
		return sk.ecdsaPrivateKey._StringRaw()
	}

	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._StringRaw()
	}

	return ""
}

func (sk PrivateKey) StringDer() string {
	if sk.ecdsaPrivateKey != nil {
		return sk.ecdsaPrivateKey._StringDer()
	}

	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._StringDer()
	}

	return ""
}

func (pk PublicKey) String() string {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._StringDer()
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._StringDer()
	}

	return ""
}

func (pk PublicKey) StringDer() string {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._StringDer()
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._StringDer()
	}

	return ""
}

func (pk PublicKey) StringRaw() string {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._StringRaw()
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._StringRaw()
	}

	return ""
}

// `Deprecated: Use ToEvmAddress instead`
func (pk PublicKey) ToEthereumAddress() string {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._ToEthereumAddress()
	}

	panic("unsupported operation on Ed25519PublicKey")
}

func (pk PublicKey) ToEvmAddress() string {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._ToEthereumAddress()
	}

	panic("unsupported operation on Ed25519PublicKey")
}

/*
 * For `Ed25519` the result of this method call is identical to `toBytesRaw()` while for `ECDSA`
 * this method is identical to `toBytesDer()`.
 *
 * We strongly recommend using `toBytesRaw()` or `toBytesDer()` instead.
 */
func (sk PrivateKey) Bytes() []byte {
	if sk.ecdsaPrivateKey != nil {
		return sk.ecdsaPrivateKey._BytesDer()
	}

	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._BytesRaw()
	}

	return []byte{}
}

func (sk PrivateKey) BytesDer() []byte {
	if sk.ecdsaPrivateKey != nil {
		return sk.ecdsaPrivateKey._BytesDer()
	}

	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._BytesDer()
	}

	return []byte{}
}

func (sk PrivateKey) BytesRaw() []byte {
	if sk.ecdsaPrivateKey != nil {
		return sk.ecdsaPrivateKey._BytesRaw()
	}

	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._BytesRaw()
	}

	return []byte{}
}

/*
 * For `Ed25519` the result of this method call is identical to `toBytesRaw()` while for `ECDSA`
 * this method is identical to `toBytesDer()`.
 *
 * We strongly recommend using `toBytesRaw()` or `toBytesDer()` instead.
 */
func (pk PublicKey) Bytes() []byte {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._BytesDer()
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._BytesRaw()
	}

	return []byte{}
}

func (pk PublicKey) BytesRaw() []byte {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._BytesRaw()
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._BytesRaw()
	}

	return []byte{}
}

func (pk PublicKey) BytesDer() []byte {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._BytesDer()
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._BytesDer()
	}

	return []byte{}
}

func (sk PrivateKey) Keystore(passphrase string) ([]byte, error) {
	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._Keystore(passphrase)
	}

	return []byte{}, errors.New("only ed25519 keystore is supported right now")
}

func (sk PrivateKey) WriteKeystore(destination io.Writer, passphrase string) error {
	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._WriteKeystore(destination, passphrase)
	}

	return errors.New("only writing ed25519 keystore is supported right now")
}

// Sign signs the provided message with the Ed25519PrivateKey.
func (sk PrivateKey) Sign(message []byte) []byte {
	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._Sign(message)
	}
	if sk.ecdsaPrivateKey != nil {
		return sk.ecdsaPrivateKey._Sign(message)
	}

	return []byte{}
}

func (sk PrivateKey) SupportsDerivation() bool {
	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._SupportsDerivation()
	}

	return false
}

func (sk PrivateKey) Derive(index uint32) (PrivateKey, error) {
	if sk.ed25519PrivateKey != nil {
		key, err := sk.ed25519PrivateKey._Derive(index)
		if err != nil {
			return PrivateKey{}, err
		}

		return PrivateKey{
			ed25519PrivateKey: key,
		}, nil
	}
	if sk.ecdsaPrivateKey != nil {
		key, err := sk.ecdsaPrivateKey._Derive(index)
		if err != nil {
			return PrivateKey{}, err
		}

		return PrivateKey{
			ecdsaPrivateKey: key,
		}, nil
	}

	return PrivateKey{}, nil
}

func (sk PrivateKey) LegacyDerive(index int64) (PrivateKey, error) {
	if sk.ed25519PrivateKey != nil {
		key, err := sk.ed25519PrivateKey._LegacyDerive(index)
		if err != nil {
			return PrivateKey{}, err
		}

		return PrivateKey{
			ed25519PrivateKey: key,
		}, nil
	}

	return PrivateKey{}, errors.New("only ed25519 legacy derivation is supported")
}

func (sk PrivateKey) _ToProtoKey() *services.Key {
	if sk.ecdsaPrivateKey != nil {
		return sk.ecdsaPrivateKey._ToProtoKey()
	}

	if sk.ed25519PrivateKey != nil {
		return sk.ed25519PrivateKey._ToProtoKey()
	}

	return &services.Key{}
}

func (pk PublicKey) _ToProtoKey() *services.Key {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._ToProtoKey()
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._ToProtoKey()
	}

	return &services.Key{}
}

func (pk PublicKey) _ToSignaturePairProtobuf(signature []byte) *services.SignaturePair {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._ToSignaturePairProtobuf(signature)
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._ToSignaturePairProtobuf(signature)
	}

	return &services.SignaturePair{}
}

// SignTransaction signes the transaction and adds the signature to the transaction
func (sk PrivateKey) SignTransaction(tx *Transaction) ([]byte, error) {
	if sk.ecdsaPrivateKey != nil {
		b, err := sk.ecdsaPrivateKey._SignTransaction(tx)
		if err != nil {
			return []byte{}, err
		}

		return b, nil
	}

	if sk.ed25519PrivateKey != nil {
		b, err := sk.ed25519PrivateKey._SignTransaction(tx)
		if err != nil {
			return []byte{}, err
		}

		return b, nil
	}

	return []byte{}, errors.New("key type not supported, only ed25519 and ECDSASecp256K1 are supported right now")
}

func (pk PublicKey) Verify(message []byte, signature []byte) bool {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._Verify(message, signature)
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._Verify(message, signature)
	}

	return false
}

func (pk PublicKey) VerifyTransaction(transaction Transaction) bool {
	if pk.ecdsaPublicKey != nil {
		return pk.ecdsaPublicKey._VerifyTransaction(transaction)
	}

	if pk.ed25519PublicKey != nil {
		return pk.ed25519PublicKey._VerifyTransaction(transaction)
	}

	return false
}
// Filename: crypto_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"testing"
)

func TestSetKeyUsesAnyKey(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	keys := make([]PrivateKey, 3)
	pubKeys := make([]PublicKey, 3)

	for i := range keys {
		newKey, err := PrivateKeyGenerateEd25519()
		if err != nil {
			panic(err)
		}

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	thresholdKey := KeyListWithThreshold(2).
		AddAllPublicKeys(pubKeys)

	_, err = NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetKey(newKey).
		SetKey(thresholdKey).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)
}

func DisabledTestECDSAPrivateKey(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		SetMaxAutomaticTokenAssociations(100).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tx, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: crypto_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"crypto/ed25519"
	"encoding/hex"
	"fmt"
	"strings"
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/ethereum/go-ethereum/crypto"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/proto"
)

const _Ed25519PubKeyPrefix = "302a300506032b6570032100"
const _ECDSAPubKeyPrefix = "3036301006072a8648ce3d020106052b8104000a0322000"
const _ECDSAPrivatePrefix = "30540201010420"

const testPrivateKeyStr = "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10"

const testPublicKeyStr = "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7"

const testMnemonic3 = "obvious favorite remain caution remove laptop base vacant increase video erase pass sniff sausage knock grid argue salt romance way alone fever slush dune"

// generated by hedera-keygen-java, not used anywhere
const testMnemonic = "inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home"
const testMnemonicKey = "302e020100300506032b657004220420853f15aecd22706b105da1d709b4ac05b4906170c2b9c7495dff9af49e1391da"

// backup phrase generated by the iOS wallet, not used anywhere
const iosMnemonicString = "tiny denial casual grass skull spare awkward indoor ethics dash enough flavor good daughter early hard rug staff capable swallow raise flavor empty angle"

// private key for "default account", should be index 0
const iosDefaultPrivateKey = "5f66a51931e8c99089472e0d70516b6272b94dd772b967f8221e1077f966dbda2b60cf7ee8cf10ecd5a076bffad9a7c7b97df370ad758c0f1dd4ef738e04ceb6"

// backup phrase generated by the Android wallet, also not used anywhere
const androidMnemonicString = "ramp april job flavor surround pyramid fish sea good know blame gate village viable include mixed term draft among monitor swear swing novel track"

// private key for "default account", should be index 0
const androidDefaultPrivateKey = "c284c25b3a1458b59423bc289e83703b125c8eefec4d5aa1b393c2beb9f2bae66188a344ba75c43918ab12fa2ea4a92960eca029a2320d8c6a1c3b94e06c9985"

// test pem key contests for the above testPrivateKeyStr
const pemString = `-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEINtIS4KOZLLY8SzjwKDpOguMznrxu485yXcyOUSCU44Q
-----END PRIVATE KEY-----
`

// const encryptedPem = `-----BEGIN ENCRYPTED PRIVATE KEY-----
// MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAi8WY7Gy2tThQICCAAw
// DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEOq46NPss58chbjUn20NoK0EQG1x
// R88hIXcWDOECttPTNlMXWJt7Wufm1YwBibrxmCq1QykIyTYhy1TZMyxyPxlYW6aV
// 9hlo4YEh3uEaCmfJzWM=
// -----END ENCRYPTED PRIVATE KEY-----`

const encryptedPem = `-----BEGIN ENCRYPTED PRIVATE KEY-----
MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAi8WY7Gy2tThQICCAAw
DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEOq46NPss58chbjUn20NoK0EQG1x
R88hIXcWDOECttPTNlMXWJt7Wufm1YwBibrxmCq1QykIyTYhy1TZMyxyPxlYW6aV
9hlo4YEh3uEaCmfJzWM=
-----END ENCRYPTED PRIVATE KEY-----
`
const pemPassphrase = "this is a passphrase"

func TestUnitPrivateKeyGenerate(t *testing.T) {
	t.Parallel()

	key, err := GeneratePrivateKey()

	require.NoError(t, err)
	assert.True(t, strings.HasPrefix(key.String(), _Ed25519PrivateKeyPrefix))
}

func TestUnitPrivateEd25519KeyGenerate(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()

	require.NoError(t, err)
	assert.True(t, strings.HasPrefix(key.String(), _Ed25519PrivateKeyPrefix))
}

func TestUnitPrivateECDSAKeyGenerate(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()

	require.NoError(t, err)
	assert.True(t, strings.HasPrefix(key.String(), _ECDSAPrivatePrefix))
}

func TestUnitPrivateKeyExternalSerialization(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyFromString(testPrivateKeyStr)

	require.NoError(t, err)
	assert.Equal(t, testPrivateKeyStr, key.String())
}

func TestUnitPrivateKeyExternalSerializationForConcatenatedHex(t *testing.T) {
	t.Parallel()

	keyStr := "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7"
	key, err := PrivateKeyFromStringEd25519(keyStr)

	require.NoError(t, err)
	assert.Equal(t, testPrivateKeyStr, key.String())
}

func TestUnitShouldMatchHbarWalletV1(t *testing.T) {
	t.Parallel()

	mnemonic, err := MnemonicFromString("jolly kidnap tom lawn drunk chick optic lust mutter mole bride galley dense member sage neural widow decide curb aboard margin manure")
	require.NoError(t, err)

	key, err := mnemonic.ToLegacyPrivateKey()
	require.NoError(t, err)

	deriveKey, err := key.LegacyDerive(1099511627775)
	require.NoError(t, err)

	assert.Equal(t, "302a300506032b657003210045f3a673984a0b4ee404a1f4404ed058475ecd177729daa042e437702f7791e9", deriveKey.PublicKey().String())
}

func TestUnitLegacyPrivateKeyFromMnemonicDerive(t *testing.T) {
	t.Parallel()

	mnemonic, err := MnemonicFromString("jolly kidnap tom lawn drunk chick optic lust mutter mole bride galley dense member sage neural widow decide curb aboard margin manure")
	require.NoError(t, err)

	key, err := mnemonic.ToLegacyPrivateKey()
	require.NoError(t, err)

	deriveKey, err := key.LegacyDerive(0)
	require.NoError(t, err)
	deriveKey2, err := key.LegacyDerive(-1)
	require.NoError(t, err)

	assert.Equal(t, "302e020100300506032b657004220420882a565ad8cb45643892b5366c1ee1c1ef4a730c5ce821a219ff49b6bf173ddf", deriveKey2.String())
	assert.Equal(t, "302e020100300506032b657004220420fae0002d2716ea3a60c9cd05ee3c4bb88723b196341b68a02d20975f9d049dc6", deriveKey.String())
}

func TestUnitPrivateKeyExternalSerializationForRawHex(t *testing.T) {
	t.Parallel()

	keyStr := "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10"
	key, err := PrivateKeyFromStringEd25519(keyStr)

	require.NoError(t, err)
	assert.Equal(t, testPrivateKeyStr, key.String())
}

func TestUnitPublicKeyExternalSerializationForDerEncodedHex(t *testing.T) {
	t.Parallel()

	key, err := PublicKeyFromString(testPublicKeyStr)

	require.NoError(t, err)
	assert.Equal(t, testPublicKeyStr, key.String())
}

func TestUnitPublicKeyExternalSerializationForRawHex(t *testing.T) {
	t.Parallel()

	keyStr := "e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7"
	key, err := PublicKeyFromStringEd25519(keyStr)

	require.NoError(t, err)
	assert.Equal(t, testPublicKeyStr, key.String())
}

func TestUnitMnemonicToPrivateKey(t *testing.T) {
	t.Parallel()

	mnemonic, err := MnemonicFromString(testMnemonic)
	require.NoError(t, err)

	key, err := mnemonic.ToPrivateKey("")
	require.NoError(t, err)

	assert.Equal(t, testMnemonicKey, key.String())
}

func TestUnitIOSPrivateKeyFromMnemonic(t *testing.T) {
	t.Parallel()

	mnemonic, err := MnemonicFromString(iosMnemonicString)
	require.NoError(t, err)

	key, err := PrivateKeyFromMnemonic(mnemonic, "")
	require.NoError(t, err)

	derivedKey, err := key.Derive(0)
	require.NoError(t, err)

	expectedKey, err := PrivateKeyFromString(iosDefaultPrivateKey)
	require.NoError(t, err)

	assert.Equal(t, expectedKey.ed25519PrivateKey.keyData, derivedKey.ed25519PrivateKey.keyData)
}

func TestUnitAndroidPrivateKeyFromMnemonic(t *testing.T) {
	t.Parallel()

	mnemonic, err := MnemonicFromString(androidMnemonicString)
	require.NoError(t, err)

	key, err := PrivateKeyFromMnemonic(mnemonic, "")
	require.NoError(t, err)

	derivedKey, err := key.Derive(0)
	require.NoError(t, err)

	expectedKey, err := PrivateKeyFromString(androidDefaultPrivateKey)
	require.NoError(t, err)

	assert.Equal(t, expectedKey.ed25519PrivateKey.keyData, derivedKey.ed25519PrivateKey.keyData)
}

func TestUnitMnemonic3(t *testing.T) {
	t.Parallel()

	mnemonic, err := MnemonicFromString(testMnemonic3)
	require.NoError(t, err)

	key, err := mnemonic.ToLegacyPrivateKey()
	require.NoError(t, err)

	derivedKey, err := key.LegacyDerive(0)
	require.NoError(t, err)
	derivedKey2, err := key.LegacyDerive(-1)
	require.NoError(t, err)

	assert.Equal(t, "302e020100300506032b6570042204202b7345f302a10c2a6d55bf8b7af40f125ec41d780957826006d30776f0c441fb", derivedKey.String())
	assert.Equal(t, "302e020100300506032b657004220420caffc03fdb9853e6a91a5b3c57a5c0031d164ce1c464dea88f3114786b5199e5", derivedKey2.String())
}

func TestUnitSigning(t *testing.T) {
	t.Parallel()

	priKey, err := PrivateKeyFromString(testPrivateKeyStr)
	require.NoError(t, err)

	pubKey, err := PublicKeyFromString(testPublicKeyStr)
	require.NoError(t, err)

	testSignData := []byte("this is the test data to sign")
	signature := priKey.Sign(testSignData)

	assert.True(t, ed25519.Verify(pubKey.Bytes(), []byte("this is the test data to sign"), signature))
}

func TestUnitGenerated24MnemonicToWorkingPrivateKey(t *testing.T) {
	t.Parallel()

	mnemonic, err := GenerateMnemonic24()

	require.NoError(t, err)

	privateKey, err := mnemonic.ToPrivateKey("")

	require.NoError(t, err)

	message := []byte("this is a test message")

	signature := privateKey.Sign(message)

	assert.True(t, ed25519.Verify(privateKey.PublicKey().Bytes(), message, signature))
}

func TestUnitGenerated12MnemonicToWorkingPrivateKey(t *testing.T) {
	t.Parallel()

	mnemonic, err := GenerateMnemonic12()

	require.NoError(t, err)

	privateKey, err := mnemonic.ToPrivateKey("")

	require.NoError(t, err)

	message := []byte("this is a test message")

	signature := privateKey.Sign(message)

	assert.True(t, ed25519.Verify(privateKey.PublicKey().Bytes(), message, signature))
}

func TestUnitPrivateKeyFromKeystore(t *testing.T) {
	t.Parallel()

	privatekey, err := PrivateKeyFromKeystore([]byte(testKeystore), passphrase)
	require.NoError(t, err)

	actualPrivateKey, err := PrivateKeyFromStringEd25519(testKeystoreKeyString)
	require.NoError(t, err)

	assert.Equal(t, actualPrivateKey.ed25519PrivateKey.keyData, privatekey.ed25519PrivateKey.keyData)
}

func TestUnitPrivateKeyKeystore(t *testing.T) {
	t.Parallel()

	privateKey, err := PrivateKeyFromString(testPrivateKeyStr)
	require.NoError(t, err)

	keystore, err := privateKey.Keystore(passphrase)
	require.NoError(t, err)

	ksPrivateKey, err := _ParseKeystore(keystore, passphrase)
	require.NoError(t, err)

	assert.Equal(t, privateKey.ed25519PrivateKey.keyData, ksPrivateKey.ed25519PrivateKey.keyData)
}

func TestUnitPrivateKeyReadKeystore(t *testing.T) {
	t.Parallel()

	actualPrivateKey, err := PrivateKeyFromStringEd25519(testKeystoreKeyString)
	require.NoError(t, err)

	keystoreReader := bytes.NewReader([]byte(testKeystore))

	privateKey, err := PrivateKeyReadKeystore(keystoreReader, passphrase)
	require.NoError(t, err)

	assert.Equal(t, actualPrivateKey.ed25519PrivateKey.keyData, privateKey.ed25519PrivateKey.keyData)
}

func TestUnitPrivateKeyFromPem(t *testing.T) {
	t.Parallel()

	actualPrivateKey, err := PrivateKeyFromString(testPrivateKeyStr)
	require.NoError(t, err)

	privateKey, err := PrivateKeyFromPem([]byte(pemString), "")
	require.NoError(t, err)

	assert.Equal(t, actualPrivateKey, privateKey)
}

func TestUnitPrivateKeyFromPemInvalid(t *testing.T) {
	t.Parallel()

	_, err := PrivateKeyFromPem([]byte("invalid"), "")
	assert.Error(t, err)
}

func TestUnitPrivateKeyFromPemWithPassphrase(t *testing.T) {
	t.Parallel()

	actualPrivateKey, err := PrivateKeyFromString(testPrivateKeyStr)
	require.NoError(t, err)

	privateKey, err := PrivateKeyFromPem([]byte(encryptedPem), pemPassphrase)
	require.NoError(t, err)

	assert.Equal(t, actualPrivateKey, privateKey)
}

func TestUnitECDSAPrivateKeyFromUnencryptedUncompressedPEM(t *testing.T) {
	unencryptedUncompressed := "-----BEGIN EC PRIVATE KEY-----\n" +
		"MHQCAQEEIG8I+jKi+iGVa7ttbfnlnML5AdvPugbgBWnseYjrle6qoAcGBSuBBAAK\n" +
		"oUQDQgAEqf5BmMeBzkU1Ra9UAbZJo3tytVOlb7erTc36LRLP20mOLU7+mFY+3Cfe\n" +
		"fAZgBtPXRAmDtRvYGODswAalW85GKA==\n" +
		"-----END EC PRIVATE KEY-----"

	privateKey, err := PrivateKeyFromPem([]byte(unencryptedUncompressed), "")
	require.NoError(t, err)

	assert.Equal(t, "6f08fa32a2fa21956bbb6d6df9e59cc2f901dbcfba06e00569ec7988eb95eeaa", privateKey.StringRaw())
}
func TestUnitECDSAPrivateKeyFromUnencryptedCompressedPEM(t *testing.T) {
	unencryptedCompressed := "-----BEGIN EC PRIVATE KEY-----\n" +
		"MFQCAQEEIOHyhclwHbha3f281Kvd884rhBzltxGJxCZyaQCagH9joAcGBSuBBAAK\n" +
		"oSQDIgACREr6gFZa4K7hBP+bA25VdgQ+0ABFgM+g5RYw/W6T1Og=\n" +
		"-----END EC PRIVATE KEY-----"

	privateKey, err := PrivateKeyFromPem([]byte(unencryptedCompressed), "")
	require.NoError(t, err)

	assert.Equal(t, "e1f285c9701db85addfdbcd4abddf3ce2b841ce5b71189c4267269009a807f63", privateKey.StringRaw())
}
func TestUnitECDSAPrivateKeyFromEncryptedUncompressedPEM(t *testing.T) {
	encryptedUncompressed := "-----BEGIN EC PRIVATE KEY-----\n" +
		"Proc-Type: 4,ENCRYPTED\n" +
		"DEK-Info: AES-128-CBC,0046A9EED8D16F0CAA66A197CE8BE8BD\n" +
		"\n" +
		"9VU9gReUmrn4XywjMx0F0A3oGzpHIksEXma72TCSdcxI7zHy0mtzuGq4Wd25O38s\n" +
		"H9c6kvhTPS1N/c6iNhx154B0HUoND8jvAvfxbGR/R87vpZJsOoKCmRxGqrxG8HER\n" +
		"FIHQ1jy16DrAbU95kDyLsiF1dy2vUY/HoqFZwxl/IVc=\n" +
		"-----END EC PRIVATE KEY-----"

	privateKey, err := PrivateKeyFromPem([]byte(encryptedUncompressed), "asdasd123")
	require.NoError(t, err)

	assert.Equal(t, "cf49eb5206c1b0468854d6ea7b370590619625514f71ff93608a18465e4012ad", privateKey.StringRaw())
}
func TestUnitECDSAPrivateKeyFromEncryptedCompressedPEM(t *testing.T) {
	encryptedCompressed := "-----BEGIN EC PRIVATE KEY-----\n" +
		"Proc-Type: 4,ENCRYPTED\n" +
		"DEK-Info: AES-128-CBC,4A9B3B987EC2EFFA405818327D14FFF7\n" +
		"\n" +
		"Wh756RkK5fn1Ke2denR1OYfqE9Kr4BXhgrEMTU/6o0SNhMULUhWGHrCWvmNeEQwp\n" +
		"ZVZYUxgYoTlJBeREzKAZithcvxIcTbQfLABo1NZbjA6YKqAqlGpM6owwL/f9e2ST\n" +
		"-----END EC PRIVATE KEY-----"

	privateKey, err := PrivateKeyFromPem([]byte(encryptedCompressed), "asdasd123")
	require.NoError(t, err)

	assert.Equal(t, "c0d3e16ba5a1abbeac4cd327a3c3c1cc10438431d0bac019054e573e67768bb5", privateKey.StringRaw())
}

func TestUnitPrivateKeyECDSASign(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)

	hash := crypto.Keccak256Hash([]byte("aaa"))
	sig := key.Sign([]byte("aaa"))
	s2 := crypto.VerifySignature(key.ecdsaPrivateKey._PublicKey()._BytesRaw(), hash.Bytes(), sig)
	require.True(t, s2)
}

func DisabledTestUnitPrivateKeyECDSASign(t *testing.T) {
	t.Parallel()

	message := []byte("hello world")
	key, err := PrivateKeyFromStringECDSA("8776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048")
	require.NoError(t, err)

	sig := key.Sign(message)

	require.Equal(t, hex.EncodeToString(sig), "f3a13a555f1f8cd6532716b8f388bd4e9d8ed0b252743e923114c0c6cbfe414cf791c8e859afd3c12009ecf2cb20dacf01636d80823bcdbd9ec1ce59afe008f0")
	require.True(t, key.PublicKey().Verify(message, sig))
}

func TestUnitPrivateKeyEd25519FromString(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	key2, err := PrivateKeyFromString(key.String())
	require.NoError(t, err)

	require.Equal(t, key2.String(), key.String())
}

func TestUnitPrivateKeyEd25519FromStringRaw(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	key2, err := PrivateKeyFromStringEd25519(key.StringRaw())
	require.NoError(t, err)

	require.Equal(t, key2.String(), key.String())
}

func TestUnitPrivateKeyEd25519FromStringDer(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	key2, err := PrivateKeyFromStringEd25519(key.StringDer())
	require.NoError(t, err)

	require.Equal(t, key2.StringDer(), key.StringDer())
}

func TestUnitPublicKeyEd25519FromString(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	publicKey := key.PublicKey()
	publicKey2, err := PublicKeyFromStringEd25519(publicKey.String())
	require.NoError(t, err)
	require.Equal(t, publicKey2.String(), publicKey.String())
}

func TestUnitPublicKeyEd25519FromStringRaw(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	publicKey := key.PublicKey()
	publicKey2, err := PublicKeyFromStringEd25519(publicKey.StringRaw())
	require.NoError(t, err)

	require.Equal(t, publicKey2.String(), publicKey.String())
}

func TestUnitPublicKeyEd25519FromStringDer(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	publicKey := key.PublicKey()
	publicKey2, err := PublicKeyFromStringEd25519(publicKey.StringDer())
	require.NoError(t, err)

	require.Equal(t, publicKey2.StringDer(), publicKey.StringDer())
}

func TestUnitPrivateKeyECDSAFromString(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	key2, err := PrivateKeyFromString(key.String())
	require.NoError(t, err)

	require.Equal(t, key2.String(), key.String())
}

func TestUnitPrivateKeyECDSAFromStringWithPrefix(t *testing.T) {
	t.Parallel()

	_, err := PrivateKeyFromStringECDSA("0x7e18ba654522ff6ca5314d83354aaeca416abaef89ab27ffe01ecf5830ae8730")
	require.NoError(t, err)
}

func TestUnitPrivateKeyECDSAFromStringRaw(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	key2, err := PrivateKeyFromStringECDSA(key.StringRaw())
	require.NoError(t, err)

	require.Equal(t, key2.String(), key.String())
}

func TestUnitPrivateKeyECDSAFromStringDer(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	key2, err := PrivateKeyFromStringECDSA(key.StringDer())
	require.NoError(t, err)

	require.Equal(t, key2.StringDer(), key.StringDer())
}

func TestUnitPrivateKeyECDSAFromStringLegacyDer(t *testing.T) {
	key, err := PrivateKeyFromString("3030020100300706052b8104000a04220420c78aa6584228422d2edb027dec01ff374eb0720e32be2da827d51ed0711d4f8c")
	require.NoError(t, err)
	key2, err := PrivateKeyFromStringECDSA(key.StringDer())
	require.NoError(t, err)

	require.Equal(t, key2.StringDer(), key.StringDer())
}

func TestUnitPrivateKeyECDSAFromStringDerUncompressed(t *testing.T) {
	key := "3074020101042052DDBE84838D865C18F043489C285C0B62041389569E8A62530" +
		"56D0FFBEB7F5DA00706052B8104000AA144034200049D7DABF194F47CD5756BCC5231C821" +
		"B34AFA03046EF7F645A2D026BF38D0332AF958B7840607EE4853DED1D372CF89FF131C788" +
		"EE22644CF642503DF82EEF652"
	expectedDerExport := "3054020101042052ddbe84838d865c18f043489c285c0b62041389569e8" +
		"a6253056d0ffbeb7f5da00706052b8104000aa124032200029d7dabf194f47cd5756bcc5231c821b" +
		"34afa03046ef7f645a2d026bf38d0332a"
	key2, err := PrivateKeyFromStringECDSA(key)
	require.NoError(t, err)

	require.Equal(t, key2.StringDer(), expectedDerExport)
}

func TestUnitPublicKeyECDSAFromString(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := key.PublicKey()
	publicKey2, err := PublicKeyFromStringECDSA(publicKey.String())
	require.NoError(t, err)
	require.Equal(t, publicKey2.String(), publicKey.String())
}

func TestUnitPublicKeyECDSAFromStringRaw(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := key.PublicKey()
	publicKey2, err := PublicKeyFromStringECDSA(publicKey.StringRaw())
	require.NoError(t, err)

	require.Equal(t, publicKey2.String(), publicKey.String())
}

func TestUnitPublicKeyECDSAFromStringDer(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	publicKey := key.PublicKey()
	publicKey2, err := PublicKeyFromStringECDSA(publicKey.StringDer())
	require.NoError(t, err)

	require.Equal(t, publicKey2.StringDer(), publicKey.StringDer())
}

func TestUnitPublicKeyECDSAFromStringLegacyDer(t *testing.T) {
	publicKey, err := PublicKeyFromStringECDSA("302d300706052b8104000a0322000298c5d6efb814ead640467934b5ef9a02b81d3c483719675cb261cc5fde3edd57")
	require.NoError(t, err)
	publicKey2, err := PublicKeyFromStringECDSA(publicKey.StringDer())
	require.NoError(t, err)

	require.Equal(t, publicKey2.StringDer(), publicKey.StringDer())
}

func TestUnitPrivateKeyFromBytesDerECDSA(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	bytes := key.BytesDer()
	key2, err := PrivateKeyFromBytesDer(bytes)
	require.NoError(t, err)
	require.True(t, strings.HasPrefix(key2.String(), _ECDSAPrivatePrefix))
}

func TestUnitPrivateKeyFromBytesDerECDSAUncompressed(t *testing.T) {
	key := "3074020101042052DDBE84838D865C18F043489C285C0B62041389569E8A62530" +
		"56D0FFBEB7F5DA00706052B8104000AA144034200049D7DABF194F47CD5756BCC5231C821" +
		"B34AFA03046EF7F645A2D026BF38D0332AF958B7840607EE4853DED1D372CF89FF131C788" +
		"EE22644CF642503DF82EEF652"
	bytes, err := hex.DecodeString(key)
	require.NoError(t, err)
	key2, err := PrivateKeyFromBytesDer(bytes)
	require.NoError(t, err)
	fmt.Printf("key2.String(): %v\n", key2.String())
	require.True(t, strings.HasPrefix(key2.String(), _ECDSAPrivatePrefix))
}

func TestUnitPrivateKeyFromBytesDerEd25519(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	bytes := key.BytesDer()
	key2, err := PrivateKeyFromBytesDer(bytes)
	require.NoError(t, err)
	require.True(t, strings.HasPrefix(key2.String(), _Ed25519PrivateKeyPrefix))
}

func TestUnitPublicKeyFromBytesDerECDSA(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	pkey := key.PublicKey()
	bytes := pkey.BytesDer()
	pkey2, err := PublicKeyFromBytesDer(bytes)
	require.NoError(t, err)
	require.True(t, strings.HasPrefix(pkey2.String(), _ECDSAPubKeyPrefix))
}

func TestUnitPublicKeyFromBytesDerEd25519(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	pkey := key.PublicKey()
	bytes := pkey.BytesDer()
	pkey2, err := PublicKeyFromBytesDer(bytes)
	require.NoError(t, err)
	require.True(t, strings.HasPrefix(pkey2.String(), _Ed25519PubKeyPrefix))
}

func TestUnitPrivateKeyFromStringDerEd25519(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	key2, err := PrivateKeyFromStringDer(key.StringDer())
	require.NoError(t, err)
	require.Equal(t, key2.String(), key.String())
}

func TestUnitPrivateKeyFromStringDerECDSA(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	key2, err := PrivateKeyFromStringDer(key.StringDer())
	require.NoError(t, err)
	require.Equal(t, key2.String(), key.String())
}

func TestUnitPrivateKeyECDSAFromBytes(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	key2, err := PrivateKeyFromBytes(key.Bytes())
	require.NoError(t, err)
	require.Equal(t, key2.String(), key.String())
}

func TestUnitPrivateKeyEd25519FromBytes(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	key2, err := PrivateKeyFromBytes(key.Bytes())
	require.NoError(t, err)
	require.Equal(t, key2.String(), key.String())
}

func TestUnitPrivateKeyFromBytesECDSA(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	key2, err := PrivateKeyFromBytesECDSA(key.Bytes())
	require.NoError(t, err)
	require.Equal(t, key2.String(), key.String())
}

func TestUnitPrivateKeyFromBytesEd25519(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	key2, err := PrivateKeyFromBytesEd25519(key.Bytes())
	require.NoError(t, err)
	require.Equal(t, key2.String(), key.String())
}

func TestUnitPublicKeyFromBytesECDSA(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	key2, err := PublicKeyFromBytesECDSA(key.PublicKey().Bytes())
	require.NoError(t, err)
	require.Equal(t, key.PublicKey().String(), key2.String())
}

func TestUnitPublicKeyFromBytesEd25519(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	key2, err := PublicKeyFromBytesEd25519(key.PublicKey().Bytes())
	require.NoError(t, err)
	require.Equal(t, key.PublicKey().String(), key2.String())
}

func TestUnitPublicKeyECDSAFromBytes(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	key2, err := PublicKeyFromBytes(key.PublicKey().Bytes())
	require.NoError(t, err)
	require.Equal(t, key.PublicKey().String(), key2.String())
}

func TestUnitPublicKeyEd25519FromBytes(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	key2, err := PublicKeyFromBytes(key.PublicKey().Bytes())
	require.NoError(t, err)
	require.Equal(t, key.PublicKey().String(), key2.String())
}

func TestUnitPrivateKeyBytesRawEd25519(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	require.Equal(t, key.ed25519PrivateKey.keyData[0:32], key.BytesRaw())
}

func TestUnitPrivateKeyBytesRawECDSA(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	require.Equal(t, key.ecdsaPrivateKey.keyData.D.Bytes(), key.BytesRaw())
}

func TestUnitPublicKeyBytesRawEd25519(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	require.Equal(t, key.PublicKey().ed25519PublicKey.keyData, key.PublicKey().BytesRaw())
}

func TestUnitPublicKeyBytesRawECDSA(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	require.Equal(t, crypto.CompressPubkey(&key.ecdsaPrivateKey.keyData.PublicKey), key.PublicKey().BytesRaw())
}

func TestUnitECDSAPrivateKeyFromBytesInvalidLength(t *testing.T) {
	invalidPrivateKey := make([]byte, 31)
	_, err := _ECDSAPrivateKeyFromBytes(invalidPrivateKey)
	require.Error(t, err)
	expectedError := fmt.Sprintf("invalid private key length: %v bytes", len(invalidPrivateKey))
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitECDSAPrivateKeyFromBytesRawInvalidLength(t *testing.T) {
	invalidPrivateKey := make([]byte, 31)
	_, err := _ECDSAPrivateKeyFromBytesRaw(invalidPrivateKey)
	require.Error(t, err)
	expectedError := fmt.Sprintf("invalid private key length: %v bytes", len(invalidPrivateKey))
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitECDSAPrivateKeyFromBytesRawInvalidKey(t *testing.T) {
	invalidPrivateKey := make([]byte, 32)
	_, err := _ECDSAPrivateKeyFromBytesRaw(invalidPrivateKey)
	require.Error(t, err)
	expectedError := "invalid private key, zero or negative"
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnit_ECDSAPrivateKeyFromBytesDerInvalidKey(t *testing.T) {
	invalidPrivateKey := make([]byte, 32)
	_, err := _ECDSAPrivateKeyFromBytesDer(invalidPrivateKey)
	require.Error(t, err)
}

func Test_EcdsaPrivateKeyFromBytesDer_InvalidData(t *testing.T) {
	key, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)
	der := key.BytesDer()
	trailingBytes := []byte{0x01, 0x02, 0x03}
	derWithTrailingBytes := append(der, trailingBytes...)
	_, err = _ECDSAPrivateKeyFromBytesDer(derWithTrailingBytes)
	require.Error(t, err)
	expectedError := "x509: trailing data after ASN.1 of public-key"
	if err == nil || err.Error() != expectedError {
		t.Fatalf("Expected error %q, got %q", expectedError, err)
	}
}

func TestUnitECDSAPublicKeyFromBytesInvalidLength(t *testing.T) {
	invalidPrivateKey := make([]byte, 31)
	_, err := _ECDSAPublicKeyFromBytes(invalidPrivateKey)
	require.Error(t, err)
	expectedError := fmt.Sprintf("invalid compressed ECDSA public key length: %v bytes", len(invalidPrivateKey))
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitECDSAPublicKeyFromBytesRawInvalidLength(t *testing.T) {
	_, err := _ECDSAPublicKeyFromBytesRaw(nil)
	require.Error(t, err)
	invalidPrivateKey := make([]byte, 31)
	_, err = _ECDSAPublicKeyFromBytesRaw(invalidPrivateKey)
	require.Error(t, err)
	expectedError := fmt.Sprintf("invalid public key length: %v bytes", len(invalidPrivateKey))
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitECDSAPublicKeyFromBytesRawInvalidKey(t *testing.T) {
	invalidPrivateKey := make([]byte, 33)
	_, err := _ECDSAPublicKeyFromBytesRaw(invalidPrivateKey)
	require.Error(t, err)
	expectedError := "invalid public key"
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitECDSAPublicKeyFromBytesDerInvalidKey(t *testing.T) {
	_, err := _ECDSAPublicKeyFromBytesDer(nil)
	require.Error(t, err)
	invalidPrivateKey := make([]byte, 33)
	_, err = _ECDSAPublicKeyFromBytesDer(invalidPrivateKey)
	require.Error(t, err)
}

func TestUnitECDSAPublicKeyFromBytesDerWrongAlgorithmOID(t *testing.T) {
	hexStr := "3036301006072a8648ce3d020206052b8104000a032200021ef6d7f710abb6f137f1c0dd87c6fd0200486c0754273d628cde6688e0bc9bf5"
	bytes, err := hex.DecodeString(hexStr)
	require.NoError(t, err)
	_, err = _ECDSAPublicKeyFromBytesDer(bytes)
	expectedError := "public key is not an ECDSA public key"
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitECDSAPublicKeyFromBytesDerWrongCurve(t *testing.T) {
	hexStr := "3036301006072a8648ce3d020106052b8104000b03220002f3c22171a370bd5eba014c4ffa2002c4de4e0d8545ab964cda10467f23cfa2e0"
	bytes, err := hex.DecodeString(hexStr)
	require.NoError(t, err)
	_, err = _ECDSAPublicKeyFromBytesDer(bytes)
	expectedError := "public key is not a secp256k1 public key"
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitEd25519PrivateKeyFromBytesDerWrongLength(t *testing.T) {
	invalidPrivateKey := make([]byte, 33)
	_, err := _Ed25519PrivateKeyFromBytesDer(invalidPrivateKey)
	require.Error(t, err)
	expectedError := fmt.Sprintf("invalid private key length: %v byt", len(invalidPrivateKey))
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitEd25519PrivateKeyFromBytesDerWrongKey(t *testing.T) {
	invalidPrivateKey := make([]byte, 32)
	_, err := _Ed25519PublicKeyFromBytesDer(invalidPrivateKey)
	require.Error(t, err)
}

func TestUnitEd25519PublicKeyFromBytesDerWrongAlgorithmOID(t *testing.T) {
	hexStr := "3036301006072a8648ce3d020206052b8104000a032200021ef6d7f710abb6f137f1c0dd87c6fd0200486c0754273d628cde6688e0bc9bf5"
	bytes, err := hex.DecodeString(hexStr)
	require.NoError(t, err)
	_, err = _Ed25519PublicKeyFromBytesDer(bytes)
	expectedError := "invalid algorithm identifier, expected Ed25519"
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitEd25519PublicKeyFromBytesDerWrongCurve(t *testing.T) {
	bytes, _ := hex.DecodeString("3053300506032b6570032100b6ecf351b0d0d8fce400647f4944621b411e97ae83a249fcadb33cf165f40ca2")
	modifiedBytes := append(bytes[:14], bytes[15:]...)
	_Ed25519PublicKeyFromBytesDer(modifiedBytes)
}

func TestUnitEd25519PublicKeyFromStringWrongLength(t *testing.T) {
	_, err := _Ed25519PublicKeyFromString("303")
	require.Error(t, err)
	expectedError := "encoding/hex: odd length hex string"
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitEd25519PublicKeyFromBytesRawWrongLength(t *testing.T) {
	_, err := _Ed25519PublicKeyFromBytesRaw(nil)
	require.Error(t, err)
	expectedError := "byte array can't be null"
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
	invalidPrivateKey := make([]byte, 33)
	_, err = _Ed25519PublicKeyFromBytesRaw(invalidPrivateKey)
	require.Error(t, err)
	expectedError = fmt.Sprintf("invalid public key length: %v bytes", len(invalidPrivateKey))
	if err.Error() != expectedError {
		t.Errorf("expected error message %q, but got %q", expectedError, err.Error())
	}
}

func TestUnitPrivateKeyECDSASignTransaction(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyGenerateEcdsa()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	txID := TransactionIDGenerate(AccountID{Account: 123})

	tx, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTransactionID(txID).
		SetInitialBalance(newBalance).
		SetMaxAutomaticTokenAssociations(100).
		Freeze()
	require.NoError(t, err)

	_, err = newKey.SignTransaction(&tx.Transaction)
	require.NoError(t, err)
}

func TestUnitPublicKeyFromPrivateKeyString(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyFromStringECDSA("30540201010420ac318ea8ff8d991ab2f16172b4738e74dc35a56681199cfb1c0cb2e7cb560ffda00706052b8104000aa124032200036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4")
	require.NoError(t, err)
	require.Equal(t, "3036301006072a8648ce3d020106052b8104000a032200036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4", key.PublicKey().String())
}

func TestUnitPublicKeyToEthereumAddress(t *testing.T) {
	t.Parallel()

	byt, err := hex.DecodeString("03af80b90d25145da28c583359beb47b21796b2fe1a23c1511e443e7a64dfdb27d")
	require.NoError(t, err)
	key, err := PublicKeyFromBytesECDSA(byt)
	ethereumAddress := key.ToEthereumAddress()
	require.Equal(t, ethereumAddress, "627306090abab3a6e1400e9345bc60c78a8bef57")
}

func TestSlip10Ed25519Vector1(t *testing.T) {
	t.Parallel()

	// https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-1-for-ed25519
	test1PrivateKey := "2b4be7f19ee27bbf30c667b642d5f4aa69fd169872f8fc3059c08ebae2eb19e7"
	test1PublicKey := "a4b2856bfec510abab89753fac1ac0e1112364e7d250545963f135f2a33188ed"
	test1ChainCode := "90046a93de5380a72b5e45010748567d5ea02bbf6522f979e05c0d8d8ca9fffb"
	test2PrivateKey := "68e0fe46dfb67e368c75379acec591dad19df3cde26e63b93a8e704f1dade7a3"
	test2PublicKey := "8c8a13df77a28f3445213a0f432fde644acaa215fc72dcdf300d5efaa85d350c"
	test2ChainCode := "8b59aa11380b624e81507a27fedda59fea6d0b779a778918a2fd3590e16e9c69"
	test3PrivateKey := "b1d0bad404bf35da785a64ca1ac54b2617211d2777696fbffaf208f746ae84f2"
	test3PublicKey := "1932a5270f335bed617d5b935c80aedb1a35bd9fc1e31acafd5372c30f5c1187"
	test3ChainCode := "a320425f77d1b5c2505a6b1b27382b37368ee640e3557c315416801243552f14"
	test4PrivateKey := "92a5b23c0b8a99e37d07df3fb9966917f5d06e02ddbd909c7e184371463e9fc9"
	test4PublicKey := "ae98736566d30ed0e9d2f4486a64bc95740d89c7db33f52121f8ea8f76ff0fc1"
	test4ChainCode := "2e69929e00b5ab250f49c3fb1c12f252de4fed2c1db88387094a0f8c4c9ccd6c"
	test5PrivateKey := "30d1dc7e5fc04c31219ab25a27ae00b50f6fd66622f6e9c913253d6511d1e662"
	test5PublicKey := "8abae2d66361c879b900d204ad2cc4984fa2aa344dd7ddc46007329ac76c429c"
	test5ChainCode := "8f6d87f93d750e0efccda017d662a1b31a266e4a6f5993b15f5c1f07f74dd5cc"
	test6PrivateKey := "8f94d394a8e8fd6b1bc2f3f49f5c47e385281d5c17e65324b0f62483e37e8793"
	test6PublicKey := "3c24da049451555d51a7014a37337aa4e12d41e485abccfa46b47dfb2af54b7a"
	test6ChainCode := "68789923a0cac2cd5a29172a475fe9e0fb14cd6adb5ad98a3fa70333e7afa230"

	seed, err := hex.DecodeString("000102030405060708090a0b0c0d0e0f")
	assert.NoError(t, err)

	//Chain m
	key1, err := PrivateKeyFromSeedEd25519(seed)
	assert.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)
	assert.Equal(t, hex.EncodeToString(key1.ed25519PrivateKey.chainCode), test1ChainCode)

	// Chain m/0'
	key2, err := key1.Derive(0)
	assert.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)
	assert.Equal(t, hex.EncodeToString(key2.ed25519PrivateKey.chainCode), test2ChainCode)

	// Chain m/0'/1'
	key3, err := key2.Derive(1)
	assert.NoError(t, err)
	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)
	assert.Equal(t, hex.EncodeToString(key3.ed25519PrivateKey.chainCode), test3ChainCode)

	// Chain m/0'/1'/2'
	key4, err := key3.Derive(2)
	assert.NoError(t, err)
	assert.Equal(t, key4.StringRaw(), test4PrivateKey)
	assert.Equal(t, key4.PublicKey().StringRaw(), test4PublicKey)
	assert.Equal(t, hex.EncodeToString(key4.ed25519PrivateKey.chainCode), test4ChainCode)

	//Chain m/0'/1'/2'/2'
	key5, err := key4.Derive(2)
	assert.NoError(t, err)
	assert.Equal(t, key5.StringRaw(), test5PrivateKey)
	assert.Equal(t, key5.PublicKey().StringRaw(), test5PublicKey)
	assert.Equal(t, hex.EncodeToString(key5.ed25519PrivateKey.chainCode), test5ChainCode)

	// Chain m/0'/1'/2'/2'/1000000000'
	key6, err := key5.Derive(1000000000)
	assert.NoError(t, err)
	assert.Equal(t, key6.StringRaw(), test6PrivateKey)
	assert.Equal(t, key6.PublicKey().StringRaw(), test6PublicKey)
	assert.Equal(t, hex.EncodeToString(key6.ed25519PrivateKey.chainCode), test6ChainCode)
}

func TestSlip10Ed25519Vector2(t *testing.T) {
	t.Parallel()

	// https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-2-for-ed25519
	test1PrivateKey := "171cb88b1b3c1db25add599712e36245d75bc65a1a5c9e18d76f9f2b1eab4012"
	test1PublicKey := "8fe9693f8fa62a4305a140b9764c5ee01e455963744fe18204b4fb948249308a"
	test1ChainCode := "ef70a74db9c3a5af931b5fe73ed8e1a53464133654fd55e7a66f8570b8e33c3b"
	test2PrivateKey := "1559eb2bbec5790b0c65d8693e4d0875b1747f4970ae8b650486ed7470845635"
	test2PublicKey := "86fab68dcb57aa196c77c5f264f215a112c22a912c10d123b0d03c3c28ef1037"
	test2ChainCode := "0b78a3226f915c082bf118f83618a618ab6dec793752624cbeb622acb562862d"
	test3PrivateKey := "ea4f5bfe8694d8bb74b7b59404632fd5968b774ed545e810de9c32a4fb4192f4"
	test3PublicKey := "5ba3b9ac6e90e83effcd25ac4e58a1365a9e35a3d3ae5eb07b9e4d90bcf7506d"
	test3ChainCode := "138f0b2551bcafeca6ff2aa88ba8ed0ed8de070841f0c4ef0165df8181eaad7f"
	test4PrivateKey := "3757c7577170179c7868353ada796c839135b3d30554bbb74a4b1e4a5a58505c"
	test4PublicKey := "2e66aa57069c86cc18249aecf5cb5a9cebbfd6fadeab056254763874a9352b45"
	test4ChainCode := "73bd9fff1cfbde33a1b846c27085f711c0fe2d66fd32e139d3ebc28e5a4a6b90"
	test5PrivateKey := "5837736c89570de861ebc173b1086da4f505d4adb387c6a1b1342d5e4ac9ec72"
	test5PublicKey := "e33c0f7d81d843c572275f287498e8d408654fdf0d1e065b84e2e6f157aab09b"
	test5ChainCode := "0902fe8a29f9140480a00ef244bd183e8a13288e4412d8389d140aac1794825a"
	test6PrivateKey := "551d333177df541ad876a60ea71f00447931c0a9da16f227c11ea080d7391b8d"
	test6PublicKey := "47150c75db263559a70d5778bf36abbab30fb061ad69f69ece61a72b0cfa4fc0"
	test6ChainCode := "5d70af781f3a37b829f0d060924d5e960bdc02e85423494afc0b1a41bbe196d4"

	seed, err := hex.DecodeString("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542")
	assert.NoError(t, err)

	// Chain m
	key1, err := PrivateKeyFromSeedEd25519(seed)
	assert.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)
	assert.Equal(t, hex.EncodeToString(key1.ed25519PrivateKey.chainCode), test1ChainCode)

	// Chain m/0'
	key2, err := key1.Derive(0)
	assert.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)
	assert.Equal(t, hex.EncodeToString(key2.ed25519PrivateKey.chainCode), test2ChainCode)

	// Chain m/0'/2147483647'
	key3, err := key2.Derive(2147483647)
	assert.NoError(t, err)
	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)
	assert.Equal(t, hex.EncodeToString(key3.ed25519PrivateKey.chainCode), test3ChainCode)

	// Chain m/0'/2147483647'/1'
	key4, err := key3.Derive(1)
	assert.NoError(t, err)
	assert.Equal(t, key4.StringRaw(), test4PrivateKey)
	assert.Equal(t, key4.PublicKey().StringRaw(), test4PublicKey)
	assert.Equal(t, hex.EncodeToString(key4.ed25519PrivateKey.chainCode), test4ChainCode)

	// Chain m/0'/2147483647'/1'/2147483646'
	key5, err := key4.Derive(2147483646)
	assert.NoError(t, err)
	assert.Equal(t, key5.StringRaw(), test5PrivateKey)
	assert.Equal(t, key5.PublicKey().StringRaw(), test5PublicKey)
	assert.Equal(t, hex.EncodeToString(key5.ed25519PrivateKey.chainCode), test5ChainCode)

	// Chain m/0'/2147483647'/1'/2147483646'/2'
	key6, err := key5.Derive(2)
	assert.NoError(t, err)
	assert.Equal(t, key6.StringRaw(), test6PrivateKey)
	assert.Equal(t, key6.PublicKey().StringRaw(), test6PublicKey)
	assert.Equal(t, hex.EncodeToString(key6.ed25519PrivateKey.chainCode), test6ChainCode)
}

func TestSlip10ECDSAVector1(t *testing.T) {
	t.Parallel()

	// https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-1-for-secp256k1
	test1PrivateKey := "e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35"
	test1PublicKey := "0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2"
	test1ChainCode := "873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508"
	test2PrivateKey := "edb2e14f9ee77d26dd93b4ecede8d16ed408ce149b6cd80b0715a2d911a0afea"
	test2PublicKey := "035a784662a4a20a65bf6aab9ae98a6c068a81c52e4b032c0fb5400c706cfccc56"
	test2ChainCode := "47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141"
	test3PrivateKey := "3c6cb8d0f6a264c91ea8b5030fadaa8e538b020f0a387421a12de9319dc93368"
	test3PublicKey := "03501e454bf00751f24b1b489aa925215d66af2234e3891c3b21a52bedb3cd711c"
	test3ChainCode := "2a7857631386ba23dacac34180dd1983734e444fdbf774041578e9b6adb37c19"
	test4PrivateKey := "cbce0d719ecf7431d88e6a89fa1483e02e35092af60c042b1df2ff59fa424dca"
	test4PublicKey := "0357bfe1e341d01c69fe5654309956cbea516822fba8a601743a012a7896ee8dc2"
	test4ChainCode := "04466b9cc8e161e966409ca52986c584f07e9dc81f735db683c3ff6ec7b1503f"
	test5PrivateKey := "0f479245fb19a38a1954c5c7c0ebab2f9bdfd96a17563ef28a6a4b1a2a764ef4"
	test5PublicKey := "02e8445082a72f29b75ca48748a914df60622a609cacfce8ed0e35804560741d29"
	test5ChainCode := "cfb71883f01676f587d023cc53a35bc7f88f724b1f8c2892ac1275ac822a3edd"
	test6PrivateKey := "471b76e389e528d6de6d816857e012c5455051cad6660850e58372a6c3e6e7c8"
	test6PublicKey := "022a471424da5e657499d1ff51cb43c47481a03b1e77f951fe64cec9f5a48f7011"
	test6ChainCode := "c783e67b921d2beb8f6b389cc646d7263b4145701dadd2161548a8b078e65e9e"

	seed, err := hex.DecodeString("000102030405060708090a0b0c0d0e0f")
	assert.NoError(t, err)

	// Chain m
	key1, err := PrivateKeyFromSeedECDSAsecp256k1(seed)
	assert.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)
	assert.Equal(t, hex.EncodeToString(key1.ecdsaPrivateKey.chainCode), test1ChainCode)

	// Chain m/0'
	key2, err := key1.Derive(ToHardenedIndex(0))
	assert.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)
	assert.Equal(t, hex.EncodeToString(key2.ecdsaPrivateKey.chainCode), test2ChainCode)

	// Chain m/0'/1
	key3, err := key2.Derive(1)
	assert.NoError(t, err)
	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)
	assert.Equal(t, hex.EncodeToString(key3.ecdsaPrivateKey.chainCode), test3ChainCode)

	// Chain m/0'/1/2'
	key4, err := key3.Derive(ToHardenedIndex(2))
	assert.NoError(t, err)
	assert.Equal(t, key4.StringRaw(), test4PrivateKey)
	assert.Equal(t, key4.PublicKey().StringRaw(), test4PublicKey)
	assert.Equal(t, hex.EncodeToString(key4.ecdsaPrivateKey.chainCode), test4ChainCode)

	// Chain m/0'/1/2'/2
	key5, err := key4.Derive(2)
	assert.NoError(t, err)
	assert.Equal(t, key5.StringRaw(), test5PrivateKey)
	assert.Equal(t, key5.PublicKey().StringRaw(), test5PublicKey)
	assert.Equal(t, hex.EncodeToString(key5.ecdsaPrivateKey.chainCode), test5ChainCode)

	// Chain m/0'/1/2'/2/1000000000
	key6, err := key5.Derive(1000000000)
	assert.NoError(t, err)
	assert.Equal(t, key6.StringRaw(), test6PrivateKey)
	assert.Equal(t, key6.PublicKey().StringRaw(), test6PublicKey)
	assert.Equal(t, hex.EncodeToString(key6.ecdsaPrivateKey.chainCode), test6ChainCode)
}

func TestSlip10ECDSAVector2(t *testing.T) {
	t.Parallel()

	// https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-2-for-secp256k1
	test1PrivateKey := "4b03d6fc340455b363f51020ad3ecca4f0850280cf436c70c727923f6db46c3e"
	test1PublicKey := "03cbcaa9c98c877a26977d00825c956a238e8dddfbd322cce4f74b0b5bd6ace4a7"
	test1ChainCode := "60499f801b896d83179a4374aeb7822aaeaceaa0db1f85ee3e904c4defbd9689"
	test2PrivateKey := "abe74a98f6c7eabee0428f53798f0ab8aa1bd37873999041703c742f15ac7e1e"
	test2PublicKey := "02fc9e5af0ac8d9b3cecfe2a888e2117ba3d089d8585886c9c826b6b22a98d12ea"
	test2ChainCode := "f0909affaa7ee7abe5dd4e100598d4dc53cd709d5a5c2cac40e7412f232f7c9c"
	test3PrivateKey := "877c779ad9687164e9c2f4f0f4ff0340814392330693ce95a58fe18fd52e6e93"
	test3PublicKey := "03c01e7425647bdefa82b12d9bad5e3e6865bee0502694b94ca58b666abc0a5c3b"
	test3ChainCode := "be17a268474a6bb9c61e1d720cf6215e2a88c5406c4aee7b38547f585c9a37d9"
	test4PrivateKey := "704addf544a06e5ee4bea37098463c23613da32020d604506da8c0518e1da4b7"
	test4PublicKey := "03a7d1d856deb74c508e05031f9895dab54626251b3806e16b4bd12e781a7df5b9"
	test4ChainCode := "f366f48f1ea9f2d1d3fe958c95ca84ea18e4c4ddb9366c336c927eb246fb38cb"
	test5PrivateKey := "f1c7c871a54a804afe328b4c83a1c33b8e5ff48f5087273f04efa83b247d6a2d"
	test5PublicKey := "02d2b36900396c9282fa14628566582f206a5dd0bcc8d5e892611806cafb0301f0"
	test5ChainCode := "637807030d55d01f9a0cb3a7839515d796bd07706386a6eddf06cc29a65a0e29"
	test6PrivateKey := "bb7d39bdb83ecf58f2fd82b6d918341cbef428661ef01ab97c28a4842125ac23"
	test6PublicKey := "024d902e1a2fc7a8755ab5b694c575fce742c48d9ff192e63df5193e4c7afe1f9c"
	test6ChainCode := "9452b549be8cea3ecb7a84bec10dcfd94afe4d129ebfd3b3cb58eedf394ed271"

	seed, err := hex.DecodeString("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542")
	assert.NoError(t, err)

	// Chain m
	key1, err := PrivateKeyFromSeedECDSAsecp256k1(seed)
	assert.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)
	assert.Equal(t, hex.EncodeToString(key1.ecdsaPrivateKey.chainCode), test1ChainCode)

	// Chain m/0
	key2, err := key1.Derive(0)
	assert.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)
	assert.Equal(t, hex.EncodeToString(key2.ecdsaPrivateKey.chainCode), test2ChainCode)

	// Chain m/0/2147483647'
	key3, err := key2.Derive(ToHardenedIndex(2147483647))
	assert.NoError(t, err)
	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)
	assert.Equal(t, hex.EncodeToString(key3.ecdsaPrivateKey.chainCode), test3ChainCode)

	// Chain m/0/2147483647'/1
	key4, err := key3.Derive(1)
	assert.NoError(t, err)
	assert.Equal(t, key4.StringRaw(), test4PrivateKey)
	assert.Equal(t, key4.PublicKey().StringRaw(), test4PublicKey)
	assert.Equal(t, hex.EncodeToString(key4.ecdsaPrivateKey.chainCode), test4ChainCode)

	// Chain m/0/2147483647'/1/2147483646'
	key5, err := key4.Derive(ToHardenedIndex(2147483646))
	assert.NoError(t, err)
	assert.Equal(t, key5.StringRaw(), test5PrivateKey)
	assert.Equal(t, key5.PublicKey().StringRaw(), test5PublicKey)
	assert.Equal(t, hex.EncodeToString(key5.ecdsaPrivateKey.chainCode), test5ChainCode)

	// Chain m/0/2147483647'/1/2147483646'/2
	key6, err := key5.Derive(2)
	assert.NoError(t, err)
	assert.Equal(t, key6.StringRaw(), test6PrivateKey)
	assert.Equal(t, key6.PublicKey().StringRaw(), test6PublicKey)
	assert.Equal(t, hex.EncodeToString(key6.ecdsaPrivateKey.chainCode), test6ChainCode)
}

func TestFromBytesEd25519(t *testing.T) {
	keyBytes, _ := hex.DecodeString("0011223344556677889900112233445566778899001122334455667788990011")
	protoKey := &services.Key{
		Key: &services.Key_Ed25519{Ed25519: keyBytes},
	}
	bytes, err := proto.Marshal(protoKey)
	require.NoError(t, err)

	cut, err := KeyFromBytes(bytes)
	require.NoError(t, err)

	assert.IsType(t, PublicKey{}, cut)
	cutBytes, _ := KeyToBytes(cut.(PublicKey).ed25519PublicKey)
	assert.Equal(t, keyBytes, cutBytes[2:])
}

func TestFromBytesECDSA(t *testing.T) {
	keyBytes, _ := hex.DecodeString("3a21034e0441201f2bf9c7d9873c2a9dc3fd451f64b7c05e17e4d781d916e3a11dfd99")

	cut, err := KeyFromBytes(keyBytes)
	require.NoError(t, err)

	assert.IsType(t, PublicKey{}, cut)
	cutBytes, _ := KeyToBytes(cut.(PublicKey).ecdsaPublicKey)
	assert.Equal(t, keyBytes, cutBytes)
}

func TestFromBytesKeyList(t *testing.T) {
	keyBytes1, _ := hex.DecodeString("0011223344556677889900112233445566778899001122334455667788990011")
	keyBytes2, _ := hex.DecodeString("aa11223344556677889900112233445566778899001122334455667788990011")

	protoKeyList := &services.KeyList{
		Keys: []*services.Key{
			{Key: &services.Key_Ed25519{Ed25519: keyBytes1}},
			{Key: &services.Key_Ed25519{Ed25519: keyBytes2}},
		},
	}

	protoKey := &services.Key{
		Key: &services.Key_KeyList{KeyList: protoKeyList},
	}
	bytes, err := proto.Marshal(protoKey)
	require.NoError(t, err)

	cut, err := KeyFromBytes(bytes)
	require.NoError(t, err)

	assert.IsType(t, &KeyList{}, cut)

	keyList := cut.(*KeyList)
	actual := keyList._ToProtoKey().GetKeyList()

	assert.Len(t, actual.Keys, 2)
	assert.Equal(t, keyBytes1, actual.Keys[0].GetEd25519())
	assert.Equal(t, keyBytes2, actual.Keys[1].GetEd25519())
}

func TestFromBytesThresholdKey(t *testing.T) {
	keyBytes1, _ := hex.DecodeString("0011223344556677889900112233445566778899001122334455667788990011")
	keyBytes2, _ := hex.DecodeString("aa11223344556677889900112233445566778899001122334455667788990011")

	protoKeyList := &services.KeyList{
		Keys: []*services.Key{
			{Key: &services.Key_Ed25519{Ed25519: keyBytes1}},
			{Key: &services.Key_Ed25519{Ed25519: keyBytes2}},
		},
	}

	protoThresholdKey := &services.ThresholdKey{
		Threshold: 1,
		Keys:      protoKeyList,
	}

	protoKey := &services.Key{
		Key: &services.Key_ThresholdKey{ThresholdKey: protoThresholdKey},
	}
	bytes, err := proto.Marshal(protoKey)
	require.NoError(t, err)

	cut, err := KeyFromBytes(bytes)
	require.NoError(t, err)

	assert.IsType(t, &KeyList{}, cut)

	thresholdKey := cut.(*KeyList)
	actual := thresholdKey._ToProtoKey().GetThresholdKey()

	assert.Equal(t, uint32(1), actual.Threshold)
	assert.Len(t, actual.Keys.Keys, 2)
	assert.Equal(t, keyBytes1, actual.Keys.Keys[0].GetEd25519())
	assert.Equal(t, keyBytes2, actual.Keys.Keys[1].GetEd25519())
}

func TestThrowsUnsupportedKeyFromBytes(t *testing.T) {
	keyBytes := []byte{0, 1, 2}
	protoKey := &services.Key{
		Key: &services.Key_RSA_3072{RSA_3072: keyBytes},
	}
	bytes, err := proto.Marshal(protoKey)
	require.NoError(t, err)

	_, err = KeyFromBytes(bytes)
	assert.Error(t, err)
	assert.Equal(t, "key type not implemented: &{[0 1 2]}", err.Error())
}

func TestStringMethod(t *testing.T) {
	ecdsaPrivateKey, _ := _GenerateECDSAPrivateKey()
	ecdsaPublicKey := ecdsaPrivateKey._PublicKey()

	ed25519PrivateKey, _ := _GenerateEd25519PrivateKey()
	ed25519PublicKey := ed25519PrivateKey._PublicKey()

	assert.Equal(t, ecdsaPrivateKey.String(), ecdsaPrivateKey.String())
	assert.Equal(t, ecdsaPublicKey.String(), ecdsaPublicKey.String())
	assert.Equal(t, ed25519PrivateKey.String(), ed25519PrivateKey.String())
	assert.Equal(t, ed25519PublicKey.String(), ed25519PublicKey.String())

}
// Filename: custom_fee.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// Base struct for all custom fees
type CustomFee struct {
	FeeCollectorAccountID  *AccountID
	AllCollectorsAreExempt bool
}

func _CustomFeeFromProtobuf(customFee *services.CustomFee) Fee {
	if customFee == nil {
		return nil
	}

	var id *AccountID
	if customFee.FeeCollectorAccountId != nil {
		id = _AccountIDFromProtobuf(customFee.FeeCollectorAccountId)
	}

	fee := CustomFee{
		FeeCollectorAccountID:  id,
		AllCollectorsAreExempt: customFee.AllCollectorsAreExempt,
	}

	switch t := customFee.Fee.(type) {
	case *services.CustomFee_FixedFee:
		return _CustomFixedFeeFromProtobuf(t.FixedFee, fee)
	case *services.CustomFee_FractionalFee:
		return _CustomFractionalFeeFromProtobuf(t.FractionalFee, fee)
	case *services.CustomFee_RoyaltyFee:
		return _CustomRoyaltyFeeFromProtobuf(t.RoyaltyFee, fee)
	}

	return nil
}

// SetFeeCollectorAccountID sets the account ID that will receive the custom fee
func (fee *CustomFee) SetFeeCollectorAccountID(id AccountID) *CustomFee {
	fee.FeeCollectorAccountID = &id
	return fee
}

// GetFeeCollectorAccountID returns the account ID that will receive the custom fee
func (fee *CustomFee) GetFeeCollectorAccountID() AccountID {
	return *fee.FeeCollectorAccountID
}

// SetAllCollectorsAreExempt sets whether or not all collectors are exempt from the custom fee
func (fee *CustomFee) SetAllCollectorsAreExempt(exempt bool) *CustomFee {
	fee.AllCollectorsAreExempt = exempt
	return fee
}

// GetAllCollectorsAreExempt returns whether or not all collectors are exempt from the custom fee
func (fee *CustomFee) GetAllCollectorsAreExempt() bool {
	return fee.AllCollectorsAreExempt
}

// CustomFeeFromBytes returns a CustomFee from a raw protobuf byte array
func CustomFeeFromBytes(data []byte) (Fee, error) {
	if data == nil {
		return nil, errByteArrayNull
	}
	pb := services.CustomFee{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return nil, err
	}

	return _CustomFeeFromProtobuf(&pb), nil
}
// Filename: custom_fixed_fee.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

type Fee interface {
	_ToProtobuf() *services.CustomFee
	validateNetworkOnIDs(client *Client) error
}

// A fixed fee transfers a specified amount of the token, to the specified collection account(s),
// each time a token transfer is initiated. The custom token fee does not depend on the amount of the
// token that is being transferred.
type CustomFixedFee struct {
	CustomFee
	Amount              int64
	DenominationTokenID *TokenID
}

// A fixed fee transfers a specified amount of the token, to the specified collection account(s),
// each time a token transfer is initiated. The custom token fee does not depend on the amount of the
// token that is being transferred.
func NewCustomFixedFee() *CustomFixedFee {
	return &CustomFixedFee{
		CustomFee:           CustomFee{},
		Amount:              0,
		DenominationTokenID: nil,
	}
}

func _CustomFixedFeeFromProtobuf(fixedFee *services.FixedFee, customFee CustomFee) CustomFixedFee {
	return CustomFixedFee{
		CustomFee:           customFee,
		Amount:              fixedFee.Amount,
		DenominationTokenID: _TokenIDFromProtobuf(fixedFee.DenominatingTokenId),
	}
}

func (fee CustomFixedFee) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}
	if fee.DenominationTokenID != nil {
		if fee.DenominationTokenID != nil {
			if err := fee.DenominationTokenID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	if fee.FeeCollectorAccountID != nil {
		if fee.FeeCollectorAccountID != nil {
			if err := fee.FeeCollectorAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	return nil
}

func (fee CustomFixedFee) _ToProtobuf() *services.CustomFee {
	var tokenID *services.TokenID
	if fee.DenominationTokenID != nil {
		tokenID = fee.DenominationTokenID._ToProtobuf()
	}

	var FeeCollectorAccountID *services.AccountID
	if fee.FeeCollectorAccountID != nil {
		FeeCollectorAccountID = fee.CustomFee.FeeCollectorAccountID._ToProtobuf()
	}

	return &services.CustomFee{
		Fee: &services.CustomFee_FixedFee{
			FixedFee: &services.FixedFee{
				Amount:              fee.Amount,
				DenominatingTokenId: tokenID,
			},
		},
		FeeCollectorAccountId:  FeeCollectorAccountID,
		AllCollectorsAreExempt: fee.AllCollectorsAreExempt,
	}
}

// SetAmount sets the amount of the fixed fee in tinybar
func (fee *CustomFixedFee) SetAmount(tinybar int64) *CustomFixedFee {
	fee.Amount = tinybar
	return fee
}

// GetAmount returns the amount of the fixed fee
func (fee *CustomFixedFee) GetAmount() Hbar {
	return NewHbar(float64(fee.Amount))
}

// SetHbarAmount sets the amount of the fixed fee in hbar
func (fee *CustomFixedFee) SetHbarAmount(hbar Hbar) *CustomFixedFee {
	fee.Amount = int64(hbar.As(HbarUnits.Tinybar))
	fee.DenominationTokenID = nil
	return fee
}

// GetHbarAmount returns the amount of the fixed fee in hbar
func (fee *CustomFixedFee) GetHbarAmount() Hbar {
	return NewHbar(float64(fee.Amount))
}

// SetDenominatingTokenToSameToken sets the denomination token ID to the same token as the fee
func (fee *CustomFixedFee) SetDenominatingTokenToSameToken() *CustomFixedFee {
	fee.DenominationTokenID = &TokenID{0, 0, 0, nil}
	return fee
}

// SetDenominatingTokenID sets the denomination token ID
func (fee *CustomFixedFee) SetDenominatingTokenID(id TokenID) *CustomFixedFee {
	fee.DenominationTokenID = &id
	return fee
}

// GetDenominatingTokenID returns the denomination token ID
func (fee *CustomFixedFee) GetDenominatingTokenID() TokenID {
	if fee.DenominationTokenID != nil {
		return *fee.DenominationTokenID
	}

	return TokenID{}
}

// SetFeeCollectorAccountID sets the account ID that will receive the custom fee
func (fee *CustomFixedFee) SetFeeCollectorAccountID(id AccountID) *CustomFixedFee {
	fee.FeeCollectorAccountID = &id
	return fee
}

// GetFeeCollectorAccountID returns the account ID that will receive the custom fee
func (fee *CustomFixedFee) GetFeeCollectorAccountID() AccountID {
	return *fee.FeeCollectorAccountID
}

// SetAllCollectorsAreExempt sets whether all collectors are exempt from the custom fee
func (fee *CustomFixedFee) SetAllCollectorsAreExempt(exempt bool) *CustomFixedFee {
	fee.AllCollectorsAreExempt = exempt
	return fee
}

// ToBytes returns the byte representation of the CustomFixedFee
func (fee *CustomFixedFee) ToBytes() []byte {
	data, err := protobuf.Marshal(fee._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// String returns a string representation of the CustomFixedFee
func (fee *CustomFixedFee) String() string {
	if fee.DenominationTokenID != nil {
		return fmt.Sprintf("feeCollectorAccountID: %s, amount: %d, denominatingTokenID: %s", fee.FeeCollectorAccountID.String(), fee.Amount, fee.DenominationTokenID.String())
	}

	return fmt.Sprintf("feeCollectorAccountID: %s, amount: %d", fee.FeeCollectorAccountID.String(), fee.Amount)
}
// Filename: custom_fractional_fee.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// A fractional fee transfers the specified fraction of the total value of the tokens that are being transferred
// to the specified fee-collecting account. Along with setting a custom fractional fee, you can
type CustomFractionalFee struct {
	CustomFee
	Numerator        int64
	Denominator      int64
	MinimumAmount    int64
	MaximumAmount    int64
	AssessmentMethod FeeAssessmentMethod
}

// A fractional fee transfers the specified fraction of the total value of the tokens that are being transferred
// to the specified fee-collecting account. Along with setting a custom fractional fee, you can
func NewCustomFractionalFee() *CustomFractionalFee {
	return &CustomFractionalFee{
		CustomFee:        CustomFee{},
		Numerator:        0,
		Denominator:      0,
		MinimumAmount:    0,
		MaximumAmount:    0,
		AssessmentMethod: false,
	}
}

// SetFeeCollectorAccountID sets the account ID that will receive the custom fee
func (fee *CustomFractionalFee) SetFeeCollectorAccountID(id AccountID) *CustomFractionalFee {
	fee.FeeCollectorAccountID = &id
	return fee
}

// SetNumerator sets the numerator of the fractional fee
func (fee *CustomFractionalFee) SetNumerator(numerator int64) *CustomFractionalFee {
	fee.Numerator = numerator
	return fee
}

// SetDenominator sets the denominator of the fractional fee
func (fee *CustomFractionalFee) SetDenominator(denominator int64) *CustomFractionalFee {
	fee.Denominator = denominator
	return fee
}

// SetMin sets the minimum amount of the fractional fee
func (fee *CustomFractionalFee) SetMin(min int64) *CustomFractionalFee {
	fee.MinimumAmount = min
	return fee
}

// SetMax sets the maximum amount of the fractional fee
func (fee *CustomFractionalFee) SetMax(max int64) *CustomFractionalFee {
	fee.MaximumAmount = max
	return fee
}

// GetFeeCollectorAccountID returns the account ID that will receive the custom fee
func (fee *CustomFractionalFee) GetFeeCollectorAccountID() AccountID {
	if fee.FeeCollectorAccountID != nil {
		return *fee.FeeCollectorAccountID
	}

	return AccountID{}
}

// GetNumerator returns the numerator of the fractional fee
func (fee *CustomFractionalFee) GetNumerator() int64 {
	return fee.Numerator
}

// GetDenominator returns the denominator of the fractional fee
func (fee *CustomFractionalFee) GetDenominator() int64 {
	return fee.Denominator
}

// GetMin returns the minimum amount of the fractional fee
func (fee *CustomFractionalFee) GetMin() int64 {
	return fee.MinimumAmount
}

// GetMax returns the maximum amount of the fractional fee
func (fee *CustomFractionalFee) GetMax() int64 {
	return fee.MaximumAmount
}

// GetAssessmentMethod returns the assessment method of the fractional fee
func (fee *CustomFractionalFee) GetAssessmentMethod() FeeAssessmentMethod {
	return fee.AssessmentMethod
}

// SetAssessmentMethod sets the assessment method of the fractional fee
func (fee *CustomFractionalFee) SetAssessmentMethod(feeAssessmentMethod FeeAssessmentMethod) *CustomFractionalFee {
	fee.AssessmentMethod = feeAssessmentMethod
	return fee
}

func _CustomFractionalFeeFromProtobuf(fractionalFee *services.FractionalFee, fee CustomFee) CustomFractionalFee {
	return CustomFractionalFee{
		CustomFee:        fee,
		Numerator:        fractionalFee.FractionalAmount.Numerator,
		Denominator:      fractionalFee.FractionalAmount.Denominator,
		MinimumAmount:    fractionalFee.MinimumAmount,
		MaximumAmount:    fractionalFee.MaximumAmount,
		AssessmentMethod: FeeAssessmentMethod(fractionalFee.NetOfTransfers),
	}
}

func (fee CustomFractionalFee) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if fee.FeeCollectorAccountID != nil {
		if fee.FeeCollectorAccountID != nil {
			if err := fee.FeeCollectorAccountID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}

	return nil
}

// SetAllCollectorsAreExempt sets the flag that indicates if all collectors are exempt from the custom fee
func (fee *CustomFractionalFee) SetAllCollectorsAreExempt(exempt bool) *CustomFractionalFee {
	fee.AllCollectorsAreExempt = exempt
	return fee
}

func (fee CustomFractionalFee) _ToProtobuf() *services.CustomFee {
	var FeeCollectorAccountID *services.AccountID
	if fee.FeeCollectorAccountID != nil {
		FeeCollectorAccountID = fee.CustomFee.FeeCollectorAccountID._ToProtobuf()
	}

	return &services.CustomFee{
		Fee: &services.CustomFee_FractionalFee{
			FractionalFee: &services.FractionalFee{
				FractionalAmount: &services.Fraction{
					Numerator:   fee.Numerator,
					Denominator: fee.Denominator,
				},
				MinimumAmount:  fee.MinimumAmount,
				MaximumAmount:  fee.MaximumAmount,
				NetOfTransfers: bool(fee.AssessmentMethod),
			},
		},
		FeeCollectorAccountId:  FeeCollectorAccountID,
		AllCollectorsAreExempt: fee.AllCollectorsAreExempt,
	}
}

// ToBytes returns a byte array representation of the CustomFractionalFee
func (fee CustomFractionalFee) ToBytes() []byte {
	data, err := protobuf.Marshal(fee._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// String returns a string representation of the CustomFractionalFee
func (fee CustomFractionalFee) String() string {
	return fmt.Sprintf("feeCollectorAccountID: %s, numerator: %d, denominator: %d, min: %d, Max: %d, assessmentMethod: %s", fee.FeeCollectorAccountID.String(), fee.Numerator, fee.Denominator, fee.MinimumAmount, fee.MaximumAmount, fee.AssessmentMethod.String())
}
// Filename: custom_fractional_fee_unit_test.go
//go:build all || unit
// +build all unit

package hedera

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/proto"
)

func TestCustomFractionalFee_SettersAndGetters(t *testing.T) {
	t.Parallel()

	fee := NewCustomFractionalFee()
	const FeeAssessmentMethod_TRUE FeeAssessmentMethod = true

	fee.SetFeeCollectorAccountID(AccountID{Account: 1234}).
		SetNumerator(1).
		SetDenominator(2).
		SetMin(10).
		SetMax(100).
		SetAllCollectorsAreExempt(true).
		SetAssessmentMethod(FeeAssessmentMethod_TRUE)

	require.Equal(t, AccountID{Account: 1234}, fee.GetFeeCollectorAccountID())
	require.Equal(t, int64(1), fee.GetNumerator())
	require.Equal(t, int64(2), fee.GetDenominator())
	require.Equal(t, int64(10), fee.GetMin())
	require.Equal(t, int64(100), fee.GetMax())
	require.Equal(t, true, fee.GetAllCollectorsAreExempt())
	require.Equal(t, FeeAssessmentMethod_TRUE, fee.GetAssessmentMethod())
}

func TestCustomFractionalFee_ToBytes(t *testing.T) {
	t.Parallel()

	fee := NewCustomFractionalFee()
	const FeeAssessmentMethod_TRUE FeeAssessmentMethod = true

	fee.SetFeeCollectorAccountID(AccountID{Account: 1234}).
		SetNumerator(1).
		SetDenominator(2).
		SetMin(10).
		SetMax(100).
		SetAllCollectorsAreExempt(true).
		SetAssessmentMethod(FeeAssessmentMethod_TRUE)

	bytes := fee.ToBytes()
	require.NotEmpty(t, bytes)

	protoFee := &services.CustomFee{}
	err := proto.Unmarshal(bytes, protoFee)
	require.NoError(t, err)

	require.Equal(t, int64(1), protoFee.GetFractionalFee().GetFractionalAmount().GetNumerator())
	require.Equal(t, int64(2), protoFee.GetFractionalFee().GetFractionalAmount().GetDenominator())
	require.Equal(t, int64(10), protoFee.GetFractionalFee().GetMinimumAmount())
	require.Equal(t, int64(100), protoFee.GetFractionalFee().GetMaximumAmount())
	require.Equal(t, true, protoFee.GetFractionalFee().GetNetOfTransfers())
	require.Equal(t, int64(1234), protoFee.GetFeeCollectorAccountId().GetAccountNum())
	require.Equal(t, true, protoFee.GetAllCollectorsAreExempt())
}

func TestCustomFractionalFee_ToProtobuf(t *testing.T) {
	t.Parallel()

	fee := NewCustomFractionalFee()
	const FeeAssessmentMethod_TRUE FeeAssessmentMethod = true

	fee.SetFeeCollectorAccountID(AccountID{Account: 1234}).
		SetNumerator(1).
		SetDenominator(2).
		SetMin(10).
		SetMax(100).
		SetAllCollectorsAreExempt(true).
		SetAssessmentMethod(FeeAssessmentMethod_TRUE)

	protoFee := fee._ToProtobuf()
	require.Equal(t, int64(1), protoFee.GetFractionalFee().GetFractionalAmount().GetNumerator())
	require.Equal(t, int64(2), protoFee.GetFractionalFee().GetFractionalAmount().GetDenominator())
	require.Equal(t, int64(10), protoFee.GetFractionalFee().GetMinimumAmount())
	require.Equal(t, int64(100), protoFee.GetFractionalFee().GetMaximumAmount())
	require.Equal(t, true, protoFee.GetFractionalFee().GetNetOfTransfers())
	require.Equal(t, int64(1234), protoFee.GetFeeCollectorAccountId().GetAccountNum())
	require.Equal(t, true, protoFee.GetAllCollectorsAreExempt())
	// CustomFeeFromProtobuf calls _CustomFractionalFeeFromProtobuf
	deserializedFee := _CustomFeeFromProtobuf(protoFee)

	require.Equal(t, *fee, deserializedFee)
}
// Filename: custom_royalty_fee.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

// A royalty fee is a fractional fee that is assessed each time the ownership of an NFT is transferred from
// person A to person B. The fee collector account ID defined in the royalty fee schedule will receive the
// royalty fee each time. The royalty fee charged is a fraction of the value exchanged for the NFT.
type CustomRoyaltyFee struct {
	CustomFee
	Numerator   int64
	Denominator int64
	FallbackFee *CustomFixedFee
}

// A royalty fee is a fractional fee that is assessed each time the ownership of an NFT is transferred from
// person A to person B. The fee collector account ID defined in the royalty fee schedule will receive the
// royalty fee each time. The royalty fee charged is a fraction of the value exchanged for the NFT.
func NewCustomRoyaltyFee() *CustomRoyaltyFee {
	return &CustomRoyaltyFee{
		CustomFee:   CustomFee{},
		Numerator:   0,
		Denominator: 0,
		FallbackFee: nil,
	}
}

// SetFeeCollectorAccountID sets the account ID that will receive the custom fee
func (fee *CustomRoyaltyFee) SetFeeCollectorAccountID(accountID AccountID) *CustomRoyaltyFee {
	fee.FeeCollectorAccountID = &accountID
	return fee
}

// SetNumerator sets the numerator of the fractional fee
func (fee *CustomRoyaltyFee) SetNumerator(numerator int64) *CustomRoyaltyFee {
	fee.Numerator = numerator
	return fee
}

// SetDenominator sets the denominator of the fractional fee
func (fee *CustomRoyaltyFee) SetDenominator(denominator int64) *CustomRoyaltyFee {
	fee.Denominator = denominator
	return fee
}

// SetFallbackFee If present, the fixed fee to assess to the NFT receiver when no fungible value is exchanged with the sender
func (fee *CustomRoyaltyFee) SetFallbackFee(fallbackFee *CustomFixedFee) *CustomRoyaltyFee {
	fee.FallbackFee = fallbackFee
	return fee
}

// GetFeeCollectorAccountID returns the account ID that will receive the custom fee
func (fee *CustomRoyaltyFee) GetFeeCollectorAccountID() AccountID {
	if fee.FeeCollectorAccountID != nil {
		return *fee.FeeCollectorAccountID
	}

	return AccountID{}
}

// GetNumerator returns the numerator of the fee
func (fee *CustomRoyaltyFee) GetNumerator() int64 {
	return fee.Numerator
}

// GetDenominator returns the denominator of the fee
func (fee *CustomRoyaltyFee) GetDenominator() int64 {
	return fee.Denominator
}

// GetFallbackFee returns the fallback fee
func (fee *CustomRoyaltyFee) GetFallbackFee() CustomFixedFee {
	if fee.FallbackFee != nil {
		return *fee.FallbackFee
	}

	return CustomFixedFee{}
}

// SetAllCollectorsAreExempt sets whether all collectors are exempt from the fee
func (fee *CustomRoyaltyFee) SetAllCollectorsAreExempt(exempt bool) *CustomRoyaltyFee {
	fee.AllCollectorsAreExempt = exempt
	return fee
}

func _CustomRoyaltyFeeFromProtobuf(royalty *services.RoyaltyFee, fee CustomFee) CustomRoyaltyFee {
	var fallback CustomFixedFee
	if royalty.FallbackFee != nil {
		fallback = _CustomFixedFeeFromProtobuf(royalty.FallbackFee, fee)
	}
	return CustomRoyaltyFee{
		CustomFee:   fee,
		Numerator:   royalty.ExchangeValueFraction.Numerator,
		Denominator: royalty.ExchangeValueFraction.Denominator,
		FallbackFee: &fallback,
	}
}

func (fee CustomRoyaltyFee) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums || fee.FallbackFee == nil {
		return nil
	}

	return fee.FallbackFee.validateNetworkOnIDs(client)
}

func (fee CustomRoyaltyFee) _ToProtobuf() *services.CustomFee {
	var fallback *services.FixedFee
	if fee.FallbackFee != nil {
		fallback = fee.FallbackFee._ToProtobuf().GetFixedFee()
	}

	var FeeCollectorAccountID *services.AccountID
	if fee.FeeCollectorAccountID != nil {
		FeeCollectorAccountID = fee.CustomFee.FeeCollectorAccountID._ToProtobuf()
	}

	return &services.CustomFee{
		Fee: &services.CustomFee_RoyaltyFee{
			RoyaltyFee: &services.RoyaltyFee{
				ExchangeValueFraction: &services.Fraction{
					Numerator:   fee.Numerator,
					Denominator: fee.Denominator,
				},
				FallbackFee: fallback,
			},
		},
		FeeCollectorAccountId:  FeeCollectorAccountID,
		AllCollectorsAreExempt: fee.AllCollectorsAreExempt,
	}
}
// Filename: delegatable_contract_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
	protobuf "google.golang.org/protobuf/proto"
)

// ContractID is the ID for a Hedera smart contract
type DelegatableContractID struct {
	Shard      uint64
	Realm      uint64
	Contract   uint64
	EvmAddress []byte
	checksum   *string
}

// DelegatableContractIDFromString constructs a DelegatableContractID from a string formatted as `Shard.Realm.Contract` (for example "0.0.3")
func DelegatableContractIDFromString(data string) (DelegatableContractID, error) {
	shard, realm, num, checksum, evm, err := _ContractIDFromString(data)
	if err != nil {
		return DelegatableContractID{}, err
	}

	if num == -1 {
		return DelegatableContractID{
			Shard:      uint64(shard),
			Realm:      uint64(realm),
			Contract:   0,
			EvmAddress: evm,
			checksum:   checksum,
		}, nil
	}

	return DelegatableContractID{
		Shard:      uint64(shard),
		Realm:      uint64(realm),
		Contract:   uint64(num),
		EvmAddress: nil,
		checksum:   checksum,
	}, nil
}

// Verify that the client has a valid checksum.
func (id *DelegatableContractID) ValidateChecksum(client *Client) error {
	if !id._IsZero() && client != nil {
		var tempChecksum _ParseAddressResult
		var err error
		if client.network.ledgerID != nil {
			tempChecksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Contract))
		}
		if err != nil {
			return err
		}
		err = _ChecksumVerify(tempChecksum.status)
		if err != nil {
			return err
		}
		if id.checksum == nil {
			return errChecksumMissing
		}
		if tempChecksum.correctChecksum != *id.checksum {
			networkName := NetworkNameOther
			if client.network.ledgerID != nil {
				networkName, _ = client.network.ledgerID.ToNetworkName()
			}
			return errors.New(fmt.Sprintf("network mismatch or wrong checksum given, given checksum: %s, correct checksum %s, network: %s",
				*id.checksum,
				tempChecksum.correctChecksum,
				networkName))
		}
	}

	return nil
}

// DelegatableContractIDFromEvmAddress constructs a DelegatableContractID from a string representation of a _Solidity address
func DelegatableContractIDFromEvmAddress(shard uint64, realm uint64, evmAddress string) (DelegatableContractID, error) {
	temp, err := hex.DecodeString(evmAddress)
	if err != nil {
		return DelegatableContractID{}, err
	}
	return DelegatableContractID{
		Shard:      shard,
		Realm:      realm,
		Contract:   0,
		EvmAddress: temp,
		checksum:   nil,
	}, nil
}

// DelegatableContractIDFromSolidityAddress constructs a DelegatableContractID from a string representation of a _Solidity address
// Does not populate DelegatableContractID.EvmAddress
func DelegatableContractIDFromSolidityAddress(s string) (DelegatableContractID, error) {
	shard, realm, contract, err := _IdFromSolidityAddress(s)
	if err != nil {
		return DelegatableContractID{}, err
	}

	return DelegatableContractID{
		Shard:    shard,
		Realm:    realm,
		Contract: contract,
	}, nil
}

// String returns the string representation of a DelegatableContractID formatted as `Shard.Realm.Contract` (for example "0.0.3")
func (id DelegatableContractID) String() string {
	if len(id.EvmAddress) > 0 {
		temp := hex.EncodeToString(id.EvmAddress)
		return fmt.Sprintf("%d.%d.%s", id.Shard, id.Realm, temp)
	}
	return fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Contract)
}

// ToStringWithChecksum returns the string representation of a DelegatableContractID formatted as `Shard.Realm.Contract-Checksum` (for example "0.0.3-abcde")
func (id DelegatableContractID) ToStringWithChecksum(client Client) (string, error) {
	if id.EvmAddress != nil {
		return "", errors.New("EvmAddress doesn't support checksums")
	}
	if client.GetNetworkName() == nil && client.GetLedgerID() == nil {
		return "", errNetworkNameMissing
	}
	var checksum _ParseAddressResult
	var err error
	if client.network.ledgerID != nil {
		checksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Contract))
	}
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%d.%d.%d-%s", id.Shard, id.Realm, id.Contract, checksum.correctChecksum), nil
}

// ToSolidityAddress returns the string representation of the DelegatableContractID as a _Solidity address.
func (id DelegatableContractID) ToSolidityAddress() string {
	return _IdToSolidityAddress(id.Shard, id.Realm, id.Contract)
}

func (id DelegatableContractID) _ToProtobuf() *services.ContractID {
	resultID := services.ContractID{
		ShardNum: int64(id.Shard),
		RealmNum: int64(id.Realm),
	}

	if id.EvmAddress != nil {
		resultID.Contract = &services.ContractID_EvmAddress{EvmAddress: id.EvmAddress}
		return &resultID
	}

	resultID.Contract = &services.ContractID_ContractNum{ContractNum: int64(id.Contract)}

	return &resultID
}

func _DelegatableContractIDFromProtobuf(contractID *services.ContractID) *DelegatableContractID {
	if contractID == nil {
		return nil
	}
	resultID := DelegatableContractID{
		Shard: uint64(contractID.ShardNum),
		Realm: uint64(contractID.RealmNum),
	}

	switch id := contractID.Contract.(type) {
	case *services.ContractID_ContractNum:
		resultID.Contract = uint64(id.ContractNum)
		resultID.EvmAddress = nil
		return &resultID
	case *services.ContractID_EvmAddress:
		resultID.EvmAddress = id.EvmAddress
		resultID.Contract = 0
		return &resultID
	default:
		return &resultID
	}
}

func (id DelegatableContractID) _IsZero() bool {
	return id.Shard == 0 && id.Realm == 0 && id.Contract == 0
}

func (id DelegatableContractID) _ToProtoKey() *services.Key {
	return &services.Key{Key: &services.Key_ContractID{ContractID: id._ToProtobuf()}}
}

// ToBytes returns a byte array representation of the DelegatableContractID
func (id DelegatableContractID) ToBytes() []byte {
	data, err := protobuf.Marshal(id._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// DelegatableContractIDFromBytes returns a DelegatableContractID generated from a byte array
func DelegatableContractIDFromBytes(data []byte) (DelegatableContractID, error) {
	pb := services.ContractID{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return DelegatableContractID{}, err
	}

	return *_DelegatableContractIDFromProtobuf(&pb), nil
}
// Filename: delegate_contract_id_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"fmt"
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
)

func TestUnitDelegatableContractIDChecksumFromString(t *testing.T) {
	t.Parallel()

	id, err := DelegatableContractIDFromString("0.0.123-rmkyk")
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	err = id.ValidateChecksum(client)
	require.Error(t, err)
	require.Equal(t, id.Contract, uint64(123))
	strChecksum, err := id.ToStringWithChecksum(*client)
	require.NoError(t, err)
	// different checksum because of different network
	require.Equal(t, strChecksum, "0.0.123-esxsf")
}

func TestUnitDelegatableContractIDChecksumToString(t *testing.T) {
	t.Parallel()

	id := DelegatableContractID{
		Shard:    50,
		Realm:    150,
		Contract: 520,
	}
	require.Equal(t, "50.150.520", id.String())
}

func TestUnitDelegatableContractIDFromStringEVM(t *testing.T) {
	t.Parallel()

	id, err := DelegatableContractIDFromString("0.0.0011223344556677889900112233445577889900")
	require.NoError(t, err)

	require.Equal(t, "0.0.0011223344556677889900112233445577889900", id.String())
}

func TestUnitDelegatableContractIDProtobuf(t *testing.T) {
	t.Parallel()

	id, err := DelegatableContractIDFromString("0.0.0011223344556677889900112233445577889900")
	require.NoError(t, err)

	pb := id._ToProtobuf()

	decoded, err := hex.DecodeString("0011223344556677889900112233445577889900")
	require.NoError(t, err)

	require.Equal(t, pb, &services.ContractID{
		ShardNum: 0,
		RealmNum: 0,
		Contract: &services.ContractID_EvmAddress{EvmAddress: decoded},
	})

	pbFrom := _DelegatableContractIDFromProtobuf(pb)

	require.Equal(t, id, *pbFrom)
}

func TestUnitDelegatableContractIDEvm(t *testing.T) {
	t.Parallel()

	hexString, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	id, err := DelegatableContractIDFromString(fmt.Sprintf("0.0.%s", hexString.PublicKey().String()))
	require.NoError(t, err)
	require.Equal(t, hex.EncodeToString(id.EvmAddress), hexString.PublicKey().String())

	pb := id._ToProtobuf()
	require.Equal(t, pb, &services.ContractID{
		ShardNum: 0,
		RealmNum: 0,
		Contract: &services.ContractID_EvmAddress{EvmAddress: id.EvmAddress},
	})

	id, err = DelegatableContractIDFromString("0.0.123")
	require.NoError(t, err)
	require.Equal(t, id.Contract, uint64(123))
	require.Nil(t, id.EvmAddress)

	pb = id._ToProtobuf()
	require.Equal(t, pb, &services.ContractID{
		ShardNum: 0,
		RealmNum: 0,
		Contract: &services.ContractID_ContractNum{ContractNum: 123},
	})
}

func TestUnitDelegatableContractIDToFromBytes(t *testing.T) {
	t.Parallel()

	id, err := DelegatableContractIDFromString("0.0.123")
	require.NoError(t, err)
	require.Equal(t, id.Contract, uint64(123))
	require.Nil(t, id.EvmAddress)

	idBytes := id.ToBytes()
	idFromBytes, err := DelegatableContractIDFromBytes(idBytes)
	require.NoError(t, err)
	require.Equal(t, id, idFromBytes)
}

func TestUnitDelegatableContractIDFromEvmAddress(t *testing.T) {
	t.Parallel()

	id, err := DelegatableContractIDFromEvmAddress(0, 0, "0011223344556677889900112233445566778899")
	require.NoError(t, err)
	require.Equal(t, id.Contract, uint64(0))
	require.Equal(t, id.EvmAddress, []byte{0x0, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0x0, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99})
}

func TestUnitDelegatableContractIDFromSolidityAddress(t *testing.T) {
	t.Parallel()

	id, err := DelegatableContractIDFromString("0.0.123-rmkyk")
	require.NoError(t, err)
	sol := id.ToSolidityAddress()
	idFromSolidity, err := DelegatableContractIDFromSolidityAddress(sol)
	require.NoError(t, err)
	require.Equal(t, idFromSolidity.Contract, uint64(123))
}

func TestUnitDelegatableContractIDToProtoKey(t *testing.T) {
	t.Parallel()

	id, err := DelegatableContractIDFromString("0.0.123-rmkyk")
	require.NoError(t, err)
	pb := id._ToProtoKey()
	require.Equal(t, pb.GetContractID().GetContractNum(), int64(123))
}
// Filename: ecdsa_private_key.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"crypto/ecdsa"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha512"
	"crypto/x509"
	"encoding/asn1"
	"encoding/hex"
	"encoding/pem"
	"fmt"
	"io"
	"strings"

	"github.com/ethereum/go-ethereum/crypto"
	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
)

// _ECDSAPrivateKey is an Key_ECDSASecp256K1 private key.
type _ECDSAPrivateKey struct {
	keyData   *ecdsa.PrivateKey
	chainCode []byte
}

const _LegacyECDSAPrivateKeyPrefix = "3030020100300706052b8104000a04220420"

func _GenerateECDSAPrivateKey() (*_ECDSAPrivateKey, error) {
	key, err := ecdsa.GenerateKey(crypto.S256(), rand.Reader)
	if err != nil {
		return &_ECDSAPrivateKey{}, err
	}

	return &_ECDSAPrivateKey{
		keyData: key,
	}, nil
}

func _ECDSAPrivateKeyFromBytes(byt []byte) (*_ECDSAPrivateKey, error) {
	length := len(byt)
	switch {
	case length == 32:
		return _ECDSAPrivateKeyFromBytesRaw(byt)
	case length > 32:
		return _ECDSAPrivateKeyFromBytesDer(byt)
	default:
		return &_ECDSAPrivateKey{}, _NewErrBadKeyf("invalid private key length: %v bytes", len(byt))
	}
}

func _ECDSAPrivateKeyFromBytesRaw(byt []byte) (*_ECDSAPrivateKey, error) {
	length := len(byt)
	if length != 32 {
		return &_ECDSAPrivateKey{}, _NewErrBadKeyf("invalid private key length: %v bytes", len(byt))
	}

	key, err := crypto.ToECDSA(byt)
	if err != nil {
		return nil, err
	}

	return &_ECDSAPrivateKey{
		keyData: key,
	}, nil
}

func _LegacyECDSAPrivateKeyFromBytesDer(byt []byte) (*_ECDSAPrivateKey, error) {
	given := hex.EncodeToString(byt)

	result := strings.ReplaceAll(given, _LegacyECDSAPrivateKeyPrefix, "")
	decoded, err := hex.DecodeString(result)
	if err != nil {
		return &_ECDSAPrivateKey{}, err
	}

	if len(decoded) != 32 {
		return &_ECDSAPrivateKey{}, _NewErrBadKeyf("invalid private key length: %v bytes", len(byt))
	}

	key, err := crypto.ToECDSA(decoded)
	if err != nil {
		return nil, err
	}

	return &_ECDSAPrivateKey{
		keyData: key,
	}, nil
}

func _ECDSAPrivateKeyFromBytesDer(data []byte) (*_ECDSAPrivateKey, error) {
	given := hex.EncodeToString(data)
	if strings.HasPrefix(given, _LegacyECDSAPrivateKeyPrefix) {
		return _LegacyECDSAPrivateKeyFromBytesDer(data)
	}

	type ECPrivateKey struct {
		Version       int
		PrivateKey    []byte
		NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
		PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
	}
	var ecKey ECPrivateKey
	if rest, err := asn1.Unmarshal(data, &ecKey); err != nil {
		return nil, err
	} else if len(rest) != 0 {
		return nil, errors.New("x509: trailing data after ASN.1 of public-key")
	}
	key, err := crypto.ToECDSA(ecKey.PrivateKey)
	if err != nil {
		return nil, err
	}
	return &_ECDSAPrivateKey{keyData: key}, nil
}

func _ECDSAPrivateKeyFromSeed(seed []byte) (*_ECDSAPrivateKey, error) {
	h := hmac.New(sha512.New, []byte("Bitcoin seed"))

	_, err := h.Write(seed)
	if err != nil {
		return &_ECDSAPrivateKey{}, err
	}

	digest := h.Sum(nil)

	keyBytes := digest[0:32]
	chainCode := digest[32:]
	privateKey, err := _ECDSAPrivateKeyFromBytes(keyBytes)

	if err != nil {
		return &_ECDSAPrivateKey{}, err
	}
	privateKey.chainCode = chainCode

	return privateKey, nil
}

func _ECDSAPrivateKeyFromString(s string) (*_ECDSAPrivateKey, error) {
	b, err := hex.DecodeString(strings.ToLower(s))
	if err != nil {
		return &_ECDSAPrivateKey{}, err
	}

	return _ECDSAPrivateKeyFromBytes(b)
}

func (sk _ECDSAPrivateKey) _PublicKey() *_ECDSAPublicKey {
	if sk.keyData.Y == nil && sk.keyData.X == nil {
		b := sk.keyData.D.Bytes()
		x, y := crypto.S256().ScalarBaseMult(b)
		sk.keyData.X = x
		sk.keyData.Y = y
		return &_ECDSAPublicKey{
			&ecdsa.PublicKey{
				Curve: crypto.S256(),
				X:     x,
				Y:     y,
			},
		}
	}

	return &_ECDSAPublicKey{
		&ecdsa.PublicKey{
			Curve: sk.keyData.Curve,
			X:     sk.keyData.X,
			Y:     sk.keyData.Y,
		},
	}
}

func _ECDSAPrivateKeyFromPem(bytes []byte, passphrase string) (*_ECDSAPrivateKey, error) {
	block, _ := pem.Decode(bytes)
	if block == nil {
		return nil, fmt.Errorf("failed to decode PEM block containing private key")
	}

	if block.Type != "EC PRIVATE KEY" {
		return nil, fmt.Errorf("unsupported PEM block type: %s", block.Type)
	}
	//nolint
	if x509.IsEncryptedPEMBlock(block) {
		der, err := x509.DecryptPEMBlock(block, []byte(passphrase))
		if err != nil {
			return nil, err
		}
		block.Bytes = der
	}

	key, err := _ECDSAPrivateKeyFromBytes(block.Bytes)
	if err != nil {
		return nil, err
	}
	return key, nil
}

func _ECDSAPrivateKeyReadPem(source io.Reader, passphrase string) (*_ECDSAPrivateKey, error) {
	pemFileBytes, err := io.ReadAll(source)
	if err != nil {
		return &_ECDSAPrivateKey{}, err
	}

	return _ECDSAPrivateKeyFromPem(pemFileBytes, passphrase)
}

func (sk _ECDSAPrivateKey) _Sign(message []byte) []byte {
	hash := crypto.Keccak256Hash(message)
	sig, err := crypto.Sign(hash.Bytes(), sk.keyData)
	if err != nil {
		panic(err)
	}

	// signature returned has a ecdsa recovery byte at the end,
	// need to remove it for verification to work.
	return sig[:len(sig)-1]
}

// SupportsDerivation returns true if the _ECDSAPrivateKey supports derivation.
func (sk _ECDSAPrivateKey) _SupportsDerivation() bool {
	return sk.chainCode != nil
}

// Derive a child key compatible with the iOS and Android wallets using a provided wallet/account index. Use index 0 for
// the default account.
//
// This will fail if the key does not support derivation which can be checked by calling SupportsDerivation()
func (sk _ECDSAPrivateKey) _Derive(index uint32) (*_ECDSAPrivateKey, error) {
	if !sk._SupportsDerivation() {
		return nil, _NewErrBadKeyf("child key cannot be derived from this key")
	}

	derivedKeyBytes, chainCode, err := _DeriveECDSAChildKey(sk._BytesRaw(), sk.chainCode, index)
	if err != nil {
		return nil, err
	}

	derivedKey, err := _ECDSAPrivateKeyFromBytes(derivedKeyBytes)
	if err != nil {
		return nil, err
	}

	derivedKey.chainCode = chainCode

	return derivedKey, nil
}

func (sk _ECDSAPrivateKey) _BytesRaw() []byte {
	privateKey := make([]byte, 32)
	temp := sk.keyData.D.Bytes()
	copy(privateKey[32-len(temp):], temp)

	return privateKey
}

func (sk _ECDSAPrivateKey) _BytesDer() []byte {
	type ECPrivateKey struct {
		Version       int
		PrivateKey    []byte
		NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
		PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
	}

	secp256k1OID := asn1.ObjectIdentifier{1, 3, 132, 0, 10}

	ecPrivateKey := ECPrivateKey{
		Version:       1, // EC private keys have a version of 1
		PrivateKey:    sk._BytesRaw(),
		NamedCurveOID: secp256k1OID,
		PublicKey:     asn1.BitString{Bytes: sk._PublicKey()._BytesRaw()},
	}

	derBytes, err := asn1.Marshal(ecPrivateKey)
	if err != nil {
		return nil
	}

	return derBytes
}

func (sk _ECDSAPrivateKey) String() string {
	return sk._StringRaw()
}

func (sk _ECDSAPrivateKey) _StringDer() string {
	return fmt.Sprint(hex.EncodeToString(sk._BytesDer()))
}

func (sk _ECDSAPrivateKey) _StringRaw() string {
	return fmt.Sprint(hex.EncodeToString(sk._BytesRaw()))
}

func (sk _ECDSAPrivateKey) _ToProtoKey() *services.Key {
	return sk._PublicKey()._ToProtoKey()
}

// _SignTransaction signes the transaction and adds the signature to the transaction
func (sk _ECDSAPrivateKey) _SignTransaction(tx *Transaction) ([]byte, error) {
	tx._RequireOneNodeAccountID()

	if tx.signedTransactions._Length() == 0 {
		return make([]byte, 0), errTransactionRequiresSingleNodeAccountID
	}

	signature := sk._Sign(tx.signedTransactions._Get(0).(*services.SignedTransaction).GetBodyBytes())

	publicKey := sk._PublicKey()
	if publicKey == nil {
		return []byte{}, errors.New("public key is nil")
	}

	wrappedPublicKey := PublicKey{
		ecdsaPublicKey: publicKey,
	}

	if tx._KeyAlreadySigned(wrappedPublicKey) {
		return []byte{}, nil
	}

	tx.transactions = _NewLockableSlice()
	tx.publicKeys = append(tx.publicKeys, wrappedPublicKey)
	tx.transactionSigners = append(tx.transactionSigners, nil)
	tx.transactionIDs.locked = true

	for index := 0; index < tx.signedTransactions._Length(); index++ {
		temp := tx.signedTransactions._Get(index).(*services.SignedTransaction)

		temp.SigMap.SigPair = append(
			temp.SigMap.SigPair,
			publicKey._ToSignaturePairProtobuf(signature),
		)
		tx.signedTransactions._Set(index, temp)
	}

	return signature, nil
}
// Filename: ecdsa_public_key.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	"encoding/asn1"
	"encoding/hex"
	"math/big"
	"strings"

	"github.com/btcsuite/btcd/btcec/v2"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
)

type _ECDSAPublicKey struct {
	*ecdsa.PublicKey
}

const _LegacyECDSAPubKeyPrefix = "302d300706052b8104000a032200"

func _ECDSAPublicKeyFromBytes(byt []byte) (*_ECDSAPublicKey, error) {
	length := len(byt)
	switch length {
	case 33:
		return _ECDSAPublicKeyFromBytesRaw(byt)
	case 47:
		return _LegacyECDSAPublicKeyFromBytesDer(byt)
	case 56:
		return _ECDSAPublicKeyFromBytesDer(byt)
	default:
		return &_ECDSAPublicKey{}, _NewErrBadKeyf("invalid compressed ECDSA public key length: %v bytes", len(byt))
	}
}

func _ECDSAPublicKeyFromBytesRaw(byt []byte) (*_ECDSAPublicKey, error) {
	if byt == nil {
		return &_ECDSAPublicKey{}, errByteArrayNull
	}
	if len(byt) != 33 {
		return &_ECDSAPublicKey{}, _NewErrBadKeyf("invalid public key length: %v bytes", len(byt))
	}

	key, err := crypto.DecompressPubkey(byt)
	if err != nil {
		return &_ECDSAPublicKey{}, err
	}

	return &_ECDSAPublicKey{
		key,
	}, nil
}

func _LegacyECDSAPublicKeyFromBytesDer(byt []byte) (*_ECDSAPublicKey, error) {
	if byt == nil {
		return &_ECDSAPublicKey{}, errByteArrayNull
	}

	given := hex.EncodeToString(byt)
	result := strings.ReplaceAll(given, _LegacyECDSAPubKeyPrefix, "")
	decoded, err := hex.DecodeString(result)
	if err != nil {
		return &_ECDSAPublicKey{}, err
	}

	if len(decoded) != 33 {
		return &_ECDSAPublicKey{}, _NewErrBadKeyf("invalid public key length: %v bytes", len(byt))
	}

	key, err := crypto.DecompressPubkey(decoded)
	if err != nil {
		return &_ECDSAPublicKey{}, err
	}

	return &_ECDSAPublicKey{
		key,
	}, nil
}
func _ECDSAPublicKeyFromBytesDer(byt []byte) (*_ECDSAPublicKey, error) {
	if byt == nil {
		return &_ECDSAPublicKey{}, errByteArrayNull
	}

	type AlgorithmIdentifier struct {
		Algorithm  asn1.ObjectIdentifier
		Parameters asn1.ObjectIdentifier
	}

	type PublicKeyInfo struct {
		AlgorithmIdentifier AlgorithmIdentifier
		PublicKey           asn1.BitString
	}

	key := &PublicKeyInfo{}
	_, err := asn1.Unmarshal(byt, key)
	if err != nil {
		return nil, err
	}

	// Check if the parsed key uses ECDSA public key algorithm
	ecdsaPublicKeyAlgorithmOID := asn1.ObjectIdentifier{1, 2, 840, 10045, 2, 1}
	if !key.AlgorithmIdentifier.Algorithm.Equal(ecdsaPublicKeyAlgorithmOID) {
		return nil, errors.New("public key is not an ECDSA public key")
	}

	// Check if the parsed key uses secp256k1 curve
	secp256k1OID := asn1.ObjectIdentifier{1, 3, 132, 0, 10}
	if !key.AlgorithmIdentifier.Parameters.Equal(secp256k1OID) {
		return nil, errors.New("public key is not a secp256k1 public key")
	}

	// Check if the public key is compressed and decompress it if necessary
	var pubKeyBytes []byte
	if key.PublicKey.Bytes[0] == 0x02 || key.PublicKey.Bytes[0] == 0x03 {
		// Decompress the public key
		pubKey, err := btcec.ParsePubKey(key.PublicKey.Bytes)
		if err != nil {
			return nil, err
		}
		pubKeyBytes = pubKey.SerializeUncompressed()
	} else {
		pubKeyBytes = key.PublicKey.Bytes
	}

	if len(pubKeyBytes) != 65 {
		return nil, errors.New("invalid public key length")
	}

	x := new(big.Int).SetBytes(pubKeyBytes[1:33])
	y := new(big.Int).SetBytes(pubKeyBytes[33:])

	pubKey := &ecdsa.PublicKey{
		Curve: btcec.S256(),
		X:     x,
		Y:     y,
	}

	// Validate the public key
	if !pubKey.Curve.IsOnCurve(pubKey.X, pubKey.Y) {
		return nil, errors.New("public key is not on the curve")
	}

	return &_ECDSAPublicKey{
		PublicKey: pubKey,
	}, nil
}

func _ECDSAPublicKeyFromString(s string) (*_ECDSAPublicKey, error) {
	byt, err := hex.DecodeString(s)
	if err != nil {
		return &_ECDSAPublicKey{}, err
	}

	return _ECDSAPublicKeyFromBytes(byt)
}

func (pk _ECDSAPublicKey) _BytesRaw() []byte {
	return crypto.CompressPubkey(pk.PublicKey)
}

func (pk _ECDSAPublicKey) _BytesDer() []byte {
	// Marshal the public key
	publicKeyBytes := pk._BytesRaw()

	// Define the public key structure
	publicKeyInfo := struct {
		Algorithm struct {
			Algorithm  asn1.ObjectIdentifier
			Parameters asn1.ObjectIdentifier
		}
		PublicKey asn1.BitString
	}{
		Algorithm: struct {
			Algorithm  asn1.ObjectIdentifier
			Parameters asn1.ObjectIdentifier
		}{
			Algorithm:  asn1.ObjectIdentifier{1, 2, 840, 10045, 2, 1}, // id-ecPublicKey
			Parameters: asn1.ObjectIdentifier{1, 3, 132, 0, 10},       // secp256k1
		},
		PublicKey: asn1.BitString{
			Bytes:     publicKeyBytes,
			BitLength: 8 * len(publicKeyBytes),
		},
	}

	// Marshal the public key info into DER format
	derBytes, err := asn1.Marshal(publicKeyInfo)
	if err != nil {
		return nil
	}

	return derBytes
}

func (pk _ECDSAPublicKey) String() string {
	return pk._StringRaw()
}
func (pk _ECDSAPublicKey) _StringRaw() string {
	return hex.EncodeToString(pk._BytesRaw())
}
func (pk _ECDSAPublicKey) _StringDer() string {
	return hex.EncodeToString(pk._BytesDer())
}

func (pk _ECDSAPublicKey) _ToProtoKey() *services.Key {
	b := crypto.CompressPubkey(pk.PublicKey)
	return &services.Key{Key: &services.Key_ECDSASecp256K1{ECDSASecp256K1: b}}
}

func (pk _ECDSAPublicKey) _ToSignaturePairProtobuf(signature []byte) *services.SignaturePair {
	return &services.SignaturePair{
		PubKeyPrefix: pk._BytesRaw(),
		Signature: &services.SignaturePair_ECDSASecp256K1{
			ECDSASecp256K1: signature,
		},
	}
}

func (pk _ECDSAPublicKey) _Verify(message []byte, signature []byte) bool {
	return crypto.VerifySignature(pk._BytesRaw(), message, signature)
}

func (pk _ECDSAPublicKey) _VerifyTransaction(tx Transaction) bool {
	if tx.signedTransactions._Length() == 0 {
		return false
	}

	_, _ = tx._BuildAllTransactions()

	for _, value := range tx.signedTransactions.slice {
		tx := value.(*services.SignedTransaction)
		found := false
		for _, sigPair := range tx.SigMap.GetSigPair() {
			if bytes.Equal(sigPair.GetPubKeyPrefix(), pk._BytesRaw()) {
				found = true
				if !pk._Verify(tx.BodyBytes, sigPair.GetECDSASecp256K1()) {
					return false
				}
			}
		}

		if !found {
			return false
		}
	}

	return true
}

func (pk _ECDSAPublicKey) _ToFullKey() []byte {
	return elliptic.Marshal(crypto.S256(), pk.X, pk.Y)
}

func (pk _ECDSAPublicKey) _ToEthereumAddress() string {
	temp := pk._ToFullKey()[1:]
	hash := crypto.Keccak256(temp)
	return hex.EncodeToString(hash[12:])
}
// Filename: ed25519_private_key.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"crypto/ed25519"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha512"
	"crypto/x509/pkix"
	"encoding/asn1"
	"encoding/hex"
	"encoding/pem"
	"fmt"
	"io"
	"strings"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
	"github.com/youmark/pkcs8"
)

// _Ed25519PrivateKey is an ed25519 private key.
type _Ed25519PrivateKey struct {
	keyData   []byte
	chainCode []byte
}

func _GenerateEd25519PrivateKey() (*_Ed25519PrivateKey, error) {
	_, privateKey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return &_Ed25519PrivateKey{}, err
	}

	return &_Ed25519PrivateKey{
		keyData: privateKey,
	}, nil
}

// Deprecated
func GeneratePrivateKey() (PrivateKey, error) {
	_, privateKey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return PrivateKey{}, err
	}

	return PrivateKey{
		ed25519PrivateKey: &_Ed25519PrivateKey{
			keyData: privateKey,
		},
	}, nil
}

// _Ed25519PrivateKeyFromBytes constructs an _Ed25519PrivateKey from a raw slice of either 32 or 64 bytes.
func _Ed25519PrivateKeyFromBytes(bytes []byte) (*_Ed25519PrivateKey, error) {
	length := len(bytes)
	switch length {
	case 48:
		return _Ed25519PrivateKeyFromBytesDer(bytes)
	case 32:
		return _Ed25519PrivateKeyFromBytesRaw(bytes)
	case 64:
		return _Ed25519PrivateKeyFromBytesRaw(bytes)
	default:
		return &_Ed25519PrivateKey{}, _NewErrBadKeyf("invalid private key length: %v bytes", len(bytes))
	}
}

// _Ed25519PrivateKeyFromBytes constructs an _Ed25519PrivateKey from a raw slice of either 32 or 64 bytes.
func _Ed25519PrivateKeyFromBytesRaw(bytes []byte) (*_Ed25519PrivateKey, error) {
	return &_Ed25519PrivateKey{
		keyData: ed25519.NewKeyFromSeed(bytes[0:32]),
	}, nil
}

// _Ed25519PrivateKeyFromBytes constructs an _Ed25519PrivateKey from a raw slice of either 32 or 64 bytes.
func _Ed25519PrivateKeyFromBytesDer(byt []byte) (*_Ed25519PrivateKey, error) {
	given := hex.EncodeToString(byt)
	result := strings.ReplaceAll(given, _Ed25519PrivateKeyPrefix, "")
	decoded, err := hex.DecodeString(result)
	if err != nil {
		return &_Ed25519PrivateKey{}, err
	}

	length := len(decoded)
	if length != 32 && length != 64 {
		return &_Ed25519PrivateKey{}, _NewErrBadKeyf("invalid private key length: %v byt", len(byt))
	}

	return &_Ed25519PrivateKey{
		keyData: ed25519.NewKeyFromSeed(decoded[0:32]),
	}, nil
}

func _Ed25519PrivateKeyFromSeed(seed []byte) (*_Ed25519PrivateKey, error) {
	h := hmac.New(sha512.New, []byte("ed25519 seed"))

	_, err := h.Write(seed)
	if err != nil {
		return nil, err
	}

	digest := h.Sum(nil)

	keyBytes := digest[0:32]
	chainCode := digest[32:]
	privateKey, err := _Ed25519PrivateKeyFromBytes(keyBytes)

	if err != nil {
		return nil, err
	}
	privateKey.chainCode = chainCode

	return privateKey, nil
}

// Deprecated
// PrivateKeyFromMnemonic recovers an _Ed25519PrivateKey from a valid 24 word length mnemonic phrase and a
// passphrase.
//
// An empty string can be passed for passPhrase If the mnemonic phrase wasn't generated with a passphrase. This is
// required to recover a private key from a mnemonic generated by the Android and iOS wallets.
func _Ed25519PrivateKeyFromMnemonic(mnemonic Mnemonic, passPhrase string) (*_Ed25519PrivateKey, error) {
	seed := mnemonic._ToSeed(passPhrase)
	keyFromSeed, err := _Ed25519PrivateKeyFromSeed(seed)
	if err != nil {
		return nil, err
	}

	keyBytes := keyFromSeed.keyData
	chainCode := keyFromSeed.chainCode

	// note the index is for derivation, not the index of the slice
	for _, index := range []uint32{44, 3030, 0, 0} {
		keyBytes, chainCode, err = _DeriveEd25519ChildKey(keyBytes, chainCode, index)
		if err != nil {
			return nil, err
		}
	}

	privateKey, err := _Ed25519PrivateKeyFromBytes(keyBytes)

	if err != nil {
		return nil, err
	}

	privateKey.chainCode = chainCode

	return privateKey, nil
}

func _Ed25519PrivateKeyFromString(s string) (*_Ed25519PrivateKey, error) {
	bytes, err := hex.DecodeString(strings.ToLower(s))
	if err != nil {
		return &_Ed25519PrivateKey{}, err
	}

	return _Ed25519PrivateKeyFromBytes(bytes)
}

// PrivateKeyFromKeystore recovers an _Ed25519PrivateKey from an encrypted _Keystore encoded as a byte slice.
func _Ed25519PrivateKeyFromKeystore(ks []byte, passphrase string) (*_Ed25519PrivateKey, error) {
	key, err := _ParseKeystore(ks, passphrase)
	if err != nil {
		return &_Ed25519PrivateKey{}, err
	}

	if key.ed25519PrivateKey != nil {
		return key.ed25519PrivateKey, nil
	}

	return &_Ed25519PrivateKey{}, errors.New("only ed25519 keys are currently supported")
}

// PrivateKeyReadKeystore recovers an _Ed25519PrivateKey from an encrypted _Keystore file.
func _Ed25519PrivateKeyReadKeystore(source io.Reader, passphrase string) (*_Ed25519PrivateKey, error) {
	keystoreBytes, err := io.ReadAll(source)
	if err != nil {
		return &_Ed25519PrivateKey{}, err
	}

	return _Ed25519PrivateKeyFromKeystore(keystoreBytes, passphrase)
}

func _Ed25519PrivateKeyFromPem(bytes []byte, passphrase string) (*_Ed25519PrivateKey, error) {
	var blockType string

	if len(passphrase) == 0 {
		blockType = "PRIVATE KEY"
	} else {
		// the pem is encrypted
		blockType = "ENCRYPTED PRIVATE KEY"
	}

	var pk *pem.Block
	for block, rest := pem.Decode(bytes); block != nil; {
		if block.Type == blockType {
			pk = block
			break
		}

		bytes = rest
		if len(bytes) == 0 {
			// no key was found
			return &_Ed25519PrivateKey{}, _NewErrBadKeyf("pem file did not contain a private key")
		}
	}

	if pk == nil {
		// no key was found
		return &_Ed25519PrivateKey{}, _NewErrBadKeyf("no PEM data is found")
	}

	if len(passphrase) == 0 {
		// key does not need decrypted, end here
		key, err := PrivateKeyFromString(hex.EncodeToString(pk.Bytes))
		if err != nil {
			return &_Ed25519PrivateKey{}, err
		}
		return key.ed25519PrivateKey, nil
	}

	keyI, err := pkcs8.ParsePKCS8PrivateKey(pk.Bytes, []byte(passphrase))
	if err != nil {
		return &_Ed25519PrivateKey{}, err
	}

	return _Ed25519PrivateKeyFromBytes(keyI.(ed25519.PrivateKey))
}

func _Ed25519PrivateKeyReadPem(source io.Reader, passphrase string) (*_Ed25519PrivateKey, error) {
	// note: Passphrases are currently not supported, but included in the function definition to avoid breaking
	// changes in the future.

	pemFileBytes, err := io.ReadAll(source)
	if err != nil {
		return &_Ed25519PrivateKey{}, err
	}

	return _Ed25519PrivateKeyFromPem(pemFileBytes, passphrase)
}

// _Ed25519PublicKey returns the _Ed25519PublicKey associated with this _Ed25519PrivateKey.
func (sk _Ed25519PrivateKey) _PublicKey() *_Ed25519PublicKey {
	return &_Ed25519PublicKey{
		keyData: sk.keyData[32:],
	}
}

// String returns the text-encoded representation of the _Ed25519PrivateKey.
func (sk _Ed25519PrivateKey) String() string {
	return sk._StringRaw()
}

// String returns the text-encoded representation of the _Ed25519PrivateKey.
func (sk _Ed25519PrivateKey) _StringDer() string {
	return fmt.Sprint(_Ed25519PrivateKeyPrefix, hex.EncodeToString(sk.keyData[:32]))
}

// String returns the text-encoded representation of the _Ed25519PrivateKey.
func (sk _Ed25519PrivateKey) _StringRaw() string {
	return hex.EncodeToString(sk.keyData[:32])
}

// _BytesRaw returns the byte slice representation of the _Ed25519PrivateKey.
func (sk _Ed25519PrivateKey) _BytesRaw() []byte {
	return sk.keyData[0:32]
}

func (sk _Ed25519PrivateKey) _BytesDer() []byte {
	type PrivateKeyInfo struct {
		Version             int
		PrivateKeyAlgorithm pkix.AlgorithmIdentifier
		PrivateKey          asn1.RawValue
	}

	// AlgorithmIdentifier for Ed25519 keys
	ed25519OID := asn1.ObjectIdentifier{1, 3, 101, 112}
	privateKeyBytes, err := asn1.Marshal(sk.keyData[:32])
	if err != nil {
		return nil
	}
	privateKeyInfo := PrivateKeyInfo{
		Version: 0,
		PrivateKeyAlgorithm: pkix.AlgorithmIdentifier{
			Algorithm: ed25519OID,
		},
		PrivateKey: asn1.RawValue{
			Tag:   asn1.TagOctetString,
			Class: asn1.ClassUniversal,
			Bytes: privateKeyBytes,
		},
	}

	derBytes, err := asn1.Marshal(privateKeyInfo)
	if err != nil {
		return nil
	}

	return derBytes
}

// Keystore returns an encrypted _Keystore containing the _Ed25519PrivateKey.
func (sk _Ed25519PrivateKey) _Keystore(passphrase string) ([]byte, error) {
	return _NewKeystore(sk.keyData, passphrase)
}

// WriteKeystore writes an encrypted _Keystore containing the _Ed25519PrivateKey to the provided destination.
func (sk _Ed25519PrivateKey) _WriteKeystore(destination io.Writer, passphrase string) error {
	keystore, err := sk._Keystore(passphrase)
	if err != nil {
		return err
	}

	_, err = destination.Write(keystore)

	return err
}

// Sign signs the provided message with the _Ed25519PrivateKey.
func (sk _Ed25519PrivateKey) _Sign(message []byte) []byte {
	return ed25519.Sign(sk.keyData, message)
}

// SupportsDerivation returns true if the _Ed25519PrivateKey supports derivation.
func (sk _Ed25519PrivateKey) _SupportsDerivation() bool {
	return sk.chainCode != nil
}

// Derive a child key compatible with the iOS and Android wallets using a provided wallet/account index. Use index 0 for
// the default account.
//
// This will fail if the key does not support derivation which can be checked by calling SupportsDerivation()
func (sk _Ed25519PrivateKey) _Derive(index uint32) (*_Ed25519PrivateKey, error) {
	if !sk._SupportsDerivation() {
		return nil, _NewErrBadKeyf("child key cannot be derived from this key")
	}

	derivedKeyBytes, chainCode, err := _DeriveEd25519ChildKey(sk._BytesRaw(), sk.chainCode, index)
	if err != nil {
		return nil, err
	}

	derivedKey, err := _Ed25519PrivateKeyFromBytes(derivedKeyBytes)

	if err != nil {
		return nil, err
	}

	derivedKey.chainCode = chainCode

	return derivedKey, nil
}

func (sk _Ed25519PrivateKey) _LegacyDerive(index int64) (*_Ed25519PrivateKey, error) {
	keyData, err := _DeriveLegacyChildKey(sk._BytesRaw(), index)
	if err != nil {
		return nil, err
	}

	return _Ed25519PrivateKeyFromBytes(keyData)
}

func (sk _Ed25519PrivateKey) _ToProtoKey() *services.Key {
	return sk._PublicKey()._ToProtoKey()
}

func (sk _Ed25519PrivateKey) _SignTransaction(tx *Transaction) ([]byte, error) {
	tx._RequireOneNodeAccountID()

	if tx.signedTransactions._Length() == 0 {
		return make([]byte, 0), errTransactionRequiresSingleNodeAccountID
	}

	signature := sk._Sign(tx.signedTransactions._Get(0).(*services.SignedTransaction).GetBodyBytes())

	publicKey := sk._PublicKey()
	if publicKey == nil {
		return []byte{}, errors.New("public key is nil")
	}

	wrappedPublicKey := PublicKey{
		ed25519PublicKey: publicKey,
	}

	if tx._KeyAlreadySigned(wrappedPublicKey) {
		return []byte{}, nil
	}

	tx.transactions = _NewLockableSlice()
	tx.publicKeys = append(tx.publicKeys, wrappedPublicKey)
	tx.transactionSigners = append(tx.transactionSigners, nil)
	tx.transactionIDs.locked = true

	for index := 0; index < tx.signedTransactions._Length(); index++ {
		temp := tx.signedTransactions._Get(index).(*services.SignedTransaction)
		temp.SigMap.SigPair = append(
			temp.SigMap.SigPair,
			publicKey._ToSignaturePairProtobuf(signature),
		)
		tx.signedTransactions._Set(index, temp)
	}

	return signature, nil
}
// Filename: ed25519_public_key.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"crypto/ed25519"
	"crypto/x509/pkix"
	"encoding/asn1"
	"encoding/hex"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
)

// _Ed25519PublicKey is an ed25519 public key.
type _Ed25519PublicKey struct {
	keyData []byte
}

// PublicKeyFromString recovers an _Ed25519PublicKey from its text-encoded representation.
func _Ed25519PublicKeyFromString(s string) (*_Ed25519PublicKey, error) {
	byt, err := hex.DecodeString(s)
	if err != nil {
		return &_Ed25519PublicKey{}, err
	}

	return _Ed25519PublicKeyFromBytes(byt)
}

// _Ed25519PublicKeyFromBytes constructs a known _Ed25519PublicKey from its text-encoded representation.
func _Ed25519PublicKeyFromBytes(bytes []byte) (*_Ed25519PublicKey, error) {
	length := len(bytes)
	switch length {
	case 32:
		return _Ed25519PublicKeyFromBytesRaw(bytes)
	case 44:
		return _Ed25519PublicKeyFromBytesDer(bytes)
	default:
		return &_Ed25519PublicKey{}, _NewErrBadKeyf("invalid public key length: %v bytes", len(bytes))
	}
}

// _Ed25519PublicKeyFromBytes constructs a known _Ed25519PublicKey from its text-encoded representation.
func _Ed25519PublicKeyFromBytesRaw(bytes []byte) (*_Ed25519PublicKey, error) {
	if bytes == nil {
		return &_Ed25519PublicKey{}, errByteArrayNull
	}
	if len(bytes) != ed25519.PublicKeySize {
		return &_Ed25519PublicKey{}, _NewErrBadKeyf("invalid public key length: %v bytes", len(bytes))
	}

	return &_Ed25519PublicKey{
		keyData: bytes,
	}, nil
}

func _Ed25519PublicKeyFromBytesDer(bytes []byte) (*_Ed25519PublicKey, error) {
	ed25519OID := asn1.ObjectIdentifier{1, 3, 101, 112}

	publicKeyInfo := struct {
		Algorithm pkix.AlgorithmIdentifier
		PublicKey asn1.BitString
	}{}

	_, err := asn1.Unmarshal(bytes, &publicKeyInfo)
	if err != nil {
		return nil, err
	}

	if !publicKeyInfo.Algorithm.Algorithm.Equal(ed25519OID) {
		return nil, errors.New("invalid algorithm identifier, expected Ed25519")
	}

	if len(publicKeyInfo.PublicKey.Bytes) != 32 {
		return nil, errors.New("invalid public key length, expected 32 bytes")
	}

	var pk _Ed25519PublicKey
	pk.keyData = publicKeyInfo.PublicKey.Bytes

	return &pk, nil
}

func (pk _Ed25519PublicKey) _StringDer() string {
	return hex.EncodeToString(pk._BytesDer())
}

// String returns the text-encoded representation of the _Ed25519PublicKey.
func (pk _Ed25519PublicKey) _StringRaw() string {
	return hex.EncodeToString(pk.keyData)
}

// _Bytes returns the byte slice representation of the _Ed25519PublicKey.
func (pk _Ed25519PublicKey) _Bytes() []byte {
	return pk.keyData
}

// _Bytes returns the byte slice representation of the _Ed25519PublicKey.
func (pk _Ed25519PublicKey) _BytesRaw() []byte {
	return pk.keyData
}

func (pk _Ed25519PublicKey) _BytesDer() []byte {
	type PublicKeyInfo struct {
		Algorithm pkix.AlgorithmIdentifier
		PublicKey asn1.BitString
	}

	ed25519OID := asn1.ObjectIdentifier{1, 3, 101, 112}
	publicKeyInfo := PublicKeyInfo{
		Algorithm: pkix.AlgorithmIdentifier{
			Algorithm: ed25519OID,
		},
		PublicKey: asn1.BitString{
			Bytes:     pk.keyData,
			BitLength: len(pk.keyData) * 8,
		},
	}

	derBytes, err := asn1.Marshal(publicKeyInfo)
	if err != nil {
		return nil
	}

	return derBytes
}

func (pk _Ed25519PublicKey) _ToProtoKey() *services.Key {
	return &services.Key{Key: &services.Key_Ed25519{Ed25519: pk.keyData}}
}

func (pk _Ed25519PublicKey) String() string {
	return pk._StringRaw()
}

func (pk _Ed25519PublicKey) _ToSignaturePairProtobuf(signature []byte) *services.SignaturePair {
	return &services.SignaturePair{
		PubKeyPrefix: pk.keyData,
		Signature: &services.SignaturePair_Ed25519{
			Ed25519: signature,
		},
	}
}

func (pk _Ed25519PublicKey) _Verify(message []byte, signature []byte) bool {
	return ed25519.Verify(pk._Bytes(), message, signature)
}

func (pk _Ed25519PublicKey) _VerifyTransaction(tx Transaction) bool {
	if tx.signedTransactions._Length() == 0 {
		return false
	}

	_, _ = tx._BuildAllTransactions()

	for _, value := range tx.signedTransactions.slice {
		tx := value.(*services.SignedTransaction)
		found := false
		for _, sigPair := range tx.SigMap.GetSigPair() {
			if bytes.Equal(sigPair.GetPubKeyPrefix(), pk._Bytes()) {
				found = true
				if !pk._Verify(tx.BodyBytes, sigPair.GetEd25519()) {
					return false
				}
			}
		}

		if !found {
			return false
		}
	}

	return true
}
// Filename: endpoint.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

type Endpoint struct {
	address    []byte
	port       int32
	domainName string
}

func (endpoint *Endpoint) SetAddress(address []byte) *Endpoint {
	endpoint.address = address
	return endpoint
}

func (endpoint *Endpoint) GetAddress() []byte {
	return endpoint.address
}

func (endpoint *Endpoint) SetPort(port int32) *Endpoint {
	endpoint.port = port
	return endpoint
}

func (endpoint *Endpoint) GetPort() int32 {
	return endpoint.port
}

func (endpoint *Endpoint) SetDomainName(domainName string) *Endpoint {
	endpoint.domainName = domainName
	return endpoint
}

func (endpoint *Endpoint) GetDomainName() string {
	return endpoint.domainName
}

func EndpointFromProtobuf(serviceEndpoint *services.ServiceEndpoint) Endpoint {
	port := serviceEndpoint.GetPort()

	if port == 0 || port == 50111 {
		port = 50211
	}

	return Endpoint{
		address:    serviceEndpoint.GetIpAddressV4(),
		port:       port,
		domainName: serviceEndpoint.GetDomainName(),
	}
}

func (endpoint *Endpoint) _ToProtobuf() *services.ServiceEndpoint {
	return &services.ServiceEndpoint{
		IpAddressV4: endpoint.address,
		Port:        endpoint.port,
		DomainName:  endpoint.domainName,
	}
}

func (endpoint *Endpoint) String() string {
	if endpoint.domainName != "" {
		// If domain name is populated domainName + port
		return endpoint.domainName + ":" + fmt.Sprintf("%d", endpoint.port)
	} else {
		return fmt.Sprintf("%d.%d.%d.%d:%d",
			int(endpoint.address[0])&0xFF,
			int(endpoint.address[1])&0xFF,
			int(endpoint.address[2])&0xFF,
			int(endpoint.address[3])&0xFF,
			endpoint.port)
	}
}
// Filename: entity_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"regexp"
	"strconv"

	"github.com/pkg/errors"
)

// EntityID is an interface for various IDs of entities (Account, Contract, File, etc)
type EntityID interface {
	_IsEntityID()
}

type _ParseAddressResult struct {
	status             int
	num1               int64
	num2               int64
	num3               int64
	correctChecksum    string
	givenChecksum      string
	noChecksumFormat   string
	withChecksumFormat string
}

func _ChecksumVerify(num int) error {
	switch num {
	case 0:
		return errors.New("Invalid ID: format should look like 0.0.123 or 0.0.123-laujm")
	case 1:
		return errors.New("Invalid ID: checksum does not match")
	case 2:
		return nil
	case 3:
		return nil
	default:
		return errors.New("Unrecognized status")
	}
}

func _ChecksumParseAddress(ledgerID *LedgerID, address string) (_ParseAddressResult, error) {
	var err error
	match := regexp.MustCompile(`(0|(?:[1-9]\d*))\.(0|(?:[1-9]\d*))\.(0|(?:[1-9]\d*))(?:-([a-z]{5}))?$`)

	matchArray := match.FindStringSubmatch(address)

	a := make([]int64, len(matchArray))
	for i := 1; i < len(matchArray)-1; i++ {
		a[i], err = strconv.ParseInt(matchArray[i], 10, 64)
		if err != nil {
			return _ParseAddressResult{status: 0}, err
		}
	}

	ad := fmt.Sprintf("%s.%s.%s", matchArray[1], matchArray[2], matchArray[3])

	checksum := _CheckChecksum(ledgerID._LedgerIDBytes, ad)

	var status int
	switch m := matchArray[4]; {
	case m == "":
		status = 2
	case m == checksum:
		status = 3
	default:
		status = 1
	}

	return _ParseAddressResult{
		status:             status,
		num1:               a[1],
		num2:               a[2],
		num3:               a[3],
		correctChecksum:    checksum,
		givenChecksum:      matchArray[4],
		noChecksumFormat:   ad,
		withChecksumFormat: ad + "(" + checksum + ")",
	}, nil
}

func _CheckChecksum(ledgerID []byte, address string) string {
	answer := ""
	digits := make([]int, 0)
	s0 := 0
	s1 := 0
	s := 0
	sh := 0
	checksum := 0
	n := len(address)
	p3 := 26 * 26 * 26
	p5 := 26 * 26 * 26 * 26 * 26
	m := 1000003
	asciiA := []rune("a")[0]
	w := 31

	h := make([]byte, len(ledgerID)+6)
	copy(h[0:len(ledgerID)], ledgerID)

	for _, j := range address {
		if string(j) == "." {
			digits = append(digits, 10)
		} else {
			processed, _ := strconv.Atoi(string(j))
			digits = append(digits, processed)
		}
	}

	for i := 0; i < len(digits); i++ {
		s = (w*s + digits[i]) % p3
		if i%2 == 0 {
			s0 = (s0 + digits[i]) % 11
		} else {
			s1 = (s1 + digits[i]) % 11
		}
	}

	for i := 0; i < len(h); i++ {
		sh = (w*sh + int(h[i])) % p5
	}

	checksum = ((((n%5)*11+s0)*11+s1)*p3 + s + sh) % p5
	checksum = (checksum * m) % p5

	for i := 0; i < 5; i++ {
		answer = string(asciiA+rune(checksum%26)) + answer
		checksum /= 26
	}

	return answer
}

func (id AccountID) _IsEntityID() {}

// func (id FileID) _IsEntityID()     {}
// func (id ContractID) _IsEntityID() {}
// Filename: errors.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"errors"
	"fmt"

	// "reflect"

	"google.golang.org/grpc/codes"
)

type ErrMaxChunksExceeded struct {
	Chunks    uint64
	MaxChunks uint64
}

var errTransactionIsFrozen = errors.New("transaction is immutable; it has at least one signature or has been explicitly frozen")
var errNoClientOrTransactionID = errors.New("`client` must have an `_Operator` or `transactionId` must be set")
var errNoClientOrTransactionIDOrNodeId = errors.New("`client` must be provided or both `nodeId` and `transactionId` must be set") // nolint
var errClientOperatorSigning = errors.New("`client` must have an `_Operator` to sign with the _Operator")
var errNoClientProvided = errors.New("`client` must be provided and have an _Operator")
var errTransactionIsNotFrozen = errors.New("transaction is not frozen")
var errFailedToDeserializeBytes = errors.New("failed to deserialize bytes")
var errNoTransactionInBytes = errors.New("no transaction was found in bytes")
var errTransactionRequiresSingleNodeAccountID = errors.New("`PrivateKey.SignTransaction()` requires `Transaction` to have a single _Node `AccountID` set")
var errNoTransactions = errors.New("no transactions to execute")
var errByteArrayNull = errors.New("byte array can't be null")
var errParameterNull = errors.New("the parameter can't be null")
var errNetworkNameMissing = errors.New("can't derive checksum for ID without knowing which _Network the ID is for")
var errChecksumMissing = errors.New("no checksum provided")
var errLockedSlice = errors.New("slice is locked")
var errNodeIsUnhealthy = errors.New("node is unhealthy")

type ErrInvalidNodeAccountIDSet struct {
	NodeAccountID AccountID
}

func (err ErrInvalidNodeAccountIDSet) Error() string {
	return fmt.Sprintf("Invalid node AccountID was set for transaction: %v", err.NodeAccountID.String())
}

func (err ErrMaxChunksExceeded) Error() string {
	return fmt.Sprintf("Message requires %d chunks, but max chunks is %d", err.Chunks, err.MaxChunks)
}

// ErrMaxQueryPaymentExceeded is returned during query execution if the total cost of the query + estimated fees exceeds
// the max query payment threshold set on the client or QueryBuilder.
type ErrMaxQueryPaymentExceeded struct {
	// The cost of the query that was attempted as returned by QueryBuilder.GetCost
	QueryCost Hbar
	// The limit for a single automatic query payment, set by
	// Client.SetMaxQueryPayment(int64) or QueryBuilder.SetMaxQueryPayment(uint64).
	MaxQueryPayment Hbar
	// Name of the query transaction class used for output
	query string
}

// Error() implements the Error interface
func (e ErrMaxQueryPaymentExceeded) Error() string {
	return fmt.Sprintf("cost of %s (%s) without explicit payment is greater than the max query payment of %s",
		e.query,
		e.QueryCost.String(),
		e.MaxQueryPayment.String())
}

// ErrBadKey is returned if a key is provided in an invalid format or structure
type ErrBadKey struct {
	message string
}

func _NewErrBadKeyf(format string, a ...interface{}) ErrBadKey {
	return ErrBadKey{fmt.Sprintf(format, a...)}
}

// Error() implements the Error interface
func (e ErrBadKey) Error() string {
	return e.message
}

// ErrHederaNetwork is returned in cases where the Hedera _Network cannot be reached or a _Network-side error occurs.
type ErrHederaNetwork struct {
	error error
	// GRPC Status Code
	StatusCode *codes.Code
}

// Error() implements the Error interface
func (e ErrHederaNetwork) Error() string {
	return fmt.Sprintf("transport error occurred while accessing the Hedera _Network: %s", e.error)
}

// ErrHederaPreCheckStatus is returned by Transaction.Execute and QueryBuilder.Execute if an exceptional status is
// returned during _Network side validation of the sent transaction.
type ErrHederaPreCheckStatus struct {
	TxID   TransactionID
	Status Status
}

// Error() implements the Error interface
func (e ErrHederaPreCheckStatus) Error() string {
	if e.TxID.AccountID == nil {
		return fmt.Sprintf("exceptional precheck status %s", e.Status.String())
	}
	if e.TxID.AccountID._IsZero() {
		return fmt.Sprintf("exceptional precheck status %s", e.Status.String())
	}
	return fmt.Sprintf("exceptional precheck status %s received for transaction %v", e.Status.String(), e.TxID)
}

// ErrHederaReceiptStatus is returned by TransactionID.GetReceipt if the status of the receipt is exceptional.
type ErrHederaReceiptStatus struct {
	TxID    TransactionID
	Status  Status
	Receipt TransactionReceipt
}

func _NewErrHederaReceiptStatus(id TransactionID, status Status) ErrHederaReceiptStatus {
	return ErrHederaReceiptStatus{TxID: id, Status: status}
}

// Error() implements the Error interface
func (e ErrHederaReceiptStatus) Error() string {
	return fmt.Sprintf("exceptional receipt status: %s", e.Status.String())
}

// ErrHederaRecordStatus is returned by TransactionID.GetRecord if the status of the record is exceptional.
type ErrHederaRecordStatus struct {
	TxID   TransactionID
	Status Status
}

// Error() implements the Error interface
func (e ErrHederaRecordStatus) Error() string {
	return fmt.Sprintf("exceptional precheck status %s", e.Status.String())
}

// ErrLocalValidation is returned by TransactionBuilder.Build(*Client) and QueryBuilder.Execute(*Client)
// if the constructed transaction or query fails local sanity checks.
type ErrLocalValidation struct {
	message string
}

// Error() implements the Error interface
func (e ErrLocalValidation) Error() string {
	return e.message
}
// Filename: ethereum_data_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestUnitEthereumData(t *testing.T) {
	t.Parallel()

	byt, err := hex.DecodeString("02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
	require.NoError(t, err)
	b, err := EthereumTransactionDataFromBytes(byt)
	require.NoError(t, err)
	k, err := b.ToBytes()
	require.Equal(t, hex.EncodeToString(k), "02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
}

func TestUnitEthereumJson(t *testing.T) {
	t.Parallel()

	byt, err := hex.DecodeString("02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
	require.NoError(t, err)
	b, err := EthereumTransactionDataFromBytes(byt)
	require.NoError(t, err)
	k, err := b.ToJson()
	require.Equal(t, string(k), "{\"ChainID\":298,\"Nonce\":2,\"GasTipCap\":47,\"GasFeeCap\":47,\"Gas\":98304,\"To\":\"0x7e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181\",\"Value\":1000000000000000000,\"Data\":\"EjRW\",\"AccessList\":[],\"v\":1,\"r\":100994654910787593347140909067229841565925886199208140719315441876745360233593,\"s\":12070180598849582105957204602453860723012110108194703753759584093273689501030}")
	second, err := EthereumTransactionDataFromJson(k)
	require.NoError(t, err)
	bytSecond, err := second.ToBytes()
	require.NoError(t, err)
	require.Equal(t, hex.EncodeToString(bytSecond), "02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
}
// Filename: ethereum_flow.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import "github.com/pkg/errors"

// Execute an Ethereum transaction on Hedera
type EthereumFlow struct {
	Transaction
	ethereumData    *EthereumTransactionData
	callDataFileID  *FileID
	maxGasAllowance *Hbar
	nodeAccountIDs  []AccountID
}

// Execute an Ethereum transaction on Hedera
func NewEthereumFlow() *EthereumFlow {
	tx := EthereumFlow{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(20))

	return &tx
}

// SetEthereumData sets the raw Ethereum transaction.
func (transaction *EthereumFlow) SetEthereumData(data *EthereumTransactionData) *EthereumFlow {
	transaction._RequireNotFrozen()
	transaction.ethereumData = data
	return transaction
}

// SetEthereumDataBytes sets the raw Ethereum transaction.
func (transaction *EthereumFlow) SetEthereumDataBytes(data []byte) *EthereumFlow {
	transaction._RequireNotFrozen()
	temp, err := EthereumTransactionDataFromBytes(data)
	if err != nil {
		panic(err)
	}
	transaction.ethereumData = temp
	return transaction
}

// GetEthreumData  returns the data of the Ethereum transaction
func (transaction *EthereumFlow) GetEthereumData() *EthereumTransactionData {
	return transaction.ethereumData
}

// SetCallDataFileID sets the file ID containing the call data.
func (transaction *EthereumFlow) SetCallDataFileID(callData FileID) *EthereumFlow {
	transaction._RequireNotFrozen()
	transaction.callDataFileID = &callData
	return transaction
}

// GetCallDataFileID returns the file ID containing the call data.
func (transaction *EthereumFlow) GetCallDataFileID() FileID {
	if transaction.callDataFileID == nil {
		return FileID{}
	}

	return *transaction.callDataFileID
}

// SetMaxGasAllowance sets the maximum gas allowance for the transaction.
func (transaction *EthereumFlow) SetMaxGasAllowance(max Hbar) *EthereumFlow {
	transaction._RequireNotFrozen()
	transaction.maxGasAllowance = &max
	return transaction
}

// GetMaxGasAllowance returns the maximum gas allowance for the transaction.
func (transaction *EthereumFlow) GetMaxGasAllowance() Hbar {
	if transaction.maxGasAllowance == nil {
		return Hbar{}
	}

	return *transaction.maxGasAllowance
}

// SetNodeAccountIDs sets the node account IDs for this Ethereum transaction.
func (transaction *EthereumFlow) SetNodeAccountIDs(nodes []AccountID) *EthereumFlow {
	transaction._RequireNotFrozen()
	transaction.nodeAccountIDs = nodes
	return transaction
}

// GetNodeAccountIDs returns the node account IDs for this Ethereum transaction.
func (transaction *EthereumFlow) GetNodeAccountIDs() []AccountID {
	return transaction.nodeAccountIDs
}

func (transaction *EthereumFlow) _CreateFile(callData []byte, client *Client) (FileID, error) {
	fileCreate := NewFileCreateTransaction()
	if len(transaction.nodeAccountIDs) > 0 {
		fileCreate.SetNodeAccountIDs(transaction.nodeAccountIDs)
	}

	if len(callData) < 4097 {
		resp, err := fileCreate.
			SetContents(callData).
			Execute(client)
		if err != nil {
			return FileID{}, err
		}

		receipt, err := resp.GetReceipt(client)
		if err != nil {
			return FileID{}, err
		}

		return *receipt.FileID, nil
	}

	resp, err := fileCreate.
		SetContents(callData[:4097]).
		Execute(client)
	if err != nil {
		return FileID{}, err
	}

	receipt, err := resp.GetReceipt(client)
	if err != nil {
		return FileID{}, err
	}

	fileID := *receipt.FileID

	resp, err = NewFileAppendTransaction().
		SetFileID(fileID).
		SetContents(callData[4097:]).
		Execute(client)
	if err != nil {
		return FileID{}, err
	}

	_, err = resp.GetReceipt(client)
	if err != nil {
		return FileID{}, err
	}

	return fileID, nil
}

// Execute executes the Transaction with the provided client
func (transaction *EthereumFlow) Execute(client *Client) (TransactionResponse, error) {
	if transaction.ethereumData == nil {
		return TransactionResponse{}, errors.New("cannot submit ethereum transaction with no ethereum data")
	}

	ethereumTransaction := NewEthereumTransaction()
	if len(transaction.nodeAccountIDs) > 0 {
		ethereumTransaction.SetNodeAccountIDs(transaction.nodeAccountIDs)
	}
	dataBytes, err := transaction.ethereumData.ToBytes()
	if err != nil {
		return TransactionResponse{}, err
	}

	if transaction.maxGasAllowance != nil {
		ethereumTransaction.SetMaxGasAllowanceHbar(*transaction.maxGasAllowance)
	}

	if transaction.callDataFileID != nil { //nolint
		if len(transaction.ethereumData._GetData()) != 0 {
			return TransactionResponse{}, errors.New("call data file ID provided, but ethereum data already contains call data")
		}

		ethereumTransaction.
			SetEthereumData(dataBytes).
			SetCallDataFileID(*transaction.callDataFileID)
	} else if len(dataBytes) <= 5120 {
		ethereumTransaction.
			SetEthereumData(dataBytes)
	} else {
		fileID, err := transaction.
			_CreateFile(dataBytes, client)
		if err != nil {
			return TransactionResponse{}, err
		}

		transaction.ethereumData._SetData([]byte{})

		ethereumTransaction.
			SetEthereumData(dataBytes).
			SetCallDataFileID(fileID)
	}

	resp, err := ethereumTransaction.
		Execute(client)
	if err != nil {
		return TransactionResponse{}, err
	}

	_, err = resp.GetReceipt(client)
	if err != nil {
		return TransactionResponse{}, err
	}

	return resp, nil
}
// Filename: ethereum_flow_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
	protobuf "google.golang.org/protobuf/proto"
)

func TestUnitEthereumFlowMock(t *testing.T) {
	t.Parallel()

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)
		require.NotEqual(t, 0, len(sigMap.SigPair))

		if bod, ok := transactionBody.Data.(*services.TransactionBody_EthereumTransaction); ok {
			require.Equal(t, hex.EncodeToString(bod.EthereumTransaction.GetEthereumData()), "02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
			require.Nil(t, bod.EthereumTransaction.CallData)
		}

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call, &services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
						ResponseType:                services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	byt, err := hex.DecodeString("02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
	require.NoError(t, err)
	b, err := EthereumTransactionDataFromBytes(byt)
	require.NoError(t, err)

	_, err = NewEthereumFlow().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetEthereumData(b).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitEthereumFlowMockEthereumDateBytes(t *testing.T) {
	t.Parallel()

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)
		require.NotEqual(t, 0, len(sigMap.SigPair))

		if bod, ok := transactionBody.Data.(*services.TransactionBody_EthereumTransaction); ok {
			require.Equal(t, hex.EncodeToString(bod.EthereumTransaction.GetEthereumData()), "02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
			require.Nil(t, bod.EthereumTransaction.CallData)
		}

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call, &services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
						ResponseType:                services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	byt, err := hex.DecodeString("02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
	require.NoError(t, err)

	_, err = NewEthereumFlow().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetEthereumDataBytes(byt).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitEthereumFlowCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	file := FileID{File: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}

	byt, err := hex.DecodeString("02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
	require.NoError(t, err)

	client := ClientForTestnet()
	client.SetAutoValidateChecksums(true)

	transaction := NewEthereumFlow().
		SetNodeAccountIDs(nodeAccountID).
		SetCallDataFileID(file).
		SetEthereumDataBytes(byt).
		SetMaxGasAllowance(NewHbar(2))

	transaction._CreateFile(byt, client)

	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetEthereumData()
	transaction.GetCallDataFileID()
	transaction.GetMaxGasAllowance()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
}
// Filename: ethereum_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/pkg/errors"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// EthereumTransaction is used to create a EthereumTransaction transaction which can be used to construct and execute
// a Ethereum Transaction.
type EthereumTransaction struct {
	Transaction
	ethereumData  []byte
	callData      *FileID
	MaxGasAllowed int64
}

// NewEthereumTransaction creates a EthereumTransaction transaction which can be used to construct and execute
// a Ethereum Transaction.
func NewEthereumTransaction() *EthereumTransaction {
	tx := EthereumTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _EthereumTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *EthereumTransaction {
	return &EthereumTransaction{
		Transaction:   tx,
		ethereumData:  pb.GetEthereumTransaction().EthereumData,
		callData:      _FileIDFromProtobuf(pb.GetEthereumTransaction().CallData),
		MaxGasAllowed: pb.GetEthereumTransaction().MaxGasAllowance,
	}
}

// SetEthereumData
// The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
// unless the callData field is set.
func (tx *EthereumTransaction) SetEthereumData(data []byte) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.ethereumData = data
	return tx
}

// GetEthereumData returns the raw Ethereum transaction (RLP encoded type 0, 1, and 2).
func (tx *EthereumTransaction) GetEthereumData() []byte {
	return tx.ethereumData
}

// Deprecated
func (tx *EthereumTransaction) SetCallData(file FileID) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.callData = &file
	return tx
}

// SetCallDataFileID sets the file ID containing the call data.
func (tx *EthereumTransaction) SetCallDataFileID(file FileID) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.callData = &file
	return tx
}

// GetCallData
// For large transactions (for example contract create) this is the callData
// of the ethereumData. The data in the ethereumData will be re-written with
// the callData element as a zero length string with the original contents in
// the referenced file at time of execution. The ethereumData will need to be
// "rehydrated" with the callData for signature validation to pass.
func (tx *EthereumTransaction) GetCallData() FileID {
	if tx.callData != nil {
		return *tx.callData
	}

	return FileID{}
}

// SetMaxGasAllowed
// The maximum amount, in tinybars, that the payer of the hedera transaction
// is willing to pay to complete the transaction.
func (tx *EthereumTransaction) SetMaxGasAllowed(gas int64) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.MaxGasAllowed = gas
	return tx
}

// SetMaxGasAllowanceHbar sets the maximum amount, that the payer of the hedera transaction
// is willing to pay to complete the transaction.
func (tx *EthereumTransaction) SetMaxGasAllowanceHbar(gas Hbar) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.MaxGasAllowed = gas.AsTinybar()
	return tx
}

// GetMaxGasAllowed returns the maximum amount, that the payer of the hedera transaction
// is willing to pay to complete the transaction.
func (tx *EthereumTransaction) GetMaxGasAllowed() int64 {
	return tx.MaxGasAllowed
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *EthereumTransaction) Sign(
	privateKey PrivateKey,
) *EthereumTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *EthereumTransaction) SignWithOperator(
	client *Client,
) (*EthereumTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *EthereumTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *EthereumTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *EthereumTransaction) AddSignature(publicKey PublicKey, signature []byte) *EthereumTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *EthereumTransaction) SetGrpcDeadline(deadline *time.Duration) *EthereumTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *EthereumTransaction) Freeze() (*EthereumTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *EthereumTransaction) FreezeWith(client *Client) (*EthereumTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *EthereumTransaction) SetMaxTransactionFee(fee Hbar) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *EthereumTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// GetRegenerateTransactionID returns true if transaction ID regeneration is enabled.
func (tx *EthereumTransaction) GetRegenerateTransactionID() bool {
	return tx.Transaction.GetRegenerateTransactionID()
}

// GetTransactionMemo returns the memo for this EthereumTransaction.
func (tx *EthereumTransaction) GetTransactionMemo() string {
	return tx.Transaction.GetTransactionMemo()
}

// SetTransactionMemo sets the memo for this EthereumTransaction.
func (tx *EthereumTransaction) SetTransactionMemo(memo string) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this EthereumTransaction.
func (tx *EthereumTransaction) SetTransactionValidDuration(duration time.Duration) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *EthereumTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this EthereumTransaction.
func (tx *EthereumTransaction) SetTransactionID(transactionID TransactionID) *EthereumTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this EthereumTransaction.
func (tx *EthereumTransaction) SetNodeAccountIDs(nodeID []AccountID) *EthereumTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *EthereumTransaction) SetMaxRetry(count int) *EthereumTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *EthereumTransaction) SetMaxBackoff(max time.Duration) *EthereumTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *EthereumTransaction) SetMinBackoff(min time.Duration) *EthereumTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *EthereumTransaction) SetLogLevel(level LogLevel) *EthereumTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *EthereumTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *EthereumTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *EthereumTransaction) getName() string {
	return "EthereumTransaction"
}
func (tx *EthereumTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.callData != nil {
		if err := tx.callData.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *EthereumTransaction) build() *services.TransactionBody {
	body := &services.EthereumTransactionBody{
		EthereumData:    tx.ethereumData,
		MaxGasAllowance: tx.MaxGasAllowed,
	}

	if tx.callData != nil {
		body.CallData = tx.callData._ToProtobuf()
	}

	return &services.TransactionBody{
		TransactionID:            tx.transactionID._ToProtobuf(),
		TransactionFee:           tx.transactionFee,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		Memo:                     tx.Transaction.memo,
		Data: &services.TransactionBody_EthereumTransaction{
			EthereumTransaction: body,
		},
	}
}

func (tx *EthereumTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return nil, errors.New("cannot schedule `EthereumTransaction")
}

func (tx *EthereumTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetContract().CallEthereum,
	}
}
// Filename: ethereum_transaction_data.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/json"

	"github.com/pkg/errors"

	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
)

// Represents the data of an Ethereum transaction.
type EthereumTransactionData struct {
	eip1559 *types.DynamicFeeTx
	legacy  *types.LegacyTx
}

// EthereumTransactionDataFromBytes constructs an EthereumTransactionData from a raw byte array.
func EthereumTransactionDataFromBytes(b []byte) (*EthereumTransactionData, error) {
	var transactionData EthereumTransactionData
	if b[0] == 2 {
		byt := b
		byt = append(byt[:0], byt[0+1:]...)
		err := rlp.DecodeBytes(byt, &transactionData.eip1559)
		if err != nil {
			return nil, err
		}

		return &transactionData, nil
	}

	err := rlp.DecodeBytes(b, &transactionData.legacy)
	if err != nil {
		return nil, err
	}

	return &transactionData, nil
}

// ToBytes returns the raw bytes of the Ethereum transaction.
func (ethereumTxData *EthereumTransactionData) ToBytes() ([]byte, error) {
	var byt []byte
	var err error
	if ethereumTxData.eip1559 != nil {
		byt, err = rlp.EncodeToBytes(ethereumTxData.eip1559)
		if err != nil {
			return []byte{}, err
		}
		byt = append([]byte{2}, byt...)

		return byt, nil
	}

	byt, err = rlp.EncodeToBytes(ethereumTxData.legacy)
	if err != nil {
		return []byte{}, err
	}

	return byt, nil
}

func (ethereumTxData *EthereumTransactionData) _GetData() []byte {
	if ethereumTxData.eip1559 != nil {
		return ethereumTxData.eip1559.Data
	}

	return ethereumTxData.legacy.Data
}

func (ethereumTxData *EthereumTransactionData) _SetData(data []byte) *EthereumTransactionData {
	if ethereumTxData.eip1559 != nil {
		ethereumTxData.eip1559.Data = data
		return ethereumTxData
	}

	ethereumTxData.legacy.Data = data
	return ethereumTxData
}

// ToJson returns a JSON representation of the Ethereum transaction.
func (ethereumTxData *EthereumTransactionData) ToJson() ([]byte, error) {
	var byt []byte
	var err error
	if ethereumTxData.eip1559 != nil {
		byt, err = json.Marshal(ethereumTxData.eip1559)
		if err != nil {
			return []byte{}, err
		}

		return byt, nil
	}

	byt, err = json.Marshal(ethereumTxData.legacy)
	if err != nil {
		return []byte{}, err
	}

	return byt, nil
}

// EthereumTransactionDataFromJson constructs an EthereumTransactionData from a JSON string.
func EthereumTransactionDataFromJson(b []byte) (*EthereumTransactionData, error) {
	var eip1559 types.DynamicFeeTx
	var leg types.LegacyTx
	err := json.Unmarshal(b, &eip1559)
	if err != nil {
		err = json.Unmarshal(b, &leg)
		if err != nil {
			return nil, errors.New("Json bytes are neither eip1559 or legacy format")
		}

		return &EthereumTransactionData{
			legacy: &leg,
		}, nil
	}

	return &EthereumTransactionData{
		eip1559: &eip1559,
	}, nil
}
// Filename: ethereum_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"io"

	"testing"

	"github.com/ethereum/go-ethereum/rlp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type EIP1559RLP struct {
	chainId        []byte
	nonce          []byte
	maxPriorityGas []byte
	maxGas         []byte
	gasLimit       []byte
	to             []byte
	value          []byte
	callData       []byte
	accessList     [][]byte
	recId          []byte
	r              []byte
	s              []byte
}

// EncodeRLP writes l as RLP list [ethereumfield1, ethereumfield2...] Omits r,s,v values on first encode
func (l *EIP1559RLP) EncodeRLP(w io.Writer) (err error) {
	fields := []interface{}{
		l.chainId,
		l.nonce,
		l.maxPriorityGas,
		l.maxGas,
		l.gasLimit,
		l.to,
		l.value,
		l.callData,
		l.accessList,
	}
	if len(l.recId) > 0 && len(l.r) > 0 && len(l.s) > 0 {
		fields = append(fields, l.recId, l.r, l.s)
	}

	return rlp.Encode(w, fields)
}

// decodeHex is a helper function that decodes a hex string and fails the test if an error occurs.
func decodeHex(t *testing.T, s string) []byte {
	bytes, err := hex.DecodeString(s)
	if err != nil {
		t.Fatalf("Failed to decode string %s: %v", s, err)
	}
	return bytes
}

// Testing the signer nonce defined in HIP-844
func TestIntegrationEthereumTransaction(t *testing.T) {
	// Skip this test because it is flaky with newest version of Local Node
	t.Skip()
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	smartContractBytecode := []byte("608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033")
	ecdsaPrivateKey, _ := PrivateKeyFromStringECDSA("30540201010420ac318ea8ff8d991ab2f16172b4738e74dc35a56681199cfb1c0cb2e7cb560ffda00706052b8104000aa124032200036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4")
	aliasAccountId := ecdsaPrivateKey.ToAccountID(0, 0)

	// Create a shallow account for the ECDSA key
	resp, err := NewTransferTransaction().
		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(-2)).
		AddHbarTransfer(*aliasAccountId, NewHbar(2)).
		Execute(env.Client)

	// Create file with the contract bytecode
	resp, err = NewFileCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKeys(env.OperatorKey.PublicKey()).
		SetContents(smartContractBytecode).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	// Create contract to be called by EthereumTransaction
	resp, err = NewContractCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetGas(1000000).
		SetConstructorParameters(NewContractFunctionParameters().AddString("hello from hedera")).
		SetBytecodeFileID(fileID).
		SetContractMemo("hedera-sdk-go::TestContractCreateTransaction_Execute").
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.ContractID)
	contractID := *receipt.ContractID

	// Call data for the smart contract
	contractMsg := "setMessage"
	msgPointer := &contractMsg

	// build the RLP list that should be signed with the test ECDSA private key
	list := &EIP1559RLP{
		chainId:        decodeHex(t, "012a"),
		nonce:          []byte{},
		maxPriorityGas: decodeHex(t, "00"),
		maxGas:         decodeHex(t, "d1385c7bf0"),
		gasLimit:       decodeHex(t, "0249f0"),
		to:             decodeHex(t, contractID.ToSolidityAddress()),
		value:          []byte{},
		callData:       NewContractFunctionParameters().AddString("new message")._Build(msgPointer),
		accessList:     [][]byte{},
	}

	bytes, _ := rlp.EncodeToBytes(list)

	// 02 is the type of the transaction EIP1559 and should be concatenated to the RLP by service requirement
	bytesToSign := append(decodeHex(t, "02"), bytes...)
	signedBytes := ecdsaPrivateKey.Sign(bytesToSign)

	// Add signature data to the RLP list for EthereumTransaction submition
	list.recId = decodeHex(t, "01")
	list.r = signedBytes[:32]
	list.s = signedBytes[len(signedBytes)-32:]

	ethereumTransactionData, _ := rlp.EncodeToBytes(list)
	// 02 is the type of the transaction EIP1559 and should be concatenated to the RLP by service requirement
	resp, err = NewEthereumTransaction().SetEthereumData(append(decodeHex(t, "02"), ethereumTransactionData...)).Execute(env.Client)

	require.NoError(t, err)

	record, _ := resp.GetRecord(env.Client)

	assert.Equal(t, int64(1), record.CallResult.SignerNonce)

	resp, err = NewContractDeleteTransaction().
		SetContractID(contractID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)

}
// Filename: ethereum_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/require"
)

func TestUnitEthereumTransactionMock(t *testing.T) {
	t.Parallel()

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	byt, err := hex.DecodeString("02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
	require.NoError(t, err)
	b, err := EthereumTransactionDataFromBytes(byt)
	toByt, err := b.ToBytes()

	tran := TransactionIDGenerate(AccountID{Account: 3})

	_, err = NewEthereumTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTransactionID(tran).
		SetEthereumData(toByt).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitEthereumTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	file := FileID{File: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	byt, err := hex.DecodeString("02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66")
	require.NoError(t, err)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewEthereumTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetEthereumData(byt).
		SetCallDataFileID(file).
		SetCallData(file).
		SetMaxGasAllowed(234).
		SetMaxGasAllowanceHbar(NewHbar(3)).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err = transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetEthereumData()
	transaction.GetCallData()
	transaction.GetMaxGasAllowed()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case EthereumTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}
// Filename: examples/account_allowance/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	aliceKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}
	bobKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	charlieKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	transactionResponse, err := hedera.NewAccountCreateTransaction().
		SetKey(aliceKey.PublicKey()).
		SetInitialBalance(hedera.NewHbar(5)).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating account", err))
	}

	transactionReceipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account creation receipt", err))
	}

	aliceID := *transactionReceipt.AccountID

	transactionResponse, err = hedera.NewAccountCreateTransaction().
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetKey(bobKey.PublicKey()).
		SetInitialBalance(hedera.NewHbar(5)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating second account", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving second account creation receipt", err))
	}

	bobID := *transactionReceipt.AccountID

	transactionResponse, err = hedera.NewAccountCreateTransaction().
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetKey(charlieKey.PublicKey()).
		SetInitialBalance(hedera.NewHbar(5)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating second account", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving second account creation receipt", err))
	}

	charlieID := *transactionReceipt.AccountID

	println("Alice's ID:", aliceID.String())
	println("Bob's ID:", bobID.String())
	println("Charlie's ID:", charlieID.String())
	println("Initial Balance:")
	err = printBalance(client, aliceID, bobID, charlieID, []hedera.AccountID{transactionResponse.NodeID})
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving balances", err))
	}

	println("Approve an allowance of 2 Hbar with owner Alice and spender Bob")

	approvalFreeze, err := hedera.NewAccountAllowanceApproveTransaction().
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		ApproveHbarAllowance(aliceID, bobID, hedera.NewHbar(2)).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account allowance approve transaction", err))
	}

	approvalFreeze.Sign(aliceKey)

	transactionResponse, err = approvalFreeze.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account allowance approve transaction", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting account allowance receipt", err))
	}

	err = printBalance(client, aliceID, bobID, charlieID, []hedera.AccountID{transactionResponse.NodeID})
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving balances", err))
	}

	println("Transferring 1 Hbar from Alice to Charlie, but the transaction is signed _only_ by Bob (Bob is dipping into his allowance from Alice)")

	transferFreeze, err := hedera.NewTransferTransaction().
		AddApprovedHbarTransfer(aliceID, hedera.NewHbar(1).Negated(), true).
		AddHbarTransfer(charlieID, hedera.NewHbar(1)).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetTransactionID(hedera.TransactionIDGenerate(bobID)).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing transfer transaction", err))
	}

	transferFreeze.Sign(bobKey)

	transactionResponse, err = transferFreeze.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing transfer transaction", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transfer transaction receipt", err))
	}

	println("Transfer succeeded. Bob should now have 1 Hbar left in his allowance.")
	err = printBalance(client, aliceID, bobID, charlieID, []hedera.AccountID{transactionResponse.NodeID})
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving balances", err))
	}

	println("Attempting to transfer 2 Hbar from Alice to Charlie using Bob's allowance.")
	println("This should fail, because there is only 1 Hbar left in Bob's allowance.")

	transferFreeze, err = hedera.NewTransferTransaction().
		AddApprovedHbarTransfer(aliceID, hedera.NewHbar(2).Negated(), true).
		AddHbarTransfer(charlieID, hedera.NewHbar(2)).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetTransactionID(hedera.TransactionIDGenerate(bobID)).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing transfer transaction", err))
	}

	transferFreeze.Sign(bobKey)

	transactionResponse, err = transferFreeze.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing transfer transaction", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		println(err.Error(), ", Transfer failed as expected")
	}

	println("Adjusting Bob's allowance, increasing it by 2 Hbar. After this, Bob's allowance should be 3 Hbar.")

	allowanceAdjust, err := hedera.NewAccountAllowanceApproveTransaction().
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		ApproveHbarAllowance(aliceID, bobID, hedera.NewHbar(2)).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account allowance adjust transaction", err))
	}

	allowanceAdjust.Sign(aliceKey)

	transactionResponse, err = allowanceAdjust.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account allowance adjust transaction", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account allowance adjust receipt", err))
	}

	err = printBalance(client, aliceID, bobID, charlieID, []hedera.AccountID{transactionResponse.NodeID})
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving balances", err))
	}

	println("Attempting to transfer 2 Hbar from Alice to Charlie using Bob's allowance again.")
	println("This time it should succeed.")

	transferFreeze, err = hedera.NewTransferTransaction().
		AddApprovedHbarTransfer(aliceID, hedera.NewHbar(2).Negated(), true).
		AddHbarTransfer(charlieID, hedera.NewHbar(2)).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetTransactionID(hedera.TransactionIDGenerate(bobID)).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing transfer transaction", err))
	}

	transferFreeze.Sign(bobKey)

	transactionResponse, err = transferFreeze.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing transfer transaction", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transfer transaction receipt", err))
	}

	println("Transfer succeeded.")
	err = printBalance(client, aliceID, bobID, charlieID, []hedera.AccountID{transactionResponse.NodeID})
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving balances", err))
	}

	println("Deleting Bob's allowance")

	approvalFreeze, err = hedera.NewAccountAllowanceApproveTransaction().
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		ApproveHbarAllowance(aliceID, bobID, hedera.ZeroHbar).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account allowance approve transaction", err))
	}

	approvalFreeze.Sign(aliceKey)

	transactionResponse, err = approvalFreeze.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account allowance approve transaction", err))
	}

	_, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting account allowance receipt", err))
	}

	println("If Bob tries to use his allowance it should fail.")

	transferFreeze, err = hedera.NewTransferTransaction().
		AddApprovedHbarTransfer(aliceID, hedera.NewHbar(1).Negated(), true).
		AddHbarTransfer(charlieID, hedera.NewHbar(1)).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetTransactionID(hedera.TransactionIDGenerate(bobID)).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing transfer transaction", err))
	}

	transferFreeze.Sign(bobKey)

	transactionResponse, err = transferFreeze.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing transfer transaction", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		println(err.Error(), ": Error just like expected")
	}

	println("\nCleaning up")

	accountDelete, err := hedera.NewAccountDeleteTransaction().
		SetAccountID(aliceID).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetTransferAccountID(client.GetOperatorAccountID()).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing alice's account deletion", err))
	}

	accountDelete.Sign(aliceKey)

	transactionResponse, err = accountDelete.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing alice's account deletion", err))
	}

	_, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving alice's account deletion receipt", err))
	}

	accountDelete, err = hedera.NewAccountDeleteTransaction().
		SetAccountID(bobID).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetTransferAccountID(client.GetOperatorAccountID()).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing bob's account deletion", err))
	}

	accountDelete.Sign(bobKey)

	transactionResponse, err = accountDelete.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing bob's account deletion", err))
	}

	_, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving bob's account deletion receipt", err))
	}

	accountDelete, err = hedera.NewAccountDeleteTransaction().
		SetAccountID(charlieID).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetTransferAccountID(client.GetOperatorAccountID()).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing charlie's account deletion", err))
	}

	accountDelete.Sign(charlieKey)

	transactionResponse, err = accountDelete.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing charlie's account deletion", err))
	}

	_, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving charlie's account deletion receipt", err))
	}

	err = client.Close()
	if err != nil {
		panic(fmt.Sprintf("%v : error closing client", err))
	}
}

func printBalance(client *hedera.Client, alice hedera.AccountID, bob hedera.AccountID, charlie hedera.AccountID, nodeID []hedera.AccountID) error {
	println()

	balance, err := hedera.NewAccountBalanceQuery().
		SetAccountID(alice).
		SetNodeAccountIDs(nodeID).
		Execute(client)
	if err != nil {
		return err
	}
	println("Alice's balance:", balance.Hbars.String())

	balance, err = hedera.NewAccountBalanceQuery().
		SetAccountID(bob).
		SetNodeAccountIDs(nodeID).
		Execute(client)
	if err != nil {
		return err
	}
	println("Bob's balance:", balance.Hbars.String())

	balance, err = hedera.NewAccountBalanceQuery().
		SetAccountID(charlie).
		SetNodeAccountIDs(nodeID).
		Execute(client)
	if err != nil {
		return err
	}
	println("Charlie's balance:", balance.Hbars.String())

	println()
	return nil
}
// Filename: examples/account_create_token_transfer/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	} 

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// ## Example
	// Create a ECDSA private key
	// Extract the ECDSA public key public key
	// Extract the Ethereum public address
	// Transfer tokens using the `TransferTransaction` to the Etherum Account Address
	// The From field should be a complete account that has a public address
	// The To field should be to a public address (to create a new account)
	// Get the child receipt or child record to return the Hedera Account ID for the new account that was created
	// Get the `AccountInfo` on the new account and show it is a hollow account by not having a public key
	// This is a hollow account in this state
	// Use the hollow account as a transaction fee payer in a HAPI transaction
	// Sign the transaction with ECDSA private key
	// Get the `AccountInfo` of the account and show the account is now a complete account by returning the public key on the account

	// Create a ECDSA private key
	privateKey, err := hedera.PrivateKeyGenerateEcdsa()
	if err != nil {
		panic(err)
	}
	// Extract the ECDSA public key public key
	publicKey := privateKey.PublicKey()
	// Extract the Ethereum public address
	evmAddress := publicKey.ToEvmAddress()

	// Create an AccountID struct with EVM address
	evmAddressAccount, err := hedera.AccountIDFromEvmPublicAddress(evmAddress)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating account from EVM address", err))
	}
	// Transfer tokens using the `TransferTransaction` to the Etherum Account Address
	tx, err := hedera.NewTransferTransaction().AddHbarTransfer(evmAddressAccount, hedera.NewHbar(4)).
		AddHbarTransfer(operatorAccountID, hedera.NewHbar(-4)).Execute(client)
	if err != nil {
		panic(err)
	}

	// Get the child receipt or child record to return the Hedera Account ID for the new account that was created
	receipt, err := tx.GetReceiptQuery().SetIncludeChildren(true).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error with receipt: ", err))
	}
	newAccountId := *receipt.Children[0].AccountID

	// Get the `AccountInfo` on the new account and show it is a hollow account by not having a public key
	info, err := hedera.NewAccountInfoQuery().SetAccountID(newAccountId).Execute(client)
	if err != nil {
		panic(err)
	}
	// Verify account is created with the public address provided
	fmt.Println(info.ContractAccountID == publicKey.ToEvmAddress())
	// Verify the account Id is the same from the create account transaction
	fmt.Println(info.AccountID.String() == newAccountId.String())
	// Verify the account does not have a Hedera public key /hollow account/
	fmt.Println(info.Key.String() == "{[]}")

	// Use the hollow account as a transaction fee payer in a HAPI transaction
	// Sign the transaction with ECDSA private key
	client.SetOperator(newAccountId, privateKey)
	tx, err = hedera.NewTransferTransaction().AddHbarTransfer(operatorAccountID, hedera.NewHbar(1)).
		AddHbarTransfer(newAccountId, hedera.NewHbar(-1)).Execute(client)
	if err != nil {
		panic(err)
	}
	receipt, err = tx.GetReceiptQuery().Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error with receipt: ", err))
	}

	// Get the `AccountInfo` of the account and show the account is now a complete account by returning the public key on the account
	info, err = hedera.NewAccountInfoQuery().SetAccountID(newAccountId).Execute(client)
	if err != nil {
		panic(err)
	}
	// Verify account is created with the public address provided
	fmt.Println(info.ContractAccountID == publicKey.ToEvmAddress())
	// Verify the account Id is the same from the create account transaction
	fmt.Println(info.AccountID.String() == newAccountId.String())
	// Verify the account does have a Hedera public key /complete Hedera account/
	fmt.Println(info.Key.String() == publicKey.String())

}
// Filename: examples/account_create_with_hts/main.go
package main

import (
	"fmt"
	"github.com/hashgraph/hedera-sdk-go/v2"
	"os"
)

func main() {

	client, err := hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	operatorId, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromStringEd25519(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorId, operatorKey)

	supplyKey, err := hedera.PrivateKeyGenerateEcdsa()
	if err != nil {
		panic(fmt.Sprintf("%v : error creating supply key", err))
	}
	freezeKey, err := hedera.PrivateKeyGenerateEcdsa()
	if err != nil {
		panic(fmt.Sprintf("%v : error creating freeze key", err))
	}
	wipeKey, err := hedera.PrivateKeyGenerateEcdsa()
	if err != nil {
		panic(fmt.Sprintf("%v : error creating wipe key", err))
	}
	/**
	 *     Example 1
	 *
	 * Step 1
	 *
	 * Create an NFT using the Hedera Token Service
	 */
	fmt.Println("Example 1")
	// IPFS content identifiers for the NFT metadata
	cid := []string{"QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
		"QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
		"QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
		"Qmd3kGgSrAwwSrhesYcY7K54f3qD7MDo38r7Po2dChtQx5",
		"QmWgkKz3ozgqtnvbCLeh7EaR1H8u5Sshx3ZJzxkcrT3jbw"}
	// Creating the transaction for token creation
	nftCreateTransaction, err := hedera.NewTokenCreateTransaction().
		SetTokenName("HIP-542 Example Collection").SetTokenSymbol("HIP-542").
		SetTokenType(hedera.TokenTypeNonFungibleUnique).SetDecimals(0).
		SetInitialSupply(0).SetMaxSupply(int64(len(cid))).
		SetTreasuryAccountID(operatorId).SetSupplyType(hedera.TokenSupplyTypeFinite).
		SetAdminKey(operatorKey).SetFreezeKey(freezeKey).SetWipeKey(wipeKey).SetSupplyKey(supplyKey).FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token transaction", err))
	}
	// Sign the transaction with the operator key
	nftSignTransaction := nftCreateTransaction.Sign(operatorKey)
	// Submit the transaction to the Hedera network
	nftCreateSubmit, err := nftSignTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error submitting transaction", err))
	}
	// Get transaction receipt information
	nftCreateReceipt, err := nftCreateSubmit.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error receiving receipt", err))
	}
	// Get token id from the transaction
	nftTokenID := *nftCreateReceipt.TokenID
	fmt.Println("Created NFT with token id: ", nftTokenID)

	/**
	 * Step 2
	 *
	 * Mint the NFT
	 */

	nftCollection := []hedera.TransactionReceipt{}

	for i, s := range cid {
		mintTransaction, err := hedera.NewTokenMintTransaction().SetTokenID(nftTokenID).SetMetadata([]byte(s)).FreezeWith(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error creating mint transaction", err))
		}
		mintTransactionSubmit, err := mintTransaction.Sign(supplyKey).Execute(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error submitting transaction", err))
		}
		receipt, err := mintTransactionSubmit.GetReceipt(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error receiving receipt", err))
		}
		nftCollection = append(nftCollection, receipt)
		fmt.Println("Created NFT ", nftTokenID.String(), " with serial: ", nftCollection[i].SerialNumbers[0])
	}
	exampleNftId := nftTokenID.Nft(nftCollection[0].SerialNumbers[0])
	/**
	 * Step 3
	 *
	 * Create an ECDSA public key alias
	 */

	fmt.Println("Creating new account...")
	privateKey, err := hedera.PrivateKeyGenerateEcdsa()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating private key", err))
	}
	publicKey := privateKey.PublicKey()
	// Assuming that the target shard and realm are known.
	// For now they are virtually always 0 and 0.
	aliasAccountId := publicKey.ToAccountID(0, 0)
	fmt.Println("New account ID: ", aliasAccountId)
	fmt.Println("Just the aliasKey: ", aliasAccountId.AliasKey)

	/**
	 * Step 4
	 *
	 * Tranfer the NFT to the public key alias using the transfer transaction
	 */
	nftTransferTransaction, err := hedera.NewTransferTransaction().AddNftTransfer(exampleNftId, operatorId, *aliasAccountId).FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating transaction", err))
	}
	// Sign the transaction with the operator key
	nftTransferTransactionSign := nftTransferTransaction.Sign(operatorKey)
	// Submit the transaction to the Hedera network
	nftTransferTransactionSubmit, err := nftTransferTransactionSign.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error submitting transaction", err))
	}
	// Get transaction receipt information here
	fmt.Println(nftTransferTransactionSubmit.GetReceipt(client))

	/**
	 * Step 5
	 *
	 * Return the new account ID in the child record
	 */

	//Returns the info for the specified NFT id
	nftInfo, err := hedera.NewTokenNftInfoQuery().SetNftID(exampleNftId).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error info query transaction", err))
	}
	nftOwnerAccountId := nftInfo[0].AccountID
	fmt.Println("Current owner account id: ", nftOwnerAccountId)

	/**
	 * Step 6
	 *
	 * Show the new account ID owns the NFT
	 */
	accountInfo, err := hedera.NewAccountInfoQuery().SetAccountID(*aliasAccountId).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error account info query", err))
	}
	fmt.Println("The normal account ID of the given alias ", accountInfo.AccountID)

	if nftOwnerAccountId == accountInfo.AccountID {
		fmt.Println("The NFT owner accountId matches the accountId created with the HTS")
	} else {
		fmt.Println("The two account IDs does not match")
	}

	/**
	 *     Example 2
	 *
	 * Step 1
	 *
	 * Create a fungible HTS token using the Hedera Token Service
	 */
	fmt.Println("Example 2")

	tokenCreateTransaction, err := hedera.NewTokenCreateTransaction().SetTokenName("HIP-542 Token").
		SetTokenSymbol("H542").SetTokenType(hedera.TokenTypeFungibleCommon).SetTreasuryAccountID(operatorId).
		SetInitialSupply(10000).SetDecimals(2).SetAutoRenewAccount(operatorId).FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating transaction", err))
	}
	// Sign the transaction with the operator key
	tokenCreateTransactionSign := tokenCreateTransaction.Sign(operatorKey)
	// Submit the transaction to the Hedera network
	tokenCreateTransactionSubmit, err := tokenCreateTransactionSign.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error submitting transaction", err))
	}

	// Get transaction receipt information
	tokenCreateTransactionReceipt, err := tokenCreateTransactionSubmit.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving receipt", err))
	}
	tokenId := *tokenCreateTransactionReceipt.TokenID
	fmt.Println("Created token with token id: ", tokenId)

	/**
	 * Step 2
	 *
	 * Create an ECDSA public key alias
	 */
	privateKey2, err := hedera.PrivateKeyGenerateEcdsa()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating private key", err))
	}
	publicKey2 := privateKey2.PublicKey()
	// Assuming that the target shard and realm are known.
	// For now they are virtually always 0 and 0.
	aliasAccountId2 := *publicKey2.ToAccountID(0, 0)
	fmt.Println("New account ID: ", aliasAccountId2)
	fmt.Println("Just the aliasKey: ", aliasAccountId2.AliasKey)

	/**
	 * Step 3
	 *
	 * Transfer the fungible token to the public key alias
	 */

	tokenTransferTransaction, err := hedera.NewTransferTransaction().
		AddTokenTransfer(tokenId, operatorId, -10).AddTokenTransfer(tokenId, aliasAccountId2, 10).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating transaction", err))
	}
	// Sign the transaction with the operator key
	tokenTransferTransactionSign := tokenTransferTransaction.Sign(operatorKey)
	// Submit the transaction to the Hedera network
	tokenTransferTransactionSubmit, err := tokenTransferTransactionSign.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error submitting transaction", err))
	}
	// Get transaction receipt information
	fmt.Println(tokenTransferTransactionSubmit.GetReceipt(client))

	/**
	 * Step 4
	 *
	 * Return the new account ID in the child record
	 */

	accountId2Info, err := hedera.NewAccountInfoQuery().SetAccountID(aliasAccountId2).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing acount info query", err))
	}
	accountId2 := accountId2Info.AccountID
	fmt.Println("The normal account ID of the given alias: ", accountId2)

	/**
	 * Step 5
	 *
	 * Show the new account ID owns the fungible token
	 */

	accountBalances, err := hedera.NewAccountBalanceQuery().SetAccountID(aliasAccountId2).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error receiving account balance", err))
	}

	tokenBalanceAccountId2 := accountBalances.Tokens.Get(tokenId)
	if tokenBalanceAccountId2 == 10 {
		fmt.Println(`Account is created succesfully using HTS "TransferTransaction"`)
	} else {
		fmt.Println("Creating account with HTS using public key alias failed")
	}

}
// Filename: examples/alias_id_example/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Defaults the operator account ID and key such that all generated transactions will be paid for
	// by this account and be signed by this key
	client.SetOperator(operatorAccountID, operatorKey)

	/*
	 * Hedera supports a form of auto account creation.
	 *
	 * You can "create" an account by generating a private key, and then deriving the public key,
	 * without any need to interact with the Hedera network.  The public key more or less acts as the user's
	 * account ID.  This public key is an account's aliasKey: a public key that aliases (or will eventually alias)
	 * to a Hedera account.
	 *
	 * An AccountId takes one of two forms: a normal AccountId with a null aliasKey member takes the form 0.0.123,
	 * while an account ID with a non-null aliasKey member takes the form
	 * 0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777
	 * Note the prefix of "0.0." indicating the shard and realm.  Also note that the aliasKey is stringified
	 * as a hex-encoded ASN1 DER representation of the key.
	 *
	 * An AccountId with an aliasKey can be used just like a normal AccountId for the purposes of queries and
	 * transactions, however most queries and transactions involving such an AccountId won't work until Hbar has
	 * been transferred to the aliasKey account.
	 *
	 * There is no record in the Hedera network of an account associated with a given aliasKey
	 * until an amount of Hbar is transferred to the account.  The moment that Hbar is transferred to that aliasKey
	 * AccountId is the moment that that account actually begins to exist in the Hedera ledger.
	 */

	println("Creating a new account")

	key, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating private key", err))
	}
	publicKey := key.PublicKey()

	// Assuming that the target shard and realm are known.
	// For now they are virtually always 0 and 0.
	aliasAccountID := publicKey.ToAccountID(0, 0)

	println("New account ID:", aliasAccountID.String())
	println("Just the key:", aliasAccountID.AliasKey.String())

	/*
	*
	* Note that no queries or transactions have taken place yet.
	* This account "creation" process is entirely local.
	*
	* AccountId.fromString() can construct an AccountId with an aliasKey.
	* It expects a string of the form 0.0.123 in the case of a normal AccountId, or of the form
	* 0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777
	* in the case of an AccountId with aliasKey.  Note the prefix of "0.0." to indicate the shard and realm.
	*
	* If the shard and realm are known, you may use PublicKeyFromString() then PublicKey.toAccountId() to construct the
	* aliasKey AccountID
	* fromStr, err := hedera.AccountIDFromString("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777")
	* publicKey2, err := hedera.PublicKeyFromString("302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777")
	* fromKeyString := publicKey2.ToAccountID(0,0)
	 */

	println("Transferring some Hbar to the new account")
	resp, err := hedera.NewTransferTransaction().
		AddHbarTransfer(client.GetOperatorAccountID(), hedera.NewHbar(1).Negated()).
		AddHbarTransfer(*aliasAccountID, hedera.NewHbar(1)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing transfer transaction", err))
	}

	receipt, err := resp.GetReceipt(client)
	println(receipt.Status.String())
	if receipt.AccountID != nil {
		println(receipt.AccountID.String())
	}
	if err != nil {
		panic(fmt.Sprintf("%v : error getting transfer transaction receipt", err))
	}

	balance, err := hedera.NewAccountBalanceQuery().
		SetAccountID(*aliasAccountID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving balance", err))
	}

	println("Balance of the new account:", balance.Hbars.String())

	info, err := hedera.NewAccountInfoQuery().
		SetAccountID(*aliasAccountID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account info", err))
	}

	/*
	 * Note that once an account exists in the ledger, it is assigned a normal AccountId, which can be retrieved
	 * via an AccountInfoQuery.
	 *
	 * Users may continue to refer to the account by its aliasKey AccountId, but they may also
	 * now refer to it by its normal AccountId
	 */

	println("New account info:")
	println("The normal account ID:", info.AccountID.String())
	println("The alias key:", info.AliasKey.String())
	println("Example complete")
	err = client.Close()
	if err != nil {
		panic(fmt.Sprintf("%v : error closing client", err))
	}
}
// Filename: examples/consensus_pub_sub/main.go
package main

import (
	"fmt"
	"os"
	"time"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

const content = `Programming is the process of creating a set of instructions that tell a computer how to perform a task. Programming can be done using a variety of computer programming languages, such as JavaScript, Python, and C++`

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Defaults the operator account ID and key such that all generated transactions will be paid for
	// by this account and be signed by this key
	client.SetOperator(operatorAccountID, operatorKey)

	// Make a new topic
	transactionResponse, err := hedera.NewTopicCreateTransaction().
		SetTransactionMemo("go sdk example create_pub_sub/main.go").
		SetAdminKey(client.GetOperatorPublicKey()).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating topic", err))
	}

	// Get the receipt
	transactionReceipt, err := transactionResponse.GetReceipt(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error getting topic create receipt", err))
	}

	// get the topic id from receipt
	topicID := *transactionReceipt.TopicID

	fmt.Printf("topicID: %v\n", topicID)

	time.Sleep(3 * time.Second)

	start := time.Now()

	// Setup a mirror client to print out messages as we receive them
	_, err = hedera.NewTopicMessageQuery().
		// For which topic ID
		SetTopicID(topicID).
		// When to start
		SetStartTime(time.Unix(0, 0)).
		Subscribe(client, func(message hedera.TopicMessage) {
			print("Received message ", message.SequenceNumber, "\r")
		})

	if err != nil {
		panic(fmt.Sprintf("%v : error subscribing to the topic", err))
	}

	// Loop submit transaction with "content" as message, wait a bit to make sure it propagates
	for {
		_, err = hedera.NewTopicMessageSubmitTransaction().
			// The message we are submitting
			SetMessage([]byte(content)).
			// To which topic ID
			SetTopicID(topicID).
			Execute(client)

		if err != nil {
			panic(fmt.Sprintf("%v : error submitting topic", err))
		}

		// Setting up how long the loop wil run
		if uint64(time.Since(start).Seconds()) > 16 {
			break
		}

		// Sleep to make sure everything propagates
		time.Sleep(5 * time.Second)
	}

	// Clean up by deleting the topic, etc
	transactionResponse, err = hedera.NewTopicDeleteTransaction().
		// Which topic ID
		SetTopicID(topicID).
		// Making sure it works right away, without propagation, by setting the same node as topic create
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// Setting the max fee just in case
		SetMaxTransactionFee(hedera.NewHbar(5)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error deleting topic", err))
	}

	// Get the receipt to make sure everything went through
	_, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt for topic deletion", err))
	}
}
// Filename: examples/consensus_pub_sub_chunked/main.go
package main

import (
	"fmt"
	"os"
	"time"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Defaults the operator account ID and key such that all generated transactions will be paid for
	// by this account and be signed by this key
	client.SetOperator(operatorAccountID, operatorKey)

	// Make a new topic ID to use
	transactionResponse, err := hedera.NewTopicCreateTransaction().
		// Memo is not required
		SetTransactionMemo("go sdk example create_pub_sub_chunked/main.go").
		// Access control for TopicSubmitMessage.
		// If unspecified, no access control is performed, all submissions are allowed.
		// Access control for UpdateTopicTransaction/DeleteTopicTransaction.
		// Anyone can increase the topic's expirationTime via UpdateTopicTransaction, regardless of the adminKey.
		// If no adminKey is specified, UpdateTopicTransaction may only be used to extend the topic's expirationTime,
		// and DeleteTopicTransaction is disallowed.
		SetAdminKey(client.GetOperatorPublicKey()).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating topic", err))
	}

	// Get the receipt that will contain topic ID
	transactionReceipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving topic creation receipt", err))
	}

	// Get the new topic ID
	topicID := *transactionReceipt.TopicID

	fmt.Printf("for topic %v\n", topicID)

	fmt.Printf("wait to propagate...\n")
	time.Sleep(10 * time.Second)

	wait := true
	start := time.Now()

	// Setup a mirror client to print out messages as we receive them
	_, err = hedera.NewTopicMessageQuery().
		// For which topic ID
		SetTopicID(topicID).
		SetStartTime(time.Unix(0, 0)).
		SetCompletionHandler(func() {
			wait = false
		}).
		Subscribe(client, func(message hedera.TopicMessage) {
			if string(message.Contents) == bigContents {
				wait = false
			}
			// Print the timestamp and the message that was received
			println(message.ConsensusTimestamp.String(), " received topic message:", string(message.Contents))
		})

	if err != nil {
		panic(fmt.Sprintf("%v : error subscribing", err))
	}

	// Prepare a message send transaction that requires a submit key from "somewhere else"
	_, err = hedera.NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// The message we are sending
		SetMessage([]byte(bigContents)).
		// How many chunks will the message be
		// 10 is default
		SetMaxChunks(15).
		SetTopicID(topicID).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error signing with operator", err))
	}

	// Get the receipt to ensure there were no errors
	receipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving topic submit transaction receipt", err))
	}

	println("TransactionID to check if successfully sent:", transactionResponse.TransactionID.String())
	println("status:", receipt.Status.String())

	// Wait for the message
	for {
		if !wait || uint64(time.Since(start).Seconds()) > 60 {
			break
		}

		time.Sleep(1 * time.Second)
	}

	// Clean up, deleting the topic ID
	transactionResponse, err = hedera.NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetMaxTransactionFee(hedera.NewHbar(5)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error deleting topic", err))
	}

	_, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving topic delete transaction receipt", err))
	}

	if wait {
		panic("Message was not received within 60 seconds")
	}
}

// 14k+ stuff to upload
const bigContents = `
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.

Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.

Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.

Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.

Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.

Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.

Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.

Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.

Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.

In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.

Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.

Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.

Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.

Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.

Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.

Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.

Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.

Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.

Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.

Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.

Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.

In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.
`
// Filename: examples/consensus_pub_sub_with_submit_key/main.go
package main

import (
	"fmt"
	"math/rand"
	"os"
	"strconv"
	"time"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	//generate new submit key
	submitKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	println("acc", client.GetOperatorAccountID().String())

	// Create new topic ID
	transactionResponse, err := hedera.NewTopicCreateTransaction().
		// You don't need any of this to create a topic
		// If key is not set all submissions are allowed
		SetTransactionMemo("HCS topic with submit key").
		// Access control for TopicSubmitMessage.
		// If unspecified, no access control is performed, all submissions are allowed.
		SetSubmitKey(submitKey.PublicKey()).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating topic", err))
	}

	// Get receipt
	transactionReceipt, err := transactionResponse.GetReceipt(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving topic create transaction receipt", err))
	}

	// Get topic ID from receipt
	topicID := *transactionReceipt.TopicID

	println("Created new topic", topicID.String(), "with ED25519 submitKey of", submitKey.String())

	time.Sleep(5 * time.Second)

	// Setup a mirror client to print out messages as we receive them
	_, err = hedera.NewTopicMessageQuery().
		// Sets for which topic
		SetTopicID(topicID).
		// Set when the query starts
		SetStartTime(time.Unix(0, 0)).
		// What to do when messages are received
		Subscribe(client, func(message hedera.TopicMessage) {
			// Print out the timestamp and the message
			println(message.ConsensusTimestamp.String(), " received topic message:", string(message.Contents))
		})
	if err != nil {
		panic(fmt.Sprintf("%v : error subscribing", err))
	}

	for i := 0; i < 3; i++ {
		message := "random message " + strconv.Itoa(rand.Int())

		println("Publishing message:", message)

		// Prepare a message send transaction that requires a submit key from "somewhere else"
		submitTx, err := hedera.NewTopicMessageSubmitTransaction().
			// Sets the topic ID we want to send to
			SetTopicID(topicID).
			// Sets the message
			SetMessage([]byte(message)).
			FreezeWith(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error freezing topic message submit transaction", err))
		}

		// Sign with that submit key we gave the topic
		submitTx.Sign(submitKey)

		// Now actually submit the transaction
		submitTxResponse, err := submitTx.Execute(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error executing topic message submit transaction", err))
		}

		// Get the receipt to ensure there were no errors
		_, err = submitTxResponse.GetReceipt(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error retrieving topic message submit transaction receipt", err))
		}

		// Wait a bit for it to propagate
		time.Sleep(2 * time.Second)
	}
}
// Filename: examples/construct_client/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	// Create client for previewnet
	previewnetClient := hedera.ClientForPreviewnet()
	// Create client for testnet
	testnetClient := hedera.ClientForTestnet()
	// Create client for mainnet
	mainnetClient := hedera.ClientForMainnet()

	println("Client Construction Example.")

	// Creating client from the set HEDERA_NETWORK environment variable
	namedNetworkClient, err := hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client for name", err))
	}

	// Creating account ID of 0.0.3
	id, err := hedera.AccountIDFromString("0.0.3")
	if err != nil {
		panic(fmt.Sprintf("%v : error creating AccountID from string", err))
	}

	// Creating a PrivateKey from a random key string we have
	key, err := hedera.PrivateKeyFromString("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10")
	if err != nil {
		panic(fmt.Sprintf("%v : error creating PrivateKey from string", err))
	}

	// Set the operators for each client
	testnetClient.SetOperator(id, key)
	mainnetClient.SetOperator(id, key)
	previewnetClient.SetOperator(id, key)
	namedNetworkClient.SetOperator(id, key)

	// Create the network map to use
	customNetwork := map[string]hedera.AccountID{
		"2.testnet.hedera.com:50211": {Account: 5},
		"3.testnet.hedera.com:50211": {Account: 6},
	}

	// Set network for customClient which uses the above custom network
	customClient := hedera.ClientForNetwork(customNetwork)
	// Setting NetworkName for the CustomClient, is only needed if you need to validate ID checksums
	customClient.SetNetworkName(hedera.NetworkNameTestnet)

	if os.Getenv("CONFIG_FILE") != "" {
		// Creating client from a file specified in environment variable CONFIG_FILE
		configClient, err := hedera.ClientFromConfigFile(os.Getenv("CONFIG_FILE"))
		if err != nil {
			panic(fmt.Sprintf("%v : error creating Client from config file", err))
		}

		// Closing the client from file
		err = configClient.Close()
		if err != nil {
			panic(fmt.Sprintf("%v : error closing configClient", err))
		}
	}

	// Clean up, closing each client
	// Can also do this by using defer in after setting up the client
	err = previewnetClient.Close()
	if err != nil {
		panic(fmt.Sprintf("%v : error closing previewnetClient", err))
	}
	err = testnetClient.Close()
	if err != nil {
		panic(fmt.Sprintf("%v : error closing testnetClient", err))
	}
	err = mainnetClient.Close()
	if err != nil {
		panic(fmt.Sprintf("%v : error closing mainnetClient", err))
	}
	err = namedNetworkClient.Close()
	if err != nil {
		panic(fmt.Sprintf("%v : error closing namedNetworkClient", err))
	}
	err = customClient.Close()
	if err != nil {
		panic(fmt.Sprintf("%v : error closing customClient", err))
	}

	println("Success!")
}
// Filename: examples/contract_helper/contract_helper.go
package contract_helper

import (
	"encoding/hex"
	"fmt"
	"strconv"

	"github.com/hashgraph/hedera-sdk-go/v2"
	"github.com/pkg/errors"
)

type ContractHelper struct {
	ContractID             hedera.ContractID
	stepResultValidators   map[int32]func(hedera.ContractFunctionResult) bool
	stepParameterSuppliers map[int32]func() *hedera.ContractFunctionParameters
	stepPayableAmounts     map[int32]*hedera.Hbar
	stepSigners            map[int32][]hedera.PrivateKey
	stepFeePayers          map[int32]*hedera.AccountID
	stepLogic              map[int32]func(address string)
}

func NewContractHelper(bytecode []byte, constructorParameters hedera.ContractFunctionParameters, client *hedera.Client) *ContractHelper {
	response, err := hedera.NewContractCreateFlow().
		SetBytecode(bytecode).
		SetGas(8000000).
		SetMaxChunks(30).
		SetConstructorParameters(&constructorParameters).
		Execute(client)
	if err != nil {
		panic(err)
	}

	receipt, err := response.GetReceipt(client)
	if err != nil {
		panic(err)
	}
	if receipt.ContractID != nil {
		return &ContractHelper{
			ContractID:             *receipt.ContractID,
			stepResultValidators:   make(map[int32]func(hedera.ContractFunctionResult) bool),
			stepParameterSuppliers: make(map[int32]func() *hedera.ContractFunctionParameters),
			stepPayableAmounts:     make(map[int32]*hedera.Hbar),
			stepSigners:            make(map[int32][]hedera.PrivateKey),
			stepFeePayers:          make(map[int32]*hedera.AccountID),
			stepLogic:              make(map[int32]func(address string)),
		}
	}

	return &ContractHelper{}
}

func (this *ContractHelper) SetResultValidatorForStep(stepIndex int32, validator func(hedera.ContractFunctionResult) bool) *ContractHelper {
	this.stepResultValidators[stepIndex] = validator
	return this
}

func (this *ContractHelper) SetParameterSupplierForStep(stepIndex int32, supplier func() *hedera.ContractFunctionParameters) *ContractHelper {
	this.stepParameterSuppliers[stepIndex] = supplier
	return this
}

func (this *ContractHelper) SetPayableAmountForStep(stepIndex int32, amount hedera.Hbar) *ContractHelper {
	this.stepPayableAmounts[stepIndex] = &amount
	return this
}

func (this *ContractHelper) AddSignerForStep(stepIndex int32, signer hedera.PrivateKey) *ContractHelper {
	if _, ok := this.stepSigners[stepIndex]; ok {
		this.stepSigners[stepIndex] = append(this.stepSigners[stepIndex], signer)
	} else {
		this.stepSigners[stepIndex] = make([]hedera.PrivateKey, 0)
		this.stepSigners[stepIndex] = append(this.stepSigners[stepIndex], signer)
	}

	return this
}

func (this *ContractHelper) SetFeePayerForStep(stepIndex int32, account hedera.AccountID, accountKey hedera.PrivateKey) *ContractHelper {
	this.stepFeePayers[stepIndex] = &account
	return this.AddSignerForStep(stepIndex, accountKey)
}

func (this *ContractHelper) SetStepLogic(stepIndex int32, specialFunction func(address string)) *ContractHelper {
	this.stepLogic[stepIndex] = specialFunction
	return this
}

func (this *ContractHelper) GetResultValidator(stepIndex int32) func(hedera.ContractFunctionResult) bool {
	if _, ok := this.stepResultValidators[stepIndex]; ok {
		return this.stepResultValidators[stepIndex]
	}

	return func(result hedera.ContractFunctionResult) bool {
		responseStatus := hedera.Status(result.GetInt32(0))
		isValid := responseStatus == hedera.StatusSuccess
		if !isValid {
			println("Encountered invalid response status", responseStatus.String())
		}
		return isValid
	}
}

func (this *ContractHelper) GetParameterSupplier(stepIndex int32) func() *hedera.ContractFunctionParameters {
	if _, ok := this.stepParameterSuppliers[stepIndex]; ok {
		return this.stepParameterSuppliers[stepIndex]
	}

	return func() *hedera.ContractFunctionParameters {
		return nil
	}
}

func (this *ContractHelper) GetPayableAmount(stepIndex int32) *hedera.Hbar {
	return this.stepPayableAmounts[stepIndex]
}

func (this *ContractHelper) GetSigners(stepIndex int32) []hedera.PrivateKey {
	if _, ok := this.stepSigners[stepIndex]; ok {
		return this.stepSigners[stepIndex]
	}

	return []hedera.PrivateKey{}
}

func (this *ContractHelper) ExecuteSteps(firstStep int32, lastStep int32, client *hedera.Client) (*ContractHelper, error) {
	for stepIndex := firstStep; stepIndex <= lastStep; stepIndex++ {
		println("Attempting to execuite step", stepIndex)

		transaction := hedera.NewContractExecuteTransaction().
			SetContractID(this.ContractID).
			SetGas(10000000)

		payableAmount := this.GetPayableAmount(stepIndex)
		if payableAmount != nil {
			transaction.SetPayableAmount(*payableAmount)
		}

		functionName := "step" + strconv.Itoa(int(stepIndex))
		parameters := this.GetParameterSupplier(stepIndex)()
		if parameters != nil {
			transaction.SetFunction(functionName, parameters)
		} else {
			transaction.SetFunction(functionName, nil)
		}

		if feePayerAccountID, ok := this.stepFeePayers[stepIndex]; ok {
			transaction.SetTransactionID(hedera.TransactionIDGenerate(*feePayerAccountID))
		}

		frozen, err := transaction.FreezeWith(client)
		if err != nil {
			return &ContractHelper{}, err
		}
		for _, signer := range this.GetSigners(stepIndex) {
			frozen.Sign(signer)
		}

		response, err := frozen.Execute(client)
		if err != nil {
			return &ContractHelper{}, err
		}

		record, err := response.GetRecord(client)
		if err != nil {
			return &ContractHelper{}, err
		}

		functionResult, err := record.GetContractExecuteResult()
		if err != nil {
			return &ContractHelper{}, err
		}

		if this.stepLogic[stepIndex] != nil {
			address := functionResult.GetAddress(1)
			if function, exists := this.stepLogic[stepIndex]; exists && function != nil {
				function(hex.EncodeToString(address))
			}
		}

		if this.GetResultValidator(stepIndex)(functionResult) {
			fmt.Printf("Step %d completed, and returned valid result. (TransactionId %s)", stepIndex, record.TransactionID.String())
		} else {
			return &ContractHelper{}, errors.New(fmt.Sprintf("Step %d returned invalid result", stepIndex))
		}
	}

	return this, nil
}
// Filename: examples/create_account/main.go
package main

import (
	"fmt"
	"github.com/hashgraph/hedera-sdk-go/v2"
	"os"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generate new key to use with new account
	newKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey}", err))
	}

	fmt.Printf("private = %v\n", newKey)
	fmt.Printf("public = %v\n", newKey.PublicKey())

	// Create account
	// The only required property here is `key`
	transactionResponse, err := hedera.NewAccountCreateTransaction().
		// The key that must sign each transfer out of the account.
		SetKey(newKey.PublicKey()).
		// If true, this account's key must sign any transaction depositing into this account (in
		// addition to all withdrawals)
		SetReceiverSignatureRequired(false).
		// The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
		// and up to a maximum value of 1000.
		SetMaxAutomaticTokenAssociations(1).
		// The memo associated with the account
		SetTransactionMemo("go sdk example create_account/main.go").
		// The account is charged to extend its expiration date every this many seconds. If it doesn't
		// have enough balance, it extends as long as possible. If it is empty when it expires, then it
		// is deleted.
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account create transaction}", err))
	}

	// Get receipt to see if transaction succeeded, and has the account ID
	transactionReceipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt}", err))
	}

	// Get account ID out of receipt
	newAccountID := *transactionReceipt.AccountID

	fmt.Printf("account = %v\n", newAccountID)
}
// Filename: examples/create_account_with_alias/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// ## Example
	// Create a ECDSA private key
	// Extract the ECDSA public key public key
	// Extract the Ethereum public address
	// Use the `AccountCreateTransaction` and populate `setAlias(evmAddress)` field with the Ethereum public address
	// Sign the `AccountCreateTransaction` transaction with the new private key
	// Get the `AccountInfo` on the new account and show that the account has contractAccountId

	// Create a ECDSA private key
	privateKey, err := hedera.PrivateKeyGenerateEcdsa()
	if err != nil {
		println(err.Error())
	}
	// Extract the ECDSA public key public key
	publicKey := privateKey.PublicKey()
	// Extract the Ethereum public address
	evmAddress := publicKey.ToEvmAddress()

	// Use the `AccountCreateTransaction` and set the EVM address field to the Ethereum public address
	frozenTxn, err := hedera.NewAccountCreateTransaction().SetInitialBalance(hedera.HbarFromTinybar(100)).
		SetKey(operatorKey).SetAlias(evmAddress).FreezeWith(client)
	if err != nil {
		println(err.Error())
	}
	response, err := frozenTxn.Sign(privateKey).Execute(client)
	if err != nil {
		println(err.Error())
	}

	transactionReceipt, err := response.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt}", err))
	}

	newAccountId := *transactionReceipt.AccountID

	// Get the `AccountInfo` on the new account and show that the account has contractAccountId
	info, err := hedera.NewAccountInfoQuery().SetAccountID(newAccountId).Execute(client)
	if err != nil {
		println(err.Error())
	}
	// Verify account is created with the provided EVM address
	fmt.Println(info.ContractAccountID == evmAddress)
	// Verify the account Id is the same from the create account transaction
	fmt.Println(info.AccountID.String() == newAccountId.String())
}
// Filename: examples/create_account_with_alias_and_receiver_signature_required/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// ## Example
	// Create an ED25519 admin private key and ECSDA private key
	// Extract the ECDSA public key public key
	// Extract the Ethereum public address
	// Use the `AccountCreateTransaction` and populate `setAlias(evmAddress)` field with the Ethereum public address and the `setReceiverSignatureRequired` to `true`
	// Sign the `AccountCreateTransaction` transaction with both the new private key and the admin key
	// Get the `AccountInfo` on the new account and show that the account has contractAccountId

	// Create an ED25519 admin private key and ECSDA private key
	adminKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(err.Error())
	}

	privateKey, err := hedera.PrivateKeyGenerateEcdsa()
	if err != nil {
		panic(err.Error())
	}
	// Extract the ECDSA public key public key
	publicKey := privateKey.PublicKey()
	// Extract the Ethereum public address
	evmAddress := publicKey.ToEvmAddress()

	// Use the `AccountCreateTransaction` and set the EVM address field to the Ethereum public address
	frozenTxn, err := hedera.NewAccountCreateTransaction().SetReceiverSignatureRequired(true).SetInitialBalance(hedera.HbarFromTinybar(100)).
		SetKey(adminKey).SetAlias(evmAddress).FreezeWith(client)
	if err != nil {
		panic(err.Error())
	}

	response, err := frozenTxn.Sign(adminKey).Sign(privateKey).Execute(client)
	if err != nil {
		panic(err.Error())
	}

	transactionReceipt, err := response.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt}", err))
	}

	newAccountId := *transactionReceipt.AccountID

	// Get the `AccountInfo` on the new account and show that the account has contractAccountId
	info, err := hedera.NewAccountInfoQuery().SetAccountID(newAccountId).Execute(client)
	if err != nil {
		panic(err.Error())
	}
	// Verify account is created with the provided EVM address
	fmt.Println(info.ContractAccountID == evmAddress)
	// Verify the account Id is the same from the create account transaction
	fmt.Println(info.AccountID.String() == newAccountId.String())
}
// Filename: examples/create_account_with_threshold_keys/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// make the key arrays
	keys := make([]hedera.PrivateKey, 3)
	pubKeys := make([]hedera.PublicKey, 3)

	fmt.Println("threshold key example")
	fmt.Println("Keys: ")

	// generate the keys and put them in their respective arrays
	for i := range keys {
		newKey, err := hedera.GeneratePrivateKey()
		if err != nil {
			panic(fmt.Sprintf("%v : error generating PrivateKey}", err))
		}

		fmt.Printf("Key %v:\n", i)
		fmt.Printf("private = %v\n", newKey)
		fmt.Printf("public = %v\n", newKey.PublicKey())

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	// A threshold key with a threshold of 2 and length of 3 requires
	// at least 2 of the 3 keys to sign anything modifying the account
	thresholdPublicKeys := hedera.KeyListWithThreshold(2).
		AddAllPublicKeys(pubKeys)

	println()
	fmt.Printf("threshold keys: %v\n", thresholdPublicKeys)
	println()

	// setup account create transaction with the public threshold keys, then freeze it for singing
	transaction, err := hedera.NewAccountCreateTransaction().
		// Only thing required to create account is the key
		SetKey(thresholdPublicKeys).
		// Setting the initial balance to be 6 Hbars
		SetInitialBalance(hedera.NewHbar(6)).
		// Presetting transaction ID, this is not required
		SetTransactionID(hedera.TransactionIDGenerate(client.GetOperatorAccountID())).
		SetTransactionMemo("sdk example create_account_with_threshold_keys/main.go").
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing create account transaction", err))
	}

	// Sign with all the private keys
	for i := range keys {
		transaction = transaction.Sign(keys[i])
	}

	// Finally, execute the transaction getting the response
	transactionResponse, err := transaction.Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating account", err))
	}

	// Get the receipt to see everything worked
	transactionReceipt, err := transactionResponse.GetReceipt(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account create receipt", err))
	}

	// Get the new account ID
	newAccountID := *transactionReceipt.AccountID

	fmt.Printf("account = %v\n", newAccountID)

	// Now we have to make sure everything worked with a transfer transaction using the new account ID
	transferTx, err := hedera.NewTransferTransaction().
		// Presetting transaction ID is not required
		SetTransactionID(hedera.TransactionIDGenerate(newAccountID)).
		// Setting node id is not required, but it guarantees the account will be available without waiting for propagation
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// Negate the Hbar if its being taken out of the account
		AddHbarTransfer(newAccountID, hedera.HbarFrom(-5, hedera.HbarUnits.Hbar)).
		AddHbarTransfer(client.GetOperatorAccountID(), hedera.HbarFrom(5, hedera.HbarUnits.Hbar)).
		FreezeWith(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error freezing transfer transaction", err))
	}

	// Manually sign with 2 of the private keys provided in the threshold
	transactionResponse, err = transferTx.
		Sign(keys[0]).
		Sign(keys[1]).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing create account transaction", err))
	}

	// Make sure the transaction executes properly
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transfer receipt", err))
	}

	fmt.Printf("status of transfer transaction: %v\n", transactionReceipt.Status)

	// This query is free
	// Here we check if transfer transaction actually succeeded
	balance, err := hedera.NewAccountBalanceQuery().
		// The account ID to check balance of
		SetAccountID(newAccountID).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account balance query", err))
	}

	fmt.Printf("account balance after transfer: %v\n", balance.Hbars.String())
}
// Filename: examples/create_file/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	transactionResponse, err := hedera.NewFileCreateTransaction().
		// A file is not implicitly owned by anyone, even the operator
		// But we do use operator's key for this one
		SetKeys(client.GetOperatorPublicKey()).
		// Initial contents of the file
		SetContents([]byte("Hello, World")).
		// Optional memo
		SetTransactionMemo("go sdk example create_file/main.go").
		// Set max transaction fee just in case we are required to pay more
		SetMaxTransactionFee(hedera.HbarFrom(8, hedera.HbarUnits.Hbar)).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating file", err))
	}

	// Make sure the transaction went through
	transactionReceipt, err := transactionResponse.GetReceipt(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving file create transaction receipt", err))
	}

	// Get and then display the file ID from the receipt
	fmt.Printf("file = %v\n", *transactionReceipt.FileID)
}
// Filename: examples/create_simple_contract/main.go
package main

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

// a simple contract struct
type contract struct {
	// ignore the link references since it is empty
	Object    string `json:"object"`
	OpCodes   string `json:"opcodes"`
	SourceMap string `json:"sourceMap"`
}

func main() {
	var client *hedera.Client
	var err error

	net := os.Getenv("HEDERA_NETWORK")
	client, err = hedera.ClientForName(net)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	configOperatorID := os.Getenv("OPERATOR_ID")
	configOperatorKey := os.Getenv("OPERATOR_KEY")

	if configOperatorID != "" && configOperatorKey != "" {
		operatorAccountID, err := hedera.AccountIDFromString(configOperatorID)
		if err != nil {
			panic(fmt.Sprintf("%v : error converting string to AccountID", err))
		}

		operatorKey, err := hedera.PrivateKeyFromString(configOperatorKey)
		if err != nil {
			panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
		}

		client.SetOperator(operatorAccountID, operatorKey)
	}

	defer func() {
		err = client.Close()
		if err != nil {
			panic(fmt.Sprintf("%v : error closing client", err))
		}
	}()

	// R contents from hello_world.json file
	rawContract, err := os.ReadFile("./hello_world.json")
	if err != nil {
		panic(fmt.Sprintf("%v : error reading hello_world.json", err))
	}

	// Initialize simple contract
	contract := contract{}

	// Unmarshal the json read from the file into the simple contract
	err = json.Unmarshal([]byte(rawContract), &contract)
	if err != nil {
		panic(fmt.Sprintf("%v : error unmarshaling the json file", err))
	}

	// Convert contract to bytes
	contractByteCode := []byte(contract.Object)

	fmt.Println("Simple contract example")
	fmt.Printf("Contract bytecode size: %v bytes\n", len(contractByteCode))

	// Upload a file containing the byte code
	byteCodeTransactionID, err := hedera.NewFileCreateTransaction().
		SetMaxTransactionFee(hedera.NewHbar(2)).
		// All keys at the top level of a key list must sign to create or modify the file
		SetKeys(client.GetOperatorPublicKey()).
		// Initial contents, in our case it's the contract object converted to bytes
		SetContents(contractByteCode).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating file", err))
	}

	// Get the record
	byteCodeTransactionRecord, err := byteCodeTransactionID.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting file creation record", err))
	}

	fmt.Printf("contract bytecode file upload fee: %v\n", byteCodeTransactionRecord.TransactionFee)

	// Get the file ID from the record we got
	byteCodeFileID := *byteCodeTransactionRecord.Receipt.FileID

	fmt.Printf("contract bytecode file: %v\n", byteCodeFileID)

	// Instantiate the contract instance
	contractTransactionResponse, err := hedera.NewContractCreateTransaction().
		// Failing to set this to a sufficient amount will result in "INSUFFICIENT_GAS" status
		SetGas(100000).
		// The file ID we got from the record of the file created previously
		SetBytecodeFileID(byteCodeFileID).
		// Setting an admin key allows you to delete the contract in the future
		SetAdminKey(client.GetOperatorPublicKey()).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating contract", err))
	}

	// get the record for the contract we created
	contractRecord, err := contractTransactionResponse.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving contract creation record", err))
	}

	contractCreateResult, err := contractRecord.GetContractCreateResult()
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving contract creation result", err))
	}

	// get the contract ID from the record
	newContractID := *contractRecord.Receipt.ContractID

	fmt.Printf("Contract create gas used: %v\n", contractCreateResult.GasUsed)
	fmt.Printf("Contract create transaction fee: %v\n", contractRecord.TransactionFee)
	fmt.Printf("Contract: %v\n", newContractID)

	// Call the contract to receive the greeting
	callResult, err := hedera.NewContractCallQuery().
		SetContractID(newContractID).
		// The amount of gas to use for the call
		// All of the gas offered will be used and charged a corresponding fee
		SetGas(100000).
		// This query requires payment, depends on gas used
		SetQueryPayment(hedera.NewHbar(1)).
		// Specified which function to call, and the parameters to pass to the function
		SetFunction("greet", nil).
		// This requires payment
		SetMaxQueryPayment(hedera.NewHbar(5)).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error executing contract call query", err))
	}

	fmt.Printf("Call gas used: %v\n", callResult.GasUsed)
	fmt.Printf("Message: %v\n", callResult.GetString(0))

	// Clean up, delete the transaction
	deleteTransactionResponse, err := hedera.NewContractDeleteTransaction().
		// Only thing required here is the contract ID
		SetContractID(newContractID).
		SetTransferAccountID(client.GetOperatorAccountID()).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error deleting contract", err))
	}

	deleteTransactionReceipt, err := deleteTransactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving contract delete receipt", err))
	}

	fmt.Printf("Status of transaction deletion: %v\n", deleteTransactionReceipt.Status)
}
// Filename: examples/create_stateful_contract/main.go
package main

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

type contract struct {
	Abi string `json:"abi"`
	Bin string `json:"bin"`
}

type contracts struct {
	Contracts map[string]contract `json:"contracts"`
	Version   string              `json:"version"`
}

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Make sure to close client after running
	defer func() {
		err = client.Close()
		if err != nil {
			panic(fmt.Sprintf("%v : error closing client", err))
		}
	}()

	// Read in the compiled contract from stateful.json
	rawSmartContract, err := os.ReadFile("./stateful.json")
	if err != nil {
		panic(fmt.Sprintf("%v : error reading stateful.json", err))
	}

	// Initialize contracts
	var smartContract contracts = contracts{}

	// Parse the rawSmartContract into smartContract
	err = json.Unmarshal([]byte(rawSmartContract), &smartContract)
	if err != nil {
		panic(fmt.Sprintf("%v : error unmarshaling", err))
	}

	// Retrieve the bytecode from the parsed smart contract
	smartContractByteCode := smartContract.Contracts["stateful.sol:StatefulContract"].Bin

	fmt.Println("Stateful contract example")
	fmt.Printf("Contract bytecode size: %v bytes\n", len(smartContractByteCode))

	// Upload a file containing the byte code
	byteCodeTransactionResponse, err := hedera.NewFileCreateTransaction().
		// A file is not implicitly owned by anyone, even the operator
		// But we do use operator's key for this one
		SetKeys(client.GetOperatorPublicKey()).
		// Set the stateful contract bytes for this
		SetContents([]byte(smartContractByteCode)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating file", err))
	}

	// Retrieve the receipt to make sure the transaction went through and to get bytecode file ID
	byteCodeTransactionReceipt, err := byteCodeTransactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting file create transaction receipt", err))
	}

	// Retrieve bytecode file ID from the receipt
	byteCodeFileID := *byteCodeTransactionReceipt.FileID

	fmt.Printf("contract bytecode file: %v\n", byteCodeFileID)

	// Set the parameters that should be passed to the contract constructor
	// In this case we are passing in a string with the value "hello from hedera!"
	// as the only parameter that is passed to the contract
	contractFunctionParams := hedera.NewContractFunctionParameters().
		AddString("hello from hedera")

	// Instantiate the contract instance
	contractTransactionID, err := hedera.NewContractCreateTransaction().
		// Set gas to create the contract
		// Failing to set this to a sufficient amount will result in "INSUFFICIENT_GAS" status
		SetGas(200000).
		// Failing to set parameters when required will result in "CONTRACT_REVERT_EXECUTED" status
		SetConstructorParameters(contractFunctionParams).
		// The contract bytecode must be set to the file ID containing the contract bytecode
		SetBytecodeFileID(byteCodeFileID).
		// Set the admin key on the contract in case the contract should be deleted or
		// updated in the future
		SetAdminKey(client.GetOperatorPublicKey()).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating contract", err))
	}

	// Get the new contract record to make sure the transaction ran successfully
	contractRecord, err := contractTransactionID.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving contract creation record", err))
	}

	// Get the contract create result from the record
	contractCreateResult, err := contractRecord.GetContractCreateResult()
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving contract creation result", err))
	}

	// Get the new contract ID from the receipt contained in the record
	newContractID := *contractRecord.Receipt.ContractID

	fmt.Printf("Contract create gas used: %v\n", contractCreateResult.GasUsed)
	fmt.Printf("Contract create transaction fee: %v\n", contractRecord.TransactionFee)
	fmt.Printf("contract: %v\n", newContractID)

	// Ask for the current message (set on creation)
	callResult, err := hedera.NewContractCallQuery().
		// Set which contract
		SetContractID(newContractID).
		// The amount of gas to use for the call
		// All of the gas offered will be used and charged a corresponding fee
		SetGas(100000).
		// This query requires payment, depends on gas used
		SetQueryPayment(hedera.NewHbar(1)).
		// nil -> no parameters
		// Specified which function to call, and the parameters to pass to the function
		SetFunction("getMessage", nil).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing contract call query", err))
	}

	fmt.Printf("Call gas used: %v\n", callResult.GasUsed)
	// Get the message from the result
	// The `0` is the index to fetch a particular type from
	//
	// e.g. type of `getMessage` was `(uint32, string)`
	// then you'd need to get each field separately using:
	//      uint32 := callResult.getUint32(0);
	//      string := callResult.getString(1);
	fmt.Printf("Message: %v\n", callResult.GetString(0))

	// In this case we are passing in a string with the value "Hello from Hedera again!"
	// as the only parameter that is passed to the contract
	contractFunctionParams = hedera.NewContractFunctionParameters().
		AddString("Hello from Hedera again!")

	// Update the message
	contractExecuteID, err := hedera.NewContractExecuteTransaction().
		// Set which contract
		SetContractID(newContractID).
		// Set the gas to execute the contract call
		SetGas(100000).
		// Set the function to call and the parameters to send
		// in this case we're calling function "set_message" with a single
		// string parameter of value "Hello from Hedera again!"
		// If instead the "setMessage" method were to require "uint32, string"
		// parameters then you must do:
		//     contractFunctionParams := hedera.NewContractFunctionParameters().
		//          .addUint32(1)
		//          .addString("string 3")
		SetFunction("setMessage", contractFunctionParams).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error executing contract", err))
	}

	// Retrieve the record to make sure the execute transaction ran
	contractExecuteRecord, err := contractExecuteID.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving contract execution record", err))
	}

	// Get the contract execute result, that contains gas used
	contractExecuteResult, err := contractExecuteRecord.GetContractExecuteResult()
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving contract exe", err))
	}

	// Print gas used
	fmt.Printf("Execute gas used: %v\n", contractExecuteResult.GasUsed)

	// Call a method on a contract that exists on Hedera
	secondCallResult, err := hedera.NewContractCallQuery().
		// Set which contract
		SetContractID(newContractID).
		// Set gas to use
		SetGas(100000).
		// Set the query payment explicitly since sometimes automatic payment calculated
		// is too low
		SetQueryPayment(hedera.NewHbar(1)).
		// Set the function to call on the contract
		SetFunction("getMessage", nil).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error executing contract call query", err))
	}

	// Get gas used
	fmt.Printf("Call gas used: %v\n", secondCallResult.GasUsed)
	// Get a string from the result at index 0
	fmt.Printf("Message: %v\n", secondCallResult.GetString(0))
}
// Filename: examples/custom_fees/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generate new key to be used with new account
	aliceKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	// Create three accounts, Alice, Bob, and Charlie.  Alice will be the treasury for our example token.
	// Fees only apply in transactions not involving the treasury, so we need two other accounts.

	aliceAccountCreate, err := hedera.NewAccountCreateTransaction().
		SetInitialBalance(hedera.NewHbar(10)).
		SetKey(aliceKey).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account create for alice", err))
	}

	aliceAccountCreate.Sign(aliceKey)
	resp, err := aliceAccountCreate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account create for alice", err))
	}

	receipt, err := resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt for alice account create", err))
	}

	var aliceId hedera.AccountID
	if receipt.AccountID != nil {
		aliceId = *receipt.AccountID
	} else {
		panic("Receipt didn't return alice's ID")
	}

	bobKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	bobAccountCreate, err := hedera.NewAccountCreateTransaction().
		SetInitialBalance(hedera.NewHbar(10)).
		SetKey(bobKey).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account create for bob", err))
	}

	bobAccountCreate.Sign(bobKey)
	resp, err = bobAccountCreate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account create for bob", err))
	}

	receipt, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt for bob account create", err))
	}

	var bobId hedera.AccountID
	if receipt.AccountID != nil {
		bobId = *receipt.AccountID
	} else {
		panic("Receipt didn't return bob's ID")
	}

	charlieKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	charlieAccountCreate, err := hedera.NewAccountCreateTransaction().
		SetInitialBalance(hedera.NewHbar(10)).
		SetKey(charlieKey).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account create for charlie", err))
	}

	charlieAccountCreate.Sign(aliceKey)
	resp, err = charlieAccountCreate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account create for charlie", err))
	}

	receipt, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt for charlie account create", err))
	}

	var charlieId hedera.AccountID
	if receipt.AccountID != nil {
		charlieId = *receipt.AccountID
	} else {
		panic("Receipt didn't return charlie's ID")
	}

	println("Alice:", aliceId.String())
	println("Bob:", bobId.String())
	println("Charlie:", charlieId.String())

	// Let's start with a custom fee list of 1 fixed fee.  A custom fee list can be a list of up to
	// 10 custom fees, where each fee is a fixed fee or a fractional fee.
	// This fixed fee will mean that every time Bob transfers any number of tokens to Charlie,
	// Alice will collect 1 Hbar from each account involved in the transaction who is SENDING
	// the Token (in this case, Bob).

	customHbarFee := hedera.NewCustomFixedFee().
		SetHbarAmount(hedera.NewHbar(1)).
		SetFeeCollectorAccountID(aliceId)

	// In this example the fee is in Hbar, but you can charge a fixed fee in a token if you'd like.
	// EG, you can make it so that each time an account transfers Foo tokens,
	// they must pay a fee in Bar tokens to the fee collecting account.
	// To charge a fixed fee in tokens, instead of calling setHbarAmount(), call
	// setDenominatingTokenId(tokenForFee) and setAmount(tokenFeeAmount).

	// Setting the feeScheduleKey to Alice's key will enable Alice to change the custom
	// fees list on this token later using the TokenFeeScheduleUpdateTransaction.
	// We will create an initial supply of 100 of these tokens.

	tokenCreate, err := hedera.NewTokenCreateTransaction().
		// Token name and symbol are only things required to create a token
		SetTokenName("Example Token").
		SetTokenSymbol("EX").
		// The key which can perform update/delete operations on the token. If empty, the token can be
		// perceived as immutable (not being able to be updated/deleted)
		SetAdminKey(aliceKey).
		// The key which can change the supply of a token. The key is used to sign Token Mint/Burn
		// operations
		SetSupplyKey(aliceKey).
		// The key which can change the token's custom fee schedule; must sign a TokenFeeScheduleUpdate
		// transaction
		SetFeeScheduleKey(aliceKey).
		// The account which will act as a treasury for the token. This account
		// will receive the specified initial supply or the newly minted NFTs
		SetTreasuryAccountID(aliceId).
		// The custom fees to be assessed during a CryptoTransfer that transfers units of this token
		SetCustomFees([]hedera.Fee{*customHbarFee}).
		// Specifies the initial supply of tokens to be put in circulation. The
		// initial supply is sent to the Treasury Account.
		SetInitialSupply(100).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing token create transaction", err))
	}

	// Sign with alice's key before executing
	tokenCreate.Sign(aliceKey)
	resp, err = tokenCreate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing token create transaction", err))
	}

	// Get receipt to make sure the transaction passed through
	receipt, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt for token create transaction", err))
	}

	// Get the token out of the receipt
	var tokenId hedera.TokenID
	if receipt.TokenID != nil {
		tokenId = *receipt.TokenID
	} else {
		println("Token ID missing in the receipt")
	}

	println("TokenID:", tokenId.String())

	tokenInfo1, err := hedera.NewTokenInfoQuery().
		SetTokenID(tokenId).
		Execute(client)

	println("Custom Fees according to TokenInfoQuery:")
	for _, i := range tokenInfo1.CustomFees {
		switch t := i.(type) {
		case hedera.CustomFixedFee:
			println(t.String())
		}
	}

	// We must associate the token with Bob and Charlie before they can trade in it.

	tokenAssociate, err := hedera.NewTokenAssociateTransaction().
		// Account to associate token with
		SetAccountID(bobId).
		// The token to associate with
		SetTokenIDs(tokenId).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing token associate transaction for bob", err))
	}

	// Signing with bob's key
	tokenAssociate.Sign(bobKey)
	resp, err = tokenAssociate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing token associate transaction for bob", err))
	}

	_, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt for token associate transaction for bob", err))
	}

	// Associating charlie's account with the token
	tokenAssociate, err = hedera.NewTokenAssociateTransaction().
		// Account to associate token with
		SetAccountID(charlieId).
		// The token to associate with
		SetTokenIDs(tokenId).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing token associate transaction for charlie", err))
	}

	// Signing with charlie's key
	tokenAssociate.Sign(charlieKey)
	resp, err = tokenAssociate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing token associate transaction for charlie", err))
	}

	_, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt for token associate transaction for charlie", err))
	}

	// Give all 100 tokens to Bob
	transferTransaction, err := hedera.NewTransferTransaction().
		// The 100 tokens being given to bob
		AddTokenTransfer(tokenId, bobId, 100).
		// Have to take the 100 tokens from alice by negating the 100
		AddTokenTransfer(tokenId, aliceId, -100).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing token transfer transaction for alice", err))
	}

	// Have to sign with alice's key as we are taking alice's tokens
	transferTransaction.Sign(aliceKey)
	resp, err = transferTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing token transfer transaction for alice", err))
	}

	// Make sure the transaction passed through
	_, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt for token transfer transaction for alice", err))
	}

	// Check alice's balance before Bob transfers 20 tokens to Charlie
	// This is a free query
	aliceBalance1, err := hedera.NewAccountBalanceQuery().
		SetAccountID(aliceId).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting account balance 1 for alice", err))
	}

	println("Alice's Hbar balance before Bob transfers 20 tokens to Charlie:", aliceBalance1.Hbars.String())

	// Transfer 20 tokens from bob to charlie
	transferTransaction, err = hedera.NewTransferTransaction().
		// Taking away 20 tokens from bob
		AddTokenTransfer(tokenId, bobId, -20).
		// Giving 20 to charlie
		AddTokenTransfer(tokenId, charlieId, 20).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing token transfer transaction for bob", err))
	}

	// As we are taking from bob, bob has to sign this.
	transferTransaction.Sign(bobKey)
	resp, err = transferTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing token transfer transaction for bob", err))
	}

	// Getting the record to show the assessed custom fees
	record1, err := resp.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting record for token transfer transaction for bob", err))
	}

	// Query to check alice's balance
	aliceBalance2, err := hedera.NewAccountBalanceQuery().
		SetAccountID(aliceId).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting account balance 2 for alice", err))
	}

	println("Alice's Hbar balance after Bob transfers 20 tokens to Charlie:", aliceBalance2.Hbars.String())
	println("Assessed fees according to transaction record:")
	for _, k := range record1.AssessedCustomFees {
		println(k.String())
	}

	// Let's use the TokenUpdateFeeScheduleTransaction with Alice's key to change the custom fees on our token.
	// TokenUpdateFeeScheduleTransaction will replace the list of fees that apply to the token with
	// an entirely new list.  Let's charge a 10% fractional fee.  This means that when Bob attempts to transfer
	// 20 tokens to Charlie, 10% of the tokens he attempts to transfer (2 in this case) will be transferred to
	// Alice instead.

	// Fractional fees default to FeeAssessmentMethod.INCLUSIVE, which is the behavior described above.
	// If you set the assessment method to EXCLUSIVE, then when Bob attempts to transfer 20 tokens to Charlie,
	// Charlie will receive all 20 tokens, and Bob will be charged an _additional_ 10% fee which
	// will be transferred to Alice.

	customFractionalFee := hedera.NewCustomFractionalFee().
		SetNumerator(1).
		SetDenominator(10).
		// The minimum amount to assess
		SetMin(1).
		// The maximum amount to assess (zero implies no maximum)
		SetMax(10).
		// The account to receive the custom fee
		SetFeeCollectorAccountID(aliceId)

	tokenFeeUpdate, err := hedera.NewTokenFeeScheduleUpdateTransaction().
		// The token for which the custom fee will be updated
		SetTokenID(tokenId).
		// The updated custom fee
		SetCustomFees([]hedera.Fee{*customFractionalFee}).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing token fee update", err))
	}

	// As the token is owned by alice and all keys are set to alice's key we have to sign with that
	tokenFeeUpdate.Sign(aliceKey)
	resp, err = tokenFeeUpdate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing token fee update", err))
	}

	_, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt for token fee update", err))
	}

	// Get token info, we can check if the custom fee is updated
	tokenInfo2, err := hedera.NewTokenInfoQuery().
		SetTokenID(tokenId).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info 2", err))
	}

	println("Custom Fees according to TokenInfoQuery:")
	for _, i := range tokenInfo2.CustomFees {
		switch t := i.(type) {
		case hedera.CustomFractionalFee:
			println(t.String())
		}
	}

	// Another account balance query to check alice's token balance before Bob transfers 20 tokens to Charlie
	aliceBalance3, err := hedera.NewAccountBalanceQuery().
		SetAccountID(aliceId).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting account balance 3 for alice", err))
	}

	println("Alice's token balance before Bob transfers 20 tokens to Charlie:", aliceBalance3.Tokens.Get(tokenId))

	// Once again transfer 20 tokens from bob to charlie
	transferTransaction, err = hedera.NewTransferTransaction().
		AddTokenTransfer(tokenId, bobId, -20).
		AddTokenTransfer(tokenId, charlieId, 20).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing token transfer transaction for bob", err))
	}

	// Bob's is losing 20 tokens again. so he has to sign this transfer
	transferTransaction.Sign(bobKey)
	resp, err = transferTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing token transfer transaction for bob", err))
	}

	record2, err := resp.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting record for token transfer transaction for bob", err))
	}

	// Checking alice's token balance again
	aliceBalance4, err := hedera.NewAccountBalanceQuery().
		SetAccountID(aliceId).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting account balance 2 for alice", err))
	}

	println("Alice's token balance after Bob transfers 20 tokens to Charlie:", aliceBalance4.Tokens.Get(tokenId))
	println("Token transfers according to transaction record:")
	for token, transfer := range record2.TokenTransfers {
		tokenT := ""
		for _, t := range transfer {
			tokenT = tokenT + " " + t.String()
		}
		println("for token", token.String()+":", tokenT)
	}
	println("Assessed fees according to transaction record:")
	for _, k := range record2.AssessedCustomFees {
		println(k.String())
	}

	//Clean up

	tokenDelete, _ := hedera.NewTokenDeleteTransaction().
		SetTokenID(tokenId).
		FreezeWith(client)

	tokenDelete.Sign(aliceKey)
	resp, _ = tokenDelete.Execute(client)
	_, _ = resp.GetReceipt(client)

	accDelete, _ := hedera.NewAccountDeleteTransaction().
		SetTransactionID(hedera.TransactionIDGenerate(charlieId)).
		SetTransferAccountID(client.GetOperatorAccountID()).
		SetAccountID(charlieId).
		FreezeWith(client)

	accDelete.Sign(charlieKey)
	resp, err = accDelete.Execute(client)
	_, _ = resp.GetReceipt(client)

	accDelete, _ = hedera.NewAccountDeleteTransaction().
		SetTransactionID(hedera.TransactionIDGenerate(bobId)).
		SetTransferAccountID(client.GetOperatorAccountID()).
		SetAccountID(bobId).
		FreezeWith(client)

	accDelete.Sign(bobKey)
	resp, _ = accDelete.Execute(client)
	_, _ = resp.GetReceipt(client)

	accDelete, _ = hedera.NewAccountDeleteTransaction().
		SetTransactionID(hedera.TransactionIDGenerate(aliceId)).
		SetTransferAccountID(client.GetOperatorAccountID()).
		SetAccountID(aliceId).
		FreezeWith(client)

	accDelete.Sign(aliceKey)
	resp, _ = accDelete.Execute(client)
	_, _ = resp.GetReceipt(client)

	_ = client.Close()
}
// Filename: examples/dab/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	accountID, _ := hedera.AccountIDFromString("0.0.1999")
	description := "Hedera™ cryptocurrency"
	newDescription := "Hedera™ cryptocurrency - updated"

	ipv4 := []byte{127, 0, 0, 1}

	gossipEndpoint := hedera.Endpoint{}
	gossipEndpoint.SetAddress(ipv4).SetPort(50211)

	serviceEndpoint := hedera.Endpoint{}
	serviceEndpoint.SetAddress(ipv4).SetPort(50211)

	adminKey, _ := hedera.PrivateKeyGenerateEd25519()

	nodeCreateTransaction := hedera.NewNodeCreateTransaction().
		SetAccountID(accountID).
		SetDescription(description).
		SetGossipCaCertificate([]byte("gossipCaCertificate")).
		SetServiceEndpoints([]hedera.Endpoint{serviceEndpoint}).
		SetGossipEndpoints([]hedera.Endpoint{gossipEndpoint}).
		SetAdminKey(adminKey.PublicKey())

	resp, err := nodeCreateTransaction.Execute(client)
	fmt.Println(err)
	_, err = resp.SetValidateStatus(true).GetReceipt(client)
	fmt.Println(err)

	nodeUpdateTransaction := hedera.NewNodeUpdateTransaction().
		SetNodeID(123).
		SetDescription(newDescription).
		SetGossipCaCertificate([]byte("gossipCaCertificate")).
		SetServiceEndpoints([]hedera.Endpoint{serviceEndpoint}).
		SetGossipEndpoints([]hedera.Endpoint{gossipEndpoint}).
		SetAdminKey(adminKey.PublicKey())
	resp, err = nodeUpdateTransaction.Execute(client)
	fmt.Println(err)

	_, err = resp.SetValidateStatus(true).GetReceipt(client)
	fmt.Println(err)

	nodeDeleteTransaction := hedera.NewNodeDeleteTransaction().
		SetNodeID(123)
	resp, err = nodeDeleteTransaction.Execute(client)
	fmt.Println(err)

	_, err = resp.SetValidateStatus(true).GetReceipt(client)
	fmt.Println(err)
}
// Filename: examples/delete_account/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generate the key to use with the new account
	newKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	fmt.Println("Creating an account to delete:")
	fmt.Printf("private = %v\n", newKey)
	fmt.Printf("public = %v\n", newKey.PublicKey())

	// First create an account
	transactionResponse, err := hedera.NewAccountCreateTransaction().
		// This key will be required to delete the account later
		SetKey(newKey.PublicKey()).
		// Initial balance
		SetInitialBalance(hedera.NewHbar(2)).
		SetTransactionMemo("go sdk example delete_account/main.go").
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating account", err))
	}

	transactionReceipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account creation receipt", err))
	}

	newAccountID := *transactionReceipt.AccountID

	fmt.Printf("account = %v\n", newAccountID)
	fmt.Println("deleting created account")

	// To delete an account you must do the following:
	deleteTransaction, err := hedera.NewAccountDeleteTransaction().
		// Set the account to be deleted
		SetAccountID(newAccountID).
		// Set an account ID to transfer the balance of the deleted account to
		SetTransferAccountID(hedera.AccountID{Account: 3}).
		SetTransactionMemo("go sdk example delete_account/main.go").
		FreezeWith(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account delete transaction", err))
	}

	// Manually sign the transaction with the private key of the account to be deleted
	deleteTransaction = deleteTransaction.Sign(newKey)

	// Execute the transaction
	deleteTransactionResponse, err := deleteTransaction.Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error deleting account", err))
	}

	deleteTransactionReceipt, err := deleteTransactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account deletion receipt", err))
	}

	fmt.Printf("account delete transaction status: %v\n", deleteTransactionReceipt.Status)
}
// Filename: examples/delete_file/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generate the key to be used with the new file
	newKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	fmt.Println("Creating a file to delete:")

	// First create a file
	freezeTransaction, err := hedera.NewFileCreateTransaction().
		// Mock contents
		SetContents([]byte("The quick brown fox jumps over the lazy dog")).
		// All keys at the top level of a key list must sign to create or modify the file. Any one of
		// the keys at the top level key list can sign to delete the file.
		SetKeys(newKey.PublicKey()).
		SetTransactionMemo("go sdk example delete_file/main.go").
		SetMaxTransactionFee(hedera.HbarFrom(8, hedera.HbarUnits.Hbar)).
		FreezeWith(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error freezing transaction", err))
	}
	transactionResponse, err := freezeTransaction.Sign(newKey).Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error creating file", err))
	}

	// Get the receipt to make sure transaction went through
	receipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving file creation receipt", err))
	}

	// Retrieve file ID from the receipt
	newFileID := *receipt.FileID

	fmt.Printf("file = %v\n", newFileID)
	fmt.Println("deleting created file")

	// To delete a file you must do the following:
	deleteTransaction, err := hedera.NewFileDeleteTransaction().
		// Set file ID
		SetFileID(newFileID).
		FreezeWith(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error freezing file delete transaction", err))
	}

	// Sign with the key we used to create the file
	deleteTransaction.Sign(newKey)

	// Execute the file delete transaction
	deleteTransactionResponse, err := deleteTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing file delete transaction", err))
	}

	// Check that it went through
	deleteTransactionReceipt, err := deleteTransactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving file deletion receipt", err))
	}

	fmt.Printf("file delete transaction status: %v\n", deleteTransactionReceipt.Status)

	// Querying for file info on a deleted file will result in FILE_DELETED
	// Good way to check if file was actually deleted
	fileInfo, err := hedera.NewFileInfoQuery().
		// Only file ID required
		SetFileID(newFileID).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error executing file info query", err))
	}

	fmt.Printf("file %v was deleted: %v\n", newFileID, fileInfo.IsDeleted)
}
// Filename: examples/exempt_custom_fees/main.go
package main

import (
	"fmt"
	"github.com/hashgraph/hedera-sdk-go/v2"
	"os"
)

func main() {
	client, err := hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	id, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	key, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(id, key)

	/**     Example 1
	 *
	 * Step 1
	 *
	 * Create accounts A, B, and C
	 */

	firstAccountPrivateKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(err)
	}
	firstPublicKey := firstAccountPrivateKey.PublicKey()
	firstAccount, err := hedera.NewAccountCreateTransaction().
		SetKey(firstPublicKey).
		SetInitialBalance(hedera.HbarFrom(1000, hedera.HbarUnits.Tinybar)).
		Execute(client)
	if err != nil {
		panic(err)
	}
	receiptFirstAccount, err := firstAccount.GetReceipt(client)
	if err != nil {
		panic(err)
	}

	//Get the new account ID from the receipt
	firstAccountId := *receiptFirstAccount.AccountID
	fmt.Println("firstAccountId: ", firstAccountId)

	secondAccountPrivateKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(err)
	}
	secondAccountPublicKey := secondAccountPrivateKey.PublicKey()
	secondAccount, err := hedera.NewAccountCreateTransaction().
		SetKey(secondAccountPublicKey).
		SetInitialBalance(hedera.HbarFrom(1000, hedera.HbarUnits.Tinybar)).
		Execute(client)
	if err != nil {
		panic(err)
	}
	receiptSecondAccount, err := secondAccount.GetReceipt(client)
	if err != nil {
		panic(err)
	}

	//Get the new account ID from the receipt
	secondAccountId := *receiptSecondAccount.AccountID
	fmt.Println("secondAccountId: ", secondAccountId)

	thirdAccountPrivateKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(err)
	}
	thirdAccountPublicKey := thirdAccountPrivateKey.PublicKey()
	thirdAccount, err := hedera.NewAccountCreateTransaction().
		SetKey(thirdAccountPublicKey).
		SetInitialBalance(hedera.HbarFrom(1000, hedera.HbarUnits.Tinybar)).
		Execute(client)
	if err != nil {
		panic(err)
	}
	receiptThirdAccount, err := thirdAccount.GetReceipt(client)
	if err != nil {
		panic(err)
	}

	//Get the new account ID from the receipt
	thirdAccountId := *receiptThirdAccount.AccountID
	fmt.Println("thirdAccountId: ", thirdAccountId)

	/**
	 * Step 2
	 *
	 * 2. Create a fungible token that has three fractional fees
	 * Fee #1 sends 1/100 of the transferred value to collector 0.0.A.
	 * Fee #2 sends 2/100 of the transferred value to collector 0.0.B.
	 * Fee #3 sends 3/100 of the transferred value to collector 0.0.C.
	 */

	fee1 := hedera.NewCustomFractionalFee().SetFeeCollectorAccountID(firstAccountId).SetNumerator(1).SetDenominator(100).SetAllCollectorsAreExempt(true)
	fee2 := hedera.NewCustomFractionalFee().SetFeeCollectorAccountID(secondAccountId).SetNumerator(2).SetDenominator(100).SetAllCollectorsAreExempt(true)
	fee3 := hedera.NewCustomFractionalFee().SetFeeCollectorAccountID(thirdAccountId).SetNumerator(3).SetDenominator(100).SetAllCollectorsAreExempt(true)
	tokenCreateTransaction, err := hedera.NewTokenCreateTransaction().
		SetTokenName("HIP-573 Token").SetTokenSymbol("H573").
		SetTokenType(hedera.TokenTypeFungibleCommon).
		SetTreasuryAccountID(id).SetAutoRenewAccount(id).
		SetAdminKey(key.PublicKey()).SetFreezeKey(key.PublicKey()).
		SetWipeKey(key.PublicKey()).SetInitialSupply(100000000). // Total supply = 100000000 / 10 ^ 2
		SetDecimals(2).SetCustomFees([]hedera.Fee{fee1, fee2, fee3}).FreezeWith(client)
	if err != nil {
		panic(err)
	}

	transactionResponse, err := tokenCreateTransaction.Sign(key).
		Sign(firstAccountPrivateKey).
		Sign(secondAccountPrivateKey).
		Sign(thirdAccountPrivateKey).Execute(client)
	if err != nil {
		panic(err)
	}
	receipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(err)
	}
	tokenId := *receipt.TokenID
	fmt.Println("Created token with token id: ", tokenId)

	/**
	 * Step 3
	 *
	 * Collector 0.0.B sends 10_000 units of the token to 0.0.A.
	 */

	const amount = 10_000
	// First we transfer the amount from treasury account to second account
	treasuryTokenTransferTransaction, err := hedera.NewTransferTransaction().
		AddTokenTransfer(tokenId, id, -amount).AddTokenTransfer(tokenId, secondAccountId, amount).
		FreezeWith(client)
	if err != nil {
		panic(err)
	}

	treasuryTokenTransferSubmit, err := treasuryTokenTransferTransaction.Sign(key).Execute(client)
	if err != nil {
		panic(err)
	}
	treasuryTransferReceipt, err := treasuryTokenTransferSubmit.GetReceipt(client)
	if err != nil {
		panic(err)
	}

	fmt.Println("Sending from treasury account to the second account - 'TransferTransaction' status: ", treasuryTransferReceipt.Status)

	tokenTransferTx, err := hedera.NewTransferTransaction().
		AddTokenTransfer(tokenId, secondAccountId, -amount).
		AddTokenTransfer(tokenId, firstAccountId, amount).
		FreezeWith(client)
	if err != nil {
		panic(err)
	}

	submitTransaction, err := tokenTransferTx.Sign(key).Sign(secondAccountPrivateKey).Execute(client)
	if err != nil {
		panic(err)
	}

	record, err := submitTransaction.GetRecord(client)
	if err != nil {
		panic(err)
	}
	fmt.Println("Transaction fee: ", record.TransactionFee)

	/**
	 * Step 5
	 *
	 * Show that the fee collector accounts in the custom fee list
	 * of the token that was created was not charged a custom fee in the transfer
	 */

	firstAccountBalanceAfter, err := hedera.NewAccountBalanceQuery().
		SetAccountID(firstAccountId).
		Execute(client)
	if err != nil {
		panic(err)
	}
	fmt.Println("first's balance:", firstAccountBalanceAfter.Tokens.Get(tokenId))

	secondAccountBalanceAfter, err := hedera.NewAccountBalanceQuery().
		SetAccountID(secondAccountId).
		Execute(client)
	if err != nil {
		panic(err)
	}
	fmt.Println("second's balance:", secondAccountBalanceAfter.Tokens.Get(tokenId))

	thirdAccountBalanceAfter, err := hedera.NewAccountBalanceQuery().
		SetAccountID(thirdAccountId).
		Execute(client)
	if err != nil {
		panic(err)
	}
	fmt.Println("third's balance:", secondAccountBalanceAfter.Tokens.Get(tokenId))

	if firstAccountBalanceAfter.Tokens.Get(tokenId) == amount && secondAccountBalanceAfter.Tokens.Get(tokenId) == 0 && thirdAccountBalanceAfter.Tokens.Get(tokenId) == 0 {
		fmt.Println("Fee collector accounts were not charged after transfer transaction")
	}

	client.Close()

}
// Filename: examples/file_append_chunked/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Create a new file
	newFileResponse, err := hedera.NewFileCreateTransaction().
		// Accepts both Key and []Key
		// All keys at the top level of a key list must sign to create or modify the file. Any one of
		// the keys at the top level key list can sign to delete the file.
		SetKeys(client.GetOperatorPublicKey()).
		// Basic starting file content
		SetContents([]byte("Hello from Hedera.")).
		SetMemo("go file append test").
		// Set max fee if we don't want to get overcharged
		SetMaxTransactionFee(hedera.NewHbar(2)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating file", err))
	}

	// Get receipt to make sure the transaction worked
	receipt, err := newFileResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving file creation receipt", err))
	}

	// Retrieve file ID from the receipt
	fileID := *receipt.FileID

	// File append
	fileResponse, err := hedera.NewFileAppendTransaction().
		// Make sure the node is the same as the new file, as we don't have to wait for propagation
		SetNodeAccountIDs([]hedera.AccountID{newFileResponse.NodeID}).
		// File ID to append to
		SetFileID(fileID).
		// Contents that will be appended to the end of the file
		SetContents([]byte(bigContents)).
		// Set max transaction when you are not sure how much it will cost.
		SetMaxTransactionFee(hedera.NewHbar(5)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing file append transaction", err))
	}

	// Checking if transaction went through
	receipt, err = fileResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving file append transaction receipt", err))
	}

	// Checking if append succeeded
	println(receipt.Status.String())
	info, err := hedera.NewFileInfoQuery().
		// Once again same node account ID
		SetNodeAccountIDs([]hedera.AccountID{fileResponse.NodeID}).
		// Only the file ID is required for this
		SetFileID(fileID).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error executing file info query", err))
	}

	println("File size according to `FileInfoQuery`:", info.Size)
	println("File memo according to `FileInfoQuery`:", info.FileMemo)
}

// 14k+ stuff to upload
const bigContents = `
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.

Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.

Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.

Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.

Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.

Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.

Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.

Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.

Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.

In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.

Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.

Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.

Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.

Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.

Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.

Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.

Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.

Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.

Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.

Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.

Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.

In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.
`
// Filename: examples/generate_key/main.go
package main

import (
	"fmt"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	// Generating key
	privateKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	// Retrieve the public key
	publicKey := privateKey.PublicKey()

	fmt.Printf("private = %v\n", privateKey)
	fmt.Printf("public = %v\n", publicKey)
}
// Filename: examples/generate_key_with_mnemonic/main.go
package main

import (
	"fmt"
	"strings"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	// Generate 24 word mnemonic
	mnemonic24, err := hedera.GenerateMnemonic24()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating 24 word mnemonic", err))
	}

	// Generate 12 word mnemonic
	mnemonic12, err := hedera.GenerateMnemonic12()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating 12 word mnemonic", err))
	}

	// Given legacy string
	legacyString := "jolly,kidnap,tom,lawn,drunk,chick,optic,lust,mutter,mole,bride,galley,dense,member,sage,neural,widow,decide,curb,aboard,margin,manure"

	// Initializing a legacy mnemonic from legacy string
	mnemonicLegacy, err := hedera.NewMnemonic(strings.Split(legacyString, ","))
	if err != nil {
		panic(fmt.Sprintf("%v : error generating mnemonic from legacy string", err))
	}

	fmt.Printf("mnemonic 24 word = %v\n", mnemonic24)
	fmt.Printf("mnemonic 12 word = %v\n", mnemonic12)
	fmt.Printf("mnemonic legacy = %v\n", mnemonicLegacy)

	// Creating a Private Key from 24 word mnemonic with an optional passphrase
	privateKey24, err := mnemonic24.ToPrivateKey( /* passphrase */ "")
	if err != nil {
		panic(fmt.Sprintf("%v : error converting 24 word mnemonic to PrivateKey", err))
	}

	// Creating a Private Key from 12 word mnemonic with an optional passphrase
	privateKey12, err := mnemonic12.ToPrivateKey( /* passphrase */ "")
	if err != nil {
		panic(fmt.Sprintf("%v : error converting 12 word mnemonic to PrivateKey", err))
	}

	// ToLegacyPrivateKey() doesn't support a passphrase
	privateLegacy, err := mnemonicLegacy.ToLegacyPrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error converting legacy mnemonic to PrivateKey", err))
	}

	// Retrieving the Public Key
	publicKey24 := privateKey24.PublicKey()
	publicKey12 := privateKey12.PublicKey()
	publicLegacy := privateLegacy.PublicKey()

	fmt.Printf("private 24 word = %v\n", privateKey24)
	fmt.Printf("public 24 word = %v\n", publicKey24)

	fmt.Printf("private 12 word = %v\n", privateKey12)
	fmt.Printf("public 12 word = %v\n", publicKey12)

	fmt.Printf("private legacy = %v\n", privateLegacy)
	fmt.Printf("public legacy = %v\n", publicLegacy)
}
// Filename: examples/get_account_balance/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// This is a free query to retrieve account's balance
	balance, err := hedera.NewAccountBalanceQuery().
		// Have to set account ID
		SetAccountID(client.GetOperatorAccountID()).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error executing account balance query", err))
	}

	fmt.Printf("balance = %v\n", balance.Hbars.String())
}
// Filename: examples/get_address_book/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	fileQuery := hedera.NewFileContentsQuery().
		// Set the file ID for address book which is 0.0.102
		SetFileID(hedera.FileIDForAddressBook())

	println("the network that address book is for:", client.GetNetworkName().String())

	cost, err := fileQuery.GetCost(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting file contents query cost", err))
	}

	println("file contents cost:", cost.String())

	// Have to always set the cost a little bigger, otherwise it is possible it won't go through
	fileQuery.SetMaxQueryPayment(hedera.NewHbar(1))

	// Execute the file content query
	contents, err := fileQuery.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing file contents query", err))
	}

	fileByte, err := os.OpenFile("address-book-byte.pb", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(fmt.Sprintf("%v : error opening address-book-byte.pb", err))
	}

	fileString, err := os.OpenFile("address-book-string.pb", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(fmt.Sprintf("%v : error opening address-book-string.pb", err))
	}

	// Write the contents (string([]byte)) into the string file
	leng, err := fileString.WriteString(string(contents))
	if err != nil {
		panic(fmt.Sprintf("%v : error writing contents to file", err))
	}
	// Write the contents ([]byte) into the byte file
	_, err = fileByte.Write(contents)
	if err != nil {
		panic(fmt.Sprintf("%v : error writing contents to file", err))
	}

	temp := make([]byte, leng)

	_, err = fileString.Read(temp)

	// Close the files
	err = fileString.Close()
	if err != nil {
		panic(fmt.Sprintf("%v : error closing the file", err))
	}
	err = fileByte.Close()
	if err != nil {
		panic(fmt.Sprintf("%v : error closing the file", err))
	}
}
// Filename: examples/get_file_contents/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Constructors exist for convenient files
	//fileID := hedera.FileIDForAddressBook()
	// fileID := hedera.FileIDForFeeSchedule()
	fileID := hedera.FileIDForExchangeRate()

	contents, err := hedera.NewFileContentsQuery().
		// Set the file ID for whatever file you need
		SetFileID(fileID).
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error executing file contents query", err))
	}

	exchangeRate, err := hedera.ExchangeRateFromBytes(contents)
	if err != nil {
		panic(fmt.Sprintf("%v : error converting contents to exchange rate", err))
	}

	fmt.Printf("Contents for file %v :\n", fileID.String())
	fmt.Print(exchangeRate.String())
	fmt.Println()
}
// Filename: examples/logging/main.go
package main

import (
	"fmt"
	"github.com/hashgraph/hedera-sdk-go/v2"
	"os"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// The client comes with default logger.
	// We can also set a custom logger for this client.
	// The logger must implement the hedera.Logger interface.
	logger := hedera.NewLogger("Hedera sdk", hedera.LoggerLevelDebug)
	client.SetLogger(logger)

	// Set the logging level fot this client, to be used as default.
	// Individual log levels can be set for the Query or Transaction object by
	// chaining the SetLogLevel() function on the given Transaction or Query object.
	client.SetLogLevel(hedera.LoggerLevelTrace)

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generate new key to use with new account
	newKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey}", err))
	}

	fmt.Printf("private = %v\n", newKey)
	fmt.Printf("public = %v\n", newKey.PublicKey())

	// Transaction used to show default logging functionality from client
	_, err = hedera.NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account create transaction}", err))
	}

	// Disable default logging on client, to show logging functionality from transaction
	client.SetLogLevel(hedera.LoggerLevelDisabled)

	// Create account transaction used to show logging functionality
	_, err = hedera.NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		// Set logging level for the specific transaction
		SetLogLevel(hedera.LoggerLevelTrace).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account create transaction}", err))
	}
}
// Filename: examples/multi_app_transfer/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	// Our hypothetical primary service only knows the operator/sender's account ID and the recipient's accountID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	operatorPrivateKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	recipientAccountID := hedera.AccountID{Account: 3}

	// We create a client without a set operator
	client, err := hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	client.SetOperator(operatorAccountID, operatorPrivateKey)

	// We must manually construct a TransactionID with the accountID of the operator/sender
	// This is the account that will be charged the transaction fee
	txID := hedera.TransactionIDGenerate(operatorAccountID)

	// The following steps are required for manually signing
	transaction, err := hedera.NewTransferTransaction().
		// 1. Manually set the transaction ID
		SetTransactionID(txID).
		// 2. Add your sender and amount to be send
		AddHbarTransfer(operatorAccountID, hedera.NewHbar(-1)).
		// 3. add the recipient(s) and amount to be received
		AddHbarTransfer(recipientAccountID, hedera.NewHbar(1)).
		SetTransactionMemo("go sdk example multi_app_transfer/main.go").
		// 4. build the transaction using the client that does not have a set operator
		FreezeWith(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error freezing Transfer Transaction", err))
	}

	// Marshal your transaction to bytes
	txBytes, err := transaction.ToBytes()
	if err != nil {
		panic(fmt.Sprintf("%v : error converting transfer transaction to bytes", err))
	}

	fmt.Printf("Marshalled the unsigned transaction to bytes \n%v\n", txBytes)

	//
	// Send the bytes to the application or service that acts as a signer for your transactions
	//
	signedTxBytes, err := signingService(txBytes)

	if err != nil {
		panic(fmt.Sprintf("%v : error signing transfer transaction", err))
	}

	fmt.Printf("Received bytes for signed transaction: \n%v\n", signedTxBytes)

	// Unmarshal your bytes into the signed transaction
	var signedTx hedera.TransferTransaction
	tx, err := hedera.TransactionFromBytes(signedTxBytes)
	if err != nil {
		panic(fmt.Sprintf("%v : error converting bytes to transfer transaction", err))
	}

	// Converting from interface{} to TransferTransaction, if that's what we got
	switch t := tx.(type) {
	case hedera.TransferTransaction:
		signedTx = t
	default:
		panic("Did not receive `TransferTransaction` back from signed bytes")
	}

	// Execute the transaction
	response, err := signedTx.Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error executing the transfer transaction", err))
	}

	// Get the receipt of the transaction to check the status
	receipt, err := response.GetReceipt(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transfer transaction receipt", err))
	}

	// If Status Success is returned then everything is good
	fmt.Printf("Crypto transfer status: %v\n", receipt.Status)
}

// signingService represents an offline service which knows the private keys needed for signing
// a transaction and returns the byte representation of the transaction
func signingService(txBytes []byte) ([]byte, error) {
	fmt.Println("\nSigning service has received the transaction")

	// Your signing service is aware of the operator's private key
	operatorPrivateKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		return txBytes, err
	}

	// Unmarshal the unsigned transaction's bytes
	var unsignedTx hedera.TransferTransaction
	tx, err := hedera.TransactionFromBytes(txBytes)
	if err != nil {
		return txBytes, err
	}

	// Converting from interface{} to TransferTransaction, if that's what we got
	switch t := tx.(type) {
	case hedera.TransferTransaction:
		unsignedTx = t
	default:
		panic("Did not receive `TransferTransaction` back from signed bytes")
	}

	fmt.Printf("The Signing service is signing the transaction with key: %v\n", operatorPrivateKey)

	// sign your unsigned transaction and marshal back to bytes
	return unsignedTx.
		Sign(operatorPrivateKey).
		ToBytes()
}
// Filename: examples/precompile_example/main.go
package main

import (
	_ "embed"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
	"github.com/hashgraph/hedera-sdk-go/v2/examples/contract_helper"
)

//go:embed PrecompileExample.json
var precompileExample []byte

type AbiObject struct {
	ByteCode string `json:"bytecode"`
}

func additionalLogic(privateKey hedera.PrivateKey, keyList *hedera.KeyList, address string, client *hedera.Client) {
	id, err := hedera.TokenIDFromSolidityAddress(address)
	if err != nil {
		panic(err)
	}
	asd, err := hedera.NewTokenUpdateTransaction().SetTokenID(id).SetAdminKey(keyList).SetSupplyKey(keyList).Sign(privateKey).Execute(client)
	if err != nil {
		panic(err)
	}
	rec, err := asd.GetReceipt(client)
	if err != nil {
		panic(err)
	}
	fmt.Printf("asd: %v\n", rec)
}
func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	alicePrivateKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating Alice's private key", err))
	}
	alicePublicKey := alicePrivateKey.PublicKey()
	accountCreateResponse, err := hedera.NewAccountCreateTransaction().
		SetKey(alicePublicKey).
		SetInitialBalance(hedera.NewHbar(1)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating Alice's account", err))
	}

	accountCreateReceipt, err := accountCreateResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account create receipt", err))
	}

	var aliceAccountID hedera.AccountID
	if accountCreateReceipt.AccountID != nil {
		aliceAccountID = *accountCreateReceipt.AccountID
	} else {
		panic("Alice's account id from receipt is nil")
	}

	var abiObject AbiObject
	err = json.Unmarshal(precompileExample, &abiObject)
	if err != nil {
		panic("error reading from json")
	}

	contractFunctionParameters, err := hedera.NewContractFunctionParameters().
		AddAddress(client.GetOperatorAccountID().ToSolidityAddress())
	if err != nil {
		panic(fmt.Sprintf("%v : error making contract function parameters", err))
	}

	contractFunctionParameters, err = contractFunctionParameters.
		AddAddress(aliceAccountID.ToSolidityAddress())
	if err != nil {
		panic(fmt.Sprintf("%v : error adding alice's address to contract function parameters", err))
	}

	contractHelper := contract_helper.NewContractHelper([]byte(abiObject.ByteCode), *contractFunctionParameters, client)

	keyList := hedera.KeyListWithThreshold(1).Add(operatorKey.PublicKey()).Add(contractHelper.ContractID)

	tx, err := hedera.NewAccountUpdateTransaction().SetAccountID(operatorAccountID).SetKey(keyList).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating alice's account", err))
	}
	_, err = tx.GetReceipt(client)
	if err != nil {
		panic(err)
	}
	keyList = hedera.KeyListWithThreshold(1).Add(alicePublicKey).Add(contractHelper.ContractID)

	frozenTxn, err := hedera.NewAccountUpdateTransaction().SetAccountID(aliceAccountID).SetKey(keyList).FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating alice's account", err))
	}
	tx, err = frozenTxn.Sign(alicePrivateKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating alice's account", err))
	}
	_, err = tx.GetReceipt(client)
	if err != nil {
		panic(err)
	}

	tokenUpdateFunction := func(address string) {
		id, err := hedera.TokenIDFromSolidityAddress(address)
		if err != nil {
			panic(err)
		}
		frozenTxn, err := hedera.NewTokenUpdateTransaction().SetTokenID(id).SetAdminKey(keyList).SetSupplyKey(keyList).FreezeWith(client)
		if err != nil {
			panic(err)
		}
		tx, err := frozenTxn.Sign(alicePrivateKey).Execute(client)
		if err != nil {
			panic(err)
		}
		_, err = tx.GetReceipt(client)
		if err != nil {
			panic(err)
		}
	}

	contractHelper.
		SetResultValidatorForStep(0, func(contractFunctionResult hedera.ContractFunctionResult) bool {
			println("getPseudoRandomSeed() returned " + hex.EncodeToString(contractFunctionResult.GetBytes32(0)))
			return true
		}).
		SetPayableAmountForStep(1, hedera.NewHbar(20)).
		// step 3 associates Alice with the token, which requires Alice's signature
		AddSignerForStep(3, alicePrivateKey).
		AddSignerForStep(5, alicePrivateKey).
		SetParameterSupplierForStep(11, func() *hedera.ContractFunctionParameters {
			return hedera.NewContractFunctionParameters().
				// when contracts work with a public key, they handle the raw bytes of the public key
				AddBytes(alicePublicKey.BytesRaw())
		}).
		SetPayableAmountForStep(11, hedera.NewHbar(40)).
		// Because we're setting the adminKey for the created NFT token to Alice's key,
		// Alice must sign the ContractExecuteTransaction.
		AddSignerForStep(11, alicePrivateKey).
		SetStepLogic(11, tokenUpdateFunction).
		// and Alice must sign for minting because her key is the supply key.
		AddSignerForStep(12, alicePrivateKey).
		SetParameterSupplierForStep(12, func() *hedera.ContractFunctionParameters {
			return hedera.NewContractFunctionParameters().
				// add three metadatas
				AddBytesArray([][]byte{{0x01b}, {0x02b}, {0x03b}})
		}). // and alice must sign to become associated with the token.
		AddSignerForStep(13, alicePrivateKey).
		// Alice must sign to burn the token because her key is the supply key
		AddSignerForStep(16, alicePrivateKey)

	// step 0 tests pseudo random number generator (PRNG)
	// step 1 creates a fungible token
	// step 2 mints it
	// step 3 associates Alice with it
	// step 4 transfers it to Alice.
	// step 5 approves an allowance of the fungible token with operator as the owner and Alice as the spender
	// steps 6 - 10 test misc functions on the fungible token (see PrecompileExample.sol for details).
	// step 11 creates an NFT token with a custom fee, and with the admin and supply set to Alice's key
	// step 12 mints some NFTs
	// step 13 associates Alice with the NFT token
	// step 14 transfers some NFTs to Alice
	// step 15 approves an NFT allowance with operator as the owner and Alice as the spender
	// step 16 burn some NFTs

	// TODO there is currently possible bug in services causing this operation to fail, should be investigated
	// _, err = contractHelper.
	// 	ExecuteSteps( /* from step */ 0 /* to step */, 16, client)
	// if err != nil {
	// 	panic(fmt.Sprintf("%v : error executing steps", err))
	// }
}
// Filename: examples/rng_transaction/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	createResponse, err := hedera.NewPrngTransaction().
		// Set the range
		SetRange(12).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing rng transaction", err))
	}

	transactionRecord, err := createResponse.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt", err))
	}
	fmt.Printf("transactionRecord: %v\n", transactionRecord)
	if transactionRecord.PrngNumber == nil {
		panic(fmt.Sprintf("%v : error, pseudo-random number is nil", err))
	}

	println("The pseudo-random number is:", *transactionRecord.PrngNumber)
}
// Filename: examples/schedule_identical_transaction/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	pubKeys := make([]hedera.PublicKey, 3)
	clients := make([]*hedera.Client, 3)
	accounts := make([]hedera.AccountID, 3)

	fmt.Println("threshold key example")
	fmt.Println("Keys: ")

	var scheduleID *hedera.ScheduleID

	// Loop to generate keys, clients, and accounts
	for i := range pubKeys {
		newKey, err := hedera.GeneratePrivateKey()
		if err != nil {
			panic(fmt.Sprintf("%v : error generating PrivateKey", err))
		}

		fmt.Printf("Key %v:\n", i)
		fmt.Printf("private = %v\n", newKey)
		fmt.Printf("public = %v\n", newKey.PublicKey())

		pubKeys[i] = newKey.PublicKey()

		createResponse, err := hedera.NewAccountCreateTransaction().
			// The key that must sign each transfer out of the account. If receiverSigRequired is true, then
			// it must also sign any transfer into the account.
			SetKey(newKey).
			SetInitialBalance(hedera.NewHbar(1)).
			Execute(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error creating account", err))
		}

		// Make sure the transaction succeeded
		transactionReceipt, err := createResponse.GetReceipt(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error getting receipt 1", err))
		}

		newClient, err := hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
		if err != nil {
			panic(fmt.Sprintf("%v : error creating client", err))
		}
		newClient = newClient.SetOperator(*transactionReceipt.AccountID, newKey)

		clients[i] = newClient
		accounts[i] = *transactionReceipt.AccountID

		fmt.Printf("account = %v\n", accounts[i])
	}

	// A threshold key with a threshold of 2 and length of 3 requires
	// at least 2 of the 3 keys to sign anything modifying the account
	keyList := hedera.KeyListWithThreshold(2).
		AddAllPublicKeys(pubKeys)

	// We are using all of these keys, so the scheduled transaction doesn't automatically go through
	// It works perfectly fine with just one key
	createResponse, err := hedera.NewAccountCreateTransaction().
		// The key that must sign each transfer out of the account. If receiverSigRequired is true, then
		// it must also sign any transfer into the account.
		SetKey(keyList).
		SetInitialBalance(hedera.NewHbar(10)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing create account transaction", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err := createResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt 2", err))
	}
	thresholdAccount := *transactionReceipt.AccountID

	fmt.Printf("threshold account = %v\n", thresholdAccount)

	for _, client := range clients {
		operator := client.GetOperatorAccountID().String()

		// Each client creates an identical transaction, sending 1 hbar to each of the created accounts,
		// sent from the threshold Account
		tx := hedera.NewTransferTransaction()
		for _, account := range accounts {
			tx.AddHbarTransfer(account, hedera.NewHbar(1))
		}
		tx.AddHbarTransfer(thresholdAccount, hedera.NewHbar(3).Negated())

		tx, err := tx.FreezeWith(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error while freezing transaction for client ", err))
		}

		signedTransaction, err := tx.SignWithOperator(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error while signing with operator client ", operator))
		}

		scheduledTx, err := hedera.NewScheduleCreateTransaction().
			SetScheduledTransaction(signedTransaction)
		if err != nil {
			panic(fmt.Sprintf("%v : error while setting scheduled transaction with operator client", operator))
		}

		scheduledTx = scheduledTx.
			SetPayerAccountID(thresholdAccount)

		response, err := scheduledTx.Execute(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error while executing schedule create transaction with operator", operator))
		}

		receipt, err := hedera.NewTransactionReceiptQuery().
			SetTransactionID(response.TransactionID).
			SetNodeAccountIDs([]hedera.AccountID{response.NodeID}).
			Execute(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error while getting schedule create receipt transaction with operator", operator))
		}

		fmt.Printf("operator [%s]: scheduleID = %v\n", operator, receipt.ScheduleID)

		// Save the schedule ID, so that it can be asserted for each client submission
		if scheduleID == nil {
			scheduleID = receipt.ScheduleID
		}

		if scheduleID.String() != receipt.ScheduleID.String() {
			panic("invalid generated schedule id, expected " + scheduleID.String() + ", got "+ receipt.ScheduleID.String())
		}

		// If the status return by the receipt is related to already created, execute a schedule sign transaction
		if receipt.Status == hedera.StatusIdenticalScheduleAlreadyCreated {
			signTransaction, err := hedera.NewScheduleSignTransaction().
				SetNodeAccountIDs([]hedera.AccountID{createResponse.NodeID}).
				SetScheduleID(*receipt.ScheduleID).
				Execute(client)

			if err != nil {
				panic(fmt.Sprintf("%v : error while executing scheduled sign with operator", operator))
			}

			_, err = signTransaction.GetReceipt(client)
			if err != nil {
				if err.Error() != "exceptional receipt status: SCHEDULE_ALREADY_EXECUTED" {
					panic(fmt.Sprintf("%v : error while getting scheduled sign with operator ", operator))
				}
			}
		}
	}

	// Making sure the scheduled transaction executed properly with schedule info query
	info, err := hedera.NewScheduleInfoQuery().
		SetScheduleID(*scheduleID).
		SetNodeAccountIDs([]hedera.AccountID{createResponse.NodeID}).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving schedule info after signing", err))
	}

	// Checking if the scheduled transaction was executed and signed, and retrieving the signatories
	if !info.ExecutedAt.IsZero() {
		println("Signing success, signed at: ", info.ExecutedAt.String())
		println("Signatories: ", info.Signatories.String())
	}else{
		panic("Signing failed")
	}
}
// Filename: examples/schedule_multisig_transaction/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	keys := make([]hedera.PrivateKey, 3)
	pubKeys := make([]hedera.PublicKey, 3)

	fmt.Println("threshold key example")
	fmt.Println("Keys: ")

	// Loop to generate keys for the KeyList
	for i := range keys {
		newKey, err := hedera.GeneratePrivateKey()
		if err != nil {
			panic(fmt.Sprintf("%v : error generating PrivateKey}", err))
		}

		fmt.Printf("Key %v:\n", i)
		fmt.Printf("private = %v\n", newKey)
		fmt.Printf("public = %v\n", newKey.PublicKey())

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	// A threshold key with a threshold of 2 and length of 3 requires
	// at least 2 of the 3 keys to sign anything modifying the account
	keyList := hedera.NewKeyList().
		AddAllPublicKeys(pubKeys)

	// We are using all of these keys, so the scheduled transaction doesn't automatically go through
	// It works perfectly fine with just one key
	createResponse, err := hedera.NewAccountCreateTransaction().
		// The key that must sign each transfer out of the account. If receiverSigRequired is true, then
		// it must also sign any transfer into the account.
		SetKey(keyList).
		SetInitialBalance(hedera.NewHbar(10)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing create account transaction", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err := createResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt", err))
	}

	// Pre-generating transaction id for the scheduled transaction so we can track it
	transactionID := hedera.TransactionIDGenerate(client.GetOperatorAccountID())

	println("transactionId for scheduled transaction = ", transactionID.String())

	// Not really necessary as its client.GetOperatorAccountID()
	newAccountID := *transactionReceipt.AccountID

	fmt.Printf("account = %v\n", newAccountID)

	// Creating a non frozen transaction for the scheduled transaction
	// In this case its TransferTransaction
	transferTx := hedera.NewTransferTransaction().
		SetTransactionID(transactionID).
		AddHbarTransfer(newAccountID, hedera.HbarFrom(-1, hedera.HbarUnits.Hbar)).
		AddHbarTransfer(client.GetOperatorAccountID(), hedera.HbarFrom(1, hedera.HbarUnits.Hbar))

	// Scheduling it, this gives us hedera.ScheduleCreateTransaction
	scheduled, err := transferTx.Schedule()
	if err != nil {
		panic(fmt.Sprintf("%v : error scheduling Transfer Transaction", err))
	}

	// Executing the scheduled transaction
	scheduleResponse, err := scheduled.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing schedule create", err))
	}

	// Make sure it executed successfully
	scheduleReceipt, err := scheduleResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting schedule create receipt", err))
	}

	// Taking out the schedule ID
	scheduleID := *scheduleReceipt.ScheduleID

	// Using the schedule ID to get the schedule transaction info, which contains the whole scheduled transaction
	info, err := hedera.NewScheduleInfoQuery().
		SetNodeAccountIDs([]hedera.AccountID{createResponse.NodeID}).
		SetScheduleID(scheduleID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting schedule info", err))
	}

	// Taking out the TransferTransaction from earlier
	transfer, err := info.GetScheduledTransaction()
	if err != nil {
		panic(fmt.Sprintf("%v : error getting transaction from schedule info", err))
	}

	// Converting it from interface to hedera.TransferTransaction() and retrieving the amount of transfers
	// to check if we have the right one, and that it's not empty
	var transfers map[hedera.AccountID]hedera.Hbar
	switch tx := transfer.(type) {
	case *hedera.TransferTransaction:
		transfers = tx.GetHbarTransfers()
	}

	if len(transfers) != 2 {
		println("more transfers than expected")
	}

	// Checking if the Hbar values are correct
	if transfers[newAccountID].AsTinybar() != -hedera.NewHbar(1).AsTinybar() {
		println("transfer for ", newAccountID.String(), " is not whats is expected")
	}

	// Checking if the Hbar values are correct
	if transfers[client.GetOperatorAccountID()].AsTinybar() != hedera.NewHbar(1).AsTinybar() {
		println("transfer for ", client.GetOperatorAccountID().String(), " is not whats is expected")
	}

	println("sending schedule sign transaction")

	// Creating a scheduled sign transaction, we have to sign with all of the keys in the KeyList
	signTransaction, err := hedera.NewScheduleSignTransaction().
		SetNodeAccountIDs([]hedera.AccountID{createResponse.NodeID}).
		SetScheduleID(scheduleID).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing sign transaction", err))
	}

	// Signing the scheduled transaction
	signTransaction.Sign(keys[0])
	signTransaction.Sign(keys[1])
	signTransaction.Sign(keys[2])

	resp, err := signTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing schedule sign transaction", err))
	}

	// Getting the receipt to make sure the signing executed properly
	_, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing schedule sign receipt", err))
	}

	// Making sure the scheduled transaction executed properly with schedule info query
	info, err = hedera.NewScheduleInfoQuery().
		SetScheduleID(scheduleID).
		SetNodeAccountIDs([]hedera.AccountID{createResponse.NodeID}).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving schedule info after signing", err))
	}

	// Checking if the scheduled transaction was executed and signed, and retrieving the signatories
	if !info.ExecutedAt.IsZero() {
		println("Singing success, signed at: ", info.ExecutedAt.String())
		println("Signatories: ", info.Signatories.String())
	}else{
		panic("Signing failed")
	}
}
// Filename: examples/schedule_transfer_example/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	bobsKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating Bob's key", err))
	}

	bobsAccountCreate, err := hedera.NewAccountCreateTransaction().
		SetReceiverSignatureRequired(true).
		SetKey(bobsKey).
		SetInitialBalance(hedera.NewHbar(10)).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account creation", err))
	}

	bobsAccountCreate.Sign(bobsKey)

	response, err := bobsAccountCreate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating Bob's account", err))
	}

	transactionReceipt, err := response.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt", err))
	}

	if transactionReceipt.AccountID == nil {
		panic(fmt.Sprintf("%v : missing Bob's AccountID", err))
	}

	bobsID := *transactionReceipt.AccountID

	println("Alice's ID:", client.GetOperatorAccountID().String())
	println("Bob's ID:", bobsID.String())

	bobsInitialBalance, err := hedera.NewAccountBalanceQuery().
		SetAccountID(bobsID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting Bob's balance", err))
	}

	println("Bob's initial balance:", bobsInitialBalance.Hbars.String())

	transactionID := hedera.TransactionIDGenerate(bobsID)

	transferToSchedule := hedera.NewTransferTransaction().
		SetTransactionID(transactionID).
		AddHbarTransfer(client.GetOperatorAccountID(), hedera.HbarFrom(-2, hedera.HbarUnits.Hbar)).
		AddHbarTransfer(bobsID, hedera.HbarFrom(2, hedera.HbarUnits.Hbar))

	scheduleTransaction, err := transferToSchedule.Schedule()
	if err != nil {
		panic(fmt.Sprintf("%v : error setting schedule transaction", err))
	}

	frozenScheduleTransaction, err := scheduleTransaction.FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing scheduled transaction", err))
	}

	frozenScheduleTransaction.Sign(bobsKey)

	response, err = frozenScheduleTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing create scheduled transaction", err))
	}

	transactionReceipt, err = response.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting schedule create receipt", err))
	}

	if transactionReceipt.ScheduleID == nil {
		panic(fmt.Sprintf("%v : missing Bob's ScheduleID", err))
	}

	bobsBalanceAfterSchedule, err := hedera.NewAccountBalanceQuery().
		SetAccountID(bobsID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting Bob's balance", err))
	}

	println("Bob's balance after schedule:", bobsBalanceAfterSchedule.Hbars.String())

	//clean up

	deleteAccount, err := hedera.NewAccountDeleteTransaction().
		SetAccountID(bobsID).
		SetTransferAccountID(client.GetOperatorAccountID()).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error cleaning up", err))
	}

	deleteAccount.Sign(bobsKey)

	response, err = deleteAccount.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error cleaning up", err))
	}

	_, err = response.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error cleaning up", err))
	}
}
// Filename: examples/schedule_with_expiration/main.go
package main

import (
	"fmt"
	"os"
	"time"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	keys := make([]hedera.PrivateKey, 2)
	pubKeys := make([]hedera.PublicKey, 2)

	fmt.Println("Scheduled transaction example with expiration")
	fmt.Println("Keys: ")

	// Loop to generate keys for the KeyList
	for i := range keys {
		newKey, err := hedera.PrivateKeyGenerateEd25519()
		if err != nil {
			panic(fmt.Sprintf("%v : error generating PrivateKey}", err))
		}

		fmt.Printf("Key %v:\n", i)
		fmt.Printf("private = %v\n", newKey)
		fmt.Printf("public = %v\n", newKey.PublicKey())

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	// A threshold key with a threshold of 2 and length of 3 requires
	// at least 2 of the 3 keys to sign anything modifying the account
	keyList := hedera.NewKeyList().
		AddAllPublicKeys(pubKeys)

	// We are using all of these keys, so the scheduled transaction doesn't automatically go through
	// It works perfectly fine with just one key
	createResponse, err := hedera.NewAccountCreateTransaction().
		// The key that must sign each transfer out of the account. If receiverSigRequired is true, then
		// it must also sign any transfer into the account.
		SetKey(keyList).
		SetNodeAccountIDs([]hedera.AccountID{{Account: 3}}).
		SetInitialBalance(hedera.NewHbar(10)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing create account transaction", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err := createResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt", err))
	}

	// Pre-generating transaction id for the scheduled transaction so we can track it
	transactionID := hedera.TransactionIDGenerate(client.GetOperatorAccountID())

	println("TransactionID for transaction to be scheduled = ", transactionID.String())

	// Not really necessary as its client.GetOperatorAccountID()
	newAccountID := *transactionReceipt.AccountID

	fmt.Printf("account = %v\n", newAccountID)

	// Creating a non frozen transaction for the scheduled transaction
	// In this case its TransferTransaction
	transferTx := hedera.NewTransferTransaction().
		SetTransactionID(transactionID).
		AddHbarTransfer(newAccountID, hedera.HbarFrom(-1, hedera.HbarUnits.Hbar)).
		AddHbarTransfer(client.GetOperatorAccountID(), hedera.HbarFrom(1, hedera.HbarUnits.Hbar))

	// Scheduling it, this gives us hedera.ScheduleCreateTransaction
	scheduled, err := transferTx.Schedule()
	if err != nil {
		panic(fmt.Sprintf("%v : error scheduling Transfer Transaction", err))
	}

	// Executing the scheduled transaction
	scheduleResponse, err := scheduled.
		SetExpirationTime(time.Now().Add(30 * time.Minute)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing schedule create", err))
	}

	// Make sure it executed successfully
	scheduleRecord, err := scheduleResponse.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting schedule create record", err))
	}

	// Taking out the schedule ID
	scheduleID := *scheduleRecord.Receipt.ScheduleID
	scheduledTransactionID := scheduleRecord.TransactionID
	println("Scheduled TransactionID:", scheduledTransactionID.String())

	println("Signing with first key")

	// Creating a scheduled sign transaction, we have to sign with all of the keys in the KeyList
	signTransaction, err := hedera.NewScheduleSignTransaction().
		SetNodeAccountIDs([]hedera.AccountID{createResponse.NodeID}).
		SetScheduleID(scheduleID).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing sign transaction", err))
	}

	// Signing the scheduled transaction
	signTransaction.Sign(keys[0])

	resp, err := signTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing schedule sign transaction", err))
	}

	// Getting the receipt to make sure the signing executed properly
	_, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing schedule sign receipt", err))
	}

	// Making sure the scheduled transaction executed properly with schedule info query
	info, err := hedera.NewScheduleInfoQuery().
		SetScheduleID(scheduleID).
		SetNodeAccountIDs([]hedera.AccountID{createResponse.NodeID}).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving schedule info after signing", err))
	}

	println("Signers: ", info.Signatories.String())

	println("Signing with second key")

	signTransaction, err = hedera.NewScheduleSignTransaction().
		SetNodeAccountIDs([]hedera.AccountID{createResponse.NodeID}).
		SetScheduleID(scheduleID).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing sign transaction", err))
	}

	// Signing the scheduled transaction
	signTransaction.Sign(keys[1])

	resp, err = signTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing schedule sign transaction", err))
	}

	// Getting the receipt to make sure the signing executed properly
	_, err = resp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing schedule sign receipt", err))
	}

	info, err = hedera.NewScheduleInfoQuery().
		SetScheduleID(scheduleID).
		SetNodeAccountIDs([]hedera.AccountID{createResponse.NodeID}).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving schedule info after signing", err))
	}

	println("Signers: ", info.Signatories.String())

	if info.ExecutedAt != nil {
		println("Singing success, executed at: ", info.ExecutedAt.String())
	}
}
// Filename: examples/serialize-deserialize/example1/main.go
package main

import (
	"fmt"
	"github.com/hashgraph/hedera-sdk-go/v2"
	"os"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generate new key to use with new account
	newKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(err)
	}
	resp, err := hedera.NewAccountCreateTransaction().SetKey(newKey).Execute(client)
	receipt, err := resp.GetReceipt(client)
	newAccountId := *receipt.AccountID

	bytes, err := hedera.NewTransferTransaction().AddHbarTransfer(operatorAccountID, hedera.NewHbar(1)).
		ToBytes()

	if err != nil {
		panic(err)
	}

	txFromBytes, err := hedera.TransactionFromBytes(bytes)

	transaction := txFromBytes.(hedera.TransferTransaction)
	_, err = transaction.AddHbarTransfer(newAccountId, hedera.NewHbar(-1)).SignWithOperator(client)

	_, err = transaction.Execute(client)
	if err != nil {
		panic(err)
	}
	// Get the `AccountInfo` on the new account and show it is a hollow account by not having a public key
	info, err := hedera.NewAccountInfoQuery().SetAccountID(newAccountId).Execute(client)
	fmt.Println("Balance of new account: ", info.Balance)
}
// Filename: examples/serialize-deserialize/example2/main.go
package main

import (
	"fmt"
	"github.com/hashgraph/hedera-sdk-go/v2"
	"os"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generate new key to use with new account
	newKey, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(err)
	}
	resp, err := hedera.NewAccountCreateTransaction().SetKey(newKey).Execute(client)
	receipt, err := resp.GetReceipt(client)
	newAccountId := *receipt.AccountID

	// Prepare and sign the tx and send it to be signed by another actor
	fmt.Println("Creating a transfer transaction, signing it with operator and serializing it to bytes...")
	bytes, err := hedera.NewTransferTransaction().AddHbarTransfer(operatorAccountID, hedera.NewHbar(1)).AddHbarTransfer(newAccountId, hedera.NewHbar(-1)).
		Sign(operatorKey).ToBytes()

	FromBytes, err := hedera.TransactionFromBytes(bytes)
	if err != nil {
		panic(err)
	}
	txFromBytes := FromBytes.(hedera.TransferTransaction)
	// New Account add his sign and execute the tx:
	fmt.Println("Signing deserialized transaction with `newAccount` private key and executing it...")
	executed, err := txFromBytes.Sign(newKey).SetMaxTransactionFee(hedera.NewHbar(2)).Execute(client)
	if err != nil {
		panic(err)
	}
	receipt, err = executed.GetReceipt(client)
	if err != nil {
		panic(err)
	}
	fmt.Println("Tx successfully executed. Here is receipt:", receipt)
}
// Filename: examples/staking/main.go
package main

import (
	"fmt"
	"github.com/hashgraph/hedera-sdk-go/v2"
	"os"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generate new key to use with new account
	newKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	fmt.Printf("private = %v\n", newKey)
	fmt.Printf("public = %v\n", newKey.PublicKey())

	transactionResponse, err := hedera.NewAccountCreateTransaction().
		// The key that must sign each transfer out of the account.
		SetKey(newKey.PublicKey()).
		// If true, this account's key must sign any transaction depositing into this account (in
		// addition to all withdrawals)
		SetReceiverSignatureRequired(false).
		// The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
		// and up to a maximum value of 1000.
		SetMaxAutomaticTokenAssociations(1).
		// The memo associated with the account
		SetTransactionMemo("go sdk example create_account/main.go").
		// The account is charged to extend its expiration date every this many seconds. If it doesn't
		// have enough balance, it extends as long as possible. If it is empty when it expires, then it
		// is deleted.
		SetStakedAccountID(hedera.AccountID{Account: 3}).
		SetInitialBalance(hedera.NewHbar(20)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account create transaction", err))
	}

	// Get receipt to see if transaction succeeded, and has the account ID
	transactionReceipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt", err))
	}

	accountID := *transactionReceipt.AccountID

	println("AccountID of staking account:", accountID.String())

	info, err := hedera.NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account info", err))
	}

	println("Staked Node Account ID:", info.StakingInfo.StakedAccountID.String())
}
// Filename: examples/staking_with_update/main.go
package main

import (
	"fmt"
	"github.com/hashgraph/hedera-sdk-go/v2"
	"os"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generate new key to use with new account
	newKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	fmt.Printf("private = %v\n", newKey)
	fmt.Printf("public = %v\n", newKey.PublicKey())

	// Create account
	// The only required property here is `key`
	transactionResponse, err := hedera.NewAccountCreateTransaction().
		// The key that must sign each transfer out of the account.
		SetKey(newKey.PublicKey()).
		// If true, this account's key must sign any transaction depositing into this account (in
		// addition to all withdrawals)
		SetReceiverSignatureRequired(false).
		// The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
		// and up to a maximum value of 1000.
		SetMaxAutomaticTokenAssociations(1).
		// The memo associated with the account
		SetTransactionMemo("go sdk example create_account/main.go").
		// The account is charged to extend its expiration date every this many seconds. If it doesn't
		// have enough balance, it extends as long as possible. If it is empty when it expires, then it
		// is deleted.
		SetStakedAccountID(hedera.AccountID{Account: 3}).
		SetInitialBalance(hedera.NewHbar(20)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account create transaction", err))
	}

	// Get receipt to see if transaction succeeded, and has the account ID
	transactionReceipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt", err))
	}

	accountID := *transactionReceipt.AccountID

	info, err := hedera.NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account info", err))
	}

	println("Staked account id:", info.StakingInfo.StakedAccountID.String())

	freezeUpdate, err := hedera.NewAccountUpdateTransaction().
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		SetAccountID(accountID).
		// Should use ClearStakedNodeID(), but it doesn't work for now.
		SetStakedNodeID(0).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account update transaction", err))
	}

	freezeUpdate.Sign(newKey)

	transactionResponse, err = freezeUpdate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account update transaction", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt}", err))
	}

	info, err = hedera.NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account info", err))
	}

	println("Staked node id after update:", *info.StakingInfo.StakedNodeID)
}
// Filename: examples/token_airdrop/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

/**
 * @summary HIP-904 https://hips.hedera.com/hip/hip-904
 * @description Airdrop fungible and non fungible tokens to an account
 */
func main() {

	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	fmt.Println("Example Start!")

	/*
	 * Step 1:
	 * Create 4 accounts
	 */
	privateKey1, _ := hedera.PrivateKeyGenerateEd25519()
	accountCreateResp, err := hedera.NewAccountCreateTransaction().
		SetKey(privateKey1).
		SetInitialBalance(hedera.NewHbar(10)).
		SetMaxAutomaticTokenAssociations(-1).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v error creating account", err))
	}
	receipt, err := accountCreateResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v error creating account", err))
	}
	alice := receipt.AccountID

	privateKey2, _ := hedera.PrivateKeyGenerateEd25519()
	accountCreateResp, err = hedera.NewAccountCreateTransaction().
		SetKey(privateKey2).
		SetInitialBalance(hedera.NewHbar(10)).
		SetMaxAutomaticTokenAssociations(1).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v error creating account", err))
	}
	receipt, err = accountCreateResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v error creating account", err))
	}
	bob := receipt.AccountID

	privateKey3, _ := hedera.PrivateKeyGenerateEd25519()
	accountCreateResp, err = hedera.NewAccountCreateTransaction().
		SetKey(privateKey3).
		SetInitialBalance(hedera.NewHbar(10)).
		SetMaxAutomaticTokenAssociations(0).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v error creating account", err))
	}
	receipt, err = accountCreateResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v error creating account", err))
	}
	carol := receipt.AccountID

	treasuryKey, _ := hedera.PrivateKeyGenerateEd25519()
	accountCreateResp, err = hedera.NewAccountCreateTransaction().
		SetKey(treasuryKey).
		SetInitialBalance(hedera.NewHbar(10)).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v error creating account", err))
	}

	receipt, err = accountCreateResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v error creating account", err))
	}
	treasury := receipt.AccountID

	/*
	 * Step 2:
	 * Create FT and NFT and mint
	 */
	tokenCreateTxn, _ := hedera.NewTokenCreateTransaction().
		SetTokenName("Fungible Token").
		SetTokenSymbol("TFT").
		SetTokenMemo("Example memo").
		SetDecimals(3).
		SetInitialSupply(1000).
		SetMaxSupply(1000).
		SetTreasuryAccountID(*treasury).
		SetSupplyType(hedera.TokenSupplyTypeFinite).
		SetAdminKey(operatorKey).
		SetFreezeKey(operatorKey).
		SetSupplyKey(operatorKey).
		SetMetadataKey(operatorKey).
		SetPauseKey(operatorKey).
		FreezeWith(client)

	tokenCreateResp, err := tokenCreateTxn.Sign(treasuryKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v error creating token", err))
	}

	receipt, err = tokenCreateResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}
	tokenID := receipt.TokenID

	nftCreateTransaction, _ := hedera.NewTokenCreateTransaction().
		SetTokenName("Example NFT").
		SetTokenSymbol("ENFT").
		SetTokenType(hedera.TokenTypeNonFungibleUnique).
		SetDecimals(0).
		SetInitialSupply(0).
		SetMaxSupply(10).
		SetTreasuryAccountID(*treasury).
		SetSupplyType(hedera.TokenSupplyTypeFinite).
		SetAdminKey(operatorKey).
		SetFreezeKey(operatorKey).
		SetSupplyKey(operatorKey).
		FreezeWith(client)
	tokenCreateResp, err = nftCreateTransaction.Sign(treasuryKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}
	nftCreateReceipt, err := tokenCreateResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}
	nftID := *nftCreateReceipt.TokenID
	var initialMetadataList = [][]byte{{2, 1}, {1, 2}, {1, 5}}

	mintTransaction, _ := hedera.NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(initialMetadataList).
		FreezeWith(client)

	mintTransactionSubmit, err := mintTransaction.Sign(operatorKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error minting NFT", err))
	}
	receipt, err = mintTransactionSubmit.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error minting NFT", err))
	}

	/*
	 * Step 3:
	 * Airdrop fungible tokens to all 3 accounts
	 */

	airdropTx, _ := hedera.NewTokenAirdropTransaction().
		AddTokenTransfer(*tokenID, *alice, 100).
		AddTokenTransfer(*tokenID, *bob, 100).
		AddTokenTransfer(*tokenID, *carol, 100).
		AddTokenTransfer(*tokenID, *treasury, -300).
		FreezeWith(client)
	airdropResponse, err := airdropTx.Sign(treasuryKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error airdropping tokens", err))
	}
	record, err := airdropResponse.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error airdropping tokens", err))
	}

	fmt.Println("Pending airdrops length: ", len(record.PendingAirdropRecords))
	fmt.Println("Pending airdrops: ", record.PendingAirdropRecords[0].String())

	/*
	 * Step 5:
	 * Query to verify alice and bob received the airdrops and carol did not
	 */
	aliceBalance, _ := hedera.NewAccountBalanceQuery().
		SetAccountID(*alice).
		Execute(client)

	bobBalance, _ := hedera.NewAccountBalanceQuery().
		SetAccountID(*alice).
		Execute(client)
	carolBalance, _ := hedera.NewAccountBalanceQuery().
		SetAccountID(*alice).
		Execute(client)

	fmt.Println("Alice ft balance after airdrop: ", aliceBalance.Tokens.Get(*tokenID))
	fmt.Println("Bob ft balance after airdrop: ", bobBalance.Tokens.Get(*tokenID))
	fmt.Println("Carol ft balance after airdrop: ", carolBalance.Tokens.Get(*tokenID))

	/*
	 * Step 6:
	 * Claim the airdrop for carol
	 */
	fmt.Println("Claiming ft with carol")

	claimTx, _ := hedera.NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(client)

	_, err = claimTx.Sign(privateKey3).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error claiming tokens", err))
	}
	carolBalance, _ = hedera.NewAccountBalanceQuery().
		SetAccountID(*alice).
		Execute(client)
	fmt.Println("Carol ft balance after claim: ", carolBalance.Tokens.Get(*tokenID))

	/*
	 * Step 7:
	 * Airdrop the NFTs to all three accounts
	 */

	airdropTx, _ = hedera.NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(1), *treasury, *alice).
		AddNftTransfer(nftID.Nft(2), *treasury, *bob).
		AddNftTransfer(nftID.Nft(3), *treasury, *carol).
		FreezeWith(client)
	airdropResponse, err = airdropTx.Sign(treasuryKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error airdropping tokens", err))
	}
	record, err = airdropResponse.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error airdropping tokens", err))
	}

	/*
	 * Step 8:
	 * Get the transaction record and verify two pending airdrops (for bob & carol)
	 */

	fmt.Println("Pending airdrops length: ", len(record.PendingAirdropRecords))
	fmt.Println("Pending airdrops for Bob: ", record.PendingAirdropRecords[0].String())
	fmt.Println("Pending airdrops for Carol: ", record.PendingAirdropRecords[1].String())

	/*
	 * Step 9:
	 * Query to verify alice received the airdrop and bob and carol did not
	 */

	aliceBalance, _ = hedera.NewAccountBalanceQuery().
		SetAccountID(*alice).
		Execute(client)

	bobBalance, _ = hedera.NewAccountBalanceQuery().
		SetAccountID(*alice).
		Execute(client)
	carolBalance, _ = hedera.NewAccountBalanceQuery().
		SetAccountID(*alice).
		Execute(client)

	fmt.Println("Alice nft balance after airdrop: ", aliceBalance.Tokens.Get(nftID))
	fmt.Println("Bob nft balance after airdrop: ", bobBalance.Tokens.Get(nftID))
	fmt.Println("Carol nft balance after airdrop: ", carolBalance.Tokens.Get(nftID))

	/*
	 * Step 10:
	 * Claim the airdrop for bob
	 */
	fmt.Println("Claiming nft with Bob")
	claimTx, _ = hedera.NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(client)

	claimResp, err := claimTx.Sign(privateKey2).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error claiming tokens", err))
	}
	_, err = claimResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error claiming tokens", err))
	}
	bobBalance, _ = hedera.NewAccountBalanceQuery().
		SetAccountID(*bob).
		Execute(client)
	fmt.Println("Bob nft balance after claim: ", bobBalance.Tokens.Get(nftID))

	/*
	 * Step 11:
	 * Cancel the airdrop for carol
	 */
	fmt.Println("Canceling nft with Carol")
	cancelTx, _ := hedera.NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[1].GetPendingAirdropId()).
		FreezeWith(client)

	cancelResp, err := cancelTx.Sign(treasuryKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error canceling tokens", err))
	}
	_, err = cancelResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error canceling tokens", err))
	}
	carolBalance, _ = hedera.NewAccountBalanceQuery().
		SetAccountID(*carol).
		Execute(client)
	fmt.Println("Carol nft balance after cancel: ", carolBalance.Tokens.Get(nftID))

	/*
	 * Step 12:
	 * Reject the NFT for bob
	 */
	fmt.Println("Rejecting nft with Bob")

	rejectTxn, _ := hedera.NewTokenRejectTransaction().
		AddNftID(nftID.Nft(2)).
		SetOwnerID(*bob).
		FreezeWith(client)

	rejectResp, err := rejectTxn.Sign(privateKey2).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error rejecting tokens", err))
	}
	_, err = rejectResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error rejecting tokens", err))
	}

	/*
	 * Step 13:
	 * Query to verify bob no longer has the NFT
	 */
	bobBalance, _ = hedera.NewAccountBalanceQuery().
		SetAccountID(*bob).
		Execute(client)
	fmt.Println("Bob nft balance after reject: ", bobBalance.Tokens.Get(nftID))

	/*
	 * Step 13:
	 * Query to verify the NFT was returned to the Treasury
	 */
	treasuryBalance, _ := hedera.NewAccountBalanceQuery().
		SetAccountID(*treasury).
		Execute(client)
	fmt.Println("Treasury nft balance after reject: ", treasuryBalance.Tokens.Get(nftID))

	/*
	 * Step 14:
	 * Reject the fungible tokens for Carol
	 */

	rejectTxn, _ = hedera.NewTokenRejectTransaction().
		AddTokenID(*tokenID).
		SetOwnerID(*carol).
		FreezeWith(client)

	rejectResp, err = rejectTxn.Sign(privateKey3).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error rejecting tokens", err))
	}
	_, err = rejectResp.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error rejecting tokens", err))
	}

	/*
	 * Step 14:
	 * Query to verify carol no longer has the fungible tokens
	 */
	carolBalance, _ = hedera.NewAccountBalanceQuery().
		SetAccountID(*alice).
		Execute(client)
	fmt.Println("Carol ft balance after claim: ", carolBalance.Tokens.Get(*tokenID))

	/*
	 * Step 15:
	 * Query to verify Treasury received the rejected fungible tokens
	 */
	treasuryBalance, _ = hedera.NewAccountBalanceQuery().
		SetAccountID(*treasury).
		Execute(client)
	fmt.Println("Treasury ft balance after reject: ", treasuryBalance.Tokens.Get(*tokenID))

	/*
	 * Clean up:
	 */
	client.Close()

	fmt.Println("Example Complete!")

}
// Filename: examples/token_reject/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// create treasury account
	treasuryKey, _ := hedera.PrivateKeyGenerateEd25519()
	accountCreate, _ := hedera.NewAccountCreateTransaction().
		SetKey(treasuryKey).
		SetMaxAutomaticTokenAssociations(100).
		Execute(client)
	receipt, err := accountCreate.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error creating account", err))
	}

	treasury := *receipt.AccountID

	// create receiver account with unlimited auto associations
	receiverKey, _ := hedera.PrivateKeyGenerateEd25519()
	accountCreate, _ = hedera.NewAccountCreateTransaction().
		SetKey(receiverKey).
		SetMaxAutomaticTokenAssociations(-1).
		Execute(client)
	receipt, err = accountCreate.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error creating account", err))
	}

	receiver := *receipt.AccountID

	// create fungible token
	frozenTokenCreate, _ := hedera.NewTokenCreateTransaction().
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetTokenMemo("asdf").
		SetDecimals(18).
		SetInitialSupply(1_000_000).
		SetTreasuryAccountID(treasury).
		SetAdminKey(client.GetOperatorPublicKey()).FreezeWith(client)
	tokenCreate, _ := frozenTokenCreate.Sign(treasuryKey).Execute(client)
	receipt, err = tokenCreate.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error creating token", err))
	}

	tokenID := *receipt.TokenID

	// create NFT
	frozenTokenCreate, _ = hedera.NewTokenCreateTransaction().
		SetTokenName("Example Collection").SetTokenSymbol("ABC").
		SetTokenType(hedera.TokenTypeNonFungibleUnique).
		SetDecimals(0).
		SetInitialSupply(0).
		SetMaxSupply(10).
		SetTreasuryAccountID(treasury).
		SetSupplyType(hedera.TokenSupplyTypeFinite).
		SetSupplyKey(treasuryKey).
		SetAdminKey(treasuryKey).FreezeWith(client)
	tokenCreate, _ = frozenTokenCreate.Sign(treasuryKey).Execute(client)
	receipt, err = tokenCreate.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error creating token", err))
	}

	nftID := *receipt.TokenID

	// mint 3 NFTs
	initialMetadataList := [][]byte{{1}, {2}, {3}}
	frozenMint, _ := hedera.NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(initialMetadataList).FreezeWith(client)
	mint, _ := frozenMint.Sign(treasuryKey).Execute(client)
	receipt, err = mint.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error minting nfts", err))
	}

	serials := receipt.SerialNumbers

	// transfer the tokens to the receiver account
	frozenTransfer, _ := hedera.NewTransferTransaction().
		AddNftTransfer(nftID.Nft(serials[0]), treasury, receiver).
		AddNftTransfer(nftID.Nft(serials[1]), treasury, receiver).
		AddNftTransfer(nftID.Nft(serials[2]), treasury, receiver).
		AddTokenTransfer(tokenID, treasury, -1000000).
		AddTokenTransfer(tokenID, receiver, 1000000).
		FreezeWith(client)
	tokenTransfer, _ := frozenTransfer.Sign(treasuryKey).Execute(client)
	receipt, err = tokenTransfer.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error transferring tokens", err))
	}

	tokenBalance, err := hedera.NewAccountBalanceQuery().SetAccountID(receiver).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error getting balance", err))
	}

	fmt.Println("Fungible token balance for receiver account before reject: ", tokenBalance.Tokens.Get(tokenID))
	fmt.Println("NFT balance for receiver account before reject: ", tokenBalance.Tokens.Get(nftID))

	tokenBalance, err = hedera.NewAccountBalanceQuery().SetAccountID(treasury).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error getting balance", err))
	}
	fmt.Println("Fungible token balance for treasury account before reject: ", tokenBalance.Tokens.Get(tokenID))
	fmt.Println("NFT balance for receiver treasury before reject: ", tokenBalance.Tokens.Get(nftID))
	fmt.Println("-----------------------------------")

	// reject the fungible tokens
	frozenReject, _ := hedera.NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetTokenIDs(tokenID).
		FreezeWith(client)
	reject, _ := frozenReject.Sign(receiverKey).Execute(client)
	receipt, err = reject.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error rejecting tokens", err))
	}

	// reject the NFTs
	frozenRejectFlow, _ := hedera.NewTokenRejectFlow().
		SetOwnerID(receiver).
		SetNftIDs(nftID.Nft(serials[0]), nftID.Nft(serials[1]), nftID.Nft(serials[2])).
		FreezeWith(client)
	reject, _ = frozenRejectFlow.Sign(receiverKey).Execute(client)
	receipt, err = reject.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error rejecting tokens", err))
	}

	tokenBalance, err = hedera.NewAccountBalanceQuery().SetAccountID(receiver).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error getting balance", err))
	}

	fmt.Println("Fungible token balance for receiver account after reject: ", tokenBalance.Tokens.Get(tokenID))
	fmt.Println("NFT balance for receiver account after reject: ", tokenBalance.Tokens.Get(nftID))

	tokenBalance, err = hedera.NewAccountBalanceQuery().SetAccountID(treasury).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : Error getting balance", err))
	}
	fmt.Println("Fungible token balance for treasury account after reject: ", tokenBalance.Tokens.Get(tokenID))
	fmt.Println("NFT balance for receiver treasury after reject: ", tokenBalance.Tokens.Get(nftID))
}
// Filename: examples/token_update_keys/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

/**
 * @summary HIP-540 https://hips.hedera.com/hip/hip-540
 * @description Change or remove existing keys from a token
 */
func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Create admin key
	adminKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error creating admin key", err))
	}
	fmt.Println("create wipe key: ", adminKey.String())

	// Create supply key
	supplyKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error creating supply key", err))
	}
	fmt.Println("create supply key: ", supplyKey.String())

	// Create wipe key
	wipeKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error creating supply key", err))
	}
	fmt.Println("create wipe key: ", supplyKey.String())

	// Create the token
	tx, err := hedera.NewTokenCreateTransaction().
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetDecimals(3).
		SetTokenType(hedera.TokenTypeFungibleCommon).
		SetInitialSupply(1000000).
		SetTreasuryAccountID(client.GetOperatorAccountID()).
		SetFreezeDefault(false).
		SetSupplyKey(supplyKey).
		SetWipeKey(wipeKey).
		SetAdminKey(adminKey).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}
	resp, err := tx.Sign(adminKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}

	receipt, err := resp.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}
	tokenID := receipt.TokenID
	fmt.Println("created token: ", tokenID)

	// Query the token info after creation
	info, err := hedera.NewTokenInfoQuery().
		SetTokenID(*receipt.TokenID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}
	fmt.Println("token's supply key after creation: ", info.SupplyKey)
	fmt.Println("token's wipe key after creation: ", info.WipeKey)
	fmt.Println("token's admin key after creation: ", info.AdminKey)

	removeWipeKeyFullValidation(client, *receipt.TokenID, adminKey)
	newSupplyKey := updateSupplyKeyFullValidation(client, *receipt.TokenID, supplyKey)
	removeSupplyKeyNoValidation(client, *receipt.TokenID, newSupplyKey)
	removeAdminKeyNoValidation(client, *receipt.TokenID, adminKey)
}

// With "full" verification mode, our required key
// structure is a 1/2 threshold with components:
//   - Admin key
//   - A 2/2 list including the role key and its replacement key
func removeWipeKeyFullValidation(client *hedera.Client, tokenID hedera.TokenID, adminKey hedera.PrivateKey) {
	// Remove wipe key by setting it to a empty key list
	tx, err := hedera.NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetWipeKey(hedera.NewKeyList()).
		SetKeyVerificationMode(hedera.FULL_VALIDATION).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}
	resp, err := tx.Sign(adminKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}
	_, err = resp.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}

	// Query the token info to get the wipe key after removal
	info, err := hedera.NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}
	fmt.Println("token's wipe key after removal: ", info.WipeKey)
}

func updateSupplyKeyFullValidation(client *hedera.Client, tokenID hedera.TokenID, oldSupplyKey hedera.PrivateKey) hedera.PrivateKey {
	newSupplyKey, _ := hedera.GeneratePrivateKey()

	// Update  supply key by setting it to a new key
	tx, err := hedera.NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetSupplyKey(newSupplyKey.PublicKey()).
		SetKeyVerificationMode(hedera.FULL_VALIDATION).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}

	// Sign with old and new supply keys
	_, err = newSupplyKey.SignTransaction(&tx.Transaction)
	if err != nil {
		panic(fmt.Sprintf("%v : error signing tx", err))
	}
	_, err = oldSupplyKey.SignTransaction(&tx.Transaction)
	if err != nil {
		panic(fmt.Sprintf("%v : error signing tx", err))
	}

	resp, err := tx.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}
	_, err = resp.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}

	// Query the token info to get the supply key after update
	info, err := hedera.NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}
	fmt.Println("token's supply key after update: ", info.SupplyKey)

	return newSupplyKey
}

func removeSupplyKeyNoValidation(client *hedera.Client, tokenID hedera.TokenID, oldSupplyKey hedera.PrivateKey) {
	zeroNewKey, _ := hedera.ZeroKey()

	// Remove supply key by setting it to a zero key
	tx, err := hedera.NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetSupplyKey(zeroNewKey).
		SetKeyVerificationMode(hedera.NO_VALIDATION).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}

	// Sign with old supply key
	resp, err := tx.Sign(oldSupplyKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}
	_, err = resp.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}

	// Query the token info to get the supply key after removal
	info, err := hedera.NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}

	newSupplyKey := info.SupplyKey.(hedera.PublicKey)
	fmt.Println("token's supply key after zero out: ", newSupplyKey.StringRaw())
}

func removeAdminKeyNoValidation(client *hedera.Client, tokenID hedera.TokenID, oldAdminKey hedera.PrivateKey) {
	// Remove admin key by setting it to a zero key
	tx, err := hedera.NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetAdminKey(hedera.NewKeyList()).
		SetKeyVerificationMode(hedera.NO_VALIDATION).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}

	// Sign with old supply key
	resp, err := tx.Sign(oldAdminKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}
	_, err = resp.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}

	// Query the token info to get the admin key after removal
	info, err := hedera.NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}

	fmt.Println("token's admin key after removal: ", info.AdminKey)
}
// Filename: examples/token_update_metadata/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}
	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}
	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}
	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	updateMutableTokenMetadata(client)

	updateImmutableTokenMetadata(client)
}

func updateMutableTokenMetadata(client *hedera.Client) {
	// Create admin key
	adminKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error creating admin key", err))
	}
	fmt.Println("create admin key: ", adminKey.String())

	var initialMetadata = []byte{1, 2, 3}
	var newMetadata = []byte{3, 4, 5, 6}

	// Create the token
	tx, err := hedera.NewTokenCreateTransaction().
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetDecimals(3).
		SetTokenType(hedera.TokenTypeFungibleCommon). // The same flow can be executed with a TokenTypeNonFungibleUnique (i.e. HIP-765)
		SetTokenMetadata(initialMetadata).
		SetInitialSupply(1000000).
		SetTreasuryAccountID(client.GetOperatorAccountID()).
		SetAdminKey(adminKey).
		SetFreezeDefault(false).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}
	resp, err := tx.Sign(adminKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}

	receipt, err := resp.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}
	fmt.Println("created token: ", receipt.TokenID.String())

	// Query the token info to get the metadata after creation
	info, err := hedera.NewTokenInfoQuery().
		SetTokenID(*receipt.TokenID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}
	fmt.Println("token's metadata after creation: ", info.Metadata)

	// Update the token's metadata
	tx1, err := hedera.NewTokenUpdateTransaction().
		SetTokenID(*receipt.TokenID).
		SetTokenMetadata(newMetadata).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}
	resp, err = tx1.Sign(adminKey).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}
	_, err = resp.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}

	// Query the token info to get the metadata after update
	info, err = hedera.NewTokenInfoQuery().
		SetTokenID(*receipt.TokenID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}
	fmt.Println("token's metadata after update: ", info.Metadata)
}

func updateImmutableTokenMetadata(client *hedera.Client) {
	// Create metadata key
	metadataKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error creating admin key", err))
	}
	fmt.Println("create metadata key: ", metadataKey.String())

	var initialMetadata = []byte{1, 2, 3}
	var newMetadata = []byte{3, 4, 5, 6}

	// Create the token
	resp, err := hedera.NewTokenCreateTransaction().
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetDecimals(3).
		SetTokenType(hedera.TokenTypeFungibleCommon). // The same flow can be executed with a TokenTypeNonFungibleUnique (i.e. HIP-765)
		SetTokenMetadata(initialMetadata).
		SetInitialSupply(1000000).
		SetTreasuryAccountID(client.GetOperatorAccountID()).
		SetMetadataKey(metadataKey).
		SetFreezeDefault(false).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}

	receipt, err := resp.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}
	fmt.Println("created token: ", receipt.TokenID.String())

	// Query the token info to get the metadata after creation
	info, err := hedera.NewTokenInfoQuery().
		SetTokenID(*receipt.TokenID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}
	fmt.Println("token's metadata after creation: ", info.Metadata)

	// Update the token's metadata
	tx, err := hedera.NewTokenUpdateTransaction().
		SetTokenID(*receipt.TokenID).
		SetTokenMetadata(newMetadata).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}
	resp, err = tx.Sign(metadataKey).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}
	_, err = resp.SetValidateStatus(true).GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating token", err))
	}

	// Query the token info to get the metadata after update
	info, err = hedera.NewTokenInfoQuery().
		SetTokenID(*receipt.TokenID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}
	fmt.Println("token's metadata after update: ", info.Metadata)
}
// Filename: examples/token_update_nfts/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

/**
 * @summary E2E-HIP-657 https://hips.hedera.com/hip/hip-657
 * @description Update nfts metadata of non-fungible token with metadata key
 */
func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	metadataKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(fmt.Sprintf("%v : error creating metadata key", err))
	}
	fmt.Println("create metadata key: ", metadataKey.String())

	var initialMetadataList = [][]byte{{2, 1}, {1, 2}}
	var updatedMetadata = []byte{22, 22}

	// Create token with metadata key
	nftCreateTransaction, err := hedera.NewTokenCreateTransaction().
		SetTokenName("HIP-542 Example Collection").SetTokenSymbol("HIP-542").
		SetTokenType(hedera.TokenTypeNonFungibleUnique).SetDecimals(0).
		SetInitialSupply(0).SetMaxSupply(10).
		SetTreasuryAccountID(client.GetOperatorAccountID()).SetSupplyType(hedera.TokenSupplyTypeFinite).
		SetAdminKey(operatorKey).SetFreezeKey(operatorKey).SetSupplyKey(operatorKey).SetMetadataKey(metadataKey).FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token transaction", err))
	}

	// Sign the transaction with the operator key
	nftSignTransaction := nftCreateTransaction.Sign(operatorKey)

	// Submit the transaction to the Hedera network
	nftCreateSubmit, err := nftSignTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error submitting transaction", err))
	}

	// Get transaction receipt information
	nftCreateReceipt, err := nftCreateSubmit.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error receiving receipt", err))
	}

	// Get token id from the transaction
	nftTokenID := *nftCreateReceipt.TokenID
	fmt.Println("Created NFT with token id: ", nftTokenID)

	tokenInfo, err := hedera.NewTokenInfoQuery().SetTokenID(nftTokenID).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting token info", err))
	}
	fmt.Println("Token metadata key: ", tokenInfo.MetadataKey.String())

	// Mint nfts
	mintTransaction, _ := hedera.NewTokenMintTransaction().SetTokenID(nftTokenID).SetMetadatas(initialMetadataList).FreezeWith(client)
	for _, v := range mintTransaction.GetMetadatas() {
		fmt.Println("Set metadata: ", v)
	}

	mintTransactionSubmit, err := mintTransaction.Sign(operatorKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error minting NFT", err))
	}
	receipt, err := mintTransactionSubmit.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error minting NFT", err))
	}

	// Check that metadata was set correctly
	serials := receipt.SerialNumbers
	fmt.Println(serials)
	var metadataAfterMint = make([][]byte, len(initialMetadataList))
	for i, v := range serials {
		nftID := hedera.NftID{TokenID: nftTokenID, SerialNumber: v}
		nftInfo, err := hedera.NewTokenNftInfoQuery().SetNftID(nftID).Execute(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error getting token info", err))
		}
		fmt.Println(nftInfo)
		metadataAfterMint[i] = nftInfo[0].Metadata
	}
	fmt.Println("Metadata after mint: ", metadataAfterMint)

	// Create account owner of nft
	accountCreateTransaction, err := hedera.NewAccountCreateTransaction().
		SetKey(operatorKey).SetMaxAutomaticTokenAssociations(10). // If the account does not have any automatic token association slots open ONLY then associate the NFT to the account
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating account", err))
	}
	receipt, err = accountCreateTransaction.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error receiving receipt", err))
	}
	newAccountId := receipt.AccountID

	// Transfer the NFT to the new account
	tokenTransferTransaction, err := hedera.NewTransferTransaction().AddNftTransfer(nftTokenID.Nft(serials[0]), operatorAccountID, *newAccountId).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error transfering nft", err))
	}
	_, err = tokenTransferTransaction.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error getting receipt", err))
	}

	// update nfts metadata
	metadataUpdateTransaction, err := hedera.NewTokenUpdateNftsTransaction().
		SetTokenID(nftTokenID).
		SetSerialNumbers(serials).
		SetMetadata(updatedMetadata).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating transaction", err))
	}
	fmt.Println("Updatad metadata: ", metadataUpdateTransaction.GetMetadata())
	metadataUpdateSubmit, err := metadataUpdateTransaction.Sign(metadataKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error submitting transaction", err))
	}

	receipt, err = metadataUpdateSubmit.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error receiving receipt", err))
	}
	fmt.Println("Metadata update status: ", receipt.Status)

	// Check that metadata for the NFT was updated correctly
	for _, v := range serials {
		nftID := hedera.NftID{TokenID: nftTokenID, SerialNumber: v}
		nftInfo, err := hedera.NewTokenNftInfoQuery().SetNftID(nftID).Execute(client)
		if err != nil {
			panic(fmt.Sprintf("%v : error getting token info", err))
		}
		fmt.Println("Metadata after update for serial number ", v, ": ", nftInfo[0].Metadata)
	}
}
// Filename: examples/topic_with_admin_key/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	initialAdminKeys := make([]hedera.PrivateKey, 3)

	// Generating the keys for the KeyList
	for i := range initialAdminKeys {
		key, err := hedera.GeneratePrivateKey()
		if err != nil {
			panic(fmt.Sprintf("%v : error generating PrivateKey", err))
		}
		initialAdminKeys[i] = key
	}

	// Creating KeyList with a threshold 2
	keyList := hedera.KeyListWithThreshold(2)
	for _, key := range initialAdminKeys {
		keyList.Add(key.PublicKey())
	}

	topicTx, err := hedera.NewTopicCreateTransaction().
		SetTopicMemo("demo topic").
		// Access control for UpdateTopicTransaction/DeleteTopicTransaction.
		// Anyone can increase the topic's expirationTime via UpdateTopicTransaction, regardless of the adminKey.
		// If no adminKey is specified, UpdateTopicTransaction may only be used to extend the topic's expirationTime,
		// and DeleteTopicTransaction is disallowed.
		SetAdminKey(keyList).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing topic create transaction", err))
	}

	// Signing ConsensusTopicCreateTransaction with initialAdminKeys
	for i := 0; i < 2; i++ {
		println("Signing ConsensusTopicCreateTransaction with key ", initialAdminKeys[i].String())
		topicTx.Sign(initialAdminKeys[i])
	}

	// Executing ConsensusTopicCreateTransaction
	response, err := topicTx.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating topic", err))
	}

	// Make sure it executed properly
	receipt, err := response.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving topic creation receipt", err))
	}

	// Get the topic ID out of the receipt
	topicID := *receipt.TopicID

	println("Created new topic ", topicID.String(), " with 2-of-3 threshold key as adminKey.")

	newAdminKeys := make([]hedera.PrivateKey, 4)

	// Generating the keys
	for i := range newAdminKeys {
		key, err := hedera.GeneratePrivateKey()
		if err != nil {
			panic(fmt.Sprintf("%v : error generating PrivateKey", err))
		}
		newAdminKeys[i] = key
	}

	// Creating KeyList with a threshold 3
	keyList = hedera.KeyListWithThreshold(3)
	for _, key := range newAdminKeys {
		keyList.Add(key.PublicKey())
	}

	topicUpdate, err := hedera.NewTopicUpdateTransaction().
		SetTopicID(topicID).
		SetTopicMemo("updated topic demo").
		// Updating with new KeyList here
		SetAdminKey(keyList).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing topic update transaction", err))
	}

	// Have to sign with the initial admin keys first
	for i := 0; i < 2; i++ {
		println("Signing ConsensusTopicCreateTransaction with initial admin key ", initialAdminKeys[i].String())
		topicUpdate.Sign(initialAdminKeys[i])
	}

	// Then the new ones we updated the topic with
	for i := 0; i < 3; i++ {
		println("Signing ConsensusTopicCreateTransaction with new admin key ", newAdminKeys[i].String())
		topicUpdate.Sign(newAdminKeys[i])
	}

	// Now to execute the topic update transaction
	response, err = topicUpdate.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating topic", err))
	}

	// Make sure the transaction ran properly
	receipt, err = response.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving topic update receipt", err))
	}

	println("Updated topic ", topicID.String(), " with 3-of-4 threshold key as adminKey")

	// Make sure everything worked by checking the topic memo
	topicInfo, err := hedera.NewTopicInfoQuery().
		SetTopicID(topicID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing topic info query", err))
	}

	// Should be "updated topic demo"
	println(topicInfo.TopicMemo)
}
// Filename: examples/transfer_crypto/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	fmt.Println("Crypto Transfer Example")

	fmt.Printf("Transferring 1 hbar from %v to 0.0.3\n", client.GetOperatorAccountID())

	transactionResponse, err := hedera.NewTransferTransaction().
		// Hbar has to be negated to denote we are taking out from that account
		AddHbarTransfer(client.GetOperatorAccountID(), hedera.NewHbar(-1)).
		// If the amount of these 2 transfers is not the same, the transaction will throw an error
		AddHbarTransfer(hedera.AccountID{Account: 3}, hedera.NewHbar(1)).
		SetTransactionMemo("go sdk example send_hbar/main.go").
		Execute(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error executing transfer", err))
	}

	// Retrieve the receipt to make sure the transaction went through
	transactionReceipt, err := transactionResponse.GetReceipt(client)

	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transfer receipt", err))
	}

	fmt.Printf("crypto transfer status: %v\n", transactionReceipt.Status)
}
// Filename: examples/transfer_tokens/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	key1, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}
	key2, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	fmt.Printf("privateKey = %v\n", key1.String())
	fmt.Printf("publicKey = %v\n", key1.PublicKey().String())
	fmt.Printf("privateKey = %v\n", key2.String())
	fmt.Printf("publicKey = %v\n", key2.PublicKey().String())

	// Creating 2 accounts for transferring tokens
	transactionResponse, err := hedera.NewAccountCreateTransaction().
		// The key that must sign each transfer out of the account. If receiverSigRequired is true, then
		// it must also sign any transfer into the account.
		SetKey(key1.PublicKey()).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating account", err))
	}

	// First receipt with account ID 1, will error if transaction failed
	transactionReceipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account creation receipt", err))
	}

	// Retrieving account ID out of the first receipt
	accountID1 := *transactionReceipt.AccountID

	fmt.Printf("account = %v\n", accountID1.String())

	// Creating a new account for the token
	transactionResponse, err = hedera.NewAccountCreateTransaction().
		// The key that must sign each transfer out of the account. If receiverSigRequired is true, then
		// it must also sign any transfer into the account.
		SetKey(key2.PublicKey()).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating second account", err))
	}

	// Second receipt with account ID 2, will error if transaction failed
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving second account creation receipt", err))
	}

	// Retrieving account ID out of the second receipt
	accountID2 := *transactionReceipt.AccountID

	fmt.Printf("account = %v\n", accountID2.String())

	// Creating a new token
	transactionResponse, err = hedera.NewTokenCreateTransaction().
		// The publicly visible name of the token
		SetTokenName("ffff").
		// The publicly visible token symbol
		SetTokenSymbol("F").
		SetMaxTransactionFee(hedera.NewHbar(1000)).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// For tokens of type FUNGIBLE_COMMON - the number of decimal places a
		// token is divisible by. For tokens of type NON_FUNGIBLE_UNIQUE - value
		// must be 0
		SetDecimals(3).
		// Specifies the initial supply of tokens to be put in circulation. The
		// initial supply is sent to the Treasury Account. The supply is in the
		// lowest denomination possible. In the case for NON_FUNGIBLE_UNIQUE Type
		// the value must be 0
		SetInitialSupply(1000000).
		// The account which will act as a treasury for the token. This account
		// will receive the specified initial supply or the newly minted NFTs in
		// the case for NON_FUNGIBLE_UNIQUE Type
		SetTreasuryAccountID(client.GetOperatorAccountID()).
		// The key which can perform update/delete operations on the token. If empty, the token can be
		// perceived as immutable (not being able to be updated/deleted)
		SetAdminKey(client.GetOperatorPublicKey()).
		// The key which can sign to freeze or unfreeze an account for token transactions. If empty,
		// freezing is not possible
		SetFreezeKey(client.GetOperatorPublicKey()).
		// The key which can wipe the token balance of an account. If empty, wipe is not possible
		SetWipeKey(client.GetOperatorPublicKey()).
		// The key which can grant or revoke KYC of an account for the token's transactions. If empty,
		// KYC is not required, and KYC grant or revoke operations are not possible.
		SetKycKey(client.GetOperatorPublicKey()).
		// The key which can change the supply of a token. The key is used to sign Token Mint/Burn
		// operations
		SetSupplyKey(client.GetOperatorPublicKey()).
		// The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If
		// true, an account must be unfrozen before it can receive the token
		SetFreezeDefault(false).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}

	// Make sure the token create transaction ran
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving token creation receipt", err))
	}

	// Retrieve the token out of the receipt
	tokenID := *transactionReceipt.TokenID

	fmt.Printf("token = %v\n", tokenID.String())

	// Associating the token with the first account, so it can interact with the token
	transaction, err := hedera.NewTokenAssociateTransaction().
		// The account ID to be associated
		SetAccountID(accountID1).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// The token ID that the account will be associated to
		SetTokenIDs(tokenID).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing token associate transaction", err))
	}

	// Has to be signed by the account1's key
	transactionResponse, err = transaction.
		Sign(key1).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error associating token", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving token associate transaction receipt", err))
	}

	fmt.Printf("Associated account %v with token %v\n", accountID1.String(), tokenID.String())

	// Associating the token with the first account, so it can interact with the token
	transaction, err = hedera.NewTokenAssociateTransaction().
		// The account ID to be associated
		SetAccountID(accountID2).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// The token ID that the account will be associated to
		SetTokenIDs(tokenID).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing token associate transaction", err))
	}

	// Has to be signed by the account1's key
	transactionResponse, err = transaction.
		Sign(key2).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error associating token", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving token associate transaction receipt", err))
	}

	fmt.Printf("Associated account %v with token %v\n", accountID2.String(), tokenID.String())

	// This transaction grants Kyc to the first account
	// Must be signed by the Token's kycKey.
	transactionResponse, err = hedera.NewTokenGrantKycTransaction().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// The account that KYC is being granted to
		SetAccountID(accountID1).
		// As the token kyc key is client.GetOperatorPublicKey(), we don't have to explicitly sign with anything
		// as it's done automatically by execute for the operator
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error granting kyc", err))
	}

	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving grant kyc transaction receipt", err))
	}

	fmt.Printf("Granted KYC for account %v on token %v\n", accountID1.String(), tokenID.String())

	// This transaction grants Kyc to the second account
	transactionResponse, err = hedera.NewTokenGrantKycTransaction().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// The account that KYC is being granted to
		SetAccountID(accountID2).
		// As the token kyc key is client.GetOperatorPublicKey(), we don't have to explicitly sign with anything
		// as it's done automatically by execute for the operator
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error granting kyc to second account", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving grant kyc transaction receipt", err))
	}

	fmt.Printf("Granted KYC for account %v on token %v\n", accountID2.String(), tokenID.String())

	transactionResponse, err = hedera.NewTransferTransaction().
		// Same as for Hbar transfer, token value has to be negated to denote they are being taken out
		AddTokenTransfer(tokenID, client.GetOperatorAccountID(), -10).
		// Same as for Hbar transfer, the 2 transfers here have to be equal, otherwise it will lead to an error
		AddTokenTransfer(tokenID, accountID1, 10).
		// We don't have to sign this one as we are transferring tokens from the operator
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error transferring from operator to account1", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transfer from operator to account1 receipt", err))
	}

	fmt.Printf(
		"Sent 10 tokens from account %v to account %v on token %v\n",
		client.GetOperatorAccountID().String(),
		accountID1.String(),
		tokenID.String(),
	)

	transferTransaction, err := hedera.NewTransferTransaction().
		// 10 tokens from account 1
		AddTokenTransfer(tokenID, accountID1, -10).
		// 10 token to account 2
		AddTokenTransfer(tokenID, accountID2, 10).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing transfer from account1 to account2", err))
	}

	// As we are now transferring tokens from accountID1 to accountID2, this has to be signed by accountID1's key
	transferTransaction = transferTransaction.Sign(key1)

	// Execute the transfer transaction
	transactionResponse, err = transferTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error transferring from account1 to account2", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transfer from account1 to account2 receipt", err))
	}

	fmt.Printf(
		"Sent 10 tokens from account %v to account %v on token %v\n",
		accountID1.String(),
		accountID2.String(),
		tokenID.String(),
	)

	transferTransaction, err = hedera.NewTransferTransaction().
		// 10 tokens from account 2
		AddTokenTransfer(tokenID, accountID2, -10).
		// 10 token to account 1
		AddTokenTransfer(tokenID, accountID1, 10).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing transfer from account2 to account1", err))
	}

	// As we are now transferring tokens from accountID2 back to accountID1, this has to be signed by accountID2's key
	transferTransaction = transferTransaction.Sign(key2)

	// Executing the transfer transaction
	transactionResponse, err = transferTransaction.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error transferring from account2 to account1", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transfer from account2 to account1 receipt", err))
	}

	fmt.Printf(
		"Sent 10 tokens from account %v to account %v on token %v\n",
		accountID2.String(),
		accountID1.String(),
		tokenID.String(),
	)

	// Clean up

	// Now we can wipe the 10 tokens that are in possession of accountID1
	// Has to be signed by wipe key of the token, in this case it was the operator key
	transactionResponse, err = hedera.NewTokenWipeTransaction().
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// From which account
		SetAccountID(accountID1).
		// For which token
		SetTokenID(tokenID).
		// How many
		SetAmount(10).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error wiping from token", err))
	}

	// Make sure the transaction succeeded
	_, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving token wipe transaction receipt", err))
	}

	fmt.Printf("Wiped account %v on token %v\n", accountID1.String(), tokenID.String())

	// Now to delete the token
	// Has to be signed by admin key of the token, in this case it was the operator key
	transactionResponse, err = hedera.NewTokenDeleteTransaction().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error deleting token", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving token delete transaction receipt", err))
	}

	fmt.Printf("DeletedAt token %v\n", tokenID.String())

	// Now that the tokens have been wiped from accountID1, we can safely delete it
	accountDeleteTx, err := hedera.NewAccountDeleteTransaction().
		SetAccountID(accountID1).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// Tp which account to transfer the account 1 balance
		SetTransferAccountID(client.GetOperatorAccountID()).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account delete transaction", err))
	}

	// Account deletion has to always be signed by the key for the account
	transactionResponse, err = accountDeleteTx.
		Sign(key1).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error deleting account 1", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transfer transaction receipt", err))
	}

	fmt.Printf("DeletedAt account %v\n", accountID1.String())

	accountDeleteTx, err = hedera.NewAccountDeleteTransaction().
		SetAccountID(accountID2).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// Tp which account to transfer the account 2 balance
		SetTransferAccountID(client.GetOperatorAccountID()).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account delete transaction", err))
	}

	// Account deletion has to always be signed by the key for the account
	transactionResponse, err = accountDeleteTx.
		Sign(key2).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error deleting account2", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account delete transaction receipt", err))
	}

	fmt.Printf("DeletedAt account %v\n", accountID2.String())
}
// Filename: examples/update_account_public_key/main.go
package main

import (
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

func main() {
	var client *hedera.Client
	var err error

	// Retrieving network type from environment variable HEDERA_NETWORK
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	// Retrieving operator ID from environment variable OPERATOR_ID
	operatorAccountID, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to AccountID", err))
	}

	// Retrieving operator key from environment variable OPERATOR_KEY
	operatorKey, err := hedera.PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(fmt.Sprintf("%v : error converting string to PrivateKey", err))
	}

	// Setting the client operator ID and key
	client.SetOperator(operatorAccountID, operatorKey)

	// Generating key for the new account
	key1, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	// Generating the key to update to
	key2, err := hedera.GeneratePrivateKey()
	if err != nil {
		panic(fmt.Sprintf("%v : error generating PrivateKey", err))
	}

	// Creating new account
	accountTxResponse, err := hedera.NewAccountCreateTransaction().
		// The key that must sign each transfer out of the account. If receiverSigRequired is true, then
		// it must also sign any transfer into the account.
		// Using the public key for this, but a PrivateKey or a KeyList can also be used
		SetKey(key1.PublicKey()).
		SetInitialBalance(hedera.ZeroHbar).
		SetTransactionID(hedera.TransactionIDGenerate(client.GetOperatorAccountID())).
		SetTransactionMemo("sdk example create_account__with_manual_signing/main.go").
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating account", err))
	}

	println("transaction ID:", accountTxResponse.TransactionID.String())

	// Get the receipt making sure transaction worked
	accountTxReceipt, err := accountTxResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving account creation receipt", err))
	}

	// Retrieve the account ID out of the Receipt
	accountID := *accountTxReceipt.AccountID
	println("account =", accountID.String())
	println("key =", key1.PublicKey().String())
	println(":: update public key of account", accountID.String())
	println("set key =", key2.PublicKey().String())

	// Updating the account with the new key
	accountUpdateTx, err := hedera.NewAccountUpdateTransaction().
		SetAccountID(accountID).
		// The new key
		SetKey(key2.PublicKey()).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing account update transaction", err))
	}

	// Have to sign with both keys, the initial key first
	accountUpdateTx.Sign(key1)
	accountUpdateTx.Sign(key2)

	// Executing the account update transaction
	accountUpdateTxResponse, err := accountUpdateTx.Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating account", err))
	}

	println("transaction ID:", accountUpdateTxResponse.TransactionID.String())

	// Make sure the transaction went through
	_, err = accountUpdateTxResponse.GetReceipt(client)

	println(":: getAccount and check our current key")
	info, err := hedera.NewAccountInfoQuery().
		SetAccountID(accountID).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing account info query", err))
	}

	// This should be same as key2
	println("key =", info.Key.String())
}
// Filename: examples/zero_token_operations/main.go
package main

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/hashgraph/hedera-sdk-go/v2"
	"github.com/hashgraph/hedera-sdk-go/v2/examples/contract_helper"
)

type Contract struct {
	Bytecode string `json:"bytecode"`
}

// Steps 1-5 are executed through ContractHelper and calling HIP564Example Contract.
// Step 6 is executed through the SDK
func main() {
	var client *hedera.Client
	var err error
	var contract Contract
	// Retrieving network type from environment variable HEDERA_NETWORK, i.e. testnet
	client, err = hedera.ClientForName(os.Getenv("HEDERA_NETWORK"))
	if err != nil {
		panic(fmt.Sprintf("%v : error creating client", err))
	}

	//Grab your testnet account ID and private key from the environment variable
	myAccountId, err := hedera.AccountIDFromString(os.Getenv("OPERATOR_ID"))
	if err != nil {
		panic(err)
	}

	myPrivateKey, err := hedera.PrivateKeyFromStringEd25519(os.Getenv("OPERATOR_KEY"))
	if err != nil {
		panic(err)
	}

	//Print your testnet account ID and private key to the console to make sure there was no error
	fmt.Printf("The account ID is = %v\n", myAccountId)
	fmt.Printf("The private key is = %v\n", myPrivateKey)

	client.SetOperator(myAccountId, myPrivateKey)
	//Generate new keys for the account you will create
	alicePrivateKey, err := hedera.PrivateKeyGenerateEd25519()
	if err != nil {
		panic(err)
	}

	newAccountPublicKey := alicePrivateKey.PublicKey()

	//Create new account and assign the public key
	aliceAccount, err := hedera.NewAccountCreateTransaction().
		SetKey(newAccountPublicKey).
		SetInitialBalance(hedera.HbarFrom(1000, hedera.HbarUnits.Tinybar)).
		Execute(client)
	if err != nil {
		panic(err)
	}
	//Request the receipt of the transaction
	receipt, err := aliceAccount.GetReceipt(client)
	if err != nil {
		panic(err)
	}

	//Get the new account ID from the receipt
	aliceAccountId := *receipt.AccountID
	fmt.Println("aliceAcountid is: ", aliceAccountId)
	//Transfer hbar from your testnet account to the new account
	transaction := hedera.NewTransferTransaction().
		AddHbarTransfer(myAccountId, hedera.HbarFrom(-1000, hedera.HbarUnits.Tinybar)).
		AddHbarTransfer(aliceAccountId, hedera.HbarFrom(1000, hedera.HbarUnits.Tinybar))

	//Submit the transaction to a Hedera network
	transaction.Execute(client)

	rawContract, err := os.ReadFile("../precompile_example/ZeroTokenOperations.json")
	if err != nil {
		panic(fmt.Sprintf("%v : error reading json", err))
	}

	err = json.Unmarshal([]byte(rawContract), &contract)
	if err != nil {
		panic(fmt.Sprintf("%v : error unmarshaling the json file", err))
	}
	params, err := hedera.NewContractFunctionParameters().AddAddress(myAccountId.ToSolidityAddress())
	if err != nil {
		panic(fmt.Sprintf("%v : error adding first address to contract function parameters", err))
	}
	params, err = params.AddAddress(aliceAccountId.ToSolidityAddress())
	if err != nil {
		panic(fmt.Sprintf("%v : error adding second address to contract function parameters", err))
	}

	helper := contract_helper.NewContractHelper([]byte(contract.Bytecode), *params, client)
	helper.SetPayableAmountForStep(0, hedera.NewHbar(20)).AddSignerForStep(1, alicePrivateKey)

	keyList := hedera.KeyListWithThreshold(1).Add(myPrivateKey.PublicKey()).Add(helper.ContractID)
	frozenTxn, err := hedera.NewAccountUpdateTransaction().SetAccountID(myAccountId).SetKey(keyList).FreezeWith(client)
	if err != nil {
		panic(err)
	}
	tx, err := frozenTxn.Sign(myPrivateKey).Execute(client)
	if err != nil {
		panic(err)
	}
	_, err = tx.GetReceipt(client)
	if err != nil {
		panic(err)
	}
	keyList = hedera.KeyListWithThreshold(1).Add(alicePrivateKey.PublicKey()).Add(helper.ContractID)

	frozenTxn, err = hedera.NewAccountUpdateTransaction().SetAccountID(aliceAccountId).SetKey(keyList).FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating alice's account", err))
	}
	tx, err = frozenTxn.Sign(alicePrivateKey).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error updating alice's account", err))
	}
	_, err = tx.GetReceipt(client)
	if err != nil {
		panic(err)
	}

	// TODO there is currently possible bug in services causing this operation to fail, should be investigated
	// _, err = helper.ExecuteSteps(0, 5, client)
	// if err != nil {
	// 	panic(fmt.Sprintf("%v : error in helper", err))
	// }
	transactionResponse, err := hedera.NewTokenCreateTransaction().
		SetTokenName("Black Sea LimeChain Token").
		SetTokenSymbol("BSL").
		SetTreasuryAccountID(myAccountId).
		SetInitialSupply(10000).
		SetDecimals(2).
		SetAutoRenewAccount(myAccountId).
		SetFreezeDefault(false).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error creating token", err))
	}

	// Make sure the token create transaction ran
	transactionReceipt, err := transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving token creation receipt", err))
	}

	// Retrieve the token out of the receipt
	tokenID := *transactionReceipt.TokenID

	fmt.Printf("token = %v\n", tokenID.String())

	// Associating the token with the second account, so it can interact with the token
	associatingTransaction, err := hedera.NewTokenAssociateTransaction().
		// The account ID to be associated
		SetAccountID(aliceAccountId).
		SetNodeAccountIDs([]hedera.AccountID{transactionResponse.NodeID}).
		// The token ID that the account will be associated to
		SetTokenIDs(tokenID).
		FreezeWith(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error freezing second token associate transaction", err))
	}
	// Has to be signed by the account2's key
	transactionResponse, err = associatingTransaction.
		Sign(alicePrivateKey).
		Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error executing second token associate transaction", err))
	}

	// Make sure the transaction succeeded
	transactionReceipt, err = transactionResponse.GetReceipt(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving second token associate transaction receipt", err))
	}

	fmt.Printf("Associated account %v with token %v\n", aliceAccountId.String(), tokenID.String())

	// Transfer 0 tokens
	transactionResponse, err = hedera.NewTransferTransaction().
		AddTokenTransfer(tokenID, myAccountId, 0).AddTokenTransfer(tokenID, aliceAccountId, 0).Execute(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error transfering token", err))
	}
	_, err = transactionResponse.GetRecord(client)
	if err != nil {
		panic(fmt.Sprintf("%v : error retrieving transaction", err))
	}
}
// Filename: exchange_rate.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// ExchangeRate is the exchange rate between HBAR and USD
type ExchangeRate struct {
	Hbars          int32
	cents          int32
	expirationTime *services.TimestampSeconds
}

func _ExchangeRateFromProtobuf(protoExchange *services.ExchangeRate) ExchangeRate {
	if protoExchange == nil {
		return ExchangeRate{}
	}
	var expirationTime *services.TimestampSeconds
	if protoExchange.ExpirationTime != nil {
		expirationTime = protoExchange.ExpirationTime
	}

	return ExchangeRate{
		protoExchange.HbarEquiv,
		protoExchange.CentEquiv,
		expirationTime,
	}
}

func (exchange *ExchangeRate) _ToProtobuf() *services.ExchangeRate {
	return &services.ExchangeRate{
		HbarEquiv:      exchange.Hbars,
		CentEquiv:      exchange.cents,
		ExpirationTime: exchange.expirationTime,
	}
}

// ToBytes returns the byte representation of the ExchangeRate
func (exchange *ExchangeRate) ToBytes() []byte {
	data, err := protobuf.Marshal(exchange._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// ExchangeRateFromString returns an ExchangeRate from a string representation of the exchange rate
func ExchangeRateFromBytes(data []byte) (ExchangeRate, error) {
	if data == nil {
		return ExchangeRate{}, errByteArrayNull
	}
	pb := services.ExchangeRate{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return ExchangeRate{}, err
	}

	exchangeRate := _ExchangeRateFromProtobuf(&pb)
	if err != nil {
		return ExchangeRate{}, err
	}

	return exchangeRate, nil
}

// String returns a string representation of the ExchangeRate
func (exchange *ExchangeRate) String() string {
	return fmt.Sprintf("Hbars: %d to Cents: %d, expires: %s", exchange.Hbars, exchange.cents, exchange.expirationTime.String())
}
// Filename: executable.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"context"
	"encoding/hex"
	"strconv"
	"time"

	"github.com/cenkalti/backoff/v4"

	protobuf "google.golang.org/protobuf/proto"

	"github.com/pkg/errors"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

const maxAttempts = 10

type _ExecutionState uint32

const (
	executionStateRetry    _ExecutionState = 0
	executionStateFinished _ExecutionState = 1
	executionStateError    _ExecutionState = 2
	executionStateExpired  _ExecutionState = 3
)

type Executable interface {
	GetMaxBackoff() time.Duration
	GetMinBackoff() time.Duration
	GetGrpcDeadline() *time.Duration
	GetMaxRetry() int
	GetNodeAccountIDs() []AccountID
	GetLogLevel() *LogLevel

	shouldRetry(Executable, interface{}) _ExecutionState
	makeRequest() interface{}
	advanceRequest()
	getNodeAccountID() AccountID
	getMethod(*_Channel) _Method
	mapStatusError(Executable, interface{}) error
	mapResponse(interface{}, AccountID, interface{}) (interface{}, error)
	getName() string
	validateNetworkOnIDs(client *Client) error
	isTransaction() bool
	getLogger(Logger) Logger
	getTransactionIDAndMessage() (string, string)
	getLogID(Executable) string // This returns transaction creation timestamp + transaction name
}

type executable struct {
	transactionIDs *_LockableSlice
	nodeAccountIDs *_LockableSlice
	maxBackoff     *time.Duration
	minBackoff     *time.Duration
	grpcDeadline   *time.Duration
	maxRetry       int
	logLevel       *LogLevel
}

type _Method struct {
	query func(
		context.Context,
		*services.Query,
		...grpc.CallOption,
	) (*services.Response, error)
	transaction func(
		context.Context,
		*services.Transaction,
		...grpc.CallOption,
	) (*services.TransactionResponse, error)
}

func (e *executable) GetMaxBackoff() time.Duration {
	if e.maxBackoff != nil {
		return *e.maxBackoff
	}

	return 8 * time.Second
}

func (e *executable) GetMinBackoff() time.Duration {
	if e.minBackoff != nil {
		return *e.minBackoff
	}

	return 250 * time.Millisecond
}

func (e *executable) SetMaxBackoff(max time.Duration) *executable {
	if max.Nanoseconds() < 0 {
		panic("maxBackoff must be a positive duration")
	} else if max.Nanoseconds() < e.minBackoff.Nanoseconds() {
		panic("maxBackoff must be greater than or equal to minBackoff")
	}
	e.maxBackoff = &max
	return e
}

func (e *executable) SetMinBackoff(min time.Duration) *executable {
	if min.Nanoseconds() < 0 {
		panic("minBackoff must be a positive duration")
	} else if e.maxBackoff.Nanoseconds() < min.Nanoseconds() {
		panic("minBackoff must be less than or equal to maxBackoff")
	}
	e.minBackoff = &min
	return e
}

// GetGrpcDeadline returns the grpc deadline
func (e *executable) GetGrpcDeadline() *time.Duration {
	return e.grpcDeadline
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (e *executable) SetGrpcDeadline(deadline *time.Duration) *executable {
	e.grpcDeadline = deadline
	return e
}

// GetMaxRetry returns the max number of errors before execution will fail.
func (e *executable) GetMaxRetry() int {
	return e.maxRetry
}

func (e *executable) SetMaxRetry(max int) *executable {
	e.maxRetry = max
	return e
}

// GetNodeAccountID returns the node AccountID for this transaction.
func (e *executable) GetNodeAccountIDs() []AccountID {
	nodeAccountIDs := []AccountID{}

	for _, value := range e.nodeAccountIDs.slice {
		nodeAccountIDs = append(nodeAccountIDs, value.(AccountID))
	}

	return nodeAccountIDs
}

func (e *executable) SetNodeAccountIDs(nodeAccountIDs []AccountID) *executable {
	for _, nodeAccountID := range nodeAccountIDs {
		e.nodeAccountIDs._Push(nodeAccountID)
	}
	e.nodeAccountIDs._SetLocked(true)
	return e
}

func (e *executable) GetLogLevel() *LogLevel {
	return e.logLevel
}

func (e *executable) SetLogLevel(level LogLevel) *executable {
	e.logLevel = &level
	return e
}

func (e *executable) getLogger(clientLogger Logger) Logger {
	if e.logLevel != nil {
		return clientLogger.SubLoggerWithLevel(*e.logLevel)
	}
	return clientLogger
}

func (e *executable) getNodeAccountID() AccountID {
	return e.nodeAccountIDs._GetCurrent().(AccountID)
}

func _Execute(client *Client, e Executable) (interface{}, error) {
	var maxAttempts int
	backOff := backoff.NewExponentialBackOff()
	backOff.InitialInterval = e.GetMinBackoff()
	backOff.MaxInterval = e.GetMaxBackoff()
	backOff.Multiplier = 2

	if client.maxAttempts != nil {
		maxAttempts = *client.maxAttempts
	} else {
		maxAttempts = e.GetMaxRetry()
	}

	currentBackoff := e.GetMinBackoff()

	var attempt int64
	var errPersistent error
	var marshaledRequest []byte

	txLogger := e.getLogger(client.logger)
	txID, msg := e.getTransactionIDAndMessage()

	for attempt = int64(0); attempt < int64(maxAttempts); attempt, currentBackoff = attempt+1, currentBackoff*2 {
		var protoRequest interface{}
		var node *_Node
		var ok bool

		if e.isTransaction() {
			if attempt > 0 && len(e.GetNodeAccountIDs()) > 1 {
				e.advanceRequest()
			}
		}

		protoRequest = e.makeRequest()
		if len(e.GetNodeAccountIDs()) == 0 {
			node = client.network._GetNode()
		} else {
			nodeAccountID := e.getNodeAccountID()
			if node, ok = client.network._GetNodeForAccountID(nodeAccountID); !ok {
				return TransactionResponse{}, ErrInvalidNodeAccountIDSet{nodeAccountID}
			}
		}

		if e.isTransaction() {
			marshaledRequest, _ = protobuf.Marshal(protoRequest.(*services.Transaction))
		} else {
			marshaledRequest, _ = protobuf.Marshal(protoRequest.(*services.Query))
		}

		node._InUse()

		txLogger.Trace("executing", "requestId", e.getLogID(e), "nodeAccountID", node.accountID.String(), "nodeIPAddress", node.address._String(), "Request Proto", hex.EncodeToString(marshaledRequest))

		if !node._IsHealthy() {
			txLogger.Trace("node is unhealthy, waiting before continuing", "requestId", e.getLogID(e), "delay", node._Wait().String())
			_DelayForAttempt(e.getLogID(e), currentBackoff, attempt, txLogger, errNodeIsUnhealthy)
			continue
		}

		txLogger.Trace("updating node account ID index", "requestId", e.getLogID(e))
		channel, err := node._GetChannel(txLogger)
		if err != nil {
			client.network._IncreaseBackoff(node)
			errPersistent = err
			continue
		}

		e.advanceRequest()

		method := e.getMethod(channel)

		var resp interface{}

		ctx := context.TODO()
		var cancel context.CancelFunc

		if e.GetGrpcDeadline() != nil {
			grpcDeadline := time.Now().Add(*e.GetGrpcDeadline())
			ctx, cancel = context.WithDeadline(ctx, grpcDeadline)
		}

		txLogger.Trace("executing gRPC call", "requestId", e.getLogID(e))

		var marshaledResponse []byte
		if method.query != nil {
			resp, err = method.query(ctx, protoRequest.(*services.Query))
			if err == nil {
				marshaledResponse, _ = protobuf.Marshal(resp.(*services.Response))
			}
		} else {
			resp, err = method.transaction(ctx, protoRequest.(*services.Transaction))
			if err == nil {
				marshaledResponse, _ = protobuf.Marshal(resp.(*services.TransactionResponse))
			}
		}

		if cancel != nil {
			cancel()
		}
		if err != nil {
			errPersistent = err
			if _ExecutableDefaultRetryHandler(e.getLogID(e), err, txLogger) {
				client.network._IncreaseBackoff(node)
				continue
			}
			if errPersistent == nil {
				errPersistent = errors.New("error")
			}

			if e.isTransaction() {
				return TransactionResponse{}, errors.Wrapf(errPersistent, "retry %d/%d", attempt, maxAttempts)
			}

			return &services.Response{}, errors.Wrapf(errPersistent, "retry %d/%d", attempt, maxAttempts)
		}

		node._DecreaseBackoff()

		statusError := e.mapStatusError(e, resp)

		txLogger.Trace(
			msg,
			"requestID", e.getLogID(e),
			"nodeID", node.accountID.String(),
			"nodeAddress", node.address._String(),
			"nodeIsHealthy", strconv.FormatBool(node._IsHealthy()),
			"network", client.GetLedgerID().String(),
			"status", statusError.Error(),
			"txID", txID,
		)

		switch e.shouldRetry(e, resp) {
		case executionStateRetry:
			errPersistent = statusError
			_DelayForAttempt(e.getLogID(e), currentBackoff, attempt, txLogger, errPersistent)
			continue
		case executionStateExpired:
			if e.isTransaction() {
				transaction := e.(TransactionInterface)
				if transaction.regenerateID(client) {
					txLogger.Trace("received `TRANSACTION_EXPIRED` with transaction ID regeneration enabled; regenerating", "requestId", e.getLogID(e))
					continue
				} else {
					return TransactionResponse{}, statusError
				}
			} else {
				return &services.Response{}, statusError
			}
		case executionStateError:
			if e.isTransaction() {
				return TransactionResponse{}, statusError
			}

			return &services.Response{}, statusError
		case executionStateFinished:
			txLogger.Trace("finished", "Response Proto", hex.EncodeToString(marshaledResponse))
			return e.mapResponse(resp, node.accountID, protoRequest)
		}
	}

	if errPersistent == nil {
		errPersistent = errors.New("unknown error occurred after max attempts")
	}

	if e.isTransaction() {
		return TransactionResponse{}, errors.Wrapf(errPersistent, "retry %d/%d", attempt, maxAttempts)
	}

	txLogger.Error("exceeded maximum attempts for request", "last exception being", errPersistent)

	return &services.Response{}, errPersistent
}

func _DelayForAttempt(logID string, backoff time.Duration, attempt int64, logger Logger, err error) {
	logger.Trace("retrying request attempt", "requestId", logID, "delay", backoff, "attempt", attempt+1, "error", err)

	time.Sleep(backoff)
}

func _ExecutableDefaultRetryHandler(logID string, err error, logger Logger) bool {
	code := status.Code(err)
	logger.Trace("received gRPC error with status code", "requestId", logID, "status", code.String())
	switch code {
	case codes.ResourceExhausted, codes.Unavailable:
		return true
	case codes.Internal:
		grpcErr, ok := status.FromError(err)

		if !ok {
			return false
		}

		return rstStream.Match([]byte(grpcErr.Message()))
	default:
		return false
	}
}
// Filename: fee_assessment_method.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

type FeeAssessmentMethod bool

const (
	FeeAssessmentMethodInclusive FeeAssessmentMethod = false
	FeeAssessmentMethodExclusive FeeAssessmentMethod = true
)

// String returns a string representation of the FeeAssessmentMethod
func (assessment FeeAssessmentMethod) String() string {
	if assessment {
		return "FeeAssessmentMethodExclusive"
	}

	return "FeeAssessmentMethodInclusive"
}
// Filename: fee_components.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// nolint
type FeeComponents struct {
	Min                        int64
	Max                        int64
	Constant                   int64
	TransactionBandwidthByte   int64
	TransactionVerification    int64
	TransactionRamByteHour     int64
	TransactionStorageByteHour int64
	ContractTransactionGas     int64
	TransferVolumeHbar         int64
	ResponseMemoryByte         int64
	ResponseDiscByte           int64
}

func _FeeComponentsFromProtobuf(feeComponents *services.FeeComponents) (FeeComponents, error) {
	if feeComponents == nil {
		return FeeComponents{}, errParameterNull
	}

	return FeeComponents{
		Min:                        feeComponents.GetMin(),
		Max:                        feeComponents.GetMax(),
		Constant:                   feeComponents.GetConstant(),
		TransactionBandwidthByte:   feeComponents.GetBpt(),
		TransactionVerification:    feeComponents.GetVpt(),
		TransactionRamByteHour:     feeComponents.GetRbh(),
		TransactionStorageByteHour: feeComponents.GetSbh(),
		ContractTransactionGas:     feeComponents.GetGas(),
		TransferVolumeHbar:         feeComponents.GetTv(),
		ResponseMemoryByte:         feeComponents.GetBpr(),
		ResponseDiscByte:           feeComponents.GetSbpr(),
	}, nil
}

func (feeComponents FeeComponents) _ToProtobuf() *services.FeeComponents {
	return &services.FeeComponents{
		Min:      feeComponents.Min,
		Max:      feeComponents.Max,
		Constant: feeComponents.Constant,
		Bpt:      feeComponents.TransactionBandwidthByte,
		Vpt:      feeComponents.TransactionVerification,
		Rbh:      feeComponents.TransactionRamByteHour,
		Sbh:      feeComponents.TransactionStorageByteHour,
		Gas:      feeComponents.ContractTransactionGas,
		Tv:       feeComponents.TransferVolumeHbar,
		Bpr:      feeComponents.ResponseMemoryByte,
		Sbpr:     feeComponents.ResponseDiscByte,
	}
}

// ToBytes returns the byte representation of the FeeComponents
func (feeComponents FeeComponents) ToBytes() []byte {
	data, err := protobuf.Marshal(feeComponents._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// FeeComponentsFromBytes returns the FeeComponents from a byte array representation
func FeeComponentsFromBytes(data []byte) (FeeComponents, error) {
	if data == nil {
		return FeeComponents{}, errByteArrayNull
	}
	pb := services.FeeComponents{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return FeeComponents{}, err
	}

	info, err := _FeeComponentsFromProtobuf(&pb)
	if err != nil {
		return FeeComponents{}, err
	}

	return info, nil
}

// String returns a string representation of the FeeComponents
func (feeComponents FeeComponents) String() string {
	return fmt.Sprintf("Min: %d, Max: %d, Constant: %d,TransactionBandwithByte: %d,TransactionVerification: %d,TransactionRamByteHour: %d,TransactionStorageByteHour: %d, ContractTransactionGas: %d,TransferVolumeHbar: %d, ResponseMemoryByte: %d, ResponseDiscByte: %d", feeComponents.Min, feeComponents.Max, feeComponents.Constant, feeComponents.TransactionBandwidthByte, feeComponents.TransactionVerification, feeComponents.TransactionRamByteHour, feeComponents.TransactionStorageByteHour, feeComponents.ContractTransactionGas, feeComponents.TransferVolumeHbar, feeComponents.ResponseMemoryByte, feeComponents.ResponseDiscByte)
}
// Filename: fee_data.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

type FeeData struct {
	NodeData    *FeeComponents
	NetworkData *FeeComponents
	ServiceData *FeeComponents
}

func _FeeDataFromProtobuf(feeData *services.FeeData) (FeeData, error) {
	if feeData == nil {
		return FeeData{}, errParameterNull
	}

	nodeData, err := _FeeComponentsFromProtobuf(feeData.Nodedata)
	if err != nil {
		return FeeData{}, err
	}

	networkData, err := _FeeComponentsFromProtobuf(feeData.Networkdata)
	if err != nil {
		return FeeData{}, err
	}

	serviceData, err := _FeeComponentsFromProtobuf(feeData.Servicedata)
	if err != nil {
		return FeeData{}, err
	}

	return FeeData{
		NodeData:    &nodeData,
		NetworkData: &networkData,
		ServiceData: &serviceData,
	}, nil
}

func (feeData FeeData) _ToProtobuf() *services.FeeData {
	var nodeData *services.FeeComponents
	if feeData.NodeData != nil {
		nodeData = feeData.NodeData._ToProtobuf()
	}

	var networkData *services.FeeComponents
	if feeData.NetworkData != nil {
		networkData = feeData.NetworkData._ToProtobuf()
	}

	var serviceData *services.FeeComponents
	if feeData.ServiceData != nil {
		serviceData = feeData.ServiceData._ToProtobuf()
	}

	return &services.FeeData{
		Nodedata:    nodeData,
		Networkdata: networkData,
		Servicedata: serviceData,
	}
}

// ToBytes returns the byte representation of the FeeData
func (feeData FeeData) ToBytes() []byte {
	data, err := protobuf.Marshal(feeData._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// FeeDataFromBytes returns a FeeData struct from a raw byte array
func FeeDataFromBytes(data []byte) (FeeData, error) {
	if data == nil {
		return FeeData{}, errByteArrayNull
	}
	pb := services.FeeData{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return FeeData{}, err
	}

	info, err := _FeeDataFromProtobuf(&pb)
	if err != nil {
		return FeeData{}, err
	}

	return info, nil
}

// String returns a string representation of the FeeData
func (feeData FeeData) String() string {
	return fmt.Sprintf("\nNodedata: %s\nNetworkdata: %s\nServicedata: %s\n", feeData.NodeData.String(), feeData.NetworkData.String(), feeData.ServiceData.String())
}
// Filename: fee_schedule.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

type FeeSchedule struct {
	TransactionFeeSchedules []TransactionFeeSchedule
	ExpirationTime          *time.Time
}

func _FeeScheduleFromProtobuf(feeSchedule *services.FeeSchedule) (FeeSchedule, error) {
	if feeSchedule == nil {
		return FeeSchedule{}, errParameterNull
	}

	txFeeSchedules := make([]TransactionFeeSchedule, 0)
	for _, txFeeSchedule := range feeSchedule.GetTransactionFeeSchedule() {
		txFeeScheduleFromProto, err := _TransactionFeeScheduleFromProtobuf(txFeeSchedule)
		if err != nil {
			return FeeSchedule{}, err
		}
		txFeeSchedules = append(txFeeSchedules, txFeeScheduleFromProto)
	}

	var expiry time.Time
	if feeSchedule.ExpiryTime != nil {
		expiry = time.Unix(feeSchedule.ExpiryTime.Seconds, 0)
	}

	return FeeSchedule{
		TransactionFeeSchedules: txFeeSchedules,
		ExpirationTime:          &expiry,
	}, nil
}

func (feeSchedule FeeSchedule) _ToProtobuf() *services.FeeSchedule {
	txFeeSchedules := make([]*services.TransactionFeeSchedule, 0)
	for _, txFeeSchedule := range feeSchedule.TransactionFeeSchedules {
		txFeeSchedules = append(txFeeSchedules, txFeeSchedule._ToProtobuf())
	}

	var expiry services.TimestampSeconds
	if feeSchedule.ExpirationTime != nil {
		expiry = services.TimestampSeconds{Seconds: feeSchedule.ExpirationTime.Unix()}
	}

	return &services.FeeSchedule{
		TransactionFeeSchedule: txFeeSchedules,
		ExpiryTime:             &expiry,
	}
}

// ToBytes returns the byte representation of the FeeSchedule
func (feeSchedule FeeSchedule) ToBytes() []byte {
	data, err := protobuf.Marshal(feeSchedule._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// FeeScheduleFromBytes returns a FeeSchedule from a raw protobuf byte array
func FeeScheduleFromBytes(data []byte) (FeeSchedule, error) {
	if data == nil {
		return FeeSchedule{}, errByteArrayNull
	}
	pb := services.FeeSchedule{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return FeeSchedule{}, err
	}

	info, err := _FeeScheduleFromProtobuf(&pb)
	if err != nil {
		return FeeSchedule{}, err
	}

	return info, nil
}

// String returns a string representation of the FeeSchedule
func (feeSchedule FeeSchedule) String() string {
	array := "\n"
	for _, i := range feeSchedule.TransactionFeeSchedules {
		array = array + i.String() + "\n"
	}
	return fmt.Sprintf("TransactionFeeSchedules: %s, Expiration: %s", array, feeSchedule.ExpirationTime)
}
// Filename: fee_schedules.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

type FeeSchedules struct {
	current *FeeSchedule
	next    *FeeSchedule
}

func _FeeSchedulesFromProtobuf(feeSchedules *services.CurrentAndNextFeeSchedule) (FeeSchedules, error) {
	if feeSchedules == nil {
		return FeeSchedules{}, errParameterNull
	}

	var current FeeSchedule
	var err error
	if feeSchedules.CurrentFeeSchedule != nil {
		current, err = _FeeScheduleFromProtobuf(feeSchedules.GetCurrentFeeSchedule())
		if err != nil {
			return FeeSchedules{}, err
		}
	}

	var next FeeSchedule
	if feeSchedules.NextFeeSchedule != nil {
		next, err = _FeeScheduleFromProtobuf(feeSchedules.GetNextFeeSchedule())
		if err != nil {
			return FeeSchedules{}, err
		}
	}

	return FeeSchedules{
		current: &current,
		next:    &next,
	}, nil
}

func (feeSchedules FeeSchedules) _ToProtobuf() *services.CurrentAndNextFeeSchedule {
	var current *services.FeeSchedule
	if feeSchedules.current != nil {
		current = feeSchedules.current._ToProtobuf()
	}

	var next *services.FeeSchedule
	if feeSchedules.next != nil {
		next = feeSchedules.next._ToProtobuf()
	}

	return &services.CurrentAndNextFeeSchedule{
		CurrentFeeSchedule: current,
		NextFeeSchedule:    next,
	}
}

// ToBytes returns the byte representation of the FeeSchedules
func (feeSchedules FeeSchedules) ToBytes() []byte {
	data, err := protobuf.Marshal(feeSchedules._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// FeeSchedulesFromBytes returns a FeeSchedules object from a raw byte array
func FeeSchedulesFromBytes(data []byte) (FeeSchedules, error) {
	if data == nil {
		return FeeSchedules{}, errByteArrayNull
	}
	pb := services.CurrentAndNextFeeSchedule{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return FeeSchedules{}, err
	}

	info, err := _FeeSchedulesFromProtobuf(&pb)
	if err != nil {
		return FeeSchedules{}, err
	}

	return info, nil
}

// String returns a string representation of the FeeSchedules
func (feeSchedules FeeSchedules) String() string {
	return fmt.Sprintf("Current: %s, Next: %s", feeSchedules.current.String(), feeSchedules.next.String())
}
// Filename: fee_schedules_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func DisabledTestIntegrationNodeAddressBookFromBytes(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	nodeAddressBookBytes, err := NewFileContentsQuery().
		SetFileID(FileID{Shard: 0, Realm: 0, File: 101}).
		Execute(env.Client)
	require.NoError(t, err)
	nodeAddressbook, err := NodeAddressBookFromBytes(nodeAddressBookBytes)
	require.NoError(t, err)
	assert.NotNil(t, nodeAddressbook)

	for _, ad := range nodeAddressbook.NodeAddresses {
		println(ad.NodeID)
		println(string(ad.CertHash))
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: fee_schedules_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnitFeeSchedulesFromBytes(t *testing.T) {
	t.Parallel()
	// nolint
	dat, err := os.ReadFile("./fee_schedule/fee_schedule.pb")
	require.NoError(t, err)
	feeSchedules, err := FeeSchedulesFromBytes(dat)
	require.NoError(t, err)
	assert.NotNil(t, feeSchedules)
	assert.Equal(t, int64(11461413665), feeSchedules.current.TransactionFeeSchedules[0].Fees[0].NodeData.Constant)
	assert.Equal(t, int64(229228273302), feeSchedules.current.TransactionFeeSchedules[0].Fees[0].ServiceData.Constant)
	assert.Equal(t, feeSchedules.current.TransactionFeeSchedules[0].RequestType, RequestTypeCryptoCreate)
}
// Filename: file_append_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
	protobuf "google.golang.org/protobuf/proto"
)

// FileAppendTransaction appends the given contents to the end of the file. If a file is too big to create with a single
// FileCreateTransaction, then it can be created with the first part of its contents, and then appended multiple times
// to create the entire file.
type FileAppendTransaction struct {
	Transaction
	maxChunks uint64
	contents  []byte
	fileID    *FileID
	chunkSize int
}

// NewFileAppendTransaction creates a FileAppendTransaction transaction which can be
// used to construct and execute a File Append Transaction.
func NewFileAppendTransaction() *FileAppendTransaction {
	tx := FileAppendTransaction{
		Transaction: _NewTransaction(),
		maxChunks:   20,
		contents:    make([]byte, 0),
		chunkSize:   2048,
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _FileAppendTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *FileAppendTransaction {
	return &FileAppendTransaction{
		Transaction: tx,
		maxChunks:   20,
		contents:    pb.GetFileAppend().GetContents(),
		chunkSize:   2048,
		fileID:      _FileIDFromProtobuf(pb.GetFileAppend().GetFileID()),
	}
}

// SetFileID sets the FileID of the file to which the bytes are appended to.
func (tx *FileAppendTransaction) SetFileID(fileID FileID) *FileAppendTransaction {
	tx._RequireNotFrozen()
	tx.fileID = &fileID
	return tx
}

// GetFileID returns the FileID of the file to which the bytes are appended to.
func (tx *FileAppendTransaction) GetFileID() FileID {
	if tx.fileID == nil {
		return FileID{}
	}

	return *tx.fileID
}

// SetMaxChunkSize Sets maximum amount of chunks append function can create
func (tx *FileAppendTransaction) SetMaxChunkSize(size int) *FileAppendTransaction {
	tx._RequireNotFrozen()
	tx.chunkSize = size
	return tx
}

// GetMaxChunkSize returns maximum amount of chunks append function can create
func (tx *FileAppendTransaction) GetMaxChunkSize() int {
	return tx.chunkSize
}

// SetMaxChunks sets the maximum number of chunks that can be created
func (tx *FileAppendTransaction) SetMaxChunks(size uint64) *FileAppendTransaction {
	tx._RequireNotFrozen()
	tx.maxChunks = size
	return tx
}

// GetMaxChunks returns the maximum number of chunks that can be created
func (tx *FileAppendTransaction) GetMaxChunks() uint64 {
	return tx.maxChunks
}

// SetContents sets the bytes to append to the contents of the file.
func (tx *FileAppendTransaction) SetContents(contents []byte) *FileAppendTransaction {
	tx._RequireNotFrozen()
	tx.contents = contents
	return tx
}

// GetContents returns the bytes to append to the contents of the file.
func (tx *FileAppendTransaction) GetContents() []byte {
	return tx.contents
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *FileAppendTransaction) Sign(
	privateKey PrivateKey,
) *FileAppendTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *FileAppendTransaction) SignWithOperator(
	client *Client,
) (*FileAppendTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *FileAppendTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *FileAppendTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *FileAppendTransaction) AddSignature(publicKey PublicKey, signature []byte) *FileAppendTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *FileAppendTransaction) SetGrpcDeadline(deadline *time.Duration) *FileAppendTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *FileAppendTransaction) Freeze() (*FileAppendTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *FileAppendTransaction) FreezeWith(client *Client) (*FileAppendTransaction, error) {
	if tx.IsFrozen() {
		return tx, nil
	}

	if tx.nodeAccountIDs._Length() == 0 {
		if client == nil {
			return tx, errNoClientOrTransactionIDOrNodeId
		}

		tx.SetNodeAccountIDs(client.network._GetNodeAccountIDsForExecute())
	}

	tx._InitFee(client)
	err := tx.validateNetworkOnIDs(client)
	if err != nil {
		return &FileAppendTransaction{}, err
	}
	if err := tx._InitTransactionID(client); err != nil {
		return tx, err
	}
	body := tx.build()

	chunks := uint64((len(tx.contents) + (tx.chunkSize - 1)) / tx.chunkSize)
	if chunks > tx.maxChunks {
		return tx, ErrMaxChunksExceeded{
			Chunks:    chunks,
			MaxChunks: tx.maxChunks,
		}
	}

	nextTransactionID := tx.transactionIDs._GetCurrent().(TransactionID)

	tx.transactionIDs = _NewLockableSlice()
	tx.transactions = _NewLockableSlice()
	tx.signedTransactions = _NewLockableSlice()

	if b, ok := body.Data.(*services.TransactionBody_FileAppend); ok {
		for i := 0; uint64(i) < chunks; i++ {
			start := i * tx.chunkSize
			end := start + tx.chunkSize

			if end > len(tx.contents) {
				end = len(tx.contents)
			}

			tx.transactionIDs._Push(_TransactionIDFromProtobuf(nextTransactionID._ToProtobuf()))
			if err != nil {
				panic(err)
			}
			b.FileAppend.Contents = tx.contents[start:end]

			body.TransactionID = nextTransactionID._ToProtobuf()
			body.Data = &services.TransactionBody_FileAppend{
				FileAppend: b.FileAppend,
			}

			for _, nodeAccountID := range tx.GetNodeAccountIDs() {
				body.NodeAccountID = nodeAccountID._ToProtobuf()

				bodyBytes, err := protobuf.Marshal(body)
				if err != nil {
					return tx, errors.Wrap(err, "error serializing body for file append")
				}

				tx.signedTransactions._Push(&services.SignedTransaction{
					BodyBytes: bodyBytes,
					SigMap:    &services.SignatureMap{},
				})
			}

			validStart := *nextTransactionID.ValidStart

			*nextTransactionID.ValidStart = validStart.Add(1 * time.Nanosecond)
		}
	}

	return tx, nil
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *FileAppendTransaction) SetMaxTransactionFee(fee Hbar) *FileAppendTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *FileAppendTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *FileAppendTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this FileAppendTransaction.
func (tx *FileAppendTransaction) SetTransactionMemo(memo string) *FileAppendTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this FileAppendTransaction.
func (tx *FileAppendTransaction) SetTransactionValidDuration(duration time.Duration) *FileAppendTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *FileAppendTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this FileAppendTransaction.
func (tx *FileAppendTransaction) SetTransactionID(transactionID TransactionID) *FileAppendTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountID sets the _Node AccountID for this FileAppendTransaction.
func (tx *FileAppendTransaction) SetNodeAccountIDs(nodeAccountIDs []AccountID) *FileAppendTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeAccountIDs)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *FileAppendTransaction) SetMaxRetry(count int) *FileAppendTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *FileAppendTransaction) SetMaxBackoff(max time.Duration) *FileAppendTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *FileAppendTransaction) SetMinBackoff(min time.Duration) *FileAppendTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *FileAppendTransaction) SetLogLevel(level LogLevel) *FileAppendTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

// Execute executes the Transaction with the provided client
func (tx *FileAppendTransaction) Execute(
	client *Client,
) (TransactionResponse, error) {
	if client == nil {
		return TransactionResponse{}, errNoClientProvided
	}

	if tx.freezeError != nil {
		return TransactionResponse{}, tx.freezeError
	}

	list, err := tx.ExecuteAll(client)

	if err != nil {
		if len(list) > 0 {
			return TransactionResponse{
				TransactionID: tx.GetTransactionID(),
				NodeID:        list[0].NodeID,
				Hash:          make([]byte, 0),
			}, err
		}
		return TransactionResponse{
			TransactionID: tx.GetTransactionID(),
			Hash:          make([]byte, 0),
		}, err
	}

	return list[0], nil
}

// ExecuteAll executes the all the Transactions with the provided client
func (tx *FileAppendTransaction) ExecuteAll(
	client *Client,
) ([]TransactionResponse, error) {
	if client == nil || client.operator == nil {
		return []TransactionResponse{}, errNoClientProvided
	}

	if !tx.IsFrozen() {
		_, err := tx.FreezeWith(client)
		if err != nil {
			return []TransactionResponse{}, err
		}
	}

	var transactionID TransactionID
	if tx.transactionIDs._Length() > 0 {
		transactionID = tx.GetTransactionID()
	} else {
		return []TransactionResponse{}, errors.New("transactionID list is empty")
	}

	if !client.GetOperatorAccountID()._IsZero() && client.GetOperatorAccountID()._Equals(*transactionID.AccountID) {
		tx.SignWith(
			client.GetOperatorPublicKey(),
			client.operator.signer,
		)
	}

	size := tx.signedTransactions._Length() / tx.nodeAccountIDs._Length()
	list := make([]TransactionResponse, size)

	for i := 0; i < size; i++ {
		resp, err := _Execute(client, tx)

		if err != nil {
			return list, err
		}

		list[i] = resp.(TransactionResponse)

		_, err = list[i].SetValidateStatus(false).GetReceipt(client)
		if err != nil {
			return list, err
		}
	}

	return list, nil
}

func (tx *FileAppendTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	chunks := uint64((len(tx.contents) + (tx.chunkSize - 1)) / tx.chunkSize)
	if chunks > 1 {
		return &ScheduleCreateTransaction{}, ErrMaxChunksExceeded{
			Chunks:    chunks,
			MaxChunks: 1,
		}
	}

	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *FileAppendTransaction) getName() string {
	return "FileAppendTransaction"
}
func (tx *FileAppendTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.fileID != nil {
		if err := tx.fileID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *FileAppendTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_FileAppend{
			FileAppend: tx.buildProtoBody(),
		},
	}
}

func (tx *FileAppendTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_FileAppend{
			FileAppend: tx.buildProtoBody(),
		},
	}, nil
}
func (tx *FileAppendTransaction) buildProtoBody() *services.FileAppendTransactionBody {
	body := &services.FileAppendTransactionBody{
		Contents: tx.contents,
	}

	if tx.fileID != nil {
		body.FileID = tx.fileID._ToProtobuf()
	}

	return body
}

func (tx *FileAppendTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetFile().AppendContent,
	}
}

func (tx *FileAppendTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: file_append_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationFileAppendTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewFileAppendTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContents([]byte(" world!")).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	contents, err := NewFileContentsQuery().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, []byte("Hello world!"), contents)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileAppendTransactionNoFileID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	_, err = NewFileAppendTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContents([]byte(" world!")).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Contains(t, err.Error(), "exceptional precheck status INVALID_FILE_ID", err.Error())
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileAppendTransactionNothingSet(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewFileAppendTransaction().
		SetContents([]byte(" world!")).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.Error(t, err)
	if err != nil {
		assert.Contains(t, err.Error(), "exceptional precheck status INVALID_FILE_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
func TestIntegrationFileAppendTransactionCanExecuteAfterSerializationDeserialization(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	before := NewFileAppendTransaction().
		SetFileID(fileID)

	bytes, err := before.ToBytes()
	require.NoError(t, err)

	afterI, err := TransactionFromBytes(bytes)
	require.NoError(t, err)

	tx := afterI.(FileAppendTransaction)

	resp, err = tx.SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContents([]byte(" world!")).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	contents, err := NewFileContentsQuery().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, []byte("Hello world!"), contents)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: file_append_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitFileAppendTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	fileAppend := NewFileAppendTransaction().
		SetFileID(fileID)

	err = fileAppend.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitFileAppendTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	fileAppend := NewFileAppendTransaction().
		SetFileID(fileID)

	err = fileAppend.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitFileAppendTransactionMock(t *testing.T) {
	t.Parallel()

	fil := []byte(" world!")
	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if bod, ok := transactionBody.Data.(*services.TransactionBody_FileAppend); ok {
			require.Equal(t, bod.FileAppend.FileID.FileNum, int64(3))
			require.Equal(t, bytes.Compare(bod.FileAppend.Contents, fil), 0)
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call, &services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
						AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
							AccountNum: 234,
						}},
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewFileAppendTransaction().
		SetFileID(FileID{File: 3}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetContents(fil).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitFileAppendTransactionGet(t *testing.T) {
	t.Parallel()

	fileID := FileID{File: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewFileAppendTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetFileID(fileID).
		SetContents([]byte("Hello, World")).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetMaxChunkSize(12).
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetFileID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetContents()
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxChunkSize()
}

//func TestUnitFileAppendTransactionNothingSet(t *testing.T) {
//	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
//	transactionID := TransactionIDGenerate(AccountID{Account: 324})
//
//	transaction, err := NewFileAppendTransaction().
//		SetTransactionID(transactionID).
//		SetNodeAccountIDs(nodeAccountID).
//		Freeze()
//	require.NoError(t, err)
//
//	transaction.GetTransactionID()
//	transaction.GetNodeAccountIDs()
//
//	_, err = transaction.GetTransactionHash()
//	require.NoError(t, err)
//
//	transaction.GetFileID()
//	transaction.GetMaxTransactionFee()
//	transaction.GetTransactionMemo()
//	transaction.GetRegenerateTransactionID()
//	_, err = transaction.GetSignatures()
//	require.NoError(t, err)
//	transaction.GetRegenerateTransactionID()
//	transaction.GetMaxTransactionFee()
//	transaction.GetContents()
//	transaction.GetRegenerateTransactionID()
//	transaction.GetMaxChunkSize()
//}

func TestUnitFileAppendTransactionBigContentsMock(t *testing.T) {
	t.Parallel()

	var previousTransactionID string

	receipt := &services.Response{
		Response: &services.Response_TransactionGetReceipt{
			TransactionGetReceipt: &services.TransactionGetReceiptResponse{
				Header: &services.ResponseHeader{
					NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
					ResponseType:                services.ResponseType_ANSWER_ONLY,
				},
				Receipt: &services.TransactionReceipt{
					Status: services.ResponseCodeEnum_SUCCESS,
					FileID: &services.FileID{FileNum: 3},
				},
			},
		},
	}

	contents := ""

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)
		if previousTransactionID == "" {
			previousTransactionID = transactionId
		} else {
			require.NotEqual(t, transactionId, previousTransactionID)
			previousTransactionID = transactionId
		}

		contents += string(transactionBody.Data.(*services.TransactionBody_FileAppend).FileAppend.Contents)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call, receipt, call, receipt, call, receipt, call, receipt, call, receipt, call, receipt, call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewFileAppendTransaction().
		SetFileID(FileID{File: 3}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetContents([]byte(bigContents2)).
		Execute(client)
	require.NoError(t, err)

	require.Equal(t, bigContents2, contents)
}

func TestUnitFileAppendTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	file := FileID{File: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewFileAppendTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetFileID(file).
		SetContents([]byte{1}).
		SetMaxChunkSize(5).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetContents()
	transaction.GetMaxChunkSize()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case FileAppendTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitFileAppendTransactionSerialization(t *testing.T) {
	t.Parallel()

	fileID := FileID{File: 7}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewFileAppendTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetFileID(fileID).
		SetContents([]byte("Hello, World")).
		Freeze()
	require.NoError(t, err)

	txBytes, err := transaction.ToBytes()
	require.NoError(t, err)

	txParsed, err := TransactionFromBytes(txBytes)
	require.NoError(t, err)

	result, ok := txParsed.(FileAppendTransaction)
	require.True(t, ok)

	require.Equal(t, transactionID.AccountID, result.GetTransactionID().AccountID)
	require.Equal(t, fileID, result.GetFileID())
	require.Equal(t, transaction.GetContents(), result.GetContents())
}
// Filename: file_contents_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// FileContentsQuery retrieves the contents of a file.
type FileContentsQuery struct {
	Query
	fileID *FileID
}

// NewFileContentsQuery creates a FileContentsQuery which retrieves the contents of a file.
func NewFileContentsQuery() *FileContentsQuery {
	header := services.QueryHeader{}
	return &FileContentsQuery{
		Query: _NewQuery(true, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *FileContentsQuery) SetGrpcDeadline(deadline *time.Duration) *FileContentsQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetFileID sets the FileID of the file whose contents are requested.
func (q *FileContentsQuery) SetFileID(fileID FileID) *FileContentsQuery {
	q.fileID = &fileID
	return q
}

// GetFileID returns the FileID of the file whose contents are requested.
func (q *FileContentsQuery) GetFileID() FileID {
	if q.fileID == nil {
		return FileID{}
	}

	return *q.fileID
}

func (q *FileContentsQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *FileContentsQuery) Execute(client *Client) ([]byte, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return []byte{}, err
	}

	return resp.GetFileGetContents().FileContents.Contents, nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *FileContentsQuery) SetMaxQueryPayment(maxPayment Hbar) *FileContentsQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *FileContentsQuery) SetQueryPayment(paymentAmount Hbar) *FileContentsQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this FileContentsQuery.
func (q *FileContentsQuery) SetNodeAccountIDs(accountID []AccountID) *FileContentsQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *FileContentsQuery) SetMaxRetry(count int) *FileContentsQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *FileContentsQuery) SetMaxBackoff(max time.Duration) *FileContentsQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *FileContentsQuery) SetMinBackoff(min time.Duration) *FileContentsQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *FileContentsQuery) SetPaymentTransactionID(transactionID TransactionID) *FileContentsQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *FileContentsQuery) SetLogLevel(level LogLevel) *FileContentsQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *FileContentsQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetFile().GetFileContent,
	}
}

// Get the name of the Query
func (q *FileContentsQuery) getName() string {
	return "FileContentsQuery"
}

func (q *FileContentsQuery) buildQuery() *services.Query {
	body := &services.FileGetContentsQuery{
		Header: q.pbHeader,
	}

	if q.fileID != nil {
		body.FileID = q.fileID._ToProtobuf()
	}

	return &services.Query{
		Query: &services.Query_FileGetContents{
			FileGetContents: body,
		},
	}
}

func (q *FileContentsQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.fileID != nil {
		if err := q.fileID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *FileContentsQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetFileGetContents()
}
// Filename: file_contents_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationFileContentsQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	var contents = []byte("Hellow world!")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(contents).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	remoteContents, err := NewFileContentsQuery().
		SetFileID(*fileID).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, contents, remoteContents)

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileContentsQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	var contents = []byte("Hellow world!")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(contents).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileContents := NewFileContentsQuery().
		SetFileID(*fileID).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := fileContents.GetCost(env.Client)
	require.NoError(t, err)

	remoteContents, err := fileContents.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, contents, remoteContents)

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileContentsQuerySetBigMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	var contents = []byte("Hellow world!")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(contents).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileContents := NewFileContentsQuery().
		SetFileID(*fileID).
		SetMaxQueryPayment(NewHbar(100000)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := fileContents.GetCost(env.Client)
	require.NoError(t, err)

	remoteContents, err := fileContents.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, contents, remoteContents)

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileContentsQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	var contents = []byte("Hellow world!")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(contents).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileContents := NewFileContentsQuery().
		SetFileID(*fileID).
		SetMaxQueryPayment(HbarFromTinybar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := fileContents.GetCost(env.Client)
	require.NoError(t, err)

	_, err = fileContents.Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "cost of FileContentsQuery ("+cost.String()+") without explicit payment is greater than the max query payment of 1 tℏ", err.Error())
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileContentsQueryInsufficientFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	var contents = []byte("Hellow world!")

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents(contents).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileContents := NewFileContentsQuery().
		SetFileID(*fileID).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	_, err = fileContents.GetCost(env.Client)
	require.NoError(t, err)

	_, err = fileContents.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_TX_FEE", err.Error())
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileContentsQueryNoFileID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewFileContentsQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_FILE_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: file_contents_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitFileContentsQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	fileContents := NewFileContentsQuery().
		SetFileID(fileID)

	err = fileContents.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitFileContentsQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	fileContents := NewFileContentsQuery().
		SetFileID(fileID)

	err = fileContents.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitFileContentsQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_FileGetContents{
				FileGetContents: &services.FileGetContentsResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 3},
				},
			},
		},
		&services.Response{
			Response: &services.Response_FileGetContents{
				FileGetContents: &services.FileGetContentsResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 3},
				},
			},
		},
		&services.Response{
			Response: &services.Response_FileGetContents{
				FileGetContents: &services.FileGetContentsResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					FileContents: &services.FileGetContentsResponse_FileContents{
						FileID:   &services.FileID{FileNum: 3},
						Contents: []byte{123},
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewFileContentsQuery().
		SetFileID(FileID{File: 3}).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{{Account: 3}})

	_, err := query.GetCost(client)
	require.NoError(t, err)

	result, err := query.Execute(client)
	require.NoError(t, err)

	require.Equal(t, bytes.Compare(result, []byte{123}), 0)
}

func TestUnitFileContentsQueryGet(t *testing.T) {
	t.Parallel()

	fileID := FileID{File: 7}

	balance := NewFileContentsQuery().
		SetFileID(fileID).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}})

	balance.GetFileID()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitFileContentsQuerySetNothing(t *testing.T) {
	t.Parallel()

	balance := NewFileContentsQuery()

	balance.GetFileID()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitFileContentsQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 3
	file := FileID{File: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewFileContentsQuery().
		SetFileID(file).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3)).
		SetGrpcDeadline(&grpc)

	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)
	query.GetNodeAccountIDs()
	query.GetMaxBackoff()
	query.GetMinBackoff()
	query.getName()
	query.GetFileID()
	query.GetQueryPayment()
	query.GetMaxQueryPayment()
}
// Filename: file_create_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// FileCreateTransaction creates a new file, containing the given contents.  It is referenced by its FileID, and does
// not have a filename, so it is important to get and hold onto the FileID. After the file is created, the FileID for
// it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to
// be created, and retrieving that.
//
// See FileInfoQuery for more information about files.
//
// The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0 and realm 0, with
// a null key. Future versions of the API will support multiple realms and multiple shards.
type FileCreateTransaction struct {
	Transaction
	keys           *KeyList
	expirationTime *time.Time
	contents       []byte
	memo           string
}

// NewFileCreateTransaction creates a FileCreateTransaction which creates a new file, containing the given contents.  It is referenced by its FileID, and does
// not have a filename, so it is important to get and hold onto the FileID. After the file is created, the FileID for
// it can be found in the receipt, or retrieved with a GetByKey query, or by asking for a Record of the transaction to
// be created, and retrieving that.
//
// See FileInfoQuery for more information about files.
//
// The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0 and realm 0, with
// a null key. Future versions of the API will support multiple realms and multiple shards.
func NewFileCreateTransaction() *FileCreateTransaction {
	tx := FileCreateTransaction{
		Transaction: _NewTransaction(),
	}

	tx.SetExpirationTime(time.Now().Add(7890000 * time.Second))
	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _FileCreateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *FileCreateTransaction {
	keys, _ := _KeyListFromProtobuf(pb.GetFileCreate().GetKeys())
	expiration := _TimeFromProtobuf(pb.GetFileCreate().GetExpirationTime())

	return &FileCreateTransaction{
		Transaction:    tx,
		keys:           &keys,
		expirationTime: &expiration,
		contents:       pb.GetFileCreate().GetContents(),
		memo:           pb.GetMemo(),
	}
}

// AddKey adds a key to the internal list of keys associated with the file. All of the keys on the list must sign to
// create or modify a file, but only one of them needs to sign in order to delete the file. Each of those "keys" may
// itself be threshold key containing other keys (including other threshold keys). In other words, the behavior is an
// AND for create/modify, OR for delete. This is useful for acting as a revocation server. If it is desired to have the
// behavior be AND for all 3 operations (or OR for all 3), then the list should have only a single Key, which is a
// threshold key, with N=1 for OR, N=M for AND.
//
// If a file is created without adding ANY keys, the file is immutable and ONLY the
// expirationTime of the file can be changed using FileUpdateTransaction. The file contents or its keys will not be
// mutable.
func (tx *FileCreateTransaction) SetKeys(keys ...Key) *FileCreateTransaction {
	tx._RequireNotFrozen()
	if tx.keys == nil {
		tx.keys = &KeyList{keys: []Key{}}
	}
	keyList := NewKeyList()
	keyList.AddAll(keys)

	tx.keys = keyList

	return tx
}

func (tx *FileCreateTransaction) GetKeys() KeyList {
	if tx.keys != nil {
		return *tx.keys
	}

	return KeyList{}
}

// SetExpirationTime sets the time at which this file should expire (unless FileUpdateTransaction is used before then to
// extend its life). The file will automatically disappear at the fileExpirationTime, unless its expiration is extended
// by another transaction before that time. If the file is deleted, then its contents will become empty and it will be
// marked as deleted until it expires, and then it will cease to exist.
func (tx *FileCreateTransaction) SetExpirationTime(expiration time.Time) *FileCreateTransaction {
	tx._RequireNotFrozen()
	tx.expirationTime = &expiration
	return tx
}

func (tx *FileCreateTransaction) GetExpirationTime() time.Time {
	if tx.expirationTime != nil {
		return *tx.expirationTime
	}

	return time.Time{}
}

// SetContents sets the bytes that are the contents of the file (which can be empty). If the size of the file and other
// fields in the transaction exceed the max transaction size then FileCreateTransaction can be used to continue
// uploading the file.
func (tx *FileCreateTransaction) SetContents(contents []byte) *FileCreateTransaction {
	tx._RequireNotFrozen()
	tx.contents = contents
	return tx
}

// GetContents returns the bytes that are the contents of the file (which can be empty).
func (tx *FileCreateTransaction) GetContents() []byte {
	return tx.contents
}

// SetMemo Sets the memo associated with the file (UTF-8 encoding max 100 bytes)
func (tx *FileCreateTransaction) SetMemo(memo string) *FileCreateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo
	return tx
}

// GetMemo returns the memo associated with the file (UTF-8 encoding max 100 bytes)
func (tx *FileCreateTransaction) GetMemo() string {
	return tx.memo
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *FileCreateTransaction) Sign(
	privateKey PrivateKey,
) *FileCreateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *FileCreateTransaction) SignWithOperator(
	client *Client,
) (*FileCreateTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *FileCreateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *FileCreateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *FileCreateTransaction) AddSignature(publicKey PublicKey, signature []byte) *FileCreateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *FileCreateTransaction) SetGrpcDeadline(deadline *time.Duration) *FileCreateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *FileCreateTransaction) Freeze() (*FileCreateTransaction, error) {
	_, err := tx.FreezeWith(nil)
	return tx, err
}

func (tx *FileCreateTransaction) FreezeWith(client *Client) (*FileCreateTransaction, error) {
	if tx.IsFrozen() {
		return tx, nil
	}
	tx._InitFee(client)
	if err := tx._InitTransactionID(client); err != nil {
		return tx, err
	}
	body := tx.build()

	return tx, _TransactionFreezeWith(&tx.Transaction, client, body)
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *FileCreateTransaction) SetMaxTransactionFee(fee Hbar) *FileCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *FileCreateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *FileCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this FileCreateTransaction.
func (tx *FileCreateTransaction) SetTransactionMemo(memo string) *FileCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this FileCreateTransaction.
func (tx *FileCreateTransaction) SetTransactionValidDuration(duration time.Duration) *FileCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *FileCreateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this FileCreateTransaction.
func (tx *FileCreateTransaction) SetTransactionID(transactionID TransactionID) *FileCreateTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountID sets the _Node AccountID for this FileCreateTransaction.
func (tx *FileCreateTransaction) SetNodeAccountIDs(nodeID []AccountID) *FileCreateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *FileCreateTransaction) SetMaxRetry(count int) *FileCreateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *FileCreateTransaction) SetMaxBackoff(max time.Duration) *FileCreateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *FileCreateTransaction) SetMinBackoff(min time.Duration) *FileCreateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *FileCreateTransaction) SetLogLevel(level LogLevel) *FileCreateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *FileCreateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *FileCreateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *FileCreateTransaction) getName() string {
	return "FileCreateTransaction"
}
func (tx *FileCreateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_FileCreate{
			FileCreate: tx.buildProtoBody(),
		},
	}
}

func (tx *FileCreateTransaction) validateNetworkOnIDs(client *Client) error {
	return nil
}

func (tx *FileCreateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_FileCreate{
			FileCreate: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *FileCreateTransaction) buildProtoBody() *services.FileCreateTransactionBody {
	body := &services.FileCreateTransactionBody{
		Memo: tx.memo,
	}

	if tx.expirationTime != nil {
		body.ExpirationTime = _TimeToProtobuf(*tx.expirationTime)
	}

	if tx.keys != nil {
		body.Keys = tx.keys._ToProtoKeyList()
	}

	if tx.contents != nil {
		body.Contents = tx.contents
	}

	return body
}

func (tx *FileCreateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetFile().CreateFile,
	}
}
func (tx *FileCreateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: file_create_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationFileCreateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileCreateTransactionNoKey(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: UNAUTHORIZED", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: file_create_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"encoding/hex"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
	protobuf "google.golang.org/protobuf/proto"
)

func TestUnitFileCreateTransactionMock(t *testing.T) {
	t.Parallel()

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if bod, ok := transactionBody.Data.(*services.TransactionBody_FileCreate); ok {
			require.Equal(t, bod.FileCreate.Memo, "go sdk e2e tests")
			require.Equal(t, hex.EncodeToString(bod.FileCreate.Keys.Keys[0].GetEd25519()), "87deee7c3e3bd41d94d710531d529a1ae0c2e0463b27250072e177879267f501")
			require.Equal(t, bytes.Compare(bod.FileCreate.Contents, []byte("Hello, World")), 0)
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	_, err = NewFileCreateTransaction().
		SetKeys(newKey).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetContents([]byte("Hello, World")).
		SetMemo("go sdk e2e tests").
		Execute(client)
	require.NoError(t, err)
}

func TestUnitFileCreateTransactionGet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()

	transaction, err := NewFileCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKeys(newKey).
		SetContents([]byte("Hello, World")).
		SetMemo("").
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetKeys()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetContents()
	transaction.GetRegenerateTransactionID()
	transaction.GetMemo()
}

func TestUnitFileCreateTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewFileCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetKeys()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetContents()
	transaction.GetRegenerateTransactionID()
	transaction.GetMemo()
}

func TestUnitFileCreateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	transaction, err := NewFileCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKeys(newKey).
		SetContents([]byte{5, 6}).
		SetExpirationTime(time.Unix(4, 56)).
		SetMemo("memo").
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetFileCreate()
	require.Equal(t, proto.Keys.Keys[0].String(), newKey._ToProtoKey().String())
	require.Equal(t, proto.Contents, []byte{5, 6})
	require.Equal(t, proto.ExpirationTime.String(), _TimeToProtobuf(time.Unix(4, 56)).String())
	require.Equal(t, proto.Memo, "memo")
}

func TestUnitFileCreateTransactionCoverage(t *testing.T) {
	t.Parallel()

	grpc := time.Second * 30
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewFileCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKeys(newKey).
		SetMemo("yes").
		SetExpirationTime(time.Unix(23, 32)).
		SetContents([]byte{0}).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetKeys()
	transaction.GetMemo()
	transaction.GetExpirationTime()
	transaction.GetContents()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case FileCreateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}
// Filename: file_delete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"

	"time"
)

// FileDeleteTransaction Deletes the given file. After deletion, it will be marked as deleted and will have no contents.
// But information about it will continue to exist until it expires. A list of keys was given when
// the file was created. All the top level keys on that list must sign transactions to create or
// modify the file, but any single one of the top level keys can be used to delete the file. This
// transaction must be signed by 1-of-M KeyList keys. If keys contains additional KeyList or
// ThresholdKey then 1-of-M secondary KeyList or ThresholdKey signing requirements must be meet.
type FileDeleteTransaction struct {
	Transaction
	fileID *FileID
}

// NewFileDeleteTransaction creates a FileDeleteTransaction which deletes the given file. After deletion,
// it will be marked as deleted and will have no contents.
// But information about it will continue to exist until it expires. A list of keys was given when
// the file was created. All the top level keys on that list must sign transactions to create or
// modify the file, but any single one of the top level keys can be used to delete the file. This
// transaction must be signed by 1-of-M KeyList keys. If keys contains additional KeyList or
// ThresholdKey then 1-of-M secondary KeyList or ThresholdKey signing requirements must be meet.
func NewFileDeleteTransaction() *FileDeleteTransaction {
	tx := FileDeleteTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _FileDeleteTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *FileDeleteTransaction {
	return &FileDeleteTransaction{
		Transaction: tx,
		fileID:      _FileIDFromProtobuf(pb.GetFileDelete().GetFileID()),
	}
}

// SetFileID Sets the FileID of the file to be deleted
func (tx *FileDeleteTransaction) SetFileID(fileID FileID) *FileDeleteTransaction {
	tx._RequireNotFrozen()
	tx.fileID = &fileID
	return tx
}

// GetFileID returns the FileID of the file to be deleted
func (tx *FileDeleteTransaction) GetFileID() FileID {
	if tx.fileID == nil {
		return FileID{}
	}

	return *tx.fileID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *FileDeleteTransaction) Sign(
	privateKey PrivateKey,
) *FileDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *FileDeleteTransaction) SignWithOperator(
	client *Client,
) (*FileDeleteTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *FileDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *FileDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *FileDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *FileDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *FileDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *FileDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *FileDeleteTransaction) Freeze() (*FileDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *FileDeleteTransaction) FreezeWith(client *Client) (*FileDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// GetMaxTransactionFee returns the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *FileDeleteTransaction) GetMaxTransactionFee() Hbar {
	return tx.Transaction.GetMaxTransactionFee()
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *FileDeleteTransaction) SetMaxTransactionFee(fee Hbar) *FileDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *FileDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *FileDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this FileDeleteTransaction.
func (tx *FileDeleteTransaction) SetTransactionMemo(memo string) *FileDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this FileDeleteTransaction.
func (tx *FileDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *FileDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *FileDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this FileDeleteTransaction.
func (tx *FileDeleteTransaction) SetTransactionID(transactionID TransactionID) *FileDeleteTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountID sets the _Node AccountID for this FileDeleteTransaction.
func (tx *FileDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *FileDeleteTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *FileDeleteTransaction) SetMaxRetry(count int) *FileDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *FileDeleteTransaction) SetMaxBackoff(max time.Duration) *FileDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *FileDeleteTransaction) SetMinBackoff(min time.Duration) *FileDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *FileDeleteTransaction) SetLogLevel(level LogLevel) *FileDeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *FileDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *FileDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *FileDeleteTransaction) getName() string {
	return "FileDeleteTransaction"
}
func (tx *FileDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.fileID != nil {
		if err := tx.fileID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *FileDeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_FileDelete{
			FileDelete: tx.buildProtoBody(),
		},
	}
}

func (tx *FileDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_FileDelete{
			FileDelete: tx.buildProtoBody(),
		},
	}, nil
}
func (tx *FileDeleteTransaction) buildProtoBody() *services.FileDeleteTransactionBody {
	body := &services.FileDeleteTransactionBody{}
	if tx.fileID != nil {
		body.FileID = tx.fileID._ToProtobuf()
	}
	return body
}

func (tx *FileDeleteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetFile().DeleteFile,
	}
}
func (tx *FileDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: file_delete_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationFileDeleteTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileDeleteTransactionNothingSet(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	resp, err = NewFileDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Contains(t, err.Error(), "exceptional precheck status INVALID_FILE_ID")
	}
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: file_delete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitFileDeleteTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	fileDelete := NewFileDeleteTransaction().
		SetFileID(fileID)

	err = fileDelete.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitFileDeleteTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	fileDelete := NewFileDeleteTransaction().
		SetFileID(fileID)

	err = fileDelete.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitFileDeleteTransactionMock(t *testing.T) {
	t.Parallel()

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
				key, _ := PrivateKeyFromStringEd25519("302e020100300506032b657004220420d45e1557156908c967804615af59a000be88c7aa7058bfcbe0f46b16c28f887d")
				require.Equal(t, key.PublicKey().String(), pbTemp.String())
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if bod, ok := transactionBody.Data.(*services.TransactionBody_FileDelete); ok {
			require.Equal(t, bod.FileDelete.FileID.FileNum, int64(3))
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewFileDeleteTransaction().
		SetFileID(FileID{File: 3}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitFileDeleteTransactionGet(t *testing.T) {
	t.Parallel()

	fileID := FileID{File: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewFileDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetFileID(fileID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetFileID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitFileDeleteTransactionNothingSet(t *testing.T) {
	t.Parallel()

	fileID := FileID{File: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewFileDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetFileID(fileID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetFileID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitFileDeleteTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	file := FileID{File: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewFileDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetFileID(file).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetFileID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case FileDeleteTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}
// Filename: file_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
	protobuf "google.golang.org/protobuf/proto"
)

// A FileID is the ID for a file on the _Network.
type FileID struct {
	Shard    uint64
	Realm    uint64
	File     uint64
	checksum *string
}

// FileIDForAddressBook returns the public node address book for the current network.
func FileIDForAddressBook() FileID {
	return FileID{File: 102}
}

// FileIDForFeeSchedule returns the current fee schedule for the network.
func FileIDForFeeSchedule() FileID {
	return FileID{File: 111}
}

// FileIDForExchangeRate returns the current exchange rates of HBAR to USD.
func FileIDForExchangeRate() FileID {
	return FileID{File: 112}
}

// FileIDFromString returns a FileID parsed from the given string.
// A malformatted string will cause this to return an error instead.
func FileIDFromString(data string) (FileID, error) {
	shard, realm, num, checksum, err := _IdFromString(data)
	if err != nil {
		return FileID{}, err
	}

	return FileID{
		Shard:    uint64(shard),
		Realm:    uint64(realm),
		File:     uint64(num),
		checksum: checksum,
	}, nil
}

// Verify that the client has a valid checksum.
func (id *FileID) ValidateChecksum(client *Client) error {
	if !id._IsZero() && client != nil {
		var tempChecksum _ParseAddressResult
		var err error
		tempChecksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.File))
		if err != nil {
			return err
		}
		err = _ChecksumVerify(tempChecksum.status)
		if err != nil {
			return err
		}
		if id.checksum == nil {
			return errChecksumMissing
		}
		if tempChecksum.correctChecksum != *id.checksum {
			networkName := NetworkNameOther
			if client.network.ledgerID != nil {
				networkName, _ = client.network.ledgerID.ToNetworkName()
			}
			return errors.New(fmt.Sprintf("network mismatch or wrong checksum given, given checksum: %s, correct checksum %s, network: %s",
				*id.checksum,
				tempChecksum.correctChecksum,
				networkName))
		}
	}

	return nil
}

// Deprecated - use ValidateChecksum instead
func (id *FileID) Validate(client *Client) error {
	return id.ValidateChecksum(client)
}

// FileIDFromSolidityAddress returns a FileID parsed from the given solidity address.
func FileIDFromSolidityAddress(s string) (FileID, error) {
	shard, realm, file, err := _IdFromSolidityAddress(s)
	if err != nil {
		return FileID{}, err
	}

	return FileID{
		Shard: shard,
		Realm: realm,
		File:  file,
	}, nil
}

func (id FileID) _IsZero() bool {
	return id.Shard == 0 && id.Realm == 0 && id.File == 0
}

// String returns the string representation of a FileID in the format used within protobuf.
func (id FileID) String() string {
	return fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.File)
}

// ToStringWithChecksum returns the string representation of a FileId with checksum.
func (id FileID) ToStringWithChecksum(client Client) (string, error) {
	if client.GetNetworkName() == nil && client.GetLedgerID() == nil {
		return "", errNetworkNameMissing
	}
	var checksum _ParseAddressResult
	var err error
	if client.network.ledgerID != nil {
		checksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.File))
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%d.%d.%d-%s", id.Shard, id.Realm, id.File, checksum.correctChecksum), nil
}

// ToSolidityAddress returns the string representation of a FileID in the format used by Solidity.
func (id FileID) ToSolidityAddress() string {
	return _IdToSolidityAddress(id.Shard, id.Realm, id.File)
}

func (id FileID) _ToProtobuf() *services.FileID {
	return &services.FileID{
		ShardNum: int64(id.Shard),
		RealmNum: int64(id.Realm),
		FileNum:  int64(id.File),
	}
}

func _FileIDFromProtobuf(fileID *services.FileID) *FileID {
	if fileID == nil {
		return nil
	}

	return &FileID{
		Shard: uint64(fileID.ShardNum),
		Realm: uint64(fileID.RealmNum),
		File:  uint64(fileID.FileNum),
	}
}

// ToBytes returns a byte array representation of the FileID
func (id FileID) ToBytes() []byte {
	data, err := protobuf.Marshal(id._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// FileIDFromBytes returns a FileID from a byte array
func FileIDFromBytes(data []byte) (FileID, error) {
	if data == nil {
		return FileID{}, errByteArrayNull
	}
	pb := services.FileID{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return FileID{}, err
	}

	return *_FileIDFromProtobuf(&pb), nil
}
// Filename: file_id_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnitFileIDChecksumFromString(t *testing.T) {
	t.Parallel()

	id, err := FileIDFromString("0.0.123-rmkyk")
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	id.ToStringWithChecksum(*client)
	sol := id.ToSolidityAddress()
	FileIDFromSolidityAddress(sol)
	id.Validate(client)

	pb := id._ToProtobuf()
	_FileIDFromProtobuf(pb)

	idByte := id.ToBytes()
	FileIDFromBytes(idByte)

	require.Equal(t, FileID{File: 111}.String(), FileIDForFeeSchedule().String())
	require.Equal(t, FileID{File: 102}.String(), FileIDForAddressBook().String())
	require.Equal(t, FileID{File: 112}.String(), FileIDForExchangeRate().String())

	assert.Equal(t, id.File, uint64(123))
}

func TestUnitFileIDChecksumToString(t *testing.T) {
	t.Parallel()

	id := AccountID{
		Shard:   50,
		Realm:   150,
		Account: 520,
	}
	assert.Equal(t, "50.150.520", id.String())
}
// Filename: file_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// FileInfo contains the details about a file stored on Hedera
type FileInfo struct {
	FileID         FileID
	Size           int64
	ExpirationTime time.Time
	IsDeleted      bool
	Keys           KeyList
	FileMemo       string
	LedgerID       LedgerID
}

func _FileInfoFromProtobuf(fileInfo *services.FileGetInfoResponse_FileInfo) (FileInfo, error) {
	if fileInfo == nil {
		return FileInfo{}, errParameterNull
	}
	var keys KeyList
	var err error
	if fileInfo.Keys != nil {
		keys, err = _KeyListFromProtobuf(fileInfo.Keys)
		if err != nil {
			return FileInfo{}, err
		}
	}

	fileID := FileID{}
	if fileInfo.FileID != nil {
		fileID = *_FileIDFromProtobuf(fileInfo.FileID)
	}

	return FileInfo{
		FileID:         fileID,
		Size:           fileInfo.Size,
		ExpirationTime: _TimeFromProtobuf(fileInfo.ExpirationTime),
		IsDeleted:      fileInfo.Deleted,
		Keys:           keys,
		FileMemo:       fileInfo.Memo,
		LedgerID:       LedgerID{fileInfo.LedgerId},
	}, nil
}

func (fileInfo *FileInfo) _ToProtobuf() *services.FileGetInfoResponse_FileInfo {
	return &services.FileGetInfoResponse_FileInfo{
		FileID: fileInfo.FileID._ToProtobuf(),
		Size:   fileInfo.Size,
		ExpirationTime: &services.Timestamp{
			Seconds: int64(fileInfo.ExpirationTime.Second()),
			Nanos:   int32(fileInfo.ExpirationTime.Nanosecond()),
		},
		Deleted:  fileInfo.IsDeleted,
		Keys:     fileInfo.Keys._ToProtoKeyList(),
		Memo:     fileInfo.FileMemo,
		LedgerId: fileInfo.LedgerID.ToBytes(),
	}
}

// ToBytes returns the byte representation of the FileInfo
func (fileInfo FileInfo) ToBytes() []byte {
	data, err := protobuf.Marshal(fileInfo._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// FileInfoFromBytes returns a FileInfo object from a raw byte array
func FileInfoFromBytes(data []byte) (FileInfo, error) {
	if data == nil {
		return FileInfo{}, errByteArrayNull
	}
	pb := services.FileGetInfoResponse_FileInfo{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return FileInfo{}, err
	}

	info, err := _FileInfoFromProtobuf(&pb)
	if err != nil {
		return FileInfo{}, err
	}

	return info, nil
}
// Filename: file_info_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// FileInfoQuery is a query which can be used to get all of the information about a file, except for its contents.
// When a file expires, it no longer exists, and there will be no info about it, and the fileInfo field will be blank.
// If a transaction or smart contract deletes the file, but it has not yet expired, then the
// fileInfo field will be non-empty, the deleted field will be true, its size will be 0,
// and its contents will be empty. Note that each file has a FileID, but does not have a filename.
type FileInfoQuery struct {
	Query
	fileID *FileID
}

// NewFileInfoQuery creates a FileInfoQuery which can be used to get all of the information about a file, except for its contents.
func NewFileInfoQuery() *FileInfoQuery {
	header := services.QueryHeader{}
	return &FileInfoQuery{
		Query: _NewQuery(true, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *FileInfoQuery) SetGrpcDeadline(deadline *time.Duration) *FileInfoQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetFileID sets the FileID of the file whose info is requested.
func (q *FileInfoQuery) SetFileID(fileID FileID) *FileInfoQuery {
	q.fileID = &fileID
	return q
}

// GetFileID returns the FileID of the file whose info is requested.
func (q *FileInfoQuery) GetFileID() FileID {
	if q.fileID == nil {
		return FileID{}
	}

	return *q.fileID
}

func (q *FileInfoQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *FileInfoQuery) Execute(client *Client) (FileInfo, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return FileInfo{}, err
	}

	info, err := _FileInfoFromProtobuf(resp.GetFileGetInfo().FileInfo)
	if err != nil {
		return FileInfo{}, err
	}

	return info, nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *FileInfoQuery) SetMaxQueryPayment(maxPayment Hbar) *FileInfoQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *FileInfoQuery) SetQueryPayment(paymentAmount Hbar) *FileInfoQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this FileInfoQuery.
func (q *FileInfoQuery) SetNodeAccountIDs(accountID []AccountID) *FileInfoQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *FileInfoQuery) SetMaxRetry(count int) *FileInfoQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *FileInfoQuery) SetMaxBackoff(max time.Duration) *FileInfoQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *FileInfoQuery) SetMinBackoff(min time.Duration) *FileInfoQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *FileInfoQuery) SetPaymentTransactionID(transactionID TransactionID) *FileInfoQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *FileInfoQuery) SetLogLevel(level LogLevel) *FileInfoQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *FileInfoQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetFile().GetFileInfo,
	}
}

func (q *FileInfoQuery) getName() string {
	return "FileInfoQuery"
}

func (q *FileInfoQuery) buildQuery() *services.Query {
	body := &services.FileGetInfoQuery{
		Header: q.pbHeader,
	}

	if q.fileID != nil {
		body.FileID = q.fileID._ToProtobuf()
	}

	return &services.Query{
		Query: &services.Query_FileGetInfo{
			FileGetInfo: body,
		},
	}
}

func (q *FileInfoQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.fileID != nil {
		if err := q.fileID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *FileInfoQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetFileGetInfo()
}
// Filename: file_info_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationFileInfoQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	info, err := NewFileInfoQuery().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, *fileID, info.FileID)
	assert.Equal(t, info.Size, int64(12))
	assert.False(t, info.IsDeleted)
	assert.NotNil(t, info.Keys)

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileInfoQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	fileInfo := NewFileInfoQuery().
		SetFileID(*fileID).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := fileInfo.GetCost(env.Client)
	require.NoError(t, err)

	info, err := fileInfo.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, *fileID, info.FileID)
	assert.Equal(t, info.Size, int64(12))
	assert.False(t, info.IsDeleted)

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileInfoQuerySetBigMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	fileInfo := NewFileInfoQuery().
		SetFileID(*fileID).
		SetMaxQueryPayment(NewHbar(10000)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	_, err = fileInfo.GetCost(env.Client)
	require.NoError(t, err)

	info, err := fileInfo.Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, *fileID, info.FileID)
	assert.Equal(t, info.Size, int64(12))
	assert.False(t, info.IsDeleted)

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileInfoQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	fileInfo := NewFileInfoQuery().
		SetFileID(*fileID).
		SetMaxQueryPayment(HbarFromTinybar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	cost, err := fileInfo.GetCost(env.Client)
	require.NoError(t, err)

	_, err = fileInfo.Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "cost of FileInfoQuery ("+cost.String()+") without explicit payment is greater than the max query payment of 1 tℏ", err.Error())
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileInfoQueryInsufficientFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := receipt.FileID
	assert.NotNil(t, fileID)

	fileInfo := NewFileInfoQuery().
		SetFileID(*fileID).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID})

	_, err = fileInfo.GetCost(env.Client)
	require.NoError(t, err)

	_, err = fileInfo.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_TX_FEE", err.Error())
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(*fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileInfoQueryNoFileID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewFileInfoQuery().
		SetQueryPayment(NewHbar(1)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_FILE_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: file_info_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitFileInfoQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	fileInfo := NewFileInfoQuery().
		SetFileID(fileID)

	err = fileInfo.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitFileInfoQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	fileInfo := NewFileInfoQuery().
		SetFileID(fileID)

	err = fileInfo.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitFileInfoQueryMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)
	key := newKey.PublicKey().BytesRaw()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_FileGetInfo{
				FileGetInfo: &services.FileGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_FileGetInfo{
				FileGetInfo: &services.FileGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_FileGetInfo{
				FileGetInfo: &services.FileGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					FileInfo: &services.FileGetInfoResponse_FileInfo{
						FileID:         &services.FileID{FileNum: 3},
						Size:           10,
						ExpirationTime: nil,
						Deleted:        false,
						Keys: &services.KeyList{
							Keys: []*services.Key{
								{
									Key: &services.Key_Ed25519{
										Ed25519: key,
									},
								},
							},
						},
						Memo:     "no memo",
						LedgerId: []byte{0},
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewFileInfoQuery().
		SetFileID(FileID{File: 3}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMaxQueryPayment(NewHbar(1))

	cost, err := query.GetCost(client)
	require.NoError(t, err)
	require.Equal(t, cost, HbarFromTinybar(2))

	result, err := query.Execute(client)
	require.NoError(t, err)

	require.Equal(t, result.Keys.keys[0].String(), newKey.PublicKey().String())
	require.Equal(t, result.FileMemo, "no memo")
	require.Equal(t, result.IsDeleted, false)
	require.True(t, result.LedgerID.IsMainnet())
}

func TestUnitFileInfoQueryGet(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	fileID := FileID{File: 3, checksum: &checksum}
	deadline := time.Duration(time.Minute)
	accountId := AccountID{Account: 123}
	transactionID := TransactionIDGenerate(accountId)
	query := NewFileInfoQuery().
		SetFileID(fileID).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}}).
		SetGrpcDeadline(&deadline).
		SetMaxBackoff(1 * time.Minute).
		SetMinBackoff(500 * time.Millisecond).
		SetMaxRetry(5).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(500))
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)
	require.Equal(t, fileID, query.GetFileID())
	require.Equal(t, []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}, query.GetNodeAccountIDs())
	require.Equal(t, 500*time.Millisecond, query.GetMinBackoff())
	require.Equal(t, 1*time.Minute, query.GetMaxBackoff())
	require.Equal(t, 5, query.GetMaxRetryCount())
	require.Equal(t, transactionID, query.GetPaymentTransactionID())
	require.Equal(t, HbarFromTinybar(25), query.GetQueryPayment())
	require.Equal(t, NewHbar(500), query.GetMaxQueryPayment())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}

func TestUnitFileInfoQuerySetNothing(t *testing.T) {
	t.Parallel()

	balance := NewFileInfoQuery()

	require.Equal(t, FileID{}, balance.GetFileID())
	require.Equal(t, []AccountID{}, balance.GetNodeAccountIDs())
	require.Equal(t, 250*time.Millisecond, balance.GetMinBackoff())
	require.Equal(t, 8*time.Second, balance.GetMaxBackoff())
	require.Equal(t, 10, balance.GetMaxRetryCount())
	require.Equal(t, TransactionID{}, balance.GetPaymentTransactionID())
	require.Equal(t, Hbar{}, balance.GetQueryPayment())
	require.Equal(t, Hbar{}, balance.GetMaxQueryPayment())
}
// Filename: file_update_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// FileUpdateTransaction
// Modify the metadata and/or contents of a file. If a field is not set in the transaction body, the
// corresponding file attribute will be unchanged. This transaction must be signed by all the keys
// in the top level of a key list (M-of-M) of the file being updated. If the keys themselves are
// being updated, then the transaction must also be signed by all the new keys. If the keys contain
// additional KeyList or ThresholdKey then M-of-M secondary KeyList or ThresholdKey signing
// requirements must be meet
type FileUpdateTransaction struct {
	Transaction
	fileID         *FileID
	keys           *KeyList
	expirationTime *time.Time
	contents       []byte
	memo           string
}

// NewFileUpdateTransaction creates a FileUpdateTransaction which modifies the metadata and/or contents of a file.
// If a field is not set in the transaction body, the corresponding file attribute will be unchanged.
// tx transaction must be signed by all the keys in the top level of a key list (M-of-M) of the file being updated.
// If the keys themselves are being updated, then the transaction must also be signed by all the new keys. If the keys contain
// additional KeyList or ThresholdKey then M-of-M secondary KeyList or ThresholdKey signing
// requirements must be meet
func NewFileUpdateTransaction() *FileUpdateTransaction {
	tx := FileUpdateTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(5))
	return &tx
}

func _FileUpdateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *FileUpdateTransaction {
	keys, _ := _KeyListFromProtobuf(pb.GetFileUpdate().GetKeys())
	expiration := _TimeFromProtobuf(pb.GetFileUpdate().GetExpirationTime())

	return &FileUpdateTransaction{
		Transaction:    tx,
		fileID:         _FileIDFromProtobuf(pb.GetFileUpdate().GetFileID()),
		keys:           &keys,
		expirationTime: &expiration,
		contents:       pb.GetFileUpdate().GetContents(),
		memo:           pb.GetFileUpdate().GetMemo().Value,
	}
}

// SetFileID Sets the FileID to be updated
func (tx *FileUpdateTransaction) SetFileID(fileID FileID) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	tx.fileID = &fileID
	return tx
}

// GetFileID returns the FileID to be updated
func (tx *FileUpdateTransaction) GetFileID() FileID {
	if tx.fileID == nil {
		return FileID{}
	}

	return *tx.fileID
}

// SetKeys Sets the new list of keys that can modify or delete the file
func (tx *FileUpdateTransaction) SetKeys(keys ...Key) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	if tx.keys == nil {
		tx.keys = &KeyList{keys: []Key{}}
	}
	keyList := NewKeyList()
	keyList.AddAll(keys)

	tx.keys = keyList

	return tx
}

func (tx *FileUpdateTransaction) GetKeys() KeyList {
	if tx.keys != nil {
		return *tx.keys
	}

	return KeyList{}
}

// SetExpirationTime Sets the new expiry time
func (tx *FileUpdateTransaction) SetExpirationTime(expiration time.Time) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	tx.expirationTime = &expiration
	return tx
}

// GetExpirationTime returns the new expiry time
func (tx *FileUpdateTransaction) GetExpirationTime() time.Time {
	if tx.expirationTime != nil {
		return *tx.expirationTime
	}

	return time.Time{}
}

// SetContents Sets the new contents that should overwrite the file's current contents
func (tx *FileUpdateTransaction) SetContents(contents []byte) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	tx.contents = contents
	return tx
}

// GetContents returns the new contents that should overwrite the file's current contents
func (tx *FileUpdateTransaction) GetContents() []byte {
	return tx.contents
}

// SetFileMemo Sets the new memo to be associated with the file (UTF-8 encoding max 100 bytes)
func (tx *FileUpdateTransaction) SetFileMemo(memo string) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo

	return tx
}

// GeFileMemo
// Deprecated: use GetFileMemo()
func (tx *FileUpdateTransaction) GeFileMemo() string {
	return tx.memo
}

func (tx *FileUpdateTransaction) GetFileMemo() string {
	return tx.memo
}

// ----- Required Interfaces ------- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *FileUpdateTransaction) Sign(
	privateKey PrivateKey,
) *FileUpdateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *FileUpdateTransaction) SignWithOperator(
	client *Client,
) (*FileUpdateTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *FileUpdateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *FileUpdateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *FileUpdateTransaction) AddSignature(publicKey PublicKey, signature []byte) *FileUpdateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when tx deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *FileUpdateTransaction) SetGrpcDeadline(deadline *time.Duration) *FileUpdateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *FileUpdateTransaction) Freeze() (*FileUpdateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *FileUpdateTransaction) FreezeWith(client *Client) (*FileUpdateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *FileUpdateTransaction) SetMaxTransactionFee(fee Hbar) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *FileUpdateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this FileUpdateTransaction.
func (tx *FileUpdateTransaction) SetTransactionMemo(memo string) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this FileUpdateTransaction.
func (tx *FileUpdateTransaction) SetTransactionValidDuration(duration time.Duration) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *FileUpdateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this FileUpdateTransaction.
func (tx *FileUpdateTransaction) SetTransactionID(transactionID TransactionID) *FileUpdateTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountID sets the _Node AccountID for this FileUpdateTransaction.
func (tx *FileUpdateTransaction) SetNodeAccountIDs(nodeID []AccountID) *FileUpdateTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *FileUpdateTransaction) SetMaxRetry(count int) *FileUpdateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *FileUpdateTransaction) SetMaxBackoff(max time.Duration) *FileUpdateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *FileUpdateTransaction) SetMinBackoff(min time.Duration) *FileUpdateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *FileUpdateTransaction) SetLogLevel(level LogLevel) *FileUpdateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *FileUpdateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *FileUpdateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *FileUpdateTransaction) getName() string {
	return "FileUpdateTransaction"
}
func (tx *FileUpdateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.fileID != nil {
		if err := tx.fileID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}
func (tx *FileUpdateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_FileUpdate{
			FileUpdate: tx.buildProtoBody(),
		},
	}
}
func (tx *FileUpdateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_FileUpdate{
			FileUpdate: tx.buildProtoBody(),
		},
	}, nil
}
func (tx *FileUpdateTransaction) buildProtoBody() *services.FileUpdateTransactionBody {
	body := &services.FileUpdateTransactionBody{
		Memo: &wrapperspb.StringValue{Value: tx.memo},
	}
	if tx.fileID != nil {
		body.FileID = tx.fileID._ToProtobuf()
	}

	if tx.expirationTime != nil {
		body.ExpirationTime = _TimeToProtobuf(*tx.expirationTime)
	}

	if tx.keys != nil {
		body.Keys = tx.keys._ToProtoKeyList()
	}

	if tx.contents != nil {
		body.Contents = tx.contents
	}

	return body
}
func (tx *FileUpdateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetFile().UpdateFile,
	}
}
func (tx *FileUpdateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: file_update_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationFileUpdateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	var newContents = []byte("Good Night, World")

	resp, err = NewFileUpdateTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetContents(newContents).
		Execute(env.Client)

	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	contents, err := NewFileContentsQuery().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, newContents, contents)

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileUpdateTransactionNoFileID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewFileCreateTransaction().
		SetKeys(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetContents([]byte("Hello, World")).
		SetTransactionMemo("go sdk e2e tests").
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	fileID := *receipt.FileID
	assert.NotNil(t, fileID)

	_, err = NewFileUpdateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	if err != nil {
		assert.Contains(t, err.Error(), "exceptional precheck status INVALID_FILE_ID")
	}

	resp, err = NewFileDeleteTransaction().
		SetFileID(fileID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: file_update_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitFileUpdateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	fileUpdate := NewFileUpdateTransaction().
		SetFileID(fileID)

	err = fileUpdate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitFileUpdateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	fileID, err := FileIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	fileUpdate := NewFileUpdateTransaction().
		SetFileID(fileID)

	err = fileUpdate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitFileUpdateTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		key, _ := PrivateKeyFromStringEd25519("302e020100300506032b657004220420d45e1557156908c967804615af59a000be88c7aa7058bfcbe0f46b16c28f887d")
		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		require.Equal(t, bytes.Compare(sigMap.SigPair[1].PubKeyPrefix, key.PublicKey().BytesRaw()), 0)
		require.Equal(t, bytes.Compare(sigMap.SigPair[0].PubKeyPrefix, newKey.PublicKey().BytesRaw()), 0)

		if bod, ok := transactionBody.Data.(*services.TransactionBody_FileUpdate); ok {
			require.Equal(t, bod.FileUpdate.FileID.FileNum, int64(3))
			require.Equal(t, bytes.Compare(bod.FileUpdate.Contents, []byte{123}), 0)
			require.Equal(t, bod.FileUpdate.Memo, &wrapperspb.StringValue{Value: "no memo"})
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	freez, err := NewFileUpdateTransaction().
		SetFileID(FileID{File: 3}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetFileMemo("no memo").
		SetKeys(newKey).
		SetContents([]byte{123}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}

func TestUnitFileUpdateTransactionGet(t *testing.T) {
	t.Parallel()

	fileID := FileID{File: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()

	transaction, err := NewFileUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKeys(newKey).
		SetContents([]byte{}).
		SetFileID(fileID).
		SetFileMemo("").
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetKeys()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetContents()
	transaction.GetRegenerateTransactionID()
	transaction.GetFileID()
	transaction.GetFileMemo()
}

func TestUnitFileUpdateTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewFileUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetKeys()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetContents()
	transaction.GetRegenerateTransactionID()
	transaction.GetFileID()
	transaction.GetFileMemo()
}

func TestUnitFileUpdateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	fileID := FileID{File: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	transaction, err := NewFileUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKeys(newKey).
		SetContents([]byte{5, 6}).
		SetFileID(fileID).
		SetFileMemo("").
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetFileUpdate()
	require.Equal(t, proto.Keys.Keys[0].String(), newKey._ToProtoKey().String())
	require.Equal(t, proto.Contents, []byte{5, 6})
	require.Equal(t, proto.FileID.String(), fileID._ToProtobuf().String())
}

func TestUnitFileUpdateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	file := FileID{File: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewFileUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKeys(newKey).
		SetFileMemo("yes").
		SetExpirationTime(time.Unix(23, 32)).
		SetContents([]byte{0}).
		SetFileID(file).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetKeys()
	transaction.GetFileMemo()
	transaction.GetExpirationTime()
	transaction.GetContents()
	transaction.GetExpirationTime()
	transaction.GetFileID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case FileUpdateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}
// Filename: freeze_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"

	"time"
)

type FreezeTransaction struct {
	Transaction
	startTime  time.Time
	endTime    time.Time
	fileID     *FileID
	fileHash   []byte
	freezeType FreezeType
}

func NewFreezeTransaction() *FreezeTransaction {
	tx := FreezeTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _FreezeTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *FreezeTransaction {
	startTime := time.Date(
		time.Now().Year(), time.Now().Month(), time.Now().Day(),
		int(pb.GetFreeze().GetStartHour()), int(pb.GetFreeze().GetStartMin()), // nolint
		0, time.Now().Nanosecond(), time.Now().Location(),
	)

	endTime := time.Date(
		time.Now().Year(), time.Now().Month(), time.Now().Day(),
		int(pb.GetFreeze().GetEndHour()), int(pb.GetFreeze().GetEndMin()), // nolint
		0, time.Now().Nanosecond(), time.Now().Location(),
	)

	return &FreezeTransaction{
		Transaction: tx,
		startTime:   startTime,
		endTime:     endTime,
		fileID:      _FileIDFromProtobuf(pb.GetFreeze().GetUpdateFile()),
		fileHash:    pb.GetFreeze().FileHash,
	}
}

func (tx *FreezeTransaction) SetStartTime(startTime time.Time) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.startTime = startTime
	return tx
}

func (tx *FreezeTransaction) GetStartTime() time.Time {
	return tx.startTime
}

// Deprecated
func (tx *FreezeTransaction) SetEndTime(endTime time.Time) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.endTime = endTime
	return tx
}

// Deprecated
func (tx *FreezeTransaction) GetEndTime() time.Time {
	return tx.endTime
}

func (tx *FreezeTransaction) SetFileID(id FileID) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.fileID = &id
	return tx
}

func (tx *FreezeTransaction) GetFileID() *FileID {
	return tx.fileID
}

func (tx *FreezeTransaction) SetFreezeType(freezeType FreezeType) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.freezeType = freezeType
	return tx
}

func (tx *FreezeTransaction) GetFreezeType() FreezeType {
	return tx.freezeType
}

func (tx *FreezeTransaction) SetFileHash(hash []byte) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.fileHash = hash
	return tx
}

func (tx *FreezeTransaction) GetFileHash() []byte {
	return tx.fileHash
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *FreezeTransaction) Sign(
	privateKey PrivateKey,
) *FreezeTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *FreezeTransaction) SignWithOperator(
	client *Client,
) (*FreezeTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *FreezeTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *FreezeTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *FreezeTransaction) AddSignature(publicKey PublicKey, signature []byte) *FreezeTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

func (tx *FreezeTransaction) Freeze() (*FreezeTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *FreezeTransaction) FreezeWith(client *Client) (*FreezeTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// GetMaxTransactionFee returns the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *FreezeTransaction) GetMaxTransactionFee() Hbar {
	return tx.Transaction.GetMaxTransactionFee()
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *FreezeTransaction) SetMaxTransactionFee(fee Hbar) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *FreezeTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this FreezeTransaction.
func (tx *FreezeTransaction) SetTransactionMemo(memo string) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this FreezeTransaction.
func (tx *FreezeTransaction) SetTransactionValidDuration(duration time.Duration) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *FreezeTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this FreezeTransaction.
func (tx *FreezeTransaction) SetTransactionID(transactionID TransactionID) *FreezeTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountID sets the _Node AccountID for this FreezeTransaction.
func (tx *FreezeTransaction) SetNodeAccountIDs(nodeID []AccountID) *FreezeTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *FreezeTransaction) SetMaxRetry(count int) *FreezeTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *FreezeTransaction) SetMaxBackoff(max time.Duration) *FreezeTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *FreezeTransaction) SetMinBackoff(min time.Duration) *FreezeTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *FreezeTransaction) SetLogLevel(level LogLevel) *FreezeTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *FreezeTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *FreezeTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *FreezeTransaction) getName() string {
	return "FreezeTransaction"
}
func (tx *FreezeTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_Freeze{
			Freeze: tx.buildProtoBody(),
		},
	}
}
func (tx *FreezeTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_Freeze{
			Freeze: tx.buildProtoBody(),
		},
	}, nil
}
func (tx *FreezeTransaction) buildProtoBody() *services.FreezeTransactionBody {
	body := &services.FreezeTransactionBody{
		FileHash:   tx.fileHash,
		StartTime:  _TimeToProtobuf(tx.startTime),
		FreezeType: services.FreezeType(tx.freezeType),
	}

	if tx.fileID != nil {
		body.UpdateFile = tx.fileID._ToProtobuf()
	}

	return body
}
func (tx *FreezeTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetFreeze().Freeze,
	}
}
func (tx *FreezeTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: freeze_type.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import "fmt"

type FreezeType int32

const (
	FreezeTypeUnknown          FreezeType = 0
	FreezeTypeFreezeOnly       FreezeType = 1
	FreezeTypePrepareUpgrade   FreezeType = 2
	FreezeTypeFreezeUpgrade    FreezeType = 3
	FreezeTypeFreezeAbort      FreezeType = 4
	FreezeTypeTelemetryUpgrade FreezeType = 5
)

func (freezeType FreezeType) String() string {
	switch freezeType {
	case FreezeTypeUnknown:
		return "UNKNOWN_FREEZE_TYPE"
	case FreezeTypeFreezeOnly:
		return "FREEZE_ONLY"
	case FreezeTypePrepareUpgrade:
		return "PREPARE_UPGRADE"
	case FreezeTypeFreezeUpgrade:
		return "FREEZE_UPGRADE"
	case FreezeTypeFreezeAbort:
		return "FREEZE_ABORT"
	case FreezeTypeTelemetryUpgrade:
		return "TELEMETRY_UPGRADE"
	}

	panic(fmt.Sprintf("unreacahble: FreezeType.String() switch statement is non-exhaustive. Status: %v", uint32(freezeType)))
}
// Filename: hbar.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"math"
	"regexp"
	"strconv"

	"github.com/pkg/errors"
)

// Hbar is a typesafe wrapper around values of HBAR providing foolproof conversions to other denominations.
type Hbar struct {
	tinybar int64
}

// MaxHbar is the maximum amount the Hbar type can wrap.
var MaxHbar = Hbar{math.MaxInt64}

// MinHbar is the minimum amount the Hbar type can wrap.
var MinHbar = Hbar{math.MinInt64}

// ZeroHbar wraps a 0 value of Hbar.
var ZeroHbar = Hbar{0}

// HbarFrom creates a representation of Hbar in tinybar on the unit provided
func HbarFrom(bars float64, unit HbarUnit) Hbar {
	return HbarFromTinybar(int64(bars * float64(unit._NumberOfTinybar())))
}

// HbarFromTinybar creates a representation of Hbar in tinybars
func HbarFromTinybar(tinybar int64) Hbar {
	return Hbar{tinybar}
}

// NewHbar constructs a new Hbar from a possibly fractional amount of hbar.
func NewHbar(hbar float64) Hbar {
	return HbarFrom(hbar, HbarUnits.Hbar)
}

// AsTinybar returns the equivalent tinybar amount.
func (hbar Hbar) AsTinybar() int64 {
	return hbar.tinybar
}

// As returns the equivalent amount in the given unit.
func (hbar Hbar) As(unit HbarUnit) float64 {
	return float64(hbar.tinybar) / float64(unit._NumberOfTinybar())
}

// String returns a string representation of the Hbar value.
func (hbar Hbar) String() string {
	// Format the string as tinybar if the value is 1000 tinybar or less
	if -10000 <= hbar.tinybar && hbar.tinybar <= 10000 {
		return fmt.Sprintf("%v %s", hbar.tinybar, HbarUnits.Tinybar.Symbol())
	}

	return fmt.Sprintf("%v %s", float64(hbar.tinybar)/float64(HbarUnits.Hbar._NumberOfTinybar()), HbarUnits.Hbar.Symbol())
}

// HbarFromString returns a Hbar representation of the string provided.
func HbarFromString(hbar string) (Hbar, error) {
	var err error
	match := regexp.MustCompile(`^((?:\+|\-)?\d+(?:\.\d+)?)(?: (tℏ|μℏ|mℏ|ℏ|kℏ|Mℏ|Gℏ))?$`)

	matchArray := match.FindStringSubmatch(hbar)
	if len(matchArray) == 0 {
		return Hbar{}, errors.New("invalid number and/or symbol")
	}

	a, err := strconv.ParseFloat(matchArray[1], 64)
	if err != nil {
		return Hbar{}, err
	}

	return HbarFrom(a, _HbarUnitFromString(matchArray[2])), nil
}

func _HbarUnitFromString(symbol string) HbarUnit {
	switch symbol {
	case HbarUnits.Tinybar.Symbol():
		return HbarUnits.Tinybar
	case HbarUnits.Microbar.Symbol():
		return HbarUnits.Microbar
	case HbarUnits.Millibar.Symbol():
		return HbarUnits.Millibar
	case HbarUnits.Kilobar.Symbol():
		return HbarUnits.Kilobar
	case HbarUnits.Megabar.Symbol():
		return HbarUnits.Megabar
	case HbarUnits.Gigabar.Symbol():
		return HbarUnits.Gigabar
	default:
		return HbarUnits.Hbar
	}
}

// ToString returns a string representation of the Hbar value in the given unit.
func (hbar Hbar) ToString(unit HbarUnit) string {
	return fmt.Sprintf("%v %v", float64(hbar.tinybar)/float64(unit._NumberOfTinybar()), unit.Symbol())
}

// Negated returns the negated value of the Hbar.
func (hbar Hbar) Negated() Hbar {
	return Hbar{
		tinybar: -hbar.tinybar,
	}
}
// Filename: hbar_allowance.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// An approved allowance of hbar transfers for a spender.
type HbarAllowance struct {
	OwnerAccountID   *AccountID
	SpenderAccountID *AccountID
	Amount           int64
}

// NewHbarAllowance creates a new HbarAllowance with the given owner, spender, and amount.
func NewHbarAllowance(ownerAccountID AccountID, spenderAccountID AccountID, amount int64) HbarAllowance { //nolint
	return HbarAllowance{
		OwnerAccountID:   &ownerAccountID,
		SpenderAccountID: &spenderAccountID,
		Amount:           amount,
	}
}

func _HbarAllowanceFromProtobuf(pb *services.CryptoAllowance) HbarAllowance {
	body := HbarAllowance{
		Amount: pb.Amount,
	}

	if pb.Spender != nil {
		body.SpenderAccountID = _AccountIDFromProtobuf(pb.Spender)
	}

	if pb.Owner != nil {
		body.OwnerAccountID = _AccountIDFromProtobuf(pb.Owner)
	}

	return body
}

func (approval *HbarAllowance) _ToProtobuf() *services.CryptoAllowance {
	body := &services.CryptoAllowance{
		Amount: approval.Amount,
	}

	if approval.SpenderAccountID != nil {
		body.Spender = approval.SpenderAccountID._ToProtobuf()
	}

	if approval.OwnerAccountID != nil {
		body.Owner = approval.OwnerAccountID._ToProtobuf()
	}

	return body
}

// String returns a string representation of the HbarAllowance
func (approval *HbarAllowance) String() string {
	if approval.OwnerAccountID != nil && approval.SpenderAccountID != nil { //nolint
		return fmt.Sprintf("OwnerAccountID: %s, SpenderAccountID: %s, Amount: %s", approval.OwnerAccountID.String(), approval.SpenderAccountID.String(), HbarFromTinybar(approval.Amount).String())
	} else if approval.OwnerAccountID != nil {
		return fmt.Sprintf("OwnerAccountID: %s, Amount: %s", approval.OwnerAccountID.String(), HbarFromTinybar(approval.Amount).String())
	} else if approval.SpenderAccountID != nil {
		return fmt.Sprintf("SpenderAccountID: %s, Amount: %s", approval.SpenderAccountID.String(), HbarFromTinybar(approval.Amount).String())
	}

	return ""
}
// Filename: hbar_transfer.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import "github.com/hashgraph/hedera-protobufs-go/services"

type _HbarTransfer struct {
	accountID  *AccountID
	Amount     Hbar
	IsApproved bool
}

func _HbarTransferFromProtobuf(pb []*services.AccountAmount) []*_HbarTransfer {
	result := make([]*_HbarTransfer, 0)
	for _, acc := range pb {
		result = append(result, &_HbarTransfer{
			accountID:  _AccountIDFromProtobuf(acc.AccountID),
			Amount:     HbarFromTinybar(acc.Amount),
			IsApproved: acc.GetIsApproval(),
		})
	}

	return result
}

func (transfer *_HbarTransfer) _ToProtobuf() *services.AccountAmount { //nolint
	var account *services.AccountID
	if transfer.accountID != nil {
		account = transfer.accountID._ToProtobuf()
	}

	return &services.AccountAmount{
		AccountID:  account,
		Amount:     transfer.Amount.AsTinybar(),
		IsApproval: transfer.IsApproved,
	}
}
// Filename: hbar_unit.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

type HbarUnit string

// HbarUnits is a set of HbarUnit
var HbarUnits = struct {
	Tinybar  HbarUnit
	Microbar HbarUnit
	Millibar HbarUnit
	Hbar     HbarUnit
	Kilobar  HbarUnit
	Megabar  HbarUnit
	Gigabar  HbarUnit
}{
	Tinybar:  HbarUnit("tinybar"),
	Microbar: HbarUnit("microbar"),
	Millibar: HbarUnit("millibar"),
	Hbar:     HbarUnit("hbar"),
	Kilobar:  HbarUnit("kilobar"),
	Megabar:  HbarUnit("megabar"),
	Gigabar:  HbarUnit("gigabar"),
}

// Symbol returns the symbol representation of the HbarUnit
func (unit HbarUnit) Symbol() string {
	switch unit {
	case HbarUnits.Tinybar:
		return "tℏ"
	case HbarUnits.Microbar:
		return "μℏ"
	case HbarUnits.Millibar:
		return "mℏ"
	case HbarUnits.Hbar:
		return "ℏ"
	case HbarUnits.Kilobar:
		return "kℏ"
	case HbarUnits.Megabar:
		return "Mℏ"
	case HbarUnits.Gigabar:
		return "Gℏ"
	}

	panic("unreachable: HbarUnit.Symbol() switch statement is non-exhaustive")
}

// String returns a string representation of the HbarUnit
func (unit HbarUnit) String() string {
	return string(unit)
}

func (unit HbarUnit) _NumberOfTinybar() int64 {
	switch unit {
	case HbarUnits.Tinybar:
		return 1
	case HbarUnits.Microbar:
		return 100
	case HbarUnits.Millibar:
		return 100_000
	case HbarUnits.Hbar:
		return 100_000_000
	case HbarUnits.Kilobar:
		return 100_000_000_000
	case HbarUnits.Megabar:
		return 100_000_000_000_000
	case HbarUnits.Gigabar:
		return 100_000_000_000_000_000
	}

	panic("unreachable: HbarUnit.Symbol() switch statement is non-exhaustive")
}
// Filename: hbar_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitHbarFromTinybar(t *testing.T) {
	t.Parallel()

	tinybar := HbarUnits.Hbar._NumberOfTinybar()

	hbar := HbarFromTinybar(tinybar)

	assert.Equal(t, tinybar, hbar.tinybar)

	tinybar = MaxHbar.tinybar

	hbar = HbarFromTinybar(tinybar)

	assert.Equal(t, tinybar, hbar.tinybar)

	tinybar = MinHbar.tinybar

	hbar = HbarFromTinybar(tinybar)

	assert.Equal(t, tinybar, hbar.tinybar)
}

func TestUnitHbarUnit(t *testing.T) {
	t.Parallel()

	tinybar := HbarUnits.Kilobar._NumberOfTinybar()

	hbar := HbarFromTinybar(tinybar)

	hbar2, err := HbarFromString(hbar.ToString(HbarUnits.Kilobar))
	require.NoError(t, err)
	assert.Equal(t, hbar2.tinybar, hbar.tinybar)

	tinybar = HbarUnits.Gigabar._NumberOfTinybar()

	hbar = HbarFromTinybar(tinybar)

	hbar2, err = HbarFromString(hbar.ToString(HbarUnits.Gigabar))
	require.NoError(t, err)
	assert.Equal(t, hbar2.tinybar, hbar.tinybar)

	tinybar = HbarUnits.Microbar._NumberOfTinybar()

	hbar = HbarFromTinybar(tinybar)

	hbar2, err = HbarFromString(hbar.ToString(HbarUnits.Microbar))
	require.NoError(t, err)
	assert.Equal(t, hbar2.tinybar, hbar.tinybar)

	hbar2, err = HbarFromString("-5.123 Gℏ")
	require.NoError(t, err)
	assert.Equal(t, hbar2.tinybar, int64(-512300000000000000))

	hbar2, err = HbarFromString("5")
	require.NoError(t, err)
	assert.Equal(t, hbar2.ToString(HbarUnits.Hbar), "5 ℏ")

	hbar2, err = HbarFromString("+5.123 ℏ")
	require.NoError(t, err)
	assert.Equal(t, hbar2.ToString(HbarUnits.Millibar), "5123 mℏ")

	hbar2, err = HbarFromString("1.151 uℏ")
	assert.Error(t, err)

	hbar2, err = HbarFromString("1.151.")
	assert.Error(t, err)
}
// Filename: id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"strconv"
	"strings"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

func _AccountIDFromString(s string) (shard int, realm int, num int, checksum *string, alias *PublicKey, evmAddress *[]byte, err error) {
	if _Has0xPrefix(s) {
		s = _Without0x(s)
	}
	if _IsHex(s) {
		bytes := _Hex2Bytes(s)
		if err == nil {
			if len(bytes) == 20 {
				return 0, 0, -1, nil, nil, &bytes, nil
			}
		}
	}

	if strings.Contains(s, "-") {
		values := strings.SplitN(s, "-", 2)

		if len(values) > 2 {
			return 0, 0, 0, nil, nil, nil, fmt.Errorf("expected {shard}.{realm}.{num}-{checksum}")
		}

		checksum = &values[1]
		s = values[0]
	}

	values := strings.SplitN(s, ".", 3)
	if len(values) != 3 {
		// Was not three values separated by periods
		return 0, 0, 0, nil, nil, nil, fmt.Errorf("expected {shard}.{realm}.{num}")
	}

	shard, err = strconv.Atoi(values[0])
	if err != nil {
		return 0, 0, 0, nil, nil, nil, err
	}

	realm, err = strconv.Atoi(values[1])
	if err != nil {
		return 0, 0, 0, nil, nil, nil, err
	}

	if len(values[2]) < 20 {
		num, err = strconv.Atoi(values[2])
		if err != nil {
			return 0, 0, 0, nil, nil, nil, err
		}

		return shard, realm, num, checksum, nil, nil, nil
	} else if len(values[2]) == 40 {
		temp, err2 := hex.DecodeString(values[2])
		if err2 != nil {
			return 0, 0, 0, nil, nil, nil, err2
		}
		var key services.Key
		err2 = protobuf.Unmarshal(temp, &key)
		if err2 != nil {
			return shard, realm, -1, checksum, nil, &temp, nil
		}
		aliasKey, err2 := _KeyFromProtobuf(&key)
		if err2 != nil {
			return shard, realm, -1, checksum, nil, &temp, nil
		}

		if aliasPublicKey, ok := aliasKey.(PublicKey); ok {
			return shard, realm, -1, checksum, &aliasPublicKey, nil, nil
		}

		return shard, realm, -1, checksum, nil, &temp, nil
	}

	key, err := PublicKeyFromString(values[2])
	if err != nil {
		return 0, 0, 0, nil, nil, nil, err
	}

	return shard, realm, -1, checksum, &key, nil, nil
}

func _ContractIDFromString(s string) (shard int, realm int, num int, checksum *string, evmAddress []byte, err error) {
	if strings.Contains(s, "-") {
		values := strings.SplitN(s, "-", 2)

		if len(values) > 2 {
			return 0, 0, 0, nil, nil, fmt.Errorf("expected {shard}.{realm}.{num}-{checksum}")
		}

		checksum = &values[1]
		s = values[0]
	}

	values := strings.SplitN(s, ".", 3)
	if len(values) != 3 {
		// Was not three values separated by periods
		return 0, 0, 0, nil, nil, fmt.Errorf("expected {shard}.{realm}.{num}")
	}

	shard, err = strconv.Atoi(values[0])
	if err != nil {
		return 0, 0, 0, nil, nil, err
	}

	realm, err = strconv.Atoi(values[1])
	if err != nil {
		return 0, 0, 0, nil, nil, err
	}

	num, err = strconv.Atoi(values[2])
	if err != nil {
		temp, err2 := hex.DecodeString(values[2])
		if err2 != nil {
			return 0, 0, 0, nil, nil, err
		}
		return shard, realm, -1, checksum, temp, nil
	}

	return shard, realm, num, checksum, nil, nil
}

func _IdFromString(s string) (shard int, realm int, num int, checksum *string, err error) {
	if strings.Contains(s, "-") {
		values := strings.SplitN(s, "-", 2)

		if len(values) > 2 {
			return 0, 0, 0, nil, fmt.Errorf("expected {shard}.{realm}.{num}-{checksum}")
		}

		checksum = &values[1]
		s = values[0]
	}

	values := strings.SplitN(s, ".", 3)
	if len(values) != 3 {
		// Was not three values separated by periods
		return 0, 0, 0, nil, fmt.Errorf("expected {shard}.{realm}.{num}")
	}

	shard, err = strconv.Atoi(values[0])
	if err != nil {
		return 0, 0, 0, nil, err
	}

	realm, err = strconv.Atoi(values[1])
	if err != nil {
		return 0, 0, 0, nil, err
	}

	num, err = strconv.Atoi(values[2])
	if err != nil {
		return 0, 0, 0, nil, err
	}

	return shard, realm, num, checksum, nil
}

func _IdFromSolidityAddress(s string) (uint64, uint64, uint64, error) {
	bytes, err := hex.DecodeString(s)
	if err != nil {
		return 0, 0, 0, err
	}

	if len(bytes) != 20 {
		return 0, 0, 0, fmt.Errorf("_Solidity address must be 20 bytes")
	}

	return uint64(binary.BigEndian.Uint32(bytes[0:4])), binary.BigEndian.Uint64(bytes[4:12]), binary.BigEndian.Uint64(bytes[12:20]), nil
}

func _IdToSolidityAddress(shard uint64, realm uint64, num uint64) string {
	bytes := make([]byte, 20)
	binary.BigEndian.PutUint32(bytes[0:4], uint32(shard))
	binary.BigEndian.PutUint64(bytes[4:12], realm)
	binary.BigEndian.PutUint64(bytes[12:20], num)
	return hex.EncodeToString(bytes)
}

func _Has0xPrefix(str string) bool {
	return len(str) >= 2 && str[0] == '0' && (str[1] == 'x' || str[1] == 'X')
}

func _Without0x(s string) string {
	if _Has0xPrefix(s) {
		s = s[2:]
	}
	if len(s)%2 == 1 {
		s = "0" + s
	}
	return s
}

func _Hex2Bytes(str string) []byte {
	h, _ := hex.DecodeString(str)
	return h
}

func _IsHexCharacter(c byte) bool {
	return ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')
}

func _IsHex(str string) bool {
	if len(str)%2 != 0 {
		return false
	}
	for _, c := range []byte(str) {
		if !_IsHexCharacter(c) {
			return false
		}
	}
	return true
}
// Filename: index.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
// Filename: internal_token_transfer.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

type _TokenTransfer struct {
	Transfers        []*_HbarTransfer
	ExpectedDecimals *uint32
}

func _TokenTransferPrivateFromProtobuf(pb *services.TokenTransferList) *_TokenTransfer {
	if pb == nil {
		return &_TokenTransfer{}
	}

	var decimals *uint32
	if pb.ExpectedDecimals != nil {
		temp := pb.ExpectedDecimals.GetValue()
		decimals = &temp
	}

	return &_TokenTransfer{
		Transfers:        _HbarTransferFromProtobuf(pb.Transfers),
		ExpectedDecimals: decimals,
	}
}

func (transfer *_TokenTransfer) _ToProtobuf() []*services.AccountAmount {
	transfers := make([]*services.AccountAmount, 0)
	for _, t := range transfer.Transfers {
		transfers = append(transfers, &services.AccountAmount{
			AccountID:  t.accountID._ToProtobuf(),
			Amount:     t.Amount.AsTinybar(),
			IsApproval: t.IsApproved,
		})
	}
	return transfers
}
// Filename: key_list.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// KeyList is a list of keys
type KeyList struct {
	keys      []Key
	threshold int
}

// NewKeyListWithThreshold creates a new KeyList with the given threshold
func KeyListWithThreshold(threshold uint) *KeyList {
	return &KeyList{
		keys:      make([]Key, 0),
		threshold: int(threshold),
	}
}

// NewKeyList creates a new KeyList with no threshold
func NewKeyList() *KeyList {
	return &KeyList{
		keys:      make([]Key, 0),
		threshold: -1,
	}
}

// SetThreshold sets the threshold of the KeyList
func (kl *KeyList) SetThreshold(threshold int) *KeyList {
	kl.threshold = threshold
	return kl
}

// Add adds a key to the KeyList
func (kl *KeyList) Add(key Key) *KeyList {
	kl.keys = append(kl.keys, key)
	return kl
}

// AddAll adds all the keys to the KeyList
func (kl *KeyList) AddAll(keys []Key) *KeyList {
	for _, key := range keys {
		kl.Add(key)
	}

	return kl
}

// AddAllPublicKeys adds all the public keys to the KeyList
func (kl *KeyList) AddAllPublicKeys(keys []PublicKey) *KeyList {
	for _, key := range keys {
		kl.Add(key)
	}

	return kl
}

// String returns a string representation of the KeyList
func (kl KeyList) String() string {
	var s string
	if kl.threshold > 0 {
		s = "{threshold:" + fmt.Sprint(kl.threshold) + ",["
	} else {
		s = "{["
	}

	for i, key := range kl.keys {
		s += key.String()
		if i != len(kl.keys)-1 {
			s += ","
		}
	}

	s += "]}"

	return s
}

func (kl KeyList) _ToProtoKey() *services.Key {
	keys := make([]*services.Key, len(kl.keys))
	for i, key := range kl.keys {
		keys[i] = key._ToProtoKey()
	}

	if kl.threshold >= 0 {
		return &services.Key{
			Key: &services.Key_ThresholdKey{
				ThresholdKey: &services.ThresholdKey{
					Threshold: uint32(kl.threshold),
					Keys: &services.KeyList{
						Keys: keys,
					},
				},
			},
		}
	}

	return &services.Key{
		Key: &services.Key_KeyList{
			KeyList: &services.KeyList{
				Keys: keys,
			},
		},
	}
}

func (kl *KeyList) _ToProtoKeyList() *services.KeyList {
	keys := make([]*services.Key, len(kl.keys))
	for i, key := range kl.keys {
		keys[i] = key._ToProtoKey()
	}

	return &services.KeyList{
		Keys: keys,
	}
}

func _KeyListFromProtobuf(pb *services.KeyList) (KeyList, error) {
	if pb == nil {
		return KeyList{}, errParameterNull
	}
	var keys = make([]Key, len(pb.Keys))

	for i, pbKey := range pb.Keys {
		key, err := _KeyFromProtobuf(pbKey)

		if err != nil {
			return KeyList{}, err
		}

		keys[i] = key
	}

	return KeyList{
		keys:      keys,
		threshold: -1,
	}, nil
}
// Filename: key_list_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/proto"
)

// Mock Key and PublicKey structs and methods for testing
type MockKey struct {
	data string
}

func (k MockKey) _ToProtoKey() *services.Key {
	return &services.Key{Key: &services.Key_Ed25519{Ed25519: []byte(k.data)}}
}

func (k MockKey) String() string {
	return k.data
}

func TestNewKeyList(t *testing.T) {
	kl := NewKeyList()
	assert.NotNil(t, kl)
	assert.Equal(t, -1, kl.threshold)
	assert.Empty(t, kl.keys)
}

func TestKeyListWithThreshold(t *testing.T) {
	kl := KeyListWithThreshold(2)
	assert.NotNil(t, kl)
	assert.Equal(t, 2, kl.threshold)
	assert.Empty(t, kl.keys)
}

func TestSetThreshold(t *testing.T) {
	kl := NewKeyList()
	kl.SetThreshold(3)
	assert.Equal(t, 3, kl.threshold)
}

func TestAdd(t *testing.T) {
	kl := NewKeyList()
	key := MockKey{data: "key1"}
	kl.Add(key)
	assert.Len(t, kl.keys, 1)
	assert.Equal(t, key, kl.keys[0])
}

func TestAddAll(t *testing.T) {
	kl := NewKeyList()
	keys := []Key{MockKey{data: "key1"}, MockKey{data: "key2"}}
	kl.AddAll(keys)
	assert.Len(t, kl.keys, 2)
	assert.Equal(t, keys[0], kl.keys[0])
	assert.Equal(t, keys[1], kl.keys[1])
}

func TestAddAllPublicKeys(t *testing.T) {
	kl := NewKeyList()
	keys := []PublicKey{{ed25519PublicKey: &_Ed25519PublicKey{keyData: []byte{1, 2}}}, {ed25519PublicKey: &_Ed25519PublicKey{keyData: []byte{1}}}}
	kl.AddAllPublicKeys(keys)
	assert.Len(t, kl.keys, 2)
	assert.Equal(t, keys[0], kl.keys[0])
	assert.Equal(t, keys[1], kl.keys[1])
}

func TestStringKeyList(t *testing.T) {
	kl := KeyListWithThreshold(2)
	key := MockKey{data: "key1"}
	kl.Add(key)
	expected := "{threshold:2,[key1]}"
	assert.Equal(t, expected, kl.String())

	kl2 := NewKeyList()
	kl2.Add(key)
	expected2 := "{[key1]}"
	assert.Equal(t, expected2, kl2.String())
}

func TestToProtoKey(t *testing.T) {
	kl := KeyListWithThreshold(2)
	key := MockKey{data: "key1"}
	kl.Add(key)
	protoKey := kl._ToProtoKey()

	expected := &services.Key{
		Key: &services.Key_ThresholdKey{
			ThresholdKey: &services.ThresholdKey{
				Threshold: uint32(kl.threshold),
				Keys: &services.KeyList{
					Keys: []*services.Key{
						{Key: &services.Key_Ed25519{Ed25519: []byte(key.data)}},
					},
				},
			},
		},
	}

	assert.True(t, proto.Equal(protoKey, expected))
}

func TestToProtoKeyList(t *testing.T) {
	kl := NewKeyList()
	key := MockKey{data: "key1"}
	kl.Add(key)
	protoKeyList := kl._ToProtoKeyList()

	expected := &services.KeyList{
		Keys: []*services.Key{
			{Key: &services.Key_Ed25519{Ed25519: []byte(key.data)}},
		},
	}

	assert.True(t, proto.Equal(protoKeyList, expected))
}

func TestKeyListFromProtobuf(t *testing.T) {
	pk, _ := PrivateKeyFromStringEd25519("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11")
	protoKeyList := &services.KeyList{
		Keys: []*services.Key{
			{Key: &services.Key_Ed25519{Ed25519: pk.PublicKey().Bytes()}},
		},
	}

	kl, err := _KeyListFromProtobuf(protoKeyList)
	require.NoError(t, err)

	assert.Len(t, kl.keys, 1)
	assert.Equal(t, -1, kl.threshold)
}

func TestKeyListFromProtobuf_Nil(t *testing.T) {
	kl, err := _KeyListFromProtobuf(nil)
	assert.Error(t, errParameterNull, err)
	assert.Equal(t, KeyList{}, kl)
}
// Filename: keystore.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"crypto/aes"
	cipher2 "crypto/cipher"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"crypto/sha512"
	"crypto/subtle"
	"encoding/hex"
	"encoding/json"

	"io"

	"golang.org/x/crypto/pbkdf2"
)

type _Keystore struct {
	Version uint8       `json:"version"`
	Crypto  _CryptoData `json:"crypto"`
}

// internal struct used for cipher parameters
type _CipherParams struct {
	// hex-encoded initialization vector
	IV string `json:"iv"`
}

// internal struct used for kdf parameters
type _KdfParams struct {
	// derived key length
	DKLength int `json:"dklength"`
	// hex-encoded salt
	Salt string `json:"salt"`
	// iteration count
	Count int `json:"c"`
	// hash function
	PRF string `json:"prf"`
}

// internal type used in _Keystore to represent the crypto data
type _CryptoData struct {
	// hex-encoded ciphertext
	CipherText   string        `json:"ciphertext"`
	CipherParams _CipherParams `json:"cipherparams"`
	// Cipher being used
	Cipher string `json:"cipher"`
	// key derivation function being used
	KDF string `json:"kdf"`
	// parameters for key derivation function
	KDFParams _KdfParams `json:"kdfparams"`
	// hex-encoded HMAC-SHA384
	Mac string `json:"mac"`
}

const Aes128Ctr = "aes-128-ctr"
const HmacSha256 = "hmac-sha256"

// all values taken from https://github.com/ethereumjs/ethereumjs-wallet/blob/de3a92e752673ada1d78f95cf80bc56ae1f59775/src/index.ts#L25
const dkLen int = 32
const c int = 262144
const saltLen uint = 32

func _RandomBytes(n uint) ([]byte, error) {
	// based on https://github.com/gophercon/2016-talks/tree/master/GeorgeTankersley-CryptoForGoDevelopers
	b := make([]byte, n)
	_, err := io.ReadFull(rand.Reader, b)
	if err != nil {
		return nil, err
	}

	return b, nil
}

func _NewKeystore(privateKey []byte, passphrase string) ([]byte, error) {
	salt, err := _RandomBytes(saltLen)
	if err != nil {
		return nil, err
	}

	key := pbkdf2.Key([]byte(passphrase), salt, c, dkLen, sha256.New)

	iv, err := _RandomBytes(16)
	if err != nil {
		return nil, err
	}

	// AES-128-CTR with the first half of the derived key and a random IV
	block, err := aes.NewCipher(key[0:16])
	if err != nil {
		return nil, err
	}

	cipher := cipher2.NewCTR(block, iv)
	cipherText := make([]byte, len(privateKey))
	cipher.XORKeyStream(cipherText, privateKey)

	h := hmac.New(sha512.New384, key[16:])

	if _, err = h.Write(cipherText); err != nil {
		return nil, err
	}

	mac := h.Sum(nil)

	keystore := _Keystore{
		Version: 1,
		Crypto: _CryptoData{
			CipherText: hex.EncodeToString(cipherText),
			CipherParams: _CipherParams{
				IV: hex.EncodeToString(iv),
			},
			Cipher: Aes128Ctr,
			KDF:    "pbkdf2",
			KDFParams: _KdfParams{
				DKLength: dkLen,
				Salt:     hex.EncodeToString(salt),
				Count:    c,
				PRF:      HmacSha256,
			},
			Mac: hex.EncodeToString(mac),
		},
	}

	return json.Marshal(keystore)
}

func _ParseKeystore(keystoreBytes []byte, passphrase string) (PrivateKey, error) {
	keyStore := _Keystore{}

	err := json.Unmarshal(keystoreBytes, &keyStore)

	if err != nil {
		return PrivateKey{}, err
	}

	if keyStore.Version != 1 {
		// todo: change to a switch and handle differently if future _Keystore versions are added
		return PrivateKey{}, _NewErrBadKeyf("unsupported _Keystore version: %v", keyStore.Version)
	}

	if keyStore.Crypto.KDF != "pbkdf2" {
		return PrivateKey{}, _NewErrBadKeyf("unsupported KDF: %v", keyStore.Crypto.KDF)
	}

	if keyStore.Crypto.Cipher != Aes128Ctr {
		return PrivateKey{}, _NewErrBadKeyf("unsupported _Keystore cipher: %v", keyStore.Crypto.Cipher)
	}

	if keyStore.Crypto.KDFParams.PRF != HmacSha256 {
		return PrivateKey{}, _NewErrBadKeyf(
			"unsupported PRF: %v",
			keyStore.Crypto.KDFParams.PRF)
	}

	salt, err := hex.DecodeString(keyStore.Crypto.KDFParams.Salt)

	if err != nil {
		return PrivateKey{}, err
	}

	iv, err := hex.DecodeString(keyStore.Crypto.CipherParams.IV)

	if err != nil {
		return PrivateKey{}, err
	}

	cipherBytes, err := hex.DecodeString(keyStore.Crypto.CipherText)

	if err != nil {
		return PrivateKey{}, err
	}

	key := pbkdf2.Key([]byte(passphrase), salt, keyStore.Crypto.KDFParams.Count, dkLen, sha256.New)

	mac, err := hex.DecodeString(keyStore.Crypto.Mac)

	if err != nil {
		return PrivateKey{}, err
	}

	h := hmac.New(sha512.New384, key[16:])

	_, err = h.Write(cipherBytes)

	if err != nil {
		return PrivateKey{}, err
	}

	verifyMac := h.Sum(nil)

	if subtle.ConstantTimeCompare(mac, verifyMac) == 0 {
		return PrivateKey{}, _NewErrBadKeyf("hmac mismatch; passphrase is incorrect")
	}

	block, err := aes.NewCipher(key[:16])
	if err != nil {
		return PrivateKey{}, err
	}

	decipher := cipher2.NewCTR(block, iv)
	pkBytes := make([]byte, len(cipherBytes))

	decipher.XORKeyStream(pkBytes, cipherBytes)

	return PrivateKeyFromBytesEd25519(pkBytes)
}
// Filename: keystore_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

const passphrase string = "HelloHashgraph!"

const testKeystoreKeyString string = "45e512c479dc40bc47561c507daa962aa17b6133f8433c459adb481e06cbdafb"

// generated with the JS SDK
const testKeystore string = `{"version":1,"crypto":{"ciphertext":"9dfa728ba59e50d745f76a5fb4cab6918d4096869ab436a879731095f621456f5add51715ce81383a7996f3a75359e8216102285238a3ad8fac4dfa17894a6aa","cipherparams":{"iv":"c3198c3529fef9c5e2886f19c479683e"},"cipher":"aes-128-ctr","kdf":"pbkdf2","kdfparams":{"dkLen":32,"salt":"c87aba46b7db247694763cff3f2ec18bad1006590c6bb9befc14f05b2b2af479","c":262144,"prf":"hmac-sha256"},"mac":"f6f7a1552b3618209073feebe0109f57a3df57d8b11f07ff44aad82bafffbd15636263b96cfd2328b122d2851771c7b4"}}`

func TestUnitDecryptKeyStore(t *testing.T) {
	t.Parallel()

	privateKey, err := PrivateKeyFromString(testKeystoreKeyString)
	require.NoError(t, err)

	ksPrivateKey, err := _ParseKeystore([]byte(testKeystore), passphrase)
	require.NoError(t, err)

	assert.Equal(t, privateKey.ed25519PrivateKey.keyData, ksPrivateKey.ed25519PrivateKey.keyData)
}

func TestUnitEncryptAndDecryptKeyStore(t *testing.T) {
	t.Parallel()

	privateKey, err := PrivateKeyFromString(testPrivateKeyStr)
	require.NoError(t, err)

	keyStore, err := _NewKeystore(privateKey.Bytes(), passphrase)
	require.NoError(t, err)

	ksPrivateKey, err := _ParseKeystore(keyStore, passphrase)
	require.NoError(t, err)

	assert.Equal(t, privateKey.ed25519PrivateKey.keyData, ksPrivateKey.ed25519PrivateKey.keyData)
}
// Filename: ledger_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"

	"github.com/pkg/errors"
)

type LedgerID struct {
	_LedgerIDBytes []byte
}

// LedgerIDFromString returns a LedgerID from a string representation of a ledger ID.
func LedgerIDFromString(id string) (*LedgerID, error) {
	switch id {
	case "mainnet": //nolint
		return &LedgerID{
			_LedgerIDBytes: []byte{0},
		}, nil
	case "testnet": //nolint
		return &LedgerID{
			_LedgerIDBytes: []byte{1},
		}, nil
	case "previewnet": //nolint
		return &LedgerID{
			_LedgerIDBytes: []byte{2},
		}, nil
	default:
		temp, err := hex.DecodeString(id)
		if err != nil {
			return &LedgerID{}, err
		}
		return &LedgerID{
			_LedgerIDBytes: temp,
		}, nil
	}
}

// LedgerIDFromBytes returns a LedgerID from a byte representation of a ledger ID.
func LedgerIDFromBytes(byt []byte) *LedgerID {
	return &LedgerID{
		_LedgerIDBytes: byt,
	}
}

// LedgerIDFromNetworkName returns a LedgerID from a NetworkName.
func LedgerIDFromNetworkName(network NetworkName) (*LedgerID, error) {
	switch network.String() {
	case "mainnet": //nolint
		return &LedgerID{
			_LedgerIDBytes: []byte{0},
		}, nil
	case "testnet": //nolint
		return &LedgerID{
			_LedgerIDBytes: []byte{1},
		}, nil
	case "previewnet": //nolint
		return &LedgerID{
			_LedgerIDBytes: []byte{2},
		}, nil
	default:
		return &LedgerID{}, errors.New("unknown network in network name")
	}
}

// LedgerIDMainnet returns a LedgerID for mainnet.
func NewLedgerIDMainnet() *LedgerID {
	return &LedgerID{
		_LedgerIDBytes: []byte{0},
	}
}

// LedgerIDTestnet returns a LedgerID for testnet.
func NewLedgerIDTestnet() *LedgerID {
	return &LedgerID{
		_LedgerIDBytes: []byte{1},
	}
}

// LedgerIDPreviewnet returns a LedgerID for previewnet.
func NewLedgerIDPreviewnet() *LedgerID {
	return &LedgerID{
		_LedgerIDBytes: []byte{2},
	}
}

// IsMainnet returns true if the LedgerID is for mainnet.
func (id *LedgerID) IsMainnet() bool {
	return hex.EncodeToString(id._LedgerIDBytes) == "00"
}

// IsTestnet returns true if the LedgerID is for testnet.
func (id *LedgerID) IsTestnet() bool {
	return hex.EncodeToString(id._LedgerIDBytes) == "01"
}

// IsPreviewnet returns true if the LedgerID is for previewnet.
func (id *LedgerID) IsPreviewnet() bool {
	return hex.EncodeToString(id._LedgerIDBytes) == "02"
}

// String returns a string representation of the LedgerID.
func (id *LedgerID) String() string {
	h := hex.EncodeToString(id._LedgerIDBytes)
	switch h {
	case "00":
		return "mainnet"
	case "01":
		return "testnet"
	case "02":
		return "previewnet"
	default:
		return h
	}
}

// ToBytes returns a byte representation of the LedgerID.
func (id *LedgerID) ToBytes() []byte {
	return id._LedgerIDBytes
}

// ToNetworkName returns a NetworkName from the LedgerID.
func (id *LedgerID) ToNetworkName() (NetworkName, error) {
	switch hex.EncodeToString(id._LedgerIDBytes) {
	case "00":
		return NetworkNameMainnet, nil
	case "01":
		return NetworkNameTestnet, nil
	case "02":
		return NetworkNamePreviewnet, nil
	default:
		return NetworkNameOther, nil
	}
}
// Filename: legacy.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

var legacy = [...]string{
	"aback",
	"abbey",
	"abbot",
	"abide",
	"ablaze",
	"able",
	"aboard",
	"abode",
	"abort",
	"abound",
	"about",
	"above",
	"abroad",
	"abrupt",
	"absent",
	"absorb",
	"absurd",
	"abuse",
	"accent",
	"accept",
	"access",
	"accord",
	"accuse",
	"ace",
	"ache",
	"aching",
	"acid",
	"acidic",
	"acorn",
	"acre",
	"across",
	"act",
	"action",
	"active",
	"actor",
	"actual",
	"acute",
	"adam",
	"adapt",
	"add",
	"added",
	"addict",
	"adept",
	"adhere",
	"adjust",
	"admire",
	"admit",
	"adobe",
	"adopt",
	"adrift",
	"adult",
	"adverb",
	"advice",
	"aerial",
	"afar",
	"affair",
	"affect",
	"afford",
	"afghan",
	"afield",
	"afloat",
	"afraid",
	"afresh",
	"after",
	"again",
	"age",
	"agency",
	"agenda",
	"agent",
	"aghast",
	"agile",
	"ago",
	"agony",
	"agree",
	"agreed",
	"ahead",
	"aid",
	"aide",
	"aim",
	"air",
	"airman",
	"airy",
	"akin",
	"alarm",
	"alaska",
	"albeit",
	"album",
	"ale",
	"alert",
	"alibi",
	"alice",
	"alien",
	"alight",
	"align",
	"alike",
	"alive",
	"alkali",
	"all",
	"alley",
	"allied",
	"allow",
	"alloy",
	"ally",
	"almond",
	"almost",
	"aloft",
	"alone",
	"along",
	"aloof",
	"aloud",
	"alpha",
	"alpine",
	"also",
	"altar",
	"alter",
	"always",
	"amaze",
	"amazon",
	"amber",
	"ambush",
	"amen",
	"amend",
	"amid",
	"amidst",
	"amiss",
	"among",
	"amount",
	"ample",
	"amuse",
	"anchor",
	"and",
	"andrew",
	"anew",
	"angel",
	"anger",
	"angle",
	"angry",
	"animal",
	"ankle",
	"annoy",
	"annual",
	"answer",
	"anthem",
	"any",
	"anyhow",
	"anyway",
	"apart",
	"apathy",
	"apex",
	"apiece",
	"appeal",
	"appear",
	"apple",
	"apply",
	"april",
	"apron",
	"arab",
	"arcade",
	"arcane",
	"arch",
	"arctic",
	"ardent",
	"are",
	"area",
	"argue",
	"arid",
	"arise",
	"ark",
	"arm",
	"armful",
	"army",
	"aroma",
	"around",
	"arouse",
	"array",
	"arrest",
	"arrive",
	"arrow",
	"arson",
	"art",
	"artery",
	"artful",
	"artist",
	"ascent",
	"ash",
	"ashen",
	"ashore",
	"aside",
	"ask",
	"asleep",
	"aspect",
	"assay",
	"assent",
	"assert",
	"assess",
	"asset",
	"assign",
	"assist",
	"assume",
	"assure",
	"asthma",
	"astute",
	"asylum",
	"ate",
	"athens",
	"atlas",
	"atom",
	"atomic",
	"attach",
	"attack",
	"attain",
	"attend",
	"attic",
	"auburn",
	"audio",
	"audit",
	"august",
	"aunt",
	"auntie",
	"aura",
	"austin",
	"author",
	"auto",
	"autumn",
	"avail",
	"avenge",
	"avenue",
	"avert",
	"avid",
	"avoid",
	"await",
	"awake",
	"awaken",
	"award",
	"aware",
	"awash",
	"away",
	"awful",
	"awhile",
	"axe",
	"axes",
	"axiom",
	"axis",
	"axle",
	"aye",
	"babe",
	"baby",
	"bach",
	"back",
	"backup",
	"bacon",
	"bad",
	"badge",
	"badly",
	"bag",
	"baggy",
	"bail",
	"bait",
	"bake",
	"baker",
	"bakery",
	"bald",
	"ball",
	"ballad",
	"ballet",
	"ballot",
	"baltic",
	"bamboo",
	"ban",
	"banal",
	"banana",
	"band",
	"bang",
	"bank",
	"bar",
	"barber",
	"bare",
	"barely",
	"barge",
	"bark",
	"barley",
	"barn",
	"baron",
	"barrel",
	"barren",
	"basalt",
	"base",
	"basic",
	"basil",
	"basin",
	"basis",
	"basket",
	"bass",
	"bat",
	"batch",
	"bath",
	"baton",
	"battle",
	"bay",
	"beach",
	"beacon",
	"beak",
	"beam",
	"bean",
	"bear",
	"beard",
	"beast",
	"beat",
	"beauty",
	"become",
	"bed",
	"beech",
	"beef",
	"beefy",
	"beep",
	"beer",
	"beet",
	"beetle",
	"before",
	"beg",
	"beggar",
	"begin",
	"behalf",
	"behave",
	"behind",
	"beige",
	"being",
	"belief",
	"bell",
	"belly",
	"belong",
	"below",
	"belt",
	"bench",
	"bend",
	"benign",
	"bent",
	"berlin",
	"berry",
	"berth",
	"beset",
	"beside",
	"best",
	"bestow",
	"bet",
	"beta",
	"betray",
	"better",
	"beware",
	"beyond",
	"bias",
	"biceps",
	"bicker",
	"bid",
	"big",
	"bigger",
	"bike",
	"bile",
	"bill",
	"bin",
	"binary",
	"bind",
	"biopsy",
	"birch",
	"bird",
	"birdie",
	"birth",
	"bishop",
	"bit",
	"bitch",
	"bite",
	"bitter",
	"black",
	"blade",
	"blame",
	"bland",
	"blast",
	"blaze",
	"bleak",
	"blend",
	"bless",
	"blew",
	"blind",
	"blink",
	"blip",
	"bliss",
	"blitz",
	"block",
	"blond",
	"blood",
	"bloody",
	"bloom",
	"blot",
	"blouse",
	"blow",
	"blue",
	"bluff",
	"blunt",
	"blur",
	"blush",
	"boar",
	"board",
	"boast",
	"boat",
	"bob",
	"bodily",
	"body",
	"bogus",
	"boil",
	"bold",
	"bolt",
	"bomb",
	"bombay",
	"bond",
	"bone",
	"bonn",
	"bonnet",
	"bonus",
	"bony",
	"book",
	"boom",
	"boost",
	"boot",
	"booth",
	"booze",
	"border",
	"bore",
	"borrow",
	"bosom",
	"boss",
	"boston",
	"both",
	"bother",
	"bottle",
	"bottom",
	"bought",
	"bounce",
	"bound",
	"bounty",
	"bout",
	"bovine",
	"bow",
	"bowel",
	"bowl",
	"box",
	"boy",
	"boyish",
	"brace",
	"brain",
	"brainy",
	"brake",
	"bran",
	"branch",
	"brand",
	"brandy",
	"brass",
	"brave",
	"bravo",
	"brazil",
	"breach",
	"bread",
	"break",
	"breast",
	"breath",
	"bred",
	"breed",
	"breeze",
	"brew",
	"bribe",
	"brick",
	"bride",
	"bridge",
	"brief",
	"bright",
	"brim",
	"brine",
	"bring",
	"brink",
	"brisk",
	"broad",
	"broke",
	"broken",
	"bronze",
	"brook",
	"broom",
	"brown",
	"bruise",
	"brush",
	"brutal",
	"brute",
	"bubble",
	"buck",
	"bucket",
	"buckle",
	"budget",
	"buffet",
	"buggy",
	"build",
	"bulb",
	"bulge",
	"bulk",
	"bulky",
	"bull",
	"bullet",
	"bully",
	"bump",
	"bumpy",
	"bunch",
	"bundle",
	"bunk",
	"bunny",
	"burden",
	"bureau",
	"burial",
	"buried",
	"burly",
	"burn",
	"burnt",
	"burrow",
	"burst",
	"bury",
	"bus",
	"bush",
	"bust",
	"bustle",
	"busy",
	"but",
	"butler",
	"butt",
	"butter",
	"button",
	"buy",
	"buyer",
	"buzz",
	"bye",
	"byte",
	"cab",
	"cabin",
	"cable",
	"cache",
	"cactus",
	"caesar",
	"cage",
	"cairo",
	"cajun",
	"cajole",
	"cake",
	"calf",
	"call",
	"caller",
	"calm",
	"calmly",
	"came",
	"camel",
	"camera",
	"camp",
	"campus",
	"can",
	"canada",
	"canal",
	"canary",
	"cancel",
	"cancer",
	"candid",
	"candle",
	"candy",
	"cane",
	"canine",
	"canoe",
	"canopy",
	"canvas",
	"canyon",
	"cap",
	"cape",
	"car",
	"carbon",
	"card",
	"care",
	"career",
	"caress",
	"cargo",
	"carl",
	"carnal",
	"carol",
	"carp",
	"carpet",
	"carrot",
	"carry",
	"cart",
	"cartel",
	"case",
	"cash",
	"cask",
	"cast",
	"castle",
	"casual",
	"cat",
	"catch",
	"cater",
	"cattle",
	"caught",
	"causal",
	"cause",
	"cave",
	"cease",
	"celery",
	"cell",
	"cellar",
	"celtic",
	"cement",
	"censor",
	"census",
	"cent",
	"cereal",
	"chain",
	"chair",
	"chalk",
	"chalky",
	"champ",
	"chance",
	"change",
	"chant",
	"chaos",
	"chap",
	"chapel",
	"charge",
	"charm",
	"chart",
	"chase",
	"chat",
	"cheap",
	"cheat",
	"check",
	"cheek",
	"cheeky",
	"cheer",
	"cheery",
	"cheese",
	"chef",
	"cheque",
	"cherry",
	"chess",
	"chest",
	"chew",
	"chic",
	"chick",
	"chief",
	"child",
	"chile",
	"chill",
	"chilly",
	"chin",
	"china",
	"chip",
	"choice",
	"choir",
	"choose",
	"chop",
	"choppy",
	"chord",
	"chorus",
	"chose",
	"chosen",
	"chris",
	"chrome",
	"chunk",
	"chunky",
	"church",
	"cider",
	"cigar",
	"cinema",
	"circa",
	"circle",
	"circus",
	"cite",
	"city",
	"civic",
	"civil",
	"clad",
	"claim",
	"clammy",
	"clan",
	"clap",
	"clash",
	"clasp",
	"class",
	"clause",
	"claw",
	"clay",
	"clean",
	"clear",
	"clergy",
	"clerk",
	"clever",
	"click",
	"client",
	"cliff",
	"climax",
	"climb",
	"clinch",
	"cling",
	"clinic",
	"clip",
	"cloak",
	"clock",
	"clone",
	"close",
	"closer",
	"closet",
	"cloth",
	"cloud",
	"cloudy",
	"clout",
	"clown",
	"club",
	"clue",
	"clumsy",
	"clung",
	"clutch",
	"coach",
	"coal",
	"coarse",
	"coast",
	"coat",
	"coax",
	"cobalt",
	"cobra",
	"coca",
	"cock",
	"cocoa",
	"code",
	"coffee",
	"coffin",
	"cohort",
	"coil",
	"coin",
	"coke",
	"cold",
	"collar",
	"colon",
	"colony",
	"colt",
	"column",
	"comb",
	"combat",
	"come",
	"comedy",
	"comic",
	"commit",
	"common",
	"compel",
	"comply",
	"concur",
	"cone",
	"confer",
	"congo",
	"consul",
	"convex",
	"convey",
	"convoy",
	"cook",
	"cool",
	"cope",
	"copper",
	"copy",
	"coral",
	"cord",
	"core",
	"cork",
	"corn",
	"corner",
	"corps",
	"corpse",
	"corpus",
	"cortex",
	"cosmic",
	"cosmos",
	"cost",
	"costly",
	"cotton",
	"couch",
	"cough",
	"could",
	"count",
	"county",
	"coup",
	"couple",
	"coupon",
	"course",
	"court",
	"cousin",
	"cove",
	"cover",
	"covert",
	"cow",
	"coward",
	"cowboy",
	"cozy",
	"crab",
	"crack",
	"cradle",
	"craft",
	"crafty",
	"crag",
	"crane",
	"crash",
	"crate",
	"crater",
	"crawl",
	"crazy",
	"creak",
	"cream",
	"creamy",
	"create",
	"credit",
	"creed",
	"creek",
	"creep",
	"creepy",
	"crept",
	"crest",
	"crew",
	"cried",
	"crime",
	"crisis",
	"crisp",
	"critic",
	"crook",
	"crop",
	"cross",
	"crow",
	"crowd",
	"crown",
	"crude",
	"cruel",
	"cruise",
	"crunch",
	"crush",
	"crust",
	"crux",
	"cry",
	"crypt",
	"cuba",
	"cube",
	"cubic",
	"cuckoo",
	"cuff",
	"cult",
	"cup",
	"curb",
	"cure",
	"curfew",
	"curl",
	"curry",
	"curse",
	"cursor",
	"curve",
	"cuss",
	"custom",
	"cut",
	"cute",
	"cycle",
	"cyclic",
	"cynic",
	"czech",
	"dad",
	"daddy",
	"dagger",
	"daily",
	"dairy",
	"daisy",
	"dale",
	"dam",
	"damage",
	"damp",
	"dampen",
	"dance",
	"danger",
	"danish",
	"dare",
	"dark",
	"darken",
	"darn",
	"dart",
	"dash",
	"data",
	"date",
	"david",
	"dawn",
	"day",
	"dead",
	"deadly",
	"deaf",
	"deal",
	"dealer",
	"dean",
	"dear",
	"death",
	"debate",
	"debit",
	"debris",
	"debt",
	"debtor",
	"decade",
	"decay",
	"decent",
	"decide",
	"deck",
	"decor",
	"decree",
	"deduce",
	"deed",
	"deep",
	"deeply",
	"deer",
	"defeat",
	"defect",
	"defend",
	"defer",
	"define",
	"defy",
	"degree",
	"deity",
	"delay",
	"delete",
	"delhi",
	"delta",
	"demand",
	"demise",
	"demo",
	"demure",
	"denial",
	"denote",
	"dense",
	"dental",
	"deny",
	"depart",
	"depend",
	"depict",
	"deploy",
	"depot",
	"depth",
	"deputy",
	"derive",
	"desert",
	"design",
	"desire",
	"desist",
	"desk",
	"detail",
	"detect",
	"deter",
	"detest",
	"detour",
	"device",
	"devise",
	"devoid",
	"devote",
	"devour",
	"dial",
	"diana",
	"diary",
	"dice",
	"dictum",
	"did",
	"die",
	"diesel",
	"diet",
	"differ",
	"dig",
	"digest",
	"digit",
	"dine",
	"dinghy",
	"dinner",
	"diode",
	"dip",
	"dire",
	"direct",
	"dirt",
	"dirty",
	"disc",
	"disco",
	"dish",
	"disk",
	"dismal",
	"dispel",
	"ditch",
	"dive",
	"divert",
	"divide",
	"divine",
	"dizzy",
	"docile",
	"dock",
	"doctor",
	"dog",
	"dogma",
	"dole",
	"doll",
	"dollar",
	"dolly",
	"domain",
	"dome",
	"domino",
	"donate",
	"done",
	"donkey",
	"donor",
	"doom",
	"door",
	"dorsal",
	"dose",
	"dot",
	"double",
	"doubt",
	"dough",
	"dour",
	"dove",
	"down",
	"dozen",
	"draft",
	"drag",
	"dragon",
	"drain",
	"drama",
	"drank",
	"draw",
	"drawer",
	"dread",
	"dream",
	"dreary",
	"dress",
	"drew",
	"dried",
	"drift",
	"drill",
	"drink",
	"drip",
	"drive",
	"driver",
	"drop",
	"drove",
	"drown",
	"drug",
	"drum",
	"drunk",
	"dry",
	"dual",
	"duck",
	"duct",
	"due",
	"duel",
	"duet",
	"duke",
	"dull",
	"duly",
	"dumb",
	"dummy",
	"dump",
	"dune",
	"dung",
	"duress",
	"during",
	"dusk",
	"dust",
	"dusty",
	"dutch",
	"duty",
	"dwarf",
	"dwell",
	"dyer",
	"dying",
	"dynamo",
	"each",
	"eager",
	"eagle",
	"ear",
	"earl",
	"early",
	"earn",
	"earth",
	"ease",
	"easel",
	"easily",
	"east",
	"easter",
	"easy",
	"eat",
	"eaten",
	"eater",
	"echo",
	"eddy",
	"eden",
	"edge",
	"edible",
	"edict",
	"edit",
	"editor",
	"eel",
	"eerie",
	"eerily",
	"effect",
	"effort",
	"egg",
	"ego",
	"eight",
	"eighth",
	"eighty",
	"either",
	"elbow",
	"elder",
	"eldest",
	"elect",
	"eleven",
	"elicit",
	"elite",
	"else",
	"elude",
	"elves",
	"embark",
	"emblem",
	"embryo",
	"emerge",
	"emit",
	"empire",
	"employ",
	"empty",
	"enable",
	"enamel",
	"end",
	"endure",
	"enemy",
	"energy",
	"engage",
	"engine",
	"enjoy",
	"enlist",
	"enough",
	"ensure",
	"entail",
	"enter",
	"entire",
	"entry",
	"envoy",
	"envy",
	"enzyme",
	"epic",
	"epoch",
	"equal",
	"equate",
	"equip",
	"equity",
	"era",
	"erect",
	"eric",
	"erode",
	"erotic",
	"errant",
	"error",
	"escape",
	"escort",
	"essay",
	"essex",
	"estate",
	"esteem",
	"ethic",
	"ethnic",
	"europe",
	"evade",
	"eve",
	"even",
	"event",
	"ever",
	"every",
	"evict",
	"evil",
	"evoke",
	"evolve",
	"exact",
	"exam",
	"exceed",
	"excel",
	"except",
	"excess",
	"excise",
	"excite",
	"excuse",
	"exempt",
	"exert",
	"exile",
	"exist",
	"exit",
	"exodus",
	"exotic",
	"expand",
	"expect",
	"expert",
	"expire",
	"export",
	"expose",
	"extend",
	"extra",
	"eye",
	"eyed",
	"fabric",
	"face",
	"facial",
	"fact",
	"factor",
	"fade",
	"fail",
	"faint",
	"fair",
	"fairly",
	"fairy",
	"faith",
	"fake",
	"falcon",
	"fall",
	"false",
	"falter",
	"fame",
	"family",
	"famine",
	"famous",
	"fan",
	"fancy",
	"far",
	"farce",
	"fare",
	"farm",
	"farmer",
	"fast",
	"fasten",
	"faster",
	"fat",
	"fatal",
	"fate",
	"father",
	"fatty",
	"fault",
	"faulty",
	"fauna",
	"fear",
	"feast",
	"feat",
	"fed",
	"fee",
	"feeble",
	"feed",
	"feel",
	"feet",
	"fell",
	"fellow",
	"felt",
	"female",
	"fence",
	"fend",
	"ferry",
	"fetal",
	"fetch",
	"feudal",
	"fever",
	"few",
	"fewer",
	"fiasco",
	"fiddle",
	"field",
	"fiend",
	"fierce",
	"fiery",
	"fifth",
	"fifty",
	"fig",
	"fight",
	"figure",
	"file",
	"fill",
	"filled",
	"filler",
	"film",
	"filter",
	"filth",
	"filthy",
	"final",
	"finale",
	"find",
	"fine",
	"finery",
	"finger",
	"finish",
	"finite",
	"fire",
	"firm",
	"firmly",
	"first",
	"fiscal",
	"fish",
	"fisher",
	"fist",
	"fit",
	"fitful",
	"five",
	"fix",
	"flag",
	"flair",
	"flak",
	"flame",
	"flank",
	"flap",
	"flare",
	"flash",
	"flask",
	"flat",
	"flavor",
	"flaw",
	"fled",
	"flee",
	"fleece",
	"fleet",
	"flesh",
	"fleshy",
	"flew",
	"flick",
	"flight",
	"flimsy",
	"flint",
	"flirt",
	"float",
	"flock",
	"flood",
	"floor",
	"floppy",
	"flora",
	"floral",
	"flour",
	"flow",
	"flower",
	"fluent",
	"fluffy",
	"fluid",
	"flung",
	"flurry",
	"flush",
	"flute",
	"flux",
	"fly",
	"flyer",
	"foal",
	"foam",
	"focal",
	"focus",
	"fog",
	"foil",
	"fold",
	"folk",
	"follow",
	"folly",
	"fond",
	"fondly",
	"font",
	"food",
	"fool",
	"foot",
	"for",
	"forbid",
	"force",
	"ford",
	"forest",
	"forge",
	"forget",
	"fork",
	"form",
	"formal",
	"format",
	"former",
	"fort",
	"forth",
	"forty",
	"forum",
	"fossil",
	"foster",
	"foul",
	"found",
	"four",
	"fourth",
	"fox",
	"foyer",
	"frail",
	"frame",
	"franc",
	"france",
	"frank",
	"fraud",
	"fred",
	"free",
	"freed",
	"freely",
	"freeze",
	"french",
	"frenzy",
	"fresh",
	"friar",
	"friday",
	"fridge",
	"fried",
	"friend",
	"fright",
	"fringe",
	"frock",
	"frog",
	"from",
	"front",
	"frost",
	"frosty",
	"frown",
	"frozen",
	"frugal",
	"fruit",
	"fry",
	"fudge",
	"fuel",
	"full",
	"fully",
	"fumes",
	"fun",
	"fund",
	"funny",
	"fur",
	"furry",
	"fury",
	"fuse",
	"fusion",
	"fuss",
	"fussy",
	"futile",
	"future",
	"fuzzy",
	"gadget",
	"gain",
	"gala",
	"galaxy",
	"gale",
	"gall",
	"galley",
	"gallon",
	"gallop",
	"gamble",
	"game",
	"gamma",
	"gandhi",
	"gang",
	"gap",
	"garage",
	"garden",
	"garlic",
	"gas",
	"gasp",
	"gate",
	"gather",
	"gauge",
	"gaunt",
	"gave",
	"gaze",
	"gear",
	"geese",
	"gem",
	"gemini",
	"gender",
	"gene",
	"geneva",
	"genial",
	"genius",
	"genre",
	"gentle",
	"gently",
	"gentry",
	"genus",
	"george",
	"germ",
	"get",
	"ghetto",
	"ghost",
	"giant",
	"gift",
	"giggle",
	"gill",
	"gilt",
	"ginger",
	"girl",
	"give",
	"given",
	"glad",
	"glade",
	"glance",
	"gland",
	"glare",
	"glass",
	"glassy",
	"gleam",
	"glee",
	"glide",
	"global",
	"globe",
	"gloom",
	"gloomy",
	"gloria",
	"glory",
	"gloss",
	"glossy",
	"glove",
	"glow",
	"glue",
	"gnat",
	"gnu",
	"goal",
	"goat",
	"gold",
	"golden",
	"golf",
	"gone",
	"gong",
	"goo",
	"good",
	"goose",
	"gore",
	"gorge",
	"gory",
	"gosh",
	"gospel",
	"gossip",
	"got",
	"gothic",
	"govern",
	"gown",
	"grab",
	"grace",
	"grade",
	"grail",
	"grain",
	"grand",
	"grant",
	"grape",
	"graph",
	"grasp",
	"grass",
	"grassy",
	"grate",
	"grave",
	"gravel",
	"gravy",
	"grease",
	"greasy",
	"great",
	"greece",
	"greed",
	"greedy",
	"greek",
	"green",
	"greet",
	"grew",
	"grey",
	"grid",
	"grief",
	"grill",
	"grim",
	"grin",
	"grind",
	"grip",
	"grit",
	"gritty",
	"groan",
	"groin",
	"groom",
	"groove",
	"gross",
	"ground",
	"group",
	"grove",
	"grow",
	"grown",
	"growth",
	"grudge",
	"grunt",
	"guard",
	"guess",
	"guest",
	"guide",
	"guild",
	"guilt",
	"guilty",
	"guise",
	"guitar",
	"gulf",
	"gully",
	"gun",
	"gunman",
	"guru",
	"gut",
	"guy",
	"gypsy",
	"habit",
	"hack",
	"had",
	"hail",
	"hair",
	"hairy",
	"haiti",
	"hale",
	"half",
	"hall",
	"halt",
	"hamlet",
	"hammer",
	"hand",
	"handle",
	"handy",
	"hang",
	"hangar",
	"hanoi",
	"happen",
	"happy",
	"harass",
	"harbor",
	"hard",
	"harder",
	"hardly",
	"hare",
	"harem",
	"harm",
	"harp",
	"harry",
	"harsh",
	"has",
	"hash",
	"hassle",
	"haste",
	"hasten",
	"hasty",
	"hat",
	"hatch",
	"hate",
	"haul",
	"haunt",
	"havana",
	"have",
	"haven",
	"havoc",
	"hawaii",
	"hawk",
	"hay",
	"hazard",
	"haze",
	"hazel",
	"hazy",
	"head",
	"heal",
	"health",
	"heap",
	"hear",
	"heard",
	"heart",
	"hearth",
	"hearty",
	"heat",
	"heater",
	"heaven",
	"heavy",
	"hebrew",
	"heck",
	"hectic",
	"hedge",
	"heel",
	"hefty",
	"height",
	"heir",
	"held",
	"helium",
	"helix",
	"hell",
	"hello",
	"helm",
	"helmet",
	"help",
	"hemp",
	"hence",
	"henry",
	"her",
	"herald",
	"herb",
	"herd",
	"here",
	"hereby",
	"hermes",
	"hernia",
	"hero",
	"heroic",
	"heroin",
	"hey",
	"heyday",
	"hick",
	"hidden",
	"hide",
	"high",
	"higher",
	"highly",
	"hill",
	"him",
	"hind",
	"hinder",
	"hint",
	"hippie",
	"hire",
	"his",
	"hiss",
	"hit",
	"hive",
	"hoard",
	"hoarse",
	"hobby",
	"hockey",
	"hold",
	"holder",
	"hole",
	"hollow",
	"holly",
	"holy",
	"home",
	"honest",
	"honey",
	"hood",
	"hook",
	"hope",
	"horn",
	"horrid",
	"horror",
	"horse",
	"hose",
	"host",
	"hot",
	"hotel",
	"hound",
	"hour",
	"house",
	"hover",
	"how",
	"huge",
	"hull",
	"human",
	"humane",
	"humble",
	"humid",
	"hung",
	"hunger",
	"hungry",
	"hunt",
	"hurdle",
	"hurl",
	"hurry",
	"hurt",
	"hush",
	"hut",
	"hybrid",
	"hymn",
	"hyphen",
	"ice",
	"icing",
	"icon",
	"idaho",
	"idea",
	"ideal",
	"idiom",
	"idiot",
	"idle",
	"idly",
	"idol",
	"ignite",
	"ignore",
	"ill",
	"image",
	"immune",
	"impact",
	"imply",
	"import",
	"impose",
	"inca",
	"incest",
	"inch",
	"income",
	"incur",
	"indeed",
	"index",
	"india",
	"indian",
	"indoor",
	"induce",
	"inept",
	"inert",
	"infant",
	"infect",
	"infer",
	"influx",
	"inform",
	"inject",
	"injure",
	"injury",
	"ink",
	"inlaid",
	"inland",
	"inlet",
	"inmate",
	"inn",
	"innate",
	"inner",
	"input",
	"insane",
	"insect",
	"insert",
	"inset",
	"inside",
	"insist",
	"insult",
	"insure",
	"intact",
	"intake",
	"intend",
	"inter",
	"into",
	"invade",
	"invent",
	"invest",
	"invite",
	"invoke",
	"inward",
	"iowa",
	"iran",
	"iraq",
	"irish",
	"iron",
	"ironic",
	"irony",
	"isaac",
	"isabel",
	"island",
	"isle",
	"israel",
	"issue",
	"italy",
	"itch",
	"item",
	"itself",
	"ivan",
	"ivory",
	"jack",
	"jacket",
	"jacob",
	"jade",
	"jaguar",
	"jail",
	"james",
	"jane",
	"japan",
	"jargon",
	"java",
	"jaw",
	"jazz",
	"jeep",
	"jelly",
	"jerky",
	"jest",
	"jet",
	"jewel",
	"jewish",
	"jim",
	"job",
	"jock",
	"jockey",
	"joe",
	"john",
	"join",
	"joint",
	"joke",
	"jolly",
	"jolt",
	"jordan",
	"joseph",
	"joy",
	"joyful",
	"joyous",
	"judge",
	"judy",
	"juice",
	"juicy",
	"july",
	"jumble",
	"jumbo",
	"jump",
	"june",
	"jungle",
	"junior",
	"junk",
	"junta",
	"jury",
	"just",
	"kansas",
	"karate",
	"karl",
	"keel",
	"keen",
	"keep",
	"keeper",
	"kenya",
	"kept",
	"kernel",
	"kettle",
	"key",
	"khaki",
	"kick",
	"kid",
	"kidnap",
	"kidney",
	"kill",
	"killer",
	"kin",
	"kind",
	"kindly",
	"king",
	"kiss",
	"kite",
	"kitten",
	"knack",
	"knee",
	"kneel",
	"knew",
	"knife",
	"knight",
	"knit",
	"knob",
	"knock",
	"knot",
	"know",
	"known",
	"koran",
	"korea",
	"kuwait",
	"label",
	"lace",
	"lack",
	"lad",
	"ladder",
	"laden",
	"lady",
	"lagoon",
	"laity",
	"lake",
	"lamb",
	"lame",
	"lamp",
	"lance",
	"land",
	"lane",
	"lap",
	"lapse",
	"large",
	"larval",
	"laser",
	"last",
	"latch",
	"late",
	"lately",
	"latent",
	"later",
	"latest",
	"latin",
	"latter",
	"laugh",
	"launch",
	"lava",
	"lavish",
	"law",
	"lawful",
	"lawn",
	"lawyer",
	"lay",
	"layer",
	"layman",
	"lazy",
	"lead",
	"leader",
	"leaf",
	"leafy",
	"league",
	"leak",
	"leaky",
	"lean",
	"leap",
	"learn",
	"lease",
	"leash",
	"least",
	"leave",
	"led",
	"ledge",
	"left",
	"leg",
	"legacy",
	"legal",
	"legend",
	"legion",
	"lemon",
	"lend",
	"length",
	"lens",
	"lent",
	"leo",
	"leper",
	"lesion",
	"less",
	"lessen",
	"lesser",
	"lesson",
	"lest",
	"let",
	"lethal",
	"letter",
	"level",
	"lever",
	"levy",
	"lewis",
	"liable",
	"liar",
	"libel",
	"libya",
	"lice",
	"lick",
	"lid",
	"lie",
	"lied",
	"lier",
	"life",
	"lift",
	"light",
	"like",
	"likely",
	"limb",
	"lime",
	"limit",
	"limp",
	"line",
	"linear",
	"linen",
	"linger",
	"link",
	"lint",
	"lion",
	"lip",
	"liquid",
	"liquor",
	"list",
	"listen",
	"lit",
	"live",
	"lively",
	"liver",
	"liz",
	"lizard",
	"load",
	"loaf",
	"loan",
	"lobby",
	"lobe",
	"local",
	"locate",
	"lock",
	"locus",
	"lodge",
	"loft",
	"lofty",
	"github.com/rs/zerolog/log",
	"logic",
	"logo",
	"london",
	"lone",
	"lonely",
	"long",
	"longer",
	"look",
	"loop",
	"loose",
	"loosen",
	"loot",
	"lord",
	"lorry",
	"lose",
	"loss",
	"lost",
	"lot",
	"lotion",
	"lotus",
	"loud",
	"loudly",
	"lounge",
	"lousy",
	"love",
	"lovely",
	"lover",
	"low",
	"lower",
	"lowest",
	"loyal",
	"lucid",
	"luck",
	"lucky",
	"lucy",
	"lull",
	"lump",
	"lumpy",
	"lunacy",
	"lunar",
	"lunch",
	"lung",
	"lure",
	"lurid",
	"lush",
	"lust",
	"lute",
	"luther",
	"luxury",
	"lying",
	"lymph",
	"lynch",
	"lyric",
	"macho",
	"macro",
	"mad",
	"madam",
	"made",
	"mafia",
	"magic",
	"magma",
	"magnet",
	"magnum",
	"magpie",
	"maid",
	"maiden",
	"mail",
	"main",
	"mainly",
	"major",
	"make",
	"maker",
	"male",
	"malice",
	"mall",
	"malt",
	"mammal",
	"manage",
	"mane",
	"mania",
	"manic",
	"manner",
	"manor",
	"mantle",
	"manual",
	"manure",
	"many",
	"map",
	"maple",
	"marble",
	"march",
	"mare",
	"margin",
	"maria",
	"marina",
	"mark",
	"market",
	"marry",
	"mars",
	"marsh",
	"martin",
	"martyr",
	"mary",
	"mask",
	"mason",
	"mass",
	"mast",
	"master",
	"mat",
	"match",
	"mate",
	"matrix",
	"matter",
	"mature",
	"maxim",
	"may",
	"maybe",
	"mayor",
	"maze",
	"mead",
	"meadow",
	"meal",
	"mean",
	"meant",
	"meat",
	"medal",
	"media",
	"median",
	"medic",
	"medium",
	"meet",
	"mellow",
	"melody",
	"melon",
	"melt",
	"member",
	"memo",
	"memory",
	"menace",
	"mend",
	"mental",
	"mentor",
	"menu",
	"mercy",
	"mere",
	"merely",
	"merge",
	"merger",
	"merit",
	"merry",
	"mesh",
	"mess",
	"messy",
	"met",
	"metal",
	"meter",
	"_Method",
	"methyl",
	"metric",
	"metro",
	"mexico",
	"miami",
	"mickey",
	"mid",
	"midday",
	"middle",
	"midst",
	"midway",
	"might",
	"mighty",
	"mild",
	"mildew",
	"mile",
	"milk",
	"milky",
	"mill",
	"mimic",
	"mince",
	"mind",
	"mine",
	"mini",
	"mink",
	"minor",
	"mint",
	"minus",
	"minute",
	"mire",
	"mirror",
	"mirth",
	"misery",
	"miss",
	"mist",
	"misty",
	"mite",
	"mix",
	"moan",
	"moat",
	"mob",
	"mobile",
	"mock",
	"mode",
	"model",
	"modem",
	"modern",
	"modest",
	"modify",
	"module",
	"moist",
	"molar",
	"mold",
	"mole",
	"molten",
	"moment",
	"monday",
	"money",
	"monk",
	"monkey",
	"month",
	"mood",
	"moody",
	"moon",
	"moor",
	"moral",
	"morale",
	"morbid",
	"more",
	"morgue",
	"mortal",
	"mortar",
	"mosaic",
	"moscow",
	"moses",
	"mosque",
	"moss",
	"most",
	"mostly",
	"moth",
	"mother",
	"motion",
	"motive",
	"motor",
	"mount",
	"mourn",
	"mouse",
	"mouth",
	"move",
	"movie",
	"mrs",
	"much",
	"muck",
	"mucus",
	"mud",
	"muddle",
	"muddy",
	"mule",
	"mummy",
	"munich",
	"murder",
	"murky",
	"murmur",
	"muscle",
	"museum",
	"music",
	"mussel",
	"must",
	"mutant",
	"mute",
	"mutiny",
	"mutter",
	"mutton",
	"mutual",
	"muzzle",
	"myopic",
	"myriad",
	"myself",
	"mystic",
	"myth",
	"nadir",
	"nail",
	"naked",
	"name",
	"namely",
	"nape",
	"napkin",
	"naples",
	"narrow",
	"nasal",
	"nasty",
	"nathan",
	"nation",
	"native",
	"nature",
	"nausea",
	"naval",
	"nave",
	"navy",
	"near",
	"nearer",
	"nearly",
	"neat",
	"neatly",
	"neck",
	"need",
	"needle",
	"needy",
	"negate",
	"neon",
	"nepal",
	"nephew",
	"nerve",
	"nest",
	"net",
	"neural",
	"never",
	"newly",
	"next",
	"nice",
	"nicely",
	"niche",
	"nickel",
	"niece",
	"night",
	"nile",
	"nimble",
	"nine",
	"ninety",
	"ninth",
	"nobel",
	"noble",
	"nobody",
	"_Node",
	"noise",
	"noisy",
	"none",
	"noon",
	"nor",
	"norm",
	"normal",
	"north",
	"norway",
	"nose",
	"nosy",
	"not",
	"note",
	"notice",
	"notify",
	"notion",
	"noun",
	"novel",
	"novice",
	"now",
	"nozzle",
	"null",
	"numb",
	"number",
	"nurse",
	"nut",
	"nylon",
	"nymph",
	"oak",
	"oar",
	"oasis",
	"oath",
	"obese",
	"obey",
	"object",
	"oblige",
	"oboe",
	"obtain",
	"obtuse",
	"occult",
	"occupy",
	"occur",
	"ocean",
	"octave",
	"odd",
	"off",
	"offend",
	"offer",
	"office",
	"offset",
	"often",
	"ohio",
	"oil",
	"oily",
	"okay",
	"old",
	"older",
	"oldest",
	"olive",
	"omega",
	"omen",
	"omit",
	"once",
	"one",
	"onion",
	"only",
	"onset",
	"onto",
	"onus",
	"onward",
	"opaque",
	"open",
	"openly",
	"opera",
	"opium",
	"oppose",
	"optic",
	"option",
	"oracle",
	"oral",
	"orange",
	"orbit",
	"orchid",
	"ordeal",
	"order",
	"organ",
	"orgasm",
	"orient",
	"origin",
	"ornate",
	"orphan",
	"oscar",
	"other",
	"otter",
	"ought",
	"ounce",
	"our",
	"out",
	"outer",
	"output",
	"outset",
	"oval",
	"oven",
	"over",
	"overt",
	"owe",
	"owing",
	"owl",
	"own",
	"owner",
	"oxford",
	"oxide",
	"oxygen",
	"oyster",
	"ozone",
	"pace",
	"pack",
	"packet",
	"pact",
	"pad",
	"paddle",
	"paddy",
	"pagan",
	"page",
	"paid",
	"pain",
	"paint",
	"pair",
	"palace",
	"pale",
	"palm",
	"pan",
	"panama",
	"panel",
	"panic",
	"papa",
	"papal",
	"paper",
	"parade",
	"parcel",
	"pardon",
	"parent",
	"paris",
	"parish",
	"park",
	"parody",
	"parrot",
	"part",
	"partly",
	"party",
	"pascal",
	"pass",
	"past",
	"paste",
	"pastel",
	"pastor",
	"pastry",
	"pat",
	"patch",
	"patent",
	"path",
	"patio",
	"patrol",
	"patron",
	"paul",
	"pause",
	"pave",
	"paw",
	"pawn",
	"pay",
	"peace",
	"peach",
	"peak",
	"pear",
	"pearl",
	"pedal",
	"peel",
	"peer",
	"peking",
	"pelvic",
	"pelvis",
	"pen",
	"penal",
	"pence",
	"pencil",
	"penny",
	"people",
	"pepper",
	"per",
	"perch",
	"peril",
	"period",
	"perish",
	"permit",
	"person",
	"peru",
	"pest",
	"pet",
	"peter",
	"petite",
	"petrol",
	"petty",
	"phase",
	"philip",
	"phone",
	"photo",
	"phrase",
	"piano",
	"pick",
	"picket",
	"picnic",
	"pie",
	"piece",
	"pier",
	"pierce",
	"piety",
	"pig",
	"pigeon",
	"piggy",
	"pike",
	"pile",
	"pill",
	"pillar",
	"pillow",
	"pilot",
	"pin",
	"pinch",
	"pine",
	"pink",
	"pint",
	"pious",
	"pipe",
	"pirate",
	"piss",
	"pistol",
	"piston",
	"pit",
	"pitch",
	"pity",
	"pivot",
	"pixel",
	"pizza",
	"place",
	"placid",
	"plague",
	"plain",
	"plan",
	"plane",
	"planet",
	"plank",
	"plant",
	"plasma",
	"plate",
	"play",
	"player",
	"plea",
	"plead",
	"please",
	"pledge",
	"plenty",
	"plight",
	"plot",
	"plough",
	"ploy",
	"plug",
	"plum",
	"plump",
	"plunge",
	"plural",
	"plus",
	"plush",
	"pocket",
	"poem",
	"poet",
	"poetic",
	"poetry",
	"point",
	"poison",
	"poland",
	"polar",
	"pole",
	"police",
	"policy",
	"polish",
	"polite",
	"poll",
	"pollen",
	"polo",
	"pond",
	"ponder",
	"pony",
	"pool",
	"poor",
	"poorly",
	"pop",
	"poppy",
	"pore",
	"pork",
	"port",
	"portal",
	"pose",
	"posh",
	"post",
	"postal",
	"pot",
	"potato",
	"potent",
	"pouch",
	"pound",
	"pour",
	"powder",
	"power",
	"praise",
	"pray",
	"prayer",
	"preach",
	"prefer",
	"prefix",
	"press",
	"pretty",
	"price",
	"pride",
	"priest",
	"primal",
	"prime",
	"prince",
	"print",
	"prior",
	"prism",
	"prison",
	"privy",
	"prize",
	"probe",
	"profit",
	"prompt",
	"prone",
	"proof",
	"propel",
	"proper",
	"prose",
	"proton",
	"proud",
	"prove",
	"proven",
	"proxy",
	"prune",
	"pry",
	"psalm",
	"pseudo",
	"psyche",
	"pub",
	"public",
	"puff",
	"pull",
	"pulp",
	"pulpit",
	"pulsar",
	"pulse",
	"pump",
	"punch",
	"punish",
	"punk",
	"pupil",
	"puppet",
	"puppy",
	"pure",
	"purely",
	"purge",
	"purify",
	"purple",
	"purse",
	"pursue",
	"push",
	"pushy",
	"put",
	"putt",
	"puzzle",
	"quaint",
	"quake",
	"quarry",
	"quart",
	"quartz",
	"quebec",
	"queen",
	"queer",
	"query",
	"quest",
	"queue",
	"quick",
	"quid",
	"quiet",
	"quilt",
	"quirk",
	"quit",
	"quite",
	"quiver",
	"quiz",
	"quota",
	"quote",
	"rabbit",
	"race",
	"racial",
	"racism",
	"rack",
	"racket",
	"radar",
	"radio",
	"radish",
	"radius",
	"raffle",
	"raft",
	"rage",
	"raid",
	"rail",
	"rain",
	"rainy",
	"raise",
	"rake",
	"rally",
	"ramp",
	"random",
	"range",
	"rank",
	"ransom",
	"rape",
	"rapid",
	"rare",
	"rarely",
	"rarity",
	"rash",
	"rat",
	"rate",
	"rather",
	"ratify",
	"ratio",
	"rattle",
	"rave",
	"raven",
	"raw",
	"ray",
	"razor",
	"reach",
	"react",
	"read",
	"reader",
	"ready",
	"real",
	"really",
	"realm",
	"reap",
	"rear",
	"reason",
	"rebel",
	"recall",
	"recent",
	"recess",
	"recipe",
	"reckon",
	"record",
	"recoup",
	"rector",
	"red",
	"redeem",
	"redo",
	"reduce",
	"reed",
	"reef",
	"reek",
	"refer",
	"reform",
	"refuge",
	"refuse",
	"regal",
	"regard",
	"regent",
	"regime",
	"region",
	"regret",
	"reign",
	"reject",
	"relate",
	"relax",
	"relay",
	"relic",
	"relief",
	"relish",
	"rely",
	"remain",
	"remark",
	"remedy",
	"remind",
	"remit",
	"remote",
	"remove",
	"renal",
	"render",
	"rent",
	"rental",
	"repair",
	"repeal",
	"repeat",
	"repent",
	"reply",
	"report",
	"rescue",
	"resent",
	"reside",
	"resign",
	"resin",
	"resist",
	"resort",
	"rest",
	"result",
	"resume",
	"retail",
	"retain",
	"retina",
	"retire",
	"return",
	"reveal",
	"review",
	"revise",
	"revive",
	"revolt",
	"reward",
	"rex",
	"rhine",
	"rhino",
	"rhyme",
	"rhythm",
	"ribbon",
	"rice",
	"rich",
	"rick",
	"rid",
	"ride",
	"rider",
	"ridge",
	"rife",
	"rifle",
	"rift",
	"right",
	"rigid",
	"rile",
	"rim",
	"ring",
	"rinse",
	"riot",
	"ripe",
	"ripen",
	"ripple",
	"rise",
	"risk",
	"risky",
	"rite",
	"ritual",
	"ritz",
	"rival",
	"river",
	"road",
	"roar",
	"roast",
	"rob",
	"robe",
	"robert",
	"robin",
	"robot",
	"robust",
	"rock",
	"rocket",
	"rocky",
	"rod",
	"rode",
	"rodent",
	"rogue",
	"role",
	"roll",
	"roman",
	"rome",
	"roof",
	"room",
	"root",
	"rope",
	"rose",
	"rosy",
	"rot",
	"rotate",
	"rotor",
	"rotten",
	"rouge",
	"rough",
	"round",
	"route",
	"rover",
	"row",
	"royal",
	"rub",
	"rubber",
	"rubble",
	"ruby",
	"rudder",
	"rude",
	"rug",
	"rugby",
	"ruin",
	"rule",
	"ruler",
	"rumble",
	"rump",
	"run",
	"rune",
	"rung",
	"runway",
	"rural",
	"rush",
	"russia",
	"rust",
	"rustic",
	"rusty",
	"sack",
	"sacred",
	"sad",
	"saddle",
	"sadism",
	"sadly",
	"safari",
	"safe",
	"safely",
	"safer",
	"safety",
	"saga",
	"sage",
	"sahara",
	"said",
	"sail",
	"sailor",
	"saint",
	"sake",
	"salad",
	"salary",
	"sale",
	"saline",
	"saliva",
	"salmon",
	"saloon",
	"salt",
	"salty",
	"salute",
	"sam",
	"same",
	"sample",
	"sand",
	"sandy",
	"sane",
	"sash",
	"satin",
	"satire",
	"saturn",
	"sauce",
	"saucer",
	"saudi",
	"sauna",
	"savage",
	"save",
	"saw",
	"say",
	"scale",
	"scalp",
	"scan",
	"scant",
	"scar",
	"scarce",
	"scare",
	"scarf",
	"scary",
	"scene",
	"scenic",
	"scent",
	"school",
	"scold",
	"scope",
	"score",
	"scorn",
	"scotch",
	"scott",
	"scout",
	"scrap",
	"scrape",
	"scream",
	"screen",
	"screw",
	"script",
	"scroll",
	"scrub",
	"scum",
	"sea",
	"seal",
	"seam",
	"seaman",
	"search",
	"season",
	"seat",
	"second",
	"secret",
	"sect",
	"sector",
	"secure",
	"see",
	"seed",
	"seeing",
	"seek",
	"seem",
	"seize",
	"seldom",
	"select",
	"self",
	"sell",
	"seller",
	"semi",
	"senate",
	"send",
	"senile",
	"senior",
	"sense",
	"sensor",
	"sent",
	"sentry",
	"seoul",
	"sequel",
	"serene",
	"serial",
	"series",
	"sermon",
	"serum",
	"serve",
	"server",
	"set",
	"settle",
	"seven",
	"severe",
	"sew",
	"sewage",
	"shabby",
	"shade",
	"shadow",
	"shady",
	"shaft",
	"shaggy",
	"shah",
	"shake",
	"shaky",
	"shall",
	"sham",
	"shame",
	"shape",
	"share",
	"shark",
	"sharp",
	"shawl",
	"she",
	"shear",
	"sheen",
	"sheep",
	"sheer",
	"sheet",
	"shelf",
	"shell",
	"sherry",
	"shield",
	"shift",
	"shine",
	"shiny",
	"ship",
	"shire",
	"shirk",
	"shirt",
	"shiver",
	"shock",
	"shoe",
	"shook",
	"shoot",
	"shop",
	"shore",
	"short",
	"shot",
	"should",
	"shout",
	"show",
	"shower",
	"shrank",
	"shrewd",
	"shrill",
	"shrimp",
	"shrine",
	"shrink",
	"shrub",
	"shrug",
	"shut",
	"shy",
	"shyly",
	"sick",
	"side",
	"siege",
	"sigh",
	"sight",
	"sigma",
	"sign",
	"signal",
	"silent",
	"silk",
	"silken",
	"silky",
	"sill",
	"silly",
	"silo",
	"silver",
	"simple",
	"simply",
	"since",
	"sinful",
	"sing",
	"singer",
	"single",
	"sink",
	"sir",
	"sire",
	"siren",
	"sister",
	"sit",
	"site",
	"sitter",
	"six",
	"sixth",
	"sixty",
	"size",
	"sketch",
	"skill",
	"skin",
	"skinny",
	"skip",
	"skirt",
	"skull",
	"sky",
	"slab",
	"slack",
	"slain",
	"slam",
	"slang",
	"slap",
	"slat",
	"slate",
	"slave",
	"sleek",
	"sleep",
	"sleepy",
	"sleeve",
	"slice",
	"slick",
	"slid",
	"slide",
	"slight",
	"slim",
	"slimy",
	"sling",
	"slip",
	"slit",
	"slogan",
	"slope",
	"sloppy",
	"slot",
	"slow",
	"slowly",
	"slug",
	"slum",
	"slump",
	"smack",
	"small",
	"smart",
	"smash",
	"smear",
	"smell",
	"smelly",
	"smelt",
	"smile",
	"smite",
	"smoke",
	"smoky",
	"smooth",
	"smug",
	"snack",
	"snail",
	"snake",
	"snap",
	"snatch",
	"sneak",
	"snow",
	"snowy",
	"snug",
	"soak",
	"soap",
	"sober",
	"soccer",
	"social",
	"sock",
	"socket",
	"socks",
	"soda",
	"sodden",
	"sodium",
	"sofa",
	"soft",
	"soften",
	"softly",
	"soggy",
	"soil",
	"solar",
	"sold",
	"sole",
	"solely",
	"solemn",
	"solid",
	"solo",
	"solve",
	"some",
	"son",
	"sonar",
	"sonata",
	"song",
	"sonic",
	"sony",
	"soon",
	"sooner",
	"soot",
	"soothe",
	"sordid",
	"sore",
	"sorrow",
	"sorry",
	"sort",
	"soul",
	"sound",
	"soup",
	"sour",
	"source",
	"soviet",
	"sow",
	"space",
	"spade",
	"spain",
	"span",
	"spare",
	"spark",
	"sparse",
	"spasm",
	"spat",
	"spate",
	"speak",
	"spear",
	"speech",
	"speed",
	"speedy",
	"spell",
	"spend",
	"sphere",
	"spice",
	"spicy",
	"spider",
	"spiky",
	"spill",
	"spin",
	"spinal",
	"spine",
	"spiral",
	"spirit",
	"spit",
	"spite",
	"splash",
	"split",
	"spoil",
	"spoke",
	"sponge",
	"spoon",
	"sport",
	"spot",
	"spouse",
	"spray",
	"spread",
	"spree",
	"spring",
	"sprint",
	"spur",
	"squad",
	"square",
	"squash",
	"squat",
	"squid",
	"stab",
	"stable",
	"stack",
	"staff",
	"stage",
	"stain",
	"stair",
	"stairs",
	"stake",
	"stale",
	"stall",
	"stamp",
	"stance",
	"stand",
	"staple",
	"star",
	"starch",
	"stare",
	"stark",
	"start",
	"starve",
	"state",
	"static",
	"statue",
	"status",
	"stay",
	"stead",
	"steady",
	"steak",
	"steal",
	"steam",
	"steel",
	"steep",
	"steer",
	"stem",
	"stench",
	"step",
	"stereo",
	"stern",
	"stew",
	"stick",
	"sticky",
	"stiff",
	"stifle",
	"stigma",
	"still",
	"sting",
	"stint",
	"stir",
	"stitch",
	"stock",
	"stocky",
	"stone",
	"stony",
	"stool",
	"stop",
	"store",
	"storm",
	"stormy",
	"story",
	"stout",
	"stove",
	"stow",
	"strain",
	"strait",
	"strand",
	"strap",
	"strata",
	"straw",
	"stray",
	"streak",
	"stream",
	"street",
	"stress",
	"strict",
	"stride",
	"strife",
	"strike",
	"string",
	"strip",
	"stripe",
	"strive",
	"stroke",
	"stroll",
	"strong",
	"stud",
	"studio",
	"study",
	"stuff",
	"stuffy",
	"stunt",
	"stupid",
	"sturdy",
	"style",
	"submit",
	"subtle",
	"subtly",
	"suburb",
	"such",
	"sudden",
	"sue",
	"suez",
	"suffer",
	"sugar",
	"suit",
	"suite",
	"suitor",
	"sullen",
	"sultan",
	"sum",
	"summer",
	"summit",
	"summon",
	"sun",
	"sunday",
	"sunny",
	"sunset",
	"super",
	"superb",
	"supper",
	"supple",
	"supply",
	"sure",
	"surely",
	"surf",
	"surge",
	"survey",
	"suture",
	"swamp",
	"swan",
	"swap",
	"swarm",
	"sway",
	"swear",
	"sweat",
	"sweaty",
	"sweden",
	"sweep",
	"sweet",
	"swell",
	"swift",
	"swim",
	"swine",
	"swing",
	"swirl",
	"swiss",
	"switch",
	"sword",
	"swore",
	"sydney",
	"symbol",
	"synod",
	"syntax",
	"syria",
	"syrup",
	"system",
	"table",
	"tablet",
	"taboo",
	"tacit",
	"tackle",
	"tact",
	"tactic",
	"tail",
	"tailor",
	"taiwan",
	"take",
	"tale",
	"talent",
	"talk",
	"tall",
	"tally",
	"tame",
	"tampa",
	"tan",
	"tandem",
	"tangle",
	"tank",
	"tap",
	"tape",
	"target",
	"tariff",
	"tarp",
	"tart",
	"tarzan",
	"task",
	"taste",
	"tasty",
	"tattoo",
	"taurus",
	"taut",
	"tavern",
	"tax",
	"taxi",
	"tea",
	"teach",
	"teak",
	"team",
	"tear",
	"tease",
	"tech",
	"teeth",
	"tell",
	"temper",
	"temple",
	"tempo",
	"tempt",
	"ten",
	"tenant",
	"tend",
	"tender",
	"tendon",
	"tennis",
	"tenor",
	"tense",
	"tent",
	"tenth",
	"tenure",
	"teresa",
	"term",
	"terror",
	"terse",
	"test",
	"texas",
	"text",
	"thank",
	"thaw",
	"them",
	"theme",
	"thence",
	"theory",
	"there",
	"these",
	"thesis",
	"they",
	"thick",
	"thief",
	"thigh",
	"thin",
	"thing",
	"think",
	"third",
	"thirst",
	"thirty",
	"this",
	"thomas",
	"thorn",
	"those",
	"though",
	"thread",
	"threat",
	"three",
	"thrill",
	"thrive",
	"throat",
	"throne",
	"throng",
	"throw",
	"thrust",
	"thud",
	"thug",
	"thumb",
	"thus",
	"thyme",
	"tibet",
	"tick",
	"ticket",
	"tidal",
	"tide",
	"tidy",
	"tie",
	"tier",
	"tiger",
	"tight",
	"tile",
	"till",
	"tilt",
	"timber",
	"time",
	"timid",
	"tin",
	"tiny",
	"tip",
	"tire",
	"tissue",
	"title",
	"toad",
	"toast",
	"today",
	"toe",
	"toilet",
	"token",
	"tokyo",
	"told",
	"toll",
	"tom",
	"tomato",
	"tomb",
	"tonal",
	"tone",
	"tongue",
	"tonic",
	"too",
	"took",
	"tool",
	"tooth",
	"top",
	"topaz",
	"topic",
	"torch",
	"torque",
	"torso",
	"tort",
	"toss",
	"total",
	"touch",
	"tough",
	"tour",
	"toward",
	"towel",
	"tower",
	"town",
	"toxic",
	"toxin",
	"toy",
	"trace",
	"track",
	"tract",
	"trade",
	"tragic",
	"trail",
	"train",
	"trait",
	"tram",
	"trance",
	"trap",
	"trauma",
	"travel",
	"tray",
	"tread",
	"treat",
	"treaty",
	"treble",
	"tree",
	"trek",
	"tremor",
	"trench",
	"trend",
	"trendy",
	"trial",
	"tribal",
	"tribe",
	"trick",
	"tricky",
	"tried",
	"trifle",
	"trim",
	"trio",
	"trip",
	"triple",
	"troop",
	"trophy",
	"trot",
	"trough",
	"trout",
	"truce",
	"truck",
	"true",
	"truly",
	"trunk",
	"trust",
	"truth",
	"try",
	"tube",
	"tumble",
	"tuna",
	"tundra",
	"tune",
	"tunic",
	"tunnel",
	"turban",
	"turf",
	"turk",
	"turkey",
	"turn",
	"turtle",
	"tutor",
	"tweed",
	"twelve",
	"twenty",
	"twice",
	"twin",
	"twist",
	"two",
	"tycoon",
	"tying",
	"type",
	"tyrant",
	"ugly",
	"ulcer",
	"ultra",
	"umpire",
	"unable",
	"uncle",
	"under",
	"uneasy",
	"unfair",
	"unify",
	"union",
	"unique",
	"unit",
	"unite",
	"unity",
	"unlike",
	"unrest",
	"unruly",
	"until",
	"update",
	"upheld",
	"uphill",
	"uphold",
	"upon",
	"upper",
	"uproar",
	"upset",
	"upshot",
	"uptake",
	"upturn",
	"upward",
	"urban",
	"urge",
	"urgent",
	"urging",
	"urine",
	"usable",
	"usage",
	"use",
	"useful",
	"user",
	"usual",
	"utmost",
	"utter",
	"vacant",
	"vacuum",
	"vague",
	"vain",
	"valet",
	"valid",
	"valley",
	"value",
	"valve",
	"van",
	"vanish",
	"vanity",
	"vary",
	"vase",
	"vast",
	"vat",
	"vault",
	"vector",
	"veil",
	"vein",
	"velvet",
	"vendor",
	"veneer",
	"venice",
	"venom",
	"vent",
	"venue",
	"venus",
	"verb",
	"verbal",
	"verge",
	"verify",
	"verity",
	"verse",
	"versus",
	"very",
	"vessel",
	"vest",
	"vet",
	"veto",
	"via",
	"viable",
	"vicar",
	"vice",
	"victim",
	"victor",
	"video",
	"vienna",
	"view",
	"vigil",
	"viking",
	"vile",
	"villa",
	"vine",
	"vinyl",
	"viola",
	"violet",
	"violin",
	"viral",
	"virgo",
	"virtue",
	"virus",
	"visa",
	"vision",
	"visit",
	"visual",
	"vital",
	"vivid",
	"vocal",
	"vodka",
	"vogue",
	"voice",
	"void",
	"volley",
	"volume",
	"vote",
	"vowel",
	"voyage",
	"vulgar",
	"wade",
	"wage",
	"waist",
	"wait",
	"waiter",
	"wake",
	"walk",
	"walker",
	"wall",
	"wallet",
	"walnut",
	"wander",
	"want",
	"war",
	"warden",
	"warm",
	"warmth",
	"warn",
	"warp",
	"warsaw",
	"wary",
	"was",
	"wash",
	"wasp",
	"waste",
	"watch",
	"water",
	"watery",
	"wave",
	"wax",
	"way",
	"weak",
	"weaken",
	"wealth",
	"weapon",
	"wear",
	"weary",
	"weave",
	"wedge",
	"wee",
	"weed",
	"week",
	"weekly",
	"weep",
	"weigh",
	"weight",
	"weird",
	"well",
	"were",
	"west",
	"wet",
	"whale",
	"wharf",
	"what",
	"wheat",
	"wheel",
	"when",
	"whence",
	"where",
	"which",
	"whiff",
	"while",
	"whim",
	"whip",
	"whisky",
	"white",
	"who",
	"whole",
	"wholly",
	"whom",
	"whose",
	"why",
	"wicked",
	"wide",
	"widely",
	"widen",
	"wider",
	"widow",
	"width",
	"wife",
	"wig",
	"wild",
	"wildly",
	"will",
	"willow",
	"wily",
	"win",
	"wind",
	"window",
	"windy",
	"wine",
	"wing",
	"wink",
	"winner",
	"winter",
	"wipe",
	"wire",
	"wisdom",
	"wise",
	"wish",
	"wit",
	"witch",
	"with",
	"within",
	"witty",
	"wizard",
	"woke",
	"wolf",
	"wolves",
	"woman",
	"womb",
	"won",
	"wonder",
	"wood",
	"wooden",
	"woods",
	"woody",
	"wool",
	"word",
	"work",
	"worker",
	"world",
	"worm",
	"worry",
	"worse",
	"worst",
	"worth",
	"worthy",
	"would",
	"wound",
	"wrap",
	"wrath",
	"wreath",
	"wreck",
	"wring",
	"wrist",
	"writ",
	"write",
	"writer",
	"wrong",
	"xerox",
	"yacht",
	"yale",
	"yard",
	"yarn",
	"yeah",
	"year",
	"yeard",
	"yeast",
	"yellow",
	"yet",
	"yield",
	"yogurt",
	"yolk",
	"you",
	"young",
	"your",
	"youth",
	"zaire",
	"zeal",
	"zebra",
	"zenith",
	"zero",
	"zeus",
	"zigzag",
	"zinc",
	"zombie",
	"zone",
}
// Filename: live_hash.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"time"
)

// LiveHash is a hash that is live on the Hedera network
type LiveHash struct {
	AccountID AccountID
	Hash      []byte
	Keys      KeyList
	// Deprecated
	Duration         time.Time
	LiveHashDuration time.Duration
}

func (liveHash *LiveHash) _ToProtobuf() *services.LiveHash {
	return &services.LiveHash{
		AccountId: liveHash.AccountID._ToProtobuf(),
		Hash:      liveHash.Hash,
		Keys:      liveHash.Keys._ToProtoKeyList(),
		Duration:  _DurationToProtobuf(liveHash.LiveHashDuration),
	}
}

func _LiveHashFromProtobuf(hash *services.LiveHash) (LiveHash, error) {
	if hash == nil {
		return LiveHash{}, errParameterNull
	}

	var keyList KeyList
	var err error
	if hash.Keys != nil {
		keyList, err = _KeyListFromProtobuf(hash.Keys)
		if err != nil {
			return LiveHash{}, err
		}
	}

	accountID := AccountID{}
	if hash.AccountId != nil {
		accountID = *_AccountIDFromProtobuf(hash.AccountId)
	}

	var duration time.Duration
	if hash.Duration != nil {
		duration = _DurationFromProtobuf(hash.Duration)
	}

	return LiveHash{
		AccountID:        accountID,
		Hash:             hash.Hash,
		Keys:             keyList,
		LiveHashDuration: duration,
	}, nil
}

// ToBytes returns the byte representation of the LiveHash
func (liveHash LiveHash) ToBytes() []byte {
	data, err := protobuf.Marshal(liveHash._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// LiveHashFromBytes returns a LiveHash object from a raw byte array
func LiveHashFromBytes(data []byte) (LiveHash, error) {
	if data == nil {
		return LiveHash{}, errByteArrayNull
	}
	pb := services.LiveHash{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return LiveHash{}, err
	}

	liveHash, err := _LiveHashFromProtobuf(&pb)
	if err != nil {
		return LiveHash{}, err
	}

	return liveHash, nil
}
// Filename: live_hash_add_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"

	"time"
)

// LiveHashAddTransaction At consensus, attaches the given livehash to the given account.  The hash can be deleted by the
// key controlling the account, or by any of the keys associated to the livehash.  Hence livehashes
// provide a revocation service for their implied credentials; for example, when an authority grants
// a credential to the account, the account owner will cosign with the authority (or authorities) to
// attach a hash of the credential to the account---hence proving the grant. If the credential is
// revoked, then any of the authorities may delete it (or the account owner). In this way, the
// livehash mechanism acts as a revocation service.  An account cannot have two identical livehashes
// associated. To modify the list of keys in a livehash, the livehash should first be deleted, then
// recreated with a new list of keys.
type LiveHashAddTransaction struct {
	Transaction
	accountID *AccountID
	hash      []byte
	keys      *KeyList
	duration  *time.Duration
}

// NewLiveHashAddTransaction creates LiveHashAddTransaction which at consensus, attaches the given livehash to the given account.
// The hash can be deleted by the key controlling the account, or by any of the keys associated to the livehash.  Hence livehashes
// provide a revocation service for their implied credentials; for example, when an authority grants
// a credential to the account, the account owner will cosign with the authority (or authorities) to
// attach a hash of the credential to the account---hence proving the grant. If the credential is
// revoked, then any of the authorities may delete it (or the account owner). In this way, the
// livehash mechanism acts as a revocation service.  An account cannot have two identical livehashes
// associated. To modify the list of keys in a livehash, the livehash should first be deleted, then
// recreated with a new list of keys.
func NewLiveHashAddTransaction() *LiveHashAddTransaction {
	tx := LiveHashAddTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))
	return &tx
}

func _LiveHashAddTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *LiveHashAddTransaction {
	keys, _ := _KeyListFromProtobuf(pb.GetCryptoAddLiveHash().LiveHash.GetKeys())
	duration := _DurationFromProtobuf(pb.GetCryptoAddLiveHash().LiveHash.Duration)

	return &LiveHashAddTransaction{
		Transaction: tx,
		accountID:   _AccountIDFromProtobuf(pb.GetCryptoAddLiveHash().GetLiveHash().GetAccountId()),
		hash:        pb.GetCryptoAddLiveHash().LiveHash.Hash,
		keys:        &keys,
		duration:    &duration,
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *LiveHashAddTransaction) SetGrpcDeadline(deadline *time.Duration) *LiveHashAddTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

// SetHash Sets the SHA-384 hash of a credential or certificate
func (tx *LiveHashAddTransaction) SetHash(hash []byte) *LiveHashAddTransaction {
	tx._RequireNotFrozen()
	tx.hash = hash
	return tx
}

func (tx *LiveHashAddTransaction) GetHash() []byte {
	return tx.hash
}

// SetKeys Sets a list of keys (primitive or threshold), all of which must sign to attach the livehash to an account.
// Any one of which can later delete it.
func (tx *LiveHashAddTransaction) SetKeys(keys ...Key) *LiveHashAddTransaction {
	tx._RequireNotFrozen()
	if tx.keys == nil {
		tx.keys = &KeyList{keys: []Key{}}
	}
	keyList := NewKeyList()
	keyList.AddAll(keys)

	tx.keys = keyList

	return tx
}

func (tx *LiveHashAddTransaction) GetKeys() KeyList {
	if tx.keys != nil {
		return *tx.keys
	}

	return KeyList{}
}

// SetDuration Set the duration for which the livehash will remain valid
func (tx *LiveHashAddTransaction) SetDuration(duration time.Duration) *LiveHashAddTransaction {
	tx._RequireNotFrozen()
	tx.duration = &duration
	return tx
}

// GetDuration returns the duration for which the livehash will remain valid
func (tx *LiveHashAddTransaction) GetDuration() time.Duration {
	if tx.duration != nil {
		return *tx.duration
	}

	return time.Duration(0)
}

// SetAccountID Sets the account to which the livehash is attached
func (tx *LiveHashAddTransaction) SetAccountID(accountID AccountID) *LiveHashAddTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetAccountID returns the account to which the livehash is attached
func (tx *LiveHashAddTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *LiveHashAddTransaction) Sign(
	privateKey PrivateKey,
) *LiveHashAddTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *LiveHashAddTransaction) SignWithOperator(
	client *Client,
) (*LiveHashAddTransaction, error) {
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *LiveHashAddTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *LiveHashAddTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *LiveHashAddTransaction) AddSignature(publicKey PublicKey, signature []byte) *LiveHashAddTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

func (tx *LiveHashAddTransaction) Freeze() (*LiveHashAddTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *LiveHashAddTransaction) FreezeWith(client *Client) (*LiveHashAddTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// GetMaxTransactionFee returns the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *LiveHashAddTransaction) GetMaxTransactionFee() Hbar {
	return tx.Transaction.GetMaxTransactionFee()
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *LiveHashAddTransaction) SetMaxTransactionFee(fee Hbar) *LiveHashAddTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *LiveHashAddTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *LiveHashAddTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this LiveHashAddTransaction.
func (tx *LiveHashAddTransaction) SetTransactionMemo(memo string) *LiveHashAddTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this LiveHashAddTransaction.
func (tx *LiveHashAddTransaction) SetTransactionValidDuration(duration time.Duration) *LiveHashAddTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *LiveHashAddTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// GetTransactionID gets the TransactionID for this	 LiveHashAddTransaction.
func (tx *LiveHashAddTransaction) GetTransactionID() TransactionID {
	return tx.Transaction.GetTransactionID()
}

// SetTransactionID sets the TransactionID for this LiveHashAddTransaction.
func (tx *LiveHashAddTransaction) SetTransactionID(transactionID TransactionID) *LiveHashAddTransaction {
	tx._RequireNotFrozen()

	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountID sets the _Node AccountID for this LiveHashAddTransaction.
func (tx *LiveHashAddTransaction) SetNodeAccountIDs(nodeID []AccountID) *LiveHashAddTransaction {
	tx._RequireNotFrozen()
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *LiveHashAddTransaction) SetMaxRetry(count int) *LiveHashAddTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *LiveHashAddTransaction) SetMaxBackoff(max time.Duration) *LiveHashAddTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *LiveHashAddTransaction) SetMinBackoff(min time.Duration) *LiveHashAddTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *LiveHashAddTransaction) SetLogLevel(level LogLevel) *LiveHashAddTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *LiveHashAddTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *LiveHashAddTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *LiveHashAddTransaction) getName() string {
	return "LiveHashAddTransaction"
}
func (tx *LiveHashAddTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *LiveHashAddTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_CryptoAddLiveHash{
			CryptoAddLiveHash: tx.buildProtoBody(),
		},
	}
}

func (tx *LiveHashAddTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return nil, errors.New("cannot schedule `LiveHashAddTransaction`")
}

func (tx *LiveHashAddTransaction) buildProtoBody() *services.CryptoAddLiveHashTransactionBody {
	body := &services.CryptoAddLiveHashTransactionBody{
		LiveHash: &services.LiveHash{},
	}

	if tx.accountID != nil {
		body.LiveHash.AccountId = tx.accountID._ToProtobuf()
	}

	if tx.duration != nil {
		body.LiveHash.Duration = _DurationToProtobuf(*tx.duration)
	}

	if tx.keys != nil {
		body.LiveHash.Keys = tx.keys._ToProtoKeyList()
	}

	if tx.hash != nil {
		body.LiveHash.Hash = tx.hash
	}

	return body
}

func (tx *LiveHashAddTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetCrypto().AddLiveHash,
	}
}
func (tx *LiveHashAddTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: live_hash_add_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationLiveHashAddTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_hash, _ := hex.DecodeString("100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	resp2, err := NewLiveHashAddTransaction().
		SetAccountID(accountID).
		SetDuration(24 * 30 * time.Hour).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetHash(_hash).
		SetKeys(newKey.PublicKey()).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status NOT_SUPPORTED received for transaction %s", resp2.TransactionID), err.Error())
	}

	resp2, err = NewLiveHashDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetHash(_hash).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status NOT_SUPPORTED received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: live_hash_add_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitLiveHashAddTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	addLiveHash := NewLiveHashAddTransaction().
		SetAccountID(accountID)

	err = addLiveHash.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitLiveHashAddTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	addLiveHash := NewLiveHashAddTransaction().
		SetAccountID(accountID)

	err = addLiveHash.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitLiveHashAddTransactionGet(t *testing.T) {
	t.Parallel()

	accountID := AccountID{Account: 7}

	newKey, err := PrivateKeyGenerateEd25519()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewLiveHashAddTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKeys(newKey).
		SetAccountID(accountID).
		SetHash([]byte{}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetKeys()
	transaction.GetRegenerateTransactionID()
	transaction.GetHash()
}

func TestUnitLiveHashAddTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewLiveHashAddTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetKeys()
	transaction.GetRegenerateTransactionID()
	transaction.GetHash()
}

func TestUnitLiveHashFromBytes(t *testing.T) {
	t.Parallel()

	liveHash := LiveHash{
		AccountID: AccountID{Account: 3},
		Hash:      []byte{1},
	}

	byt := liveHash.ToBytes()
	fromBytes, err := LiveHashFromBytes(byt)
	require.NoError(t, err)
	require.Equal(t, fromBytes.AccountID.Account, uint64(3))
}

func TestUnitLiveHashAddTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewLiveHashAddTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetKeys(newKey).
		SetHash([]byte{1}).
		SetAccountID(account).
		SetDuration(time.Second * 30).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetKeys()
	transaction.GetAccountID()
	transaction.GetHash()
	transaction.GetKeys()
	transaction.GetDuration()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case LiveHashAddTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitLiveHashAddTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	freez, err := NewLiveHashAddTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetKeys(newKey).
		SetAccountID(AccountID{Account: 3}).
		SetHash([]byte{123}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: live_hash_delete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"errors"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"time"
)

// LiveHashDeleteTransaction At consensus, deletes a livehash associated to the given account. The transaction must be signed
// by either the key of the owning account, or at least one of the keys associated to the livehash.
type LiveHashDeleteTransaction struct {
	Transaction
	accountID *AccountID
	hash      []byte
}

// NewLiveHashDeleteTransaction creates LiveHashDeleteTransaction which at consensus, deletes a livehash associated to the given account.
// The transaction must be signed by either the key of the owning account, or at least one of the keys associated to the livehash.
func NewLiveHashDeleteTransaction() *LiveHashDeleteTransaction {
	tx := LiveHashDeleteTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _LiveHashDeleteTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *LiveHashDeleteTransaction {
	return &LiveHashDeleteTransaction{
		Transaction: tx,
		accountID:   _AccountIDFromProtobuf(pb.GetCryptoDeleteLiveHash().GetAccountOfLiveHash()),
		hash:        pb.GetCryptoDeleteLiveHash().LiveHashToDelete,
	}
}

// SetHash Set the SHA-384 livehash to delete from the account
func (tx *LiveHashDeleteTransaction) SetHash(hash []byte) *LiveHashDeleteTransaction {
	tx._RequireNotFrozen()
	tx.hash = hash
	return tx
}

// GetHash returns the SHA-384 livehash to delete from the account
func (tx *LiveHashDeleteTransaction) GetHash() []byte {
	return tx.hash
}

// SetAccountID Sets the account owning the livehash
func (tx *LiveHashDeleteTransaction) SetAccountID(accountID AccountID) *LiveHashDeleteTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetAccountID returns the account owning the livehash
func (tx *LiveHashDeleteTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *LiveHashDeleteTransaction) Sign(privateKey PrivateKey) *LiveHashDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *LiveHashDeleteTransaction) SignWithOperator(client *Client) (*LiveHashDeleteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *LiveHashDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *LiveHashDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *LiveHashDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *LiveHashDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *LiveHashDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *LiveHashDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *LiveHashDeleteTransaction) Freeze() (*LiveHashDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *LiveHashDeleteTransaction) FreezeWith(client *Client) (*LiveHashDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee for this LiveHashDeleteTransaction.
func (tx *LiveHashDeleteTransaction) SetMaxTransactionFee(fee Hbar) *LiveHashDeleteTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *LiveHashDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *LiveHashDeleteTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this LiveHashDeleteTransaction.
func (tx *LiveHashDeleteTransaction) SetTransactionMemo(memo string) *LiveHashDeleteTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this LiveHashDeleteTransaction.
func (tx *LiveHashDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *LiveHashDeleteTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *LiveHashDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this LiveHashDeleteTransaction.
func (tx *LiveHashDeleteTransaction) SetTransactionID(transactionID TransactionID) *LiveHashDeleteTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this LiveHashDeleteTransaction.
func (tx *LiveHashDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *LiveHashDeleteTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *LiveHashDeleteTransaction) SetMaxRetry(count int) *LiveHashDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *LiveHashDeleteTransaction) SetMaxBackoff(max time.Duration) *LiveHashDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *LiveHashDeleteTransaction) SetMinBackoff(min time.Duration) *LiveHashDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *LiveHashDeleteTransaction) SetLogLevel(level LogLevel) *LiveHashDeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *LiveHashDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *LiveHashDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *LiveHashDeleteTransaction) getName() string {
	return "LiveHashDeleteTransaction"
}

func (tx *LiveHashDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *LiveHashDeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_CryptoDeleteLiveHash{
			CryptoDeleteLiveHash: tx.buildProtoBody(),
		},
	}
}

func (tx *LiveHashDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return nil, errors.New("cannot schedule `LiveHashDeleteTransaction`")
}

func (tx *LiveHashDeleteTransaction) buildProtoBody() *services.CryptoDeleteLiveHashTransactionBody {
	body := &services.CryptoDeleteLiveHashTransactionBody{}

	if tx.accountID != nil {
		body.AccountOfLiveHash = tx.accountID._ToProtobuf()
	}

	if tx.hash != nil {
		body.LiveHashToDelete = tx.hash
	}

	return body
}

func (tx *LiveHashDeleteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetCrypto().DeleteLiveHash,
	}
}
func (tx *LiveHashDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: live_hash_delete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
	protobuf "google.golang.org/protobuf/proto"
)

func TestUnitLiveHashDeleteTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewLiveHashDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetHash([]byte{1}).
		SetAccountID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetAccountID()
	transaction.GetHash()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case LiveHashDeleteTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitLiveHashDeleteTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	freez, err := NewLiveHashDeleteTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAccountID(AccountID{Account: 3}).
		SetHash([]byte{123}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: live_hash_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// LiveHashQuery Requests a livehash associated to an account.
type LiveHashQuery struct {
	Query
	accountID *AccountID
	hash      []byte
}

// NewLiveHashQuery creates a LiveHashQuery that requests a livehash associated to an account.
func NewLiveHashQuery() *LiveHashQuery {
	header := services.QueryHeader{}
	return &LiveHashQuery{
		Query: _NewQuery(true, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *LiveHashQuery) SetGrpcDeadline(deadline *time.Duration) *LiveHashQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetAccountID Sets the AccountID to which the livehash is associated
func (q *LiveHashQuery) SetAccountID(accountID AccountID) *LiveHashQuery {
	q.accountID = &accountID
	return q
}

// GetAccountID returns the AccountID to which the livehash is associated
func (q *LiveHashQuery) GetAccountID() AccountID {
	if q.accountID == nil {
		return AccountID{}
	}

	return *q.accountID
}

// SetHash Sets the SHA-384 data in the livehash
func (q *LiveHashQuery) SetHash(hash []byte) *LiveHashQuery {
	q.hash = hash
	return q
}

// GetHash returns the SHA-384 data in the livehash
func (q *LiveHashQuery) GetGetHash() []byte {
	return q.hash
}

func (q *LiveHashQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *LiveHashQuery) Execute(client *Client) (LiveHash, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return LiveHash{}, err
	}

	liveHash, err := _LiveHashFromProtobuf(resp.GetCryptoGetLiveHash().LiveHash)
	if err != nil {
		return LiveHash{}, err
	}

	return liveHash, nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *LiveHashQuery) SetMaxQueryPayment(maxPayment Hbar) *LiveHashQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *LiveHashQuery) SetQueryPayment(paymentAmount Hbar) *LiveHashQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this LiveHashQuery.
func (q *LiveHashQuery) SetNodeAccountIDs(accountID []AccountID) *LiveHashQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *LiveHashQuery) SetMaxBackoff(max time.Duration) *LiveHashQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *LiveHashQuery) SetMinBackoff(min time.Duration) *LiveHashQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *LiveHashQuery) SetPaymentTransactionID(transactionID TransactionID) *LiveHashQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *LiveHashQuery) SetMaxRetry(count int) *LiveHashQuery {
	q.Query.SetMaxRetry(count)
	return q
}

func (q *LiveHashQuery) SetLogLevel(level LogLevel) *LiveHashQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *LiveHashQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetCrypto().GetLiveHash,
	}
}

func (q *LiveHashQuery) getName() string {
	return "LiveHashQuery"
}

func (q *LiveHashQuery) buildQuery() *services.Query {
	body := &services.CryptoGetLiveHashQuery{
		Header: q.pbHeader,
	}
	if q.accountID != nil {
		body.AccountID = q.accountID._ToProtobuf()
	}

	if len(q.hash) > 0 {
		body.Hash = q.hash
	}

	return &services.Query{
		Query: &services.Query_CryptoGetLiveHash{
			CryptoGetLiveHash: body,
		},
	}
}

func (q *LiveHashQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.accountID != nil {
		if err := q.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *LiveHashQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetCryptoGetLiveHash()
}
// Filename: live_hash_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationLiveHashQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_hash, _ := hex.DecodeString("100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	resp2, err := NewLiveHashAddTransaction().
		SetAccountID(accountID).
		SetDuration(24 * 30 * time.Hour).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetHash(_hash).
		SetKeys(newKey.PublicKey()).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status NOT_SUPPORTED received for transaction %s", resp2.TransactionID), err.Error())
	}

	_, err = NewLiveHashQuery().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		SetHash(_hash).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status NOT_SUPPORTED", err.Error())
	}

	resp2, err = NewLiveHashDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetHash(_hash).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status NOT_SUPPORTED received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationLiveHashQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_hash, _ := hex.DecodeString("100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	resp2, err := NewLiveHashAddTransaction().
		SetAccountID(accountID).
		SetDuration(24 * 30 * time.Hour).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetHash(_hash).
		SetKeys(newKey.PublicKey()).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status NOT_SUPPORTED received for transaction %s", resp2.TransactionID), err.Error())
	}

	liveHashQ := NewLiveHashQuery().
		SetAccountID(accountID).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetHash(_hash)

	cost, err := liveHashQ.GetCost(env.Client)
	assert.Error(t, err)

	_, err = liveHashQ.SetQueryPayment(cost).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status NOT_SUPPORTED", err.Error())
	}

	resp2, err = NewLiveHashDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetHash(_hash).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status NOT_SUPPORTED received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: live_hash_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitLiveHashQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	liveHashQuery := NewLiveHashQuery().
		SetAccountID(accountID)

	err = liveHashQuery.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitLiveHashQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	liveHashQuery := NewLiveHashQuery().
		SetAccountID(accountID)

	err = liveHashQuery.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitLiveHashQueryGet(t *testing.T) {
	t.Parallel()

	accountID := AccountID{Account: 7}

	balance := NewLiveHashQuery().
		SetAccountID(accountID).
		SetHash([]byte{}).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}})

	balance.GetAccountID()
	balance.GetGetHash()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitLiveHashQuerySetNothing(t *testing.T) {
	t.Parallel()

	balance := NewLiveHashQuery()

	balance.GetAccountID()
	balance.GetGetHash()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitLiveHashQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 3
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewLiveHashQuery().
		SetAccountID(account).
		SetHash([]byte{1}).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3)).
		SetGrpcDeadline(&grpc)

	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)
	query.GetNodeAccountIDs()
	query.GetMaxBackoff()
	query.GetMinBackoff()
	query.getName()
	query.GetAccountID()
	query.GetGetHash()
	query.GetQueryPayment()
	query.GetMaxQueryPayment()
}

func TestUnitLiveHashQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_CryptoGetLiveHash{
				CryptoGetLiveHash: &services.CryptoGetLiveHashResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_CryptoGetLiveHash{
				CryptoGetLiveHash: &services.CryptoGetLiveHashResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_CryptoGetLiveHash{
				CryptoGetLiveHash: &services.CryptoGetLiveHashResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					LiveHash: &services.LiveHash{
						Hash:      []byte{1},
						AccountId: &services.AccountID{Account: &services.AccountID_AccountNum{AccountNum: 3}},
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewLiveHashQuery().
		SetAccountID(AccountID{Account: 3}).
		SetHash([]byte{1}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMaxQueryPayment(NewHbar(1))

	_, err := query.GetCost(client)
	require.NoError(t, err)

	_, err = query.Execute(client)
	require.NoError(t, err)
}
// Filename: lockable_slice.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

type _LockableSlice struct {
	slice  []interface{}
	locked bool
	index  int
}

func _NewLockableSlice() *_LockableSlice {
	return &_LockableSlice{
		slice: []interface{}{},
	}
}

func (this *_LockableSlice) _RequireNotLocked() {
	if this.locked {
		panic(errLockedSlice)
	}
}

func (this *_LockableSlice) _SetLocked(locked bool) *_LockableSlice { // nolint
	this.locked = locked
	return this
}

func (this *_LockableSlice) _SetSlice(slice []interface{}) *_LockableSlice { //nolint
	this._RequireNotLocked()
	this.slice = slice
	this.index = 0
	return this
}

func (this *_LockableSlice) _Push(items ...interface{}) *_LockableSlice {
	this._RequireNotLocked()
	this.slice = append(this.slice, items...)
	return this
}

func (this *_LockableSlice) _Clear() *_LockableSlice { //nolint
	this._RequireNotLocked()
	this.slice = []interface{}{}
	return this
}

func (this *_LockableSlice) _Get(index int) interface{} { //nolint
	return this.slice[index]
}

func (this *_LockableSlice) _Set(index int, item interface{}) *_LockableSlice { //nolint
	this._RequireNotLocked()

	if len(this.slice) == index {
		this.slice = append(this.slice, item)
	} else {
		this.slice[index] = item
	}

	return this
}

func (this *_LockableSlice) _SetIfAbsent(index int, item interface{}) *_LockableSlice { //nolint
	this._RequireNotLocked()
	if len(this.slice) == index || this.slice[index] == nil {
		this._Set(index, item)
	}
	return this
}

func (this *_LockableSlice) _GetNext() interface{} { //nolint
	return this._Get(this._Advance())
}

func (this *_LockableSlice) _GetCurrent() interface{} { //nolint
	return this._Get(this.index)
}

func (this *_LockableSlice) _Advance() int { //nolint
	index := this.index
	if len(this.slice) != 0 {
		this.index = (this.index + 1) % len(this.slice)
	}
	return index
}

func (this *_LockableSlice) _IsEmpty() bool { //nolint
	return len(this.slice) == 0
}

func (this *_LockableSlice) _Length() int { //nolint
	return len(this.slice)
}
// Filename: logger.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"os"
	"time"

	"github.com/rs/zerolog"
)

type LogLevel string

const (
	LoggerLevelTrace    LogLevel = "TRACE"
	LoggerLevelDebug    LogLevel = "DEBUG"
	LoggerLevelInfo     LogLevel = "INFO"
	LoggerLevelWarn     LogLevel = "WARN"
	LoggerLevelError    LogLevel = "ERROR"
	LoggerLevelDisabled LogLevel = "DISABLED"
)

type Logger interface {
	SetSilent(isSilent bool)
	SetLevel(level LogLevel)
	SubLoggerWithLevel(level LogLevel) Logger
	Error(msg string, keysAndValues ...interface{})
	Warn(msg string, keysAndValues ...interface{})
	Info(msg string, keysAndValues ...interface{})
	Debug(msg string, keysAndValues ...interface{})
	Trace(msg string, keysAndValues ...interface{})
}

type DefaultLogger struct {
	logger *zerolog.Logger
	level  LogLevel
}

func NewLogger(component string, level LogLevel) *DefaultLogger {
	var logger zerolog.Logger
	logger = zerolog.New(os.Stdout).With().Str("module", component).Timestamp().Logger()

	if os.Getenv("HEDERA_SDK_GO_LOG_PRETTY") != "" {
		// Pretty logging
		output := zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339}
		logger = zerolog.New(output).With().Str("module", component).Timestamp().Logger()
	}

	logger = loggerForLevel(logger, level)
	return &DefaultLogger{
		logger: &logger,
		level:  level,
	}
}

func (l *DefaultLogger) SetSilent(isSilent bool) {
	if isSilent {
		logger := l.logger.Level(zerolog.Disabled)
		l.logger = &logger
	} else {
		l.SetLevel(l.level)
	}
}

func loggerForLevel(logger zerolog.Logger, level LogLevel) zerolog.Logger {
	switch level {
	case LoggerLevelTrace:
		return logger.Level(zerolog.TraceLevel)
	case LoggerLevelDebug:
		return logger.Level(zerolog.DebugLevel)
	case LoggerLevelInfo:
		return logger.Level(zerolog.InfoLevel)
	case LoggerLevelWarn:
		return logger.Level(zerolog.WarnLevel)
	case LoggerLevelError:
		return logger.Level(zerolog.ErrorLevel)
	default:
		return logger.Level(zerolog.Disabled)
	}
}

func (l *DefaultLogger) SetLevel(level LogLevel) {
	l.level = level
	logger := loggerForLevel(*l.logger, level)
	l.logger = &logger
}

func (l *DefaultLogger) SubLoggerWithLevel(level LogLevel) Logger {
	l.level = level
	logger := loggerForLevel(*l.logger, level)

	return &DefaultLogger{
		logger: &logger,
		level:  level,
	}
}

func (l *DefaultLogger) Warn(msg string, keysAndValues ...interface{}) {
	addFields(l.logger.Warn(), msg, keysAndValues...)
}

func (l *DefaultLogger) Error(msg string, keysAndValues ...interface{}) {
	addFields(l.logger.Error(), msg, keysAndValues...)
}

func (l *DefaultLogger) Trace(msg string, keysAndValues ...interface{}) {
	addFields(l.logger.Trace(), msg, keysAndValues...)
}

func (l *DefaultLogger) Debug(msg string, keysAndValues ...interface{}) {
	addFields(l.logger.Debug(), msg, keysAndValues...)
}

func (l *DefaultLogger) Info(msg string, keysAndValues ...interface{}) {
	addFields(l.logger.Info(), msg, keysAndValues...)
}

func argsToFields(keysAndValues ...interface{}) map[string]interface{} {
	fields := make(map[string]interface{})
	for i := 0; i < len(keysAndValues); i += 2 {
		fields[fmt.Sprint(keysAndValues[i])] = keysAndValues[i+1]
	}
	return fields
}

func addFields(event *zerolog.Event, msg string, keysAndValues ...interface{}) {
	for key, value := range argsToFields(keysAndValues...) {
		switch v := value.(type) {
		case string:
			event.Str(key, v)
		case int64:
			event.Int64(key, v)
		case time.Duration:
			event.Dur(key, v)
		default:
			event.Str(key, fmt.Sprint(value))
		}
	}

	event.Msg(msg)
}
// Filename: logger_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"os"
	"testing"
	"time"

	"github.com/rs/zerolog"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewLogger(t *testing.T) {
	logger := NewLogger("test", LoggerLevelDebug)
	require.NotNil(t, logger)
	assert.Equal(t, LoggerLevelDebug, logger.level)
}

func TestLogger_SetLevel(t *testing.T) {
	logger := NewLogger("test", LoggerLevelDebug)
	logger.SetLevel(LoggerLevelInfo)
	assert.Equal(t, LoggerLevelInfo, logger.level)
}
func TestLogger_SetSilent(t *testing.T) {
	var buf bytes.Buffer
	writer := zerolog.ConsoleWriter{Out: &buf, TimeFormat: time.RFC3339}
	zerolog.SetGlobalLevel(zerolog.TraceLevel)

	l := NewLogger("test", LoggerLevelTrace)
	l.SetLevel(LoggerLevelTrace)

	logger := zerolog.New(&writer)
	l.logger = &logger

	l.Debug("debug message", "debugKey", "debugValue")
	l.Info("info message", "infoKey", "infoValue")
	l.Warn("warn message", "warnKey", "warnValue")
	l.Error("error message", "errorKey", "errorValue")
	l.Trace("trace message", "traceKey", "traceValue")
	assert.Contains(t, buf.String(), "debug message")
	assert.Contains(t, buf.String(), "info message")
	assert.Contains(t, buf.String(), "warn message")
	assert.Contains(t, buf.String(), "error message")
	assert.Contains(t, buf.String(), "trace message")

	// coverage only
	l.SetSilent(true)
	l.SetSilent(false)
}

func TestNewLoggerWithEnvironmentVariableSet(t *testing.T) {
	os.Setenv("HEDERA_SDK_GO_LOG_PRETTY", "1")
	logger := NewLogger("test", LoggerLevelDebug)
	require.NotNil(t, logger)
	assert.Equal(t, LoggerLevelDebug, logger.level)
	os.Unsetenv("HEDERA_SDK_GO_LOG_PRETTY")
}
// Filename: managed_network.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"crypto/rand"
	"math"
	"math/big"
	"sync"
	"time"
)

type _ManagedNetwork struct {
	network                map[string][]_IManagedNode
	nodes                  []_IManagedNode
	healthyNodes           []_IManagedNode
	healthyNodesMutex      *sync.RWMutex
	maxNodeAttempts        int
	minBackoff             time.Duration
	maxBackoff             time.Duration
	maxNodesPerTransaction *int
	ledgerID               *LedgerID
	transportSecurity      bool
	verifyCertificate      bool
	minNodeReadmitPeriod   time.Duration
	maxNodeReadmitPeriod   time.Duration
	earliestReadmitTime    time.Time
}

func _NewManagedNetwork() _ManagedNetwork {
	return _ManagedNetwork{
		network:                map[string][]_IManagedNode{},
		nodes:                  []_IManagedNode{},
		healthyNodes:           []_IManagedNode{},
		healthyNodesMutex:      &sync.RWMutex{},
		maxNodeAttempts:        -1,
		minBackoff:             8 * time.Second,
		maxBackoff:             1 * time.Hour,
		maxNodesPerTransaction: nil,
		ledgerID:               nil,
		transportSecurity:      false,
		verifyCertificate:      false,
		minNodeReadmitPeriod:   8 * time.Second,
		maxNodeReadmitPeriod:   1 * time.Hour,
	}
}

func (this *_ManagedNetwork) _SetNetwork(network map[string]_IManagedNode) error {
	newNodes := make([]_IManagedNode, len(this.nodes))
	newNodeKeys := map[string]bool{}
	newNodeValues := map[string]bool{}

	// Copy all the nodes into the `newNodes` list
	copy(newNodes, this.nodes)

	// Remove nodes from the old this which do not belong to the new this
	for _, index := range _GetNodesToRemove(network, newNodes) {
		node := newNodes[index]

		if err := node._Close(); err != nil {
			return err
		}

		if index == len(newNodes)-1 {
			newNodes = newNodes[:index]
		} else {
			newNodes = append(newNodes[:index], newNodes[index+1:]...)
		}
	}

	for _, node := range newNodes {
		newNodeKeys[node._GetKey()] = true
		newNodeValues[node._GetAddress()] = true
	}

	for key, value := range network {
		_, keyOk := newNodeKeys[key]
		_, valueOk := newNodeValues[value._GetAddress()]

		if keyOk && valueOk {
			continue
		}

		newNodes = append(newNodes, value)
	}

	newNetwork, newHealthyNodes := _CreateNetworkFromNodes(newNodes)

	this.nodes = newNodes
	this.network = newNetwork
	this.healthyNodes = newHealthyNodes

	return nil
}

func (this *_ManagedNetwork) _ReadmitNodes() {
	now := time.Now()

	this.healthyNodesMutex.Lock()
	defer this.healthyNodesMutex.Unlock()

	if this.earliestReadmitTime.Before(now) {
		nextEarliestReadmitTime := now.Add(this.maxNodeReadmitPeriod)

		for _, node := range this.nodes {
			if node._GetReadmitTime() != nil && node._GetReadmitTime().After(now) && node._GetReadmitTime().Before(nextEarliestReadmitTime) {
				nextEarliestReadmitTime = *node._GetReadmitTime()
			}
		}

		this.earliestReadmitTime = nextEarliestReadmitTime
		if this.earliestReadmitTime.Before(now.Add(this.minNodeReadmitPeriod)) {
			this.earliestReadmitTime = now.Add(this.minNodeReadmitPeriod)
		}

	outer:
		for _, node := range this.nodes {
			for _, healthyNode := range this.healthyNodes {
				if node == healthyNode {
					continue outer
				}
			}

			if node._GetReadmitTime().Before(now) {
				this.healthyNodes = append(this.healthyNodes, node)
			}
		}
	}
}

func (this *_ManagedNetwork) _GetNumberOfNodesForTransaction() int { // nolint
	this._ReadmitNodes()
	if this.maxNodesPerTransaction != nil {
		return int(math.Min(float64(*this.maxNodesPerTransaction), float64(len(this.network))))
	}

	return (len(this.network) + 3 - 1) / 3
}

func (this *_ManagedNetwork) _SetMaxNodesPerTransaction(max int) {
	this.maxNodesPerTransaction = &max
}

func (this *_ManagedNetwork) _SetMaxNodeAttempts(max int) {
	this.maxNodeAttempts = max
}

func (this *_ManagedNetwork) _GetMaxNodeAttempts() int {
	return this.maxNodeAttempts
}

func (this *_ManagedNetwork) _SetMinNodeReadmitPeriod(min time.Duration) {
	this.minNodeReadmitPeriod = min
	this.earliestReadmitTime = time.Now().Add(this.minNodeReadmitPeriod)
}

func (this *_ManagedNetwork) _GetMinNodeReadmitPeriod() time.Duration {
	return this.minNodeReadmitPeriod
}

func (this *_ManagedNetwork) _SetMaxNodeReadmitPeriod(max time.Duration) {
	this.maxNodeReadmitPeriod = max
}

func (this *_ManagedNetwork) _GetMaxNodeReadmitPeriod() time.Duration {
	return this.maxNodeReadmitPeriod
}

func (this *_ManagedNetwork) _SetMinBackoff(minBackoff time.Duration) {
	this.minBackoff = minBackoff
	for _, nod := range this.healthyNodes {
		if nod != nil {
			nod._SetMinBackoff(minBackoff)
		}
	}
}

func (this *_ManagedNetwork) _GetNode() _IManagedNode {
	this._ReadmitNodes()
	this.healthyNodesMutex.RLock()
	defer this.healthyNodesMutex.RUnlock()

	if len(this.healthyNodes) == 0 {
		panic("failed to find a healthy working node")
	}

	bg := big.NewInt(int64(len(this.healthyNodes)))
	index, _ := rand.Int(rand.Reader, bg)
	return this.healthyNodes[index.Int64()]
}

func (this *_ManagedNetwork) _GetMinBackoff() time.Duration {
	return this.minBackoff
}

func (this *_ManagedNetwork) _SetMaxBackoff(maxBackoff time.Duration) {
	this.maxBackoff = maxBackoff
	for _, node := range this.healthyNodes {
		node._SetMaxBackoff(maxBackoff)
	}
}

func (this *_ManagedNetwork) _GetMaxBackoff() time.Duration {
	return this.maxBackoff
}

func (this *_ManagedNetwork) _GetLedgerID() *LedgerID {
	return this.ledgerID
}

func (this *_ManagedNetwork) _SetLedgerID(id LedgerID) *_ManagedNetwork {
	this.ledgerID = &id
	return this
}

func (this *_ManagedNetwork) _Close() error {
	for _, conn := range this.healthyNodes {
		if err := conn._Close(); err != nil {
			return err
		}
	}

	return nil
}

func _CreateNetworkFromNodes(nodes []_IManagedNode) (network map[string][]_IManagedNode, healthyNodes []_IManagedNode) {
	healthyNodes = []_IManagedNode{}
	network = map[string][]_IManagedNode{}

	for _, node := range nodes {
		if node._IsHealthy() {
			healthyNodes = append(healthyNodes, node)
		}

		value, ok := network[node._GetKey()]
		if !ok {
			value = []_IManagedNode{}
		}
		value = append(value, node)
		network[node._GetKey()] = value
	}

	return network, healthyNodes
}

func (this *_ManagedNetwork) _SetTransportSecurity(transportSecurity bool) (err error) {
	if this.transportSecurity != transportSecurity {
		if err := this._Close(); err != nil {
			return err
		}

		newNodes := make([]_IManagedNode, len(this.nodes))

		copy(newNodes, this.nodes)

		for i, node := range newNodes {
			if transportSecurity {
				newNodes[i] = node._ToSecure()
			} else {
				newNodes[i] = node._ToInsecure()
			}
		}

		newNetwork, newHealthyNodes := _CreateNetworkFromNodes(newNodes)

		this.nodes = newNodes
		this.healthyNodes = newHealthyNodes
		this.network = newNetwork
	}

	this.transportSecurity = transportSecurity
	return nil
}

func _GetNodesToRemove(network map[string]_IManagedNode, nodes []_IManagedNode) []int {
	nodeIndices := []int{}

	for i := len(nodes) - 1; i >= 0; i-- {
		if _, ok := network[nodes[i]._GetKey()]; !ok {
			nodeIndices = append(nodeIndices, i)
		}
	}

	return nodeIndices
}

func (this *_ManagedNetwork) _SetVerifyCertificate(verify bool) *_ManagedNetwork {
	for _, node := range this.nodes {
		node._SetVerifyCertificate(verify)
	}

	this.verifyCertificate = verify
	return this
}

func (this *_ManagedNetwork) _GetVerifyCertificate() bool {
	return this.verifyCertificate
}
// Filename: managed_network_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"math"
	"testing"
	"time"

	"github.com/pkg/errors"
	"github.com/stretchr/testify/require"
)

func (this *_ManagedNetwork) removeNodeFromHealthyNodes(nodeToRemove _IManagedNode) {
	newHealthyNodes := make([]_IManagedNode, 0)

	for _, node := range this.healthyNodes {
		if node != nodeToRemove {
			newHealthyNodes = append(newHealthyNodes, node)
		}
	}

	this.healthyNodes = newHealthyNodes
}

func newMockNodes() map[string]_IManagedNode {
	address1, _ := _ManagedNodeAddressFromString("node1:50211")
	address2, _ := _ManagedNodeAddressFromString("node1:50212")
	address3, _ := _ManagedNodeAddressFromString("node2:50211")

	return map[string]_IManagedNode{
		"node1:50211": &mockManagedNode{address: address1, healthy: true},
		"node1:50212": &mockManagedNode{address: address2, healthy: true},
		"node2:50211": &mockManagedNode{address: address3, healthy: true},
	}
}

type mockManagedNode struct {
	address                    *_ManagedNodeAddress
	currentBackoff             time.Duration
	lastUsed                   time.Time
	useCount                   int64
	minBackoff                 time.Duration
	maxBackoff                 time.Duration
	badGrpcStatusCount         int64
	readmitTime                *time.Time
	healthy                    bool
	minBackoffCalled           bool
	maxBackoffCalled           bool
	setVerifyCertificateCalled bool
	toSecureCalled             bool
	toInsecureCalled           bool
}
type mockManagedNodeWithError struct {
	mockManagedNode
}

func (m *mockManagedNodeWithError) _Close() error {
	return errors.New("closing error")
}

func (m *mockManagedNode) _GetAddress() string {
	return m.address._String()
}

func (m *mockManagedNode) _GetKey() string {
	return m.address._String()
}

func (m *mockManagedNode) _IsHealthy() bool {
	return m.healthy
}

func (m *mockManagedNode) _Close() error {
	return nil
}

func (m *mockManagedNode) _DecreaseBackoff() {

}

func (m *mockManagedNode) _IncreaseBackoff() {
	m.healthy = false
}

func (m *mockManagedNode) _ResetBackoff() {
	// No need to implement this for the test
}

func (m *mockManagedNode) _GetReadmitTime() *time.Time {
	return m.readmitTime
}

func (m *mockManagedNode) _GetAttempts() int64 {
	return 0
}

func (m *mockManagedNode) _GetLastUsed() time.Time {
	return time.Now()
}

func (m *mockManagedNode) _GetManagedNode() *_ManagedNode {
	return nil
}

func (m *mockManagedNode) _ToSecure() _IManagedNode {
	m.toSecureCalled = true
	return m
}

func (m *mockManagedNode) _ToInsecure() _IManagedNode {
	m.toInsecureCalled = true
	return m
}

func (m *mockManagedNode) _SetMinBackoff(minBackoff time.Duration) {
	m.minBackoff = minBackoff
	m.minBackoffCalled = true
}

func (m *mockManagedNode) _SetMaxBackoff(maxBackoff time.Duration) {
	m.maxBackoff = maxBackoff
	m.maxBackoffCalled = true
}

func (m *mockManagedNode) _GetMinBackoff() time.Duration {
	return time.Duration(0)
}

func (m *mockManagedNode) _GetMaxBackoff() time.Duration {
	return time.Duration(0)
}

func (m *mockManagedNode) _Wait() time.Duration {
	return time.Duration(0)
}

func (m *mockManagedNode) _GetUseCount() int64 {
	return 0
}

func (m *mockManagedNode) _SetVerifyCertificate(verify bool) {
	m.setVerifyCertificateCalled = true
}

func (m *mockManagedNode) _GetVerifyCertificate() bool {
	return true
}

func (m *mockManagedNode) _InUse() {
}

func TestUnitManagedNetworkSetGet(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)
	ledgerId, err := LedgerIDFromString("mainnet")
	require.NoError(t, err)
	mn._SetLedgerID(*ledgerId)
	mn._SetMaxNodeAttempts(10)
	mn._SetMinBackoff(1 * time.Second)
	mn._SetMaxBackoff(2 * time.Second)
	mn._SetMaxNodesPerTransaction(3)
	mn._SetTransportSecurity(false)
	mn._SetVerifyCertificate(false)
	mn._SetMinNodeReadmitPeriod(4 * time.Second)
	mn._SetMaxNodeReadmitPeriod(5 * time.Second)

	require.Equal(t, 10, mn.maxNodeAttempts)
	require.Equal(t, 1*time.Second, mn._GetMinBackoff())
	require.Equal(t, 2*time.Second, mn._GetMaxBackoff())
	require.Equal(t, 3, *mn.maxNodesPerTransaction)
	require.Equal(t, ledgerId, mn._GetLedgerID())
	require.False(t, mn.transportSecurity)
	require.False(t, mn._GetVerifyCertificate())
	require.Equal(t, 4*time.Second, mn.minNodeReadmitPeriod)
	require.Equal(t, 5*time.Second, mn.maxNodeReadmitPeriod)
	for _, node := range mockNodes {
		mockNode, ok := node.(*mockManagedNode)
		require.True(t, ok, "node should be of type *mockManagedNode")

		require.True(t, mockNode.minBackoffCalled, "minBackoffCalled should be true")
		require.True(t, mockNode.maxBackoffCalled, "maxBackoffCalled should be true")
		require.True(t, mockNode.setVerifyCertificateCalled, "setVerifyCertificateCalled should be true")
		// Should not be called, as those are false by default
		require.False(t, mockNode.toSecureCalled, "toSecureCalled should be false")
		require.False(t, mockNode.toInsecureCalled, "toInsecureCalled should be false")
	}
	mn._SetTransportSecurity(true)
	mn._SetVerifyCertificate(true)
	for _, node := range mockNodes {
		mockNode, ok := node.(*mockManagedNode)
		require.True(t, ok, "node should be of type *mockManagedNode")

		require.True(t, mockNode.setVerifyCertificateCalled, "setVerifyCertificateCalled should be true")
		require.True(t, mockNode.toSecureCalled, "toSecureCalled should be true")
	}
	mn._SetTransportSecurity(false)
	for _, node := range mockNodes {
		mockNode, ok := node.(*mockManagedNode)
		require.True(t, ok, "node should be of type *mockManagedNode")
		require.True(t, mockNode.toInsecureCalled, "toInsecureCalled should be true")
	}
}

func TestUnitNewManagedNetwork(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()

	require.NotNil(t, mn.network)
	require.NotNil(t, mn.nodes)
	require.NotNil(t, mn.healthyNodes)
	require.Equal(t, -1, mn._GetMaxNodeAttempts())
	require.Equal(t, 8*time.Second, mn.minBackoff)
	require.Equal(t, 1*time.Hour, mn.maxBackoff)
	require.Nil(t, mn.maxNodesPerTransaction)
	require.Nil(t, mn.ledgerID)
	require.False(t, mn.transportSecurity)
	require.False(t, mn.verifyCertificate)
	require.Equal(t, 8*time.Second, mn._GetMinNodeReadmitPeriod())
	require.Equal(t, 1*time.Hour, mn._GetMaxNodeReadmitPeriod())
}

func TestUnitSetNetwork(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Check if the nodes are properly set in the _ManagedNetwork
	require.Equal(t, 3, len(mn.nodes))
	for _, node := range mn.nodes {
		require.Contains(t, mockNodes, node._GetAddress())
	}

	// Check if the healthy nodes are properly set in the _ManagedNetwork
	require.Equal(t, 3, len(mn.healthyNodes))
	for _, node := range mn.healthyNodes {
		require.Contains(t, mockNodes, node._GetAddress())
	}

	mockNodes["node1:50211"].(*mockManagedNode).healthy = false
	err = mn._SetNetwork(mockNodes)
	require.NoError(t, err)
	// Check if only the healthy nodes are properly set in the _ManagedNetwork
	require.Equal(t, 2, len(mn.healthyNodes))
	for _, node := range mn.healthyNodes {
		require.True(t, node._IsHealthy())
	}

	// Check if the nodes are properly set in the _ManagedNetwork
	require.Equal(t, 3, len(mn.nodes))
	for _, node := range mn.nodes {
		require.Contains(t, mockNodes, node._GetAddress())
	}
}

func TestUnitSetNetworkWithErorr(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	address4, _ := _ManagedNodeAddressFromString("node1:50213")
	mockNodesWithError := map[string]_IManagedNode{
		"node1:50213": &mockManagedNodeWithError{
			mockManagedNode: mockManagedNode{address: address4, healthy: true},
		},
	}

	err := mn._SetNetwork(mockNodesWithError)
	require.NoError(t, err)
	// Add a new node, should error, because existing node return an error on close
	err = mn._SetNetwork(mockNodes)
	require.Error(t, err)
}

func TestUnitManagedNetworkCloseWithError(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNode := &mockManagedNode{}
	mockNodeWithError := &mockManagedNodeWithError{
		mockManagedNode: *mockNode,
	}

	// Inject the node with an error into the healthyNodes slice
	mn.healthyNodes = append(mn.healthyNodes, mockNodeWithError)

	err := mn._Close()
	require.Error(t, err)
	require.Equal(t, "closing error", err.Error())
}

func TestUnitManagedNetworkSetTransportSecurityWithError(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNode := &mockManagedNode{}
	mockNodeWithError := &mockManagedNodeWithError{
		mockManagedNode: *mockNode,
	}

	// Inject the node with an error into the healthyNodes slice
	mn.healthyNodes = append(mn.healthyNodes, mockNodeWithError)

	// Attempt to set the transport security
	err := mn._SetTransportSecurity(true)
	require.Error(t, err)
	require.Equal(t, "closing error", err.Error())
}

func TestUnitSetNetwork_NodeRemoved(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Remove a node from the mockNodes map
	removedNodeKey := "node1:50211"
	removedNode := mockNodes[removedNodeKey]
	delete(mockNodes, removedNodeKey)

	err = mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Check if the node was removed from the _ManagedNetwork
	require.Equal(t, 2, len(mn.nodes))
	for _, node := range mn.nodes {
		require.NotEqual(t, removedNode._GetAddress(), node._GetAddress())
	}
}

func TestUnitSetNetwork_NodeAdded(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Add a new node to the mockNodes map
	newNodeKey := "node2:50212"
	address4, _ := _ManagedNodeAddressFromString("node2:50212")
	newNode := &mockManagedNode{address: address4, healthy: true}
	mockNodes[newNodeKey] = newNode

	err = mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Check if the new node was added to the _ManagedNetwork
	require.Equal(t, 4, len(mn.nodes))
	foundNewNode := false
	for _, node := range mn.nodes {
		if node._GetAddress() == newNode._GetAddress() {
			foundNewNode = true
		}
	}
	require.True(t, foundNewNode)
}

func TestUnitSetNetworkRemoveAllNodes(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Remove all nodes from the mockNodes map
	for key := range mockNodes {
		delete(mockNodes, key)
	}

	// Set up the new network without any nodes
	err = mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Check if there are no nodes in the _ManagedNetwork
	require.Equal(t, 0, len(mn.nodes))
}

func TestUnitReadmitNodes_NodeReadmitted(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	unhealthyNodeKey := "node1:50211"
	unhealthyNode := mockNodes[unhealthyNodeKey].(*mockManagedNode)
	mn.removeNodeFromHealthyNodes(unhealthyNode)
	unhealthyNode.healthy = true

	// Set readmit time for the unhealthy node to a time before now
	pastTime := time.Now().Add(-1 * time.Minute)
	unhealthyNode.readmitTime = &pastTime

	// Call _ReadmitNodes to readmit healthy nodes
	mn._ReadmitNodes()

	// Check if the previously unhealthy node is now in the healthyNodes list
	found := false
	for _, node := range mn.healthyNodes {
		if node._GetAddress() == unhealthyNodeKey {
			found = true
			break
		}
	}
	require.True(t, found, "node1:50211 should be present in the healthyNodes list after readmission")
}

func TestUnitReadmitNodes_NodeNotReadmitted(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	unhealthyNodeKey := "node1:50212"
	unhealthyNode := mockNodes[unhealthyNodeKey].(*mockManagedNode)
	unhealthyNode.healthy = false
	mn.removeNodeFromHealthyNodes(unhealthyNode)

	// Set readmit time for the unhealthy node to a time in the future
	futureTime := time.Now().Add(1 * time.Hour)
	unhealthyNode.readmitTime = &futureTime

	// Call _ReadmitNodes
	mn._ReadmitNodes()

	// Check if the unhealthy node is not present in the healthyNodes list
	found := false
	for _, node := range mn.healthyNodes {
		if node._GetAddress() == unhealthyNodeKey {
			found = true
			break
		}
	}
	require.False(t, found, "node1:50212 should not be present in the healthyNodes list since its readmit time is in the future")
}

func TestUnitReadmitNodes_UpdateEarliestReadmitTime(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Make a node unhealthy and set its readmit time to a future time, before the minNodeReadmitPeriod
	unhealthyNodeKey := "node1:50211"
	unhealthyNode := mockNodes[unhealthyNodeKey].(*mockManagedNode)
	unhealthyNode.healthy = false
	mn.removeNodeFromHealthyNodes(unhealthyNode)

	futureReadmitTime := time.Now().Add(3 * time.Second) // Assuming minNodeReadmitPeriod is greater than 3 seconds
	unhealthyNode.readmitTime = &futureReadmitTime

	// Call _ReadmitNodes
	mn._ReadmitNodes()

	// Check if the unhealthy node is not present in the healthyNodes list
	found := false
	for _, node := range mn.healthyNodes {
		if node._GetAddress() == unhealthyNodeKey {
			found = true
			break
		}
	}
	require.False(t, found, "node1:50211 should not be present in the healthyNodes list since its readmit time is in the future")

	// Check if the earliestReadmitTime is updated to now.Add(this.minNodeReadmitPeriod)
	require.WithinDuration(t, futureReadmitTime.Add(mn.minNodeReadmitPeriod), mn.earliestReadmitTime, 5*time.Second)
}

func TestUnitGetNumberOfNodesForTransaction_Default(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	numNodes := mn._GetNumberOfNodesForTransaction()

	// Default behavior: (len(this.network) + 3 - 1) / 3
	expectedNumNodes := (len(mockNodes) + 3 - 1) / 3
	require.Equal(t, expectedNumNodes, numNodes)
}

func TestUnitGetNumberOfNodesForTransaction_MaxNodesPerTransaction(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	maxNodes := 2
	mn._SetMaxNodesPerTransaction(maxNodes)

	numNodes := mn._GetNumberOfNodesForTransaction()

	// If maxNodesPerTransaction is set, the number of nodes should be the minimum of maxNodesPerTransaction and the number of nodes in the network
	expectedNumNodes := int(math.Min(float64(maxNodes), float64(len(mockNodes))))
	require.Equal(t, expectedNumNodes, numNodes)
}

func TestUnitGetNumberOfNodesForTransaction_MaxNodesGreaterThanNetworkSize(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	maxNodes := 9
	mn._SetMaxNodesPerTransaction(maxNodes)

	numNodes := mn._GetNumberOfNodesForTransaction()

	expectedNumNodes := int(math.Min(float64(maxNodes), float64(len(mockNodes))))
	require.Equal(t, expectedNumNodes, numNodes)
}

func TestUnitGetNumberOfNodesForTransaction_MaxNodesNotSet(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	numNodes := mn._GetNumberOfNodesForTransaction()
	// 1/3 of the network size
	require.Equal(t, 1, numNodes)
}

func TestUnitGetNode(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Ensure that there are healthy nodes in the network
	require.NotEqual(t, 0, len(mn.healthyNodes))

	// Get a random node from the managed network
	node := mn._GetNode()

	// Check if the returned node is not nil
	require.NotNil(t, node)

	// Check if the returned node is one of the healthy nodes in the managed network
	found := false
	for _, healthyNode := range mn.healthyNodes {
		if node._GetAddress() == healthyNode._GetAddress() {
			found = true
			break
		}
	}
	require.True(t, found, "The returned node should be one of the healthy nodes in the managed network")
}

func TestUnitGetNodePanicNoHealthyNodes(t *testing.T) {
	t.Parallel()

	mn := _NewManagedNetwork()
	mockNodes := newMockNodes()
	err := mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Mark all nodes as unhealthy and set their readmit time in the future
	for _, node := range mockNodes {
		node.(*mockManagedNode).healthy = false
		readmitTime := time.Now().Add(1 * time.Minute)
		node.(*mockManagedNode).readmitTime = &readmitTime
	}

	// Update the network with unhealthy nodes
	err = mn._SetNetwork(mockNodes)
	require.NoError(t, err)

	// Ensure that there are no healthy nodes in the network
	require.Equal(t, 0, len(mn.healthyNodes))

	// Check if calling _GetNode() panics when there are no healthy nodes
	defer func() {
		if r := recover(); r != nil {
			panicValue, ok := r.(string)
			require.True(t, ok, "Panic value should be a string")
			require.Equal(t, "failed to find a healthy working node", panicValue)
		}
	}()

	mn._GetNode()
	require.Fail(t, "Expected _GetNode to panic")
}
// Filename: managed_node.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"sync"
	"time"
)

type _IManagedNode interface {
	_GetKey() string
	_SetVerifyCertificate(verify bool)
	_GetVerifyCertificate() bool
	_SetMinBackoff(waitTime time.Duration)
	_GetMinBackoff() time.Duration
	_SetMaxBackoff(waitTime time.Duration)
	_GetMaxBackoff() time.Duration
	_InUse()
	_IsHealthy() bool
	_IncreaseBackoff()
	_DecreaseBackoff()
	_Wait() time.Duration
	_GetUseCount() int64
	_GetLastUsed() time.Time
	_GetAttempts() int64
	_GetReadmitTime() *time.Time
	_GetAddress() string
	_ToSecure() _IManagedNode
	_ToInsecure() _IManagedNode
	_GetManagedNode() *_ManagedNode
	_Close() error
}

type _ManagedNode struct {
	address            *_ManagedNodeAddress
	currentBackoff     time.Duration
	lastUsed           time.Time
	useCount           int64
	minBackoff         time.Duration
	maxBackoff         time.Duration
	badGrpcStatusCount int64
	readmitTime        *time.Time
	mutex              sync.RWMutex
}

func (node *_ManagedNode) _GetAttempts() int64 {
	node.mutex.RLock()
	defer node.mutex.RUnlock()
	return node.badGrpcStatusCount
}

func (node *_ManagedNode) _GetAddress() string {
	if node.address != nil {
		return node.address._String()
	}

	return ""
}

func (node *_ManagedNode) _GetReadmitTime() *time.Time {
	node.mutex.RLock()
	defer node.mutex.RUnlock()
	return node.readmitTime
}

func _NewManagedNode(address string, minBackoff time.Duration) (node *_ManagedNode, err error) {
	node = &_ManagedNode{
		currentBackoff:     minBackoff,
		lastUsed:           time.Now(),
		useCount:           0,
		minBackoff:         minBackoff,
		maxBackoff:         1 * time.Hour,
		badGrpcStatusCount: 0,
	}
	node.address, err = _ManagedNodeAddressFromString(address)
	return node, err
}

func (node *_ManagedNode) _SetMinBackoff(minBackoff time.Duration) {
	if node.currentBackoff == node.minBackoff {
		node.currentBackoff = node.minBackoff
	}

	node.minBackoff = minBackoff
}

func (node *_ManagedNode) _GetMinBackoff() time.Duration {
	return node.minBackoff
}

func (node *_ManagedNode) _SetMaxBackoff(waitTime time.Duration) {
	node.maxBackoff = waitTime
}

func (node *_ManagedNode) _GetMaxBackoff() time.Duration {
	return node.maxBackoff
}

func (node *_ManagedNode) _InUse() {
	node.mutex.Lock()
	defer node.mutex.Unlock()

	node.useCount++
	node.lastUsed = time.Now()
}

func (node *_ManagedNode) _IsHealthy() bool {
	node.mutex.RLock()
	defer node.mutex.RUnlock()

	if node.readmitTime == nil {
		return true
	}

	return node.readmitTime.Before(time.Now())
}

func (node *_ManagedNode) _IncreaseBackoff() {
	node.mutex.Lock()
	defer node.mutex.Unlock()

	node.badGrpcStatusCount++
	node.currentBackoff *= 2
	if node.currentBackoff > node.maxBackoff {
		node.currentBackoff = node.maxBackoff
	}
	readmitTime := time.Now().Add(node.currentBackoff)
	node.readmitTime = &readmitTime
}

func (node *_ManagedNode) _DecreaseBackoff() {
	node.mutex.Lock()
	defer node.mutex.Unlock()

	node.currentBackoff /= 2
	if node.currentBackoff < node.minBackoff {
		node.currentBackoff = node.minBackoff
	}
}

func (node *_ManagedNode) _Wait() time.Duration {
	node.mutex.RLock()
	defer node.mutex.RUnlock()
	return node.readmitTime.Sub(node.lastUsed)
}

func (node *_ManagedNode) _GetUseCount() int64 {
	return node.useCount
}

func (node *_ManagedNode) _GetLastUsed() time.Time {
	return node.lastUsed
}
// Filename: managed_node_address.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"regexp"
	"strconv"
)

var hostAndPort = regexp.MustCompile(`^(\S+):(\d+)$`)

type _ManagedNodeAddress struct {
	address *string
	port    uint32
}

func _ManagedNodeAddressFromString(str string) (*_ManagedNodeAddress, error) {
	hostAndPortMatch := hostAndPort.FindStringSubmatch(str)

	if len(hostAndPortMatch) > 1 {
		port, err := strconv.ParseUint(hostAndPortMatch[2], 10, 64)
		if err != nil {
			return nil, err
		}

		return &_ManagedNodeAddress{
			address: &hostAndPortMatch[1],
			port:    uint32(port),
		}, nil
	}

	return nil, fmt.Errorf("failed to parse node address")
}

func (address *_ManagedNodeAddress) _IsTransportSecurity() bool {
	return address.port == 50212 || address.port == 443
}

func (address *_ManagedNodeAddress) _ToInsecure() *_ManagedNodeAddress {
	if address.port == 50212 {
		address.port = uint32(50211)
	}

	return address
}

func (address *_ManagedNodeAddress) _ToSecure() *_ManagedNodeAddress {
	if address.port == 50211 {
		address.port = uint32(50212)
	}
	return address
}

func (address *_ManagedNodeAddress) _Equals(comp _ManagedNodeAddress) bool { //nolint
	if address.address != nil && address.address == comp.address {
		if address.port == comp.port {
			return true
		}
	}

	return false
}

func (address *_ManagedNodeAddress) _String() string {
	if address.address != nil {
		return *address.address + ":" + strconv.FormatInt(int64(address.port), 10)
	}

	return ""
}
// Filename: managed_node_address_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestUnitManagedNodeAddressTest(t *testing.T) {
	t.Parallel()

	ipAddress, err := _ManagedNodeAddressFromString("35.237.200.180:50211")
	require.NoError(t, err)
	require.True(t, *ipAddress.address == "35.237.200.180")
	require.True(t, ipAddress.port == 50211)
	require.True(t, ipAddress._String() == "35.237.200.180:50211")

	ipAddressSecure := ipAddress._ToSecure()
	require.True(t, *ipAddressSecure.address == "35.237.200.180")
	require.True(t, ipAddressSecure.port == 50212)
	require.True(t, ipAddressSecure._String() == "35.237.200.180:50212")

	ipAddressInsecure := ipAddressSecure._ToInsecure()
	require.True(t, *ipAddressInsecure.address == "35.237.200.180")
	require.True(t, ipAddressInsecure.port == 50211)
	require.True(t, ipAddressInsecure._String() == "35.237.200.180:50211")

	urlAddress, err := _ManagedNodeAddressFromString("0.testnet.hedera.com:50211")
	require.NoError(t, err)
	require.True(t, *urlAddress.address == "0.testnet.hedera.com")
	require.True(t, urlAddress.port == 50211)
	require.True(t, urlAddress._String() == "0.testnet.hedera.com:50211")

	urlAddressSecure := urlAddress._ToSecure()
	require.True(t, *urlAddressSecure.address == "0.testnet.hedera.com")
	require.True(t, urlAddressSecure.port == 50212)
	require.True(t, urlAddressSecure._String() == "0.testnet.hedera.com:50212")

	urlAddressInsecure := urlAddressSecure._ToInsecure()
	require.True(t, *urlAddressInsecure.address == "0.testnet.hedera.com")
	require.True(t, urlAddressInsecure.port == 50211)
	require.True(t, urlAddressInsecure._String() == "0.testnet.hedera.com:50211")

	mirrorNodeAddress, err := _ManagedNodeAddressFromString("hcs.mainnet.mirrornode.hedera.com:50211")
	require.NoError(t, err)
	require.True(t, *mirrorNodeAddress.address == "hcs.mainnet.mirrornode.hedera.com")
	require.True(t, mirrorNodeAddress.port == 50211)
	require.True(t, mirrorNodeAddress._String() == "hcs.mainnet.mirrornode.hedera.com:50211")

	mirrorNodeAddressSecure := mirrorNodeAddress._ToSecure()
	require.True(t, *mirrorNodeAddressSecure.address == "hcs.mainnet.mirrornode.hedera.com")
	require.True(t, mirrorNodeAddressSecure.port == 50212)
	require.True(t, mirrorNodeAddressSecure._String() == "hcs.mainnet.mirrornode.hedera.com:50212")

	mirrorNodeAddressInsecure := mirrorNodeAddressSecure._ToInsecure()
	require.True(t, *mirrorNodeAddressInsecure.address == "hcs.mainnet.mirrornode.hedera.com")
	require.True(t, mirrorNodeAddressInsecure.port == 50211)
	require.True(t, mirrorNodeAddressInsecure._String() == "hcs.mainnet.mirrornode.hedera.com:50211")

	_, err = _ManagedNodeAddressFromString("this is a random string with spaces:443")
	require.Error(t, err)

	_, err = _ManagedNodeAddressFromString("hcs.mainnet.mirrornode.hedera.com:notarealport")
	require.Error(t, err)
}
// Filename: max_auto_associations_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Limited max auto association tests
func TestLimitedMaxAutoAssociationsFungibleTokensFlow(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create token1
	tokenID1, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create token2
	tokenID2, err := createFungibleToken(&env)
	require.NoError(t, err)

	// account create with 1 max auto associations
	receiver, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(1)
	})
	require.NoError(t, err)

	// transfer token1 to receiver account
	tokenTransferTransaction, err := NewTransferTransaction().
		AddTokenTransfer(tokenID1, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID1, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer token2 to the receiver should fail with NO_REMAINING_AUTOMATIC_ASSOCIATIONS
	tokenTransferTransaction2, err := NewTransferTransaction().
		AddTokenTransfer(tokenID2, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID2, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction2.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "NO_REMAINING_AUTOMATIC_ASSOCIATIONS")
}

func TestLimitedMaxAutoAssociationsNFTsFlow(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create 2 NFT collections and mint 10 NFTs for each collection
	nftID1, err := createNft(&env)
	require.NoError(t, err)

	mint, err := NewTokenMintTransaction().SetTokenID(nftID1).SetMetadatas(mintMetadata).Execute(env.Client)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftID2, err := createNft(&env)
	require.NoError(t, err)

	mint, err = NewTokenMintTransaction().SetTokenID(nftID2).SetMetadatas(mintMetadata).Execute(env.Client)
	receipt, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// account create with 1 max auto associations
	receiver, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(1)
	})
	require.NoError(t, err)

	// transfer nftID1 nfts to receiver account
	tokenTransferTransaction, err := NewTransferTransaction().
		AddNftTransfer(nftID1.Nft(serials[0]), env.OperatorID, receiver).
		AddNftTransfer(nftID1.Nft(serials[1]), env.OperatorID, receiver).
		AddNftTransfer(nftID1.Nft(serials[2]), env.OperatorID, receiver).
		AddNftTransfer(nftID1.Nft(serials[3]), env.OperatorID, receiver).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer nftID2 nft to receiver should fail with NO_REMAINING_AUTOMATIC_ASSOCIATIONS
	tokenTransferTransaction2, err := NewTransferTransaction().
		AddNftTransfer(nftID2.Nft(serials[0]), env.OperatorID, receiver).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction2.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "NO_REMAINING_AUTOMATIC_ASSOCIATIONS")
}

func TestLimitedMaxAutoAssociationsFungibleTokensWithManualAssociate(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create token1
	tokenID1, err := createFungibleToken(&env)

	// account create
	receiver, key, err := createAccount(&env)
	require.NoError(t, err)

	frozenAssociateTxn, err := NewTokenAssociateTransaction().SetAccountID(receiver).AddTokenID(tokenID1).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenAssociateTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer token1 to receiver account
	tokenTransferTransaction, err := NewTransferTransaction().
		AddTokenTransfer(tokenID1, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID1, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance of the receiver is 10
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(10), tokenBalance.Tokens.Get(tokenID1))
}

func TestLimitedMaxAutoAssociationsNFTsManualAssociate(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create NFT collection and mint 10
	nftID1, err := createNft(&env)
	require.NoError(t, err)

	mint, err := NewTokenMintTransaction().SetTokenID(nftID1).SetMetadatas(mintMetadata).Execute(env.Client)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// account create
	receiver, key, err := createAccount(&env)
	require.NoError(t, err)

	frozenAssociateTxn, err := NewTokenAssociateTransaction().SetAccountID(receiver).AddTokenID(nftID1).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenAssociateTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer nftID1 nfts to receiver account
	tokenTransferTransaction, err := NewTransferTransaction().
		AddNftTransfer(nftID1.Nft(serials[0]), env.OperatorID, receiver).
		AddNftTransfer(nftID1.Nft(serials[1]), env.OperatorID, receiver).
		AddNftTransfer(nftID1.Nft(serials[2]), env.OperatorID, receiver).
		AddNftTransfer(nftID1.Nft(serials[3]), env.OperatorID, receiver).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

// HIP-904 Unlimited max auto association tests
func TestUnlimitedMaxAutoAssociationsExecutes(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// account create with unlimited max auto associations - verify it executes
	_, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	accountID, newKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// update the account with unlimited max auto associations
	accountUpdateFrozen, err := NewAccountUpdateTransaction().
		SetMaxAutomaticTokenAssociations(-1).
		SetAccountID(accountID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	accountUpdate, err := accountUpdateFrozen.Sign(newKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = accountUpdate.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func TestUnlimitedMaxAutoAssociationsAllowsToTransferFungibleTokens(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create token1
	tokenID1, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create token2
	tokenID2, err := createFungibleToken(&env)
	require.NoError(t, err)

	// account create with unlimited max auto associations
	accountID1, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)
	// create account with 100 max auto associations
	accountID2, newKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// update the account with unlimited max auto associations
	accountUpdateFrozen, err := NewAccountUpdateTransaction().
		SetMaxAutomaticTokenAssociations(-1).
		SetAccountID(accountID2).
		FreezeWith(env.Client)
	require.NoError(t, err)

	accountUpdate, err := accountUpdateFrozen.Sign(newKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = accountUpdate.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer to both receivers some token1 tokens
	tokenTransferTransaction, err := NewTransferTransaction().
		AddTokenTransfer(tokenID1, env.Client.GetOperatorAccountID(), -1000).
		AddTokenTransfer(tokenID1, accountID1, 1000).
		AddTokenTransfer(tokenID1, env.Client.GetOperatorAccountID(), -1000).
		AddTokenTransfer(tokenID1, accountID2, 1000).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer to both receivers some token2 tokens
	tokenTransferTransaction, err = NewTransferTransaction().
		AddTokenTransfer(tokenID2, env.Client.GetOperatorAccountID(), -1000).
		AddTokenTransfer(tokenID2, accountID1, 1000).
		AddTokenTransfer(tokenID2, env.Client.GetOperatorAccountID(), -1000).
		AddTokenTransfer(tokenID2, accountID2, 1000).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance of the receivers is 1000
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(accountID1).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1000), tokenBalance.Tokens.Get(tokenID1))
	assert.Equal(t, uint64(1000), tokenBalance.Tokens.Get(tokenID2))

	tokenBalance, err = NewAccountBalanceQuery().SetAccountID(accountID2).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1000), tokenBalance.Tokens.Get(tokenID1))
	assert.Equal(t, uint64(1000), tokenBalance.Tokens.Get(tokenID2))
}

func TestUnlimitedMaxAutoAssociationsAllowsToTransferFungibleTokensWithDecimals(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create token1
	tokenID1, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetDecimals(10)
	})
	require.NoError(t, err)

	// create token2
	tokenID2, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetDecimals(10)
	})
	require.NoError(t, err)

	// account create with unlimited max auto associations
	accountID, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// transfer some token1 and token2 tokens
	tokenTransferTransaction, err := NewTransferTransaction().
		AddTokenTransferWithDecimals(tokenID1, env.Client.GetOperatorAccountID(), -1000, 10).
		AddTokenTransferWithDecimals(tokenID1, accountID, 1000, 10).
		AddTokenTransferWithDecimals(tokenID2, env.Client.GetOperatorAccountID(), -1000, 10).
		AddTokenTransferWithDecimals(tokenID2, accountID, 1000, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance of the receiver is 1000
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(accountID).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1000), tokenBalance.Tokens.Get(tokenID1))
	assert.Equal(t, uint64(1000), tokenBalance.Tokens.Get(tokenID2))
}

func TestUnlimitedMaxAutoAssociationsAllowsToTransferFromFungibleTokens(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create spender account which will be approved to spend
	spender, spenderKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(10)
	})
	require.NoError(t, err)

	// create token1
	tokenID1, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create token2
	tokenID2, err := createFungibleToken(&env)
	require.NoError(t, err)

	// account create with unlimited max auto associations
	accountID, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// approve the spender
	approve, err := NewAccountAllowanceApproveTransaction().
		AddTokenApproval(tokenID1, spender, 2000).
		AddTokenApproval(tokenID2, spender, 2000).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = approve.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transferFrom some token1 and token2 tokens
	env.Client.SetOperator(spender, spenderKey)
	tokenTransferTransactionFrozen, err := NewTransferTransaction().
		AddApprovedTokenTransfer(tokenID1, env.OperatorID, -1000, true).
		AddTokenTransfer(tokenID1, accountID, 1000).
		AddApprovedTokenTransfer(tokenID2, env.OperatorID, -1000, true).
		AddTokenTransfer(tokenID2, accountID, 1000).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tokenTransferTransaction, err := tokenTransferTransactionFrozen.Sign(spenderKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	env.Client.SetOperator(env.OperatorID, env.OperatorKey)

	// verify the balance of the receiver is 1000
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(accountID).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1000), tokenBalance.Tokens.Get(tokenID1))
	assert.Equal(t, uint64(1000), tokenBalance.Tokens.Get(tokenID2))
}

func TestUnlimitedMaxAutoAssociationsAllowsToTransferNFTs(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create 2 NFT collections and mint 10 NFTs for each collection
	nftID1, err := createNft(&env)
	require.NoError(t, err)

	mint, err := NewTokenMintTransaction().SetTokenID(nftID1).SetMetadatas(mintMetadata).Execute(env.Client)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftID2, err := createNft(&env)
	require.NoError(t, err)

	mint, err = NewTokenMintTransaction().SetTokenID(nftID2).SetMetadatas(mintMetadata).Execute(env.Client)
	receipt, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// account create with unlimited max auto associations
	accountID1, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	accountID2, newKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// account update with unlimited max auto associations
	accountUpdateFrozen, err := NewAccountUpdateTransaction().
		SetMaxAutomaticTokenAssociations(-1).
		SetAccountID(accountID2).
		FreezeWith(env.Client)
	require.NoError(t, err)

	accountUpdate, err := accountUpdateFrozen.Sign(newKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = accountUpdate.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer nft1 to both receivers, 2 for each
	tokenTransferTransaction, err := NewTransferTransaction().
		AddNftTransfer(nftID1.Nft(serials[0]), env.OperatorID, accountID1).
		AddNftTransfer(nftID1.Nft(serials[1]), env.OperatorID, accountID1).
		AddNftTransfer(nftID1.Nft(serials[2]), env.OperatorID, accountID2).
		AddNftTransfer(nftID1.Nft(serials[3]), env.OperatorID, accountID2).
		Execute(env.Client)

	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer nft2 to both receivers, 2 for each
	tokenTransferTransaction, err = NewTransferTransaction().
		AddNftTransfer(nftID2.Nft(serials[0]), env.OperatorID, accountID1).
		AddNftTransfer(nftID2.Nft(serials[1]), env.OperatorID, accountID1).
		AddNftTransfer(nftID2.Nft(serials[2]), env.OperatorID, accountID2).
		AddNftTransfer(nftID2.Nft(serials[3]), env.OperatorID, accountID2).
		Execute(env.Client)

	require.NoError(t, err)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance of the receivers is 2
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(accountID1).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(2), tokenBalance.Tokens.Get(nftID1))
	assert.Equal(t, uint64(2), tokenBalance.Tokens.Get(nftID2))

	tokenBalance, err = NewAccountBalanceQuery().SetAccountID(accountID2).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(2), tokenBalance.Tokens.Get(nftID1))
	assert.Equal(t, uint64(2), tokenBalance.Tokens.Get(nftID2))
}

func TestUnlimitedMaxAutoAssociationsAllowsToTransferFromNFTs(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create spender account which will be approved to spend
	spender, spenderKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(10)
	})
	require.NoError(t, err)

	// create 2 NFT collections and mint 10 NFTs for each collection
	nftID1, err := createNft(&env)
	require.NoError(t, err)

	mint, err := NewTokenMintTransaction().SetTokenID(nftID1).SetMetadatas(mintMetadata).Execute(env.Client)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftID2, err := createNft(&env)
	require.NoError(t, err)

	mint, err = NewTokenMintTransaction().SetTokenID(nftID2).SetMetadatas(mintMetadata).Execute(env.Client)
	receipt, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// account create with unlimited max auto associations
	accountID, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// approve the spender
	approve, err := NewAccountAllowanceApproveTransaction().
		AddAllTokenNftApproval(nftID1, spender).
		AddAllTokenNftApproval(nftID2, spender).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = approve.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transferFrom some nft1 nfts
	env.Client.SetOperator(spender, spenderKey)
	tokenTransferTransactionFrozen, err := NewTransferTransaction().
		AddApprovedNftTransfer(nftID1.Nft(serials[0]), env.OperatorID, accountID, true).
		AddApprovedNftTransfer(nftID1.Nft(serials[1]), env.OperatorID, accountID, true).
		AddApprovedNftTransfer(nftID2.Nft(serials[0]), env.OperatorID, accountID, true).
		AddApprovedNftTransfer(nftID2.Nft(serials[1]), env.OperatorID, accountID, true).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tokenTransferTransaction, err := tokenTransferTransactionFrozen.Sign(spenderKey).Execute(env.Client)

	_, err = tokenTransferTransaction.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	env.Client.SetOperator(env.OperatorID, env.OperatorKey)

	// verify the balance of the receiver is 2
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(accountID).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(2), tokenBalance.Tokens.Get(nftID1))
	assert.Equal(t, uint64(2), tokenBalance.Tokens.Get(nftID2))
}

func TestUnlimitedMaxAutoAssociationsFailsWithInvalid(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// account create with -2 and with -1000 max auto associations
	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	_, err = NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(0)).
		SetMaxAutomaticTokenAssociations(-2).
		Execute(env.Client)
	require.ErrorContains(t, err, "INVALID_MAX_AUTO_ASSOCIATIONS")

	_, err = NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(0)).
		SetMaxAutomaticTokenAssociations(-1000).
		Execute(env.Client)
	require.ErrorContains(t, err, "INVALID_MAX_AUTO_ASSOCIATIONS")

	// create account with 100 max auto associations
	accountID, newKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// account update with -2 max auto associations - should fail
	accountUpdateFrozen, err := NewAccountUpdateTransaction().
		SetMaxAutomaticTokenAssociations(-2).
		SetAccountID(accountID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx, err := accountUpdateFrozen.Sign(newKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_MAX_AUTO_ASSOCIATIONS")

	// account update with -1000 max auto associations - should fail
	accountUpdateFrozen, err = NewAccountUpdateTransaction().
		SetMaxAutomaticTokenAssociations(-1000).
		SetAccountID(accountID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx, err = accountUpdateFrozen.Sign(newKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_MAX_AUTO_ASSOCIATIONS")
}
// Filename: mirror_network.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"math/rand"
)

type _MirrorNetwork struct {
	_ManagedNetwork
}

func _NewMirrorNetwork() *_MirrorNetwork {
	return &_MirrorNetwork{
		_ManagedNetwork: _NewManagedNetwork(),
	}
}

func (network *_MirrorNetwork) _SetNetwork(newNetwork []string) (err error) {
	newMirrorNetwork := make(map[string]_IManagedNode)
	for _, url := range newNetwork {
		if newMirrorNetwork[url], err = _NewMirrorNode(url); err != nil {
			return err
		}
	}

	return network._ManagedNetwork._SetNetwork(newMirrorNetwork)
}

func (network *_MirrorNetwork) _GetNetwork() []string {
	temp := make([]string, 0)
	for url := range network._ManagedNetwork.network { //nolint
		temp = append(temp, url)
	}

	return temp
}

// nolint:unused
// Deprecated: _SetTransportSecurity is no longer supported, as only secured connections are now allowed.
func (network *_MirrorNetwork) _SetTransportSecurity(transportSecurity bool) *_MirrorNetwork {
	return network
}

func (network *_MirrorNetwork) _GetNextMirrorNode() *_MirrorNode {
	node := network._ManagedNetwork.healthyNodes[rand.Intn(len(network.healthyNodes))] // nolint
	if node, ok := node.(*_MirrorNode); ok {
		return node
	}
	return &_MirrorNode{}
}
// Filename: mirror_node.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"crypto/tls"
	"time"

	"google.golang.org/grpc/credentials/insecure"

	"github.com/hashgraph/hedera-protobufs-go/mirror"
	"github.com/pkg/errors"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/keepalive"

	"google.golang.org/grpc"
)

type _MirrorNode struct {
	*_ManagedNode
	consensusServiceClient *mirror.ConsensusServiceClient
	networkServiceClient   *mirror.NetworkServiceClient
	client                 *grpc.ClientConn
}

func (node *_MirrorNode) _SetVerifyCertificate(_ bool) {
}

func (node *_MirrorNode) _GetVerifyCertificate() bool {
	return false
}

func _NewMirrorNode(address string) (node *_MirrorNode, err error) {
	node = &_MirrorNode{}
	node._ManagedNode, err = _NewManagedNode(address, 250*time.Millisecond)
	return node, err
}

func (node *_MirrorNode) _GetKey() string {
	return node.address._String()
}

func (node *_MirrorNode) _SetMinBackoff(waitTime time.Duration) {
	node._ManagedNode._SetMinBackoff(waitTime)
}

func (node *_MirrorNode) _GetMinBackoff() time.Duration {
	return node._ManagedNode._GetMinBackoff()
}

func (node *_MirrorNode) _SetMaxBackoff(waitTime time.Duration) {
	node._ManagedNode._SetMaxBackoff(waitTime)
}

func (node *_MirrorNode) _GetMaxBackoff() time.Duration {
	return node._ManagedNode._GetMaxBackoff()
}

func (node *_MirrorNode) _InUse() {
	node._ManagedNode._InUse()
}

func (node *_MirrorNode) _IsHealthy() bool {
	return node._ManagedNode._IsHealthy()
}

func (node *_MirrorNode) _IncreaseBackoff() {
	node._ManagedNode._IncreaseBackoff()
}

func (node *_MirrorNode) _DecreaseBackoff() {
	node._ManagedNode._DecreaseBackoff()
}

func (node *_MirrorNode) _Wait() time.Duration {
	return node._ManagedNode._Wait()
}

func (node *_MirrorNode) _GetUseCount() int64 {
	return node._ManagedNode._GetUseCount()
}

func (node *_MirrorNode) _GetLastUsed() time.Time {
	return node._ManagedNode._GetLastUsed()
}

func (node *_MirrorNode) _GetManagedNode() *_ManagedNode {
	return node._ManagedNode
}

func (node *_MirrorNode) _GetAttempts() int64 {
	return node._ManagedNode._GetAttempts()
}

func (node *_MirrorNode) _GetAddress() string {
	return node._ManagedNode._GetAddress()
}

func (node *_MirrorNode) _GetReadmitTime() *time.Time {
	return node._ManagedNode._GetReadmitTime()
}

func (node *_MirrorNode) _GetConsensusServiceClient() (*mirror.ConsensusServiceClient, error) {
	if node.consensusServiceClient != nil {
		return node.consensusServiceClient, nil
	} else if node.client != nil {
		channel := mirror.NewConsensusServiceClient(node.client)
		node.consensusServiceClient = &channel
		return node.consensusServiceClient, nil
	}

	var kacp = keepalive.ClientParameters{
		Time:                10 * time.Second,
		Timeout:             time.Second,
		PermitWithoutStream: true,
	}

	var security grpc.DialOption

	if node._ManagedNode.address._IsTransportSecurity() {
		security = grpc.WithTransportCredentials(credentials.NewTLS(&tls.Config{})) // nolint
	} else {
		security = grpc.WithTransportCredentials(insecure.NewCredentials()) //nolint
	}

	conn, err := grpc.NewClient(node._ManagedNode.address._String(), security, grpc.WithKeepaliveParams(kacp))
	if err != nil {
		return nil, errors.Wrapf(err, "error connecting to mirror at %s", node._ManagedNode.address._String())
	}

	channel := mirror.NewConsensusServiceClient(conn)
	node.consensusServiceClient = &channel
	node.client = conn

	return node.consensusServiceClient, nil
}

func (node *_MirrorNode) _GetNetworkServiceClient() (*mirror.NetworkServiceClient, error) {
	if node.networkServiceClient != nil {
		return node.networkServiceClient, nil
	} else if node.client != nil {
		channel := mirror.NewNetworkServiceClient(node.client)
		node.networkServiceClient = &channel
		return node.networkServiceClient, nil
	}

	var kacp = keepalive.ClientParameters{
		Time:                time.Minute,
		Timeout:             20 * time.Second,
		PermitWithoutStream: true,
	}

	var security grpc.DialOption

	if node._ManagedNode.address._IsTransportSecurity() {
		security = grpc.WithTransportCredentials(credentials.NewTLS(&tls.Config{})) // nolint
	} else {
		security = grpc.WithTransportCredentials(insecure.NewCredentials()) //nolint
	}

	conn, err := grpc.NewClient(node._ManagedNode.address._String(), security, grpc.WithKeepaliveParams(kacp))
	if err != nil {
		return nil, errors.Wrapf(err, "error connecting to mirror at %s", node._ManagedNode.address._String())
	}

	channel := mirror.NewNetworkServiceClient(conn)
	node.networkServiceClient = &channel
	node.client = conn

	return node.networkServiceClient, nil
}

func (node *_MirrorNode) _ToSecure() _IManagedNode {
	managed := _ManagedNode{
		address:            node.address._ToSecure(),
		currentBackoff:     node.currentBackoff,
		lastUsed:           node.lastUsed,
		readmitTime:        node.readmitTime,
		useCount:           node.useCount,
		minBackoff:         node.minBackoff,
		badGrpcStatusCount: node.badGrpcStatusCount,
	}

	return &_MirrorNode{
		_ManagedNode:           &managed,
		consensusServiceClient: node.consensusServiceClient,
		client:                 node.client,
	}
}

func (node *_MirrorNode) _ToInsecure() _IManagedNode {
	managed := _ManagedNode{
		address:            node.address._ToInsecure(),
		currentBackoff:     node.currentBackoff,
		lastUsed:           node.lastUsed,
		readmitTime:        node.readmitTime,
		useCount:           node.useCount,
		minBackoff:         node.minBackoff,
		badGrpcStatusCount: node.badGrpcStatusCount,
	}

	return &_MirrorNode{
		_ManagedNode:           &managed,
		consensusServiceClient: node.consensusServiceClient,
		client:                 node.client,
	}
}

func (node *_MirrorNode) _Close() error {
	if node.consensusServiceClient != nil {
		return node.client.Close()
	}

	return nil
}
// Filename: mnemonic.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"crypto/sha256"
	"fmt"
	"math/big"
	"regexp"
	"strconv"
	"strings"

	"crypto/sha512"

	"github.com/pkg/errors"
	"github.com/tyler-smith/go-bip39"
	"golang.org/x/crypto/pbkdf2"
	"golang.org/x/text/unicode/norm"
)

type Mnemonic struct {
	words string
}

// Deprecated
func (m Mnemonic) ToPrivateKey(passPhrase string) (PrivateKey, error) {
	return PrivateKeyFromMnemonic(m, passPhrase)
}

// GenerateMnemonic generates a random 24-word mnemonic
func GenerateMnemonic24() (Mnemonic, error) {
	entropy, err := bip39.NewEntropy(256)

	if err != nil {
		// It is only possible for there to be an error if the operating
		// system's rng is unreadable
		return Mnemonic{}, fmt.Errorf("could not retrieve random bytes from the operating system")
	}

	mnemonic, err := bip39.NewMnemonic(entropy)

	// Note that this should never actually fail since it is being provided by library generated mnemonic
	if err != nil {
		return Mnemonic{}, err
	}

	return Mnemonic{mnemonic}, nil
}

// GenerateMnemonic12 generates a random 12-word mnemonic
func GenerateMnemonic12() (Mnemonic, error) {
	entropy, err := bip39.NewEntropy(128)

	if err != nil {
		// It is only possible for there to be an error if the operating
		// system's rng is unreadable
		return Mnemonic{}, fmt.Errorf("could not retrieve random bytes from the operating system")
	}

	mnemonic, err := bip39.NewMnemonic(entropy)

	// Note that this should never actually fail since it is being provided by library generated mnemonic
	if err != nil {
		return Mnemonic{}, err
	}

	return Mnemonic{mnemonic}, nil
}

// MnemonicFromString creates a mnemonic from a string of 24 words separated by spaces
//
// Keys are lazily generated
func MnemonicFromString(s string) (Mnemonic, error) {
	return NewMnemonic(strings.Split(s, " "))
}

// String returns the mnemonic as a string.
func (m Mnemonic) String() string {
	return m.words
}

// Words returns the mnemonic as a slice of strings
func (m Mnemonic) Words() []string {
	return strings.Split(m.words, " ")
}

// NewMnemonic Creates a mnemonic from a slice of 24 strings
//
// Keys are lazily generated
func NewMnemonic(words []string) (Mnemonic, error) {
	joinedString := strings.Join(words, " ")

	if len(words) == 24 || len(words) == 12 || len(words) == 22 {
		if len(words) == 22 { //nolint
			return Mnemonic{
				words: joinedString,
			}._LegacyValidate()
		} else if bip39.IsMnemonicValid(joinedString) {
			return Mnemonic{
				words: joinedString,
			}, nil
		} else {
			return Mnemonic{}, fmt.Errorf("invalid mnemonic composition")
		}
	} else {
		return Mnemonic{}, fmt.Errorf("invalid mnemonic string")
	}
}

func (m Mnemonic) _LegacyValidate() (Mnemonic, error) {
	if len(strings.Split(m.words, " ")) != 22 {
		return Mnemonic{}, fmt.Errorf("not a legacy mnemonic")
	}

	indices, err := m._Indices()
	if err != nil {
		return Mnemonic{}, err
	}

	entropy, checksum := m._ToLegacyEntropy(indices)
	newchecksum := _Crc8(entropy)

	if checksum != newchecksum {
		return Mnemonic{}, fmt.Errorf("legacy mnemonic checksum mismatch")
	}

	return m, nil
}

func (m Mnemonic) _Indices() ([]int, error) {
	var indices []int
	var check bool
	temp := strings.Split(m.words, " ")
	if len(temp) == 22 { // nolint
		for _, mnemonicString := range strings.Split(m.words, " ") {
			check = false
			for i, stringCheck := range legacy {
				if mnemonicString == stringCheck {
					check = true
					indices = append(indices, i)
				}
			}
			if !check {
				return make([]int, 0), fmt.Errorf("word is not in the legacy word list")
			}
		}
	} else if len(temp) == 24 {
		for _, mnemonicString := range strings.Split(m.words, " ") {
			t, check := bip39.GetWordIndex(mnemonicString)
			if !check {
				return make([]int, 0), bip39.ErrInvalidMnemonic
			}
			indices = append(indices, t)
		}
	} else {
		return make([]int, 0), errors.New("not a 22 word or a 24 mnemonic")
	}

	return indices, nil
}

// ToLegacyPrivateKey converts a mnemonic to a legacy private key
func (m Mnemonic) ToLegacyPrivateKey() (PrivateKey, error) {
	indices, err := m._Indices()
	if err != nil {
		return PrivateKey{}, err
	}

	var entropy []byte
	if len(indices) == 22 { // nolint
		entropy, _ = m._ToLegacyEntropy(indices)
	} else if len(indices) == 24 {
		entropy, err = m._ToLegacyEntropy2()
		if err != nil {
			return PrivateKey{}, err
		}
	} else {
		return PrivateKey{}, errors.New("not a legacy key")
	}

	return PrivateKeyFromBytesEd25519(entropy)
}

func bytesToBits(dat []uint8) []bool {
	bits := make([]bool, len(dat)*8)

	for i := range bits {
		bits[i] = false
	}

	for i := 0; i < len(dat); i++ {
		for j := 0; j < 8; j++ {
			bits[(i*8)+j] = (dat[i] & (1 << (7 - j))) != 0
		}
	}

	return bits
}

func (m Mnemonic) _ToLegacyEntropy(indices []int) ([]byte, uint8) {
	data := _ConvertRadix(indices, len(legacy), 256, 33)

	checksum := data[len(data)-1]
	result := make([]uint8, len(data)-1)

	for i := 0; i < len(data)-1; i++ {
		result[i] = data[i] ^ checksum
	}

	return result, checksum
}

func (m Mnemonic) _ToLegacyEntropy2() ([]byte, error) {
	indices := strings.Split(m.words, " ")
	concatBitsLen := len(indices) * 11
	concatBits := make([]bool, concatBitsLen)

	for i := range concatBits {
		concatBits[i] = false
	}

	for index, word := range indices {
		nds, check := bip39.GetWordIndex(word)
		if !check {
			return make([]byte, 0), bip39.ErrInvalidMnemonic
		}

		for i := 0; i < 11; i++ {
			concatBits[(index*11)+i] = (nds & (1 << (10 - i))) != 0
		}
	}

	checksumBitsLen := concatBitsLen / 33
	entropyBitsLen := concatBitsLen - checksumBitsLen

	entropy := make([]uint8, entropyBitsLen/8)

	for i := 0; i < len(entropy); i++ {
		for j := 0; j < 8; j++ {
			if concatBits[(i*8)+j] {
				entropy[i] |= 1 << (7 - j)
			}
		}
	}

	hash := sha256.New()
	if _, err := hash.Write(entropy); err != nil {
		return nil, err
	}

	hashbits := bytesToBits(hash.Sum(nil))

	for i := 0; i < checksumBitsLen; i++ {
		if concatBits[entropyBitsLen+i] != hashbits[i] {
			return make([]uint8, 0), errors.New("checksum mismatch")
		}
	}

	return entropy, nil
}

func (m Mnemonic) _ToSeed(passPhrase string) []byte {
	passPhraseNFKD := norm.NFKD.String(passPhrase)
	salt := []byte("mnemonic" + passPhraseNFKD)
	seed := pbkdf2.Key([]byte(m.String()), salt, 2048, 64, sha512.New)
	return seed
}

// ToStandardEd25519PrivateKey converts a mnemonic to a standard ed25519 private key
func (m Mnemonic) ToStandardEd25519PrivateKey(passPhrase string, index uint32) (PrivateKey, error) {
	seed := m._ToSeed(passPhrase)
	derivedKey, err := _Ed25519PrivateKeyFromSeed(seed)
	if err != nil {
		return PrivateKey{}, err
	}

	keyBytes, chainCode := derivedKey.keyData, derivedKey.chainCode
	for _, i := range []uint32{44, 3030, 0, 0, index} {
		keyBytes, chainCode, err = _DeriveEd25519ChildKey(keyBytes, chainCode, i)
		if err != nil {
			return PrivateKey{}, err
		}
	}

	privateKey, err := _Ed25519PrivateKeyFromBytes(keyBytes)
	if err != nil {
		return PrivateKey{}, err
	}

	privateKey.chainCode = chainCode

	return PrivateKey{
		ed25519PrivateKey: privateKey,
	}, nil
}

// calculateDerivationPathValues converts a derivation path string to an array of integers
func calculateDerivationPathValues(derivationPath string) ([]uint32, error) {
	re := regexp.MustCompile(`m/(\d+'?)/(\d+'?)/(\d+'?)/(\d+'?)/(\d+'?)`)
	matches := re.FindStringSubmatch(derivationPath)
	if len(matches) != 6 {
		return nil, fmt.Errorf("invalid derivation path format")
	}

	values := make([]uint32, 5)
	for i, match := range matches[1:] {
		if strings.HasSuffix(match, "'") {
			match = strings.TrimSuffix(match, "'")
			value, err := strconv.Atoi(match)
			if err != nil {
				return nil, err
			}
			values[i] = ToHardenedIndex(uint32(value))
		} else {
			value, err := strconv.Atoi(match)
			if err != nil {
				return nil, err
			}
			values[i] = uint32(value)
		}
	}

	return values, nil
}

func (m Mnemonic) toStandardECDSAsecp256k1PrivateKeyImpl(passPhrase string, derivationPathValues []uint32) (PrivateKey, error) {
	seed := m._ToSeed(passPhrase)
	derivedKey, err := _ECDSAPrivateKeyFromSeed(seed)
	if err != nil {
		return PrivateKey{}, err
	}

	keyBytes, chainCode := derivedKey.keyData.D.Bytes(), derivedKey.chainCode
	for _, i := range derivationPathValues {
		keyBytes, chainCode, err = _DeriveECDSAChildKey(keyBytes, chainCode, i)
		if err != nil {
			return PrivateKey{}, err
		}
	}

	privateKey, err := _ECDSAPrivateKeyFromBytes(keyBytes)
	if err != nil {
		return PrivateKey{}, err
	}

	privateKey.chainCode = chainCode

	return PrivateKey{
		ecdsaPrivateKey: privateKey,
	}, nil
}

// ToStandardECDSAsecp256k1PrivateKey converts a mnemonic to a standard ecdsa secp256k1 private key
func (m Mnemonic) ToStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(passPhrase string, derivationPath string) (PrivateKey, error) {
	derivationPathValues, err := calculateDerivationPathValues(derivationPath)
	if err != nil {
		return PrivateKey{}, err
	}

	return m.toStandardECDSAsecp256k1PrivateKeyImpl(passPhrase, derivationPathValues)
}

// ToStandardECDSAsecp256k1PrivateKey converts a mnemonic to a standard ecdsa secp256k1 private key
// Uses the default derivation path of `m/44'/3030'/0'/0/${index}`
func (m Mnemonic) ToStandardECDSAsecp256k1PrivateKey(passPhrase string, index uint32) (PrivateKey, error) {
	seed := m._ToSeed(passPhrase)
	derivedKey, err := _ECDSAPrivateKeyFromSeed(seed)
	if err != nil {
		return PrivateKey{}, err
	}

	keyBytes, chainCode := derivedKey.keyData.D.Bytes(), derivedKey.chainCode
	for _, i := range []uint32{
		ToHardenedIndex(44),
		ToHardenedIndex(3030),
		ToHardenedIndex(0),
		0,
		index} {
		keyBytes, chainCode, err = _DeriveECDSAChildKey(keyBytes, chainCode, i)
		if err != nil {
			return PrivateKey{}, err
		}
	}

	privateKey, err := _ECDSAPrivateKeyFromBytes(keyBytes)
	if err != nil {
		return PrivateKey{}, err
	}

	privateKey.chainCode = chainCode

	return PrivateKey{
		ecdsaPrivateKey: privateKey,
	}, nil
}

func _ConvertRadix(nums []int, fromRadix int, toRadix int, toLength int) []uint8 {
	num := big.NewInt(0)

	for _, element := range nums {
		num = num.Mul(num, big.NewInt(int64(fromRadix)))
		num = num.Add(num, big.NewInt(int64(element)))
	}

	result := make([]uint8, toLength)

	for i := toLength - 1; i >= 0; i-- {
		tem := new(big.Int).Div(num, big.NewInt(int64(toRadix)))
		rem := new(big.Int).Mod(num, big.NewInt(int64(toRadix)))
		num = num.Set(tem)
		result[i] = uint8(rem.Uint64())
	}

	return result
}

func _Crc8(data []uint8) uint8 {
	var crc uint8
	crc = 0xff

	for i := 0; i < len(data)-1; i++ {
		crc ^= data[i]
		for j := 0; j < 8; j++ {
			var temp uint8
			if crc&1 == 0 {
				temp = 0
			} else {
				temp = 0xb2
			}
			crc = crc>>1 ^ temp
		}
	}

	return crc ^ 0xff
}
// Filename: mnemonic_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var mnemonicLegacyV1String = "jolly kidnap tom lawn drunk chick optic lust mutter mole bride galley dense member sage neural widow decide curb aboard margin manure"

var mnemonicLegacyV2String = "obvious favorite remain caution remove laptop base vacant increase video erase pass sniff sausage knock grid argue salt romance way alone fever slush dune"

var mnemonic24WordString = "inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home"

var mnemonic12WordString = "finish furnace tomorrow wine mass goose festival air palm easy region guilt"

var passPhrase = "some pass"

func TestUnitGenerate24WordMnemonic(t *testing.T) {
	mnemonic, err := GenerateMnemonic24()
	require.NoError(t, err)

	assert.Equal(t, 24, len(mnemonic.Words()))
}

func TestUnitGenerate12WordMnemonic(t *testing.T) {
	mnemonic, err := GenerateMnemonic12()
	require.NoError(t, err)

	assert.Equal(t, 12, len(mnemonic.Words()))
}

func TestUnitMnemonicFromString(t *testing.T) {
	mnemonic, err := MnemonicFromString(testMnemonic)
	require.NoError(t, err)

	assert.Equal(t, testMnemonic, mnemonic.String())
	assert.Equal(t, 24, len(mnemonic.Words()))
}

func TestUnitNew24MnemonicFromGeneratedMnemonic(t *testing.T) {
	generatedMnemonic, err := GenerateMnemonic24()
	require.NoError(t, err)

	mnemonicFromSlice, err := NewMnemonic(generatedMnemonic.Words())
	require.NoError(t, err)
	assert.Equal(t, generatedMnemonic.words, mnemonicFromSlice.words)

	mnemonicFromString, err := MnemonicFromString(generatedMnemonic.String())
	require.NoError(t, err)
	assert.Equal(t, generatedMnemonic, mnemonicFromString)

	gKey, err := generatedMnemonic.ToPrivateKey(passphrase)
	require.NoError(t, err)

	slKey, err := generatedMnemonic.ToPrivateKey(passphrase)
	require.NoError(t, err)

	stKey, err := generatedMnemonic.ToPrivateKey(passphrase)
	require.NoError(t, err)

	assert.Equal(t, gKey.ed25519PrivateKey.keyData, slKey.ed25519PrivateKey.keyData)
	assert.Equal(t, gKey.ed25519PrivateKey.keyData, stKey.ed25519PrivateKey.keyData)
}

func TestUnitNew12MnemonicFromGeneratedMnemonic(t *testing.T) {
	generatedMnemonic, err := GenerateMnemonic12()
	require.NoError(t, err)

	mnemonicFromSlice, err := NewMnemonic(generatedMnemonic.Words())
	require.NoError(t, err)
	assert.Equal(t, generatedMnemonic.words, mnemonicFromSlice.words)

	mnemonicFromString, err := MnemonicFromString(generatedMnemonic.String())
	require.NoError(t, err)
	assert.Equal(t, generatedMnemonic, mnemonicFromString)

	gKey, err := generatedMnemonic.ToPrivateKey(passphrase)
	require.NoError(t, err)

	slKey, err := mnemonicFromSlice.ToPrivateKey(passphrase)
	require.NoError(t, err)

	stKey, err := mnemonicFromString.ToPrivateKey(passphrase)
	require.NoError(t, err)

	assert.Equal(t, gKey.ed25519PrivateKey.keyData, slKey.ed25519PrivateKey.keyData)
	assert.Equal(t, gKey.ed25519PrivateKey.keyData, stKey.ed25519PrivateKey.keyData)
}

func TestLegacyV1Mnemonic(t *testing.T) {
	test1PrivateKey := "00c2f59212cb3417f0ee0d38e7bd876810d04f2dd2cb5c2d8f26ff406573f2bd"
	test1PublicKey := "0c5bb4624df6b64c2f07a8cb8753945dd42d4b9a2ed4c0bf98e87ef154f473e9"
	test2PrivateKey := "fae0002d2716ea3a60c9cd05ee3c4bb88723b196341b68a02d20975f9d049dc6"
	test2PublicKey := "f40f9fdb1f161c31ed656794ada7af8025e8b5c70e538f38a4dfb46a0a6b0392"
	test3PrivateKey := "882a565ad8cb45643892b5366c1ee1c1ef4a730c5ce821a219ff49b6bf173ddf"
	test3PublicKey := "53c6b451e695d6abc52168a269316a0d20deee2331f612d4fb8b2b379e5c6854"
	test4PrivateKey := "6890dc311754ce9d3fc36bdf83301aa1c8f2556e035a6d0d13c2cccdbbab1242"
	test4PublicKey := "45f3a673984a0b4ee404a1f4404ed058475ecd177729daa042e437702f7791e9"

	mnemonic, err := MnemonicFromString(mnemonicLegacyV1String)
	require.NoError(t, err)

	key1, err := mnemonic.ToLegacyPrivateKey()
	require.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)

	key2, err := key1.LegacyDerive(0)
	require.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)

	key3, err := key1.LegacyDerive(-1)
	require.NoError(t, err)

	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)

	key4, err := key1.LegacyDerive(1099511627775)
	require.NoError(t, err)

	assert.Equal(t, key4.StringRaw(), test4PrivateKey)
	assert.Equal(t, key4.PublicKey().StringRaw(), test4PublicKey)
}

func TestLegacyV2Mnemonic(t *testing.T) {
	test1PrivateKey := "98aa82d6125b5efa04bf8372be7931d05cd77f5ef3330b97d6ee7c006eaaf312"
	test1PublicKey := "e0ce688d614f22f96d9d213ca513d58a7d03d954fe45790006e6e86b25456465"
	test2PrivateKey := "2b7345f302a10c2a6d55bf8b7af40f125ec41d780957826006d30776f0c441fb"
	test2PublicKey := "0e19f99800b007cc7c82f9d85b73e0f6e48799469450caf43f253b48c4d0d91a"
	test3PrivateKey := "caffc03fdb9853e6a91a5b3c57a5c0031d164ce1c464dea88f3114786b5199e5"
	test3PublicKey := "9fe11da3fcfba5d28a6645ecb611a9a43dbe6014b102279ba1d34506ea86974b"

	mnemonic, err := MnemonicFromString(mnemonicLegacyV2String)
	require.NoError(t, err)

	key1, err := mnemonic.ToLegacyPrivateKey()
	require.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)

	key2, err := key1.LegacyDerive(0)
	require.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)

	key3, err := key1.LegacyDerive(-1)
	require.NoError(t, err)

	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)
}

func TestUnitMnemonicBreaksWithBadLength(t *testing.T) {
	// note this mnemonic is probably invalid and is only used to test breakage based on length
	shortMnemonic := "inmate flip alley wear offer often piece magnet surge toddler submit right business"

	_, err := MnemonicFromString(shortMnemonic)
	assert.Error(t, err)

	_, err = NewMnemonic(strings.Split(shortMnemonic, " "))
	assert.Error(t, err)
}

func TestBIP39NFKD(t *testing.T) {
	passphrase := "\u03B4\u03BF\u03BA\u03B9\u03BC\u03AE"
	expectedPrivateKey := "302e020100300506032b6570042204203fefe1000db9485372851d542453b07e7970de4e2ecede7187d733ac037f4d2c"
	mnemonic, err := MnemonicFromString(mnemonic24WordString)
	assert.NoError(t, err)
	key, err := mnemonic.ToPrivateKey(passphrase)
	assert.NoError(t, err)
	assert.Equal(t, key.String(), expectedPrivateKey)
}
func TestBIP39Vector(t *testing.T) {
	passPhrase := "TREZOR"

	// the commented out tests are 18 words mnemonic, which are not supported.
	tests := [][]string{
		{
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
			"c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04",
		},
		{
			"legal winner thank year wave sausage worth useful legal winner thank yellow",
			"2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6fa457fe1296106559a3c80937a1c1069be3a3a5bd381ee6260e8d9739fce1f607",
		},
		{
			"letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
			"d71de856f81a8acc65e6fc851a38d4d7ec216fd0796d0a6827a3ad6ed5511a30fa280f12eb2e47ed2ac03b5c462a0358d18d69fe4f985ec81778c1b370b652a8",
		},
		{
			"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
			"ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",
		},
		// {
		// 	"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
		// 	"035895f2f481b1b0f01fcf8c289c794660b289981a78f8106447707fdd9666ca06da5a9a565181599b79f53b844d8a71dd9f439c52a3d7b3e8a79c906ac845fa",
		// },
		// {
		// 	"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
		// 	"f2b94508732bcbacbcc020faefecfc89feafa6649a5491b8c952cede496c214a0c7b3c392d168748f2d4a612bada0753b52a1c7ac53c1e93abd5c6320b9e95dd",
		// },
		// {
		// 	"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
		// 	"107d7c02a5aa6f38c58083ff74f04c607c2d2c0ecc55501dadd72d025b751bc27fe913ffb796f841c49b1d33b610cf0e91d3aa239027f5e99fe4ce9e5088cd65",
		// },
		// {
		// 	"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
		// 	"0cd6e5d827bb62eb8fc1e262254223817fd068a74b5b449cc2f667c3f1f985a76379b43348d952e2265b4cd129090758b3e3c2c49103b5051aac2eaeb890a528",
		// },
		{
			"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
			"bda85446c68413707090a52022edd26a1c9462295029f2e60cd7c4f2bbd3097170af7a4d73245cafa9c3cca8d561a7c3de6f5d4a10be8ed2a5e608d68f92fcc8",
		},
		{
			"legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
			"bc09fca1804f7e69da93c2f2028eb238c227f2e9dda30cd63699232578480a4021b146ad717fbb7e451ce9eb835f43620bf5c514db0f8add49f5d121449d3e87",
		},
		{
			"letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
			"c0c519bd0e91a2ed54357d9d1ebef6f5af218a153624cf4f2da911a0ed8f7a09e2ef61af0aca007096df430022f7a2b6fb91661a9589097069720d015e4e982f",
		},
		{
			"zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
			"dd48c104698c30cfe2b6142103248622fb7bb0ff692eebb00089b32d22484e1613912f0a5b694407be899ffd31ed3992c456cdf60f5d4564b8ba3f05a69890ad",
		},
		{
			"ozone drill grab fiber curtain grace pudding thank cruise elder eight picnic",
			"274ddc525802f7c828d8ef7ddbcdc5304e87ac3535913611fbbfa986d0c9e5476c91689f9c8a54fd55bd38606aa6a8595ad213d4c9c9f9aca3fb217069a41028",
		},
		// {
		// 	"gravity machine north sort system female filter attitude volume fold club stay feature office ecology stable narrow fog",
		// 	"628c3827a8823298ee685db84f55caa34b5cc195a778e52d45f59bcf75aba68e4d7590e101dc414bc1bbd5737666fbbef35d1f1903953b66624f910feef245ac",
		// },
		{
			"hamster diagram private dutch cause delay private meat slide toddler razor book happy fancy gospel tennis maple dilemma loan word shrug inflict delay length",
			"64c87cde7e12ecf6704ab95bb1408bef047c22db4cc7491c4271d170a1b213d20b385bc1588d9c7b38f1b39d415665b8a9030c9ec653d75e65f847d8fc1fc440",
		},
		{
			"scheme spot photo card baby mountain device kick cradle pact join borrow",
			"ea725895aaae8d4c1cf682c1bfd2d358d52ed9f0f0591131b559e2724bb234fca05aa9c02c57407e04ee9dc3b454aa63fbff483a8b11de949624b9f1831a9612",
		},
		// {
		// 	"horn tenant knee talent sponsor spell gate clip pulse soap slush warm silver nephew swap uncle crack brave",
		// 	"fd579828af3da1d32544ce4db5c73d53fc8acc4ddb1e3b251a31179cdb71e853c56d2fcb11aed39898ce6c34b10b5382772db8796e52837b54468aeb312cfc3d",
		// },
		{
			"panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside",
			"72be8e052fc4919d2adf28d5306b5474b0069df35b02303de8c1729c9538dbb6fc2d731d5f832193cd9fb6aeecbc469594a70e3dd50811b5067f3b88b28c3e8d",
		},
		{
			"cat swing flag economy stadium alone churn speed unique patch report train",
			"deb5f45449e615feff5640f2e49f933ff51895de3b4381832b3139941c57b59205a42480c52175b6efcffaa58a2503887c1e8b363a707256bdd2b587b46541f5",
		},
		// {
		// 	"light rule cinnamon wrap drastic word pride squirrel upgrade then income fatal apart sustain crack supply proud access",
		// 	"4cbdff1ca2db800fd61cae72a57475fdc6bab03e441fd63f96dabd1f183ef5b782925f00105f318309a7e9c3ea6967c7801e46c8a58082674c860a37b93eda02",
		// },
		{
			"all hour make first leader extend hole alien behind guard gospel lava path output census museum junior mass reopen famous sing advance salt reform",
			"26e975ec644423f4a4c4f4215ef09b4bd7ef924e85d1d17c4cf3f136c2863cf6df0a475045652c57eb5fb41513ca2a2d67722b77e954b4b3fc11f7590449191d",
		},
		{
			"vessel ladder alter error federal sibling chat ability sun glass valve picture",
			"2aaa9242daafcee6aa9d7269f17d4efe271e1b9a529178d7dc139cd18747090bf9d60295d0ce74309a78852a9caadf0af48aae1c6253839624076224374bc63f",
		},
		// {
		// 	"scissors invite lock maple supreme raw rapid void congress muscle digital elegant little brisk hair mango congress clump",
		// 	"7b4a10be9d98e6cba265566db7f136718e1398c71cb581e1b2f464cac1ceedf4f3e274dc270003c670ad8d02c4558b2f8e39edea2775c9e232c7cb798b069e88",
		// },
		{
			"void come effort suffer camp survey warrior heavy shoot primary clutch crush open amazing screen patrol group space point ten exist slush involve unfold",
			"01f5bced59dec48e362f2c45b5de68b9fd6c92c6634f44d6d40aab69056506f0e35524a518034ddc1192e1dacd32c1ed3eaa3c3b131c88ed8e7e54c49a5d0998",
		},
	}

	for _, test := range tests {
		test1Mnemonic, err := MnemonicFromString(test[0])
		assert.NoError(t, err)
		assert.Equal(t, hex.EncodeToString(test1Mnemonic._ToSeed(passPhrase)), test[1], "failed for mnemonic: ", test[0])
	}
}

func TestToStandardED25519PrivateKey(t *testing.T) {
	test1PrivateKey := "f8dcc99a1ced1cc59bc2fee161c26ca6d6af657da9aa654da724441343ecd16f"
	test1PublicKey := "2e42c9f5a5cdbde64afa65ce3dbaf013d5f9ff8d177f6ef4eb89fbe8c084ec0d"
	test1ChainCode := "404914563637c92d688deb9d41f3f25cbe8d6659d859cc743712fcfac72d7eda"
	test2PrivateKey := "e978a6407b74a0730f7aeb722ad64ab449b308e56006c8bff9aad070b9b66ddf"
	test2PublicKey := "c4b33dca1f83509f17b69b2686ee46b8556143f79f4b9df7fe7ed3864c0c64d0"
	test2ChainCode := "9c2b0073ac934696cd0b52c6c521b9bd1902aac134380a737282fdfe29014bf1"
	test3PrivateKey := "abeca64d2337db386e289482a252334c68c7536daaefff55dc169ddb77fbae28"
	test3PublicKey := "fd311925a7a04b38f7508931c6ae6a93e5dc4394d83dafda49b051c0017d3380"
	test3ChainCode := "699344acc5e07c77eb63b154b4c5c3d33cab8bf85ee21bea4cc29ab7f0502259"
	test4PrivateKey := "9a601db3e24b199912cec6573e6a3d01ffd3600d50524f998b8169c105165ae5"
	test4PublicKey := "cf525500706faa7752dca65a086c9381d30d72cc67f23bf334f330579074a890"
	test4ChainCode := "e5af7c95043a912af57a6e031ddcad191677c265d75c39954152a2733c750a3b"

	mnemonic, err := MnemonicFromString(mnemonic24WordString)
	require.NoError(t, err)

	// Chain m/44'/3030'/0'/0'/0'
	key1, err := mnemonic.ToStandardEd25519PrivateKey("", 0)
	require.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)
	assert.Equal(t, hex.EncodeToString(key1.ed25519PrivateKey.chainCode), test1ChainCode)

	// Chain m/44'/3030'/0'/0'/2147483647'
	key2, err := mnemonic.ToStandardEd25519PrivateKey("", 2147483647)
	require.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)
	assert.Equal(t, hex.EncodeToString(key2.ed25519PrivateKey.chainCode), test2ChainCode)

	// Chain m/44'/3030'/0'/0'/0'; Passphrase: "some pass"
	key3, err := mnemonic.ToStandardEd25519PrivateKey(passPhrase, 0)
	require.NoError(t, err)

	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)
	assert.Equal(t, hex.EncodeToString(key3.ed25519PrivateKey.chainCode), test3ChainCode)

	// Chain m/44'/3030'/0'/0'/2147483647'; Passphrase: "some pass"
	key4, err := mnemonic.ToStandardEd25519PrivateKey(passPhrase, 2147483647)
	require.NoError(t, err)

	assert.Equal(t, key4.StringRaw(), test4PrivateKey)
	assert.Equal(t, key4.PublicKey().StringRaw(), test4PublicKey)
	assert.Equal(t, hex.EncodeToString(key4.ed25519PrivateKey.chainCode), test4ChainCode)
}

func TestToStandardED25519PrivateKey2(t *testing.T) {
	test1PrivateKey := "020487611f3167a68482b0f4aacdeb02cc30c52e53852af7b73779f67eeca3c5"
	test1PublicKey := "2d047ff02a2091f860633f849ea2024b23e7803cfd628c9bdd635010cbd782d3"
	test1ChainCode := "48c89d67e9920e443f09d2b14525213ff83b245c8b98d63747ea0801e6d0ff3f"
	test2PrivateKey := "d0c4484480944db698dd51936b7ecc81b0b87e8eafc3d5563c76339338f9611a"
	test2PublicKey := "a1a2573c2c45bd57b0fd054865b5b3d8f492a6e1572bf04b44471e07e2f589b2"
	test2ChainCode := "c0bcdbd9df6d8a4f214f20f3e5c7856415b68be34a1f406398c04690818bea16"
	test3PrivateKey := "d06630d6e4c17942155819bbbe0db8306cd989ba7baf3c29985c8455fbefc37f"
	test3PublicKey := "6bd0a51e0ca6fcc8b13cf25efd0b4814978bcaca7d1cf7dbedf538eb02969acb"
	test3ChainCode := "998a156855ab5398afcde06164b63c5523ff2c8900db53962cc2af191df59e1c"
	test4PrivateKey := "a095ef77ee88da28f373246e9ae143f76e5839f680746c3f921e90bf76c81b08"
	test4PublicKey := "35be6a2a37ff6bbb142e9f4d9b558308f4f75d7c51d5632c6a084257455e1461"
	test4ChainCode := "19d99506a5ce2dc0080092068d278fe29b85ffb8d9c26f8956bfca876307c79c"

	mnemonic, err := MnemonicFromString(mnemonic12WordString)
	require.NoError(t, err)

	// Chain m/44'/3030'/0'/0'/0'
	key1, err := mnemonic.ToStandardEd25519PrivateKey("", 0)
	require.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)
	assert.Equal(t, hex.EncodeToString(key1.ed25519PrivateKey.chainCode), test1ChainCode)

	// Chain m/44'/3030'/0'/0'/2147483647'
	key2, err := mnemonic.ToStandardEd25519PrivateKey("", 2147483647)
	require.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)
	assert.Equal(t, hex.EncodeToString(key2.ed25519PrivateKey.chainCode), test2ChainCode)

	// Chain m/44'/3030'/0'/0'/0'; Passphrase: "some pass"
	key3, err := mnemonic.ToStandardEd25519PrivateKey(passPhrase, 0)
	require.NoError(t, err)

	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)
	assert.Equal(t, hex.EncodeToString(key3.ed25519PrivateKey.chainCode), test3ChainCode)

	// Chain m/44'/3030'/0'/0'/2147483647'; Passphrase: "some pass"
	key4, err := mnemonic.ToStandardEd25519PrivateKey(passPhrase, 2147483647)
	require.NoError(t, err)

	assert.Equal(t, key4.StringRaw(), test4PrivateKey)
	assert.Equal(t, key4.PublicKey().StringRaw(), test4PublicKey)
	assert.Equal(t, hex.EncodeToString(key4.ed25519PrivateKey.chainCode), test4ChainCode)
}

func TestToStandardED25519PrivateKeyShouldFailWhenIndexIsPreHardened(t *testing.T) {
	mnemonic, err := MnemonicFromString(mnemonic24WordString)
	require.NoError(t, err)

	hardenedIndex := ToHardenedIndex(10)

	_, err = mnemonic.ToStandardEd25519PrivateKey("", hardenedIndex)
	assert.Error(t, err)
}

func TestToStandardECDSAsecp256k1PrivateKey(t *testing.T) {
	test1PrivateKey := "0fde7bfd57ae6ec310bdd8b95967d98e8762a2c02da6f694b152cf9860860ab8"
	test1PublicKey := "03b1c064b4d04d52e51f6c8e8bb1bff75d62fa7b1446412d5901d424f6aedd6fd4"
	test1ChainCode := "7717bc71194c257d4b233e16cf48c24adef630052f874a262d19aeb2b527620d"
	test2PrivateKey := "aab7d720a32c2d1ea6123f58b074c865bb07f6c621f14cb012f66c08e64996bb"
	test2PublicKey := "03a0ea31bb3562f8a309b1436bc4b2f537301778e8a5e12b68cec26052f567a235"
	test2ChainCode := "e333da4bd9e21b5dbd2b0f6d88bad02f0fa24cf4b70b2fb613368d0364cdf8af"
	test3PrivateKey := "6df5ed217cf6d5586fdf9c69d39c843eb9d152ca19d3e41f7bab483e62f6ac25"
	test3PublicKey := "0357d69bb36fee569838fe7b325c07ca511e8c1b222873cde93fc6bb541eb7ecea"
	test3ChainCode := "0ff552587f6baef1f0818136bacac0bb37236473f6ecb5a8c1cc68a716726ed1"
	test4PrivateKey := "80df01f79ee1b1f4e9ab80491c592c0ef912194ccca1e58346c3d35cb5b7c098"
	test4PublicKey := "039ebe79f85573baa065af5883d0509a5634245f7864ddead76a008c9e42aa758d"
	test4ChainCode := "3a5048e93aad88f1c42907163ba4dce914d3aaf2eea87b4dd247ca7da7530f0b"
	test5PrivateKey := "60cb2496a623e1201d4e0e7ce5da3833cd4ec7d6c2c06bce2bcbcbc9dfef22d6"
	test5PublicKey := "02b59f348a6b69bd97afa80115e2d5331749b3c89c61297255430c487d6677f404"
	test5ChainCode := "e54254940db58ef4913a377062ac6e411daebf435ad592d262d5a66d808a8b94"
	test6PrivateKey := "100477c333028c8849250035be2a0a166a347a5074a8a727bce1db1c65181a50"
	test6PublicKey := "03d10ebfa2d8ff2cd34aa96e5ef59ca2e69316b4c0996e6d5f54b6932fe51be560"
	test6ChainCode := "cb23165e9d2d798c85effddc901a248a1a273fab2a56fe7976df97b016e7bb77"

	mnemonic, err := MnemonicFromString(mnemonic24WordString)
	require.NoError(t, err)

	// Chain m/44'/3030'/0'/0/0
	key1, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey("", 0)
	require.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)
	assert.Equal(t, hex.EncodeToString(key1.ecdsaPrivateKey.chainCode), test1ChainCode)

	// Chain m/44'/3030'/0'/0/0'
	key2, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey("", ToHardenedIndex(0))
	require.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)
	assert.Equal(t, hex.EncodeToString(key2.ecdsaPrivateKey.chainCode), test2ChainCode)

	// Chain m/44'/3030'/0'/0/0; Passphrase "some pass"
	key3, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey(passPhrase, 0)
	require.NoError(t, err)

	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)
	assert.Equal(t, hex.EncodeToString(key3.ecdsaPrivateKey.chainCode), test3ChainCode)

	// Chain m/44'/3030'/0'/0/0'; Passphrase "some pass"
	key4, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey(passPhrase, ToHardenedIndex(0))
	require.NoError(t, err)

	assert.Equal(t, key4.StringRaw(), test4PrivateKey)
	assert.Equal(t, key4.PublicKey().StringRaw(), test4PublicKey)
	assert.Equal(t, hex.EncodeToString(key4.ecdsaPrivateKey.chainCode), test4ChainCode)

	// Chain m/44'/3030'/0'/0/2147483647; Passphrase "some pass"
	key5, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey(passPhrase, 2147483647)
	require.NoError(t, err)

	assert.Equal(t, key5.StringRaw(), test5PrivateKey)
	assert.Equal(t, key5.PublicKey().StringRaw(), test5PublicKey)
	assert.Equal(t, hex.EncodeToString(key5.ecdsaPrivateKey.chainCode), test5ChainCode)

	// Chain m/44'/3030'/0'/0/2147483647'; Passphrase "some pass"
	key6, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey(passPhrase, ToHardenedIndex(2147483647))
	require.NoError(t, err)

	assert.Equal(t, key6.StringRaw(), test6PrivateKey)
	assert.Equal(t, key6.PublicKey().StringRaw(), test6PublicKey)
	assert.Equal(t, hex.EncodeToString(key6.ecdsaPrivateKey.chainCode), test6ChainCode)
}

func TestToStandardECDSAsecp256k1PrivateKey2(t *testing.T) {
	test1PrivateKey := "f033824c20dd9949ad7a4440f67120ee02a826559ed5884077361d69b2ad51dd"
	test1PublicKey := "0294bf84a54806989a74ca4b76291d386914610b40b610d303162b9e495bc06416"
	test1ChainCode := "e76e0480faf2790e62dc1a7bac9dce51db1b3571fd74d8e264abc0d240a55d09"
	test2PrivateKey := "962f549dafe2d9c8091ac918cb4fc348ab0767353f37501067897efbc84e7651"
	test2PublicKey := "027123855357fd41d28130fbc59053192b771800d28ef47319ef277a1a032af78f"
	test2ChainCode := "60c39c6a77bd68c0aaabfe2f4711dc9c2247214c4f4dae15ad4cb76905f5f544"
	test3PrivateKey := "c139ebb363d7f441ccbdd7f58883809ec0cc3ee7a122ef67974eec8534de65e8"
	test3PublicKey := "0293bdb1507a26542ed9c1ec42afe959cf8b34f39daab4bf842cdac5fa36d50ef7"
	test3ChainCode := "911a1095b64b01f7f3a06198df3d618654e5ed65862b211997c67515e3167892"
	test4PrivateKey := "87c1d8d4bb0cebb4e230852f2a6d16f6847881294b14eb1d6058b729604afea0"
	test4PublicKey := "03358e7761a422ca1c577f145fe845c77563f164b2c93b5b34516a8fa13c2c0888"
	test4ChainCode := "64173f2dcb1d65e15e787ef882fa15f54db00209e2dab16fa1661244cd98e95c"
	test5PrivateKey := "2583170ee745191d2bb83474b1de41a1621c47f6e23db3f2bf413a1acb5709e4"
	test5PublicKey := "03f9eb27cc73f751e8e476dd1db79037a7df2c749fa75b6cc6951031370d2f95a5"
	test5ChainCode := "a7250c2b07b368a054f5c91e6a3dbe6ca3bbe01eb0489fe8778304bd0a19c711"
	test6PrivateKey := "f2d008cd7349bdab19ed85b523ba218048f35ca141a3ecbc66377ad50819e961"
	test6PublicKey := "027b653d04958d4bf83dd913a9379b4f9a1a1e64025a691830a67383bc3157c044"
	test6ChainCode := "66a1175e7690e3714d53ffce16ee6bb4eb02065516be2c2ad6bf6c9df81ec394"

	mnemonic, err := MnemonicFromString(mnemonic12WordString)
	require.NoError(t, err)

	// Chain m/44'/3030'/0'/0/0
	key1, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey("", 0)
	require.NoError(t, err)

	assert.Equal(t, key1.StringRaw(), test1PrivateKey)
	assert.Equal(t, key1.PublicKey().StringRaw(), test1PublicKey)
	assert.Equal(t, hex.EncodeToString(key1.ecdsaPrivateKey.chainCode), test1ChainCode)

	// Chain m/44'/3030'/0'/0/0'
	key2, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey("", ToHardenedIndex(0))
	require.NoError(t, err)

	assert.Equal(t, key2.StringRaw(), test2PrivateKey)
	assert.Equal(t, key2.PublicKey().StringRaw(), test2PublicKey)
	assert.Equal(t, hex.EncodeToString(key2.ecdsaPrivateKey.chainCode), test2ChainCode)

	// Chain m/44'/3030'/0'/0/0; Passphrase "some pass"
	key3, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey(passPhrase, 0)
	require.NoError(t, err)

	assert.Equal(t, key3.StringRaw(), test3PrivateKey)
	assert.Equal(t, key3.PublicKey().StringRaw(), test3PublicKey)
	assert.Equal(t, hex.EncodeToString(key3.ecdsaPrivateKey.chainCode), test3ChainCode)

	// Chain m/44'/3030'/0'/0/0'; Passphrase "some pass"
	key4, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey(passPhrase, ToHardenedIndex(0))
	require.NoError(t, err)

	assert.Equal(t, key4.StringRaw(), test4PrivateKey)
	assert.Equal(t, key4.PublicKey().StringRaw(), test4PublicKey)
	assert.Equal(t, hex.EncodeToString(key4.ecdsaPrivateKey.chainCode), test4ChainCode)

	// Chain m/44'/3030'/0'/0/2147483647; Passphrase "some pass"
	key5, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey(passPhrase, 2147483647)
	require.NoError(t, err)

	assert.Equal(t, key5.StringRaw(), test5PrivateKey)
	assert.Equal(t, key5.PublicKey().StringRaw(), test5PublicKey)
	assert.Equal(t, hex.EncodeToString(key5.ecdsaPrivateKey.chainCode), test5ChainCode)

	// Chain m/44'/3030'/0'/0/2147483647'; Passphrase "some pass"
	key6, err := mnemonic.ToStandardECDSAsecp256k1PrivateKey(passPhrase, ToHardenedIndex(2147483647))
	require.NoError(t, err)

	assert.Equal(t, key6.StringRaw(), test6PrivateKey)
	assert.Equal(t, key6.PublicKey().StringRaw(), test6PublicKey)
	assert.Equal(t, hex.EncodeToString(key6.ecdsaPrivateKey.chainCode), test6ChainCode)
}

func TestToStandardECDSAsecp256k1PrivateKeyCustomDPath(t *testing.T) {
	const (
		DPATH_1       = "m/44'/60'/0'/0/0"
		PASSPHRASE_1  = ""
		CHAIN_CODE_1  = "58a9ee31eaf7499abc01952b44dbf0a2a5d6447512367f09d99381c9605bf9e8"
		PRIVATE_KEY_1 = "78f9545e40025cf7da9126a4d6a861ae34031d1c74c3404df06110c9fde371ad"
		PUBLIC_KEY_1  = "02a8f4c22eea66617d4f119e3a951b93f584949bbfee90bd555305402da6c4e569"
		DPATH_2       = "m/44'/60'/0'/0/1"
		PASSPHRASE_2  = ""
		CHAIN_CODE_2  = "6dcfc7a4914bd0e75b94a2f38afee8c247b34810202a2c64fe599ee1b88afdc9"
		PRIVATE_KEY_2 = "77ca263661ebdd5a8b33c224aeff5e7bf67eedacee68a1699d97ee8929d7b130"
		PUBLIC_KEY_2  = "03e84c9be9be53ad722038cc1943e79df27e5c1d31088adb4f0e62444f4dece683"
		DPATH_3       = "m/44'/60'/0'/0/2"
		PASSPHRASE_3  = ""
		CHAIN_CODE_3  = "c8c798d2b3696be1e7a29d1cea205507eedc2057006b9ef1cde1b4e346089e17"
		PRIVATE_KEY_3 = "31c24292eac951279b659c335e44a2e812d0f1a228b1d4d87034874d376e605a"
		PUBLIC_KEY_3  = "0207ff3faf4055c1aa7a5ad94d6ff561fac35b9ae695ef486706243667d2b4d10e"
	)

	mnemonic, err := MnemonicFromString(mnemonic24WordString)
	require.NoError(t, err)

	// m/44'/60'/0'/0/0
	key1, err := mnemonic.ToStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(PASSPHRASE_1, DPATH_1)
	require.NoError(t, err)
	assert.Equal(t, hex.EncodeToString(key1.ecdsaPrivateKey.chainCode), CHAIN_CODE_1)
	assert.Equal(t, key1.StringRaw(), PRIVATE_KEY_1)
	assert.Contains(t, key1.PublicKey().StringRaw(), PUBLIC_KEY_1)

	// m/44'/60'/0'/0/1
	key2, err := mnemonic.ToStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(PASSPHRASE_2, DPATH_2)
	require.NoError(t, err)
	assert.Equal(t, hex.EncodeToString(key2.ecdsaPrivateKey.chainCode), CHAIN_CODE_2)
	assert.Equal(t, key2.StringRaw(), PRIVATE_KEY_2)
	assert.Contains(t, key2.PublicKey().StringRaw(), PUBLIC_KEY_2)

	// m/44'/60'/0'/0/2
	key3, err := mnemonic.ToStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(PASSPHRASE_3, DPATH_3)
	require.NoError(t, err)
	assert.Equal(t, hex.EncodeToString(key3.ecdsaPrivateKey.chainCode), CHAIN_CODE_3)
	assert.Equal(t, key3.StringRaw(), PRIVATE_KEY_3)
	assert.Contains(t, key3.PublicKey().StringRaw(), PUBLIC_KEY_3)
}
// Filename: mock_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"context"
	"net"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/mirror"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/stretchr/testify/require"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/grpc"
)

func TestUnitMockQuery(t *testing.T) {
	t.Parallel()
	responses := [][]interface{}{
		{
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY, ResponseType: services.ResponseType_ANSWER_ONLY},
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY, ResponseType: services.ResponseType_ANSWER_ONLY},
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY, ResponseType: services.ResponseType_ANSWER_ONLY},
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY, ResponseType: services.ResponseType_ANSWER_ONLY},
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY, ResponseType: services.ResponseType_ANSWER_ONLY},
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY, ResponseType: services.ResponseType_ANSWER_ONLY},
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY, ResponseType: services.ResponseType_ANSWER_ONLY},
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 0},
						AccountID: &services.AccountID{ShardNum: 0, RealmNum: 0, Account: &services.AccountID_AccountNum{
							AccountNum: 1800,
						}},
						Balance: 2000,
					},
				},
			},
			&services.Response{
				Response: &services.Response_CryptogetAccountBalance{
					CryptogetAccountBalance: &services.CryptoGetAccountBalanceResponse{
						Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 0},
						AccountID: &services.AccountID{ShardNum: 0, RealmNum: 0, Account: &services.AccountID_AccountNum{
							AccountNum: 1800,
						}},
						Balance: 2000,
					},
				},
			},
		},
	}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewAccountBalanceQuery().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAccountID(AccountID{Account: 1800}).
		Execute(client)
	require.NoError(t, err)
}

func DisabledTestUnitMockBackoff(t *testing.T) {
	responses := [][]interface{}{{
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
	}, {
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	tran := TransactionIDGenerate(AccountID{Account: 3})

	_, err = NewAccountCreateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}, {Account: 4}}).
		SetKey(newKey).
		SetTransactionID(tran).
		SetInitialBalance(newBalance).
		SetMaxAutomaticTokenAssociations(100).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitMockAddressBookQuery(t *testing.T) {
	t.Parallel()
	responses := [][]interface{}{{
		&services.NodeAddress{
			RSA_PubKey: "",
			NodeId:     0,
			NodeAccountId: &services.AccountID{
				ShardNum: 0,
				RealmNum: 0,
				Account:  &services.AccountID_AccountNum{AccountNum: 3},
			},
			NodeCertHash: []byte{1},
			ServiceEndpoint: []*services.ServiceEndpoint{
				{
					IpAddressV4: []byte{byte(uint(1)), byte(uint(2)), byte(uint(2)), byte(uint(3))},
					Port:        50123,
					DomainName:  "hedera.domain.name",
				},
				{
					IpAddressV4: []byte{byte(uint(2)), byte(uint(1)), byte(uint(2)), byte(uint(3))},
					Port:        50123,
					DomainName:  "hedera.domain.name",
				},
			},
			Description: "",
			Stake:       0,
		},
		&services.NodeAddress{
			RSA_PubKey: "",
			NodeId:     0,
			NodeAccountId: &services.AccountID{
				ShardNum: 0,
				RealmNum: 0,
				Account:  &services.AccountID_AccountNum{AccountNum: 4},
			},
			NodeCertHash: []byte{1},
			ServiceEndpoint: []*services.ServiceEndpoint{
				{
					IpAddressV4: []byte{byte(uint(1)), byte(uint(2)), byte(uint(2)), byte(uint(9))},
					Port:        50123,
					DomainName:  "hedera.domain.name2",
				},
				{
					IpAddressV4: []byte{byte(uint(2)), byte(uint(1)), byte(uint(2)), byte(uint(9))},
					Port:        50123,
					DomainName:  "hedera.domain.name2",
				},
			},
			Description: "",
			Stake:       0,
		},
	},
	}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	result, err := NewAddressBookQuery().
		SetFileID(FileID{0, 0, 101, nil}).
		Execute(client)
	require.NoError(t, err)

	require.Equal(t, len(result.NodeAddresses), 2)
	require.Equal(t, result.NodeAddresses[0].AccountID.String(), "0.0.3")
	require.Equal(t, result.NodeAddresses[0].Addresses[0].String(), "hedera.domain.name:50123")
	require.Equal(t, result.NodeAddresses[0].Addresses[1].String(), "hedera.domain.name:50123")
	require.Equal(t, result.NodeAddresses[1].AccountID.String(), "0.0.4")
	require.Equal(t, result.NodeAddresses[1].Addresses[0].String(), "hedera.domain.name2:50123")
	require.Equal(t, result.NodeAddresses[1].Addresses[1].String(), "hedera.domain.name2:50123")
}

func TestUnitMockGenerateTransactionIDsPerExecution(t *testing.T) {
	t.Parallel()
	count := 0
	transactionIds := make(map[string]bool)

	call := func(request *services.Transaction) *services.TransactionResponse {
		var response *services.TransactionResponse
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)
		if count < 2 {
			require.False(t, transactionIds[transactionId])
		}
		transactionIds[transactionId] = true

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)
		require.NotEqual(t, 0, len(sigMap.SigPair))

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if count < 2 {
			response = &services.TransactionResponse{
				NodeTransactionPrecheckCode: services.ResponseCodeEnum_TRANSACTION_EXPIRED,
			}
		} else {
			response = &services.TransactionResponse{
				NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
			}
		}

		count += 1

		return response
	}
	responses := [][]interface{}{{
		call, call, call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewFileCreateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetContents([]byte("hello")).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitMockSingleTransactionIDForExecutions(t *testing.T) {
	t.Parallel()
	count := 0
	tran := TransactionIDGenerate(AccountID{Account: 1800})
	transactionIds := make(map[string]bool)
	transactionIds[tran._ToProtobuf().String()] = true

	call := func(request *services.Transaction) *services.TransactionResponse {
		var response *services.TransactionResponse

		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)
		require.True(t, transactionIds[transactionId])
		transactionIds[transactionId] = true

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)
		require.NotEqual(t, 0, len(sigMap.SigPair))

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if count < 2 {
			response = &services.TransactionResponse{
				NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
			}
		} else {
			response = &services.TransactionResponse{
				NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
			}
		}

		count += 1

		return response
	}
	responses := [][]interface{}{{
		call, call, call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewFileCreateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTransactionID(tran).
		SetContents([]byte("hello")).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitMockSingleTransactionIDForExecutionsWithTimeout(t *testing.T) {
	t.Parallel()
	count := 0
	tran := TransactionIDGenerate(AccountID{Account: 1800})
	transactionIds := make(map[string]bool)
	transactionIds[tran._ToProtobuf().String()] = true

	call := func(request *services.Transaction) *services.TransactionResponse {
		var response *services.TransactionResponse

		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)
		require.True(t, transactionIds[transactionId])
		transactionIds[transactionId] = true

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)
		require.NotEqual(t, 0, len(sigMap.SigPair))

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		if count < 2 {
			response = &services.TransactionResponse{
				NodeTransactionPrecheckCode: services.ResponseCodeEnum_TRANSACTION_EXPIRED,
			}
		} else {
			response = &services.TransactionResponse{
				NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
			}
		}

		count += 1

		return response
	}
	responses := [][]interface{}{{
		call, call, call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewFileCreateTransaction().
		SetTransactionID(tran).
		SetContents([]byte("hello")).
		Execute(client)
	require.Error(t, err)
}

type MockServers struct {
	servers []*MockServer
}

func (servers *MockServers) Close() {
	for _, server := range servers.servers {
		if server != nil {
			server.Close()
		}
	}
}

func NewMockClientAndServer(allNodeResponses [][]interface{}) (*Client, *MockServers) {
	network := map[string]AccountID{}
	mirrorNetwork := make([]string, len(allNodeResponses))
	servers := make([]*MockServer, len(allNodeResponses))
	ctx, cancel := context.WithCancel(context.Background())

	logger := NewLogger("hedera client mock", LoggerLevelError)
	var defaultLogger Logger = logger

	client := &Client{
		defaultMaxQueryPayment:          NewHbar(1),
		network:                         _NewNetwork(),
		mirrorNetwork:                   _NewMirrorNetwork(),
		autoValidateChecksums:           false,
		maxAttempts:                     nil,
		minBackoff:                      250 * time.Millisecond,
		maxBackoff:                      8 * time.Second,
		defaultRegenerateTransactionIDs: true,
		defaultNetworkUpdatePeriod:      24 * time.Hour,
		networkUpdateContext:            ctx,
		cancelNetworkUpdate:             cancel,
		logger:                          defaultLogger,
	}

	for i, responses := range allNodeResponses {
		responses := responses

		serverReady := make(chan bool)
		nodeAccountID := AccountID{Account: uint64(3 + i)}
		go func() {
			servers[i] = NewMockServer(responses)
			serverReady <- true
		}()

		<-serverReady

		network[servers[i].listener.Addr().String()] = nodeAccountID
		mirrorNetwork[i] = servers[i].listener.Addr().String()
	}

	client.SetNetwork(network)
	client.SetLedgerID(*NewLedgerIDMainnet())
	client.SetMirrorNetwork(mirrorNetwork)

	key, _ := PrivateKeyFromStringEd25519("302e020100300506032b657004220420d45e1557156908c967804615af59a000be88c7aa7058bfcbe0f46b16c28f887d")
	client.SetOperator(AccountID{Account: 1800}, key)
	client.SetMinBackoff(0)
	client.SetMaxBackoff(0)
	client.SetMinNodeReadmitTime(0)
	client.SetMaxNodeReadmitTime(0)
	client.SetNodeMinBackoff(0)
	client.SetNodeMaxBackoff(0)

	return client, &MockServers{servers}
}

func TestUnitMockAccountInfoQuery(t *testing.T) {
	t.Skip("Skipping test as it is currently broken with the addition of generating new payment transactions for queries")
	call := func(request *services.Query) *services.Response {
		require.NotNil(t, request.Query)
		accountInfoQuery := request.Query.(*services.Query_CryptoGetInfo).CryptoGetInfo

		require.Equal(t, accountInfoQuery.AccountID.String(), AccountID{Account: 5}._ToProtobuf().String())

		var payment services.TransactionBody
		require.NotEmpty(t, accountInfoQuery.Header.Payment.BodyBytes)
		err := protobuf.Unmarshal(accountInfoQuery.Header.Payment.BodyBytes, &payment)
		require.NoError(t, err)

		require.NotNil(t, payment.TransactionID)
		require.Equal(t, payment.TransactionID.AccountID.String(), AccountID{Account: 1800}._ToProtobuf().String())
		require.NotNil(t, payment.NodeAccountID)
		require.Equal(t, payment.NodeAccountID.String(), AccountID{Account: 3}._ToProtobuf().String())

		require.Equal(t, payment.Data, &services.TransactionBody_CryptoTransfer{
			CryptoTransfer: &services.CryptoTransferTransactionBody{
				Transfers: &services.TransferList{
					AccountAmounts: []*services.AccountAmount{
						{
							AccountID: AccountID{Account: 3}._ToProtobuf(),
							Amount:    HbarFromTinybar(35).AsTinybar(),
						},
						{
							AccountID: AccountID{Account: 1800}._ToProtobuf(),
							Amount:    -HbarFromTinybar(35).AsTinybar(),
						},
					},
				},
			},
		})

		key, _ := PrivateKeyFromStringEd25519(mockPrivateKey)

		return &services.Response{
			Response: &services.Response_CryptoGetInfo{
				CryptoGetInfo: &services.CryptoGetInfoResponse{
					Header: &services.ResponseHeader{
						NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
						ResponseType:                services.ResponseType_ANSWER_ONLY,
						Cost:                        35,
					},
					AccountInfo: &services.CryptoGetInfoResponse_AccountInfo{
						AccountID:         &services.AccountID{Account: &services.AccountID_AccountNum{5}},
						ContractAccountID: "",
						Deleted:           false,
						ProxyAccountID:    &services.AccountID{Account: &services.AccountID_AccountNum{5}},
						ProxyReceived:     0,
						Key:               key._ToProtoKey(),
						Balance:           0,
					},
				},
			},
		}
	}

	costCall := func(request *services.Query) *services.Response {
		require.NotNil(t, request.Query)
		accountInfoQuery := request.Query.(*services.Query_CryptoGetInfo).CryptoGetInfo

		require.Equal(t, accountInfoQuery.Header.ResponseType, services.ResponseType_COST_ANSWER)

		require.Equal(t, accountInfoQuery.AccountID.String(), AccountID{Account: 5}._ToProtobuf().String())

		var payment services.TransactionBody
		require.NotEmpty(t, accountInfoQuery.Header.Payment.BodyBytes)
		err := protobuf.Unmarshal(accountInfoQuery.Header.Payment.BodyBytes, &payment)
		require.NoError(t, err)

		return &services.Response{
			Response: &services.Response_CryptoGetInfo{
				CryptoGetInfo: &services.CryptoGetInfoResponse{
					Header: &services.ResponseHeader{
						NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
						ResponseType:                services.ResponseType_COST_ANSWER,
						Cost:                        35,
					},
				},
			},
		}
	}

	responses := [][]interface{}{{
		costCall, call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewAccountInfoQuery().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAccountID(AccountID{Account: 5}).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitMockAccountInfoQueryNoNodeSet(t *testing.T) {
	t.Skip("Skipping test as it is currently broken with the addition of generating new payment transactions for queries")
	call := func(request *services.Query) *services.Response {
		require.NotNil(t, request.Query)
		accountInfoQuery := request.Query.(*services.Query_CryptoGetInfo).CryptoGetInfo

		require.Equal(t, accountInfoQuery.AccountID.String(), AccountID{Account: 5}._ToProtobuf().String())

		var payment services.TransactionBody
		require.NotEmpty(t, accountInfoQuery.Header.Payment.BodyBytes)
		err := protobuf.Unmarshal(accountInfoQuery.Header.Payment.BodyBytes, &payment)
		require.NoError(t, err)

		require.NotNil(t, payment.TransactionID)
		require.Equal(t, payment.TransactionID.AccountID.String(), AccountID{Account: 1800}._ToProtobuf().String())
		require.NotNil(t, payment.NodeAccountID)
		require.Equal(t, payment.NodeAccountID.String(), AccountID{Account: 3}._ToProtobuf().String())

		require.Equal(t, payment.Data, &services.TransactionBody_CryptoTransfer{
			CryptoTransfer: &services.CryptoTransferTransactionBody{
				Transfers: &services.TransferList{
					AccountAmounts: []*services.AccountAmount{
						{
							AccountID: AccountID{Account: 3}._ToProtobuf(),
							Amount:    HbarFromTinybar(35).AsTinybar(),
						},
						{
							AccountID: AccountID{Account: 1800}._ToProtobuf(),
							Amount:    -HbarFromTinybar(35).AsTinybar(),
						},
					},
				},
			},
		})

		key, _ := PrivateKeyFromStringEd25519(mockPrivateKey)

		return &services.Response{
			Response: &services.Response_CryptoGetInfo{
				CryptoGetInfo: &services.CryptoGetInfoResponse{
					Header: &services.ResponseHeader{
						NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
						ResponseType:                services.ResponseType_ANSWER_ONLY,
						Cost:                        35,
					},
					AccountInfo: &services.CryptoGetInfoResponse_AccountInfo{
						AccountID:         &services.AccountID{Account: &services.AccountID_AccountNum{5}},
						ContractAccountID: "",
						Deleted:           false,
						ProxyAccountID:    &services.AccountID{Account: &services.AccountID_AccountNum{5}},
						ProxyReceived:     0,
						Key:               key._ToProtoKey(),
						Balance:           0,
					},
				},
			},
		}
	}

	costCall := func(request *services.Query) *services.Response {
		require.NotNil(t, request.Query)
		accountInfoQuery := request.Query.(*services.Query_CryptoGetInfo).CryptoGetInfo

		require.Equal(t, accountInfoQuery.Header.ResponseType, services.ResponseType_COST_ANSWER)

		require.Equal(t, accountInfoQuery.AccountID.String(), AccountID{Account: 5}._ToProtobuf().String())

		var payment services.TransactionBody
		require.NotEmpty(t, accountInfoQuery.Header.Payment.BodyBytes)
		err := protobuf.Unmarshal(accountInfoQuery.Header.Payment.BodyBytes, &payment)
		require.NoError(t, err)

		return &services.Response{
			Response: &services.Response_CryptoGetInfo{
				CryptoGetInfo: &services.CryptoGetInfoResponse{
					Header: &services.ResponseHeader{
						NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
						ResponseType:                services.ResponseType_COST_ANSWER,
						Cost:                        35,
					},
				},
			},
		}
	}

	responses := [][]interface{}{{
		costCall, call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewAccountInfoQuery().
		SetAccountID(AccountID{Account: 5}).
		Execute(client)
	require.NoError(t, err)
}

func NewMockHandler(responses []interface{}) func(interface{}, context.Context, func(interface{}) error, grpc.UnaryServerInterceptor) (interface{}, error) {
	index := 0
	return func(_srv interface{}, _ctx context.Context, dec func(interface{}) error, _interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
		if index >= len(responses) {
			return nil, status.New(codes.Aborted, "No response found").Err()
		}
		response := responses[index]
		index = index + 1

		switch response := response.(type) {
		case error:
			return nil, response
		case *services.TransactionResponse:
			return response, nil
		case *services.Response:
			return response, nil
		case *services.NodeAddress:
			return response, nil
		case func(request *services.Transaction) *services.TransactionResponse:
			request := new(services.Transaction)
			if err := dec(request); err != nil {
				return nil, err
			}
			return response(request), nil
		case func(request *services.Query) *services.Response:
			request := new(services.Query)
			if err := dec(request); err != nil {
				return nil, err
			}
			return response(request), nil
		case func(request *services.Query) *services.NodeAddress:
			request := new(services.Query)
			if err := dec(request); err != nil {
				return nil, err
			}
			return response(request), nil
		default:
			return response, nil
		}
	}
}

func NewMockStreamHandler(responses []interface{}) func(interface{}, grpc.ServerStream) error {
	return func(_ interface{}, stream grpc.ServerStream) error {
		for _, resp := range responses {
			err := stream.SendMsg(resp)
			if err != nil {
				return err
			}
		}

		return nil
	}
}

type MockServer struct {
	listener net.Listener
	server   *grpc.Server
}

func NewMockServer(responses []interface{}) (server *MockServer) {
	var err error
	server = &MockServer{
		server: grpc.NewServer(),
	}
	handler := NewMockHandler(responses)
	streamHandler := NewMockStreamHandler(responses)

	server.server.RegisterService(NewServiceDescription(handler, &services.CryptoService_ServiceDesc), nil)
	server.server.RegisterService(NewServiceDescription(handler, &services.FileService_ServiceDesc), nil)
	server.server.RegisterService(NewServiceDescription(handler, &services.SmartContractService_ServiceDesc), nil)
	server.server.RegisterService(NewServiceDescription(handler, &services.ConsensusService_ServiceDesc), nil)
	server.server.RegisterService(NewServiceDescription(handler, &services.TokenService_ServiceDesc), nil)
	server.server.RegisterService(NewServiceDescription(handler, &services.ScheduleService_ServiceDesc), nil)
	server.server.RegisterService(NewServiceDescription(handler, &services.FreezeService_ServiceDesc), nil)
	server.server.RegisterService(NewServiceDescription(handler, &services.NetworkService_ServiceDesc), nil)
	server.server.RegisterService(NewServiceDescription(handler, &services.AddressBookService_ServiceDesc), nil)
	server.server.RegisterService(NewMirrorServiceDescription(streamHandler, &mirror.NetworkService_ServiceDesc), nil)

	server.listener, err = net.Listen("tcp", "localhost:0")
	if err != nil {
		panic(err)
	}

	go func() {
		if err = server.server.Serve(server.listener); err != nil {
			panic(err)
		}
	}()

	return server
}

func (server *MockServer) Close() {
	if server.server != nil {
		server.server.GracefulStop()
	}
}

func NewServiceDescription(handler func(interface{}, context.Context, func(interface{}) error, grpc.UnaryServerInterceptor) (interface{}, error), service *grpc.ServiceDesc) *grpc.ServiceDesc {
	var methods []grpc.MethodDesc
	for _, desc := range service.Methods {
		methods = append(methods, grpc.MethodDesc{
			MethodName: desc.MethodName,
			Handler:    handler,
		})
	}

	return &grpc.ServiceDesc{
		ServiceName: service.ServiceName,
		HandlerType: service.HandlerType,
		Methods:     methods,
		Streams:     []grpc.StreamDesc{},
		Metadata:    service.Metadata,
	}
}

func NewMirrorServiceDescription(handler func(interface{}, grpc.ServerStream) error, service *grpc.ServiceDesc) *grpc.ServiceDesc {
	var streams []grpc.StreamDesc
	for _, stream := range service.Streams {
		streams = append(streams, grpc.StreamDesc{
			StreamName:    stream.StreamName,
			Handler:       handler,
			ServerStreams: stream.ServerStreams,
			ClientStreams: stream.ClientStreams,
		})
	}

	return &grpc.ServiceDesc{
		ServiceName: service.ServiceName,
		HandlerType: service.HandlerType,
		Methods:     []grpc.MethodDesc{},
		Streams:     streams,
		Metadata:    service.Metadata,
	}
}
// Filename: multi_app_transfer_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestIntegrationMultiAppTransfer(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	txID := TransactionIDGenerate(env.OperatorID)

	transaction, err := NewTransferTransaction().
		SetTransactionID(txID).
		AddHbarTransfer(env.OperatorID, NewHbar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, NewHbar(1)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	txBytes, err := transaction.ToBytes()
	require.NoError(t, err)
	signedTxBytes, err := signingService(txBytes, env.OperatorKey)
	require.NoError(t, err)

	var signedTx TransferTransaction
	tx, err := TransactionFromBytes(signedTxBytes)
	require.NoError(t, err)

	switch t := tx.(type) {
	case TransferTransaction:
		signedTx = t
	default:
		panic("Did not receive `TransferTransaction` back from signed bytes")
	}

	response, err := signedTx.Execute(env.Client)
	require.NoError(t, err)

	_, err = response.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func signingService(txBytes []byte, key PrivateKey) ([]byte, error) {
	var unsignedTx TransferTransaction
	tx, err := TransactionFromBytes(txBytes)
	if err != nil {
		return txBytes, err
	}

	switch t := tx.(type) {
	case TransferTransaction:
		unsignedTx = t
	default:
		panic("Did not receive `TransferTransaction` back from signed bytes")
	}

	return unsignedTx.
		Sign(key).
		ToBytes()
}
// Filename: network.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"math/rand"
	"time"
)

type _Network struct {
	_ManagedNetwork
	addressBook map[AccountID]NodeAddress
}

func _NewNetwork() _Network {
	return _Network{
		_ManagedNetwork: _NewManagedNetwork(),
		addressBook:     nil,
	}
}

// SetNetwork sets the network to the given map of node addresses.
func (network *_Network) SetNetwork(net map[string]AccountID) (err error) {
	newNetwork := make(map[string]_IManagedNode)

	for url, id := range net {
		node, err := _NewNode(id, url, network.minBackoff)
		if err != nil {
			return err
		}
		newNetwork[url] = node
	}

	return network._ManagedNetwork._SetNetwork(newNetwork)
}

func (network *_Network) _GetNetwork() map[string]AccountID {
	temp := make(map[string]AccountID)
	for _, node := range network._ManagedNetwork.nodes {
		switch n := node.(type) { //nolint
		case *_Node:
			temp[n._GetAddress()] = n.accountID
		}
	}

	return temp
}

func (network *_Network) _IncreaseBackoff(node *_Node) {
	network.healthyNodesMutex.Lock()
	defer network.healthyNodesMutex.Unlock()
	node._IncreaseBackoff()

	index := -1
	for i, healthyNode := range network.healthyNodes {
		if node == healthyNode {
			index = i
			break
		}
	}

	if index >= 0 && index < len(network.healthyNodes) {
		network.healthyNodes = append(network.healthyNodes[:index], network.healthyNodes[index+1:]...)
	}
}

func (network *_Network) _GetNodeForAccountID(id AccountID) (*_Node, bool) {
	node, ok := network.network[id.String()]
	if !ok || node == nil {
		return nil, false
	}
	return node[0].(*_Node), ok
}

func (network *_Network) _GetNode() *_Node {
	return network._ManagedNetwork._GetNode().(*_Node)
}

func (network *_Network) _GetLedgerID() *LedgerID {
	if network._ManagedNetwork._GetLedgerID() != nil {
		return network._ManagedNetwork._GetLedgerID()
	}

	return &LedgerID{}
}

func (network *_Network) _SetLedgerID(id LedgerID) {
	network._ManagedNetwork._SetLedgerID(id)

	if network._ManagedNetwork.transportSecurity && network.ledgerID != nil {
		switch {
		case id.IsMainnet():
			network.addressBook = mainnetAddressBook._ToMap()
		case id.IsTestnet():
			network.addressBook = testnetAddressBook._ToMap()
		case id.IsPreviewnet():
			network.addressBook = previewnetAddressBook._ToMap()
		}

		if network.addressBook != nil {
			for _, node := range network._ManagedNetwork.nodes {
				if node, ok := node.(*_Node); ok {
					temp := network.addressBook[node.accountID]
					node.addressBook = &temp
				}
			}
			for _, nodes := range network._ManagedNetwork.network {
				for _, node := range nodes {
					if node, ok := node.(*_Node); ok {
						temp := network.addressBook[node.accountID]
						node.addressBook = &temp
					}
				}
			}
		}
	}
}

func (network *_Network) _GetNodeAccountIDsForExecute() []AccountID { //nolint
	nodes := make([]AccountID, 0)
	nodesForTransaction := network._GetNumberOfNodesForTransaction()

	network.healthyNodesMutex.RLock()
	defer network.healthyNodesMutex.RUnlock()

	healthyNodes := make([]_IManagedNode, len(network.healthyNodes))
	copy(healthyNodes, network.healthyNodes)

	// shuffle the nodes, so that the first node is not always the same
	for i := range healthyNodes {
		j := rand.Intn(i + 1) // #nosec
		healthyNodes[i], healthyNodes[j] = healthyNodes[j], healthyNodes[i]
	}
	for i := 0; i < nodesForTransaction; i++ {
		nodes = append(nodes, healthyNodes[i].(*_Node).accountID)
	}
	return nodes
}

func (network *_Network) _SetMaxNodesPerTransaction(max int) {
	network._ManagedNetwork._SetMaxNodesPerTransaction(max)
}

func (network *_Network) _SetMaxNodeAttempts(max int) {
	network._ManagedNetwork._SetMaxNodeAttempts(max)
}

func (network *_Network) _GetMaxNodeAttempts() int {
	return network._ManagedNetwork._GetMaxNodeAttempts()
}

func (network *_Network) _SetNodeMinBackoff(backoff time.Duration) {
	network._ManagedNetwork._SetMinBackoff(backoff)
}

func (network *_Network) _SetNodeMaxBackoff(backoff time.Duration) {
	network._ManagedNetwork._SetMaxBackoff(backoff)
}

func (network *_Network) _GetNodeMinBackoff() time.Duration {
	return network._ManagedNetwork._GetMinBackoff()
}

func (network *_Network) _GetNodeMaxBackoff() time.Duration {
	return network._ManagedNetwork._GetMaxBackoff()
}

func (network *_Network) _SetTransportSecurity(transportSecurity bool) *_Network {
	_ = network._ManagedNetwork._SetTransportSecurity(transportSecurity)
	return network
}

func (network *_Network) _SetVerifyCertificate(verify bool) *_ManagedNetwork {
	return network._ManagedNetwork._SetVerifyCertificate(verify)
}

func (network *_Network) _GetVerifyCertificate() bool {
	return network._ManagedNetwork._GetVerifyCertificate()
}

func (network *_Network) _SetNodeMinReadmitPeriod(period time.Duration) {
	network._ManagedNetwork._SetMinNodeReadmitPeriod(period)
}

func (network *_Network) _SetNodeMaxReadmitPeriod(period time.Duration) {
	network._ManagedNetwork._SetMaxNodeReadmitPeriod(period)
}

func (network *_Network) _GetNodeMinReadmitPeriod() time.Duration {
	return network._ManagedNetwork.minNodeReadmitPeriod
}

func (network *_Network) _GetNodeMaxReadmitPeriod() time.Duration {
	return network._ManagedNetwork.maxNodeReadmitPeriod
}

// Close closes the network.
func (network *_Network) Close() error {
	err := network._ManagedNetwork._Close()
	if err != nil {
		return err
	}

	return nil
}

func _NetworkForMainnet(nodeAddresses map[AccountID]NodeAddress) *_Network {
	network := _NewNetwork()
	network.addressBook = nodeAddresses
	network._SetLedgerID(*NewLedgerIDMainnet())
	_ = network.SetNetwork(network._ToNet())
	return &network
}

func _NetworkForTestnet(nodeAddresses map[AccountID]NodeAddress) *_Network {
	network := _NewNetwork()
	network.addressBook = nodeAddresses
	network._SetLedgerID(*NewLedgerIDTestnet())
	_ = network.SetNetwork(network._ToNet())
	return &network
}

func _NetworkForPreviewnet(nodeAddresses map[AccountID]NodeAddress) *_Network {
	network := _NewNetwork()
	network.addressBook = nodeAddresses
	network._SetLedgerID(*NewLedgerIDPreviewnet())
	_ = network.SetNetwork(network._ToNet())
	return &network
}

func (network *_Network) _SetNetworkFromAddressBook(addressBook NodeAddressBook) {
	network.addressBook = addressBook._ToMap()
	_ = network.SetNetwork(network._ToNet())
}

func (network *_Network) _ToNet() map[string]AccountID {
	newNetwork := make(map[string]AccountID)
	for accountID, node := range network.addressBook {
		for _, address := range node.Addresses {
			newNetwork[address.String()] = accountID
		}
	}
	return newNetwork
}
// Filename: network_e2e_test.go
//go:build all || testnets
// +build all testnets

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"os"
	"regexp"
	"testing"
	"time"

	"github.com/rs/zerolog"
	"github.com/stretchr/testify/require"
)

func TestIntegrationNodeForTransaction(t *testing.T) {
	t.Parallel()

	client := ClientForTestnet()
	operatorID, err := AccountIDFromString(os.Getenv("OPERATOR_ID"))
	require.NoError(t, err)
	operatorKey, err := PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	require.NoError(t, err)
	client.SetOperator(operatorID, operatorKey)

	var buf bytes.Buffer
	writer := zerolog.ConsoleWriter{Out: &buf, TimeFormat: time.RFC3339}
	zerolog.SetGlobalLevel(zerolog.TraceLevel)

	l := NewLogger("test", LoggerLevelTrace)
	l.SetLevel(LoggerLevelTrace)

	logger := zerolog.New(&writer)
	l.logger = &logger
	client.SetLogger(l)
	ledger, _ := LedgerIDFromNetworkName(NetworkNameTestnet)
	client.SetTransportSecurity(true)
	client.SetLedgerID(*ledger)
	client.SetMaxAttempts(3)
	nodeAccountIDs := map[string]struct{}{}
	for i := 0; i < 5; i++ {
		_, err := NewTransferTransaction().AddHbarTransfer(operatorID, HbarFromTinybar(-1)).
			AddHbarTransfer(AccountID{Shard: 0, Realm: 0, Account: 3}, HbarFromTinybar(1)).Execute(client)
		require.NoError(t, err)
		logOutput := buf.String()
		sanitizedLogOutput := regexp.MustCompile(`\x1b\[[0-9;]*m`).ReplaceAllString(logOutput, "")
		re := regexp.MustCompile(`nodeAccountID=([\d.]+)`)
		matches := re.FindStringSubmatch(sanitizedLogOutput)
		if len(matches) > 1 {
			nodeAccountID := matches[1]
			nodeAccountIDs[nodeAccountID] = struct{}{}
		}
		buf.Reset()
	}
	require.True(t, len(nodeAccountIDs) > 1, "Expected multiple different node account IDs")
}

func TestIntegrationNodeForQuery(t *testing.T) {
	t.Parallel()

	client := ClientForTestnet()
	operatorID, err := AccountIDFromString(os.Getenv("OPERATOR_ID"))
	require.NoError(t, err)
	operatorKey, err := PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	require.NoError(t, err)
	client.SetOperator(operatorID, operatorKey)

	var buf bytes.Buffer
	writer := zerolog.ConsoleWriter{Out: &buf, TimeFormat: time.RFC3339}
	zerolog.SetGlobalLevel(zerolog.TraceLevel)

	l := NewLogger("test", LoggerLevelTrace)
	l.SetLevel(LoggerLevelTrace)

	logger := zerolog.New(&writer)
	l.logger = &logger
	client.SetLogger(l)
	ledger, _ := LedgerIDFromNetworkName(NetworkNameTestnet)
	client.SetTransportSecurity(true)
	client.SetLedgerID(*ledger)
	client.SetMaxAttempts(3)
	nodeAccountIDs := map[string]struct{}{}
	for i := 0; i < 5; i++ {
		_, err := NewAccountBalanceQuery().
			SetAccountID(AccountID{Account: 3}).
			Execute(client)
		require.NoError(t, err)
		logOutput := buf.String()
		sanitizedLogOutput := regexp.MustCompile(`\x1b\[[0-9;]*m`).ReplaceAllString(logOutput, "")
		re := regexp.MustCompile(`nodeAccountID=([\d.]+)`)
		matches := re.FindStringSubmatch(sanitizedLogOutput)
		if len(matches) > 1 {
			nodeAccountID := matches[1]
			nodeAccountIDs[nodeAccountID] = struct{}{}
		}
		buf.Reset()
	}
	require.True(t, len(nodeAccountIDs) > 1, "Expected multiple different node account IDs")
}

func TestIntegrationNodeForTransactionSourceListUnchanged(t *testing.T) {
	t.Parallel()

	client := ClientForTestnet()
	operatorID, err := AccountIDFromString(os.Getenv("OPERATOR_ID"))
	require.NoError(t, err)
	operatorKey, err := PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	require.NoError(t, err)
	client.SetOperator(operatorID, operatorKey)

	var buf bytes.Buffer
	writer := zerolog.ConsoleWriter{Out: &buf, TimeFormat: time.RFC3339}
	zerolog.SetGlobalLevel(zerolog.TraceLevel)

	l := NewLogger("test", LoggerLevelTrace)
	l.SetLevel(LoggerLevelTrace)

	logger := zerolog.New(&writer)
	l.logger = &logger
	client.SetLogger(l)
	ledger, _ := LedgerIDFromNetworkName(NetworkNameTestnet)
	client.SetTransportSecurity(true)
	client.SetLedgerID(*ledger)
	client.SetMaxAttempts(3)

	_, err = NewAccountBalanceQuery().
		SetAccountID(AccountID{Account: 3}).
		Execute(client)
	expectedHealthyNodes := make([]_IManagedNode, len(client.network.healthyNodes))
	copy(expectedHealthyNodes, client.network.healthyNodes)
	resultHealthyNodes := make([]_IManagedNode, len(client.network.healthyNodes))
	_, err = NewAccountBalanceQuery().
		SetAccountID(AccountID{Account: 3}).
		Execute(client)
	copy(resultHealthyNodes, client.network.healthyNodes)
	require.Equal(t, expectedHealthyNodes, resultHealthyNodes)
}

func TestIntegrationNodeForQuerySourceListUnchanged(t *testing.T) {
	t.Parallel()

	client := ClientForTestnet()
	operatorID, err := AccountIDFromString(os.Getenv("OPERATOR_ID"))
	require.NoError(t, err)
	operatorKey, err := PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	require.NoError(t, err)
	client.SetOperator(operatorID, operatorKey)

	var buf bytes.Buffer
	writer := zerolog.ConsoleWriter{Out: &buf, TimeFormat: time.RFC3339}
	zerolog.SetGlobalLevel(zerolog.TraceLevel)

	l := NewLogger("test", LoggerLevelTrace)
	l.SetLevel(LoggerLevelTrace)

	logger := zerolog.New(&writer)
	l.logger = &logger
	client.SetLogger(l)
	ledger, _ := LedgerIDFromNetworkName(NetworkNameTestnet)
	client.SetTransportSecurity(true)
	client.SetLedgerID(*ledger)
	client.SetMaxAttempts(3)

	_, err = NewAccountBalanceQuery().
		SetAccountID(AccountID{Account: 3}).
		Execute(client)
	expectedHealthyNodes := make([]_IManagedNode, len(client.network.healthyNodes))
	copy(expectedHealthyNodes, client.network.healthyNodes)
	resultHealthyNodes := make([]_IManagedNode, len(client.network.healthyNodes))
	_, err = NewAccountBalanceQuery().
		SetAccountID(AccountID{Account: 3}).
		Execute(client)
	copy(resultHealthyNodes, client.network.healthyNodes)
	require.Equal(t, expectedHealthyNodes, resultHealthyNodes)
}
// Filename: network_name.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

type NetworkName string

const (
	NetworkNameMainnet    NetworkName = "mainnet"
	NetworkNameTestnet    NetworkName = "testnet"
	NetworkNamePreviewnet NetworkName = "previewnet"
	NetworkNameOther      NetworkName = "other"
)

// Deprecated
func (networkName NetworkName) String() string { //nolint
	switch networkName {
	case NetworkNameMainnet:
		return "mainnet"
	case NetworkNameTestnet:
		return "testnet"
	case NetworkNamePreviewnet:
		return "previewnet"
	case NetworkNameOther:
		return "other"
	}

	panic("unreachable: NetworkName.String() switch statement is non-exhaustive.")
}

// Deprecated
func NetworkNameFromString(s string) NetworkName { //nolint
	switch s {
	case "mainnet":
		return NetworkNameMainnet
	case "testnet":
		return NetworkNameTestnet
	case "previewnet":
		return NetworkNamePreviewnet
	case "other":
		return NetworkNameOther
	}

	panic("unreachable: NetworkName.String() switch statement is non-exhaustive.")
}
// Filename: network_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"sync"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func newNetworkMockNodes() map[string]AccountID {
	nodes := make(map[string]AccountID, 2)
	nodes["0.testnet.hedera.com:50211"] = AccountID{0, 0, 3, nil, nil, nil}
	nodes["1.testnet.hedera.com:50211"] = AccountID{0, 0, 4, nil, nil, nil}
	nodes["2.testnet.hedera.com:50211"] = AccountID{0, 0, 5, nil, nil, nil}
	nodes["3.testnet.hedera.com:50211"] = AccountID{0, 0, 6, nil, nil, nil}
	nodes["4.testnet.hedera.com:50211"] = AccountID{0, 0, 7, nil, nil, nil}
	return nodes
}

func TestUnitNetworkAddressBookGetsSet(t *testing.T) {
	t.Parallel()

	network := _NewNetwork()
	network._SetTransportSecurity(true)

	ledgerID, err := LedgerIDFromString("mainnet")
	require.NoError(t, err)

	network._SetLedgerID(*ledgerID)
	require.NoError(t, err)

	require.True(t, network.addressBook != nil)
}

func TestUnitNetworkIncreaseBackoffConcurrent(t *testing.T) {
	t.Parallel()

	network := _NewNetwork()
	nodes := newNetworkMockNodes()
	err := network.SetNetwork(nodes)
	require.NoError(t, err)

	node := network._GetNode()
	require.NotNil(t, node)

	numThreads := 20
	var wg sync.WaitGroup
	wg.Add(numThreads)
	for i := 0; i < numThreads; i++ {
		go func() {
			network._IncreaseBackoff(node)
			wg.Done()
		}()
	}
	wg.Wait()

	require.Equal(t, len(nodes)-1, len(network.healthyNodes))
}

func TestUnitConcurrentGetNodeReadmit(t *testing.T) {
	t.Parallel()

	network := _NewNetwork()
	nodes := newNetworkMockNodes()
	err := network.SetNetwork(nodes)
	network._SetMinNodeReadmitPeriod(0)
	network._SetMaxNodeReadmitPeriod(0)
	require.NoError(t, err)

	for _, node := range network.nodes {
		node._SetMaxBackoff(-1 * time.Minute)
	}

	numThreads := 3
	var wg sync.WaitGroup
	wg.Add(numThreads)
	for i := 0; i < numThreads; i++ {
		go func() {
			for i := 0; i < 20; i++ {
				node := network._GetNode()
				network._IncreaseBackoff(node)
			}
			wg.Done()
		}()
	}
	wg.Wait()
	network._ReadmitNodes()
	require.Equal(t, len(nodes), len(network.healthyNodes))
}

func TestUnitConcurrentNodeAccess(t *testing.T) {
	t.Parallel()

	network := _NewNetwork()
	nodes := newNetworkMockNodes()
	err := network.SetNetwork(nodes)
	network._SetMinNodeReadmitPeriod(0)
	network._SetMaxNodeReadmitPeriod(0)
	require.NoError(t, err)

	for _, node := range network.nodes {
		node._SetMaxBackoff(-1 * time.Minute)
	}

	numThreads := 3
	var wg sync.WaitGroup
	node := network._GetNode()
	wg.Add(numThreads)
	for i := 0; i < numThreads; i++ {
		go func() {
			for i := 0; i < 20; i++ {
				network._GetNode()
				network._IncreaseBackoff(node)
				node._IsHealthy()
				node._GetAttempts()
				node._GetReadmitTime()
				node._Wait()
				node._InUse()
			}
			wg.Done()
		}()
	}
	wg.Wait()
	network._ReadmitNodes()
	require.Equal(t, len(nodes), len(network.healthyNodes))
}

func TestUnitConcurrentNodeGetChannel(t *testing.T) {
	t.Parallel()

	network := _NewNetwork()
	nodes := newNetworkMockNodes()
	err := network.SetNetwork(nodes)
	require.NoError(t, err)

	numThreads := 20
	var wg sync.WaitGroup
	node := network._GetNode()
	wg.Add(numThreads)
	logger := NewLogger("", LoggerLevelError)
	for i := 0; i < numThreads; i++ {
		go func() {
			node._GetChannel(logger)
			wg.Done()
		}()
	}
	wg.Wait()
	network._ReadmitNodes()
	require.Equal(t, len(nodes), len(network.healthyNodes))
}
// Filename: network_version_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// NetworkVersionInfo is the version info for the Hedera network protobuf and services
type NetworkVersionInfo struct {
	ProtobufVersion SemanticVersion
	ServicesVersion SemanticVersion
}

func _NetworkVersionInfoFromProtobuf(version *services.NetworkGetVersionInfoResponse) NetworkVersionInfo {
	if version == nil {
		return NetworkVersionInfo{}
	}
	return NetworkVersionInfo{
		ProtobufVersion: _SemanticVersionFromProtobuf(version.HapiProtoVersion),
		ServicesVersion: _SemanticVersionFromProtobuf(version.HederaServicesVersion),
	}
}

func (version *NetworkVersionInfo) _ToProtobuf() *services.NetworkGetVersionInfoResponse {
	return &services.NetworkGetVersionInfoResponse{
		HapiProtoVersion:      version.ProtobufVersion._ToProtobuf(),
		HederaServicesVersion: version.ServicesVersion._ToProtobuf(),
	}
}

// ToBytes returns the byte representation of the NetworkVersionInfo
func (version *NetworkVersionInfo) ToBytes() []byte {
	data, err := protobuf.Marshal(version._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// NetworkVersionInfoFromBytes returns the NetworkVersionInfo from a raw byte array
func NetworkVersionInfoFromBytes(data []byte) (NetworkVersionInfo, error) {
	if data == nil {
		return NetworkVersionInfo{}, errByteArrayNull
	}
	pb := services.NetworkGetVersionInfoResponse{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return NetworkVersionInfo{}, err
	}

	info := _NetworkVersionInfoFromProtobuf(&pb)

	return info, nil
}
// Filename: network_version_info_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// NetworkVersionInfoQuery is the query to be executed that would return the current version of the network's protobuf and services.
type NetworkVersionInfoQuery struct {
	Query
}

// NewNetworkVersionQuery creates a NetworkVersionInfoQuery builder which can be used to construct and execute a
// Network Get Version Info Query containing the current version of the network's protobuf and services.
func NewNetworkVersionQuery() *NetworkVersionInfoQuery {
	header := services.QueryHeader{}
	return &NetworkVersionInfoQuery{
		Query: _NewQuery(true, &header),
	}
}

// SetGrpcDeadline When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *NetworkVersionInfoQuery) SetGrpcDeadline(deadline *time.Duration) *NetworkVersionInfoQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

func (q *NetworkVersionInfoQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *NetworkVersionInfoQuery) Execute(client *Client) (NetworkVersionInfo, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return NetworkVersionInfo{}, err
	}

	return _NetworkVersionInfoFromProtobuf(resp.GetNetworkGetVersionInfo()), err
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *NetworkVersionInfoQuery) SetMaxQueryPayment(maxPayment Hbar) *NetworkVersionInfoQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *NetworkVersionInfoQuery) SetQueryPayment(paymentAmount Hbar) *NetworkVersionInfoQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this NetworkVersionInfoQuery.
func (q *NetworkVersionInfoQuery) SetNodeAccountIDs(accountID []AccountID) *NetworkVersionInfoQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *NetworkVersionInfoQuery) SetMaxRetry(count int) *NetworkVersionInfoQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *NetworkVersionInfoQuery) SetMaxBackoff(max time.Duration) *NetworkVersionInfoQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *NetworkVersionInfoQuery) SetMinBackoff(min time.Duration) *NetworkVersionInfoQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *NetworkVersionInfoQuery) SetPaymentTransactionID(transactionID TransactionID) *NetworkVersionInfoQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *NetworkVersionInfoQuery) SetLogLevel(level LogLevel) *NetworkVersionInfoQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *NetworkVersionInfoQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetNetwork().GetVersionInfo,
	}
}

func (q *NetworkVersionInfoQuery) getName() string {
	return "NetworkVersionInfoQuery"
}

func (q *NetworkVersionInfoQuery) buildQuery() *services.Query {
	pb := services.Query_NetworkGetVersionInfo{
		NetworkGetVersionInfo: &services.NetworkGetVersionInfoQuery{
			Header: q.pbHeader,
		},
	}

	return &services.Query{
		Query: &pb,
	}
}

func (q *NetworkVersionInfoQuery) validateNetworkOnIDs(*Client) error {
	return nil
}

func (q *NetworkVersionInfoQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetNetworkGetVersionInfo()
}
// Filename: network_version_info_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestIntegrationNetworkVersionInfoQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewNetworkVersionQuery().
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationNetworkVersionInfoQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	query := NewNetworkVersionQuery().SetNodeAccountIDs(env.NodeAccountIDs)

	cost, err := query.GetCost(env.Client)
	require.NoError(t, err)

	_, err = query.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: nework_version_info_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
)

func TestUnitNetworkVersionInfoQuerySetNothing(t *testing.T) {
	t.Parallel()

	query := NewNetworkVersionQuery()

	require.Equal(t, []AccountID{}, query.GetNodeAccountIDs())
	require.Equal(t, 250*time.Millisecond, query.GetMinBackoff())
	require.Equal(t, 8*time.Second, query.GetMaxBackoff())
	require.Equal(t, 10, query.GetMaxRetryCount())
	require.Equal(t, TransactionID{}, query.GetPaymentTransactionID())
	require.Equal(t, Hbar{}, query.GetQueryPayment())
	require.Equal(t, Hbar{}, query.GetMaxQueryPayment())
}

func TestNetworkVersionInfoQuery_Get(t *testing.T) {
	t.Parallel()

	deadline := time.Duration(time.Minute)
	transactionID := TransactionIDGenerate(AccountID{Account: 324})
	query := NewNetworkVersionQuery().
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(10)).
		SetNodeAccountIDs([]AccountID{{Account: 3}, {Account: 4}}).
		SetMaxRetry(5).
		SetMaxBackoff(10 * time.Second).
		SetMinBackoff(1 * time.Second).
		SetPaymentTransactionID(transactionID).
		SetGrpcDeadline(&deadline)

	require.Equal(t, NewHbar(2), query.GetQueryPayment())
	require.Equal(t, NewHbar(10), query.GetMaxQueryPayment())
	require.Equal(t, []AccountID{{Account: 3}, {Account: 4}}, query.GetNodeAccountIDs())
	require.Equal(t, 5, query.GetMaxRetryCount())
	require.Equal(t, 10*time.Second, query.GetMaxBackoff())
	require.Equal(t, 1*time.Second, query.GetMinBackoff())
	require.Equal(t, transactionID, query.GetPaymentTransactionID())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}

func TestUnitNetworkVersionInfoQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_NetworkGetVersionInfo{
				NetworkGetVersionInfo: &services.NetworkGetVersionInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewNetworkVersionQuery().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMaxQueryPayment(NewHbar(1))

	cost, err := query.GetCost(client)
	require.NoError(t, err)
	require.Equal(t, HbarFromTinybar(2), cost)
}
// Filename: nft_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// NftID is the ID for a non-fungible token
type NftID struct {
	TokenID      TokenID
	SerialNumber int64
}

// NewNftID constructs a new NftID from a TokenID and a serial number
func NftIDFromString(s string) (NftID, error) {
	split := strings.Split(s, "@")
	if len(split) < 2 {
		panic(errors.New("wrong NftID format"))
	}
	shard, realm, num, checksum, err := _IdFromString(split[1])
	if err != nil {
		return NftID{}, err
	}

	serial, err := strconv.Atoi(split[0])
	if err != nil {
		return NftID{}, err
	}

	return NftID{
		TokenID: TokenID{
			Shard:    uint64(shard),
			Realm:    uint64(realm),
			Token:    uint64(num),
			checksum: checksum,
		},
		SerialNumber: int64(serial),
	}, nil
}

// Validate checks that the NftID is valid
func (id *NftID) Validate(client *Client) error {
	if !id._IsZero() && client != nil && client.network.ledgerID != nil {
		if err := id.TokenID.ValidateChecksum(client); err != nil {
			return err
		}

		return nil
	}

	return nil
}

// String returns a string representation of the NftID
func (id NftID) String() string {
	return fmt.Sprintf("%d@%s", id.SerialNumber, id.TokenID.String())
}

// ToStringWithChecksum returns a string representation of the NftID with a checksum
func (id NftID) ToStringWithChecksum(client Client) (string, error) {
	token, err := id.TokenID.ToStringWithChecksum(client)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%d@%s", id.SerialNumber, token), nil
}

func (id NftID) _ToProtobuf() *services.NftID {
	return &services.NftID{
		Token_ID:     id.TokenID._ToProtobuf(),
		SerialNumber: id.SerialNumber,
	}
}

func _NftIDFromProtobuf(pb *services.NftID) NftID {
	if pb == nil {
		return NftID{}
	}

	tokenID := TokenID{}
	if pb.Token_ID != nil {
		tokenID = *_TokenIDFromProtobuf(pb.Token_ID)
	}

	return NftID{
		TokenID:      tokenID,
		SerialNumber: pb.SerialNumber,
	}
}

func (id NftID) _IsZero() bool {
	return id.TokenID._IsZero() && id.SerialNumber == 0
}

// ToBytes returns the byte representation of the NftID
func (id NftID) ToBytes() []byte {
	data, err := protobuf.Marshal(id._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// NftIDFromBytes returns the NftID from a raw byte array
func NftIDFromBytes(data []byte) (NftID, error) {
	pb := services.NftID{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return NftID{}, err
	}

	return _NftIDFromProtobuf(&pb), nil
}
// Filename: node.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"crypto/sha512"
	"crypto/tls"
	"crypto/x509"
	"encoding/hex"
	"encoding/pem"
	"sync"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/keepalive"
	"google.golang.org/grpc/status"
)

// _Node represents a node on the network
type _Node struct {
	*_ManagedNode
	accountID         AccountID
	channel           *_Channel
	addressBook       *NodeAddress
	verifyCertificate bool
	channelMutex      sync.Mutex
}

func _NewNode(accountID AccountID, address string, minBackoff time.Duration) (node *_Node, err error) {
	node = &_Node{
		accountID:         accountID,
		verifyCertificate: true,
	}
	node._ManagedNode, err = _NewManagedNode(address, minBackoff)
	return node, err
}

func (node *_Node) _GetKey() string {
	return node.accountID.String()
}

func (node *_Node) _SetMinBackoff(waitTime time.Duration) {
	node._ManagedNode._SetMinBackoff(waitTime)
}

func (node *_Node) _GetMinBackoff() time.Duration {
	return node._ManagedNode._GetMinBackoff()
}

func (node *_Node) _SetMaxBackoff(waitTime time.Duration) {
	node._ManagedNode._SetMaxBackoff(waitTime)
}

func (node *_Node) _GetMaxBackoff() time.Duration {
	return node._ManagedNode._GetMaxBackoff()
}

func (node *_Node) _InUse() {
	node._ManagedNode._InUse()
}

func (node *_Node) _IsHealthy() bool {
	return node._ManagedNode._IsHealthy()
}

func (node *_Node) _IncreaseBackoff() {
	node._ManagedNode._IncreaseBackoff()
}

func (node *_Node) _DecreaseBackoff() {
	node._ManagedNode._DecreaseBackoff()
}

func (node *_Node) _Wait() time.Duration {
	return node._ManagedNode._Wait()
}

func (node *_Node) _GetUseCount() int64 {
	return node._ManagedNode._GetUseCount()
}

func (node *_Node) _GetLastUsed() time.Time {
	return node._ManagedNode._GetLastUsed()
}

func (node *_Node) _GetManagedNode() *_ManagedNode {
	return node._ManagedNode
}

func (node *_Node) _GetAttempts() int64 {
	return node._ManagedNode._GetAttempts()
}

func (node *_Node) _GetAddress() string {
	return node._ManagedNode._GetAddress()
}

func (node *_Node) _GetReadmitTime() *time.Time {
	return node._ManagedNode._GetReadmitTime()
}

func (node *_Node) _GetChannel(logger Logger) (*_Channel, error) {
	node.channelMutex.Lock()
	defer node.channelMutex.Unlock()

	if node.channel != nil {
		return node.channel, nil
	}

	var kacp = keepalive.ClientParameters{
		Time:                10 * time.Second,
		Timeout:             2 * time.Second,
		PermitWithoutStream: true,
	}

	var conn *grpc.ClientConn
	var err error
	security := grpc.WithInsecure() //nolint
	if !node.verifyCertificate {
		println("skipping certificate check")
	}
	if node._ManagedNode.address._IsTransportSecurity() {
		security = grpc.WithTransportCredentials(credentials.NewTLS(&tls.Config{
			InsecureSkipVerify: true, // nolint
			VerifyPeerCertificate: func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error {
				if node.addressBook == nil {
					logger.Warn("skipping certificate check since no cert hash was found")
					return nil
				}

				if !node.verifyCertificate {
					return nil
				}

				for _, cert := range rawCerts {
					var certHash []byte

					block := &pem.Block{
						Type:  "CERTIFICATE",
						Bytes: cert,
					}

					var encodedBuf bytes.Buffer
					_ = pem.Encode(&encodedBuf, block)
					digest := sha512.New384()

					if _, err = digest.Write(encodedBuf.Bytes()); err != nil {
						return err
					}

					certHash = digest.Sum(nil)

					if string(node.addressBook.CertHash) == hex.EncodeToString(certHash) {
						return nil
					}
				}

				return x509.CertificateInvalidError{
					Cert:   nil,
					Reason: x509.Expired,
					Detail: "",
				}
			},
		}))
	}

	conn, err = grpc.NewClient(node._ManagedNode.address._String(), security, grpc.WithKeepaliveParams(kacp))
	if err != nil {
		return nil, status.Error(codes.ResourceExhausted, "dial timeout of 10sec exceeded")
	}

	ch := _NewChannel(conn)
	node.channel = &ch

	return node.channel, nil
}

func (node *_Node) _Close() error {
	node.channelMutex.Lock()
	defer node.channelMutex.Unlock()

	if node.channel != nil {
		err := node.channel.client.Close()
		node.channel = nil
		return err
	}

	return nil
}

func (node *_Node) _ToSecure() _IManagedNode {
	managed := _ManagedNode{
		address:            node.address._ToSecure(),
		currentBackoff:     node.currentBackoff,
		lastUsed:           node.lastUsed,
		readmitTime:        node.readmitTime,
		useCount:           node.useCount,
		minBackoff:         node.minBackoff,
		badGrpcStatusCount: node.badGrpcStatusCount,
	}

	return &_Node{
		_ManagedNode:      &managed,
		accountID:         node.accountID,
		channel:           node.channel,
		addressBook:       node.addressBook,
		verifyCertificate: node.verifyCertificate,
	}
}

func (node *_Node) _ToInsecure() _IManagedNode {
	managed := _ManagedNode{
		address:            node.address._ToInsecure(),
		currentBackoff:     node.currentBackoff,
		lastUsed:           node.lastUsed,
		readmitTime:        node.readmitTime,
		useCount:           node.useCount,
		minBackoff:         node.minBackoff,
		badGrpcStatusCount: node.badGrpcStatusCount,
	}

	return &_Node{
		_ManagedNode:      &managed,
		accountID:         node.accountID,
		channel:           node.channel,
		addressBook:       node.addressBook,
		verifyCertificate: node.verifyCertificate,
	}
}

func (node *_Node) _SetVerifyCertificate(verify bool) {
	node.verifyCertificate = verify
}

func (node *_Node) _GetVerifyCertificate() bool {
	return node.verifyCertificate
}
// Filename: node_address.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

// NodeAddress is the address of a node on the Hedera network
type NodeAddress struct {
	PublicKey   string
	AccountID   *AccountID
	NodeID      int64
	CertHash    []byte
	Addresses   []Endpoint
	Description string
}

func _NodeAddressFromProtobuf(nodeAd *services.NodeAddress) NodeAddress {
	address := make([]Endpoint, 0)

	for _, end := range nodeAd.GetServiceEndpoint() {
		address = append(address, EndpointFromProtobuf(end))
	}

	return NodeAddress{
		PublicKey:   nodeAd.GetRSA_PubKey(),
		AccountID:   _AccountIDFromProtobuf(nodeAd.GetNodeAccountId()),
		NodeID:      nodeAd.GetNodeId(),
		CertHash:    nodeAd.GetNodeCertHash(),
		Addresses:   address,
		Description: nodeAd.GetDescription(),
	}
}

func (nodeAdd *NodeAddress) _ToProtobuf() *services.NodeAddress {
	build := &services.NodeAddress{
		RSA_PubKey:      nodeAdd.PublicKey,
		NodeId:          nodeAdd.NodeID,
		NodeAccountId:   nil,
		NodeCertHash:    nodeAdd.CertHash,
		ServiceEndpoint: nil,
		Description:     nodeAdd.Description,
	}

	if nodeAdd.AccountID != nil {
		build.NodeAccountId = nodeAdd.AccountID._ToProtobuf()
	}

	serviceEndpoint := make([]*services.ServiceEndpoint, 0)
	for _, k := range nodeAdd.Addresses {
		serviceEndpoint = append(serviceEndpoint, k._ToProtobuf())
	}
	build.ServiceEndpoint = serviceEndpoint

	return build
}

// String returns a string representation of the NodeAddress
func (nodeAdd NodeAddress) String() string {
	Addresses := ""
	for _, k := range nodeAdd.Addresses {
		Addresses += k.String()
	}
	return nodeAdd.AccountID.String() + " " + Addresses + "\n" + "CertHash " + string(nodeAdd.CertHash)
}
// Filename: node_address_book.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// NodeAddressBook is the address book for the nodes on the Hedera network
type NodeAddressBook struct {
	NodeAddresses []NodeAddress
}

func _NodeAddressBookFromProtobuf(book *services.NodeAddressBook) NodeAddressBook {
	addresses := make([]NodeAddress, 0)

	for _, k := range book.NodeAddress {
		addresses = append(addresses, _NodeAddressFromProtobuf(k))
	}

	return NodeAddressBook{
		NodeAddresses: addresses,
	}
}

func (book NodeAddressBook) _ToProtobuf() *services.NodeAddressBook {
	addresses := make([]*services.NodeAddress, 0)

	for _, k := range book.NodeAddresses {
		addresses = append(addresses, k._ToProtobuf())
	}

	return &services.NodeAddressBook{
		NodeAddress: addresses,
	}
}

// ToBytes returns the byte representation of the NodeAddressBook
func (book NodeAddressBook) ToBytes() []byte {
	data, err := protobuf.Marshal(book._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

func (book NodeAddressBook) _ToMap() (result map[AccountID]NodeAddress) {
	result = map[AccountID]NodeAddress{}

	for _, node := range book.NodeAddresses {
		if node.AccountID == nil {
			continue
		}

		result[*node.AccountID] = node
	}

	return result
}

// NodeAddressBookFromBytes returns the NodeAddressBook from a raw byte array
func NodeAddressBookFromBytes(data []byte) (NodeAddressBook, error) {
	if data == nil {
		return NodeAddressBook{}, errByteArrayNull
	}
	pb := services.NodeAddressBook{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return NodeAddressBook{}, err
	}

	derivedBytes := _NodeAddressBookFromProtobuf(&pb)

	return derivedBytes, nil
}
// Filename: node_create_transaction.go
package hedera

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/**
 * A transaction to create a new node in the network address book.
 * The transaction, once complete, enables a new consensus node
 * to join the network, and requires governing council authorization.
 * <p>
 * This transaction body SHALL be considered a "privileged transaction".
 * <p>
 *
 * - MUST be signed by the governing council.
 * - MUST be signed by the `Key` assigned to the
 *   `admin_key` field.
 * - The newly created node information SHALL be added to the network address
 *   book information in the network state.
 * - The new entry SHALL be created in "state" but SHALL NOT participate in
 *   network consensus and SHALL NOT be present in network "configuration"
 *   until the next "upgrade" transaction (as noted below).
 * - All new address book entries SHALL be added to the active network
 *   configuration during the next `freeze` transaction with the field
 *   `freeze_type` set to `PREPARE_UPGRADE`.
 *
 * ### Record Stream Effects
 * Upon completion the newly assigned `node_id` SHALL be in the transaction
 * receipt.
 */
type NodeCreateTransaction struct {
	Transaction
	accountID           *AccountID
	description         string
	gossipEndpoints     []Endpoint
	serviceEndpoints    []Endpoint
	gossipCaCertificate []byte
	grpcCertificateHash []byte
	adminKey            Key
}

func NewNodeCreateTransaction() *NodeCreateTransaction {
	tx := &NodeCreateTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return tx
}

func _NodeCreateTransactionFromProtobuf(transaction Transaction, pb *services.TransactionBody) *NodeCreateTransaction {
	adminKey, err := _KeyFromProtobuf(pb.GetNodeCreate().GetAdminKey())
	if err != nil {
		return &NodeCreateTransaction{}
	}

	accountID := _AccountIDFromProtobuf(pb.GetNodeCreate().GetAccountId())
	gossipEndpoints := make([]Endpoint, 0)
	for _, endpoint := range pb.GetNodeCreate().GetGossipEndpoint() {
		gossipEndpoints = append(gossipEndpoints, EndpointFromProtobuf(endpoint))
	}
	serviceEndpoints := make([]Endpoint, 0)
	for _, endpoint := range pb.GetNodeCreate().GetServiceEndpoint() {
		serviceEndpoints = append(serviceEndpoints, EndpointFromProtobuf(endpoint))
	}

	return &NodeCreateTransaction{
		Transaction:         transaction,
		accountID:           accountID,
		description:         pb.GetNodeCreate().GetDescription(),
		gossipEndpoints:     gossipEndpoints,
		serviceEndpoints:    serviceEndpoints,
		gossipCaCertificate: pb.GetNodeCreate().GetGossipCaCertificate(),
		grpcCertificateHash: pb.GetNodeCreate().GetGrpcCertificateHash(),
		adminKey:            adminKey,
	}
}

// GetAccountID AccountID of the node
func (tx *NodeCreateTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// SetAccountID get the AccountID of the node
func (tx *NodeCreateTransaction) SetAccountID(accountID AccountID) *NodeCreateTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetDescription get the description of the node
func (tx *NodeCreateTransaction) GetDescription() string {
	return tx.description
}

// SetDescription set the description of the node
func (tx *NodeCreateTransaction) SetDescription(description string) *NodeCreateTransaction {
	tx._RequireNotFrozen()
	tx.description = description
	return tx
}

// GetServiceEndpoints the list of service endpoints for gossip.
func (tx *NodeCreateTransaction) GetGossipEndpoints() []Endpoint {
	return tx.gossipEndpoints
}

// SetServiceEndpoints the list of service endpoints for gossip.
func (tx *NodeCreateTransaction) SetGossipEndpoints(gossipEndpoints []Endpoint) *NodeCreateTransaction {
	tx._RequireNotFrozen()
	tx.gossipEndpoints = gossipEndpoints
	return tx
}

// AddGossipEndpoint add an endpoint for gossip to the list of service endpoints for gossip.
func (tx *NodeCreateTransaction) AddGossipEndpoint(endpoint Endpoint) *NodeCreateTransaction {
	tx._RequireNotFrozen()
	tx.gossipEndpoints = append(tx.gossipEndpoints, endpoint)
	return tx
}

// GetServiceEndpoints the list of service endpoints for gRPC calls.
func (tx *NodeCreateTransaction) GetServiceEndpoints() []Endpoint {
	return tx.serviceEndpoints
}

// SetServiceEndpoints the list of service endpoints for gRPC calls.
func (tx *NodeCreateTransaction) SetServiceEndpoints(serviceEndpoints []Endpoint) *NodeCreateTransaction {
	tx._RequireNotFrozen()
	tx.serviceEndpoints = serviceEndpoints
	return tx
}

// AddServiceEndpoint the list of service endpoints for gRPC calls.
func (tx *NodeCreateTransaction) AddServiceEndpoint(endpoint Endpoint) *NodeCreateTransaction {
	tx._RequireNotFrozen()
	tx.serviceEndpoints = append(tx.serviceEndpoints, endpoint)
	return tx
}

// GetGossipCaCertificate the certificate used to sign gossip events.
func (tx *NodeCreateTransaction) GetGossipCaCertificate() []byte {
	return tx.gossipCaCertificate
}

// SetGossipCaCertificate the certificate used to sign gossip events.
// This value MUST be the DER encoding of the certificate presented.
func (tx *NodeCreateTransaction) SetGossipCaCertificate(gossipCaCertificate []byte) *NodeCreateTransaction {
	tx._RequireNotFrozen()
	tx.gossipCaCertificate = gossipCaCertificate
	return tx
}

// GetGrpcCertificateHash the hash of the node gRPC TLS certificate.
func (tx *NodeCreateTransaction) GetGrpcCertificateHash() []byte {
	return tx.grpcCertificateHash
}

// SetGrpcCertificateHash the hash of the node gRPC TLS certificate.
// This value MUST be a SHA-384 hash.
func (tx *NodeCreateTransaction) SetGrpcCertificateHash(grpcCertificateHash []byte) *NodeCreateTransaction {
	tx._RequireNotFrozen()
	tx.grpcCertificateHash = grpcCertificateHash
	return tx
}

// GetAdminKey an administrative key controlled by the node operator.
func (tx *NodeCreateTransaction) GetAdminKey() Key {
	return tx.adminKey
}

// SetAdminKey an administrative key controlled by the node operator.
func (tx *NodeCreateTransaction) SetAdminKey(adminKey Key) *NodeCreateTransaction {
	tx._RequireNotFrozen()
	tx.adminKey = adminKey
	return tx
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *NodeCreateTransaction) Sign(privateKey PrivateKey) *NodeCreateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *NodeCreateTransaction) SignWithOperator(client *Client) (*NodeCreateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *NodeCreateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *NodeCreateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *NodeCreateTransaction) AddSignature(publicKey PublicKey, signature []byte) *NodeCreateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *NodeCreateTransaction) SetGrpcDeadline(deadline *time.Duration) *NodeCreateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *NodeCreateTransaction) Freeze() (*NodeCreateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *NodeCreateTransaction) FreezeWith(client *Client) (*NodeCreateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this NodeCreateTransaction.
func (tx *NodeCreateTransaction) SetMaxTransactionFee(fee Hbar) *NodeCreateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *NodeCreateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *NodeCreateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this NodeCreateTransaction.
func (tx *NodeCreateTransaction) SetTransactionMemo(memo string) *NodeCreateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this NodeCreateTransaction.
func (tx *NodeCreateTransaction) SetTransactionValidDuration(duration time.Duration) *NodeCreateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *NodeCreateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this NodeCreateTransaction.
func (tx *NodeCreateTransaction) SetTransactionID(transactionID TransactionID) *NodeCreateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this NodeCreateTransaction.
func (tx *NodeCreateTransaction) SetNodeAccountIDs(nodeID []AccountID) *NodeCreateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *NodeCreateTransaction) SetMaxRetry(count int) *NodeCreateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *NodeCreateTransaction) SetMaxBackoff(max time.Duration) *NodeCreateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *NodeCreateTransaction) SetMinBackoff(min time.Duration) *NodeCreateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *NodeCreateTransaction) SetLogLevel(level LogLevel) *NodeCreateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *NodeCreateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *NodeCreateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *NodeCreateTransaction) getName() string {
	return "NodeCreateTransaction"
}

func (tx *NodeCreateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *NodeCreateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_NodeCreate{
			NodeCreate: tx.buildProtoBody(),
		},
	}
}

func (tx *NodeCreateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_NodeCreate{
			NodeCreate: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *NodeCreateTransaction) buildProtoBody() *services.NodeCreateTransactionBody {
	body := &services.NodeCreateTransactionBody{
		Description: tx.description,
	}

	if tx.accountID != nil {
		body.AccountId = tx.accountID._ToProtobuf()
	}

	for _, endpoint := range tx.gossipEndpoints {
		body.GossipEndpoint = append(body.GossipEndpoint, endpoint._ToProtobuf())
	}

	for _, endpoint := range tx.serviceEndpoints {
		body.ServiceEndpoint = append(body.ServiceEndpoint, endpoint._ToProtobuf())
	}

	if tx.gossipCaCertificate != nil {
		body.GossipCaCertificate = tx.gossipCaCertificate
	}

	if tx.grpcCertificateHash != nil {
		body.GrpcCertificateHash = tx.grpcCertificateHash
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	return body
}

func (tx *NodeCreateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetAddressBook().CreateNode,
	}
}

func (tx *NodeCreateTransaction) preFreezeWith(client *Client) {
	// No special actions needed.
}

func (tx *NodeCreateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: node_create_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitNodeCreateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tx := NewNodeCreateTransaction().
		SetAccountID(accountID)

	err = tx.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitNodeCreateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tx := NewNodeCreateTransaction().
		SetAccountID(accountID)

	err = tx.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func endpoints(offsets ...uint) []Endpoint {
	endpoints := make([]Endpoint, 0)

	for _, offset := range offsets {
		endpoints = append(endpoints, Endpoint{
			address: []byte{byte(offset), byte(offset), byte(offset), byte(offset)},
		})
	}

	return endpoints
}

func TestUnitNodeCreateTransactionMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		status.New(codes.Unavailable, "node is UNAVAILABLE").Err(),
		status.New(codes.Internal, "Received RST_STREAM with code 0").Err(),
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_COST_ANSWER,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_RECEIPT_NOT_FOUND,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
						AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
							AccountNum: 234,
						}},
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	tran := TransactionIDGenerate(AccountID{Account: 3})

	resp, err := NewNodeCreateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}, {Account: 4}}).
		SetAdminKey(newKey).
		SetDescription("test").
		SetGossipEndpoints(endpoints(0, 1, 2)).
		SetServiceEndpoints(endpoints(3, 4, 5)).
		SetGossipCaCertificate([]byte{111}).
		SetGrpcCertificateHash([]byte{222}).
		SetTransactionID(tran).
		Execute(client)
	require.NoError(t, err)

	receipt, err := resp.GetReceipt(client)
	require.NoError(t, err)
	require.Equal(t, receipt.AccountID, &AccountID{Account: 234})
}

func TestUnitNodeCreateTransactionGet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}

	key, err := PrivateKeyGenerateEd25519()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewNodeCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(key).
		SetTransactionMemo("").
		SetDescription("test").
		SetGossipEndpoints(endpoints(0, 1, 2)).
		SetServiceEndpoints(endpoints(3, 4, 5)).
		SetGossipCaCertificate([]byte{111}).
		SetGrpcCertificateHash([]byte{222}).
		SetTransactionValidDuration(60 * time.Second).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetAccountID()
	transaction.GetDescription()
	transaction.GetGossipEndpoints()
	transaction.GetServiceEndpoints()
	transaction.GetGossipCaCertificate()
	transaction.GetGrpcCertificateHash()
	transaction.GetAdminKey()
}

func TestUnitNodeCreateTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewNodeCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetAccountID()
	transaction.GetDescription()
	transaction.GetGossipEndpoints()
	transaction.GetServiceEndpoints()
	transaction.GetGossipCaCertificate()
	transaction.GetGrpcCertificateHash()
	transaction.GetAdminKey()
}

func TestUnitNodeCreateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	stackedAccountID := AccountID{Account: 5}

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	gossipEndpoints := endpoints(1, 2, 3)
	serviceEndpoints := endpoints(3, 4, 5)
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewNodeCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAccountID(stackedAccountID).
		SetAdminKey(key).
		SetTransactionMemo("").
		SetDescription("test").
		SetGossipEndpoints(gossipEndpoints).
		SetServiceEndpoints(serviceEndpoints).
		SetGossipCaCertificate([]byte{111}).
		SetGrpcCertificateHash([]byte{222}).
		SetTransactionValidDuration(60 * time.Second).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetNodeCreate()
	require.Equal(t, proto.AccountId.String(), stackedAccountID._ToProtobuf().String())
	require.Equal(t, proto.Description, "test")
	require.Equal(t, proto.GossipEndpoint[0], gossipEndpoints[0]._ToProtobuf())
	require.Equal(t, proto.ServiceEndpoint[0], serviceEndpoints[0]._ToProtobuf())
	require.Equal(t, proto.GossipCaCertificate, []byte{111})
	require.Equal(t, proto.GrpcCertificateHash, []byte{222})
	require.Equal(t, proto.AdminKey, key._ToProtoKey())
}

func TestUnitNodeCreateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	trx, err := NewNodeCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(key).
		SetAccountID(account).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	trx.validateNetworkOnIDs(client)
	_, err = trx.Schedule()
	require.NoError(t, err)
	trx.GetTransactionID()
	trx.GetNodeAccountIDs()
	trx.GetMaxRetry()
	trx.GetMaxTransactionFee()
	trx.GetMaxBackoff()
	trx.GetMinBackoff()
	trx.GetRegenerateTransactionID()
	byt, err := trx.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := key.SignTransaction(&trx.Transaction)
	require.NoError(t, err)

	_, err = trx.GetTransactionHash()
	require.NoError(t, err)
	trx.GetMaxTransactionFee()
	trx.GetTransactionMemo()
	trx.GetRegenerateTransactionID()
	trx.GetAccountID()
	trx.GetDescription()
	trx.GetGossipEndpoints()
	trx.GetServiceEndpoints()
	trx.GetGossipCaCertificate()
	trx.GetGrpcCertificateHash()
	trx.GetAdminKey()
	_, err = trx.GetSignatures()
	require.NoError(t, err)
	trx.getName()
	switch b := txFromBytes.(type) {
	case NodeCreateTransaction:
		b.AddSignature(key.PublicKey(), sig)
	}
}
// Filename: node_delete_transaction.go
package hedera

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/**
 * A transaction to delete a node from the network address book.
 *
 * This transaction body SHALL be considered a "privileged transaction".
 *
 * - A transaction MUST be signed by the governing council.
 * - Upon success, the address book entry SHALL enter a "pending delete"
 *   state.
 * - All address book entries pending deletion SHALL be removed from the
 *   active network configuration during the next `freeze` transaction with
 *   the field `freeze_type` set to `PREPARE_UPGRADE`.<br/>
 * - A deleted address book node SHALL be removed entirely from network state.
 * - A deleted address book node identifier SHALL NOT be reused.
 *
 * ### Record Stream Effects
 * Upon completion the "deleted" `node_id` SHALL be in the transaction
 * receipt.
 */
type NodeDeleteTransaction struct {
	Transaction
	nodeID uint64
}

func NewNodeDeleteTransaction() *NodeDeleteTransaction {
	tx := &NodeDeleteTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return tx
}

func _NodeDeleteTransactionFromProtobuf(transaction Transaction, pb *services.TransactionBody) *NodeDeleteTransaction {
	return &NodeDeleteTransaction{
		Transaction: transaction,
		nodeID:      pb.GetNodeDelete().NodeId,
	}
}

// GetNodeID he consensus node identifier in the network state.
func (tx *NodeDeleteTransaction) GetNodeID() uint64 {
	return tx.nodeID
}

// SetNodeID the consensus node identifier in the network state.
func (tx *NodeDeleteTransaction) SetNodeID(nodeID uint64) *NodeDeleteTransaction {
	tx._RequireNotFrozen()
	tx.nodeID = nodeID
	return tx
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *NodeDeleteTransaction) Sign(privateKey PrivateKey) *NodeDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *NodeDeleteTransaction) SignWithOperator(client *Client) (*NodeDeleteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *NodeDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *NodeDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *NodeDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *NodeDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *NodeDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *NodeDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *NodeDeleteTransaction) Freeze() (*NodeDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *NodeDeleteTransaction) FreezeWith(client *Client) (*NodeDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this NodeDeleteTransaction.
func (tx *NodeDeleteTransaction) SetMaxTransactionFee(fee Hbar) *NodeDeleteTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *NodeDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *NodeDeleteTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this NodeDeleteTransaction.
func (tx *NodeDeleteTransaction) SetTransactionMemo(memo string) *NodeDeleteTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this NodeDeleteTransaction.
func (tx *NodeDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *NodeDeleteTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *NodeDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this NodeDeleteTransaction.
func (tx *NodeDeleteTransaction) SetTransactionID(transactionID TransactionID) *NodeDeleteTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this NodeDeleteTransaction.
func (tx *NodeDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *NodeDeleteTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *NodeDeleteTransaction) SetMaxRetry(count int) *NodeDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *NodeDeleteTransaction) SetMaxBackoff(max time.Duration) *NodeDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *NodeDeleteTransaction) SetMinBackoff(min time.Duration) *NodeDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *NodeDeleteTransaction) SetLogLevel(level LogLevel) *NodeDeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *NodeDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *NodeDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *NodeDeleteTransaction) getName() string {
	return "NodeDeleteTransaction"
}

func (tx *NodeDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	return nil
}

func (tx *NodeDeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_NodeDelete{
			NodeDelete: tx.buildProtoBody(),
		},
	}
}

func (tx *NodeDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_NodeDelete{
			NodeDelete: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *NodeDeleteTransaction) buildProtoBody() *services.NodeDeleteTransactionBody {
	return &services.NodeDeleteTransactionBody{
		NodeId: tx.nodeID,
	}
}

func (tx *NodeDeleteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetAddressBook().DeleteNode,
	}
}

func (tx *NodeDeleteTransaction) preFreezeWith(client *Client) {
	// No special actions needed.
}

func (tx *NodeDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: node_delete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/stretchr/testify/require"
)

func TestUnitNodeDeleteTransactionMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		status.New(codes.Unavailable, "node is UNAVAILABLE").Err(),
		status.New(codes.Internal, "Received RST_STREAM with code 0").Err(),
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_BUSY,
		},
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_COST_ANSWER,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_RECEIPT_NOT_FOUND,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
						AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
							AccountNum: 234,
						}},
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	tran := TransactionIDGenerate(AccountID{Account: 3})

	resp, err := NewNodeDeleteTransaction().
		SetNodeID(1).
		SetTransactionID(tran).
		Execute(client)
	require.NoError(t, err)

	receipt, err := resp.GetReceipt(client)
	require.NoError(t, err)
	require.Equal(t, receipt.AccountID, &AccountID{Account: 234})
}

func TestUnitNodeDeleteTransactionGet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewNodeDeleteTransaction().
		SetNodeID(1).
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetNodeID()
}

func TestUnitNodeDeleteTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewNodeDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetNodeID()
}

func TestUnitNodeDeleteTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewNodeDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetNodeID(1).
		SetTransactionValidDuration(60 * time.Second).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetNodeDelete()
	require.Equal(t, proto.NodeId, uint64(1))
}

func TestUnitNodeDeleteTransactionCoverage(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	trx, err := NewNodeDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetNodeID(1).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	trx.validateNetworkOnIDs(client)
	_, err = trx.Schedule()
	require.NoError(t, err)
	trx.GetTransactionID()
	trx.GetNodeAccountIDs()
	trx.GetMaxRetry()
	trx.GetMaxTransactionFee()
	trx.GetMaxBackoff()
	trx.GetMinBackoff()
	trx.GetRegenerateTransactionID()
	byt, err := trx.ToBytes()
	require.NoError(t, err)
	_, err = TransactionFromBytes(byt)
	require.NoError(t, err)
	_, err = key.SignTransaction(&trx.Transaction)
	require.NoError(t, err)

	_, err = trx.GetTransactionHash()
	require.NoError(t, err)
	trx.GetMaxTransactionFee()
	trx.GetTransactionMemo()
	trx.GetRegenerateTransactionID()
	trx.GetNodeID()
	_, err = trx.GetSignatures()
	require.NoError(t, err)
	trx.getName()
}
// Filename: node_update_transaction.go
package hedera

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/**
 * A transaction to modify address book node attributes.
 *
 * - This transaction SHALL enable the node operator, as identified by the
 *   `admin_key`, to modify operational attributes of the node.
 * - This transaction MUST be signed by the active `admin_key` for the node.
 * - If this transaction sets a new value for the `admin_key`, then both the
 *   current `admin_key`, and the new `admin_key` MUST sign this transaction.
 * - This transaction SHALL NOT change any field that is not set (is null) in
 *   this transaction body.
 * - This SHALL create a pending update to the node, but the change SHALL NOT
 *   be immediately applied to the active configuration.
 * - All pending node updates SHALL be applied to the active network
 *   configuration during the next `freeze` transaction with the field
 *   `freeze_type` set to `PREPARE_UPGRADE`.
 *
 * ### Record Stream Effects
 * Upon completion the `node_id` for the updated entry SHALL be in the
 * transaction receipt.
 */
type NodeUpdateTransaction struct {
	Transaction
	nodeID              uint64
	accountID           *AccountID
	description         string
	gossipEndpoints     []Endpoint
	serviceEndpoints    []Endpoint
	gossipCaCertificate []byte
	grpcCertificateHash []byte
	adminKey            Key
}

func NewNodeUpdateTransaction() *NodeUpdateTransaction {
	tx := &NodeUpdateTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return tx
}

func _NodeUpdateTransactionFromProtobuf(transaction Transaction, pb *services.TransactionBody) *NodeUpdateTransaction {
	adminKey, err := _KeyFromProtobuf(pb.GetNodeUpdate().GetAdminKey())
	if err != nil {
		return &NodeUpdateTransaction{}
	}

	accountID := _AccountIDFromProtobuf(pb.GetNodeUpdate().GetAccountId())
	gossipEndpoints := make([]Endpoint, 0)
	for _, endpoint := range pb.GetNodeUpdate().GetGossipEndpoint() {
		gossipEndpoints = append(gossipEndpoints, EndpointFromProtobuf(endpoint))
	}
	serviceEndpoints := make([]Endpoint, 0)
	for _, endpoint := range pb.GetNodeUpdate().GetServiceEndpoint() {
		serviceEndpoints = append(serviceEndpoints, EndpointFromProtobuf(endpoint))
	}

	var certificate []byte
	if pb.GetNodeUpdate().GetGossipCaCertificate() != nil {
		certificate = pb.GetNodeUpdate().GetGossipCaCertificate().Value
	}

	var description string
	if pb.GetNodeUpdate().GetDescription() != nil {
		description = pb.GetNodeUpdate().GetDescription().Value
	}

	var certificateHash []byte
	if pb.GetNodeUpdate().GetGrpcCertificateHash() != nil {
		certificateHash = pb.GetNodeUpdate().GetGrpcCertificateHash().Value
	}

	return &NodeUpdateTransaction{
		Transaction:         transaction,
		nodeID:              pb.GetNodeUpdate().GetNodeId(),
		accountID:           accountID,
		description:         description,
		gossipEndpoints:     gossipEndpoints,
		serviceEndpoints:    serviceEndpoints,
		gossipCaCertificate: certificate,
		grpcCertificateHash: certificateHash,
		adminKey:            adminKey,
	}
}

// GetNodeID he consensus node identifier in the network state.
func (tx *NodeUpdateTransaction) GetNodeID() uint64 {
	return tx.nodeID
}

// SetNodeID the consensus node identifier in the network state.
func (tx *NodeUpdateTransaction) SetNodeID(nodeID uint64) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.nodeID = nodeID
	return tx
}

// GetAccountID AccountID of the node
func (tx *NodeUpdateTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// SetAccountID get the AccountID of the node
func (tx *NodeUpdateTransaction) SetAccountID(accountID AccountID) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetDescription get the description of the node
func (tx *NodeUpdateTransaction) GetDescription() string {
	return tx.description
}

// SetDescription set the description of the node
func (tx *NodeUpdateTransaction) SetDescription(description string) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.description = description
	return tx
}

// SetDescription remove the description contents.
func (tx *NodeUpdateTransaction) ClearDescription(description string) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.description = ""
	return tx
}

// GetServiceEndpoints the list of service endpoints for gossip.
func (tx *NodeUpdateTransaction) GetGossipEndpoints() []Endpoint {
	return tx.gossipEndpoints
}

// SetServiceEndpoints the list of service endpoints for gossip.
func (tx *NodeUpdateTransaction) SetGossipEndpoints(gossipEndpoints []Endpoint) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.gossipEndpoints = gossipEndpoints
	return tx
}

// AddGossipEndpoint add an endpoint for gossip to the list of service endpoints for gossip.
func (tx *NodeUpdateTransaction) AddGossipEndpoint(endpoint Endpoint) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.gossipEndpoints = append(tx.gossipEndpoints, endpoint)
	return tx
}

// GetServiceEndpoints the list of service endpoints for gRPC calls.
func (tx *NodeUpdateTransaction) GetServiceEndpoints() []Endpoint {
	return tx.serviceEndpoints
}

// SetServiceEndpoints the list of service endpoints for gRPC calls.
func (tx *NodeUpdateTransaction) SetServiceEndpoints(serviceEndpoints []Endpoint) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.serviceEndpoints = serviceEndpoints
	return tx
}

// AddServiceEndpoint the list of service endpoints for gRPC calls.
func (tx *NodeUpdateTransaction) AddServiceEndpoint(endpoint Endpoint) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.serviceEndpoints = append(tx.serviceEndpoints, endpoint)
	return tx
}

// GetGossipCaCertificate the certificate used to sign gossip events.
func (tx *NodeUpdateTransaction) GetGossipCaCertificate() []byte {
	return tx.gossipCaCertificate
}

// SetGossipCaCertificate the certificate used to sign gossip events.
// This value MUST be the DER encoding of the certificate presented.
func (tx *NodeUpdateTransaction) SetGossipCaCertificate(gossipCaCertificate []byte) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.gossipCaCertificate = gossipCaCertificate
	return tx
}

// GetGrpcCertificateHash the hash of the node gRPC TLS certificate.
func (tx *NodeUpdateTransaction) GetGrpcCertificateHash() []byte {
	return tx.grpcCertificateHash
}

// SetGrpcCertificateHash the hash of the node gRPC TLS certificate.
// This value MUST be a SHA-384 hash.
func (tx *NodeUpdateTransaction) SetGrpcCertificateHash(grpcCertificateHash []byte) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.grpcCertificateHash = grpcCertificateHash
	return tx
}

// GetAdminKey an administrative key controlled by the node operator.
func (tx *NodeUpdateTransaction) GetAdminKey() Key {
	return tx.adminKey
}

// SetAdminKey an administrative key controlled by the node operator.
func (tx *NodeUpdateTransaction) SetAdminKey(adminKey Key) *NodeUpdateTransaction {
	tx._RequireNotFrozen()
	tx.adminKey = adminKey
	return tx
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *NodeUpdateTransaction) Sign(privateKey PrivateKey) *NodeUpdateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *NodeUpdateTransaction) SignWithOperator(client *Client) (*NodeUpdateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *NodeUpdateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *NodeUpdateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *NodeUpdateTransaction) AddSignature(publicKey PublicKey, signature []byte) *NodeUpdateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *NodeUpdateTransaction) SetGrpcDeadline(deadline *time.Duration) *NodeUpdateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *NodeUpdateTransaction) Freeze() (*NodeUpdateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *NodeUpdateTransaction) FreezeWith(client *Client) (*NodeUpdateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this NodeUpdateTransaction.
func (tx *NodeUpdateTransaction) SetMaxTransactionFee(fee Hbar) *NodeUpdateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *NodeUpdateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *NodeUpdateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this NodeUpdateTransaction.
func (tx *NodeUpdateTransaction) SetTransactionMemo(memo string) *NodeUpdateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this NodeUpdateTransaction.
func (tx *NodeUpdateTransaction) SetTransactionValidDuration(duration time.Duration) *NodeUpdateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *NodeUpdateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this NodeUpdateTransaction.
func (tx *NodeUpdateTransaction) SetTransactionID(transactionID TransactionID) *NodeUpdateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this NodeUpdateTransaction.
func (tx *NodeUpdateTransaction) SetNodeAccountIDs(nodeID []AccountID) *NodeUpdateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *NodeUpdateTransaction) SetMaxRetry(count int) *NodeUpdateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *NodeUpdateTransaction) SetMaxBackoff(max time.Duration) *NodeUpdateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *NodeUpdateTransaction) SetMinBackoff(min time.Duration) *NodeUpdateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *NodeUpdateTransaction) SetLogLevel(level LogLevel) *NodeUpdateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *NodeUpdateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *NodeUpdateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *NodeUpdateTransaction) getName() string {
	return "NodeUpdateTransaction"
}

func (tx *NodeUpdateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *NodeUpdateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_NodeUpdate{
			NodeUpdate: tx.buildProtoBody(),
		},
	}
}

func (tx *NodeUpdateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_NodeUpdate{
			NodeUpdate: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *NodeUpdateTransaction) buildProtoBody() *services.NodeUpdateTransactionBody {
	body := &services.NodeUpdateTransactionBody{
		Description: wrapperspb.String(tx.description),
		NodeId:      tx.nodeID,
	}

	if tx.accountID != nil {
		body.AccountId = tx.accountID._ToProtobuf()
	}

	for _, endpoint := range tx.gossipEndpoints {
		body.GossipEndpoint = append(body.GossipEndpoint, endpoint._ToProtobuf())
	}

	for _, endpoint := range tx.serviceEndpoints {
		body.ServiceEndpoint = append(body.ServiceEndpoint, endpoint._ToProtobuf())
	}

	if tx.gossipCaCertificate != nil {
		body.GossipCaCertificate = wrapperspb.Bytes(tx.gossipCaCertificate)
	}

	if tx.grpcCertificateHash != nil {
		body.GrpcCertificateHash = wrapperspb.Bytes(tx.grpcCertificateHash)
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	return body
}

func (tx *NodeUpdateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetAddressBook().UpdateNode,
	}
}

func (tx *NodeUpdateTransaction) preFreezeWith(client *Client) {
	// No special actions needed.
}

func (tx *NodeUpdateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: node_update_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitNodeUpdateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tx := NewNodeUpdateTransaction().
		SetAccountID(accountID)

	err = tx.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitNodeUpdateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tx := NewNodeUpdateTransaction().
		SetAccountID(accountID)

	err = tx.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitNodeUpdateTransactionMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_COST_ANSWER,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
						AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
							AccountNum: 234,
						}},
						NodeId: 1,
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	tran := TransactionIDGenerate(AccountID{Account: 3})

	resp, err := NewNodeUpdateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}, {Account: 4}}).
		SetAdminKey(newKey).
		SetNodeID(1).
		SetDescription("test").
		SetGossipEndpoints(endpoints(0, 1, 2)).
		SetServiceEndpoints(endpoints(3, 4, 5)).
		SetGossipCaCertificate([]byte{111}).
		SetGrpcCertificateHash([]byte{222}).
		SetTransactionID(tran).
		Execute(client)
	require.NoError(t, err)

	receipt, err := resp.GetReceipt(client)
	require.NoError(t, err)
	require.Equal(t, uint64(1), receipt.NodeID)
}

func TestUnitNodeUpdateTransactionGet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}

	key, err := PrivateKeyGenerateEd25519()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewNodeUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetNodeID(1).
		SetAdminKey(key).
		SetTransactionMemo("").
		SetDescription("test").
		SetGossipEndpoints(endpoints(0, 1, 2)).
		SetServiceEndpoints(endpoints(3, 4, 5)).
		SetGossipCaCertificate([]byte{111}).
		SetGrpcCertificateHash([]byte{222}).
		SetTransactionValidDuration(60 * time.Second).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetAccountID()
	transaction.GetDescription()
	transaction.GetGossipEndpoints()
	transaction.GetServiceEndpoints()
	transaction.GetGossipCaCertificate()
	transaction.GetGrpcCertificateHash()
	transaction.GetAdminKey()
	transaction.GetNodeID()
}

func TestUnitNodeUpdateTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewNodeUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetAccountID()
	transaction.GetDescription()
	transaction.GetGossipEndpoints()
	transaction.GetServiceEndpoints()
	transaction.GetGossipCaCertificate()
	transaction.GetGrpcCertificateHash()
	transaction.GetAdminKey()
	transaction.GetNodeID()
}

func TestUnitNodeUpdateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	stackedAccountID := AccountID{Account: 5}

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	gossipEndpoints := endpoints(1, 2, 3)
	serviceEndpoints := endpoints(3, 4, 5)
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewNodeUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeID(1).
		SetNodeAccountIDs(nodeAccountID).
		SetAccountID(stackedAccountID).
		SetAdminKey(key).
		SetTransactionMemo("").
		SetDescription("test").
		SetGossipEndpoints(gossipEndpoints).
		SetServiceEndpoints(serviceEndpoints).
		SetGossipCaCertificate([]byte{111}).
		SetGrpcCertificateHash([]byte{222}).
		SetTransactionValidDuration(60 * time.Second).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetNodeUpdate()
	require.Equal(t, proto.AccountId.String(), stackedAccountID._ToProtobuf().String())
	require.Equal(t, proto.Description.Value, "test")
	require.Equal(t, proto.GossipEndpoint[0], gossipEndpoints[0]._ToProtobuf())
	require.Equal(t, proto.ServiceEndpoint[0], serviceEndpoints[0]._ToProtobuf())
	require.Equal(t, proto.GossipCaCertificate.Value, []byte{111})
	require.Equal(t, proto.GrpcCertificateHash.Value, []byte{222})
	require.Equal(t, proto.AdminKey, key._ToProtoKey())
	require.Equal(t, proto.NodeId, uint64(1))
}

func TestUnitNodeUpdateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	key, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	trx, err := NewNodeUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(key).
		SetNodeID(1).
		SetAccountID(account).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	trx.validateNetworkOnIDs(client)
	_, err = trx.Schedule()
	require.NoError(t, err)
	trx.GetTransactionID()
	trx.GetNodeAccountIDs()
	trx.GetMaxRetry()
	trx.GetMaxTransactionFee()
	trx.GetMaxBackoff()
	trx.GetMinBackoff()
	trx.GetRegenerateTransactionID()
	byt, err := trx.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := key.SignTransaction(&trx.Transaction)
	require.NoError(t, err)

	_, err = trx.GetTransactionHash()
	require.NoError(t, err)
	trx.GetMaxTransactionFee()
	trx.GetTransactionMemo()
	trx.GetRegenerateTransactionID()
	trx.GetAccountID()
	trx.GetDescription()
	trx.GetGossipEndpoints()
	trx.GetServiceEndpoints()
	trx.GetGossipCaCertificate()
	trx.GetGrpcCertificateHash()
	trx.GetAdminKey()
	trx.GetNodeID()
	_, err = trx.GetSignatures()
	require.NoError(t, err)
	trx.getName()
	switch b := txFromBytes.(type) {
	case NodeUpdateTransaction:
		b.AddSignature(key.PublicKey(), sig)
	}
}
// Filename: one_signature_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"os"
	"sync/atomic"
	"testing"

	"github.com/stretchr/testify/require"
)

var callCount int64

func incrementCallCount() {
	atomic.AddInt64(&callCount, 1)
}

func getCallCount() int64 {
	return atomic.LoadInt64(&callCount)
}

func TestIntegrationOneSignature(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	client := ClientForNetwork(env.Client.GetNetwork()).SetOperatorWith(env.OriginalOperatorID, env.OriginalOperatorKey, signingServiceTwo)
	response, err := NewTransferTransaction().
		AddHbarTransfer(env.OriginalOperatorID, NewHbar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, NewHbar(1)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(client)
	require.NoError(t, err)

	_, err = response.GetReceipt(client)
	require.NoError(t, err)

	require.Equal(t, int64(1), getCallCount())
	client.Close()
	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func signingServiceTwo(txBytes []byte) []byte {
	localOperatorPrivateKey, _ := PrivateKeyFromString(os.Getenv("OPERATOR_KEY"))
	incrementCallCount()

	signature := localOperatorPrivateKey.Sign(txBytes)
	return signature
}
// Filename: pending_airdrop_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

/**
 * A unique, composite, identifier for a pending airdrop.
 *
 * Each pending airdrop SHALL be uniquely identified by a PendingAirdropId.
 * A PendingAirdropId SHALL be recorded when created and MUST be provided in any transaction
 * that would modify that pending airdrop (such as a `claimAirdrop` or `cancelAirdrop`).
 */
type PendingAirdropId struct {
	sender   *AccountID
	receiver *AccountID
	tokenID  *TokenID
	nftID    *NftID
}

func (pendingAirdropId *PendingAirdropId) NewPendingAirdropId() *PendingAirdropId {
	return &PendingAirdropId{}
}

// GetSender returns the AccountID of the sender
func (pendingAirdropId *PendingAirdropId) GetSender() *AccountID {
	return pendingAirdropId.sender
}

// SetSender sets the AccountID of the sender
func (pendingAirdropId *PendingAirdropId) SetSender(sender AccountID) *PendingAirdropId {
	pendingAirdropId.sender = &sender
	return pendingAirdropId
}

// GetReceiver returns the AccountID of the receiver
func (pendingAirdropId *PendingAirdropId) GetReceiver() *AccountID {
	return pendingAirdropId.receiver
}

// SetReceiver sets the AccountID of the receiver
func (pendingAirdropId *PendingAirdropId) SetReceiver(receiver AccountID) *PendingAirdropId {
	pendingAirdropId.receiver = &receiver
	return pendingAirdropId
}

// GetTokenID returns the TokenID of the pending airdrop
func (pendingAirdropId *PendingAirdropId) GetTokenID() *TokenID {
	return pendingAirdropId.tokenID
}

// SetTokenID sets the TokenID of the pending airdrop
func (pendingAirdropId *PendingAirdropId) SetTokenID(tokenID TokenID) *PendingAirdropId {
	pendingAirdropId.tokenID = &tokenID
	return pendingAirdropId
}

// GetNftID returns the NftID of the pending airdrop
func (pendingAirdropId *PendingAirdropId) GetNftID() *NftID {
	return pendingAirdropId.nftID
}

// SetNftID sets the NftID of the pending airdrop
func (pendingAirdropId *PendingAirdropId) SetNftID(nftID NftID) *PendingAirdropId {
	pendingAirdropId.nftID = &nftID
	return pendingAirdropId
}

func _PendingAirdropIdFromProtobuf(pb *services.PendingAirdropId) *PendingAirdropId {
	if pb.GetFungibleTokenType() != nil {
		return &PendingAirdropId{
			sender:   _AccountIDFromProtobuf(pb.GetSenderId()),
			receiver: _AccountIDFromProtobuf(pb.GetReceiverId()),
			tokenID:  _TokenIDFromProtobuf(pb.GetFungibleTokenType()),
		}
	} else {
		nftID := _NftIDFromProtobuf(pb.GetNonFungibleToken())
		return &PendingAirdropId{
			sender:   _AccountIDFromProtobuf(pb.GetSenderId()),
			receiver: _AccountIDFromProtobuf(pb.GetReceiverId()),
			nftID:    &nftID,
		}
	}
}

func (pendingAirdropId *PendingAirdropId) _ToProtobuf() *services.PendingAirdropId {
	pb := &services.PendingAirdropId{}

	if pendingAirdropId.sender != nil {
		pb.SenderId = pendingAirdropId.sender._ToProtobuf()
	}

	if pendingAirdropId.receiver != nil {
		pb.ReceiverId = pendingAirdropId.receiver._ToProtobuf()
	}

	if pendingAirdropId.tokenID != nil {
		pb.TokenReference = &services.PendingAirdropId_FungibleTokenType{
			FungibleTokenType: pendingAirdropId.tokenID._ToProtobuf(),
		}
	} else {
		pb.TokenReference = &services.PendingAirdropId_NonFungibleToken{
			NonFungibleToken: pendingAirdropId.nftID._ToProtobuf(),
		}
	}
	return pb
}

func (pendingAirdropId *PendingAirdropId) String() string {
	const nilString = "nil"
	var senderStr, receiverStr, tokenIDStr, nftIDStr string

	if pendingAirdropId.sender != nil {
		senderStr = pendingAirdropId.sender.String()
	} else {
		senderStr = nilString
	}

	if pendingAirdropId.receiver != nil {
		receiverStr = pendingAirdropId.receiver.String()
	} else {
		receiverStr = nilString
	}

	if pendingAirdropId.tokenID != nil {
		tokenIDStr = pendingAirdropId.tokenID.String()
	} else {
		tokenIDStr = nilString
	}

	if pendingAirdropId.nftID != nil {
		nftIDStr = pendingAirdropId.nftID.String()
	} else {
		nftIDStr = nilString
	}

	return fmt.Sprintf("Sender: %s, Receiver: %s, TokenID: %s, NftID: %s", senderStr, receiverStr, tokenIDStr, nftIDStr)
}
// Filename: pending_airdrop_id_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestPendingAirdropId_SettersAndGetters(t *testing.T) {
	t.Parallel()

	sender := AccountID{Account: 1}
	receiver := AccountID{Account: 2}
	tokenID := TokenID{Token: 3}
	nftID := NftID{TokenID: tokenID, SerialNumber: 1}

	pendingAirdropId := &PendingAirdropId{}
	pendingAirdropId.SetSender(sender)
	pendingAirdropId.SetReceiver(receiver)
	pendingAirdropId.SetTokenID(tokenID)
	pendingAirdropId.SetNftID(nftID)

	assert.Equal(t, &sender, pendingAirdropId.GetSender())
	assert.Equal(t, &receiver, pendingAirdropId.GetReceiver())
	assert.Equal(t, &tokenID, pendingAirdropId.GetTokenID())
	assert.Equal(t, &nftID, pendingAirdropId.GetNftID())
}

func TestPendingAirdropId_FromProtobuf(t *testing.T) {
	t.Parallel()

	sender := AccountID{Account: 1}
	receiver := AccountID{Account: 2}
	tokenID := TokenID{Token: 3}
	nftID := NftID{TokenID: tokenID, SerialNumber: 1}

	pb := &services.PendingAirdropId{
		SenderId:   sender._ToProtobuf(),
		ReceiverId: receiver._ToProtobuf(),
		TokenReference: &services.PendingAirdropId_FungibleTokenType{
			FungibleTokenType: tokenID._ToProtobuf(),
		},
	}

	pendingAirdropId := _PendingAirdropIdFromProtobuf(pb)
	require.NotNil(t, pendingAirdropId)
	assert.Equal(t, &sender, pendingAirdropId.GetSender())
	assert.Equal(t, &receiver, pendingAirdropId.GetReceiver())
	assert.Equal(t, &tokenID, pendingAirdropId.GetTokenID())
	assert.Nil(t, pendingAirdropId.GetNftID())

	pb = &services.PendingAirdropId{
		SenderId:   sender._ToProtobuf(),
		ReceiverId: receiver._ToProtobuf(),
		TokenReference: &services.PendingAirdropId_NonFungibleToken{
			NonFungibleToken: nftID._ToProtobuf(),
		},
	}

	pendingAirdropId = _PendingAirdropIdFromProtobuf(pb)
	require.NotNil(t, pendingAirdropId)
	assert.Equal(t, &sender, pendingAirdropId.GetSender())
	assert.Equal(t, &receiver, pendingAirdropId.GetReceiver())
	assert.Nil(t, pendingAirdropId.GetTokenID())
	assert.Equal(t, &nftID, pendingAirdropId.GetNftID())
}

func TestPendingAirdropId_ToProtobuf(t *testing.T) {
	t.Parallel()

	sender := AccountID{Account: 1}
	receiver := AccountID{Account: 2}
	tokenID := TokenID{Token: 3}
	nftID := NftID{TokenID: tokenID, SerialNumber: 1}

	pendingAirdropId := &PendingAirdropId{
		sender:   &sender,
		receiver: &receiver,
		tokenID:  &tokenID,
	}

	pb := pendingAirdropId._ToProtobuf()
	require.NotNil(t, pb)
	assert.Equal(t, sender._ToProtobuf(), pb.GetSenderId())
	assert.Equal(t, receiver._ToProtobuf(), pb.GetReceiverId())
	assert.Equal(t, tokenID._ToProtobuf(), pb.GetFungibleTokenType())
	assert.Nil(t, pb.GetNonFungibleToken())

	pendingAirdropId = &PendingAirdropId{
		sender:   &sender,
		receiver: &receiver,
		nftID:    &nftID,
	}

	pb = pendingAirdropId._ToProtobuf()
	require.NotNil(t, pb)
	assert.Equal(t, sender._ToProtobuf(), pb.GetSenderId())
	assert.Equal(t, receiver._ToProtobuf(), pb.GetReceiverId())
	assert.Nil(t, pb.GetFungibleTokenType())
	assert.Equal(t, nftID._ToProtobuf(), pb.GetNonFungibleToken())
}
// Filename: pending_airdrop_record.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

type PendingAirdropRecord struct {
	pendingAirdropId     PendingAirdropId
	pendingAirdropAmount uint64
}

func (pendingAirdropRecord *PendingAirdropRecord) GetPendingAirdropId() PendingAirdropId {
	return pendingAirdropRecord.pendingAirdropId
}

func (pendingAirdropRecord *PendingAirdropRecord) GetPendingAirdropAmount() uint64 {
	return pendingAirdropRecord.pendingAirdropAmount
}

func _PendingAirdropRecordFromProtobuf(pb *services.PendingAirdropRecord) PendingAirdropRecord {
	return PendingAirdropRecord{
		pendingAirdropId:     *(_PendingAirdropIdFromProtobuf(pb.GetPendingAirdropId())),
		pendingAirdropAmount: pb.PendingAirdropValue.GetAmount(),
	}
}

func (pendingAirdropRecord *PendingAirdropRecord) _ToProtobuf() *services.PendingAirdropRecord {
	return &services.PendingAirdropRecord{
		PendingAirdropId: pendingAirdropRecord.pendingAirdropId._ToProtobuf(),
		PendingAirdropValue: &services.PendingAirdropValue{
			Amount: pendingAirdropRecord.pendingAirdropAmount,
		},
	}
}

func (pendingAirdropRecord *PendingAirdropRecord) String() string {
	return fmt.Sprintf("PendingAirdropRecord{PendingAirdropId: %s, PendingAirdropAmount: %d}", pendingAirdropRecord.pendingAirdropId.String(), pendingAirdropRecord.pendingAirdropAmount)
}
// Filename: prng_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// PrngTransaction is used to generate a random number in a given range
type PrngTransaction struct {
	Transaction
	rang uint32
}

// NewPrngTransaction creates a PrngTransaction transaction which can be used to construct and execute
// a Prng Transaction.
func NewPrngTransaction() *PrngTransaction {
	tx := PrngTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _PrngTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *PrngTransaction {
	return &PrngTransaction{
		Transaction: tx,
		rang:        uint32(pb.GetUtilPrng().GetRange()),
	}
}

// SetPayerAccountID Sets an optional id of the account to be charged the service fee for the scheduled transaction at
// the consensus time that it executes (if ever); defaults to the ScheduleCreate payer if not
// given
func (tx *PrngTransaction) SetRange(r uint32) *PrngTransaction {
	tx._RequireNotFrozen()
	tx.rang = r

	return tx
}

// GetRange returns the range of the prng
func (tx *PrngTransaction) GetRange() uint32 {
	return tx.rang
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *PrngTransaction) Sign(privateKey PrivateKey) *PrngTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *PrngTransaction) SignWithOperator(client *Client) (*PrngTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *PrngTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *PrngTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *PrngTransaction) AddSignature(publicKey PublicKey, signature []byte) *PrngTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// SetGrpcDeadline When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *PrngTransaction) SetGrpcDeadline(deadline *time.Duration) *PrngTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *PrngTransaction) Freeze() (*PrngTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *PrngTransaction) FreezeWith(client *Client) (*PrngTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee for this PrngTransaction.
func (tx *PrngTransaction) SetMaxTransactionFee(fee Hbar) *PrngTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *PrngTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *PrngTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this PrngTransaction.
func (tx *PrngTransaction) SetTransactionMemo(memo string) *PrngTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this PrngTransaction.
func (tx *PrngTransaction) SetTransactionValidDuration(duration time.Duration) *PrngTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *PrngTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this PrngTransaction.
func (tx *PrngTransaction) SetTransactionID(transactionID TransactionID) *PrngTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this PrngTransaction.
func (tx *PrngTransaction) SetNodeAccountIDs(nodeID []AccountID) *PrngTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *PrngTransaction) SetMaxRetry(count int) *PrngTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *PrngTransaction) SetMaxBackoff(max time.Duration) *PrngTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *PrngTransaction) SetMinBackoff(min time.Duration) *PrngTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *PrngTransaction) SetLogLevel(level LogLevel) *PrngTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *PrngTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *PrngTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *PrngTransaction) getName() string {
	return "PrngTransaction"
}

func (tx *PrngTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_UtilPrng{
			UtilPrng: tx.buildProtoBody(),
		},
	}
}

func (tx *PrngTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_UtilPrng{
			UtilPrng: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *PrngTransaction) buildProtoBody() *services.UtilPrngTransactionBody {
	body := &services.UtilPrngTransactionBody{
		Range: int32(tx.rang),
	}

	return body
}

func (tx *PrngTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetUtil().Prng,
	}
}
func (tx *PrngTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}

func (tx *PrngTransaction) validateNetworkOnIDs(client *Client) error {
	return nil
}
// Filename: proxy_staker.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// ProxyStaker is an information about a single account that is proxy staking
type ProxyStaker struct {
	AccountID AccountID
	Amount    Hbar
}
// Filename: query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use q file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
	protobuf "google.golang.org/protobuf/proto"
)

// Query is the struct used to build queries.
type Query struct {
	executable
	client                *Client
	pb                    *services.Query
	pbHeader              *services.QueryHeader //nolint
	paymentTransactionIDs *_LockableSlice

	paymentTransactions []*services.Transaction
	maxQueryPayment     Hbar
	queryPayment        Hbar
	timestamp           time.Time

	isPaymentRequired bool
}

type queryResponse interface {
	GetHeader() *services.ResponseHeader
}

type QueryInterface interface {
	Executable

	buildQuery() *services.Query
	getQueryResponse(response *services.Response) queryResponse
}

// -------- Executable functions ----------

func _NewQuery(isPaymentRequired bool, header *services.QueryHeader) Query {
	minBackoff := 250 * time.Millisecond
	maxBackoff := 8 * time.Second
	return Query{
		pb:                    &services.Query{},
		pbHeader:              header,
		paymentTransactionIDs: _NewLockableSlice(),
		paymentTransactions:   make([]*services.Transaction, 0),
		isPaymentRequired:     isPaymentRequired,
		maxQueryPayment:       NewHbar(0),
		queryPayment:          NewHbar(0),
		executable: executable{
			nodeAccountIDs: _NewLockableSlice(),
			maxBackoff:     &maxBackoff,
			minBackoff:     &minBackoff,
			maxRetry:       10,
		},
	}
}

// SetMaxQueryPayment sets the maximum payment allowed for this query.
func (q *Query) SetMaxQueryPayment(maxPayment Hbar) *Query {
	q.maxQueryPayment = maxPayment
	return q
}

// SetQueryPayment sets the payment amount for this query.
func (q *Query) SetQueryPayment(paymentAmount Hbar) *Query {
	q.queryPayment = paymentAmount
	return q
}

// GetMaxQueryPayment returns the maximum payment allowed for this query.
func (q *Query) GetMaxQueryPayment() Hbar {
	return q.maxQueryPayment
}

// GetQueryPayment returns the payment amount for this query.
func (q *Query) GetQueryPayment() Hbar {
	return q.queryPayment
}

// GetCost returns the fee that would be charged to get the requested information (if a cost was requested).
func (q *Query) getCost(client *Client, e QueryInterface) (Hbar, error) {
	if client == nil || client.operator == nil {
		return Hbar{}, errNoClientProvided
	}

	var err error

	err = e.validateNetworkOnIDs(client)
	if err != nil {
		return Hbar{}, err
	}
	q.paymentTransactions = make([]*services.Transaction, 0)
	if !q.nodeAccountIDs.locked {
		q.SetNodeAccountIDs([]AccountID{client.network._GetNode().accountID})
	}

	q.pb = e.buildQuery()

	if q.isPaymentRequired && len(q.paymentTransactions) > 0 {
		q.paymentTransactionIDs._Advance()
	}

	q.pbHeader.ResponseType = services.ResponseType_COST_ANSWER
	q.paymentTransactionIDs._Advance()
	resp, err := _Execute(client, e)

	if err != nil {
		return Hbar{}, err
	}

	queryResp := e.getQueryResponse(resp.(*services.Response))
	cost := int64(queryResp.GetHeader().Cost)

	return HbarFromTinybar(cost), nil
}

func _QueryMakePaymentTransaction(transactionID TransactionID, nodeAccountID AccountID, operator *_Operator, cost Hbar) (*services.Transaction, error) {
	accountAmounts := make([]*services.AccountAmount, 0)
	accountAmounts = append(accountAmounts, &services.AccountAmount{
		AccountID: nodeAccountID._ToProtobuf(),
		Amount:    cost.tinybar,
	})
	accountAmounts = append(accountAmounts, &services.AccountAmount{
		AccountID: operator.accountID._ToProtobuf(),
		Amount:    -cost.tinybar,
	})

	body := services.TransactionBody{
		TransactionID:  transactionID._ToProtobuf(),
		NodeAccountID:  nodeAccountID._ToProtobuf(),
		TransactionFee: uint64(NewHbar(1).tinybar),
		TransactionValidDuration: &services.Duration{
			Seconds: 120,
		},
		Data: &services.TransactionBody_CryptoTransfer{
			CryptoTransfer: &services.CryptoTransferTransactionBody{
				Transfers: &services.TransferList{
					AccountAmounts: accountAmounts,
				},
			},
		},
	}

	bodyBytes, err := protobuf.Marshal(&body)
	if err != nil {
		return nil, errors.Wrap(err, "error serializing Query body")
	}

	signature := operator.signer(bodyBytes)
	sigPairs := make([]*services.SignaturePair, 0)
	sigPairs = append(sigPairs, operator.publicKey._ToSignaturePairProtobuf(signature))

	return &services.Transaction{
		BodyBytes: bodyBytes,
		SigMap: &services.SignatureMap{
			SigPair: sigPairs,
		},
	}, nil
}

// GetPaymentTransactionID returns the payment transaction id.
func (q *Query) GetPaymentTransactionID() TransactionID {
	if !q.paymentTransactionIDs._IsEmpty() {
		return q.paymentTransactionIDs._GetCurrent().(TransactionID)
	}

	return TransactionID{}
}

// GetMaxRetryCount returns the max number of errors before execution will fail.
func (q *Query) GetMaxRetryCount() int {
	return q.GetMaxRetry()
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *Query) SetPaymentTransactionID(transactionID TransactionID) *Query {
	q.paymentTransactionIDs._Clear()._Push(transactionID)._SetLocked(true)
	return q
}

func (q *Query) execute(client *Client, e QueryInterface) (*services.Response, error) {
	q.client = client
	if client == nil {
		return nil, errNoClientProvided
	}

	var err error

	err = e.validateNetworkOnIDs(client)
	if err != nil {
		return nil, err
	}

	var cost Hbar
	if q.queryPayment.tinybar == 0 && q.isPaymentRequired {
		if q.maxQueryPayment.tinybar == 0 {
			cost = client.GetDefaultMaxQueryPayment()
		} else {
			cost = q.maxQueryPayment
		}

		actualCost, err := q.getCost(client, e)
		if err != nil {
			return nil, err
		}

		if cost.tinybar < actualCost.tinybar {
			return nil, ErrMaxQueryPaymentExceeded{
				QueryCost:       actualCost,
				MaxQueryPayment: cost,
				query:           e.getName(),
			}
		}

		q.queryPayment = actualCost
	}

	q.paymentTransactions = make([]*services.Transaction, 0)
	if !q.nodeAccountIDs.locked {
		q.SetNodeAccountIDs([]AccountID{client.network._GetNode().accountID})
	}

	q.pb = e.buildQuery()
	q.pbHeader.ResponseType = services.ResponseType_ANSWER_ONLY

	resp, err := _Execute(client, e)
	if err != nil {
		return nil, err
	}

	return resp.(*services.Response), nil
}

func (q *Query) shouldRetry(e Executable, response interface{}) _ExecutionState {
	queryResp := e.(QueryInterface).getQueryResponse(response.(*services.Response))

	status := Status(queryResp.GetHeader().NodeTransactionPrecheckCode)

	retryableStatuses := map[Status]bool{
		StatusPlatformTransactionNotCreated: true,
		StatusPlatformNotActive:             true,
		StatusBusy:                          true,
	}

	if retryableStatuses[status] {
		return executionStateRetry
	}

	if status == StatusOk {
		return executionStateFinished
	}

	return executionStateError
}

func (q *Query) generatePayments(client *Client, cost Hbar) (*services.Transaction, error) {
	var tx *services.Transaction
	var err error
	for _, nodeID := range q.nodeAccountIDs.slice {
		txnID := TransactionIDGenerate(client.operator.accountID)
		tx, err = _QueryMakePaymentTransaction(
			txnID,
			nodeID.(AccountID),
			client.operator,
			cost,
		)
		if err != nil {
			return nil, err
		}
		q.paymentTransactions = append(q.paymentTransactions, tx)
	}
	return tx, nil
}

func (q *Query) advanceRequest() {
	q.nodeAccountIDs._Advance()
}

func (q *Query) makeRequest() interface{} {
	if q.client != nil && q.isPaymentRequired {
		tx, err := q.generatePayments(q.client, q.queryPayment)
		if err != nil {
			return q.pb
		}
		q.pbHeader.Payment = tx
	}

	return q.pb
}

func (q *Query) mapResponse(response interface{}, _ AccountID, _ interface{}) (interface{}, error) { // nolint
	return response.(*services.Response), nil
}

func (q *Query) isTransaction() bool {
	return false
}

func (q *Query) mapStatusError(e Executable, response interface{}) error {
	queryResp := e.(QueryInterface).getQueryResponse(response.(*services.Response))
	return ErrHederaPreCheckStatus{
		Status: Status(queryResp.GetHeader().NodeTransactionPrecheckCode),
	}
}

// ----------- Next methods should be overridden in each subclass ---------------

// NOTE: Should be implemented in every inheritor. Example:
//
//	return ErrHederaPreCheckStatus{
//		Status: Status(response.(*services.Response).GetNetworkGetVersionInfo().Header.NodeTransactionPrecheckCode),
//	}
func (q *Query) getMethod(*_Channel) _Method {
	return _Method{}
}

func (q *Query) getName() string {
	return "QueryInterface"
}

func (q *Query) getLogID(queryInterface Executable) string {
	timestamp := q.timestamp.UnixNano()
	return fmt.Sprintf("%s:%d", queryInterface.getName(), timestamp)
}

//lint:ignore U1000
func (q *Query) buildQuery() *services.Query {
	return nil
}

//lint:ignore U1000
func (q *Query) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return nil, errors.New("Not implemented")
}

// NOTE: Should be implemented in every inheritor.
func (q *Query) validateNetworkOnIDs(*Client) error {
	return errors.New("Not implemented")
}

func (q *Query) getTransactionIDAndMessage() (string, string) {
	txID := q.GetPaymentTransactionID().String()
	if txID == "" {
		txID = "None"
	}
	return txID, "QueryInterface status received"
}
// Filename: request_type.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
)

type RequestType uint32

const (
	// UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and not parsed (0 is ignored by parser)
	RequestTypeNone RequestType = 0
	// crypto transfe
	RequestTypeCryptoTransfer RequestType = 1
	// crypto update account
	RequestTypeCryptoUpdate RequestType = 2
	// crypto delete account
	RequestTypeCryptoDelete RequestType = 3
	// Add a livehash to a crypto account
	RequestTypeCryptoAddLiveHash RequestType = 4
	// Delete a livehash from a crypto account
	RequestTypeCryptoDeleteLiveHash RequestType = 5
	// Smart Contract Call
	RequestTypeContractCall RequestType = 6
	// Smart Contract Create Contract
	RequestTypeContractCreate RequestType = 7
	// Smart Contract update contract
	RequestTypeContractUpdate RequestType = 8
	// File Operation create file
	RequestTypeFileCreate RequestType = 9
	// File Operation append file
	RequestTypeFileAppend RequestType = 10
	// File Operation update file
	RequestTypeFileUpdate RequestType = 11
	// File Operation delete file
	RequestTypeFileDelete RequestType = 12
	// crypto get account balance
	RequestTypeCryptoGetAccountBalance RequestType = 13
	// crypto get account record
	RequestTypeCryptoGetAccountRecords RequestType = 14
	// Crypto get info
	RequestTypeCryptoGetInfo RequestType = 15
	// Smart Contract Call
	RequestTypeContractCallLocal RequestType = 16
	// Smart Contract get info
	RequestTypeContractGetInfo RequestType = 17
	// Smart Contract, get the byte code
	RequestTypeContractGetBytecode RequestType = 18
	// Smart Contract, get by _Solidity ID
	RequestTypeGetBySolidityID RequestType = 19
	// Smart Contract, get by key
	RequestTypeGetByKey RequestType = 20
	// Get a live hash from a crypto account
	RequestTypeCryptoGetLiveHash RequestType = 21
	// Crypto, get the stakers for the _Node
	RequestTypeCryptoGetStakers RequestType = 22
	// File Operations get file contents
	RequestTypeFileGetContents RequestType = 23
	// File Operations get the info of the file
	RequestTypeFileGetInfo RequestType = 24
	// Crypto get the transaction records
	RequestTypeTransactionGetRecord RequestType = 25
	// Contract get the transaction records
	RequestTypeContractGetRecords RequestType = 26
	// crypto create account
	RequestTypeCryptoCreate RequestType = 27
	// system delete file
	RequestTypeSystemDelete RequestType = 28
	// system undelete file
	RequestTypeSystemUndelete RequestType = 29
	// delete contract
	RequestTypeContractDelete RequestType = 30
	// freeze
	RequestTypeFreeze RequestType = 31
	// Create Tx Record
	RequestTypeCreateTransactionRecord RequestType = 32
	// Crypto Auto Renew
	RequestTypeCryptoAccountAutoRenew RequestType = 33
	// Contract Auto Renew
	RequestTypeContractAutoRenew RequestType = 34
	// Get Version
	RequestTypeGetVersionInfo RequestType = 35
	// Transaction Get Receipt
	RequestTypeTransactionGetReceipt RequestType = 36
	// Create Topic
	RequestTypeConsensusCreateTopic RequestType = 50
	// Update Topic
	RequestTypeConsensusUpdateTopic RequestType = 51
	// Delete Topic
	RequestTypeConsensusDeleteTopic RequestType = 52
	// Get Topic information
	RequestTypeConsensusGetTopicInfo RequestType = 53
	// Submit message to topic
	RequestTypeConsensusSubmitMessage RequestType = 54
	RequestTypeUncheckedSubmit        RequestType = 55
	// Create Token
	RequestTypeTokenCreate RequestType = 56
	// Get Token information
	RequestTypeTokenGetInfo RequestType = 58
	// Freeze Account
	RequestTypeTokenFreezeAccount RequestType = 59
	// Unfreeze Account
	RequestTypeTokenUnfreezeAccount RequestType = 60
	// Grant KYC to Account
	RequestTypeTokenGrantKycToAccount RequestType = 61
	// Revoke KYC from Account
	RequestTypeTokenRevokeKycFromAccount RequestType = 62
	// Delete Token
	RequestTypeTokenDelete RequestType = 63
	// Update Token
	RequestTypeTokenUpdate RequestType = 64
	// Mint tokens to treasury
	RequestTypeTokenMint RequestType = 65
	// Burn tokens from treasury
	RequestTypeTokenBurn RequestType = 66
	// Wipe token amount from Account holder
	RequestTypeTokenAccountWipe RequestType = 67
	// Associate tokens to an account
	RequestTypeTokenAssociateToAccount RequestType = 68
	// Dissociate tokens from an account
	RequestTypeTokenDissociateFromAccount RequestType = 69
	// Create Scheduled Transaction
	RequestTypeScheduleCreate RequestType = 70
	// Delete Scheduled Transaction
	RequestTypeScheduleDelete RequestType = 71
	// Sign Scheduled Transaction
	RequestTypeScheduleSign RequestType = 72
	// Get Scheduled Transaction Information
	RequestTypeScheduleGetInfo RequestType = 73
)

// String() returns a string representation of the status
func (requestType RequestType) String() string { // nolint
	switch requestType {
	case RequestTypeNone:
		return "NONE"
	case RequestTypeCryptoTransfer:
		return "CRYPTO_TRANSFER"
	case RequestTypeCryptoUpdate:
		return "CRYPTO_UPDATE"
	case RequestTypeCryptoDelete:
		return "CRYPTO_DELETE"
	case RequestTypeCryptoAddLiveHash:
		return "CRYPTO_ADD_LIVE_HASH"
	case RequestTypeCryptoDeleteLiveHash:
		return "CRYPTO_DELETE_LIVE_HASH"
	case RequestTypeContractCall:
		return "CONTRACT_CALL"
	case RequestTypeContractCreate:
		return "CONTRACT_CREATE"
	case RequestTypeContractUpdate:
		return "CONTRACT_UPDATE"
	case RequestTypeFileCreate:
		return "FILE_CREATE"
	case RequestTypeFileAppend:
		return "FILE_APPEND"
	case RequestTypeFileUpdate:
		return "FILE_UPDATE"
	case RequestTypeFileDelete:
		return "FILE_DELETE"
	case RequestTypeCryptoGetAccountBalance:
		return "CRYPTO_GET_ACCOUNT_BALANCE"
	case RequestTypeCryptoGetAccountRecords:
		return "CRYPTO_GET_ACCOUNT_RECORDS"
	case RequestTypeCryptoGetInfo:
		return "CRYPTO_GET_INFO"
	case RequestTypeContractCallLocal:
		return "CONTRACT_CALL_LOCAL"
	case RequestTypeContractGetInfo:
		return "CONTRACT_GET_INFO"
	case RequestTypeContractGetBytecode:
		return "CONTRACT_GET_BYTECODE"
	case RequestTypeGetBySolidityID:
		return "GET_BY_SOLIDITY_ID"
	case RequestTypeGetByKey:
		return "GET_BY_KEY"
	case RequestTypeCryptoGetLiveHash:
		return "CRYPTO_GET_LIVE_HASH"
	case RequestTypeCryptoGetStakers:
		return "CRYPTO_GET_STAKERS"
	case RequestTypeFileGetContents:
		return "FILE_GET_CONTENTS"
	case RequestTypeFileGetInfo:
		return "FILE_GET_INFO"
	case RequestTypeTransactionGetRecord:
		return "TRANSACTION_GET_RECORD"
	case RequestTypeContractGetRecords:
		return "CONTRACT_GET_RECORDS"
	case RequestTypeCryptoCreate:
		return "CRYPTO_CREATE"
	case RequestTypeSystemDelete:
		return "SYSTEM_DELETE"
	case RequestTypeSystemUndelete:
		return "SYSTEM_UNDELETE"
	case RequestTypeContractDelete:
		return "CONTRACT_DELETE"
	case RequestTypeFreeze:
		return "FREEZE"
	case RequestTypeCreateTransactionRecord:
		return "CREATE_TRANSACTION_RECORD"
	case RequestTypeCryptoAccountAutoRenew:
		return "CRYPTO_ACCOUNT_AUTO_RENEW"
	case RequestTypeContractAutoRenew:
		return "CONTRACT_AUTO_RENEW"
	case RequestTypeGetVersionInfo:
		return "GET_VERSION_INFO"
	case RequestTypeTransactionGetReceipt:
		return "TRANSACTION_GET_RECEIPT"
	case RequestTypeConsensusCreateTopic:
		return "CONSENSUS_CREATE_TOPIC"
	case RequestTypeConsensusUpdateTopic:
		return "CONSENSUS_UPDATE_TOPIC"
	case RequestTypeConsensusDeleteTopic:
		return "CONSENSUS_DELETE_TOPIC"
	case RequestTypeConsensusGetTopicInfo:
		return "CONSENSUS_GET_TOPIC_INFO"
	case RequestTypeConsensusSubmitMessage:
		return "CONSENSUS_SUBMIT_MESSAGE"
	case RequestTypeUncheckedSubmit:
		return "UNCHECKED_SUBMIT"
	case RequestTypeTokenCreate:
		return "TOKEN_CREATE"
	case RequestTypeTokenGetInfo:
		return "TOKEN_GET_INFO"
	case RequestTypeTokenFreezeAccount:
		return "TOKEN_FREEZE_ACCOUNT"
	case RequestTypeTokenUnfreezeAccount:
		return "TOKEN_UNFREEZE_ACCOUNT"
	case RequestTypeTokenGrantKycToAccount:
		return "TOKEN_GRANT_KYC_TO_ACCOUNT"
	case RequestTypeTokenRevokeKycFromAccount:
		return "TOKEN_REVOKE_KYC_TO_ACCOUNT"
	case RequestTypeTokenDelete:
		return "TOKEN_DELETE"
	case RequestTypeTokenUpdate:
		return "TOKEN_UPDATE"
	case RequestTypeTokenMint:
		return "TOKEN_MINT"
	case RequestTypeTokenBurn:
		return "TOKEN_BURN"
	case RequestTypeTokenAccountWipe:
		return "TOKEN_ACCOUNT_WIPE"
	case RequestTypeTokenAssociateToAccount:
		return "TOKEN_ASSOCIATE_TO_ACCOUNT"
	case RequestTypeTokenDissociateFromAccount:
		return "TOKEN_DISSOCIATE_FROM_ACCOUNT"
	case RequestTypeScheduleCreate:
		return "SCHEDULE_CREATE"
	case RequestTypeScheduleDelete:
		return "SCHEDULE_DELETE"
	case RequestTypeScheduleSign:
		return "SCHEDULE_SIGN"
	case RequestTypeScheduleGetInfo:
		return "SCHEDULE_GET_INFO"
	}

	panic(fmt.Sprintf("unreachable: RequestType.String() switch statement is non-exhaustive. RequestType: %v", uint32(requestType)))
}
// Filename: schedule_create_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"errors"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ScheduleCreateTransaction Creates a new schedule entity (or simply, schedule) in the network's action queue.
// Upon SUCCESS, the receipt contains the `ScheduleID` of the created schedule. A schedule
// entity includes a scheduledTransactionBody to be executed.
// When the schedule has collected enough signing Ed25519 keys to satisfy the schedule's signing
// requirements, the schedule can be executed.
type ScheduleCreateTransaction struct {
	Transaction
	payerAccountID  *AccountID
	adminKey        Key
	schedulableBody *services.SchedulableTransactionBody
	memo            string
	expirationTime  *time.Time
	waitForExpiry   bool
}

// NewScheduleCreateTransaction creates ScheduleCreateTransaction which creates a new schedule entity (or simply, schedule) in the network's action queue.
// Upon SUCCESS, the receipt contains the `ScheduleID` of the created schedule. A schedule
// entity includes a scheduledTransactionBody to be executed.
// When the schedule has collected enough signing Ed25519 keys to satisfy the schedule's signing
// requirements, the schedule can be executed.
func NewScheduleCreateTransaction() *ScheduleCreateTransaction {
	tx := ScheduleCreateTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _ScheduleCreateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *ScheduleCreateTransaction {
	key, _ := _KeyFromProtobuf(pb.GetScheduleCreate().GetAdminKey())
	var expirationTime time.Time
	if pb.GetScheduleCreate().GetExpirationTime() != nil {
		expirationTime = _TimeFromProtobuf(pb.GetScheduleCreate().GetExpirationTime())
	}

	return &ScheduleCreateTransaction{
		Transaction:     tx,
		payerAccountID:  _AccountIDFromProtobuf(pb.GetScheduleCreate().GetPayerAccountID()),
		adminKey:        key,
		schedulableBody: pb.GetScheduleCreate().GetScheduledTransactionBody(),
		memo:            pb.GetScheduleCreate().GetMemo(),
		expirationTime:  &expirationTime,
		waitForExpiry:   pb.GetScheduleCreate().WaitForExpiry,
	}
}

// SetPayerAccountID Sets an optional id of the account to be charged the service fee for the scheduled transaction at
// the consensus time that it executes (if ever); defaults to the ScheduleCreate payer if not
// given
func (tx *ScheduleCreateTransaction) SetPayerAccountID(payerAccountID AccountID) *ScheduleCreateTransaction {
	tx._RequireNotFrozen()
	tx.payerAccountID = &payerAccountID

	return tx
}

// GetPayerAccountID returns the optional id of the account to be charged the service fee for the scheduled transaction
func (tx *ScheduleCreateTransaction) GetPayerAccountID() AccountID {
	if tx.payerAccountID == nil {
		return AccountID{}
	}

	return *tx.payerAccountID
}

// SetAdminKey Sets an optional Hedera key which can be used to sign a ScheduleDelete and remove the schedule
func (tx *ScheduleCreateTransaction) SetAdminKey(key Key) *ScheduleCreateTransaction {
	tx._RequireNotFrozen()
	tx.adminKey = key

	return tx
}

// SetExpirationTime Sets an optional timestamp for specifying when the transaction should be evaluated for execution and then expire.
// Defaults to 30 minutes after the transaction's consensus timestamp.
func (tx *ScheduleCreateTransaction) SetExpirationTime(time time.Time) *ScheduleCreateTransaction {
	tx._RequireNotFrozen()
	tx.expirationTime = &time

	return tx
}

// GetExpirationTime returns the optional timestamp for specifying when the transaction should be evaluated for execution and then expire.
func (tx *ScheduleCreateTransaction) GetExpirationTime() time.Time {
	if tx.expirationTime != nil {
		return *tx.expirationTime
	}

	return time.Time{}
}

// SetWaitForExpiry
// When set to true, the transaction will be evaluated for execution at expiration_time instead
// of when all required signatures are received.
// When set to false, the transaction will execute immediately after sufficient signatures are received
// to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
// Defaults to false.
func (tx *ScheduleCreateTransaction) SetWaitForExpiry(wait bool) *ScheduleCreateTransaction {
	tx._RequireNotFrozen()
	tx.waitForExpiry = wait

	return tx
}

// GetWaitForExpiry returns true if the transaction will be evaluated for execution at expiration_time instead
// of when all required signatures are received.
func (tx *ScheduleCreateTransaction) GetWaitForExpiry() bool {
	return tx.waitForExpiry
}

func (tx *ScheduleCreateTransaction) _SetSchedulableTransactionBody(txBody *services.SchedulableTransactionBody) *ScheduleCreateTransaction {
	tx._RequireNotFrozen()
	tx.schedulableBody = txBody

	return tx
}

// GetAdminKey returns the optional Hedera key which can be used to sign a ScheduleDelete and remove the schedule
func (tx *ScheduleCreateTransaction) GetAdminKey() *Key {
	if tx.adminKey == nil {
		return nil
	}
	return &tx.adminKey
}

// SetScheduleMemo Sets an optional memo with a UTF-8 encoding of no more than 100 bytes which does not contain the zero byte.
func (tx *ScheduleCreateTransaction) SetScheduleMemo(memo string) *ScheduleCreateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo

	return tx
}

// GetScheduleMemo returns the optional memo with a UTF-8 encoding of no more than 100 bytes which does not contain the zero byte.
func (tx *ScheduleCreateTransaction) GetScheduleMemo() string {
	return tx.memo
}

// SetScheduledTransaction Sets the scheduled transaction
func (tx *ScheduleCreateTransaction) SetScheduledTransaction(scheduledTx ITransaction) (*ScheduleCreateTransaction, error) {
	tx._RequireNotFrozen()

	scheduled, err := scheduledTx._ConstructScheduleProtobuf()
	if err != nil {
		return tx, err
	}

	tx.schedulableBody = scheduled
	return tx, nil
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *ScheduleCreateTransaction) Sign(privateKey PrivateKey) *ScheduleCreateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *ScheduleCreateTransaction) SignWithOperator(client *Client) (*ScheduleCreateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *ScheduleCreateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *ScheduleCreateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *ScheduleCreateTransaction) AddSignature(publicKey PublicKey, signature []byte) *ScheduleCreateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// SetGrpcDeadline When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *ScheduleCreateTransaction) SetGrpcDeadline(deadline *time.Duration) *ScheduleCreateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *ScheduleCreateTransaction) Freeze() (*ScheduleCreateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *ScheduleCreateTransaction) FreezeWith(client *Client) (*ScheduleCreateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the maximum transaction fee for this ScheduleCreateTransaction.
func (tx *ScheduleCreateTransaction) SetMaxTransactionFee(fee Hbar) *ScheduleCreateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *ScheduleCreateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *ScheduleCreateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this ScheduleCreateTransaction.
func (tx *ScheduleCreateTransaction) SetTransactionMemo(memo string) *ScheduleCreateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this ScheduleCreateTransaction.
func (tx *ScheduleCreateTransaction) SetTransactionValidDuration(duration time.Duration) *ScheduleCreateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *ScheduleCreateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this ScheduleCreateTransaction.
func (tx *ScheduleCreateTransaction) SetTransactionID(transactionID TransactionID) *ScheduleCreateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this ScheduleCreateTransaction.
func (tx *ScheduleCreateTransaction) SetNodeAccountIDs(nodeID []AccountID) *ScheduleCreateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *ScheduleCreateTransaction) SetMaxRetry(count int) *ScheduleCreateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *ScheduleCreateTransaction) SetMaxBackoff(max time.Duration) *ScheduleCreateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *ScheduleCreateTransaction) SetMinBackoff(min time.Duration) *ScheduleCreateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *ScheduleCreateTransaction) SetLogLevel(level LogLevel) *ScheduleCreateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *ScheduleCreateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *ScheduleCreateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *ScheduleCreateTransaction) getName() string {
	return "ScheduleCreateTransaction"
}

func (tx *ScheduleCreateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.payerAccountID != nil {
		if err := tx.payerAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *ScheduleCreateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ScheduleCreate{
			ScheduleCreate: tx.buildProtoBody(),
		},
	}
}

func (tx *ScheduleCreateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return nil, errors.New("cannot schedule `ScheduleCreateTransaction`")
}

func (tx *ScheduleCreateTransaction) buildProtoBody() *services.ScheduleCreateTransactionBody {
	body := &services.ScheduleCreateTransactionBody{
		Memo:          tx.memo,
		WaitForExpiry: tx.waitForExpiry,
	}

	if tx.payerAccountID != nil {
		body.PayerAccountID = tx.payerAccountID._ToProtobuf()
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	if tx.schedulableBody != nil {
		body.ScheduledTransactionBody = tx.schedulableBody
	}

	if tx.expirationTime != nil {
		body.ExpirationTime = _TimeToProtobuf(*tx.expirationTime)
	}

	return body
}

func (tx *ScheduleCreateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetSchedule().CreateSchedule,
	}
}

func (tx *ScheduleCreateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: schedule_create_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

func TestIntegrationScheduleCreateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	keys := make([]PrivateKey, 2)
	pubKeys := make([]PublicKey, 2)

	for i := range keys {
		newKey, err := PrivateKeyGenerateEd25519()
		require.NoError(t, err)

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	keyList := NewKeyList().
		AddAllPublicKeys(pubKeys)

	createResponse, err := NewAccountCreateTransaction().
		SetKey(keyList).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(10)).
		Execute(env.Client)
	require.NoError(t, err)

	transactionReceipt, err := createResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transactionID := TransactionIDGenerate(env.OperatorID)
	newAccountID := *transactionReceipt.AccountID

	transferTx := NewTransferTransaction().
		SetTransactionID(transactionID).
		AddHbarTransfer(newAccountID, HbarFrom(-1, HbarUnits.Hbar)).
		AddHbarTransfer(env.Client.GetOperatorAccountID(), HbarFrom(1, HbarUnits.Hbar))

	scheduled, err := transferTx.Schedule()
	require.NoError(t, err)

	scheduleResponse, err := scheduled.
		SetExpirationTime(time.Now().Add(30 * time.Minute)).
		Execute(env.Client)
	require.NoError(t, err)

	scheduleRecord, err := scheduleResponse.GetRecord(env.Client)
	require.NoError(t, err)

	scheduleID := *scheduleRecord.Receipt.ScheduleID

	signTransaction, err := NewScheduleSignTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetScheduleID(scheduleID).
		FreezeWith(env.Client)

	signTransaction.Sign(keys[0])

	resp, err := signTransaction.Execute(env.Client)
	require.NoError(t, err)

	// Getting the receipt to make sure the signing executed properly
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Making sure the scheduled transaction executed properly with schedule info query
	info, err := NewScheduleInfoQuery().
		SetScheduleID(scheduleID).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	signTransaction, err = NewScheduleSignTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetScheduleID(scheduleID).
		FreezeWith(env.Client)

	// Signing the scheduled transaction
	signTransaction.Sign(keys[1])

	resp, err = signTransaction.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewScheduleInfoQuery().
		SetScheduleID(scheduleID).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	require.NotNil(t, info.ExecutedAt)
}

//
// func DisabledTestIntegrationScheduleCreateTransactionMultiSign(t *testing.T) {
// env := NewIntegrationTestEnv(t)
//
//	keys := make([]PrivateKey, 3)
//	pubKeys := make([]PublicKey, 3)
//
//	for i := range keys {
//		newKey, err := PrivateKeyGenerateEd25519()
//		require.NoError(t, err)
//
//		keys[i] = newKey
//		pubKeys[i] = newKey.PublicKey()
//	}
//
//	keyList := NewKeyList().
//		AddAllPublicKeys(pubKeys)
//
//	createResponse, err := NewAccountCreateTransaction().
//		SetKey(keyList).
//		SetInitialBalance(NewHbar(10)).
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	transactionReceipt, err := createResponse.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	transactionID := TransactionIDGenerate(env.Client.GetOperatorAccountID())
//
//	newAccountID := *transactionReceipt.AccountID
//
//	transferTx := NewTransferTransaction().
//		SetTransactionID(transactionID).
//		AddHbarTransfer(newAccountID, HbarFrom(-1, HbarUnits.Hbar)).
//		AddHbarTransfer(env.Client.GetOperatorAccountID(), HbarFrom(1, HbarUnits.Hbar))
//
//	scheduled, err := transferTx.Schedule()
//	require.NoError(t, err)
//
//	scheduleResponse, err := scheduled.Execute(env.Client)
//	require.NoError(t, err)
//
//	scheduleReceipt, err := scheduleResponse.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	scheduleID := *scheduleReceipt.ScheduleID
//
//	info, err := NewScheduleInfoQuery().
//		SetNodeAccountIDs([]AccountID{createResponse.NodeID}).
//		SetScheduleID(scheduleID).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	transfer, err := info.GetScheduledTransaction()
//	require.NoError(t, err)
//	assert.NotNil(t, transfer)
//
//	signTransaction, err := NewScheduleSignTransaction().
//		SetNodeAccountIDs([]AccountID{createResponse.NodeID}).
//		SetScheduleID(scheduleID).
//		FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	signTransaction.Sign(keys[0])
//	signTransaction.Sign(keys[1])
//	signTransaction.Sign(keys[2])
//
//	resp, err := signTransaction.Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	info2, err := NewScheduleInfoQuery().
//		SetScheduleID(scheduleID).
//		SetNodeAccountIDs([]AccountID{createResponse.NodeID}).
//		Execute(env.Client)
//	require.NoError(t, err)
//	assert.False(t, info2.ExecutedAt.IsZero())
//}
//
// func DisabledTestIntegrationScheduleDeleteTransactionCanExecute(t *testing.T) {
// env := NewIntegrationTestEnv(t)
//
//	key, err := GeneratePrivateKey()
//	key2, err := GeneratePrivateKey()
//	require.NoError(t, err)
//
//	createResponse, err := NewAccountCreateTransaction().
//		SetKey(key).
//		SetInitialBalance(NewHbar(10)).
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	transactionReceipt, err := createResponse.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	transactionID := TransactionIDGenerate(env.Client.GetOperatorAccountID())
//
//	newAccountID := *transactionReceipt.AccountID
//
//	transferTx := NewTransferTransaction().
//		SetTransactionID(transactionID).
//		AddHbarTransfer(newAccountID, HbarFrom(-1, HbarUnits.Hbar)).
//		AddHbarTransfer(env.Client.GetOperatorAccountID(), HbarFrom(1, HbarUnits.Hbar))
//
//	scheduled, err := transferTx.Schedule()
//	require.NoError(t, err)
//
//	fr, err := scheduled.SetAdminKey(key2).FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	scheduleResponse, err := fr.Sign(key2).Execute(env.Client)
//	require.NoError(t, err)
//
//	scheduleReceipt, err := scheduleResponse.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	scheduleID := *scheduleReceipt.ScheduleID
//
//	info, err := NewScheduleInfoQuery().
//		SetNodeAccountIDs([]AccountID{createResponse.NodeID}).
//		SetScheduleID(scheduleID).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	transfer, err := info.GetScheduledTransaction()
//	require.NoError(t, err)
//	assert.NotNil(t, transfer)
//	assert.Nil(t, info.ExecutedAt)
//	assert.Nil(t, info.DeletedAt)
//
//	tx2, err := NewScheduleDeleteTransaction().
//		SetScheduleID(scheduleID).
//		FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	resp, err := tx2.
//		Sign(key2).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	info2, err := NewScheduleInfoQuery().
//		SetScheduleID(scheduleID).
//		SetNodeAccountIDs([]AccountID{createResponse.NodeID}).
//		Execute(env.Client)
//	require.NoError(t, err)
//	assert.False(t, info2.DeletedAt.IsZero())
//}
//
// func DisabledTestIntegrationScheduleCreateTransactionCheckValidGetTransaction(t *testing.T) {
//	env := NewIntegrationTestEnv(t)
//
//	newKey, err := PrivateKeyGenerateEd25519()
//	require.NoError(t, err)
//
//	newBalance := NewHbar(1)
//
//	assert.Equal(t, HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)
//
//	transactionID := TransactionIDGenerate(env.Client.GetOperatorAccountID())
//
//	tx := NewAccountCreateTransaction().
//		SetTransactionID(transactionID).
//		SetKey(newKey.PublicKey()).
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetMaxTransactionFee(NewHbar(2)).
//		SetInitialBalance(newBalance)
//
//	require.NoError(t, err)
//
//	scheduleTx, err := tx.Schedule()
//	require.NoError(t, err)
//
//	resp, err := scheduleTx.
//		SetPayerAccountID(env.Client.GetOperatorAccountID()).
//		SetAdminKey(env.Client.GetOperatorPublicKey()).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	info, err := NewScheduleInfoQuery().
//		SetScheduleID(*receipt.ScheduleID).
//		SetQueryPayment(NewHbar(2)).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	infoTx, err := info.GetScheduledTransaction()
//	require.NoError(t, err)
//
//	assert.NotNil(t, infoTx)
//
//	switch createTx := infoTx.(type) {
//	case *AccountCreateTransaction:
//		assert.Equal(t, createTx.pbBody.GetCryptoCreateAccount().InitialBalance, uint64(NewHbar(1).tinybar))
//	}
//
//	tx2, err := NewScheduleDeleteTransaction().
//		SetScheduleID(*receipt.ScheduleID).
//		FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	resp, err = tx2.
//		Sign(newKey).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	assert.Error(t, err)
//	if err != nil {
//		assert.Equal(t, "exceptional receipt status: SCHEDULE_ALREADY_EXECUTED", err.Error())
//	}
//}
//
// func DisabledTestIntegrationScheduleCreateTransactionDuplicateFails(t *testing.T) {
//	env := NewIntegrationTestEnv(t)
//
//	key, err := GeneratePrivateKey()
//	key2, err := GeneratePrivateKey()
//	require.NoError(t, err)
//
//	createResponse, err := NewAccountCreateTransaction().
//		SetKey(key).
//		SetInitialBalance(NewHbar(10)).
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	transactionReceipt, err := createResponse.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	transactionID := TransactionIDGenerate(env.Client.GetOperatorAccountID())
//
//	newAccountID := *transactionReceipt.AccountID
//
//	transferTx := NewTransferTransaction().
//		SetTransactionID(transactionID).
//		AddHbarTransfer(newAccountID, HbarFrom(-1, HbarUnits.Hbar)).
//		AddHbarTransfer(env.Client.GetOperatorAccountID(), HbarFrom(1, HbarUnits.Hbar))
//
//	scheduled, err := transferTx.Schedule()
//	require.NoError(t, err)
//
//	fr, err := scheduled.SetAdminKey(key2).FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	fr.Sign(key2)
//
//	scheduleResponse, err := fr.Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = scheduleResponse.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	resp, err := fr.Execute(env.Client)
//	assert.Error(t, err)
//	if err != nil {
//		assert.Equal(t, fmt.Sprintf("exceptional precheck status DUPLICATE_TRANSACTION received for transaction %s", resp.TransactionID), err.Error())
//	}
//}
//
// func DisabledTestIntegrationScheduleCreateTransactionWithTransferTransaction(t *testing.T) {
//	env := NewIntegrationTestEnv(t)
//
//	key, err := GeneratePrivateKey()
//	require.NoError(t, err)
//
//	_Response, err := NewAccountCreateTransaction().
//		SetKey(key).
//		SetInitialBalance(NewHbar(2)).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	receipt, err := _Response.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	accountID := *receipt.AccountID
//
//	tx := NewTransferTransaction().
//		AddHbarTransfer(accountID, NewHbar(1).Negated()).
//		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(1))
//
//	scheduleTx, err := tx.Schedule()
//	require.NoError(t, err)
//
//	scheduleTx = scheduleTx.
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetPayerAccountID(env.Client.GetOperatorAccountID()).
//		SetAdminKey(env.Client.GetOperatorPublicKey()).
//		SetTransactionID(TransactionIDGenerate(env.Client.GetOperatorAccountID()))
//
//	_Response, err = scheduleTx.Execute(env.Client)
//	require.NoError(t, err)
//
//	receipt, err = _Response.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	scheduleID := *receipt.ScheduleID
//
//	scheduleSignTx, err := NewScheduleSignTransaction().
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetScheduleID(scheduleID).
//		FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	scheduleSignTx.Sign(key)
//
//	_Response, err = scheduleSignTx.Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = _Response.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	info, err := NewScheduleInfoQuery().
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetScheduleID(scheduleID).
//		Execute(env.Client)
//	require.NoError(t, err)
//	assert.NotNil(t, info.ExecutedAt)
//
//	err = CloseIntegrationTestEnv(env, nil)
//	require.NoError(t, err)
//}
//
// func DisabledTestIntegrationScheduledTokenNftTransferTransaction(t *testing.T) {
//	env := NewIntegrationTestEnv(t)
//
//	keys := make([]PrivateKey, 3)
//	pubKeys := make([]PublicKey, 3)
//
//	for i := range keys {
//		newKey, err := PrivateKeyGenerateEd25519()
//		require.NoError(t, err)
//
//		keys[i] = newKey
//		pubKeys[i] = newKey.PublicKey()
//	}
//
//	keyList := NewKeyList().
//		AddAllPublicKeys(pubKeys)
//
//	newBalance := NewHbar(2)
//
//	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)
//
//	resp, err := NewAccountCreateTransaction().
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetKey(keyList).
//		SetInitialBalance(newBalance).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	accountID := *receipt.AccountID
//
//	resp, err = fixme
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetTokenName("ffff").
//		SetTokenSymbol("F").
//		SetTokenType(TokenTypeNonFungibleUnique).
//		SetSupplyType(TokenSupplyTypeFinite).
//		SetMaxSupply(5).
//		SetTreasuryAccountID(env.Client.GetOperatorAccountID()).
//		SetAdminKey(env.Client.GetOperatorPublicKey()).
//		SetFreezeKey(env.Client.GetOperatorPublicKey()).
//		SetWipeKey(env.Client.GetOperatorPublicKey()).
//		SetKycKey(env.Client.GetOperatorPublicKey()).
//		SetSupplyKey(env.Client.GetOperatorPublicKey()).
//		SetFreezeDefault(false).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	tokenID := *receipt.TokenID
//	metaData := [][]byte{{50}, {50}}
//
//	mint, err := NewTokenMintTransaction().
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		SetTokenID(tokenID).
//		SetMetadatas(metaData).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	mintReceipt, err := mint.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	transaction, err := NewTokenAssociateTransaction().
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		SetAccountID(accountID).
//		SetTokenIDs(tokenID).
//		FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	resp, err = transaction.
//		Sign(keys[0]).
//		Sign(keys[1]).
//		Sign(keys[2]).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	resp, err = NewTokenGrantKycTransaction().
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		SetAccountID(accountID).
//		SetTokenID(tokenID).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	tx := NewTransferTransaction().
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[0]), env.OperatorID, accountID).
//		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[1]), env.OperatorID, accountID)
//
//	scheduleTx, err := tx.Schedule()
//	require.NoError(t, err)
//
//	scheduleTx = scheduleTx.
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetPayerAccountID(accountID).
//		SetAdminKey(env.OperatorKey).
//		SetTransactionID(TransactionIDGenerate(env.Client.GetOperatorAccountID()))
//
//	resp, err = scheduleTx.Execute(env.Client)
//	require.NoError(t, err)
//
//	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	scheduleID := *receipt.ScheduleID
//
//	info, err := NewScheduleInfoQuery().
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetScheduleID(scheduleID).
//		Execute(env.Client)
//	require.NoError(t, err)
//	assert.Equal(t, info.CreatorAccountID.String(), env.OperatorID.String())
//
//	signTransaction, err := NewScheduleSignTransaction().
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetScheduleID(scheduleID).
//		FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	signTransaction.Sign(keys[0])
//	signTransaction.Sign(keys[1])
//	signTransaction.Sign(keys[2])
//
//	resp, err = signTransaction.Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	info2, err := NewScheduleInfoQuery().
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetScheduleID(scheduleID).
//		Execute(env.Client)
//	require.NoError(t, err)
//	assert.NotNil(t, info2.ExecutedAt)
//
//	nftInfo, err := NewTokenNftInfoQuery().
//		ByNftID(tokenID.Nft(mintReceipt.SerialNumbers[0])).
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	assert.Equal(t, accountID.String(), nftInfo[0].AccountID.String())
//
//	err = CloseIntegrationTestEnv(env, &tokenID)
//	require.NoError(t, err)
//}
//
// func DisabledTestIntegrationScheduledTokenNftTransferTransactionSigned(t *testing.T) {
//	env := NewIntegrationTestEnv(t)
//
//	keys := make([]PrivateKey, 3)
//	pubKeys := make([]PublicKey, 3)
//
//	for i := range keys {
//		newKey, err := PrivateKeyGenerateEd25519()
//		require.NoError(t, err)
//
//		keys[i] = newKey
//		pubKeys[i] = newKey.PublicKey()
//	}
//
//	keyList := NewKeyList().
//		AddAllPublicKeys(pubKeys)
//
//	newBalance := NewHbar(2)
//
//	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)
//
//	resp, err := NewAccountCreateTransaction().
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetKey(keyList).
//		SetInitialBalance(newBalance).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	accountID := *receipt.AccountID
//
//	resp, err = fixme
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetTokenName("ffff").
//		SetTokenSymbol("F").
//		SetTokenType(TokenTypeNonFungibleUnique).
//		SetSupplyType(TokenSupplyTypeFinite).
//		SetMaxSupply(5).
//		SetTreasuryAccountID(env.Client.GetOperatorAccountID()).
//		SetAdminKey(env.Client.GetOperatorPublicKey()).
//		SetFreezeKey(env.Client.GetOperatorPublicKey()).
//		SetWipeKey(env.Client.GetOperatorPublicKey()).
//		SetKycKey(env.Client.GetOperatorPublicKey()).
//		SetSupplyKey(env.Client.GetOperatorPublicKey()).
//		SetFreezeDefault(false).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	tokenID := *receipt.TokenID
//	metaData := [][]byte{{50}, {50}}
//
//	mint, err := NewTokenMintTransaction().
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		SetTokenID(tokenID).
//		SetMetadatas(metaData).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	mintReceipt, err := mint.GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	transaction, err := NewTokenAssociateTransaction().
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		SetAccountID(accountID).
//		SetTokenIDs(tokenID).
//		FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	resp, err = transaction.
//		Sign(keys[0]).
//		Sign(keys[1]).
//		Sign(keys[2]).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	resp, err = NewTokenGrantKycTransaction().
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		SetAccountID(accountID).
//		SetTokenID(tokenID).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	tx := NewTransferTransaction().
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[0]), env.OperatorID, accountID).
//		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[1]), env.OperatorID, accountID)
//
//	scheduleTx, err := tx.Schedule()
//	require.NoError(t, err)
//
//	scheduleTx, err = scheduleTx.
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetPayerAccountID(accountID).
//		SetAdminKey(env.OperatorKey).
//		SetTransactionID(TransactionIDGenerate(env.Client.GetOperatorAccountID())).
//		FreezeWith(env.Client)
//	require.NoError(t, err)
//
//	scheduleTx.Sign(keys[0])
//	scheduleTx.Sign(keys[1])
//	scheduleTx.Sign(keys[2])
//
//	resp, err = scheduleTx.Execute(env.Client)
//	require.NoError(t, err)
//
//	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
//	require.NoError(t, err)
//
//	scheduleID := *receipt.ScheduleID
//
//	info2, err := NewScheduleInfoQuery().
//		SetNodeAccountIDs(env.NodeAccountIDs).
//		SetScheduleID(scheduleID).
//		Execute(env.Client)
//	require.NoError(t, err)
//	assert.NotNil(t, info2.ExecutedAt)
//
//	nftInfo, err := NewTokenNftInfoQuery().
//		ByNftID(tokenID.Nft(mintReceipt.SerialNumbers[0])).
//		SetNodeAccountIDs([]AccountID{resp.NodeID}).
//		Execute(env.Client)
//	require.NoError(t, err)
//
//	assert.Equal(t, accountID.String(), nftInfo[0].AccountID.String())
//
//	err = CloseIntegrationTestEnv(env, &tokenID)
//	require.NoError(t, err)
//}
// Filename: schedule_create_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitScheduleCreateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	scheduleCreate := NewScheduleCreateTransaction().
		SetPayerAccountID(accountID)

	err = scheduleCreate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitScheduleCreateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	scheduleCreate := NewScheduleCreateTransaction().
		SetPayerAccountID(accountID)

	err = scheduleCreate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitScheduleSignTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	scheduleID, err := ScheduleIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	err = scheduleID.Validate(client)
	require.NoError(t, err)
	scheduleSign := NewScheduleSignTransaction().
		SetScheduleID(scheduleID)

	err = scheduleSign.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitScheduleSignTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	scheduleID, err := ScheduleIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	err = scheduleID.Validate(client)
	require.Error(t, err)
	scheduleSign := NewScheduleSignTransaction().
		SetScheduleID(scheduleID)

	err = scheduleSign.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitScheduleDeleteTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	scheduleID, err := ScheduleIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	scheduleDelete := NewScheduleDeleteTransaction().
		SetScheduleID(scheduleID)

	err = scheduleDelete.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitScheduleDeleteTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	scheduleID, err := ScheduleIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	scheduleDelete := NewScheduleDeleteTransaction().
		SetScheduleID(scheduleID)

	err = scheduleDelete.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitScheduleCreateTransactionGet(t *testing.T) {
	t.Parallel()

	accountID := AccountID{Account: 7}

	newKey, err := PrivateKeyGenerateEd25519()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewScheduleCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetScheduledTransaction(NewTransferTransaction())

	transaction, err = transaction.
		SetPayerAccountID(accountID).
		SetAdminKey(newKey).
		SetScheduleMemo("").
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAdminKey()
	transaction.GetPayerAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetScheduleMemo()
}

func TestUnitScheduleCreateTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewScheduleCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAdminKey()
	transaction.GetPayerAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	transaction.GetScheduleMemo()
}

func TestUnitScheduleDeleteTransactionGet(t *testing.T) {
	t.Parallel()

	scheduleID := ScheduleID{Schedule: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewScheduleDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetScheduleID(scheduleID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetScheduleID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitScheduleDeleteTransactionSetNothing(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewScheduleDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetScheduleID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitScheduleCreateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	accountCreate, err := NewAccountCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		Freeze()
	require.NoError(t, err)

	transaction, err := NewScheduleCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(newKey).
		SetScheduleMemo("no").
		SetPayerAccountID(account).
		SetExpirationTime(time.Unix(3, 23)).
		SetWaitForExpiry(true).
		SetScheduledTransaction(accountCreate)
	require.NoError(t, err)

	transaction, err = transaction.
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	_, err = TransactionFromBytes(byt)
	require.NoError(t, err)
	_, err = newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetAdminKey()
	transaction.GetScheduleMemo()
	transaction.GetPayerAccountID()
	transaction.GetExpirationTime()
	transaction.GetWaitForExpiry()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	//switch b := txFromBytes.(type) {
	//case ScheduleCreateTransaction:
	//	b.AddSignature(newKey.PublicKey(), sig)
	//}
}

func TestUnitScheduleCreateTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	account := AccountID{Account: 3, checksum: &checksum}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	accountCreate, err := NewAccountCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		Freeze()
	require.NoError(t, err)

	freez, err := NewScheduleCreateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAdminKey(newKey).
		SetScheduleMemo("no").
		SetPayerAccountID(account).
		SetScheduledTransaction(accountCreate)
	require.NoError(t, err)

	_, err = freez.Execute(client)
	require.NoError(t, err)
}

func TestUnitScheduleDeleteTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	schedule := ScheduleID{Schedule: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewScheduleDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetScheduleID(schedule).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.validateNetworkOnIDs(client)

	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	_, err = TransactionFromBytes(byt)
	require.NoError(t, err)
	_, err = newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetScheduleID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	//switch b := txFromBytes.(type) {
	//case ScheduleDeleteTransaction:
	//	b.AddSignature(newKey.PublicKey(), sig)
	//}
}

func TestUnitScheduleDeleteTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	schedule := ScheduleID{Schedule: 3, checksum: &checksum}

	freez, err := NewScheduleDeleteTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetScheduleID(schedule).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: schedule_delete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"

	"time"
)

// ScheduleDeleteTransaction Marks a schedule in the network's action queue as deleted. Must be signed by the admin key of the
// target schedule.  A deleted schedule cannot receive any additional signing keys, nor will it be
// executed.
type ScheduleDeleteTransaction struct {
	Transaction
	scheduleID *ScheduleID
}

// NewScheduleDeleteTransaction creates ScheduleDeleteTransaction which marks a schedule in the network's action queue as deleted.
// Must be signed by the admin key of the target schedule.
// A deleted schedule cannot receive any additional signing keys, nor will it be executed.
func NewScheduleDeleteTransaction() *ScheduleDeleteTransaction {
	tx := ScheduleDeleteTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _ScheduleDeleteTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *ScheduleDeleteTransaction {
	return &ScheduleDeleteTransaction{
		Transaction: tx,
		scheduleID:  _ScheduleIDFromProtobuf(pb.GetScheduleDelete().GetScheduleID()),
	}
}

// SetScheduleID Sets the ScheduleID of the scheduled transaction to be deleted
func (tx *ScheduleDeleteTransaction) SetScheduleID(scheduleID ScheduleID) *ScheduleDeleteTransaction {
	tx._RequireNotFrozen()
	tx.scheduleID = &scheduleID
	return tx
}

func (tx *ScheduleDeleteTransaction) GetScheduleID() ScheduleID {
	if tx.scheduleID == nil {
		return ScheduleID{}
	}

	return *tx.scheduleID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *ScheduleDeleteTransaction) Sign(privateKey PrivateKey) *ScheduleDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *ScheduleDeleteTransaction) SignWithOperator(client *Client) (*ScheduleDeleteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *ScheduleDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *ScheduleDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *ScheduleDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *ScheduleDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *ScheduleDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *ScheduleDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *ScheduleDeleteTransaction) Freeze() (*ScheduleDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *ScheduleDeleteTransaction) FreezeWith(client *Client) (*ScheduleDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this ScheduleDeleteTransaction.
func (tx *ScheduleDeleteTransaction) SetMaxTransactionFee(fee Hbar) *ScheduleDeleteTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *ScheduleDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *ScheduleDeleteTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this ScheduleDeleteTransaction.
func (tx *ScheduleDeleteTransaction) SetTransactionMemo(memo string) *ScheduleDeleteTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this ScheduleDeleteTransaction.
func (tx *ScheduleDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *ScheduleDeleteTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *ScheduleDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this ScheduleDeleteTransaction.
func (tx *ScheduleDeleteTransaction) SetTransactionID(transactionID TransactionID) *ScheduleDeleteTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this ScheduleDeleteTransaction.
func (tx *ScheduleDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *ScheduleDeleteTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *ScheduleDeleteTransaction) SetMaxRetry(count int) *ScheduleDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *ScheduleDeleteTransaction) SetMaxBackoff(max time.Duration) *ScheduleDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *ScheduleDeleteTransaction) SetMinBackoff(min time.Duration) *ScheduleDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *ScheduleDeleteTransaction) SetLogLevel(level LogLevel) *ScheduleDeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *ScheduleDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *ScheduleDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *ScheduleDeleteTransaction) getName() string {
	return "ScheduleDeleteTransaction"
}

func (tx *ScheduleDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.scheduleID != nil {
		if err := tx.scheduleID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *ScheduleDeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ScheduleDelete{
			ScheduleDelete: tx.buildProtoBody(),
		},
	}
}

func (tx *ScheduleDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_ScheduleDelete{
			ScheduleDelete: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *ScheduleDeleteTransaction) buildProtoBody() *services.ScheduleDeleteTransactionBody {
	body := &services.ScheduleDeleteTransactionBody{}
	if tx.scheduleID != nil {
		body.ScheduleID = tx.scheduleID._ToProtobuf()
	}

	return body
}

func (tx *ScheduleDeleteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetSchedule().DeleteSchedule,
	}
}
func (tx *ScheduleDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: schedule_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"strings"

	"github.com/pkg/errors"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ScheduleID is the ID for a Hedera account
type ScheduleID struct {
	Shard    uint64
	Realm    uint64
	Schedule uint64
	checksum *string
}

// ScheduleIDFromString constructs an ScheduleID from a string formatted as
// `Shard.Realm.Account` (for example "0.0.3")
func ScheduleIDFromString(data string) (ScheduleID, error) {
	shard, realm, num, checksum, err := _IdFromString(data)
	if err != nil {
		return ScheduleID{}, err
	}

	return ScheduleID{
		Shard:    uint64(shard),
		Realm:    uint64(realm),
		Schedule: uint64(num),
		checksum: checksum,
	}, nil
}

// ValidateChecksum validates the checksum of the account ID
func (id *ScheduleID) ValidateChecksum(client *Client) error {
	if !id._IsZero() && client != nil {
		var tempChecksum _ParseAddressResult
		var err error
		tempChecksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Schedule))
		if err != nil {
			return err
		}
		err = _ChecksumVerify(tempChecksum.status)
		if err != nil {
			return err
		}
		if id.checksum == nil {
			return errChecksumMissing
		}
		if tempChecksum.correctChecksum != *id.checksum {
			networkName := NetworkNameOther
			if client.network.ledgerID != nil {
				networkName, _ = client.network.ledgerID.ToNetworkName()
			}
			return errors.New(fmt.Sprintf("network mismatch or wrong checksum given, given checksum: %s, correct checksum %s, network: %s",
				*id.checksum,
				tempChecksum.correctChecksum,
				networkName))
		}
	}

	return nil
}

// Deprecated - use ValidateChecksum instead
func (id *ScheduleID) Validate(client *Client) error {
	return id.ValidateChecksum(client)
}

// String returns the string representation of an ScheduleID in
// `Shard.Realm.Account` (for example "0.0.3")
func (id ScheduleID) String() string {
	return fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Schedule)
}

// ToStringWithChecksum returns the string representation of an ScheduleID in
// `Shard.Realm.Account-checksum` (for example "0.0.3-laujm")
func (id ScheduleID) ToStringWithChecksum(client Client) (string, error) {
	if client.GetNetworkName() == nil && client.GetLedgerID() == nil {
		return "", errNetworkNameMissing
	}
	var checksum _ParseAddressResult
	var err error
	if client.network.ledgerID != nil {
		checksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Schedule))
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%d.%d.%d-%s", id.Shard, id.Realm, id.Schedule, checksum.correctChecksum), nil
}

func (id ScheduleID) _ToProtobuf() *services.ScheduleID {
	return &services.ScheduleID{
		ShardNum:    int64(id.Shard),
		RealmNum:    int64(id.Realm),
		ScheduleNum: int64(id.Schedule),
	}
}

// UnmarshalJSON implements the encoding.JSON interface.
func (id *ScheduleID) UnmarshalJSON(data []byte) error {
	scheduleID, err := ScheduleIDFromString(strings.Replace(string(data), "\"", "", 2))

	if err != nil {
		return err
	}

	id.Shard = scheduleID.Shard
	id.Realm = scheduleID.Realm
	id.Schedule = scheduleID.Schedule
	id.checksum = scheduleID.checksum

	return nil
}

func _ScheduleIDFromProtobuf(scheduleID *services.ScheduleID) *ScheduleID {
	if scheduleID == nil {
		return nil
	}

	return &ScheduleID{
		Shard:    uint64(scheduleID.ShardNum),
		Realm:    uint64(scheduleID.RealmNum),
		Schedule: uint64(scheduleID.ScheduleNum),
	}
}

func (id ScheduleID) _IsZero() bool {
	return id.Shard == 0 && id.Realm == 0 && id.Schedule == 0
}

func (id ScheduleID) _Equals(other ScheduleID) bool { // nolint
	return id.Shard == other.Shard && id.Realm == other.Realm && id.Schedule == other.Schedule
}
// Filename: schedule_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
)

type ScheduleInfo struct {
	ScheduleID       ScheduleID
	CreatorAccountID AccountID
	PayerAccountID   AccountID
	ExecutedAt       *time.Time
	DeletedAt        *time.Time
	ExpirationTime   time.Time
	Signatories      *KeyList
	// Deprecated: Use ScheduleInfo.Signatories instead
	Signers                  *KeyList
	AdminKey                 Key
	Memo                     string
	ScheduledTransactionID   *TransactionID
	scheduledTransactionBody *services.SchedulableTransactionBody
	LedgerID                 LedgerID
	WaitForExpiry            bool
}

func _ScheduleInfoFromProtobuf(pb *services.ScheduleInfo) ScheduleInfo {
	if pb == nil {
		return ScheduleInfo{}
	}
	var adminKey Key
	if pb.AdminKey != nil {
		adminKey, _ = _KeyFromProtobuf(pb.AdminKey)
	}

	var signatories KeyList
	if pb.Signers != nil {
		signatories, _ = _KeyListFromProtobuf(pb.Signers)
	}

	var scheduledTransactionID TransactionID
	if pb.ScheduledTransactionID != nil {
		scheduledTransactionID = _TransactionIDFromProtobuf(pb.ScheduledTransactionID)
	}

	var executed *time.Time
	var deleted *time.Time
	switch t := pb.Data.(type) {
	case *services.ScheduleInfo_ExecutionTime:
		temp := _TimeFromProtobuf(t.ExecutionTime)
		executed = &temp
	case *services.ScheduleInfo_DeletionTime:
		temp := _TimeFromProtobuf(t.DeletionTime)
		deleted = &temp
	}

	creatorAccountID := AccountID{}
	if pb.CreatorAccountID != nil {
		creatorAccountID = *_AccountIDFromProtobuf(pb.CreatorAccountID)
	}

	payerAccountID := AccountID{}
	if pb.PayerAccountID != nil {
		payerAccountID = *_AccountIDFromProtobuf(pb.PayerAccountID)
	}

	scheduleID := ScheduleID{}
	if pb.ScheduleID != nil {
		scheduleID = *_ScheduleIDFromProtobuf(pb.ScheduleID)
	}

	return ScheduleInfo{
		ScheduleID:               scheduleID,
		CreatorAccountID:         creatorAccountID,
		PayerAccountID:           payerAccountID,
		ExecutedAt:               executed,
		DeletedAt:                deleted,
		ExpirationTime:           _TimeFromProtobuf(pb.ExpirationTime),
		Signatories:              &signatories,
		Signers:                  &signatories,
		AdminKey:                 adminKey,
		Memo:                     pb.Memo,
		ScheduledTransactionID:   &scheduledTransactionID,
		scheduledTransactionBody: pb.ScheduledTransactionBody,
		LedgerID:                 LedgerID{pb.LedgerId},
		WaitForExpiry:            pb.WaitForExpiry,
	}
}

func (scheduleInfo *ScheduleInfo) _ToProtobuf() *services.ScheduleInfo { // nolint
	var adminKey *services.Key
	if scheduleInfo.AdminKey != nil {
		adminKey = scheduleInfo.AdminKey._ToProtoKey()
	}

	var signatories *services.KeyList
	if scheduleInfo.Signatories != nil {
		signatories = scheduleInfo.Signatories._ToProtoKeyList()
	} else if scheduleInfo.Signers != nil {
		signatories = scheduleInfo.Signers._ToProtoKeyList()
	}

	info := &services.ScheduleInfo{
		ScheduleID:               scheduleInfo.ScheduleID._ToProtobuf(),
		ExpirationTime:           _TimeToProtobuf(scheduleInfo.ExpirationTime),
		ScheduledTransactionBody: scheduleInfo.scheduledTransactionBody,
		Memo:                     scheduleInfo.Memo,
		AdminKey:                 adminKey,
		Signers:                  signatories,
		CreatorAccountID:         scheduleInfo.CreatorAccountID._ToProtobuf(),
		PayerAccountID:           scheduleInfo.PayerAccountID._ToProtobuf(),
		ScheduledTransactionID:   scheduleInfo.ScheduledTransactionID._ToProtobuf(),
		LedgerId:                 scheduleInfo.LedgerID.ToBytes(),
		WaitForExpiry:            scheduleInfo.WaitForExpiry,
	}

	if scheduleInfo.ExecutedAt != nil {
		info.Data = &services.ScheduleInfo_DeletionTime{
			DeletionTime: _TimeToProtobuf(*scheduleInfo.DeletedAt),
		}
	} else if scheduleInfo.DeletedAt != nil {
		info.Data = &services.ScheduleInfo_ExecutionTime{
			ExecutionTime: _TimeToProtobuf(*scheduleInfo.ExecutedAt),
		}
	}

	return info
}

// GetScheduledTransaction returns the scheduled transaction associated with this schedule
func (scheduleInfo *ScheduleInfo) GetScheduledTransaction() (ITransaction, error) { // nolint
	pb := scheduleInfo.scheduledTransactionBody

	pbBody := &services.TransactionBody{
		TransactionFee: pb.TransactionFee,
		Memo:           pb.Memo,
	}

	tx := Transaction{
		transactionFee: pb.GetTransactionFee(),
		memo:           pb.GetMemo(),
	}

	switch pb.Data.(type) {
	case *services.SchedulableTransactionBody_ContractCall:
		pbBody.Data = &services.TransactionBody_ContractCall{
			ContractCall: pb.GetContractCall(),
		}

		tx2 := _ContractExecuteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_ContractCreateInstance:
		pbBody.Data = &services.TransactionBody_ContractCreateInstance{
			ContractCreateInstance: pb.GetContractCreateInstance(),
		}

		tx2 := _ContractCreateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_ContractUpdateInstance:
		pbBody.Data = &services.TransactionBody_ContractUpdateInstance{
			ContractUpdateInstance: pb.GetContractUpdateInstance(),
		}

		tx2 := _ContractUpdateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_ContractDeleteInstance:
		pbBody.Data = &services.TransactionBody_ContractDeleteInstance{
			ContractDeleteInstance: pb.GetContractDeleteInstance(),
		}

		tx2 := _ContractDeleteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_CryptoCreateAccount:
		pbBody.Data = &services.TransactionBody_CryptoCreateAccount{
			CryptoCreateAccount: pb.GetCryptoCreateAccount(),
		}

		tx2 := _AccountCreateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_CryptoDelete:
		pbBody.Data = &services.TransactionBody_CryptoDelete{
			CryptoDelete: pb.GetCryptoDelete(),
		}

		tx2 := _AccountDeleteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_CryptoTransfer:
		pbBody.Data = &services.TransactionBody_CryptoTransfer{
			CryptoTransfer: pb.GetCryptoTransfer(),
		}

		tx2 := _TransferTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_CryptoUpdateAccount:
		pbBody.Data = &services.TransactionBody_CryptoUpdateAccount{
			CryptoUpdateAccount: pb.GetCryptoUpdateAccount(),
		}

		tx2 := _AccountUpdateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_CryptoApproveAllowance:
		pbBody.Data = &services.TransactionBody_CryptoApproveAllowance{
			CryptoApproveAllowance: pb.GetCryptoApproveAllowance(),
		}

		tx2 := _AccountAllowanceApproveTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_CryptoDeleteAllowance:
		pbBody.Data = &services.TransactionBody_CryptoDeleteAllowance{
			CryptoDeleteAllowance: pb.GetCryptoDeleteAllowance(),
		}

		tx2 := _AccountAllowanceDeleteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_FileAppend:
		pbBody.Data = &services.TransactionBody_FileAppend{
			FileAppend: pb.GetFileAppend(),
		}

		tx2 := _FileAppendTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_FileCreate:
		pbBody.Data = &services.TransactionBody_FileCreate{
			FileCreate: pb.GetFileCreate(),
		}

		tx2 := _FileCreateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_FileDelete:
		pbBody.Data = &services.TransactionBody_FileDelete{
			FileDelete: pb.GetFileDelete(),
		}

		tx2 := _FileDeleteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_FileUpdate:
		pbBody.Data = &services.TransactionBody_FileUpdate{
			FileUpdate: pb.GetFileUpdate(),
		}

		tx2 := _FileUpdateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_SystemDelete:
		pbBody.Data = &services.TransactionBody_SystemDelete{
			SystemDelete: pb.GetSystemDelete(),
		}

		tx2 := _SystemDeleteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_SystemUndelete:
		pbBody.Data = &services.TransactionBody_SystemUndelete{
			SystemUndelete: pb.GetSystemUndelete(),
		}

		tx2 := _SystemUndeleteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_Freeze:
		pbBody.Data = &services.TransactionBody_Freeze{
			Freeze: pb.GetFreeze(),
		}

		tx2 := _FreezeTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_ConsensusCreateTopic:
		pbBody.Data = &services.TransactionBody_ConsensusCreateTopic{
			ConsensusCreateTopic: pb.GetConsensusCreateTopic(),
		}

		tx2 := _TopicCreateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_ConsensusUpdateTopic:
		pbBody.Data = &services.TransactionBody_ConsensusUpdateTopic{
			ConsensusUpdateTopic: pb.GetConsensusUpdateTopic(),
		}

		tx2 := _TopicUpdateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_ConsensusDeleteTopic:
		pbBody.Data = &services.TransactionBody_ConsensusDeleteTopic{
			ConsensusDeleteTopic: pb.GetConsensusDeleteTopic(),
		}

		tx2 := _TopicDeleteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_ConsensusSubmitMessage:
		pbBody.Data = &services.TransactionBody_ConsensusSubmitMessage{
			ConsensusSubmitMessage: pb.GetConsensusSubmitMessage(),
		}

		tx2 := _TopicMessageSubmitTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenCreation:
		pbBody.Data = &services.TransactionBody_TokenCreation{
			TokenCreation: pb.GetTokenCreation(),
		}

		tx2 := _TokenCreateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenFreeze:
		pbBody.Data = &services.TransactionBody_TokenFreeze{
			TokenFreeze: pb.GetTokenFreeze(),
		}

		tx2 := _TokenFreezeTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenUnfreeze:
		pbBody.Data = &services.TransactionBody_TokenUnfreeze{
			TokenUnfreeze: pb.GetTokenUnfreeze(),
		}

		tx2 := _TokenUnfreezeTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenFeeScheduleUpdate:
		pbBody.Data = &services.TransactionBody_TokenFeeScheduleUpdate{
			TokenFeeScheduleUpdate: pb.GetTokenFeeScheduleUpdate(),
		}

		tx2 := _TokenFeeScheduleUpdateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenGrantKyc:
		pbBody.Data = &services.TransactionBody_TokenGrantKyc{
			TokenGrantKyc: pb.GetTokenGrantKyc(),
		}

		tx2 := _TokenGrantKycTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenRevokeKyc:
		pbBody.Data = &services.TransactionBody_TokenRevokeKyc{
			TokenRevokeKyc: pb.GetTokenRevokeKyc(),
		}

		tx2 := _TokenRevokeKycTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenDeletion:
		pbBody.Data = &services.TransactionBody_TokenDeletion{
			TokenDeletion: pb.GetTokenDeletion(),
		}

		tx2 := _TokenDeleteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenUpdate:
		pbBody.Data = &services.TransactionBody_TokenUpdate{
			TokenUpdate: pb.GetTokenUpdate(),
		}

		tx2 := _TokenUpdateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenMint:
		pbBody.Data = &services.TransactionBody_TokenMint{
			TokenMint: pb.GetTokenMint(),
		}

		tx2 := _TokenMintTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenBurn:
		pbBody.Data = &services.TransactionBody_TokenBurn{
			TokenBurn: pb.GetTokenBurn(),
		}

		tx2 := _TokenBurnTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenWipe:
		pbBody.Data = &services.TransactionBody_TokenWipe{
			TokenWipe: pb.GetTokenWipe(),
		}

		tx2 := _TokenWipeTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenAssociate:
		pbBody.Data = &services.TransactionBody_TokenAssociate{
			TokenAssociate: pb.GetTokenAssociate(),
		}

		tx2 := _TokenAssociateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_TokenDissociate:
		pbBody.Data = &services.TransactionBody_TokenDissociate{
			TokenDissociate: pb.GetTokenDissociate(),
		}

		tx2 := _TokenDissociateTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_ScheduleDelete:
		pbBody.Data = &services.TransactionBody_ScheduleDelete{
			ScheduleDelete: pb.GetScheduleDelete(),
		}

		tx2 := _ScheduleDeleteTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	case *services.SchedulableTransactionBody_UtilPrng:
		pbBody.Data = &services.TransactionBody_UtilPrng{
			UtilPrng: pb.GetUtilPrng(),
		}

		tx2 := _PrngTransactionFromProtobuf(tx, pbBody)
		return tx2, nil
	default:
		return nil, errors.New("(BUG) non-exhaustive switch statement")
	}
}
// Filename: schedule_info_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ScheduleInfoQuery Gets information about a schedule in the network's action queue.
type ScheduleInfoQuery struct {
	Query
	scheduleID *ScheduleID
}

// NewScheduleInfoQuery creates ScheduleInfoQuery which gets information about a schedule in the network's action queue.
func NewScheduleInfoQuery() *ScheduleInfoQuery {
	header := services.QueryHeader{}
	return &ScheduleInfoQuery{
		Query: _NewQuery(true, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *ScheduleInfoQuery) SetGrpcDeadline(deadline *time.Duration) *ScheduleInfoQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetScheduleID Sets the id of the schedule to interrogate
func (q *ScheduleInfoQuery) SetScheduleID(scheduleID ScheduleID) *ScheduleInfoQuery {
	q.scheduleID = &scheduleID
	return q
}

// GetScheduleID returns the id of the schedule to interrogate
func (q *ScheduleInfoQuery) GetScheduleID() ScheduleID {
	if q.scheduleID == nil {
		return ScheduleID{}
	}

	return *q.scheduleID
}

func (q *ScheduleInfoQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *ScheduleInfoQuery) Execute(client *Client) (ScheduleInfo, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return ScheduleInfo{}, err
	}

	return _ScheduleInfoFromProtobuf(resp.GetScheduleGetInfo().ScheduleInfo), nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *ScheduleInfoQuery) SetMaxQueryPayment(maxPayment Hbar) *ScheduleInfoQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *ScheduleInfoQuery) SetQueryPayment(paymentAmount Hbar) *ScheduleInfoQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this ScheduleInfoQuery.
func (q *ScheduleInfoQuery) SetNodeAccountIDs(accountID []AccountID) *ScheduleInfoQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *ScheduleInfoQuery) SetMaxRetry(count int) *ScheduleInfoQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *ScheduleInfoQuery) SetMaxBackoff(max time.Duration) *ScheduleInfoQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *ScheduleInfoQuery) SetMinBackoff(min time.Duration) *ScheduleInfoQuery {
	q.Query.SetMinBackoff(min)
	return q
}

func (q *ScheduleInfoQuery) SetPaymentTransactionID(transactionID TransactionID) *ScheduleInfoQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *ScheduleInfoQuery) SetLogLevel(level LogLevel) *ScheduleInfoQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *ScheduleInfoQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetSchedule().GetScheduleInfo,
	}
}

func (q *ScheduleInfoQuery) getName() string {
	return "ScheduleInfoQuery"
}

func (q *ScheduleInfoQuery) buildQuery() *services.Query {
	body := &services.ScheduleGetInfoQuery{
		Header: q.pbHeader,
	}

	if q.scheduleID != nil {
		body.ScheduleID = q.scheduleID._ToProtobuf()
	}

	return &services.Query{
		Query: &services.Query_ScheduleGetInfo{
			ScheduleGetInfo: body,
		},
	}
}

func (q *ScheduleInfoQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.scheduleID != nil {
		if err := q.scheduleID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *ScheduleInfoQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetScheduleGetInfo()
}
// Filename: schedule_info_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitScheduleInfoQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	scheduleID, err := ScheduleIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	scheduleInfo := NewScheduleInfoQuery().
		SetScheduleID(scheduleID)

	err = scheduleInfo.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitScheduleInfoQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	scheduleID, err := ScheduleIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	scheduleInfo := NewScheduleInfoQuery().
		SetScheduleID(scheduleID)

	err = scheduleInfo.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitScheduleInfoQueryGet(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	accountId := AccountID{Account: 123}
	deadline := time.Duration(time.Minute)
	validStart := time.Now().Add(10 * time.Minute)
	scheduleID := ScheduleID{Schedule: 3, checksum: &checksum}

	query := NewScheduleInfoQuery().
		SetScheduleID(scheduleID).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}}).
		SetMaxRetry(3).
		SetMinBackoff(300 * time.Millisecond).
		SetMaxBackoff(10 * time.Second).
		SetPaymentTransactionID(TransactionID{AccountID: &accountId, ValidStart: &validStart}).
		SetMaxQueryPayment(NewHbar(500)).
		SetGrpcDeadline(&deadline)
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)
	require.Equal(t, scheduleID, query.GetScheduleID())
	require.Equal(t, []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}, query.GetNodeAccountIDs())
	require.Equal(t, 300*time.Millisecond, query.GetMinBackoff())
	require.Equal(t, 10*time.Second, query.GetMaxBackoff())
	require.Equal(t, 3, query.GetMaxRetryCount())
	require.Equal(t, TransactionID{AccountID: &AccountID{Account: 123}, ValidStart: &validStart}, query.GetPaymentTransactionID())
	require.Equal(t, HbarFromTinybar(25), query.GetQueryPayment())
	require.Equal(t, NewHbar(500), query.GetMaxQueryPayment())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}

func TestUnitScheduleInfoQuerySetNothing(t *testing.T) {
	t.Parallel()

	info := NewScheduleInfoQuery()

	require.Equal(t, ScheduleID{}, info.GetScheduleID())
	require.Equal(t, []AccountID{}, info.GetNodeAccountIDs())
	require.Equal(t, 250*time.Millisecond, info.GetMinBackoff())
	require.Equal(t, 8*time.Second, info.GetMaxBackoff())
	require.Equal(t, 10, info.GetMaxRetryCount())
	require.Equal(t, TransactionID{}, info.GetPaymentTransactionID())
	require.Equal(t, Hbar{}, info.GetQueryPayment())
	require.Equal(t, Hbar{}, info.GetMaxQueryPayment())
}

func TestUnitScheduleInfoQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	deadline := time.Second * 3
	schedule := ScheduleID{Schedule: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewScheduleInfoQuery().
		SetScheduleID(schedule).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3)).
		SetGrpcDeadline(&deadline)

	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)

	require.Equal(t, nodeAccountID, query.GetNodeAccountIDs())
	require.Equal(t, 30*time.Second, query.GetMaxBackoff())
	require.Equal(t, 10*time.Second, query.GetMinBackoff())
	require.NotEmpty(t, query.getName())
	require.Equal(t, schedule, query.GetScheduleID())
	require.Equal(t, NewHbar(3), query.GetQueryPayment())
	require.Equal(t, NewHbar(23), query.GetMaxQueryPayment())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}

func TestUnitScheduleInfoQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_ScheduleGetInfo{
				ScheduleGetInfo: &services.ScheduleGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_ScheduleGetInfo{
				ScheduleGetInfo: &services.ScheduleGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_ScheduleGetInfo{
				ScheduleGetInfo: &services.ScheduleGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					ScheduleInfo: &services.ScheduleInfo{
						ScheduleID:               nil,
						Data:                     nil,
						ExpirationTime:           nil,
						ScheduledTransactionBody: nil,
						Memo:                     "",
						AdminKey:                 nil,
						Signers:                  nil,
						CreatorAccountID:         nil,
						PayerAccountID:           nil,
						ScheduledTransactionID:   nil,
						LedgerId:                 nil,
						WaitForExpiry:            false,
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewScheduleInfoQuery().
		SetScheduleID(ScheduleID{Schedule: 3}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMaxQueryPayment(NewHbar(1))

	cost, err := query.GetCost(client)
	require.NoError(t, err)
	require.Equal(t, HbarFromTinybar(2), cost)
	_, err = query.Execute(client)
	require.NoError(t, err)
}
// Filename: schedule_sign_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/pkg/errors"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// ScheduleSignTransaction Adds zero or more signing keys to a schedule.
// If Long Term Scheduled Transactions are enabled and wait for expiry was set to true on the
// ScheduleCreate then the transaction will always wait till it's `expiration_time` to execute.
// Otherwise, if the resulting set of signing keys satisfy the
// scheduled transaction's signing requirements, it will be executed immediately after the
// triggering ScheduleSign.
// Upon SUCCESS, the receipt includes the scheduledTransactionID to use to query
// for the record of the scheduled transaction's execution (if it occurs).
type ScheduleSignTransaction struct {
	Transaction
	scheduleID *ScheduleID
}

// NewScheduleSignTransaction creates ScheduleSignTransaction which adds zero or more signing keys to a schedule.
// If Long Term Scheduled Transactions are enabled and wait for expiry was set to true on the
// ScheduleCreate then the transaction will always wait till it's `expiration_time` to execute.
// Otherwise, if the resulting set of signing keys satisfy the
// scheduled transaction's signing requirements, it will be executed immediately after the
// triggering ScheduleSign.
// Upon SUCCESS, the receipt includes the scheduledTransactionID to use to query
// for the record of the scheduled transaction's execution (if it occurs).
func NewScheduleSignTransaction() *ScheduleSignTransaction {
	tx := ScheduleSignTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _ScheduleSignTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *ScheduleSignTransaction {
	return &ScheduleSignTransaction{
		Transaction: tx,
		scheduleID:  _ScheduleIDFromProtobuf(pb.GetScheduleSign().GetScheduleID()),
	}
}

// SetScheduleID Sets the id of the schedule to add signing keys to
func (tx *ScheduleSignTransaction) SetScheduleID(scheduleID ScheduleID) *ScheduleSignTransaction {
	tx._RequireNotFrozen()
	tx.scheduleID = &scheduleID
	return tx
}

// GetScheduleID returns the id of the schedule to add signing keys to
func (tx *ScheduleSignTransaction) GetScheduleID() ScheduleID {
	if tx.scheduleID == nil {
		return ScheduleID{}
	}

	return *tx.scheduleID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *ScheduleSignTransaction) Sign(privateKey PrivateKey) *ScheduleSignTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *ScheduleSignTransaction) SignWithOperator(client *Client) (*ScheduleSignTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *ScheduleSignTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *ScheduleSignTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *ScheduleSignTransaction) AddSignature(publicKey PublicKey, signature []byte) *ScheduleSignTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *ScheduleSignTransaction) SetGrpcDeadline(deadline *time.Duration) *ScheduleSignTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *ScheduleSignTransaction) Freeze() (*ScheduleSignTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *ScheduleSignTransaction) FreezeWith(client *Client) (*ScheduleSignTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this ScheduleSignTransaction.
func (tx *ScheduleSignTransaction) SetMaxTransactionFee(fee Hbar) *ScheduleSignTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *ScheduleSignTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *ScheduleSignTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this ScheduleSignTransaction.
func (tx *ScheduleSignTransaction) SetTransactionMemo(memo string) *ScheduleSignTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this ScheduleSignTransaction.
func (tx *ScheduleSignTransaction) SetTransactionValidDuration(duration time.Duration) *ScheduleSignTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *ScheduleSignTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this ScheduleSignTransaction.
func (tx *ScheduleSignTransaction) SetTransactionID(transactionID TransactionID) *ScheduleSignTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this ScheduleSignTransaction.
func (tx *ScheduleSignTransaction) SetNodeAccountIDs(nodeID []AccountID) *ScheduleSignTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *ScheduleSignTransaction) SetMaxRetry(count int) *ScheduleSignTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *ScheduleSignTransaction) SetMaxBackoff(max time.Duration) *ScheduleSignTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *ScheduleSignTransaction) SetMinBackoff(min time.Duration) *ScheduleSignTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *ScheduleSignTransaction) SetLogLevel(level LogLevel) *ScheduleSignTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *ScheduleSignTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *ScheduleSignTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *ScheduleSignTransaction) getName() string {
	return "ScheduleSignTransaction"
}

func (tx *ScheduleSignTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.scheduleID != nil {
		if err := tx.scheduleID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *ScheduleSignTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ScheduleSign{
			ScheduleSign: tx.buildProtoBody(),
		},
	}
}

func (tx *ScheduleSignTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return nil, errors.New("cannot schedule `ScheduleSignTransaction")
}

func (tx *ScheduleSignTransaction) buildProtoBody() *services.ScheduleSignTransactionBody {
	body := &services.ScheduleSignTransactionBody{}
	if tx.scheduleID != nil {
		body.ScheduleID = tx.scheduleID._ToProtobuf()
	}

	return body
}

func (tx *ScheduleSignTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetSchedule().SignSchedule,
	}
}

func (tx *ScheduleSignTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: schedule_sign_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
	protobuf "google.golang.org/protobuf/proto"
)

func TestUnitScheduleSignTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	schedule := ScheduleID{Schedule: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewScheduleSignTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetScheduleID(schedule).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.Sign(newKey)

	transaction.validateNetworkOnIDs(client)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	_, err = TransactionFromBytes(byt)
	require.NoError(t, err)
	_, err = newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetScheduleID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	//switch b := txFromBytes.(type) {
	//case ScheduleSignTransaction:
	//	b.AddSignature(newKey.PublicKey(), sig)
	//}
}

func TestUnitScheduleSignTransactionMock(t *testing.T) {
	t.Parallel()

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	schedule := ScheduleID{Schedule: 3, checksum: &checksum}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewScheduleSignTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetScheduleID(schedule).
		Freeze()
	require.NoError(t, err)

	transaction, err = transaction.SignWithOperator(client)
	require.NoError(t, err)

	_, err = transaction.Execute(client)
	require.NoError(t, err)
}
// Filename: semantic_version.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

type SemanticVersion struct {
	Major uint32
	Minor uint32
	Patch uint32
	Pre   string
	Build string
}

func _SemanticVersionFromProtobuf(version *services.SemanticVersion) SemanticVersion {
	if version == nil {
		return SemanticVersion{}
	}
	return SemanticVersion{
		Major: uint32(version.GetMajor()),
		Minor: uint32(version.GetMinor()),
		Patch: uint32(version.GetPatch()),
		Pre:   version.GetPre(),
		Build: version.GetBuild(),
	}
}

func (version *SemanticVersion) _ToProtobuf() *services.SemanticVersion {
	return &services.SemanticVersion{
		Major: int32(version.Major),
		Minor: int32(version.Minor),
		Patch: int32(version.Patch),
		Pre:   version.Pre,
		Build: version.Build,
	}
}
// Filename: serialize_deserialize_test.go
//go:build all || e2e
// +build all e2e

package hedera

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestIntegrationSerializeTransactionDeserializeAndAgainSerializeHasTheSameBytesFreezeBeforeSer(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	env := NewIntegrationTestEnv(t)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	transactionOriginal, _ := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).SignWithOperator(env.Client)
	transactionOriginal, _ = transactionOriginal.FreezeWith(env.Client)

	require.NoError(t, err)
	firstBytes, _ := transactionOriginal.ToBytes()

	txFromBytes, err := TransactionFromBytes(firstBytes)
	require.NoError(t, err)

	transaction := txFromBytes.(AccountCreateTransaction)
	secondBytes, err := transaction.ToBytes()
	require.NoError(t, err)

	assert.Equal(t, firstBytes, secondBytes)
}

func TestIntegrationSerializeTransactionDeserializeAndAgainSerializeHasTheSameBytesDontFreeze(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)
	originalTransaction := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance)
	firstBytes, err := originalTransaction.ToBytes()
	require.NoError(t, err)

	txFromBytes, err := TransactionFromBytes(firstBytes)
	require.NoError(t, err)
	transaction := txFromBytes.(AccountCreateTransaction)

	secondBytes, err := transaction.ToBytes()
	require.NoError(t, err)

	assert.Equal(t, firstBytes, secondBytes)
}

func TestIntegrationAddSignatureSerializeDeserializeAddAnotherSignatureExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Generate new key to use with new account
	newKey, err := GeneratePrivateKey()
	if err != nil {
		panic(err)
	}
	resp, err := NewAccountCreateTransaction().SetKey(newKey).Execute(env.Client)
	receipt, err := resp.GetReceipt(env.Client)
	newAccountId := *receipt.AccountID

	// Prepare and sign the tx and send it to be signed by another actor
	txBefore := NewTransferTransaction().SetTransactionMemo("Serialize/Deserialize transaction test").AddHbarTransfer(env.OperatorID, NewHbar(-1)).AddHbarTransfer(newAccountId, NewHbar(1)).
		Sign(env.OperatorKey)

	bytes, err := txBefore.ToBytes()

	FromBytes, err := TransactionFromBytes(bytes)
	if err != nil {
		panic(err)
	}
	txFromBytes := FromBytes.(TransferTransaction)
	// Assert the fields are the same:
	assert.Equal(t, txFromBytes.signedTransactions._Length(), txBefore.signedTransactions._Length())
	assert.Equal(t, txFromBytes.memo, txBefore.memo)

	frozenTx, err := txFromBytes.FreezeWith(env.Client)
	require.NoError(t, err)

	executed, err := frozenTx.Sign(newKey).Execute(env.Client)
	if err != nil {
		panic(err)
	}
	receipt, err = executed.GetReceipt(env.Client)
	assert.Equal(t, receipt.Status, StatusSuccess)
	if err != nil {
		panic(err)
	}
}

func TestIntegrationTransactionShouldReturnFailedReceiptWhenFieldsAreNotSet(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Prepare and sign the tx and send it to be signed by another actor
	txBefore := NewTransferTransaction().SetTransactionMemo("Serialize/Deserialize transaction test").AddHbarTransfer(env.OperatorID, NewHbar(-1)).
		Sign(env.OperatorKey)

	bytes, err := txBefore.ToBytes()

	FromBytes, err := TransactionFromBytes(bytes)
	if err != nil {
		panic(err)
	}
	txFromBytes := FromBytes.(TransferTransaction)
	// Assert the fields are the same:
	assert.Equal(t, txFromBytes.signedTransactions._Length(), txBefore.signedTransactions._Length())
	assert.Equal(t, txFromBytes.memo, txBefore.memo)

	_, err = txFromBytes.Execute(env.Client)
	assert.Error(t, err)
}

func TestIntegrationAddSignatureSerializeDeserialiseExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(*receipt.AccountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)
	updateBytes, err := tx.ToBytes()
	require.NoError(t, err)

	sig1, err := newKey.SignTransaction(&tx.Transaction)
	require.NoError(t, err)

	tx2, err := TransactionFromBytes(updateBytes)
	require.NoError(t, err)

	if newTx, ok := tx2.(AccountDeleteTransaction); ok {
		assert.True(t, newTx.IsFrozen())
		resp, err = newTx.AddSignature(newKey.PublicKey(), sig1).Execute(env.Client)
		require.NoError(t, err)
	}

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)

}

func TestIntegrationTopicCreateTransactionAfterSerialization(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tx := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetSubmitKey(env.Client.GetOperatorPublicKey()).
		SetTopicMemo(topicMemo)

	// Serialize unfinished transaction
	bytes, err := tx.ToBytes()

	fromBytes, err := TransactionFromBytes(bytes)
	require.NoError(t, err)
	// Deserialize and add node accounts transaction
	transaction := fromBytes.(TopicCreateTransaction)
	resp, err := transaction.SetNodeAccountIDs(env.NodeAccountIDs).Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	info, err := NewTopicInfoQuery().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, info)

	assert.Equal(t, topicMemo, info.TopicMemo)
	assert.Equal(t, uint64(0), info.SequenceNumber)
	assert.Equal(t, env.Client.GetOperatorPublicKey().String(), info.AdminKey.String())

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicSubmitTransactionSerializationDeserialization(t *testing.T) {
	const bigContents2 = `
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.

Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.

Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.
`

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tx := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetSubmitKey(env.Client.GetOperatorPublicKey()).
		SetTopicMemo(topicMemo)

	// Serialize unfinished transaction
	bytes, err := tx.ToBytes()

	fromBytes, err := TransactionFromBytes(bytes)
	require.NoError(t, err)
	// Deserialize and add node accounts transaction
	transaction := fromBytes.(TopicCreateTransaction)
	resp, err := transaction.SetNodeAccountIDs(env.NodeAccountIDs).Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	submitBytes, err := NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMessage([]byte(bigContents2)).
		SetTopicID(topicID).ToBytes()
	require.NoError(t, err)

	fromBytes, err = TransactionFromBytes(submitBytes)
	require.NoError(t, err)

	topicSubmitTx := fromBytes.(TopicMessageSubmitTransaction)
	_, err = topicSubmitTx.Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: staking_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

type StakingInfo struct {
	DeclineStakingReward bool
	StakePeriodStart     *time.Time
	PendingReward        int64
	PendingHbarReward    Hbar
	StakedToMe           Hbar
	StakedAccountID      *AccountID
	StakedNodeID         *int64
}

func _StakingInfoFromProtobuf(pb *services.StakingInfo) StakingInfo {
	var start time.Time
	if pb.StakePeriodStart != nil {
		start = _TimeFromProtobuf(pb.StakePeriodStart)
	}

	body := StakingInfo{
		DeclineStakingReward: pb.DeclineReward,
		StakePeriodStart:     &start,
		PendingReward:        pb.PendingReward,
		PendingHbarReward:    HbarFromTinybar(pb.PendingReward),
		StakedToMe:           HbarFromTinybar(pb.StakedToMe),
	}

	switch temp := pb.StakedId.(type) {
	case *services.StakingInfo_StakedAccountId:
		body.StakedAccountID = _AccountIDFromProtobuf(temp.StakedAccountId)
	case *services.StakingInfo_StakedNodeId:
		body.StakedNodeID = &temp.StakedNodeId
	}

	return body
}

func (stakingInfo *StakingInfo) _ToProtobuf() *services.StakingInfo { // nolint
	var pendingReward int64

	if stakingInfo.PendingReward > 0 {
		pendingReward = stakingInfo.PendingReward
	} else {
		pendingReward = stakingInfo.PendingHbarReward.AsTinybar()
	}

	body := services.StakingInfo{
		DeclineReward: stakingInfo.DeclineStakingReward,
		PendingReward: pendingReward,
		StakedToMe:    stakingInfo.StakedToMe.AsTinybar(),
	}

	if stakingInfo.StakePeriodStart != nil {
		body.StakePeriodStart = _TimeToProtobuf(*stakingInfo.StakePeriodStart)
	}

	if stakingInfo.StakedAccountID != nil {
		body.StakedId = &services.StakingInfo_StakedAccountId{StakedAccountId: stakingInfo.StakedAccountID._ToProtobuf()}
	} else if stakingInfo.StakedNodeID != nil {
		body.StakedId = &services.StakingInfo_StakedNodeId{StakedNodeId: *stakingInfo.StakedNodeID}
	}

	return &body
}

// ToBytes returns the byte representation of the StakingInfo
func (stakingInfo *StakingInfo) ToBytes() []byte {
	data, err := protobuf.Marshal(stakingInfo._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// StakingInfoFromBytes returns a StakingInfo object from a raw byte array
func StakingInfoFromBytes(data []byte) (StakingInfo, error) {
	if data == nil {
		return StakingInfo{}, errByteArrayNull
	}
	pb := services.StakingInfo{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return StakingInfo{}, err
	}

	info := _StakingInfoFromProtobuf(&pb)

	return info, nil
}
// Filename: status.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import "fmt"

type Status uint32

const (
	StatusOk                                                       Status = 0
	StatusInvalidTransaction                                       Status = 1
	StatusPayerAccountNotFound                                     Status = 2
	StatusInvalidNodeAccount                                       Status = 3
	StatusTransactionExpired                                       Status = 4
	StatusInvalidTransactionStart                                  Status = 5
	StatusInvalidTransactionDuration                               Status = 6
	StatusInvalidSignature                                         Status = 7
	StatusMemoTooLong                                              Status = 8
	StatusInsufficientTxFee                                        Status = 9
	StatusInsufficientPayerBalance                                 Status = 10
	StatusDuplicateTransaction                                     Status = 11
	StatusBusy                                                     Status = 12
	StatusNotSupported                                             Status = 13
	StatusInvalidFileID                                            Status = 14
	StatusInvalidAccountID                                         Status = 15
	StatusInvalidContractID                                        Status = 16
	StatusInvalidTransactionID                                     Status = 17
	StatusReceiptNotFound                                          Status = 18
	StatusRecordNotFound                                           Status = 19
	StatusInvalidSolidityID                                        Status = 20
	StatusUnknown                                                  Status = 21
	StatusSuccess                                                  Status = 22
	StatusFailInvalid                                              Status = 23
	StatusFailFee                                                  Status = 24
	StatusFailBalance                                              Status = 25
	StatusKeyRequired                                              Status = 26
	StatusBadEncoding                                              Status = 27
	StatusInsufficientAccountBalance                               Status = 28
	StatusInvalidSolidityAddress                                   Status = 29
	StatusInsufficientGas                                          Status = 30
	StatusContractSizeLimitExceeded                                Status = 31
	StatusLocalCallModificationException                           Status = 32
	StatusContractRevertExecuted                                   Status = 33
	StatusContractExecutionException                               Status = 34
	StatusInvalidReceivingNodeAccount                              Status = 35
	StatusMissingQueryHeader                                       Status = 36
	StatusAccountUpdateFailed                                      Status = 37
	StatusInvalidKeyEncoding                                       Status = 38
	StatusNullSolidityAddress                                      Status = 39
	StatusContractUpdateFailed                                     Status = 40
	StatusInvalidQueryHeader                                       Status = 41
	StatusInvalidFeeSubmitted                                      Status = 42
	StatusInvalidPayerSignature                                    Status = 43
	StatusKeyNotProvided                                           Status = 44
	StatusInvalidExpirationTime                                    Status = 45
	StatusNoWaclKey                                                Status = 46
	StatusFileContentEmpty                                         Status = 47
	StatusInvalidAccountAmounts                                    Status = 48
	StatusEmptyTransactionBody                                     Status = 49
	StatusInvalidTransactionBody                                   Status = 50
	StatusInvalidSignatureTypeMismatchingKey                       Status = 51
	StatusInvalidSignatureCountMismatchingKey                      Status = 52
	StatusEmptyLiveHashBody                                        Status = 53
	StatusEmptyLiveHash                                            Status = 54
	StatusEmptyLiveHashKeys                                        Status = 55
	StatusInvalidLiveHashSize                                      Status = 56
	StatusEmptyQueryBody                                           Status = 57
	StatusEmptyLiveHashQuery                                       Status = 58
	StatusLiveHashNotFound                                         Status = 59
	StatusAccountIDDoesNotExist                                    Status = 60
	StatusLiveHashAlreadyExists                                    Status = 61
	StatusInvalidFileWacl                                          Status = 62
	StatusSerializationFailed                                      Status = 63
	StatusTransactionOversize                                      Status = 64
	StatusTransactionTooManyLayers                                 Status = 65
	StatusContractDeleted                                          Status = 66
	StatusPlatformNotActive                                        Status = 67
	StatusKeyPrefixMismatch                                        Status = 68
	StatusPlatformTransactionNotCreated                            Status = 69
	StatusInvalidRenewalPeriod                                     Status = 70
	StatusInvalidPayerAccountID                                    Status = 71
	StatusAccountDeleted                                           Status = 72
	StatusFileDeleted                                              Status = 73
	StatusAccountRepeatedInAccountAmounts                          Status = 74
	StatusSettingNegativeAccountBalance                            Status = 75
	StatusObtainerRequired                                         Status = 76
	StatusObtainerSameContractID                                   Status = 77
	StatusObtainerDoesNotExist                                     Status = 78
	StatusModifyingImmutableContract                               Status = 79
	StatusFileSystemException                                      Status = 80
	StatusAutorenewDurationNotInRange                              Status = 81
	StatusErrorDecodingBytestring                                  Status = 82
	StatusContractFileEmpty                                        Status = 83
	StatusContractBytecodeEmpty                                    Status = 84
	StatusInvalidInitialBalance                                    Status = 85
	StatusInvalidReceiveRecordThreshold                            Status = 86
	StatusInvalidSendRecordThreshold                               Status = 87
	StatusAccountIsNotGenesisAccount                               Status = 88
	StatusPayerAccountUnauthorized                                 Status = 89
	StatusInvalidFreezeTransactionBody                             Status = 90
	StatusFreezeTransactionBodyNotFound                            Status = 91
	StatusTransferListSizeLimitExceeded                            Status = 92
	StatusResultSizeLimitExceeded                                  Status = 93
	StatusNotSpecialAccount                                        Status = 94
	StatusContractNegativeGas                                      Status = 95
	StatusContractNegativeValue                                    Status = 96
	StatusInvalidFeeFile                                           Status = 97
	StatusInvalidExchangeRateFile                                  Status = 98
	StatusInsufficientLocalCallGas                                 Status = 99
	StatusEntityNotAllowedToDelete                                 Status = 100
	StatusAuthorizationFailed                                      Status = 101
	StatusFileUploadedProtoInvalid                                 Status = 102
	StatusFileUploadedProtoNotSavedToDisk                          Status = 103
	StatusFeeScheduleFilePartUploaded                              Status = 104
	StatusExchangeRateChangeLimitExceeded                          Status = 105
	StatusMaxContractStorageExceeded                               Status = 106
	StatusTransferAccountSameAsDeleteAccount                       Status = 107
	StatusTotalLedgerBalanceInvalid                                Status = 108
	StatusExpirationReductionNotAllowed                            Status = 110
	StatusMaxGasLimitExceeded                                      Status = 111
	StatusMaxFileSizeExceeded                                      Status = 112
	StatusReceiverSigRequired                                      Status = 113
	StatusInvalidTopicID                                           Status = 150
	StatusInvalidAdminKey                                          Status = 155
	StatusInvalidSubmitKey                                         Status = 156
	StatusUnauthorized                                             Status = 157
	StatusInvalidTopicMessage                                      Status = 158
	StatusInvalidAutorenewAccount                                  Status = 159
	StatusAutorenewAccountNotAllowed                               Status = 160
	StatusTopicExpired                                             Status = 162
	StatusInvalidChunkNumber                                       Status = 163
	StatusInvalidChunkTransactionID                                Status = 164
	StatusAccountFrozenForToken                                    Status = 165
	StatusTokensPerAccountLimitExceeded                            Status = 166
	StatusInvalidTokenID                                           Status = 167
	StatusInvalidTokenDecimals                                     Status = 168
	StatusInvalidTokenInitialSupply                                Status = 169
	StatusInvalidTreasuryAccountForToken                           Status = 170
	StatusInvalidTokenSymbol                                       Status = 171
	StatusTokenHasNoFreezeKey                                      Status = 172
	StatusTransfersNotZeroSumForToken                              Status = 173
	StatusMissingTokenSymbol                                       Status = 174
	StatusTokenSymbolTooLong                                       Status = 175
	StatusAccountKycNotGrantedForToken                             Status = 176
	StatusTokenHasNoKycKey                                         Status = 177
	StatusInsufficientTokenBalance                                 Status = 178
	StatusTokenWasDeleted                                          Status = 179
	StatusTokenHasNoSupplyKey                                      Status = 180
	StatusTokenHasNoWipeKey                                        Status = 181
	StatusInvalidTokenMintAmount                                   Status = 182
	StatusInvalidTokenBurnAmount                                   Status = 183
	StatusTokenNotAssociatedToAccount                              Status = 184
	StatusCannotWipeTokenTreasuryAccount                           Status = 185
	StatusInvalidKycKey                                            Status = 186
	StatusInvalidWipeKey                                           Status = 187
	StatusInvalidFreezeKey                                         Status = 188
	StatusInvalidSupplyKey                                         Status = 189
	StatusMissingTokenName                                         Status = 190
	StatusTokenNameTooLong                                         Status = 191
	StatusInvalidWipingAmount                                      Status = 192
	StatusTokenIsImmutable                                         Status = 193
	StatusTokenAlreadyAssociatedToAccount                          Status = 194
	StatusTransactionRequiresZeroTokenBalances                     Status = 195
	StatusAccountIsTreasury                                        Status = 196
	StatusTokenIDRepeatedInTokenList                               Status = 197
	StatusTokenTransferListSizeLimitExceeded                       Status = 198
	StatusEmptyTokenTransferBody                                   Status = 199
	StatusEmptyTokenTransferAccountAmounts                         Status = 200
	StatusInvalidScheduleID                                        Status = 201
	StatusScheduleIsImmutable                                      Status = 202
	StatusInvalidSchedulePayerID                                   Status = 203
	StatusInvalidScheduleAccountID                                 Status = 204
	StatusNoNewValidSignatures                                     Status = 205
	StatusUnresolvableRequiredSigners                              Status = 206
	StatusScheduledTransactionNotInWhitelist                       Status = 207
	StatusSomeSignaturesWereInvalid                                Status = 208
	StatusTransactionIDFieldNotAllowed                             Status = 209
	StatusIdenticalScheduleAlreadyCreated                          Status = 210
	StatusInvalidZeroByteInString                                  Status = 211
	StatusScheduleAlreadyDeleted                                   Status = 212
	StatusScheduleAlreadyExecuted                                  Status = 213
	StatusMessageSizeTooLarge                                      Status = 214
	StatusOperationRepeatedInBucketGroups                          Status = 215
	StatusBucketCapacityOverflow                                   Status = 216
	StatusNodeCapacityNotSufficientForOperation                    Status = 217
	StatusBucketHasNoThrottleGroups                                Status = 218
	StatusThrottleGroupHasZeroOpsPerSec                            Status = 219
	StatusSuccessButMissingExpectedOperation                       Status = 220
	StatusUnparseableThrottleDefinitions                           Status = 221
	StatusInvalidThrottleDefinitions                               Status = 222
	StatusAccountExpiredAndPendingRemoval                          Status = 223
	StatusInvalidTokenMaxSupply                                    Status = 224
	StatusInvalidTokenNftSerialNumber                              Status = 225
	StatusInvalidNftID                                             Status = 226
	StatusMetadataTooLong                                          Status = 227
	StatusBatchSizeLimitExceeded                                   Status = 228
	StatusInvalidQueryRange                                        Status = 229
	StatusFractionDividesByZero                                    Status = 230
	StatusInsufficientPayerBalanceForCustomFee                     Status = 231
	StatusCustomFeesListTooLong                                    Status = 232
	StatusInvalidCustomFeeCollector                                Status = 233
	StatusInvalidTokenIDInCustomFees                               Status = 234
	StatusTokenNotAssociatedToFeeCollector                         Status = 235
	StatusTokenMaxSupplyReached                                    Status = 236
	StatusSenderDoesNotOwnNftSerialNo                              Status = 237
	StatusCustomFeeNotFullySpecified                               Status = 238
	StatusCustomFeeMustBePositive                                  Status = 239
	StatusTokenHasNoFeeScheduleKey                                 Status = 240
	StatusCustomFeeOutsideNumericRange                             Status = 241
	StatusRoyaltyFractionCannotExceedOne                           Status = 242
	StatusFractionalFeeMaxAmountLessThanMinAmount                  Status = 243
	StatusCustomScheduleAlreadyHasNoFees                           Status = 244
	StatusCustomFeeDenominationMustBeFungibleCommon                Status = 245
	StatusCustomFractionalFeeOnlyAllowedForFungibleCommon          Status = 246
	StatusInvalidCustomFeeScheduleKey                              Status = 247
	StatusInvalidTokenMintMetadata                                 Status = 248
	StatusInvalidTokenBurnMetadata                                 Status = 249
	StatusCurrentTreasuryStillOwnsNfts                             Status = 250
	StatusAccountStillOwnsNfts                                     Status = 251
	StatusTreasuryMustOwnBurnedNft                                 Status = 252
	StatusAccountDoesNotOwnWipedNft                                Status = 253
	StatusAccountAmountTransfersOnlyAllowedForFungibleCommon       Status = 254
	StatusMaxNftsInPriceRegimeHaveBeenMinted                       Status = 255
	StatusPayerAccountDeleted                                      Status = 256
	StatusCustomFeeChargingExceededMaxRecursionDepth               Status = 257
	StatusCustomFeeChargingExceededMaxAccountAmounts               Status = 258
	StatusInsufficientSenderAccountBalanceForCustomFee             Status = 259
	StatusSerialNumberLimitReached                                 Status = 260
	StatusCustomRoyaltyFeeOnlyAllowedForNonFungibleUnique          Status = 261
	StatusNoRemainingAutomaticAssociations                         Status = 262
	StatusExistingAutomaticAssociationsExceedGivenLimit            Status = 263
	StatusRequestedNumAutomaticAssociationsExceedsAssociationLimit Status = 264
	StatusTokenIsPaused                                            Status = 265
	StatusTokenHasNoPauseKey                                       Status = 266
	StatusInvalidPauseKey                                          Status = 267
	StatusFreezeUpdateFileDoesNotExist                             Status = 268
	StatusFreezeUpdateFileHashDoesNotMatch                         Status = 269
	StatusNoUpgradeHasBeenPrepared                                 Status = 270
	StatusNoFreezeIsScheduled                                      Status = 271
	StatusUpdateFileHashChangedSincePrepareUpgrade                 Status = 272
	StatusFreezeStartTimeMustBeFuture                              Status = 273
	StatusPreparedUpdateFileIsImmutable                            Status = 274
	StatusFreezeAlreadyScheduled                                   Status = 275
	StatusFreezeUpgradeInProgress                                  Status = 276
	StatusUpdateFileIDDoesNotMatchPrepared                         Status = 277
	StatusUpdateFileHashDoesNotMatchPrepared                       Status = 278
	StatusConsensusGasExhausted                                    Status = 279
	StatusRevertedSuccess                                          Status = 280
	StatusMaxStorageInPriceRegimeHasBeenUsed                       Status = 281
	StatusInvalidAliasKey                                          Status = 282
	StatusUnexpectedTokenDecimals                                  Status = 283
	StatusInvalidProxyAccountID                                    Status = 284
	StatusInvalidTransferAccountID                                 Status = 285
	StatusInvalidFeeCollectorAccountID                             Status = 286
	StatusAliasIsImmutable                                         Status = 287
	StatusSpenderAccountSameAsOwner                                Status = 288
	StatusAmountExceedsTokenMaxSupply                              Status = 289
	StatusNegativeAllowanceAmount                                  Status = 290
	StatusCannotApproveForAllFungibleCommon                        Status = 291
	StatusSpenderDoesNotHaveAllowance                              Status = 292
	StatusAmountExceedsAllowance                                   Status = 293
	StatusMaxAllowancesExceeded                                    Status = 294
	StatusEmptyAllowances                                          Status = 295
	StatusSpenderAccountRepeatedInAllowance                        Status = 296
	StatusRepeatedSerialNumsInNftAllowances                        Status = 297
	StatusFungibleTokenInNftAllowances                             Status = 298
	StatusNftInFungibleTokenAllowances                             Status = 299
	StatusInvalidAllowanceOwnerID                                  Status = 300
	StatusInvalidAllowanceSpenderID                                Status = 301
	StatusRepeatedAllowancesToDelete                               Status = 302
	StatusInvalidDelegatingSpender                                 Status = 303
	StatusDelegatingSpenderCannotGrantApproveForAll                Status = 304
	StatusDelegatingSpenderDoesNotHaveApproveForAll                Status = 305
	StatusScheduleExpirationTimeTooFarInFuture                     Status = 306
	StatusScheduleExpirationTimeMustBeHigherThanConsensusTime      Status = 307
	StatusScheduleFutureThrottleExceeded                           Status = 308
	StatusScheduleFutureGasLimitExceeded                           Status = 309
	StatusInvalidEthereumTransaction                               Status = 310
	StatusWrongChanID                                              Status = 311
	StatusWrongNonce                                               Status = 312
	StatusAccessListUnsupported                                    Status = 313
	StatusSchedulePendingExpiration                                Status = 314
	StatusContractIsTokenTreasury                                  Status = 315
	StatusContractHasNonZeroTokenBalances                          Status = 316
	StatusContractExpiredAndPendingRemoval                         Status = 317
	StatusContractHasNoAutoRenewAccount                            Status = 318
	StatusPermanentRemovalRequiresSystemInitiation                 Status = 319
	StatusProxyAccountIDFieldIsDeprecated                          Status = 320
	StatusSelfStakingIsNotAllowed                                  Status = 321
	StatusInvalidStakingID                                         Status = 322
	StatusStakingNotEnabled                                        Status = 323
	StatusInvalidRandomGenerateRange                               Status = 324
	StatusMaxEntitiesInPriceRegimeHaveBeenCreated                  Status = 325
	StatusInvalidFullPrefixSignatureForPrecompile                  Status = 326
	StatusInsufficientBalancesForStorageRent                       Status = 327
	StatusMaxChildRecordsExceeded                                  Status = 328
	StatusInsufficientBalancesForRenewalFees                       Status = 329
	StatusTransactionHasUnknownFields                              Status = 330
	StatusAccountIsImmutable                                       Status = 331
	StatusAliasAlreadyAssigned                                     Status = 332
	StatusInvalidMetadataKey                                       Status = 333
	StatusTokenHasNoMetadataKey                                    Status = 334
	StatusMissingTokenMetadata                                     Status = 335
	StatusMissingSerialNumbers                                     Status = 336
	StatusTokenHasNoAdminKey                                       Status = 337
	StatusNodeDeleted                                              Status = 338
	StatusInvalidNodeId                                            Status = 339
	StatusInvalidGossipEndpoint                                    Status = 340
	StatusInvalidNodeAccountId                                     Status = 341
	StatusInvalidNodeDescription                                   Status = 342
	StatusInvalidServiceEndpoint                                   Status = 343
	StatusInvalidGossipCaeCertificate                              Status = 344
	StatusInvalidGrpcCertificate                                   Status = 345
	StatusInvalidMaxAutoAssociations                               Status = 346
	StatusMaxNodesCreated                                          Status = 347
	StatusIpFQDNCannotBeSetForSameEndpoint                         Status = 348
	StatusGossipEndpointCannotHaveFQDN                             Status = 349
	StatusFQDNSizeTooLarge                                         Status = 350
	StatusInvalidEndpoint                                          Status = 351
	StatusGossipEndpointsExceededLimit                             Status = 352
	StatusTokenReferenceRepeated                                   Status = 353
	StatusInvalidOwnerID                                           Status = 354
	StatusTokenReferenceListSizeLimitExceeded                      Status = 355
	StatusInvalidIPV4Address                                       Status = 356
	StatusServiceEndpointsExceededLimit                            Status = 357
	StatusEmptyTokenReferenceList                                  Status = 358
	StatusUpdateNodeAccountNotAllowed                              Status = 359
	StatusTokenHasNoMetadataOrSupplyKey                            Status = 360
	StatusEmptyPendingAirdropIdList                                Status = 361
	StatusPendingAirdropIdRepeated                                 Status = 362
	StatusMaxPendingAirdropIdExceeded                              Status = 363
	StatusPendingNftAirdropAlreadyExists                           Status = 364
	StatusAccountHasPendingAirdrops                                Status = 365
	StatusThrottledAtConsensus                                     Status = 366
	StatusInvalidPendingAirdropId                                  Status = 367
	StatusTokenAirdropWithFallbackRoyalty                          Status = 368
	StatusInvalidTokenIdPendingAirdrop                             Status = 369
)

// String() returns a string representation of the status
func (status Status) String() string { // nolint
	switch status {
	case StatusOk:
		return "OK"
	case StatusInvalidTransaction:
		return "INVALID_TRANSACTION"
	case StatusPayerAccountNotFound:
		return "PAYER_ACCOUNT_NOT_FOUND"
	case StatusInvalidNodeAccount:
		return "INVALID_NODE_ACCOUNT"
	case StatusTransactionExpired:
		return "TRANSACTION_EXPIRED"
	case StatusInvalidTransactionStart:
		return "INVALID_TRANSACTION_START"
	case StatusInvalidTransactionDuration:
		return "INVALID_TRANSACTION_DURATION"
	case StatusInvalidSignature:
		return "INVALID_SIGNATURE"
	case StatusMemoTooLong:
		return "MEMO_TOO_LONG"
	case StatusInsufficientTxFee:
		return "INSUFFICIENT_TX_FEE"
	case StatusInsufficientPayerBalance:
		return "INSUFFICIENT_PAYER_BALANCE"
	case StatusDuplicateTransaction:
		return "DUPLICATE_TRANSACTION"
	case StatusBusy:
		return "BUSY"
	case StatusNotSupported:
		return "NOT_SUPPORTED"
	case StatusInvalidFileID:
		return "INVALID_FILE_ID"
	case StatusInvalidAccountID:
		return "INVALID_ACCOUNT_ID"
	case StatusInvalidContractID:
		return "INVALID_CONTRACT_ID"
	case StatusInvalidTransactionID:
		return "INVALID_TRANSACTION_ID"
	case StatusReceiptNotFound:
		return "RECEIPT_NOT_FOUND"
	case StatusRecordNotFound:
		return "RECORD_NOT_FOUND"
	case StatusInvalidSolidityID:
		return "INVALID_SOLIDITY_ID"
	case StatusUnknown:
		return "UNKNOWN"
	case StatusSuccess:
		return "SUCCESS"
	case StatusFailInvalid:
		return "FAIL_INVALID"
	case StatusFailFee:
		return "FAIL_FEE"
	case StatusFailBalance:
		return "FAIL_BALANCE"
	case StatusKeyRequired:
		return "KEY_REQUIRED"
	case StatusBadEncoding:
		return "BAD_ENCODING"
	case StatusInsufficientAccountBalance:
		return "INSUFFICIENT_ACCOUNT_BALANCE"
	case StatusInvalidSolidityAddress:
		return "INVALID_SOLIDITY_ADDRESS"
	case StatusInsufficientGas:
		return "INSUFFICIENT_GAS"
	case StatusContractSizeLimitExceeded:
		return "CONTRACT_SIZE_LIMIT_EXCEEDED"
	case StatusLocalCallModificationException:
		return "LOCAL_CALL_MODIFICATION_EXCEPTION"
	case StatusContractRevertExecuted:
		return "CONTRACT_REVERT_EXECUTED"
	case StatusContractExecutionException:
		return "CONTRACT_EXECUTION_EXCEPTION"
	case StatusInvalidReceivingNodeAccount:
		return "INVALID_RECEIVING_NODE_ACCOUNT"
	case StatusMissingQueryHeader:
		return "MISSING_QUERY_HEADER"
	case StatusAccountUpdateFailed:
		return "ACCOUNT_UPDATE_FAILED"
	case StatusInvalidKeyEncoding:
		return "INVALID_KEY_ENCODING"
	case StatusNullSolidityAddress:
		return "NULL_SOLIDITY_ADDRESS"
	case StatusContractUpdateFailed:
		return "CONTRACT_UPDATE_FAILED"
	case StatusInvalidQueryHeader:
		return "INVALID_QUERY_HEADER"
	case StatusInvalidFeeSubmitted:
		return "INVALID_FEE_SUBMITTED"
	case StatusInvalidPayerSignature:
		return "INVALID_PAYER_SIGNATURE"
	case StatusKeyNotProvided:
		return "KEY_NOT_PROVIDED"
	case StatusInvalidExpirationTime:
		return "INVALID_EXPIRATION_TIME"
	case StatusNoWaclKey:
		return "NO_WACL_KEY"
	case StatusFileContentEmpty:
		return "FILE_CONTENT_EMPTY"
	case StatusInvalidAccountAmounts:
		return "INVALID_ACCOUNT_AMOUNTS"
	case StatusEmptyTransactionBody:
		return "EMPTY_TRANSACTION_BODY"
	case StatusInvalidTransactionBody:
		return "INVALID_TRANSACTION_BODY"
	case StatusInvalidSignatureTypeMismatchingKey:
		return "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"
	case StatusInvalidSignatureCountMismatchingKey:
		return "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"
	case StatusEmptyLiveHashBody:
		return "EMPTY_LIVE_HASH_BODY"
	case StatusEmptyLiveHash:
		return "EMPTY_LIVE_HASH"
	case StatusEmptyLiveHashKeys:
		return "EMPTY_LIVE_HASH_KEYS"
	case StatusInvalidLiveHashSize:
		return "INVALID_LIVE_HASH_SIZE"
	case StatusEmptyQueryBody:
		return "EMPTY_QUERY_BODY"
	case StatusEmptyLiveHashQuery:
		return "EMPTY_LIVE_HASH_QUERY"
	case StatusLiveHashNotFound:
		return "LIVE_HASH_NOT_FOUND"
	case StatusAccountIDDoesNotExist:
		return "ACCOUNT_ID_DOES_NOT_EXIST"
	case StatusLiveHashAlreadyExists:
		return "LIVE_HASH_ALREADY_EXISTS"
	case StatusInvalidFileWacl:
		return "INVALID_FILE_WACL"
	case StatusSerializationFailed:
		return "SERIALIZATION_FAILED"
	case StatusTransactionOversize:
		return "TRANSACTION_OVERSIZE"
	case StatusTransactionTooManyLayers:
		return "TRANSACTION_TOO_MANY_LAYERS"
	case StatusContractDeleted:
		return "CONTRACT_DELETED"
	case StatusPlatformNotActive:
		return "PLATFORM_NOT_ACTIVE"
	case StatusKeyPrefixMismatch:
		return "KEY_PREFIX_MISMATCH"
	case StatusPlatformTransactionNotCreated:
		return "PLATFORM_TRANSACTION_NOT_CREATED"
	case StatusInvalidRenewalPeriod:
		return "INVALID_RENEWAL_PERIOD"
	case StatusInvalidPayerAccountID:
		return "INVALID_PAYER_ACCOUNT_ID"
	case StatusAccountDeleted:
		return "ACCOUNT_DELETED"
	case StatusFileDeleted:
		return "FILE_DELETED"
	case StatusAccountRepeatedInAccountAmounts:
		return "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"
	case StatusSettingNegativeAccountBalance:
		return "SETTING_NEGATIVE_ACCOUNT_BALANCE"
	case StatusObtainerRequired:
		return "OBTAINER_REQUIRED"
	case StatusObtainerSameContractID:
		return "OBTAINER_SAME_CONTRACT_ID"
	case StatusObtainerDoesNotExist:
		return "OBTAINER_DOES_NOT_EXIST"
	case StatusModifyingImmutableContract:
		return "MODIFYING_IMMUTABLE_CONTRACT"
	case StatusFileSystemException:
		return "FILE_SYSTEM_EXCEPTION"
	case StatusAutorenewDurationNotInRange:
		return "AUTORENEW_DURATION_NOT_IN_RANGE"
	case StatusErrorDecodingBytestring:
		return "ERROR_DECODING_BYTESTRING"
	case StatusContractFileEmpty:
		return "CONTRACT_FILE_EMPTY"
	case StatusContractBytecodeEmpty:
		return "CONTRACT_BYTECODE_EMPTY"
	case StatusInvalidInitialBalance:
		return "INVALID_INITIAL_BALANCE"
	case StatusInvalidReceiveRecordThreshold:
		return "INVALID_RECEIVE_RECORD_THRESHOLD"
	case StatusInvalidSendRecordThreshold:
		return "INVALID_SEND_RECORD_THRESHOLD"
	case StatusAccountIsNotGenesisAccount:
		return "ACCOUNT_IS_NOT_GENESIS_ACCOUNT"
	case StatusPayerAccountUnauthorized:
		return "PAYER_ACCOUNT_UNAUTHORIZED"
	case StatusInvalidFreezeTransactionBody:
		return "INVALID_FREEZE_TRANSACTION_BODY"
	case StatusFreezeTransactionBodyNotFound:
		return "FREEZE_TRANSACTION_BODY_NOT_FOUND"
	case StatusTransferListSizeLimitExceeded:
		return "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"
	case StatusResultSizeLimitExceeded:
		return "RESULT_SIZE_LIMIT_EXCEEDED"
	case StatusNotSpecialAccount:
		return "NOT_SPECIAL_ACCOUNT"
	case StatusContractNegativeGas:
		return "CONTRACT_NEGATIVE_GAS"
	case StatusContractNegativeValue:
		return "CONTRACT_NEGATIVE_VALUE"
	case StatusInvalidFeeFile:
		return "INVALID_FEE_FILE"
	case StatusInvalidExchangeRateFile:
		return "INVALID_EXCHANGE_RATE_FILE"
	case StatusInsufficientLocalCallGas:
		return "INSUFFICIENT_LOCAL_CALL_GAS"
	case StatusEntityNotAllowedToDelete:
		return "ENTITY_NOT_ALLOWED_TO_DELETE"
	case StatusAuthorizationFailed:
		return "AUTHORIZATION_FAILED"
	case StatusFileUploadedProtoInvalid:
		return "FILE_UPLOADED_PROTO_INVALID"
	case StatusFileUploadedProtoNotSavedToDisk:
		return "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"
	case StatusFeeScheduleFilePartUploaded:
		return "FEE_SCHEDULE_FILE_PART_UPLOADED"
	case StatusExchangeRateChangeLimitExceeded:
		return "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"
	case StatusMaxContractStorageExceeded:
		return "MAX_CONTRACT_STORAGE_EXCEEDED"
	case StatusTransferAccountSameAsDeleteAccount:
		return "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"
	case StatusTotalLedgerBalanceInvalid:
		return "TOTAL_LEDGER_BALANCE_INVALID"
	case StatusExpirationReductionNotAllowed:
		return "EXPIRATION_REDUCTION_NOT_ALLOWED"
	case StatusMaxGasLimitExceeded:
		return "MAX_GAS_LIMIT_EXCEEDED"
	case StatusMaxFileSizeExceeded:
		return "MAX_FILE_SIZE_EXCEEDED"
	case StatusReceiverSigRequired:
		return "RECEIVER_SIG_REQUIRED"
	case StatusInvalidTopicID:
		return "INVALID_TOPIC_ID"
	case StatusInvalidAdminKey:
		return "INVALID_ADMIN_KEY"
	case StatusInvalidSubmitKey:
		return "INVALID_SUBMIT_KEY"
	case StatusUnauthorized:
		return "UNAUTHORIZED"
	case StatusInvalidTopicMessage:
		return "INVALID_TOPIC_MESSAGE"
	case StatusInvalidAutorenewAccount:
		return "INVALID_AUTORENEW_ACCOUNT"
	case StatusAutorenewAccountNotAllowed:
		return "AUTORENEW_ACCOUNT_NOT_ALLOWED"
	case StatusTopicExpired:
		return "TOPIC_EXPIRED"
	case StatusInvalidChunkNumber:
		return "INVALID_CHUNK_NUMBER"
	case StatusInvalidChunkTransactionID:
		return "INVALID_CHUNK_TRANSACTION_ID"
	case StatusAccountFrozenForToken:
		return "ACCOUNT_FROZEN_FOR_TOKEN"
	case StatusTokensPerAccountLimitExceeded:
		return "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED"
	case StatusInvalidTokenID:
		return "INVALID_TOKEN_ID"
	case StatusInvalidTokenDecimals:
		return "INVALID_TOKEN_DECIMALS"
	case StatusInvalidTokenInitialSupply:
		return "INVALID_TOKEN_INITIAL_SUPPLY"
	case StatusInvalidTreasuryAccountForToken:
		return "INVALID_TREASURY_ACCOUNT_FOR_TOKEN"
	case StatusInvalidTokenSymbol:
		return "INVALID_TOKEN_SYMBOL"
	case StatusTokenHasNoFreezeKey:
		return "TOKEN_HAS_NO_FREEZE_KEY"
	case StatusTransfersNotZeroSumForToken:
		return "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN"
	case StatusMissingTokenSymbol:
		return "MISSING_TOKEN_SYMBOL"
	case StatusTokenSymbolTooLong:
		return "TOKEN_SYMBOL_TOO_LONG"
	case StatusAccountKycNotGrantedForToken:
		return "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN"
	case StatusTokenHasNoKycKey:
		return "TOKEN_HAS_NO_KYC_KEY"
	case StatusInsufficientTokenBalance:
		return "INSUFFICIENT_TOKEN_BALANCE"
	case StatusTokenWasDeleted:
		return "TOKEN_WAS_DELETED"
	case StatusTokenHasNoSupplyKey:
		return "TOKEN_HAS_NO_SUPPLY_KEY"
	case StatusTokenHasNoWipeKey:
		return "TOKEN_HAS_NO_WIPE_KEY"
	case StatusInvalidTokenMintAmount:
		return "INVALID_TOKEN_MINT_AMOUNT"
	case StatusInvalidTokenBurnAmount:
		return "INVALID_TOKEN_BURN_AMOUNT"
	case StatusTokenNotAssociatedToAccount:
		return "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT"
	case StatusCannotWipeTokenTreasuryAccount:
		return "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT"
	case StatusInvalidKycKey:
		return "INVALID_KYC_KEY"
	case StatusInvalidWipeKey:
		return "INVALID_WIPE_KEY"
	case StatusInvalidFreezeKey:
		return "INVALID_FREEZE_KEY"
	case StatusInvalidSupplyKey:
		return "INVALID_SUPPLY_KEY"
	case StatusMissingTokenName:
		return "MISSING_TOKEN_NAME"
	case StatusTokenNameTooLong:
		return "TOKEN_NAME_TOO_LONG"
	case StatusInvalidWipingAmount:
		return "INVALID_WIPING_AMOUNT"
	case StatusTokenIsImmutable:
		return "TOKEN_IS_IMMUTABLE"
	case StatusTokenAlreadyAssociatedToAccount:
		return "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT"
	case StatusTransactionRequiresZeroTokenBalances:
		return "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES"
	case StatusAccountIsTreasury:
		return "ACCOUNT_IS_TREASURY"
	case StatusTokenIDRepeatedInTokenList:
		return "TOKEN_ID_REPEATED_IN_TOKEN_LIST"
	case StatusTokenTransferListSizeLimitExceeded:
		return "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"
	case StatusEmptyTokenTransferBody:
		return "EMPTY_TOKEN_TRANSFER_BODY"
	case StatusEmptyTokenTransferAccountAmounts:
		return "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS"
	case StatusInvalidScheduleID:
		return "INVALID_SCHEDULE_ID"
	case StatusScheduleIsImmutable:
		return "SCHEDULE_IS_IMMUTABLE"
	case StatusInvalidSchedulePayerID:
		return "INVALID_SCHEDULE_PAYER_ID"
	case StatusInvalidScheduleAccountID:
		return "INVALID_SCHEDULE_ACCOUNT_ID"
	case StatusNoNewValidSignatures:
		return "NO_NEW_VALID_SIGNATURES"
	case StatusUnresolvableRequiredSigners:
		return "UNRESOLVABLE_REQUIRED_SIGNERS"
	case StatusScheduledTransactionNotInWhitelist:
		return "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST"
	case StatusSomeSignaturesWereInvalid:
		return "SOME_SIGNATURES_WERE_INVALID"
	case StatusTransactionIDFieldNotAllowed:
		return "TRANSACTION_ID_FIELD_NOT_ALLOWED"
	case StatusIdenticalScheduleAlreadyCreated:
		return "IDENTICAL_SCHEDULE_ALREADY_CREATED"
	case StatusInvalidZeroByteInString:
		return "INVALID_ZERO_BYTE_IN_STRING"
	case StatusScheduleAlreadyDeleted:
		return "SCHEDULE_ALREADY_DELETED"
	case StatusScheduleAlreadyExecuted:
		return "SCHEDULE_ALREADY_EXECUTED"
	case StatusMessageSizeTooLarge:
		return "MESSAGE_SIZE_TOO_LARGE"
	case StatusOperationRepeatedInBucketGroups:
		return "OPERATION_REPEATED_IN_BUCKET_GROUPS"
	case StatusBucketCapacityOverflow:
		return "BUCKET_CAPACITY_OVERFLOW"
	case StatusNodeCapacityNotSufficientForOperation:
		return "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION"
	case StatusBucketHasNoThrottleGroups:
		return "BUCKET_HAS_NO_THROTTLE_GROUPS"
	case StatusThrottleGroupHasZeroOpsPerSec:
		return "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC"
	case StatusSuccessButMissingExpectedOperation:
		return "SUCCESS_BUT_MISSING_EXPECTED_OPERATION"
	case StatusUnparseableThrottleDefinitions:
		return "UNPARSEABLE_THROTTLE_DEFINITIONS"
	case StatusInvalidThrottleDefinitions:
		return "INVALID_THROTTLE_DEFINITIONS"
	case StatusAccountExpiredAndPendingRemoval:
		return "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL"
	case StatusInvalidTokenMaxSupply:
		return "INVALID_TOKEN_MAX_SUPPLY"
	case StatusInvalidTokenNftSerialNumber:
		return "INVALID_TOKEN_NFT_SERIAL_NUMBER"
	case StatusInvalidNftID:
		return "INVALID_NFT_ID"
	case StatusMetadataTooLong:
		return "METADATA_TOO_LONG"
	case StatusBatchSizeLimitExceeded:
		return "BATCH_SIZE_LIMIT_EXCEEDED"
	case StatusInvalidQueryRange:
		return "INVALID_QUERY_RANGE"
	case StatusFractionDividesByZero:
		return "FRACTION_DIVIDES_BY_ZERO"
	case StatusInsufficientPayerBalanceForCustomFee:
		return "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE"
	case StatusCustomFeesListTooLong:
		return "CUSTOM_FEES_LIST_TOO_LONG"
	case StatusInvalidCustomFeeCollector:
		return "INVALID_CUSTOM_FEE_COLLECTOR"
	case StatusInvalidTokenIDInCustomFees:
		return "INVALID_TOKEN_ID_IN_CUSTOM_FEES"
	case StatusTokenNotAssociatedToFeeCollector:
		return "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR"
	case StatusTokenMaxSupplyReached:
		return "TOKEN_MAX_SUPPLY_REACHED"
	case StatusSenderDoesNotOwnNftSerialNo:
		return "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO"
	case StatusCustomFeeNotFullySpecified:
		return "CUSTOM_FEE_NOT_FULLY_SPECIFIED"
	case StatusCustomFeeMustBePositive:
		return "CUSTOM_FEE_MUST_BE_POSITIVE"
	case StatusTokenHasNoFeeScheduleKey:
		return "TOKEN_HAS_NO_FEE_SCHEDULE_KEY"
	case StatusCustomFeeOutsideNumericRange:
		return "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE"
	case StatusRoyaltyFractionCannotExceedOne:
		return "ROYALTY_FRACTION_CANNOT_EXCEED_ONE"
	case StatusFractionalFeeMaxAmountLessThanMinAmount:
		return "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT"
	case StatusCustomScheduleAlreadyHasNoFees:
		return "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES"
	case StatusCustomFeeDenominationMustBeFungibleCommon:
		return "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON"
	case StatusCustomFractionalFeeOnlyAllowedForFungibleCommon:
		return "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"
	case StatusInvalidCustomFeeScheduleKey:
		return "INVALID_CUSTOM_FEE_SCHEDULE_KEY"
	case StatusInvalidTokenMintMetadata:
		return "INVALID_TOKEN_MINT_METADATA"
	case StatusInvalidTokenBurnMetadata:
		return "INVALID_TOKEN_BURN_METADATA"
	case StatusCurrentTreasuryStillOwnsNfts:
		return "CURRENT_TREASURY_STILL_OWNS_NFTS"
	case StatusAccountStillOwnsNfts:
		return "ACCOUNT_STILL_OWNS_NFTS"
	case StatusTreasuryMustOwnBurnedNft:
		return "TREASURY_MUST_OWN_BURNED_NFT"
	case StatusAccountDoesNotOwnWipedNft:
		return "ACCOUNT_DOES_NOT_OWN_WIPED_NFT"
	case StatusAccountAmountTransfersOnlyAllowedForFungibleCommon:
		return "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"
	case StatusMaxNftsInPriceRegimeHaveBeenMinted:
		return "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED"
	case StatusPayerAccountDeleted:
		return "PAYER_ACCOUNT_DELETED"
	case StatusCustomFeeChargingExceededMaxRecursionDepth:
		return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH"
	case StatusCustomFeeChargingExceededMaxAccountAmounts:
		return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS"
	case StatusInsufficientSenderAccountBalanceForCustomFee:
		return "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE"
	case StatusSerialNumberLimitReached:
		return "SERIAL_NUMBER_LIMIT_REACHED"
	case StatusCustomRoyaltyFeeOnlyAllowedForNonFungibleUnique:
		return "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"
	case StatusNoRemainingAutomaticAssociations:
		return "NO_REMAINING_AUTOMATIC_ASSOCIATIONS"
	case StatusExistingAutomaticAssociationsExceedGivenLimit:
		return "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT"
	case StatusRequestedNumAutomaticAssociationsExceedsAssociationLimit:
		return "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT"
	case StatusTokenIsPaused:
		return "TOKEN_IS_PAUSED"
	case StatusTokenHasNoPauseKey:
		return "TOKEN_HAS_NO_PAUSE_KEY"
	case StatusInvalidPauseKey:
		return "INVALID_PAUSE_KEY"
	case StatusFreezeUpdateFileDoesNotExist:
		return "FREEZE_UPDATE_FILE_DOES_NOT_EXIST"
	case StatusFreezeUpdateFileHashDoesNotMatch:
		return "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH"
	case StatusNoUpgradeHasBeenPrepared:
		return "NO_UPGRADE_HAS_BEEN_PREPARED"
	case StatusNoFreezeIsScheduled:
		return "NO_FREEZE_IS_SCHEDULED"
	case StatusUpdateFileHashChangedSincePrepareUpgrade:
		return "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE"
	case StatusFreezeStartTimeMustBeFuture:
		return "FREEZE_START_TIME_MUST_BE_FUTURE"
	case StatusPreparedUpdateFileIsImmutable:
		return "PREPARED_UPDATE_FILE_IS_IMMUTABLE"
	case StatusFreezeAlreadyScheduled:
		return "FREEZE_ALREADY_SCHEDULED"
	case StatusFreezeUpgradeInProgress:
		return "FREEZE_UPGRADE_IN_PROGRESS"
	case StatusUpdateFileIDDoesNotMatchPrepared:
		return "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED"
	case StatusUpdateFileHashDoesNotMatchPrepared:
		return "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED"
	case StatusConsensusGasExhausted:
		return "CONSENSUS_GAS_EXHAUSTED"
	case StatusRevertedSuccess:
		return "REVERTED_SUCCESS"
	case StatusMaxStorageInPriceRegimeHasBeenUsed:
		return "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED"
	case StatusInvalidAliasKey:
		return "INVALID_ALIAS_KEY"
	case StatusUnexpectedTokenDecimals:
		return "UNEXPECTED_TOKEN_DECIMALS"
	case StatusInvalidProxyAccountID:
		return "INVALID_PROXY_ACCOUNT_ID"
	case StatusInvalidTransferAccountID:
		return "INVALID_TRANSFER_ACCOUNT_ID"
	case StatusInvalidFeeCollectorAccountID:
		return "INVALID_FEE_COLLECTOR_ACCOUNT_ID"
	case StatusAliasIsImmutable:
		return "ALIAS_IS_IMMUTABLE"
	case StatusSpenderAccountSameAsOwner:
		return "SPENDER_ACCOUNT_SAME_AS_OWNER"
	case StatusAmountExceedsTokenMaxSupply:
		return "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY"
	case StatusNegativeAllowanceAmount:
		return "NEGATIVE_ALLOWANCE_AMOUNT"
	case StatusCannotApproveForAllFungibleCommon:
		return "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON"
	case StatusSpenderDoesNotHaveAllowance:
		return "SPENDER_DOES_NOT_HAVE_ALLOWANCE"
	case StatusAmountExceedsAllowance:
		return "AMOUNT_EXCEEDS_ALLOWANCE"
	case StatusMaxAllowancesExceeded:
		return "MAX_ALLOWANCES_EXCEEDED"
	case StatusEmptyAllowances:
		return "EMPTY_ALLOWANCES"
	case StatusSpenderAccountRepeatedInAllowance:
		return "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES"
	case StatusRepeatedSerialNumsInNftAllowances:
		return "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES"
	case StatusFungibleTokenInNftAllowances:
		return "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES"
	case StatusNftInFungibleTokenAllowances:
		return "NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES"
	case StatusInvalidAllowanceOwnerID:
		return "INVALID_ALLOWANCE_OWNER_ID"
	case StatusInvalidAllowanceSpenderID:
		return "INVALID_ALLOWANCE_SPENDER_ID"
	case StatusRepeatedAllowancesToDelete:
		return "REPEATED_ALLOWANCES_TO_DELETE"
	case StatusInvalidDelegatingSpender:
		return "INVALID_DELEGATING_SPENDER"
	case StatusDelegatingSpenderCannotGrantApproveForAll:
		return "DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL"
	case StatusDelegatingSpenderDoesNotHaveApproveForAll:
		return "DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL"
	case StatusScheduleExpirationTimeTooFarInFuture:
		return "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE"
	case StatusScheduleExpirationTimeMustBeHigherThanConsensusTime:
		return "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME"
	case StatusScheduleFutureThrottleExceeded:
		return "SCHEDULE_FUTURE_THROTTLE_EXCEEDED"
	case StatusScheduleFutureGasLimitExceeded:
		return "SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED"
	case StatusInvalidEthereumTransaction:
		return "INVALID_ETHEREUM_TRANSACTION"
	case StatusWrongChanID:
		return "WRONG_CHAIN_ID"
	case StatusWrongNonce:
		return "WRONG_NONCE"
	case StatusAccessListUnsupported:
		return "ACCESS_LIST_UNSUPPORTED"
	case StatusSchedulePendingExpiration:
		return "SCHEDULE_PENDING_EXPIRATION"
	case StatusContractIsTokenTreasury:
		return "CONTRACT_IS_TOKEN_TREASURY"
	case StatusContractHasNonZeroTokenBalances:
		return "CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES"
	case StatusContractExpiredAndPendingRemoval:
		return "CONTRACT_EXPIRED_AND_PENDING_REMOVAL"
	case StatusContractHasNoAutoRenewAccount:
		return "CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT"
	case StatusPermanentRemovalRequiresSystemInitiation:
		return "PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION"
	case StatusProxyAccountIDFieldIsDeprecated:
		return "PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED "
	case StatusSelfStakingIsNotAllowed:
		return "SELF_STAKING_IS_NOT_ALLOWED"
	case StatusInvalidStakingID:
		return "INVALID_STAKING_ID"
	case StatusStakingNotEnabled:
		return "STAKING_NOT_ENABLED"
	case StatusInvalidRandomGenerateRange:
		return "INVALID_RANDOM_GENERATE_RANGE"
	case StatusMaxEntitiesInPriceRegimeHaveBeenCreated:
		return "MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED"
	case StatusInvalidFullPrefixSignatureForPrecompile:
		return "INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE"
	case StatusInsufficientBalancesForStorageRent:
		return "INSUFFICIENT_BALANCES_FOR_STORAGE_RENT"
	case StatusMaxChildRecordsExceeded:
		return "MAX_CHILD_RECORDS_EXCEEDED"
	case StatusInsufficientBalancesForRenewalFees:
		return "INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES"
	case StatusTransactionHasUnknownFields:
		return "TRANSACTION_HAS_UNKNOWN_FIELDS"
	case StatusAccountIsImmutable:
		return "ACCOUNT_IS_IMMUTABLE"
	case StatusAliasAlreadyAssigned:
		return "ALIAS_ALREADY_ASSIGNED"
	case StatusInvalidMetadataKey:
		return "INVALID_METADATA_KEY"
	case StatusTokenHasNoMetadataKey:
		return "TOKEN_HAS_NO_METADATA_KEY"
	case StatusMissingTokenMetadata:
		return "MISSING_TOKEN_METADATA"
	case StatusMissingSerialNumbers:
		return "MISSING_SERIAL_NUMBERS"
	case StatusTokenHasNoAdminKey:
		return "TOKEN_HAS_NO_ADMIN_KEY"
	case StatusNodeDeleted:
		return "NODE_DELETED"
	case StatusInvalidNodeId:
		return "INVALID_NODE_ID"
	case StatusInvalidGossipEndpoint:
		return "INVALID_GOSSIP_ENDPOINT"
	case StatusInvalidNodeAccountId:
		return "INVALID_NODE_ACCOUNT_ID"
	case StatusInvalidNodeDescription:
		return "INVALID_NODE_DESCRIPTION"
	case StatusInvalidServiceEndpoint:
		return "INVALID_SERVICE_ENDPOINT"
	case StatusInvalidGossipCaeCertificate:
		return "INVALID_GOSSIP_CAE_CERTIFICATE"
	case StatusInvalidGrpcCertificate:
		return "INVALID_GRPC_CERTIFICATE"
	case StatusInvalidMaxAutoAssociations:
		return "INVALID_MAX_AUTO_ASSOCIATIONS"
	case StatusMaxNodesCreated:
		return "MAX_NODES_CREATED"
	case StatusIpFQDNCannotBeSetForSameEndpoint:
		return "IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT"
	case StatusGossipEndpointCannotHaveFQDN:
		return "GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN"
	case StatusFQDNSizeTooLarge:
		return "FQDN_SIZE_TOO_LARGE"
	case StatusInvalidEndpoint:
		return "INVALID_ENDPOINT"
	case StatusGossipEndpointsExceededLimit:
		return "GOSSIP_ENDPOINTS_EXCEEDED_LIMIT"
	case StatusTokenReferenceRepeated:
		return "TOKEN_REFERENCE_REPEATED"
	case StatusInvalidOwnerID:
		return "INVALID_OWNER_ID"
	case StatusTokenReferenceListSizeLimitExceeded:
		return "TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED"
	case StatusInvalidIPV4Address:
		return "INVALID_IPV4_ADDRESS"
	case StatusServiceEndpointsExceededLimit:
		return "SERVICE_ENDPOINTS_EXCEEDED_LIMIT"
	case StatusEmptyTokenReferenceList:
		return "EMPTY_TOKEN_REFERENCE_LIST"
	case StatusUpdateNodeAccountNotAllowed:
		return "UPDATE_NODE_ACCOUNT_NOT_ALLOWED"
	case StatusTokenHasNoMetadataOrSupplyKey:
		return "TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY"
	case StatusEmptyPendingAirdropIdList:
		return "EMPTY_PENDING_AIRDROP_ID_LIST"
	case StatusPendingAirdropIdRepeated:
		return "PENDING_AIRDROP_ID_REPEATED"
	case StatusMaxPendingAirdropIdExceeded:
		return "MAX_PENDING_AIRDROP_ID_EXCEEDED"
	case StatusPendingNftAirdropAlreadyExists:
		return "PENDING_NFT_AIRDROP_ALREADY_EXISTS"
	case StatusAccountHasPendingAirdrops:
		return "ACCOUNT_HAS_PENDING_AIRDROPS"
	case StatusThrottledAtConsensus:
		return "THROTTLED_AT_CONSENSUS"
	case StatusInvalidPendingAirdropId:
		return "INVALID_PENDING_AIRDROP_ID"
	case StatusTokenAirdropWithFallbackRoyalty:
		return "TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY"
	case StatusInvalidTokenIdPendingAirdrop:
		return "INVALID_TOKEN_IN_PENDING_AIRDROP"
	}

	panic(fmt.Sprintf("unreachable: Status.String() switch statement is non-exhaustive. Status: %v", uint32(status)))
}
// Filename: status_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
)

// TestStatusFromProtoToString tests pulling all codes from the proto generated code,
// converting it to the sdk enum, and calling String()
//
// Ideally this will catch any changes to _Response codes when the protobufs get updated
func TestUnitStatusFromProtoToString(t *testing.T) {
	t.Parallel()

	for _, code := range services.ResponseCodeEnum_value {
		status := Status(code)
		assert.NotPanics(t, func() { _ = status.String() })
	}
}
// Filename: storage_change.go
package hedera

import (
	"math/big"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

type StorageChange struct {
	Slot         *big.Int
	ValueRead    *big.Int
	ValueWritten *big.Int
}

// ToBytes returns the byte representation of the StorageChange
func (storageChange *StorageChange) ToBytes() []byte {
	return []byte{}
}

// StorageChangeFromBytes returns a StorageChange from a byte array
func StorageChangeFromBytes(data []byte) (StorageChange, error) {
	return StorageChange{}, nil
}
// Filename: subscription_handle.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

type SubscriptionHandle struct {
	onUnsubscribe func()
}

// Unsubscribe removes the subscription from the client
func (handle SubscriptionHandle) Unsubscribe() {
	if handle.onUnsubscribe != nil {
		handle.onUnsubscribe()
	}
}
// Filename: system_delete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// Delete a file or smart contract - can only be done with a Hedera admin.
// When it is deleted, it immediately disappears from the system as seen by the user,
// but is still stored internally until the expiration time, at which time it
// is truly and permanently deleted.
// Until that time, it can be undeleted by the Hedera admin.
// When a smart contract is deleted, the cryptocurrency account within it continues
// to exist, and is not affected by the expiration time here.
type SystemDeleteTransaction struct {
	Transaction
	contractID     *ContractID
	fileID         *FileID
	expirationTime *time.Time
}

// NewSystemDeleteTransaction creates a SystemDeleteTransaction transaction which can be
// used to construct and execute a System Delete Transaction.
func NewSystemDeleteTransaction() *SystemDeleteTransaction {
	tx := SystemDeleteTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _SystemDeleteTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *SystemDeleteTransaction {
	expiration := time.Date(
		time.Now().Year(), time.Now().Month(), time.Now().Day(),
		time.Now().Hour(), time.Now().Minute(),
		int(pb.GetSystemDelete().ExpirationTime.Seconds), time.Now().Nanosecond(), time.Now().Location(),
	)
	return &SystemDeleteTransaction{
		Transaction:    tx,
		contractID:     _ContractIDFromProtobuf(pb.GetSystemDelete().GetContractID()),
		fileID:         _FileIDFromProtobuf(pb.GetSystemDelete().GetFileID()),
		expirationTime: &expiration,
	}
}

// SetExpirationTime sets the time at which this transaction will expire.
func (tx *SystemDeleteTransaction) SetExpirationTime(expiration time.Time) *SystemDeleteTransaction {
	tx._RequireNotFrozen()
	tx.expirationTime = &expiration
	return tx
}

// GetExpirationTime returns the time at which this transaction will expire.
func (tx *SystemDeleteTransaction) GetExpirationTime() int64 {
	if tx.expirationTime != nil {
		return tx.expirationTime.Unix()
	}

	return 0
}

// SetContractID sets the ContractID of the contract which will be deleted.
func (tx *SystemDeleteTransaction) SetContractID(contractID ContractID) *SystemDeleteTransaction {
	tx._RequireNotFrozen()
	tx.contractID = &contractID
	return tx
}

// GetContractID returns the ContractID of the contract which will be deleted.
func (tx *SystemDeleteTransaction) GetContractID() ContractID {
	if tx.contractID == nil {
		return ContractID{}
	}

	return *tx.contractID
}

// SetFileID sets the FileID of the file which will be deleted.
func (tx *SystemDeleteTransaction) SetFileID(fileID FileID) *SystemDeleteTransaction {
	tx._RequireNotFrozen()
	tx.fileID = &fileID
	return tx
}

// GetFileID returns the FileID of the file which will be deleted.
func (tx *SystemDeleteTransaction) GetFileID() FileID {
	if tx.fileID == nil {
		return FileID{}
	}

	return *tx.fileID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *SystemDeleteTransaction) Sign(privateKey PrivateKey) *SystemDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *SystemDeleteTransaction) SignWithOperator(client *Client) (*SystemDeleteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *SystemDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *SystemDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *SystemDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *SystemDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *SystemDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *SystemDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *SystemDeleteTransaction) Freeze() (*SystemDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *SystemDeleteTransaction) FreezeWith(client *Client) (*SystemDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this SystemDeleteTransaction.
func (tx *SystemDeleteTransaction) SetMaxTransactionFee(fee Hbar) *SystemDeleteTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *SystemDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *SystemDeleteTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this SystemDeleteTransaction.
func (tx *SystemDeleteTransaction) SetTransactionMemo(memo string) *SystemDeleteTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this SystemDeleteTransaction.
func (tx *SystemDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *SystemDeleteTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *SystemDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this SystemDeleteTransaction.
func (tx *SystemDeleteTransaction) SetTransactionID(transactionID TransactionID) *SystemDeleteTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this SystemDeleteTransaction.
func (tx *SystemDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *SystemDeleteTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *SystemDeleteTransaction) SetMaxRetry(count int) *SystemDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *SystemDeleteTransaction) SetMaxBackoff(max time.Duration) *SystemDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *SystemDeleteTransaction) SetMinBackoff(min time.Duration) *SystemDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *SystemDeleteTransaction) SetLogLevel(level LogLevel) *SystemDeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *SystemDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *SystemDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *SystemDeleteTransaction) getName() string {
	return "SystemDeleteTransaction"
}

func (tx *SystemDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.contractID != nil {
		if err := tx.contractID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.fileID != nil {
		if err := tx.fileID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *SystemDeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_SystemDelete{
			SystemDelete: tx.buildProtoBody(),
		},
	}
}

func (tx *SystemDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_SystemDelete{
			SystemDelete: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *SystemDeleteTransaction) buildProtoBody() *services.SystemDeleteTransactionBody {
	body := &services.SystemDeleteTransactionBody{}

	if tx.expirationTime != nil {
		body.ExpirationTime = &services.TimestampSeconds{
			Seconds: tx.expirationTime.Unix(),
		}
	}

	if tx.contractID != nil {
		body.Id = &services.SystemDeleteTransactionBody_ContractID{
			ContractID: tx.contractID._ToProtobuf(),
		}
	}

	if tx.fileID != nil {
		body.Id = &services.SystemDeleteTransactionBody_FileID{
			FileID: tx.fileID._ToProtobuf(),
		}
	}

	return body
}

func (tx *SystemDeleteTransaction) getMethod(channel *_Channel) _Method {
	if channel._GetContract() == nil {
		return _Method{
			transaction: channel._GetFile().SystemDelete,
		}
	}

	return _Method{
		transaction: channel._GetContract().SystemDelete,
	}
}

func (tx *SystemDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: system_delete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
)

var testContractId = ContractID{Contract: 5}
var testExpirationTime = time.Now().Add(24 * time.Hour)
var testFileId = FileID{File: 3}
var testTrxValidDuration = 24 * time.Hour

func TestUnitSystemDeleteTransactionFromProtobuf(t *testing.T) {
	t.Parallel()

	trx, trxBody := _CreateProtoBufTrxBody()
	sysDeleteTrx := _SystemDeleteTransactionFromProtobuf(trx, trxBody)
	require.NotNil(t, sysDeleteTrx)
	require.Equal(t, "memo", sysDeleteTrx.memo)
	require.Equal(t, uint64(5), sysDeleteTrx.transactionFee)
	require.Equal(t, uint64(10), sysDeleteTrx.defaultMaxTransactionFee)
}

func TestUnitSystemDeleteTrxGettersAndSetters(t *testing.T) {
	t.Parallel()
	deleteTrx := _SetupSystemDeleteTrx()

	require.Equal(t, testContractId, deleteTrx.GetContractID())
	require.Equal(t, testExpirationTime.Unix(), deleteTrx.GetExpirationTime())
	require.Equal(t, testFileId, deleteTrx.GetFileID())
	require.Equal(t, testTrxValidDuration, deleteTrx.GetTransactionValidDuration())
}

func TestUnitSystemDeleteTrxValidateNetworkOnIDs(t *testing.T) {
	t.Parallel()
	deleteTrx := _SetupSystemDeleteTrx()
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)

	error := deleteTrx.validateNetworkOnIDs(client)
	require.NoError(t, error)
}

func TestUnitSystemDeleteTrxBuild(t *testing.T) {
	t.Parallel()
	deleteTrx := _SetupSystemDeleteTrx()

	trxBody := deleteTrx.build()

	require.NotNil(t, trxBody)
	require.Equal(t, "memo", trxBody.Memo)
	require.Equal(t, uint64(0), trxBody.TransactionFee)
	require.Equal(t, int64(testTrxValidDuration.Seconds()), trxBody.TransactionValidDuration.Seconds)
}

func TestUnitSystemDeleteTrxExecute(t *testing.T) {
	t.Parallel()
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	require.NoError(t, err)
	deleteTrx := _SetupSystemDeleteTrx()

	contractId, _ := ContractIDFromString("0.0.123-esxsf")
	deleteTrx.SetContractID(contractId)

	fileId, _ := FileIDFromString("0.0.123-esxsf")
	deleteTrx.SetFileID(fileId)

	_, err = deleteTrx.FreezeWith(client)

	deleteTrx.Sign(*client.operator.privateKey)
	response, _ := deleteTrx.Execute(client)
	require.Equal(t, deleteTrx.transactionID, response.TransactionID)

}

func TestUnitSystemConstructNewScheduleDeleteTransactionProtobuf(t *testing.T) {
	t.Parallel()
	deleteTrx := _SetupSystemUndeleteTrx()

	protoBody, err := deleteTrx.buildScheduled()
	require.NoError(t, err)
	require.NotNil(t, protoBody)
	require.Equal(t, "memo", protoBody.Memo)
	require.Equal(t, uint64(0), protoBody.TransactionFee)
}

func _CreateProtoBufTrxBody() (Transaction, *services.TransactionBody) {
	transaction := Transaction{transactionFee: 5, memo: "memo", defaultMaxTransactionFee: 10}
	transactionBody := &services.TransactionBody{
		Data: &services.TransactionBody_SystemDelete{SystemDelete: &services.SystemDeleteTransactionBody{ExpirationTime: &services.TimestampSeconds{Seconds: 100}}}}

	return transaction, transactionBody
}

func _SetupSystemDeleteTrx() *SystemDeleteTransaction {

	return NewSystemDeleteTransaction().
		SetContractID(testContractId).
		SetExpirationTime(testExpirationTime).
		SetFileID(testFileId).
		SetTransactionValidDuration(testTrxValidDuration).
		SetTransactionMemo("memo")
}
// Filename: system_undelete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"

	"time"
)

// Undelete a file or smart contract that was deleted by AdminDelete.
// Can only be done with a Hedera admin.
type SystemUndeleteTransaction struct {
	Transaction
	contractID *ContractID
	fileID     *FileID
}

// NewSystemUndeleteTransaction creates a SystemUndeleteTransaction transaction which can be
// used to construct and execute a System Undelete Transaction.
func NewSystemUndeleteTransaction() *SystemUndeleteTransaction {
	tx := SystemUndeleteTransaction{
		Transaction: _NewTransaction(),
	}
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _SystemUndeleteTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *SystemUndeleteTransaction {
	return &SystemUndeleteTransaction{
		Transaction: tx,
		contractID:  _ContractIDFromProtobuf(pb.GetSystemUndelete().GetContractID()),
		fileID:      _FileIDFromProtobuf(pb.GetSystemUndelete().GetFileID()),
	}
}

// SetContractID sets the ContractID of the contract whose deletion is being undone.
func (tx *SystemUndeleteTransaction) SetContractID(contractID ContractID) *SystemUndeleteTransaction {
	tx._RequireNotFrozen()
	tx.contractID = &contractID
	return tx
}

// GetContractID returns the ContractID of the contract whose deletion is being undone.
func (tx *SystemUndeleteTransaction) GetContractID() ContractID {
	if tx.contractID == nil {
		return ContractID{}
	}

	return *tx.contractID
}

// SetFileID sets the FileID of the file whose deletion is being undone.
func (tx *SystemUndeleteTransaction) SetFileID(fileID FileID) *SystemUndeleteTransaction {
	tx._RequireNotFrozen()
	tx.fileID = &fileID
	return tx
}

// GetFileID returns the FileID of the file whose deletion is being undone.
func (tx *SystemUndeleteTransaction) GetFileID() FileID {
	if tx.fileID == nil {
		return FileID{}
	}

	return *tx.fileID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *SystemUndeleteTransaction) Sign(privateKey PrivateKey) *SystemUndeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *SystemUndeleteTransaction) SignWithOperator(client *Client) (*SystemUndeleteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *SystemUndeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *SystemUndeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *SystemUndeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *SystemUndeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *SystemUndeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *SystemUndeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *SystemUndeleteTransaction) Freeze() (*SystemUndeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *SystemUndeleteTransaction) FreezeWith(client *Client) (*SystemUndeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this SystemUndeleteTransaction.
func (tx *SystemUndeleteTransaction) SetMaxTransactionFee(fee Hbar) *SystemUndeleteTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *SystemUndeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *SystemUndeleteTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this SystemUndeleteTransaction.
func (tx *SystemUndeleteTransaction) SetTransactionMemo(memo string) *SystemUndeleteTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this SystemUndeleteTransaction.
func (tx *SystemUndeleteTransaction) SetTransactionValidDuration(duration time.Duration) *SystemUndeleteTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *SystemUndeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this SystemUndeleteTransaction.
func (tx *SystemUndeleteTransaction) SetTransactionID(transactionID TransactionID) *SystemUndeleteTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this SystemUndeleteTransaction.
func (tx *SystemUndeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *SystemUndeleteTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *SystemUndeleteTransaction) SetMaxRetry(count int) *SystemUndeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *SystemUndeleteTransaction) SetMaxBackoff(max time.Duration) *SystemUndeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *SystemUndeleteTransaction) SetMinBackoff(min time.Duration) *SystemUndeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *SystemUndeleteTransaction) SetLogLevel(level LogLevel) *SystemUndeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *SystemUndeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *SystemUndeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *SystemUndeleteTransaction) getName() string {
	return "SystemUndeleteTransaction"
}

func (tx *SystemUndeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.contractID != nil {
		if err := tx.contractID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.fileID != nil {
		if err := tx.fileID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *SystemUndeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_SystemUndelete{
			SystemUndelete: tx.buildProtoBody(),
		},
	}
}

func (tx *SystemUndeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_SystemUndelete{
			SystemUndelete: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *SystemUndeleteTransaction) buildProtoBody() *services.SystemUndeleteTransactionBody {
	body := &services.SystemUndeleteTransactionBody{}
	if tx.contractID != nil {
		body.Id = &services.SystemUndeleteTransactionBody_ContractID{
			ContractID: tx.contractID._ToProtobuf(),
		}
	}

	if tx.fileID != nil {
		body.Id = &services.SystemUndeleteTransactionBody_FileID{
			FileID: tx.fileID._ToProtobuf(),
		}
	}

	return body
}

func (tx *SystemUndeleteTransaction) getMethod(channel *_Channel) _Method {
	if channel._GetContract() == nil {
		return _Method{
			transaction: channel._GetFile().SystemUndelete,
		}
	}

	return _Method{
		transaction: channel._GetContract().SystemUndelete,
	}
}
func (tx *SystemUndeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: system_undelete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
)

func TestUnitSystemUndeleteTransactionFromProtobuf(t *testing.T) {
	t.Parallel()

	trx, trxBody := _CreateProtoBufUndeleteTrxBody()
	sysUndeleteTrx := _SystemUndeleteTransactionFromProtobuf(trx, trxBody)
	require.NotNil(t, sysUndeleteTrx)
	require.Equal(t, "memo", sysUndeleteTrx.memo)
	require.Equal(t, uint64(5), sysUndeleteTrx.transactionFee)
	require.Equal(t, uint64(10), sysUndeleteTrx.defaultMaxTransactionFee)
}

func TestUnitSystemUndeleteTrxGettersAndSetters(t *testing.T) {
	t.Parallel()
	undeleteTrx := _SetupSystemUndeleteTrx()

	require.Equal(t, testContractId, undeleteTrx.GetContractID())
	require.Equal(t, undeleteTrx.GetNodeAccountIDs(), []AccountID{AccountID{Account: 3}})
	require.Equal(t, testFileId, undeleteTrx.GetFileID())
	require.Equal(t, testTrxValidDuration, undeleteTrx.GetTransactionValidDuration())
	require.Equal(t, testTrxValidDuration, *undeleteTrx.GetGrpcDeadline())
}

func TestUnitSystemUndeleteTrxValidateNetworkOnIDs(t *testing.T) {
	t.Parallel()
	undeleteTrx := _SetupSystemUndeleteTrx()
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)

	error := undeleteTrx.validateNetworkOnIDs(client)
	require.NoError(t, error)
}

func TestUnitSystemUndeleteTrxBuild(t *testing.T) {
	t.Parallel()
	deleteTrx := _SetupSystemUndeleteTrx()

	trxBody := deleteTrx.build()
	require.NotNil(t, trxBody)
	require.Equal(t, "memo", trxBody.Memo)
	require.Equal(t, uint64(0), trxBody.TransactionFee)
	require.Equal(t, int64(testTrxValidDuration.Seconds()), trxBody.TransactionValidDuration.Seconds)
}

func TestUnitSystemUndeleteTrxExecute(t *testing.T) {
	t.Parallel()
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	require.NoError(t, err)
	undeleteTrx := _SetupSystemUndeleteTrx()

	contractId, _ := ContractIDFromString("0.0.123-esxsf")
	undeleteTrx.SetContractID(contractId)

	fileId, _ := FileIDFromString("0.0.123-esxsf")
	undeleteTrx.SetFileID(fileId)

	_, err = undeleteTrx.FreezeWith(client)
	undeleteTrx.Sign(*client.operator.privateKey)
	response, _ := undeleteTrx.Execute(client)

	require.Equal(t, undeleteTrx.transactionID, response.TransactionID)
}

func TestUnitSystemConstructNewScheduleUndeleteTransactionProtobuf(t *testing.T) {
	t.Parallel()
	undeleteTrx := _SetupSystemUndeleteTrx()

	protoBody, err := undeleteTrx.buildScheduled()
	require.NoError(t, err)
	require.NotNil(t, protoBody)
	require.Equal(t, "memo", protoBody.Memo)
	require.Equal(t, uint64(0), protoBody.TransactionFee)
}

func _CreateProtoBufUndeleteTrxBody() (Transaction, *services.TransactionBody) {
	transaction := Transaction{transactionFee: 5, memo: "memo", defaultMaxTransactionFee: 10}
	transactionBody := &services.TransactionBody{
		Data: &services.TransactionBody_SystemUndelete{SystemUndelete: &services.SystemUndeleteTransactionBody{}}}

	return transaction, transactionBody
}

func _SetupSystemUndeleteTrx() *SystemUndeleteTransaction {
	testAccountID := AccountID{Account: 3}

	return NewSystemUndeleteTransaction().
		SetContractID(testContractId).
		SetFileID(testFileId).
		SetTransactionValidDuration(testTrxValidDuration).
		SetTransactionMemo("memo").
		SetGrpcDeadline(&testTrxValidDuration).
		SetNodeAccountIDs([]AccountID{testAccountID})
}
// Filename: tck/cmd/server.go
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/creachadair/jrpc2"
	"github.com/creachadair/jrpc2/handler"
	"github.com/creachadair/jrpc2/jhttp"
	"github.com/hashgraph/hedera-sdk-go/tck/methods"
	"github.com/hashgraph/hedera-sdk-go/tck/response"
	"github.com/hashgraph/hedera-sdk-go/v2"
	"github.com/joho/godotenv"
)

func main() {
	// Load dotenv
	_ = godotenv.Load()

	// Initialize the SDK service
	sdkService := new(methods.SDKService)
	accountService := new(methods.AccountService)
	accountService.SetSdkService(sdkService)

	// Create a new RPC server
	assigner := handler.Map{
		"setup":         postHandler(HandleError, handler.New(sdkService.Setup)),
		"reset":         postHandler(HandleError, handler.New(sdkService.Reset)),
		"createAccount": postHandler(HandleError, handler.New(accountService.CreateAccount)),
		"updateAccount": postHandler(HandleError, handler.New(accountService.UpdateAccount)),
		"deleteAccount": postHandler(HandleError, handler.New(accountService.DeleteAccount)),
		"generateKey":   postHandler(HandleError, handler.New(methods.GenerateKey)),
	}

	bridge := jhttp.NewBridge(assigner, nil)

	// Listen and redirect to bridge
	http.HandleFunc("/", bridge.ServeHTTP)
	port := os.Getenv("TCK_PORT")
	if port == "" {
		port = "80"
	}
	log.Println("Server is listening on port: " + port)

	server := &http.Server{Addr: ":" + port}

	// Start the server in a separate goroutine
	go func() {
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			fmt.Printf("Error starting server: %s\n", err)
		}
	}()

	signalCh := make(chan os.Signal, 1)
	signal.Notify(signalCh, os.Interrupt, syscall.SIGTERM)

	// Wait for the termination signal
	sig := <-signalCh
	fmt.Printf("Received signal: %v\n", sig)

	// Create a context with a timeout
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Shutdown the server gracefully
	if err := server.Shutdown(ctx); err != nil {
		fmt.Printf("Error shutting down server: %s\n", err)
	}

	log.Println("Server shutdown complete.")
}

// Handler is a function that handles errors reported by a method handler.
type Handler func(context.Context, *jrpc2.Request, error) error

func HandleError(_ context.Context, request *jrpc2.Request, err error) error {
	if err != nil {
		// jrpc generic error
		if jrpcError, ok := err.(*jrpc2.Error); ok {
			return jrpcError
		}
		// hedera specific errors
		if hederaErr, ok := err.(hedera.ErrHederaReceiptStatus); ok {
			return response.NewHederaReceiptError(hederaErr)
		}
		if hederaErr, ok := err.(hedera.ErrHederaPreCheckStatus); ok {
			return response.NewHederaPrecheckError(hederaErr)
		}
		// other errors
		return response.InternalError
	}
	return nil
}

// this wraps the jrpc2.Handler as it invokes the ErrorHandler func if error is returned
func postHandler(handler Handler, h jrpc2.Handler) jrpc2.Handler {
	return func(ctx context.Context, req *jrpc2.Request) (any, error) {
		res, err := h(ctx, req)
		if err != nil {
			log.Printf("Error occurred processing JSON-RPC request: %s, Response error: %s", req, err)
			return nil, handler(ctx, req, err)
		}
		return res, nil
	}
}
// Filename: tck/methods/account.go
package methods

import (
	"context"
	"time"

	"github.com/hashgraph/hedera-sdk-go/tck/param"
	"github.com/hashgraph/hedera-sdk-go/tck/response"
	"github.com/hashgraph/hedera-sdk-go/tck/utils"
	"github.com/hashgraph/hedera-sdk-go/v2"
)

// ---- Struct to hold hedera.Client implementation and to implement the methods of the specification ----
type AccountService struct {
	sdkService *SDKService
}

// Variable to be set to `SetGrpcDeadline` for all transactions
var threeSecondsDuration = time.Second * 3

// SetSdkService We set object, which is holding our client param. Pass it by referance, because TCK is dynamically updating it
func (a *AccountService) SetSdkService(service *SDKService) {
	a.sdkService = service
}

// CreateAccount jRPC method for createAccount
func (a *AccountService) CreateAccount(_ context.Context, accountCreateParams param.CreateAccountParams) (*response.AccountResponse, error) {
	transaction := hedera.NewAccountCreateTransaction().SetGrpcDeadline(&threeSecondsDuration)

	if accountCreateParams.Key != nil {
		key, err := utils.GetKeyFromString(*accountCreateParams.Key)
		if err != nil {
			return nil, err
		}
		transaction.SetKey(key)
	}
	if accountCreateParams.InitialBalance != nil {
		transaction.SetInitialBalance(hedera.HbarFromTinybar(*accountCreateParams.InitialBalance))
	}
	if accountCreateParams.ReceiverSignatureRequired != nil {
		transaction.SetReceiverSignatureRequired(*accountCreateParams.ReceiverSignatureRequired)
	}
	if accountCreateParams.MaxAutomaticTokenAssociations != nil {
		transaction.SetMaxAutomaticTokenAssociations(*accountCreateParams.MaxAutomaticTokenAssociations)
	}
	if accountCreateParams.StakedAccountId != nil {
		accountId, err := hedera.AccountIDFromString(*accountCreateParams.StakedAccountId)
		if err != nil {
			return nil, err
		}
		transaction.SetStakedAccountID(accountId)
	}
	if accountCreateParams.StakedNodeId != nil {
		stakedNodeID, err := accountCreateParams.StakedNodeId.Int64()
		if err != nil {
			return nil, response.InvalidParams.WithData(err.Error())
		}
		transaction.SetStakedNodeID(stakedNodeID)
	}
	if accountCreateParams.DeclineStakingReward != nil {
		transaction.SetDeclineStakingReward(*accountCreateParams.DeclineStakingReward)
	}
	if accountCreateParams.Memo != nil {
		transaction.SetAccountMemo(*accountCreateParams.Memo)
	}
	if accountCreateParams.AutoRenewPeriod != nil {
		transaction.SetAutoRenewPeriod(time.Duration(*accountCreateParams.AutoRenewPeriod) * time.Second)
	}
	if accountCreateParams.Alias != nil {
		transaction.SetAlias(*accountCreateParams.Alias)
	}
	if accountCreateParams.CommonTransactionParams != nil {
		accountCreateParams.CommonTransactionParams.FillOutTransaction(transaction, &transaction.Transaction, a.sdkService.Client)
	}
	txResponse, err := transaction.Execute(a.sdkService.Client)
	if err != nil {
		return nil, err
	}
	receipt, err := txResponse.GetReceipt(a.sdkService.Client)
	if err != nil {
		return nil, err
	}
	var accId string
	if receipt.Status == hedera.StatusSuccess {
		accId = receipt.AccountID.String()
	}
	return &response.AccountResponse{AccountId: accId, Status: receipt.Status.String()}, nil
}

// UpdateAccount jRPC method for updateAccount
func (a *AccountService) UpdateAccount(_ context.Context, accountUpdateParams param.UpdateAccountParams) (*response.AccountResponse, error) {
	transaction := hedera.NewAccountUpdateTransaction().SetGrpcDeadline(&threeSecondsDuration)
	if accountUpdateParams.AccountId != nil {
		accountId, _ := hedera.AccountIDFromString(*accountUpdateParams.AccountId)
		transaction.SetAccountID(accountId)
	}

	if accountUpdateParams.Key != nil {
		key, err := utils.GetKeyFromString(*accountUpdateParams.Key)
		if err != nil {
			return nil, err
		}
		transaction.SetKey(key)
	}

	if accountUpdateParams.ExpirationTime != nil {
		transaction.SetExpirationTime(time.Unix(*accountUpdateParams.ExpirationTime, 0))
	}

	if accountUpdateParams.ReceiverSignatureRequired != nil {
		transaction.SetReceiverSignatureRequired(*accountUpdateParams.ReceiverSignatureRequired)
	}

	if accountUpdateParams.MaxAutomaticTokenAssociations != nil {
		transaction.SetMaxAutomaticTokenAssociations(*accountUpdateParams.MaxAutomaticTokenAssociations)
	}

	if accountUpdateParams.StakedAccountId != nil {
		accountId, err := hedera.AccountIDFromString(*accountUpdateParams.StakedAccountId)
		if err != nil {
			return nil, err
		}
		transaction.SetStakedAccountID(accountId)
	}

	if accountUpdateParams.StakedNodeId != nil {
		stakedNodeID, err := accountUpdateParams.StakedNodeId.Int64()
		if err != nil {
			return nil, response.InvalidParams.WithData(err.Error())
		}
		transaction.SetStakedNodeID(stakedNodeID)
	}

	if accountUpdateParams.DeclineStakingReward != nil {
		transaction.SetDeclineStakingReward(*accountUpdateParams.DeclineStakingReward)
	}

	if accountUpdateParams.Memo != nil {
		transaction.SetAccountMemo(*accountUpdateParams.Memo)
	}

	if accountUpdateParams.AutoRenewPeriod != nil {
		transaction.SetAutoRenewPeriod(time.Duration(*accountUpdateParams.AutoRenewPeriod) * time.Second)
	}

	if accountUpdateParams.CommonTransactionParams != nil {
		accountUpdateParams.CommonTransactionParams.FillOutTransaction(transaction, &transaction.Transaction, a.sdkService.Client)
	}

	txResponse, err := transaction.Execute(a.sdkService.Client)
	if err != nil {
		return nil, err
	}
	receipt, err := txResponse.GetReceipt(a.sdkService.Client)
	if err != nil {
		return nil, err
	}
	return &response.AccountResponse{Status: receipt.Status.String()}, nil
}

// DeleteAccount jRPC method for deleteAccount
func (a *AccountService) DeleteAccount(_ context.Context, deleteAccountParams param.DeleteAccountParams) (*response.AccountResponse, error) {
	transaction := hedera.NewAccountDeleteTransaction().SetGrpcDeadline(&threeSecondsDuration)
	if deleteAccountParams.DeleteAccountId != nil {
		accountId, _ := hedera.AccountIDFromString(*deleteAccountParams.DeleteAccountId)
		transaction.SetAccountID(accountId)
	}

	if deleteAccountParams.TransferAccountId != nil {
		accountId, _ := hedera.AccountIDFromString(*deleteAccountParams.TransferAccountId)
		transaction.SetTransferAccountID(accountId)
	}

	if deleteAccountParams.CommonTransactionParams != nil {
		deleteAccountParams.CommonTransactionParams.FillOutTransaction(transaction, &transaction.Transaction, a.sdkService.Client)
	}

	txResponse, err := transaction.Execute(a.sdkService.Client)
	if err != nil {
		return nil, err
	}
	receipt, err := txResponse.GetReceipt(a.sdkService.Client)
	if err != nil {
		return nil, err
	}
	return &response.AccountResponse{Status: receipt.Status.String()}, nil
}
// Filename: tck/methods/key.go
package methods

import (
	"context"
	"encoding/hex"
	"errors"

	"github.com/hashgraph/hedera-sdk-go/tck/param"
	"github.com/hashgraph/hedera-sdk-go/tck/response"
	"github.com/hashgraph/hedera-sdk-go/tck/utils"
	"github.com/hashgraph/hedera-sdk-go/v2"
)

// GenerateKey generates key based on provided key params
func GenerateKey(_ context.Context, params param.KeyParams) (response.GenerateKeyResponse, error) {
	if params.FromKey != nil && params.Type != param.ED25519_PUBLIC_KEY && params.Type != param.ECDSA_SECP256K1_PUBLIC_KEY && params.Type != param.EVM_ADDRESS_KEY {
		return response.GenerateKeyResponse{}, utils.ErrFromKeyShouldBeProvided
	}

	if params.Threshold != nil && params.Type != param.THRESHOLD_KEY {
		return response.GenerateKeyResponse{}, utils.ErrThresholdTypeShouldBeProvided
	}

	if params.Keys != nil && params.Type != param.LIST_KEY && params.Type != param.THRESHOLD_KEY {
		return response.GenerateKeyResponse{}, utils.ErrKeysShouldBeProvided
	}

	if (params.Type == param.THRESHOLD_KEY || params.Type == param.LIST_KEY) && params.Keys == nil {
		return response.GenerateKeyResponse{}, utils.ErrKeylistRequired
	}

	if params.Type == param.THRESHOLD_KEY && params.Threshold == nil {
		return response.GenerateKeyResponse{}, utils.ErrThresholdRequired
	}

	resp := response.GenerateKeyResponse{}
	key, err := processKeyRecursively(params, &resp, false)
	if err != nil {
		return response.GenerateKeyResponse{}, err
	}
	resp.Key = key
	return resp, nil
}

func processKeyRecursively(params param.KeyParams, response *response.GenerateKeyResponse, isList bool) (string, error) {
	switch params.Type {
	case param.ED25519_PRIVATE_KEY, param.ECDSA_SECP256K1_PRIVATE_KEY:
		var privateKey string
		if params.Type == param.ED25519_PRIVATE_KEY {
			pk, _ := hedera.PrivateKeyGenerateEd25519()
			privateKey = pk.StringDer()
		} else {
			pk, _ := hedera.PrivateKeyGenerateEcdsa()
			privateKey = pk.StringDer()
		}
		if isList {
			response.PrivateKeys = append(response.PrivateKeys, privateKey)
		}
		return privateKey, nil

	case param.ED25519_PUBLIC_KEY, param.ECDSA_SECP256K1_PUBLIC_KEY:
		var publicKey, privateKey string

		setKeysFromKey := func(fromKey string, isEd25519 bool) {
			var pk hedera.PrivateKey
			if isEd25519 {
				pk, _ = hedera.PrivateKeyFromStringEd25519(fromKey)
			} else {
				pk, _ = hedera.PrivateKeyFromStringECDSA(fromKey)
			}
			privateKey = pk.StringDer()
			publicKey = pk.PublicKey().StringDer()
		}

		generateKeys := func(isEd25519 bool) {
			var pk hedera.PrivateKey
			if isEd25519 {
				pk, _ = hedera.PrivateKeyGenerateEd25519()
			} else {
				pk, _ = hedera.PrivateKeyGenerateEcdsa()
			}
			privateKey = pk.StringDer()
			publicKey = pk.PublicKey().StringDer()
		}

		isEd25519 := params.Type == param.ED25519_PUBLIC_KEY

		if params.FromKey != nil {
			setKeysFromKey(*params.FromKey, isEd25519)
		} else {
			generateKeys(isEd25519)
		}

		if isList {
			response.PrivateKeys = append(response.PrivateKeys, privateKey)
		}

		return publicKey, nil

	case param.LIST_KEY, param.THRESHOLD_KEY:
		keyList := hedera.NewKeyList()
		for _, keyParams := range *params.Keys {
			keyStr, err := processKeyRecursively(keyParams, response, true)
			if err != nil {
				return "", err
			}
			key, err := utils.GetKeyFromString(keyStr)
			if err != nil {
				return "", err
			}
			keyList.Add(key)
		}
		if params.Type == param.THRESHOLD_KEY {
			keyList.SetThreshold(*params.Threshold)
		}

		keyListBytes, err := hedera.KeyToBytes(keyList)
		if err != nil {
			return "", err
		}

		return hex.EncodeToString(keyListBytes), nil

	case param.EVM_ADDRESS_KEY:
		if params.FromKey != nil {
			key, err := utils.GetKeyFromString(*params.FromKey)
			if err != nil {
				return "", err
			}
			publicKey, ok := key.(hedera.PublicKey)
			if ok {
				return publicKey.ToEthereumAddress(), nil
			}

			privateKey, ok := key.(hedera.PrivateKey)
			if ok {
				return privateKey.PublicKey().ToEthereumAddress(), nil
			}
			return "", errors.New("invalid parameters: fromKey for evmAddress is not ECDSAsecp256k1")
		}
		privateKey, err := hedera.PrivateKeyGenerateEcdsa()
		if err != nil {
			return "", err
		}
		return privateKey.PublicKey().ToEthereumAddress(), nil

	default:
		return "", errors.New("invalid request: key type not recognized")
	}
}
// Filename: tck/methods/key_test.go
package methods

import (
	"context"
	"testing"

	"github.com/hashgraph/hedera-sdk-go/tck/param"
	"github.com/hashgraph/hedera-sdk-go/tck/utils"
	"github.com/stretchr/testify/assert"
)

func TestGenerateKeyWithInvalidFromKey(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type:      param.ED25519_PRIVATE_KEY,
		FromKey:   stringPointer("someKey"),
		Threshold: nil,
		Keys:      nil,
	}

	// When
	_, err := GenerateKey(context.Background(), params)

	// Then
	assert.Error(t, err)
	assert.Contains(t, err.Error(), utils.ErrFromKeyShouldBeProvided.Error())
}

func TestGenerateKeyWithInvalidThreshold(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type:      param.ED25519_PUBLIC_KEY,
		FromKey:   nil,
		Threshold: intPointer(1),
		Keys:      nil,
	}

	// When
	_, err := GenerateKey(context.Background(), params)

	// Then
	assert.Error(t, err)
	assert.Contains(t, err.Error(), utils.ErrThresholdTypeShouldBeProvided.Error())
}

func TestGenerateKeyWithInvalidKeys(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type:      param.ED25519_PUBLIC_KEY,
		FromKey:   nil,
		Threshold: nil,
		Keys:      &[]param.KeyParams{},
	}

	// When
	_, err := GenerateKey(context.Background(), params)

	// Then
	assert.Error(t, err)
	assert.Contains(t, err.Error(), utils.ErrKeysShouldBeProvided.Error())
}

func TestGenerateKeyWithMissingKeysForKeyList(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type:      param.LIST_KEY,
		FromKey:   nil,
		Threshold: nil,
		Keys:      nil,
	}

	// When
	_, err := GenerateKey(context.Background(), params)

	// Then
	assert.Error(t, err)
	assert.Contains(t, err.Error(), utils.ErrKeylistRequired.Error())
}

func TestGenerateKeyWithMissingThresholdForThresholdKey(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type: param.THRESHOLD_KEY,
		Keys: &[]param.KeyParams{
			{
				Type: param.ED25519_PUBLIC_KEY,
			},
		},
	}

	// When
	_, err := GenerateKey(context.Background(), params)

	// Then
	assert.Error(t, err)
	assert.Contains(t, err.Error(), utils.ErrThresholdRequired.Error())
}

func TestGenerateKeyWithValidEd25519PrivateKey(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type: param.ED25519_PRIVATE_KEY,
	}

	// When
	response, err := GenerateKey(context.Background(), params)

	// Then
	assert.NoError(t, err)
	assert.NotNil(t, response.Key)
	assert.Contains(t, response.Key, "302e020100300506032b657004220420")
}

func TestGenerateKeyWithValidEd25519PublicKey(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type: param.ED25519_PUBLIC_KEY,
	}

	// When
	response, err := GenerateKey(context.Background(), params)

	// Then
	assert.NoError(t, err)
	assert.NotNil(t, response.Key)
	assert.Contains(t, response.Key, "302a300506032b6570032100")
}

func TestGenerateKeyWithValidThresholdKey(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type:      param.THRESHOLD_KEY,
		Threshold: intPointer(2),
		Keys: &[]param.KeyParams{
			{
				Type: param.ED25519_PUBLIC_KEY,
			},
		},
	}

	// When
	response, err := GenerateKey(context.Background(), params)

	// Then
	assert.NoError(t, err)
	assert.NotNil(t, response.Key)
	assert.NotEmpty(t, response.PrivateKeys)
}

func TestGenerateKeyWithValidListKey(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type: param.LIST_KEY,
		Keys: &[]param.KeyParams{
			{
				Type: param.ED25519_PUBLIC_KEY,
			},
		},
	}

	// When
	response, err := GenerateKey(context.Background(), params)

	// Then
	assert.NoError(t, err)
	assert.NotNil(t, response.Key)
	assert.NotEmpty(t, response.PrivateKeys)
}

func TestGenerateKeyWithValidEvmAddressKey(t *testing.T) {
	// Given
	params := param.KeyParams{
		Type:    param.EVM_ADDRESS_KEY,
		FromKey: stringPointer("3054020101042056b071002a75ab207a44bb2c18320286062bc26969fcb98240301e4afbe9ee2ea00706052b8104000aa124032200038ef0b62d60b1415f8cfb460303c498fbf09cb2ef2d2ff19fad33982228ef86fd"),
	}

	// When
	response, err := GenerateKey(context.Background(), params)

	// Then
	assert.NoError(t, err)
	assert.NotNil(t, response.Key)
}
// Filename: tck/methods/sdk.go
package methods

import (
	"context"

	"github.com/hashgraph/hedera-sdk-go/tck/param"
	"github.com/hashgraph/hedera-sdk-go/tck/response"
	"github.com/hashgraph/hedera-sdk-go/v2"
)

type SDKService struct {
	Client *hedera.Client
}

// Setup function for the SDK
func (s *SDKService) Setup(_ context.Context, params param.SetupParams) (response.SetupResponse, error) {
	var clientType string

	if params.NodeIp != nil && params.NodeAccountId != nil && params.MirrorNetworkIp != nil {
		// Custom client setup
		nodeId, err := hedera.AccountIDFromString(*params.NodeAccountId)
		if err != nil {
			return response.SetupResponse{}, err
		}
		node := map[string]hedera.AccountID{
			*params.NodeIp: nodeId,
		}
		s.Client = hedera.ClientForNetwork(node)
		clientType = "custom"
		s.Client.SetMirrorNetwork([]string{*params.MirrorNetworkIp})
	} else {
		// Default to testnet
		s.Client = hedera.ClientForTestnet()
		clientType = "testnet"
	}

	// Set operator (adjustments may be needed based on the Hedera SDK)
	operatorId, _ := hedera.AccountIDFromString(params.OperatorAccountId)
	operatorKey, _ := hedera.PrivateKeyFromString(params.OperatorPrivateKey)
	s.Client.SetOperator(operatorId, operatorKey)

	return response.SetupResponse{
		Message: "Successfully setup " + clientType + " client.",
		Status:  "SUCCESS",
	}, nil
}

// Reset function for the SDK
func (s *SDKService) Reset(_ context.Context) response.SetupResponse {
	s.Client = nil
	return response.SetupResponse{
		Status: "SUCCESS",
	}
}
// Filename: tck/methods/sdk_test.go
package methods

import (
	"context"
	"testing"

	"github.com/hashgraph/hedera-sdk-go/tck/param"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSetup(t *testing.T) {
	// // Given
	sdkService := &SDKService{}
	params := param.SetupParams{
		OperatorAccountId:  "0.0.2",
		OperatorPrivateKey: "302e020100300506032b65700422042091132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137",
		NodeIp:             stringPointer("127.0.0.1:50211"),
		NodeAccountId:      stringPointer("0.0.3"),
		MirrorNetworkIp:    stringPointer("http://127.0.0.1:5551"),
	}

	// When
	response, _ := sdkService.Setup(context.Background(), params)

	// Then
	assert.Equal(t, "Successfully setup custom client.", response.Message)
	assert.Equal(t, "SUCCESS", response.Status)
}

func TestSetupFail(t *testing.T) {
	// Given
	sdkService := &SDKService{}
	params := param.SetupParams{
		OperatorAccountId:  "operatorAccountId",
		OperatorPrivateKey: "operatorPrivateKey",
		NodeIp:             stringPointer("nodeIp"),
		NodeAccountId:      stringPointer("3asdf"),
		MirrorNetworkIp:    stringPointer("127.0.0.1:50211"),
	}

	// Then
	_, err := sdkService.Setup(context.Background(), params)
	require.Error(t, err)
}

func TestReset(t *testing.T) {
	// Given
	sdkService := &SDKService{}
	params := param.SetupParams{
		OperatorAccountId:  "0.0.2",
		OperatorPrivateKey: "302e020100300506032b65700422042091132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137",
		NodeIp:             stringPointer("127.0.0.1:50211"),
		NodeAccountId:      stringPointer("0.0.3"),
		MirrorNetworkIp:    stringPointer("http://127.0.0.1:5551"),
	}

	// Setup first to initialize the client
	_, err := sdkService.Setup(context.Background(), params)
	require.NoError(t, err)

	// When
	response := sdkService.Reset(context.Background())

	// Then
	assert.Equal(t, "SUCCESS", response.Status)
	assert.Nil(t, sdkService.Client)
}

func stringPointer(s string) *string {
	return &s
}

func intPointer(i int) *int {
	return &i
}
// Filename: tck/param/account.go
package param

import (
	"encoding/json"
)

type CreateAccountParams struct {
	Key                           *string                  `json:"key"`
	InitialBalance                *int64                   `json:"initialBalance"`
	ReceiverSignatureRequired     *bool                    `json:"receiverSignatureRequired"`
	AutoRenewPeriod               *int64                   `json:"autoRenewPeriod"`
	Memo                          *string                  `json:"memo"`
	MaxAutomaticTokenAssociations *int32                   `json:"maxAutoTokenAssociations"`
	StakedAccountId               *string                  `json:"stakedAccountId"`
	StakedNodeId                  *json.Number             `json:"stakedNodeId"`
	DeclineStakingReward          *bool                    `json:"declineStakingReward"`
	Alias                         *string                  `json:"alias"`
	CommonTransactionParams       *CommonTransactionParams `json:"commonTransactionParams"`
}

type UpdateAccountParams struct {
	AccountId                     *string                  `json:"accountId"`
	Key                           *string                  `json:"key"`
	ReceiverSignatureRequired     *bool                    `json:"receiverSignatureRequired"`
	AutoRenewPeriod               *int64                   `json:"autoRenewPeriod"`
	ExpirationTime                *int64                   `json:"expirationTime"`
	Memo                          *string                  `json:"memo"`
	MaxAutomaticTokenAssociations *int32                   `json:"maxAutoTokenAssociations"`
	StakedAccountId               *string                  `json:"stakedAccountId"`
	StakedNodeId                  *json.Number             `json:"stakedNodeId"`
	DeclineStakingReward          *bool                    `json:"declineStakingReward"`
	CommonTransactionParams       *CommonTransactionParams `json:"commonTransactionParams"`
}
type DeleteAccountParams struct {
	DeleteAccountId         *string                  `json:"deleteAccountId"`
	TransferAccountId       *string                  `json:"transferAccountId"`
	CommonTransactionParams *CommonTransactionParams `json:"commonTransactionParams"`
}
// Filename: tck/param/common.go
package param

import (
	"time"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

type CommonTransactionParams struct {
	TransactionId            *string   `json:"transactionId"`
	MaxTransactionFee        *int64    `json:"maxTransactionFee"`
	ValidTransactionDuration *uint64   `json:"validTransactionDuration"`
	Memo                     *string   `json:"memo"`
	RegenerateTransactionId  *bool     `json:"regenerateTransactionId"`
	Signers                  *[]string `json:"signers"`
}

func (common *CommonTransactionParams) FillOutTransaction(transactionInterface hedera.TransactionInterface, transaction *hedera.Transaction, client *hedera.Client) {
	if common.TransactionId != nil {
		txId, _ := hedera.TransactionIdFromString(*common.TransactionId)
		transaction.SetTransactionID(txId)
	}

	if common.MaxTransactionFee != nil {
		transaction.SetMaxTransactionFee(hedera.HbarFromTinybar(*common.MaxTransactionFee))
	}

	if common.ValidTransactionDuration != nil {
		transaction.SetTransactionValidDuration(time.Duration(*common.ValidTransactionDuration) * time.Second)
	}

	if common.Memo != nil {
		transaction.SetTransactionMemo(*common.Memo)
	}

	if common.RegenerateTransactionId != nil {
		transaction.SetRegenerateTransactionID(*common.RegenerateTransactionId)
	}

	if common.Signers != nil {
		transaction.FreezeWith(client, transactionInterface)
		for _, signer := range *common.Signers {
			s, _ := hedera.PrivateKeyFromString(signer)
			transaction.Sign(s)
		}
	}
}
// Filename: tck/param/key.go
package param

type KeyType string

const (
	ED25519_PRIVATE_KEY         KeyType = "ed25519PrivateKey"
	ED25519_PUBLIC_KEY          KeyType = "ed25519PublicKey"
	ECDSA_SECP256K1_PRIVATE_KEY KeyType = "ecdsaSecp256k1PrivateKey"
	ECDSA_SECP256K1_PUBLIC_KEY  KeyType = "ecdsaSecp256k1PublicKey"
	LIST_KEY                    KeyType = "keyList"
	THRESHOLD_KEY               KeyType = "thresholdKey"
	EVM_ADDRESS_KEY             KeyType = "evmAddress"
)

type KeyParams struct {
	Type      KeyType      `json:"type"`
	FromKey   *string      `json:"fromKey"`
	Threshold *int         `json:"threshold"`
	Keys      *[]KeyParams `json:"keys"`
}
// Filename: tck/param/sdk.go
package param

type SetupParams struct {
	OperatorAccountId  string  `json:"operatorAccountId"`
	OperatorPrivateKey string  `json:"operatorPrivateKey"`
	NodeIp             *string `json:"nodeIp"`
	NodeAccountId      *string `json:"nodeAccountId"`
	MirrorNetworkIp    *string `json:"mirrorNetworkIp"`
}
// Filename: tck/response/account.go
package response

type AccountResponse struct {
	AccountId string `json:"accountId"`
	Status    string `json:"status"`
}
// Filename: tck/response/error.go
package response

import (
	"github.com/creachadair/jrpc2"
	"github.com/hashgraph/hedera-sdk-go/v2"
)

// see https://json-rpc.readthedocs.io/en/latest/exceptions.html
// some of the response codes are handled internally in the jrpc2 lib
const (
	InvalidParamsCode = -32602
	HederaErrorCode   = -32001
)

var (
	InvalidParams = jrpc2.Errorf(InvalidParamsCode, "Invalid params")
	InternalError = jrpc2.Errorf(jrpc2.InternalError, "Internal error")
	HederaError   = jrpc2.Errorf(HederaErrorCode, "Hedera error")
)

type ErrorData struct {
	Status  string `json:"status"`
	Message string `json:"message"`
}

func NewHederaReceiptError(err hedera.ErrHederaReceiptStatus) error {
	return HederaError.WithData(&ErrorData{Status: err.Status.String(), Message: err.Error()})
}

func NewHederaPrecheckError(err hedera.ErrHederaPreCheckStatus) error {
	return HederaError.WithData(&ErrorData{Status: err.Status.String(), Message: err.Error()})
}
// Filename: tck/response/key.go
package response

type GenerateKeyResponse struct {
	Key         string   `json:"key"`
	PrivateKeys []string `json:"privateKeys"`
}
// Filename: tck/response/sdk.go
package response

type SetupResponse struct {
	Message string
	Status  string
}
// Filename: tck/utils/key.go
package utils

import (
	"encoding/hex"
	"errors"

	"github.com/hashgraph/hedera-sdk-go/v2"
)

var ErrFromKeyShouldBeProvided = errors.New("invalid parameters: fromKey should only be provided for ed25519PublicKey, ecdsaSecp256k1PublicKey, or evmAddress types")
var ErrThresholdTypeShouldBeProvided = errors.New("invalid parameters: threshold should only be provided for thresholdKey types")
var ErrKeysShouldBeProvided = errors.New("invalid parameters: keys should only be provided for keyList or thresholdKey types")
var ErrKeylistRequired = errors.New("invalid request: keys list is required for generating a KeyList type")
var ErrThresholdRequired = errors.New("invalid request: threshold is required for generating a ThresholdKey type")

func getKeyListFromString(keyStr string) (hedera.Key, error) {
	bytes, err := hex.DecodeString(keyStr)
	if err != nil {
		return hedera.KeyList{}, err
	}

	return hedera.KeyFromBytes(bytes)
}

func GetKeyFromString(keyStr string) (hedera.Key, error) {
	key, err := hedera.PublicKeyFromString(keyStr)
	if err != nil {
		key, err := hedera.PrivateKeyFromStringDer(keyStr)
		if err != nil {
			return getKeyListFromString(keyStr)
		}
		return key, nil
	}
	return key, nil
}
// Filename: time.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

func _DurationToProtobuf(duration time.Duration) *services.Duration {
	return &services.Duration{
		Seconds: int64(duration.Seconds()),
	}
}

func _DurationFromProtobuf(pb *services.Duration) time.Duration {
	if pb == nil {
		return time.Duration(0)
	}
	return time.Duration(pb.Seconds * int64(time.Second))
}

func _TimeToProtobuf(t time.Time) *services.Timestamp {
	return &services.Timestamp{
		Seconds: t.Unix(),
		Nanos:   int32(t.UnixNano() - (t.Unix() * 1e+9)),
	}
}

func _TimeFromProtobuf(pb *services.Timestamp) time.Time {
	if pb == nil {
		return time.Time{}
	}
	return time.Unix(pb.Seconds, int64(pb.Nanos))
}
// Filename: token_airdrop_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

type TokenAirdropTransaction struct {
	Transaction
	tokenTransfers map[TokenID]*_TokenTransfer
	nftTransfers   map[TokenID][]*_TokenNftTransfer
}

func NewTokenAirdropTransaction() *TokenAirdropTransaction {
	tx := TokenAirdropTransaction{
		Transaction:    _NewTransaction(),
		tokenTransfers: make(map[TokenID]*_TokenTransfer),
		nftTransfers:   make(map[TokenID][]*_TokenNftTransfer),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(1))

	return &tx
}

func _TokenAirdropTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenAirdropTransaction {
	tokenTransfers := make(map[TokenID]*_TokenTransfer)
	nftTransfers := make(map[TokenID][]*_TokenNftTransfer)

	for _, tokenTransfersList := range pb.GetTokenAirdrop().GetTokenTransfers() {
		tok := _TokenIDFromProtobuf(tokenTransfersList.Token)
		tokenTransfers[*tok] = _TokenTransferPrivateFromProtobuf(tokenTransfersList)
	}

	for _, tokenTransfersList := range pb.GetTokenAirdrop().GetTokenTransfers() {
		if tokenID := _TokenIDFromProtobuf(tokenTransfersList.Token); tokenID != nil {
			for _, aa := range tokenTransfersList.GetNftTransfers() {
				if nftTransfers[*tokenID] == nil {
					nftTransfers[*tokenID] = make([]*_TokenNftTransfer, 0)
				}
				nftTransfer := _NftTransferFromProtobuf(aa)
				nftTransfers[*tokenID] = append(nftTransfers[*tokenID], &nftTransfer)
			}
		}
	}

	return &TokenAirdropTransaction{
		Transaction:    tx,
		tokenTransfers: tokenTransfers,
		nftTransfers:   nftTransfers,
	}
}

// SetTokenTransferApproval Sets the desired token unit balance adjustments
func (tx *TokenAirdropTransaction) SetTokenTransferApproval(tokenID TokenID, accountID AccountID, approval bool) *TokenAirdropTransaction { //nolint
	for token, tokenTransfer := range tx.tokenTransfers {
		if token.equals(tokenID) {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID._Equals(accountID) {
					transfer.IsApproved = approval
				}
			}
		}
	}

	return tx
}

// SetNftTransferApproval Sets the desired nft token unit balance adjustments
func (tx *TokenAirdropTransaction) SetNftTransferApproval(nftID NftID, approval bool) *TokenAirdropTransaction {
	for token, nftTransfers := range tx.nftTransfers {
		if token.equals(nftID.TokenID) {
			for _, nftTransfer := range nftTransfers {
				if nftTransfer.SerialNumber == nftID.SerialNumber {
					nftTransfer.IsApproved = approval
				}
			}
		}
	}
	return tx
}

// GetNftTransfers returns the nft transfers
func (tx *TokenAirdropTransaction) GetNftTransfers() map[TokenID][]_TokenNftTransfer {
	nftResult := make(map[TokenID][]_TokenNftTransfer)
	for token, nftTransfers := range tx.nftTransfers {
		tempArray := make([]_TokenNftTransfer, 0)
		for _, nftTransfer := range nftTransfers {
			tempArray = append(tempArray, *nftTransfer)
		}

		nftResult[token] = tempArray
	}

	return nftResult
}

// GetTokenTransfers returns the token transfers
func (tx *TokenAirdropTransaction) GetTokenTransfers() map[TokenID][]TokenTransfer {
	transfers := make(map[TokenID][]TokenTransfer)
	for tokenID, tokenTransfers := range tx.tokenTransfers {
		tokenTransfersList := make([]TokenTransfer, 0)

		for _, transfer := range tokenTransfers.Transfers {
			var acc AccountID
			if transfer.accountID != nil {
				acc = *transfer.accountID
			}
			tokenTransfersList = append(tokenTransfersList, TokenTransfer{
				AccountID:  acc,
				Amount:     transfer.Amount.AsTinybar(),
				IsApproved: transfer.IsApproved,
			})
		}

		tempTokenTransferList := _TokenTransfers{tokenTransfersList}

		transfers[tokenID] = tempTokenTransferList.transfers
	}

	return transfers
}

// GetTokenIDDecimals returns the token decimals
func (tx *TokenAirdropTransaction) GetTokenIDDecimals() map[TokenID]uint32 {
	result := make(map[TokenID]uint32)
	for token, tokenTransfer := range tx.tokenTransfers {
		if tokenTransfer.ExpectedDecimals != nil {
			result[token] = *tokenTransfer.ExpectedDecimals
		}
	}
	return result
}

// AddTokenTransferWithDecimals Sets the desired token unit balance adjustments with decimals
func (tx *TokenAirdropTransaction) AddTokenTransferWithDecimals(tokenID TokenID, accountID AccountID, value int64, decimal uint32) *TokenAirdropTransaction { //nolint
	tx._RequireNotFrozen()

	for token, tokenTransfer := range tx.tokenTransfers {
		if token.equals(tokenID) {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID._Equals(accountID) {
					transfer.Amount = HbarFromTinybar(transfer.Amount.AsTinybar() + value)
					tokenTransfer.ExpectedDecimals = &decimal

					return tx
				}
			}
		}
	}

	if v, ok := tx.tokenTransfers[tokenID]; ok {
		v.Transfers = append(v.Transfers, &_HbarTransfer{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: false,
		})
		v.ExpectedDecimals = &decimal

		return tx
	}

	tx.tokenTransfers[tokenID] = &_TokenTransfer{
		Transfers: []*_HbarTransfer{{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: false,
		}},
		ExpectedDecimals: &decimal,
	}

	return tx
}

// AddTokenTransfer Sets the desired token unit balance adjustments
// Applicable to tokens of type FUNGIBLE_COMMON.
func (tx *TokenAirdropTransaction) AddTokenTransfer(tokenID TokenID, accountID AccountID, value int64) *TokenAirdropTransaction { //nolint
	tx._RequireNotFrozen()

	for token, tokenTransfer := range tx.tokenTransfers {
		if token.equals(tokenID) {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID._Equals(accountID) {
					transfer.Amount = HbarFromTinybar(transfer.Amount.AsTinybar() + value)

					return tx
				}
			}
		}
	}

	if v, ok := tx.tokenTransfers[tokenID]; ok {
		v.Transfers = append(v.Transfers, &_HbarTransfer{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: false,
		})

		return tx
	}

	tx.tokenTransfers[tokenID] = &_TokenTransfer{
		Transfers: []*_HbarTransfer{{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: false,
		}},
	}

	return tx
}

// AddNftTransfer Sets the desired nft token unit balance adjustments
// Applicable to tokens of type NON_FUNGIBLE_UNIQUE.
func (tx *TokenAirdropTransaction) AddNftTransfer(nftID NftID, sender AccountID, receiver AccountID) *TokenAirdropTransaction {
	tx._RequireNotFrozen()

	if tx.nftTransfers == nil {
		tx.nftTransfers = make(map[TokenID][]*_TokenNftTransfer)
	}

	if tx.nftTransfers[nftID.TokenID] == nil {
		tx.nftTransfers[nftID.TokenID] = make([]*_TokenNftTransfer, 0)
	}

	tx.nftTransfers[nftID.TokenID] = append(tx.nftTransfers[nftID.TokenID], &_TokenNftTransfer{
		SenderAccountID:   sender,
		ReceiverAccountID: receiver,
		SerialNumber:      nftID.SerialNumber,
	})

	return tx
}

// AddApprovedTokenTransferWithDecimals adds an approved token transfer with decimals
func (tx *TokenAirdropTransaction) AddApprovedTokenTransferWithDecimals(tokenID TokenID, accountID AccountID, value int64, decimal uint32, approve bool) *TokenAirdropTransaction { //nolint
	tx._RequireNotFrozen()

	for token, tokenTransfer := range tx.tokenTransfers {
		if token.equals(tokenID) {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID._Equals(accountID) {
					transfer.Amount = HbarFromTinybar(transfer.Amount.AsTinybar() + value)
					tokenTransfer.ExpectedDecimals = &decimal
					for _, transfer := range tokenTransfer.Transfers {
						transfer.IsApproved = approve
					}

					return tx
				}
			}
		}
	}

	if v, ok := tx.tokenTransfers[tokenID]; ok {
		v.Transfers = append(v.Transfers, &_HbarTransfer{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: approve,
		})
		v.ExpectedDecimals = &decimal

		return tx
	}

	tx.tokenTransfers[tokenID] = &_TokenTransfer{
		Transfers: []*_HbarTransfer{{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: approve,
		}},
		ExpectedDecimals: &decimal,
	}

	return tx
}

// AddApprovedTokenTransfer adds an approved token transfer
func (tx *TokenAirdropTransaction) AddApprovedTokenTransfer(tokenID TokenID, accountID AccountID, value int64, approve bool) *TokenAirdropTransaction { //nolint
	tx._RequireNotFrozen()

	for token, tokenTransfer := range tx.tokenTransfers {
		if token.equals(tokenID) {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID._Equals(accountID) {
					transfer.Amount = HbarFromTinybar(transfer.Amount.AsTinybar() + value)
					transfer.IsApproved = approve

					return tx
				}
			}
		}
	}

	if v, ok := tx.tokenTransfers[tokenID]; ok {
		v.Transfers = append(v.Transfers, &_HbarTransfer{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: approve,
		})

		return tx
	}

	tx.tokenTransfers[tokenID] = &_TokenTransfer{
		Transfers: []*_HbarTransfer{{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: approve,
		}},
	}

	return tx
}

// AddApprovedNftTransfer adds an approved nft transfer
func (tx *TokenAirdropTransaction) AddApprovedNftTransfer(nftID NftID, sender AccountID, receiver AccountID, approve bool) *TokenAirdropTransaction {
	tx._RequireNotFrozen()

	if tx.nftTransfers == nil {
		tx.nftTransfers = make(map[TokenID][]*_TokenNftTransfer)
	}

	if tx.nftTransfers[nftID.TokenID] == nil {
		tx.nftTransfers[nftID.TokenID] = make([]*_TokenNftTransfer, 0)
	}

	tx.nftTransfers[nftID.TokenID] = append(tx.nftTransfers[nftID.TokenID], &_TokenNftTransfer{
		SenderAccountID:   sender,
		ReceiverAccountID: receiver,
		SerialNumber:      nftID.SerialNumber,
		IsApproved:        approve,
	})

	return tx
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenAirdropTransaction) Sign(privateKey PrivateKey) *TokenAirdropTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenAirdropTransaction) SignWithOperator(client *Client) (*TokenAirdropTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenAirdropTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenAirdropTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenAirdropTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenAirdropTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenAirdropTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenAirdropTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenAirdropTransaction) Freeze() (*TokenAirdropTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenAirdropTransaction) FreezeWith(client *Client) (*TokenAirdropTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenAirdropTransaction.
func (tx *TokenAirdropTransaction) SetMaxTransactionFee(fee Hbar) *TokenAirdropTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenAirdropTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenAirdropTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenAirdropTransaction.
func (tx *TokenAirdropTransaction) SetTransactionMemo(memo string) *TokenAirdropTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenAirdropTransaction.
func (tx *TokenAirdropTransaction) SetTransactionValidDuration(duration time.Duration) *TokenAirdropTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenAirdropTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenAirdropTransaction.
func (tx *TokenAirdropTransaction) SetTransactionID(transactionID TransactionID) *TokenAirdropTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenAirdropTransaction.
func (tx *TokenAirdropTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenAirdropTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenAirdropTransaction) SetMaxRetry(count int) *TokenAirdropTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenAirdropTransaction) SetMaxBackoff(max time.Duration) *TokenAirdropTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenAirdropTransaction) SetMinBackoff(min time.Duration) *TokenAirdropTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenAirdropTransaction) SetLogLevel(level LogLevel) *TokenAirdropTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenAirdropTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenAirdropTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenAirdropTransaction) getName() string {
	return "TokenAirdropTransaction"
}

func (tx *TokenAirdropTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}
	var err error
	for token, tokenTransfer := range tx.tokenTransfers {
		err = token.ValidateChecksum(client)
		if err != nil {
			return err
		}
		for _, transfer := range tokenTransfer.Transfers {
			err = transfer.accountID.ValidateChecksum(client)
			if err != nil {
				return err
			}
		}
		if err != nil {
			return err
		}
	}
	for token, nftTransfers := range tx.nftTransfers {
		err = token.ValidateChecksum(client)
		if err != nil {
			return err
		}
		for _, nftTransfer := range nftTransfers {
			err = nftTransfer.SenderAccountID.ValidateChecksum(client)
			if err != nil {
				return err
			}
			err = nftTransfer.ReceiverAccountID.ValidateChecksum(client)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (tx *TokenAirdropTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenAirdrop{
			TokenAirdrop: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenAirdropTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenAirdrop{
			TokenAirdrop: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenAirdropTransaction) buildProtoBody() *services.TokenAirdropTransactionBody {
	body := &services.TokenAirdropTransactionBody{
		TokenTransfers: []*services.TokenTransferList{},
	}

	if len(tx.tokenTransfers) > 0 {
		if body.TokenTransfers == nil {
			body.TokenTransfers = make([]*services.TokenTransferList, 0)
		}

		for tokenID := range tx.tokenTransfers {
			transfers := tx.tokenTransfers[tokenID]._ToProtobuf()

			bod := &services.TokenTransferList{
				Token:     tokenID._ToProtobuf(),
				Transfers: transfers,
			}

			if tx.tokenTransfers[tokenID].ExpectedDecimals != nil {
				bod.ExpectedDecimals = &wrapperspb.UInt32Value{Value: *tx.tokenTransfers[tokenID].ExpectedDecimals}
			}

			body.TokenTransfers = append(body.TokenTransfers, bod)
		}
	}

	if len(tx.nftTransfers) > 0 {
		if body.TokenTransfers == nil {
			body.TokenTransfers = make([]*services.TokenTransferList, 0)
		}

		for tokenID, nftTransferList := range tx.nftTransfers {
			nftTransfers := make([]*services.NftTransfer, 0)

			for _, nftT := range nftTransferList {
				nftTransfers = append(nftTransfers, nftT._ToProtobuf())
			}

			body.TokenTransfers = append(body.TokenTransfers, &services.TokenTransferList{
				Token:        tokenID._ToProtobuf(),
				NftTransfers: nftTransfers,
			})
		}
	}

	return body
}

func (tx *TokenAirdropTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().AirdropTokens,
	}
}

func (tx *TokenAirdropTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_airdrop_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenAirdropTransactionTransfersTokensWhenAssociated(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create ft and nft
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftSerials := receipt.SerialNumbers

	// Create receiver with unlimited auto associations and receiverSig = false
	receiver, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver).
		AddTokenTransfer(tokenID, receiver, 100).
		AddTokenTransfer(tokenID, env.OperatorID, -100).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = airdropTx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Verify the receiver holds the tokens via query
	receiverAccountBalance, err := NewAccountBalanceQuery().
		SetAccountID(receiver).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(100), receiverAccountBalance.Tokens.Get(tokenID))
	assert.Equal(t, uint64(2), receiverAccountBalance.Tokens.Get(nftID))

	// Verify the operator does not hold the tokens
	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1_000_000-100), operatorBalance.Tokens.Get(tokenID))
	assert.Equal(t, uint64(8), operatorBalance.Tokens.Get(nftID))
}
func TestIntegrationTokenAirdropTransactionPendingTokensWhenNotAssociated(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create ft and nft
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftSerials := receipt.SerialNumbers

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver).
		AddTokenTransfer(tokenID, receiver, 100).
		AddTokenTransfer(tokenID, env.OperatorID, -100).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// verify the pending airdrop record
	assert.Equal(t, 3, len(record.PendingAirdropRecords))
	assert.Equal(t, uint64(100), record.PendingAirdropRecords[0].pendingAirdropAmount)
	assert.Nil(t, record.PendingAirdropRecords[0].pendingAirdropId.nftID)
	assert.Equal(t, tokenID, *record.PendingAirdropRecords[0].pendingAirdropId.tokenID)

	assert.Equal(t, uint64(0), record.PendingAirdropRecords[1].pendingAirdropAmount)
	assert.Nil(t, record.PendingAirdropRecords[1].pendingAirdropId.tokenID)
	assert.Equal(t, nftID.Nft(nftSerials[0]), *record.PendingAirdropRecords[1].pendingAirdropId.nftID)

	assert.Equal(t, uint64(0), record.PendingAirdropRecords[2].pendingAirdropAmount)
	assert.Nil(t, record.PendingAirdropRecords[2].pendingAirdropId.tokenID)
	assert.Equal(t, nftID.Nft(nftSerials[1]), *record.PendingAirdropRecords[2].pendingAirdropId.nftID)

	// Verify the receiver does not hold the tokens via query
	receiverAccountBalance, err := NewAccountBalanceQuery().
		SetAccountID(receiver).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(0), receiverAccountBalance.Tokens.Get(tokenID))
	assert.Equal(t, uint64(0), receiverAccountBalance.Tokens.Get(nftID))

	// Verify the operator does hold the tokens
	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1_000_000), operatorBalance.Tokens.Get(tokenID))
	assert.Equal(t, uint64(10), operatorBalance.Tokens.Get(nftID))
}

func TestIntegrationTokenAirdropTransactionCreatesHollowAccount(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create ft and nft
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftSerials := receipt.SerialNumbers

	// Create a ECDSA private key
	privateKey, err := PrivateKeyGenerateEcdsa()
	if err != nil {
		println(err.Error())
	}
	// Extract the ECDSA public key public key
	publicKey := privateKey.PublicKey()

	aliasAccountId := publicKey.ToAccountID(0, 0)

	// should lazy-create and transfer the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, *aliasAccountId).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, *aliasAccountId).
		AddTokenTransfer(tokenID, *aliasAccountId, 100).
		AddTokenTransfer(tokenID, env.OperatorID, -100).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Verify the receiver holds the tokens via query
	receiverAccountBalance, err := NewAccountBalanceQuery().
		SetAccountID(*aliasAccountId).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(100), receiverAccountBalance.Tokens.Get(tokenID))
	assert.Equal(t, uint64(2), receiverAccountBalance.Tokens.Get(nftID))

	// Verify the operator does not hold the tokens
	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1_000_000-100), operatorBalance.Tokens.Get(tokenID))
	assert.Equal(t, uint64(8), operatorBalance.Tokens.Get(nftID))
}

func TestIntegrationTokenAirdropTransactionWithCustomFees(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create receiver with unlimited auto associations and receiverSig = false
	receiver, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// create fungible token with custom fee another token
	customFeeTokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// make the custom fee to be paid by the sender and the fee collector to be the operator account
	fee := NewCustomFixedFee().
		SetFeeCollectorAccountID(env.OperatorID).
		SetDenominatingTokenID(customFeeTokenID).
		SetAmount(1).
		SetAllCollectorsAreExempt(true)

	txResponse, err := NewTokenCreateTransaction().
		SetTokenName("Test Fungible Token").
		SetTokenSymbol("TFT").
		SetTokenMemo("I was created for integration tests").
		SetDecimals(3).
		SetInitialSupply(1_000_000).
		SetMaxSupply(1_000_000).
		SetTreasuryAccountID(env.OperatorID).
		SetSupplyType(TokenSupplyTypeFinite).
		SetAdminKey(env.OperatorKey).
		SetFreezeKey(env.OperatorKey).
		SetSupplyKey(env.OperatorKey).
		SetMetadataKey(env.OperatorKey).
		SetPauseKey(env.OperatorKey).
		SetCustomFees([]Fee{fee}).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	tokenID := receipt.TokenID

	// create sender account with unlimited associations and send some tokens to it
	sender, senderKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// associate the token to the sender
	frozenTxn, err := NewTokenAssociateTransaction().
		SetAccountID(sender).
		AddTokenID(*tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	txResponse, err = frozenTxn.Sign(senderKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// send tokens to the sender
	txResponse, err = NewTransferTransaction().
		AddTokenTransfer(customFeeTokenID, sender, 100).
		AddTokenTransfer(customFeeTokenID, env.OperatorID, -100).
		AddTokenTransfer(*tokenID, sender, 100).
		AddTokenTransfer(*tokenID, env.OperatorID, -100).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// airdrop the tokens from the sender to the receiver
	frozenTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(*tokenID, receiver, 100).
		AddTokenTransfer(*tokenID, sender, -100).
		FreezeWith(env.Client)
	require.NoError(t, err)
	airdropTx, err := frozenTx.
		Sign(senderKey).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// verify the custom fee has been paid by the sender to the collector
	receiverAccountBalance, err := NewAccountBalanceQuery().
		SetAccountID(receiver).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(100), receiverAccountBalance.Tokens.Get(*tokenID))

	senderAccountBalance, err := NewAccountBalanceQuery().
		SetAccountID(sender).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(0), senderAccountBalance.Tokens.Get(*tokenID))
	assert.Equal(t, uint64(99), senderAccountBalance.Tokens.Get(customFeeTokenID))

	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1_000_000-100), operatorBalance.Tokens.Get(*tokenID))
	assert.Equal(t, uint64(1_000_000-100+1), operatorBalance.Tokens.Get(customFeeTokenID))
}
func TestIntegrationTokenAirdropTransactionWithReceiverSigTrue(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create nft
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftSerials := receipt.SerialNumbers

	// create receiver with unlimited auto associations and receiverSig = true
	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	accountCreateFrozen, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetInitialBalance(NewHbar(3)).
		SetReceiverSignatureRequired(true).
		SetMaxAutomaticTokenAssociations(-1).
		FreezeWith(env.Client)
	require.NoError(t, err)
	accountCreate, err := accountCreateFrozen.Sign(newKey).Execute(env.Client)
	require.NoError(t, err)
	receipt, err = accountCreate.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	receiver := *receipt.AccountID

	// airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver).
		AddTokenTransfer(tokenID, receiver, 100).
		AddTokenTransfer(tokenID, env.OperatorID, -100).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = airdropTx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func TestIntegrationTokenAirdropTransactionWithNoBalanceFT(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// create fungible token
	tokenID, _ := createFungibleToken(&env)

	// create spender and approve to it some tokens
	spender, spenderKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// create sender
	sender, senderKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// transfer ft to sender
	txResponse, err := NewTransferTransaction().
		AddTokenTransfer(tokenID, sender, 100).
		AddTokenTransfer(tokenID, env.OperatorID, -100).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// approve allowance to the spender
	frozenTx, err := NewAccountAllowanceApproveTransaction().
		ApproveTokenAllowance(tokenID, sender, spender, 100).
		FreezeWith(env.Client)
	require.NoError(t, err)
	txResponse, err = frozenTx.Sign(senderKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// airdrop the tokens from the sender to the spender via approval
	frozenTxn, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, spender, 100).
		AddApprovedTokenTransfer(tokenID, sender, -100, true).
		SetTransactionID(TransactionIDGenerate(spender)).
		FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTxn.
		Sign(spenderKey).
		Execute(env.Client)
	assert.ErrorContains(t, err, "NOT_SUPPORTED")
}

func TestIntegrationTokenAirdropTransactionWithNoBalanceNFT(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// create nft
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftSerials := receipt.SerialNumbers

	// create spender and approve to it some tokens
	spender, spenderKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// create sender
	sender, senderKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	// transfer ft to sender
	txResponse, err = NewTransferTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, sender).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, sender).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// approve allowance to the spender
	frozenTx, err := NewAccountAllowanceApproveTransaction().
		ApproveTokenNftAllowance(nftID.Nft(nftSerials[0]), sender, spender).
		ApproveTokenNftAllowance(nftID.Nft(nftSerials[1]), sender, spender).
		FreezeWith(env.Client)
	require.NoError(t, err)
	txResponse, err = frozenTx.Sign(senderKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// airdrop the tokens from the sender to the spender via approval
	frozenTxn, err := NewTokenAirdropTransaction().
		AddApprovedNftTransfer(nftID.Nft(nftSerials[0]), sender, spender, true).
		AddApprovedNftTransfer(nftID.Nft(nftSerials[1]), sender, spender, true).
		SetTransactionID(TransactionIDGenerate(spender)).
		FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTxn.
		Sign(spenderKey).
		Execute(env.Client)
	assert.ErrorContains(t, err, "NOT_SUPPORTED")
}

func TestIntegrationTokenAirdropTransactionWithInvalidBody(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// create fungible token
	tokenID, _ := createFungibleToken(&env)

	// create receiver
	receiver, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(-1)
	})
	require.NoError(t, err)

	_, err = NewTokenAirdropTransaction().
		Execute(env.Client)
	require.ErrorContains(t, err, "EMPTY_TOKEN_TRANSFER_BODY")

	_, err = NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, 100).
		AddTokenTransfer(tokenID, receiver, 100).
		Execute(env.Client)
	require.ErrorContains(t, err, "INVALID_TRANSACTION_BODY")
}
// Filename: token_airdrop_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnitTokenAirdropTransactionSetTokenTransferWithDecimals(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	senderAccountID := AccountID{Account: 2}
	amount := int64(10)
	decimals := uint32(5)

	transaction := NewTokenAirdropTransaction().
		AddTokenTransferWithDecimals(tokenID, senderAccountID, amount, decimals)

	require.Equal(t, transaction.GetTokenIDDecimals()[tokenID], decimals)
}

func TestUnitTokenAirdropTransactionAddApprovedTokenTransferWithDecimals(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	accountID := AccountID{Account: 2}
	amount := int64(100)
	decimals := uint32(5)

	transaction := NewTokenAirdropTransaction().
		AddApprovedTokenTransferWithDecimals(tokenID, accountID, amount, decimals, true)

	transfers := transaction.GetTokenTransfers()
	require.NotNil(t, transfers)
	require.Contains(t, transfers, tokenID)
	require.Len(t, transfers[tokenID], 1)
	assert.Equal(t, accountID, transfers[tokenID][0].AccountID)
	assert.Equal(t, amount, transfers[tokenID][0].Amount)
	assert.True(t, transfers[tokenID][0].IsApproved)
	assert.Equal(t, decimals, transaction.GetTokenIDDecimals()[tokenID])
}

func TestUnitTokenAirdropTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	nodeAccountIDs := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 123})

	checksum := "dmqui"

	token := TokenID{Token: 3, checksum: &checksum}
	nft := NftID{TokenID: TokenID{Token: 3, checksum: &checksum}, SerialNumber: 1}
	airdrop := NewTokenAirdropTransaction().
		AddTokenTransfer(token, accountID, 100).
		AddNftTransfer(nft, accountID, accountID).
		SetTransactionID(transactionID).SetNodeAccountIDs(nodeAccountIDs).
		SetMaxTransactionFee(HbarFromTinybar(100)).SetRegenerateTransactionID(true).
		SetTransactionMemo("go sdk unit test").SetTransactionValidDuration(time.Second * 120).
		SetMaxRetry(1).SetMaxBackoff(time.Second * 120).SetMinBackoff(time.Second * 1)

	err = airdrop.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenAirdropTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	airdrop := NewTokenAirdropTransaction().
		AddTokenTransfer(TokenID{Token: 1}, accountID, 100)

	err = airdrop.validateNetworkOnIDs(client)
	require.Error(t, err)
}

func TestUnitTokenAirdropTransactionAddTokenTransfer(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	accountID := AccountID{Account: 2}
	amount := int64(100)

	transaction := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, accountID, amount)

	transfers := transaction.GetTokenTransfers()
	require.NotNil(t, transfers)
	require.Contains(t, transfers, tokenID)
	require.Len(t, transfers[tokenID], 1)
	assert.Equal(t, accountID, transfers[tokenID][0].AccountID)
	assert.Equal(t, amount, transfers[tokenID][0].Amount)
}

func TestUnitTokenAirdropTransactionAddNftTransfer(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	serialNumber := int64(1)
	nftID := NftID{TokenID: tokenID, SerialNumber: serialNumber}
	sender := AccountID{Account: 2}
	receiver := AccountID{Account: 3}

	transaction := NewTokenAirdropTransaction().
		AddNftTransfer(nftID, sender, receiver)

	nftTransfers := transaction.GetNftTransfers()
	require.NotNil(t, nftTransfers)
	require.Contains(t, nftTransfers, tokenID)
	require.Len(t, nftTransfers[tokenID], 1)
	assert.Equal(t, sender, nftTransfers[tokenID][0].SenderAccountID)
	assert.Equal(t, receiver, nftTransfers[tokenID][0].ReceiverAccountID)
	assert.Equal(t, serialNumber, nftTransfers[tokenID][0].SerialNumber)
}

func TestUnitTokenAirdropTransactionSetTokenTransferApproval(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	accountID := AccountID{Account: 2}
	amount := int64(100)

	transaction := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, accountID, amount).
		SetTokenTransferApproval(tokenID, accountID, true)

	transfers := transaction.GetTokenTransfers()
	require.NotNil(t, transfers)
	require.Contains(t, transfers, tokenID)
	require.Len(t, transfers[tokenID], 1)
	assert.True(t, transfers[tokenID][0].IsApproved)
}

func TestUnitTokenAirdropTransactionSetNftTransferApproval(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	serialNumber := int64(1)
	nftID := NftID{TokenID: tokenID, SerialNumber: serialNumber}
	sender := AccountID{Account: 2}
	receiver := AccountID{Account: 3}

	transaction := NewTokenAirdropTransaction().
		AddNftTransfer(nftID, sender, receiver).
		SetNftTransferApproval(nftID, true)

	nftTransfers := transaction.GetNftTransfers()
	require.NotNil(t, nftTransfers)
	require.Contains(t, nftTransfers, tokenID)
	require.Len(t, nftTransfers[tokenID], 1)
	assert.True(t, nftTransfers[tokenID][0].IsApproved)
}

func TestUnitTokenAirdropTransactionAddApprovedTokenTransfer(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	accountID := AccountID{Account: 2}
	amount := int64(100)

	transaction := NewTokenAirdropTransaction().
		AddApprovedTokenTransfer(tokenID, accountID, amount, true)

	transfers := transaction.GetTokenTransfers()
	require.NotNil(t, transfers)
	require.Contains(t, transfers, tokenID)
	require.Len(t, transfers[tokenID], 1)
	assert.Equal(t, accountID, transfers[tokenID][0].AccountID)
	assert.Equal(t, amount, transfers[tokenID][0].Amount)
	assert.True(t, transfers[tokenID][0].IsApproved)
}

func TestUnitTokenAirdropTransactionAddApprovedNftTransfer(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	serialNumber := int64(1)
	nftID := NftID{TokenID: tokenID, SerialNumber: serialNumber}
	sender := AccountID{Account: 2}
	receiver := AccountID{Account: 3}

	transaction := NewTokenAirdropTransaction().
		AddApprovedNftTransfer(nftID, sender, receiver, true)

	nftTransfers := transaction.GetNftTransfers()
	require.NotNil(t, nftTransfers)
	require.Contains(t, nftTransfers, tokenID)
	require.Len(t, nftTransfers[tokenID], 1)
	assert.Equal(t, sender, nftTransfers[tokenID][0].SenderAccountID)
	assert.Equal(t, receiver, nftTransfers[tokenID][0].ReceiverAccountID)
	assert.Equal(t, serialNumber, nftTransfers[tokenID][0].SerialNumber)
	assert.True(t, nftTransfers[tokenID][0].IsApproved)
}

func TestUnitTokenAirdropTransactionToBytes(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	accountID := AccountID{Account: 2}
	amount := int64(100)

	transaction := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, accountID, amount)

	bytes, err := transaction.ToBytes()
	require.NoError(t, err)
	require.NotNil(t, bytes)
}

func TestUnitTokenAirdropTransactionFromBytes(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	accountID := AccountID{Account: 2}
	amount := int64(100)

	transaction := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, accountID, amount)

	bytes, err := transaction.ToBytes()
	require.NoError(t, err)
	require.NotNil(t, bytes)

	deserializedTransaction, err := TransactionFromBytes(bytes)
	require.NoError(t, err)

	switch tx := deserializedTransaction.(type) {
	case TokenAirdropTransaction:
		assert.Equal(t, transaction.GetTokenTransfers(), tx.GetTokenTransfers())
	default:
		t.Fatalf("expected TokenAirdropTransaction, got %T", deserializedTransaction)
	}
}

func TestUnitTokenAirdropTransactionScheduleProtobuf(t *testing.T) {
	t.Parallel()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	tokenID1 := TokenID{Token: 1}
	tokenID2 := TokenID{Token: 2}
	accountID1 := AccountID{Account: 1}
	accountID2 := AccountID{Account: 2}
	amount1 := int64(100)
	amount2 := int64(200)
	serialNumber1 := int64(1)
	serialNumber2 := int64(2)

	tx, err := NewTokenAirdropTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		AddTokenTransfer(tokenID1, accountID1, amount1).
		AddTokenTransfer(tokenID2, accountID2, amount2).
		AddNftTransfer(tokenID1.Nft(serialNumber1), accountID1, accountID2).
		AddNftTransfer(tokenID2.Nft(serialNumber2), accountID2, accountID1).
		Freeze()
	require.NoError(t, err)

	expected := &services.SchedulableTransactionBody{
		TransactionFee: 100000000,
		Data: &services.SchedulableTransactionBody_TokenAirdrop{
			TokenAirdrop: &services.TokenAirdropTransactionBody{
				TokenTransfers: []*services.TokenTransferList{
					{
						Token: tokenID1._ToProtobuf(),
						Transfers: []*services.AccountAmount{
							{
								AccountID: accountID1._ToProtobuf(),
								Amount:    amount1,
							},
						},
					},
					{
						Token: tokenID2._ToProtobuf(),
						Transfers: []*services.AccountAmount{
							{
								AccountID: accountID2._ToProtobuf(),
								Amount:    amount2,
							},
						},
					},
					{
						Token: tokenID1._ToProtobuf(),
						NftTransfers: []*services.NftTransfer{
							{
								SenderAccountID:   accountID1._ToProtobuf(),
								ReceiverAccountID: accountID2._ToProtobuf(),
								SerialNumber:      serialNumber1,
							},
						},
					},
					{
						Token: tokenID2._ToProtobuf(),
						NftTransfers: []*services.NftTransfer{
							{
								SenderAccountID:   accountID2._ToProtobuf(),
								ReceiverAccountID: accountID1._ToProtobuf(),
								SerialNumber:      serialNumber2,
							},
						},
					},
				},
			},
		},
	}

	actual, err := tx.buildScheduled()
	require.NoError(t, err)
	require.ElementsMatch(t, expected.GetTokenAirdrop().TokenTransfers, actual.GetTokenAirdrop().TokenTransfers)
}
// Filename: token_allowance.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// An approved allowance of token transfers for a spender.
type TokenAllowance struct {
	TokenID          *TokenID
	SpenderAccountID *AccountID
	OwnerAccountID   *AccountID
	Amount           int64
}

// NewTokenAllowance creates a TokenAllowance with the given tokenID, owner, spender, and amount
func NewTokenAllowance(tokenID TokenID, owner AccountID, spender AccountID, amount int64) TokenAllowance { //nolint
	return TokenAllowance{
		TokenID:          &tokenID,
		SpenderAccountID: &spender,
		OwnerAccountID:   &owner,
		Amount:           amount,
	}
}

func _TokenAllowanceFromProtobuf(pb *services.TokenAllowance) TokenAllowance {
	body := TokenAllowance{
		Amount: pb.Amount,
	}

	if pb.TokenId != nil {
		body.TokenID = _TokenIDFromProtobuf(pb.TokenId)
	}

	if pb.Spender != nil {
		body.SpenderAccountID = _AccountIDFromProtobuf(pb.Spender)
	}

	if pb.Owner != nil {
		body.OwnerAccountID = _AccountIDFromProtobuf(pb.Owner)
	}

	return body
}

func (approval *TokenAllowance) _ToProtobuf() *services.TokenAllowance {
	body := &services.TokenAllowance{
		Amount: approval.Amount,
	}

	if approval.SpenderAccountID != nil {
		body.Spender = approval.SpenderAccountID._ToProtobuf()
	}

	if approval.TokenID != nil {
		body.TokenId = approval.TokenID._ToProtobuf()
	}

	if approval.OwnerAccountID != nil {
		body.Owner = approval.OwnerAccountID._ToProtobuf()
	}

	return body
}

// String returns a string representation of the TokenAllowance
func (approval *TokenAllowance) String() string {
	var owner string
	var spender string
	var token string

	if approval.OwnerAccountID != nil {
		owner = approval.OwnerAccountID.String()
	}

	if approval.SpenderAccountID != nil {
		spender = approval.SpenderAccountID.String()
	}

	if approval.TokenID != nil {
		token = approval.TokenID.String()
	}

	return fmt.Sprintf("OwnerAccountID: %s, SpenderAccountID: %s, TokenID: %s, Amount: %s", owner, spender, token, HbarFromTinybar(approval.Amount).String())
}
// Filename: token_allowance_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestUnitNewTokenAllowance(t *testing.T) {
	t.Parallel()

	tokID := TokenID{Token: 3}
	owner := AccountID{Account: 5}
	spender := AccountID{Account: 6}
	amount := int64(100)

	allowance := NewTokenAllowance(tokID, owner, spender, amount)

	newAllowance := TokenAllowance{
		TokenID:          &tokID,
		SpenderAccountID: &spender,
		OwnerAccountID:   &owner,
		Amount:           amount,
	}

	assert.Equal(t, newAllowance, allowance)
}

func TestUnitTokenAllowanceFromProtobuf(t *testing.T) {
	t.Parallel()

	tokID := TokenID{Token: 3}
	owner := AccountID{Account: 5}
	spender := AccountID{Account: 6}
	amount := int64(100)

	allowance := NewTokenAllowance(tokID, owner, spender, amount)

	pb := allowance._ToProtobuf()
	assert.NotNil(t, pb)

	allowance2 := _TokenAllowanceFromProtobuf(pb)
	assert.Equal(t, allowance, allowance2)
}

func TestUnitTokenAllowance_String(t *testing.T) {
	t.Parallel()

	tokID := TokenID{Token: 3}
	owner := AccountID{Account: 5}
	spender := AccountID{Account: 6}
	amount := int64(100)

	allowance := NewTokenAllowance(tokID, owner, spender, amount)

	assert.Equal(t, "OwnerAccountID: 0.0.5, SpenderAccountID: 0.0.6, TokenID: 0.0.3, Amount: 100 tℏ", allowance.String())
}
// Filename: token_associate_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenAssociateTransaction Associates the provided account with the provided tokens. Must be signed by the provided Account's key.
// If the provided account is not found, the transaction will resolve to
// INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to
// ACCOUNT_DELETED.
// If any of the provided tokens is not found, the transaction will resolve to
// INVALID_TOKEN_REF.
// If any of the provided tokens has been deleted, the transaction will resolve to
// TOKEN_WAS_DELETED.
// If an association between the provided account and any of the tokens already exists, the
// transaction will resolve to
// TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.
// If the provided account's associations count exceed the constraint of maximum token
// associations per account, the transaction will resolve to
// TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.
// On success, associations between the provided account and tokens are made and the account is
// ready to interact with the tokens.
type TokenAssociateTransaction struct {
	Transaction
	accountID *AccountID
	tokens    []TokenID
}

// NewTokenAssociateTransaction creates TokenAssociateTransaction which associates the provided account with the provided tokens.
// Must be signed by the provided Account's key.
// If the provided account is not found, the transaction will resolve to
// INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to
// ACCOUNT_DELETED.
// If any of the provided tokens is not found, the transaction will resolve to
// INVALID_TOKEN_REF.
// If any of the provided tokens has been deleted, the transaction will resolve to
// TOKEN_WAS_DELETED.
// If an association between the provided account and any of the tokens already exists, the
// transaction will resolve to
// TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.
// If the provided account's associations count exceed the constraint of maximum token
// associations per account, the transaction will resolve to
// TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.
// On success, associations between the provided account and tokens are made and the account is
// ready to interact with the tokens.
func NewTokenAssociateTransaction() *TokenAssociateTransaction {
	tx := TokenAssociateTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _TokenAssociateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenAssociateTransaction {
	tokens := make([]TokenID, 0)
	for _, token := range pb.GetTokenAssociate().Tokens {
		if tokenID := _TokenIDFromProtobuf(token); tokenID != nil {
			tokens = append(tokens, *tokenID)
		}
	}

	return &TokenAssociateTransaction{
		Transaction: tx,
		accountID:   _AccountIDFromProtobuf(pb.GetTokenAssociate().GetAccount()),
		tokens:      tokens,
	}
}

// SetAccountID Sets the account to be associated with the provided tokens
func (tx *TokenAssociateTransaction) SetAccountID(accountID AccountID) *TokenAssociateTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetAccountID returns the account to be associated with the provided tokens
func (tx *TokenAssociateTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// SetTokenIDs Sets the tokens to be associated with the provided account
func (tx *TokenAssociateTransaction) SetTokenIDs(ids ...TokenID) *TokenAssociateTransaction {
	tx._RequireNotFrozen()
	tx.tokens = make([]TokenID, len(ids))
	copy(tx.tokens, ids)

	return tx
}

// AddTokenID Adds the token to a token list to be associated with the provided account
func (tx *TokenAssociateTransaction) AddTokenID(id TokenID) *TokenAssociateTransaction {
	tx._RequireNotFrozen()
	if tx.tokens == nil {
		tx.tokens = make([]TokenID, 0)
	}

	tx.tokens = append(tx.tokens, id)

	return tx
}

// GetTokenIDs returns the tokens to be associated with the provided account
func (tx *TokenAssociateTransaction) GetTokenIDs() []TokenID {
	tokenIDs := make([]TokenID, len(tx.tokens))
	copy(tokenIDs, tx.tokens)

	return tokenIDs
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenAssociateTransaction) Sign(privateKey PrivateKey) *TokenAssociateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenAssociateTransaction) SignWithOperator(client *Client) (*TokenAssociateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenAssociateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenAssociateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenAssociateTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenAssociateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenAssociateTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenAssociateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenAssociateTransaction) Freeze() (*TokenAssociateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenAssociateTransaction) FreezeWith(client *Client) (*TokenAssociateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenAssociateTransaction.
func (tx *TokenAssociateTransaction) SetMaxTransactionFee(fee Hbar) *TokenAssociateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenAssociateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenAssociateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenAssociateTransaction.
func (tx *TokenAssociateTransaction) SetTransactionMemo(memo string) *TokenAssociateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenAssociateTransaction.
func (tx *TokenAssociateTransaction) SetTransactionValidDuration(duration time.Duration) *TokenAssociateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenAssociateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenAssociateTransaction.
func (tx *TokenAssociateTransaction) SetTransactionID(transactionID TransactionID) *TokenAssociateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenAssociateTransaction.
func (tx *TokenAssociateTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenAssociateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenAssociateTransaction) SetMaxRetry(count int) *TokenAssociateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenAssociateTransaction) SetMaxBackoff(max time.Duration) *TokenAssociateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenAssociateTransaction) SetMinBackoff(min time.Duration) *TokenAssociateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenAssociateTransaction) SetLogLevel(level LogLevel) *TokenAssociateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenAssociateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenAssociateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenAssociateTransaction) getName() string {
	return "TokenAssociateTransaction"
}

func (tx *TokenAssociateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	for _, tokenID := range tx.tokens {
		if err := tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenAssociateTransaction) build() *services.TransactionBody {
	body := tx.buildProtoBody()

	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenAssociate{
			TokenAssociate: body,
		},
	}
}

func (tx *TokenAssociateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenAssociate{
			TokenAssociate: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenAssociateTransaction) buildProtoBody() *services.TokenAssociateTransactionBody {
	body := &services.TokenAssociateTransactionBody{}
	if tx.accountID != nil {
		body.Account = tx.accountID._ToProtobuf()
	}

	if len(tx.tokens) > 0 {
		for _, tokenID := range tx.tokens {
			if body.Tokens == nil {
				body.Tokens = make([]*services.TokenID, 0)
			}
			body.Tokens = append(body.Tokens, tokenID._ToProtobuf())
		}
	}
	return body
}

func (tx *TokenAssociateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().AssociateTokens,
	}
}
func (tx *TokenAssociateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_associate_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenAssociateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID
	println(env.Client.GetOperatorAccountID().String())

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	dissociate, err := NewTokenDissociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = dissociate.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenAssociateTransactionNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_ACCOUNT_ID received for transaction %s", resp.TransactionID), err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTokenAssociateTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenAssociateTransactionAutoAssociate(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetMaxAutomaticTokenAssociations(2).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	toke, err := NewTokenCreateTransaction().
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetDecimals(3).
		SetInitialSupply(2).
		SetTreasuryAccountID(accountID).
		SetAdminKey(newKey.PublicKey()).
		SetFreezeKey(newKey.PublicKey()).
		SetWipeKey(newKey.PublicKey()).
		SetKycKey(newKey.PublicKey()).
		SetSupplyKey(newKey.PublicKey()).
		SetFreezeDefault(false).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		FreezeWith(env.Client)
	require.NoError(t, err)

	toke.Sign(newKey)

	resp, err = toke.Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.NotNil(t, receipt.TokenID)

	record, err := NewTransactionRecordQuery().
		SetTransactionID(resp.TransactionID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	for _, s := range record.AutomaticTokenAssociations {
		assert.Equal(t, accountID.String(), s.AccountID.String())
		assert.Equal(t, receipt.TokenID.String(), s.TokenID.String())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: token_associate_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenAssociateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenAssociate := NewTokenAssociateTransaction().
		SetAccountID(accountID).
		SetTokenIDs(tokenID)

	err = tokenAssociate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenAssociateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenAssociate := NewTokenAssociateTransaction().
		SetAccountID(accountID).
		SetTokenIDs(tokenID)

	err = tokenAssociate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenAssociateTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		key, _ := PrivateKeyFromStringEd25519("302e020100300506032b657004220420d45e1557156908c967804615af59a000be88c7aa7058bfcbe0f46b16c28f887d")
		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		require.Equal(t, bytes.Compare(sigMap.SigPair[1].PubKeyPrefix, key.PublicKey().BytesRaw()), 0)
		require.Equal(t, bytes.Compare(sigMap.SigPair[0].PubKeyPrefix, newKey.PublicKey().BytesRaw()), 0)

		if bod, ok := transactionBody.Data.(*services.TransactionBody_TokenAssociate); ok {
			require.Equal(t, bod.TokenAssociate.Account.GetAccountNum(), int64(123))
			require.Equal(t, bod.TokenAssociate.Tokens[0].TokenNum, int64(123))
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	freez, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAccountID(AccountID{Account: 123}).
		SetTokenIDs(TokenID{Token: 123}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.
		Sign(newKey).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitTokenAssociateTransactionGet(t *testing.T) {
	t.Parallel()

	tokenIDs := []TokenID{{Token: 3}, {Token: 5}, {Token: 7}}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenAssociateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(tokenIDs...).
		SetAccountID(AccountID{Account: 7}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAccountID()
	transaction.GetTokenIDs()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenAssociateTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenAssociateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAccountID()
	transaction.GetTokenIDs()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenAssociateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	tokenID2 := TokenID{Token: 4}
	tokenID3 := TokenID{Token: 3}
	accountID := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenAssociateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(tokenID, tokenID2, tokenID3).
		SetAccountID(accountID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenAssociate()
	require.Equal(t, proto.Tokens[0].String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.Tokens[1].String(), tokenID2._ToProtobuf().String())
	require.Equal(t, proto.Tokens[2].String(), tokenID3._ToProtobuf().String())
	require.Equal(t, proto.Account.String(), accountID._ToProtobuf().String())
}

func TestUnitTokenAssociateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenAssociateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(token).
		AddTokenID(token).
		SetAccountID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenIDs()
	transaction.GetAccountID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenAssociateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}
// Filename: token_association.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// A token - account association
type TokenAssociation struct {
	TokenID   *TokenID
	AccountID *AccountID
}

func tokenAssociationFromProtobuf(pb *services.TokenAssociation) TokenAssociation {
	if pb == nil {
		return TokenAssociation{}
	}

	return TokenAssociation{
		TokenID:   _TokenIDFromProtobuf(pb.TokenId),
		AccountID: _AccountIDFromProtobuf(pb.AccountId),
	}
}

func (association *TokenAssociation) toProtobuf() *services.TokenAssociation {
	var tokenID *services.TokenID
	if association.TokenID != nil {
		tokenID = association.TokenID._ToProtobuf()
	}

	var accountID *services.AccountID
	if association.AccountID != nil {
		accountID = association.AccountID._ToProtobuf()
	}

	return &services.TokenAssociation{
		TokenId:   tokenID,
		AccountId: accountID,
	}
}

// ToBytes returns the byte representation of the TokenAssociation
func (association *TokenAssociation) ToBytes() []byte {
	data, err := protobuf.Marshal(association.toProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TokenAssociationFromBytes returns a TokenAssociation from a raw protobuf byte array
func TokenAssociationFromBytes(data []byte) (TokenAssociation, error) {
	if data == nil {
		return TokenAssociation{}, errByteArrayNull
	}
	pb := services.TokenAssociation{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TokenAssociation{}, err
	}

	association := tokenAssociationFromProtobuf(&pb)

	return association, nil
}
// Filename: token_association_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
)

func TestTokenAssociationFromProtobuf(t *testing.T) {
	t.Parallel()

	var pbAssociation *services.TokenAssociation
	var association TokenAssociation

	association = tokenAssociationFromProtobuf(pbAssociation)
	assert.Equal(t, TokenAssociation{}, association)

	pbAssociation = &services.TokenAssociation{}
	association = tokenAssociationFromProtobuf(pbAssociation)
	assert.Equal(t, TokenAssociation{}, association)

	pbAssociation = &services.TokenAssociation{
		TokenId:   &services.TokenID{ShardNum: 0, RealmNum: 0, TokenNum: 3},
		AccountId: &services.AccountID{ShardNum: 0, RealmNum: 0, Account: &services.AccountID_AccountNum{AccountNum: 6}},
	}

	association = tokenAssociationFromProtobuf(pbAssociation)
	assert.Equal(t, TokenAssociation{
		TokenID:   &TokenID{Shard: 0, Realm: 0, Token: 3},
		AccountID: &AccountID{Shard: 0, Realm: 0, Account: 6},
	}, association)
}

func TestTokenAssociationToProtobuf(t *testing.T) {
	t.Parallel()

	var association TokenAssociation
	var pbAssociation *services.TokenAssociation

	association = TokenAssociation{}
	pbAssociation = association.toProtobuf()
	assert.Equal(t, &services.TokenAssociation{}, pbAssociation)

	association = TokenAssociation{
		TokenID:   &TokenID{Shard: 0, Realm: 0, Token: 3},
		AccountID: &AccountID{Shard: 0, Realm: 0, Account: 6},
	}
	pbAssociation = association.toProtobuf()
	assert.Equal(t, &services.TokenAssociation{
		TokenId:   &services.TokenID{ShardNum: 0, RealmNum: 0, TokenNum: 3},
		AccountId: &services.AccountID{ShardNum: 0, RealmNum: 0, Account: &services.AccountID_AccountNum{AccountNum: 6}},
	}, pbAssociation)

}

func TestTokenAssociationToAndFromBytes(t *testing.T) {
	t.Parallel()

	association := TokenAssociation{
		TokenID:   &TokenID{Shard: 0, Realm: 0, Token: 3},
		AccountID: &AccountID{Shard: 0, Realm: 0, Account: 6},
	}

	bytes := association.ToBytes()
	fromBytes, err := TokenAssociationFromBytes(bytes)
	assert.NoError(t, err)
	assert.Equal(t, association, fromBytes)

	association = TokenAssociation{}
	bytes = association.ToBytes()

	// Test empty bytes
	data, err := TokenAssociationFromBytes(bytes)
	assert.Nil(t, err)
	assert.Equal(t, TokenAssociation{}, data)

	// Test invalid bytes
	_, err = TokenAssociationFromBytes([]byte{0x00})
	assert.Error(t, err)

	// Test nil bytes
	_, err = TokenAssociationFromBytes(nil)
	assert.Error(t, err)
}
// Filename: token_balance_map.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

type TokenBalanceMap struct {
	balances map[string]uint64
}

// Get returns the balance of the given tokenID
func (tokenBalances *TokenBalanceMap) Get(tokenID TokenID) uint64 {
	return tokenBalances.balances[tokenID.String()]
}
func _TokenBalanceMapFromProtobuf(pb []*services.TokenBalance) TokenBalanceMap {
	balances := make(map[string]uint64)

	for _, tokenBalance := range pb {
		balances[_TokenIDFromProtobuf(tokenBalance.TokenId).String()] = tokenBalance.Balance
	}

	return TokenBalanceMap{balances}
}

func (tokenBalances *TokenBalanceMap) _ToProtobuf() []*services.TokenBalance { // nolint
	decimals := make([]*services.TokenBalance, 0)

	for s, t := range tokenBalances.balances {
		token, err := TokenIDFromString(s)
		if err != nil {
			return []*services.TokenBalance{}
		}
		decimals = append(decimals, &services.TokenBalance{
			TokenId: token._ToProtobuf(),
			Balance: t,
		})
	}

	return decimals
}
// Filename: token_balance_map_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
)

func TestUnitTokenBalanceMapGet(t *testing.T) {
	t.Parallel()

	var tokenBalances TokenBalanceMap
	tokenBalances.balances = make(map[string]uint64)
	tokenBalances.balances["0.0.123"] = 100

	assert.Equal(t, uint64(100), tokenBalances.Get(TokenID{Shard: 0, Realm: 0, Token: 123}))
}

func TestUnitTokenBalanceMapProtobuf(t *testing.T) {
	t.Parallel()

	var tokenBalances TokenBalanceMap
	tokenBalances.balances = make(map[string]uint64)
	tokenBalances.balances["0.0.123"] = 100

	pb := tokenBalances._ToProtobuf()
	tokenBalances2 := _TokenBalanceMapFromProtobuf(pb)

	assert.Equal(t, tokenBalances.balances, tokenBalances2.balances)
}

func TestUnitTokenBalanceMapEmpty(t *testing.T) {
	t.Parallel()

	var tokenBalances TokenBalanceMap
	tokenBalances.balances = make(map[string]uint64)

	// Breaks token, err := TokenIDFromString(s)
	tokenBalances.balances["0.123"] = 100

	pb := tokenBalances._ToProtobuf()

	// test that we get an empty array back
	assert.Equal(t, []*services.TokenBalance{}, pb)
}
// Filename: token_burn_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenBurnTransaction Burns tokens from the Token's treasury Account.
// If no Supply Key is defined, the transaction
// will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
// The operation decreases the Total Supply of the Token. Total supply cannot go below
// zero.
// The amount provided must be in the lowest denomination possible. Example:
// Token A has 2 decimals. In order to burn 100 tokens, one must provide amount of 10000. In order
// to burn 100.55 tokens, one must provide amount of 10055.
type TokenBurnTransaction struct {
	Transaction
	tokenID *TokenID
	amount  uint64
	serial  []int64
}

// NewTokenBurnTransaction creates TokenBurnTransaction which burns tokens from the Token's treasury Account.
// If no Supply Key is defined, the transaction
// will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
// The operation decreases the Total Supply of the Token. Total supply cannot go below
// zero.
// The amount provided must be in the lowest denomination possible. Example:
// Token A has 2 decimals. In order to burn 100 tokens, one must provide amount of 10000. In order
// to burn 100.55 tokens, one must provide amount of 10055.
func NewTokenBurnTransaction() *TokenBurnTransaction {
	tx := TokenBurnTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _TokenBurnTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenBurnTransaction {
	return &TokenBurnTransaction{
		Transaction: tx,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenBurn().Token),
		amount:      pb.GetTokenBurn().GetAmount(),
		serial:      pb.GetTokenBurn().GetSerialNumbers(),
	}
}

// SetTokenID Sets the token for which to burn tokens. If token does not exist, transaction results in
// INVALID_TOKEN_ID
func (tx *TokenBurnTransaction) SetTokenID(tokenID TokenID) *TokenBurnTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the TokenID for the token which will be burned.
func (tx *TokenBurnTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// SetAmount Sets the amount to burn from the Treasury Account. Amount must be a positive non-zero number, not
// bigger than the token balance of the treasury account (0; balance], represented in the lowest
// denomination.
func (tx *TokenBurnTransaction) SetAmount(amount uint64) *TokenBurnTransaction {
	tx._RequireNotFrozen()
	tx.amount = amount
	return tx
}

// Deprecated: Use TokenBurnTransaction.GetAmount() instead.
func (tx *TokenBurnTransaction) GetAmmount() uint64 {
	return tx.amount
}

func (tx *TokenBurnTransaction) GetAmount() uint64 {
	return tx.amount
}

// SetSerialNumber
// Applicable to tokens of type NON_FUNGIBLE_UNIQUE.
// The list of serial numbers to be burned.
func (tx *TokenBurnTransaction) SetSerialNumber(serial int64) *TokenBurnTransaction {
	tx._RequireNotFrozen()
	if tx.serial == nil {
		tx.serial = make([]int64, 0)
	}
	tx.serial = append(tx.serial, serial)
	return tx
}

// SetSerialNumbers sets the list of serial numbers to be burned.
func (tx *TokenBurnTransaction) SetSerialNumbers(serial []int64) *TokenBurnTransaction {
	tx._RequireNotFrozen()
	tx.serial = serial
	return tx
}

// GetSerialNumbers returns the list of serial numbers to be burned.
func (tx *TokenBurnTransaction) GetSerialNumbers() []int64 {
	return tx.serial
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenBurnTransaction) Sign(privateKey PrivateKey) *TokenBurnTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenBurnTransaction) SignWithOperator(client *Client) (*TokenBurnTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenBurnTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenBurnTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenBurnTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenBurnTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenBurnTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenBurnTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenBurnTransaction) Freeze() (*TokenBurnTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenBurnTransaction) FreezeWith(client *Client) (*TokenBurnTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenBurnTransaction.
func (tx *TokenBurnTransaction) SetMaxTransactionFee(fee Hbar) *TokenBurnTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenBurnTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenBurnTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenBurnTransaction.
func (tx *TokenBurnTransaction) SetTransactionMemo(memo string) *TokenBurnTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenBurnTransaction.
func (tx *TokenBurnTransaction) SetTransactionValidDuration(duration time.Duration) *TokenBurnTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenBurnTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenBurnTransaction.
func (tx *TokenBurnTransaction) SetTransactionID(transactionID TransactionID) *TokenBurnTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenBurnTransaction.
func (tx *TokenBurnTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenBurnTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenBurnTransaction) SetMaxRetry(count int) *TokenBurnTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenBurnTransaction) SetMaxBackoff(max time.Duration) *TokenBurnTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenBurnTransaction) SetMinBackoff(min time.Duration) *TokenBurnTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenBurnTransaction) SetLogLevel(level LogLevel) *TokenBurnTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenBurnTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenBurnTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenBurnTransaction) getName() string {
	return "TokenBurnTransaction"
}

func (tx *TokenBurnTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenBurnTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenBurn{
			TokenBurn: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenBurnTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenBurn{
			TokenBurn: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenBurnTransaction) buildProtoBody() *services.TokenBurnTransactionBody {
	body := &services.TokenBurnTransactionBody{
		Amount: tx.amount,
	}

	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	if tx.serial != nil {
		body.SerialNumbers = tx.serial
	}

	return body
}

func (tx *TokenBurnTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().BurnToken,
	}
}
func (tx *TokenBurnTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_burn_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenBurnTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	resp, err = NewTokenBurnTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAmount(10).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, uint64(999990), info.TotalSupply)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenBurnTransactionNoAmount(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	resp2, err := NewTokenBurnTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		Execute(env.Client)
	receipt, err = resp2.SetValidateStatus(true).GetReceipt(env.Client)
	// It is now possible to perform Zero Token Operations https://hips.hedera.com/hip/hip-564
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenBurnTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	resp2, err := NewTokenBurnTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAmount(10).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_TOKEN_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, receipt.TokenID)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenBurnTransactionTreasuryMustOwnBurnedNft(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	metaData := []byte{50, 50}

	mint, err := NewTokenMintTransaction().
		SetTokenID(tokenID).
		SetMetadata(metaData).
		Execute(env.Client)
	require.NoError(t, err)

	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(2)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	freezeAssociate, err := NewTokenAssociateTransaction().
		SetAccountID(*receipt.AccountID).
		SetTokenIDs(tokenID).
		SetNodeAccountIDs(env.NodeAccountIDs).
		FreezeWith(env.Client)
	require.NoError(t, err)

	freezeAssociate.Sign(newKey)

	resp, err = freezeAssociate.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenBurnTransaction().
		SetSerialNumbers(mintReceipt.SerialNumbers).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenBurnTransactionInvalidMetadata(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	resp, err := NewTokenBurnTransaction().
		SetAmount(1).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_TOKEN_BURN_METADATA", err.Error())
	}
}
// Filename: token_burn_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenBurnTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenBurn := NewTokenBurnTransaction().
		SetTokenID(tokenID)

	err = tokenBurn.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenBurnTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenBurn := NewTokenBurnTransaction().
		SetTokenID(tokenID)

	err = tokenBurn.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenBurnTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenBurnTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAmount(5).
		SetSerialNumber(5).
		SetSerialNumbers([]int64{1, 5, 6, 7}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAmount()
	transaction.GetSerialNumbers()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenBurnTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenBurnTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAmount()
	transaction.GetSerialNumbers()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenBurnTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenBurnTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAmount(5).
		SetSerialNumbers([]int64{1, 5, 6, 7}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenBurn()
	require.Equal(t, proto.Token.String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.Amount, uint64(5))
	require.Equal(t, proto.SerialNumbers, []int64{1, 5, 6, 7})
}

func TestUnitTokenBurnTransactionCoverage(t *testing.T) {
	t.Parallel()

	grpc := time.Second * 30
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenBurnTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAmount(5).
		SetSerialNumbers([]int64{23, 343}).
		SetSerialNumber(65).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetSerialNumbers()
	transaction.GetAmount()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenBurnTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenBurnTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	freez, err := NewTokenBurnTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAmount(5).
		SetSerialNumbers([]int64{23, 343}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: token_cancel_airdrop_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

type TokenCancelAirdropTransaction struct {
	Transaction
	pendingAirdropIds []*PendingAirdropId
}

func NewTokenCancelAirdropTransaction() *TokenCancelAirdropTransaction {
	tx := TokenCancelAirdropTransaction{
		Transaction:       _NewTransaction(),
		pendingAirdropIds: make([]*PendingAirdropId, 0),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(1))

	return &tx
}

func _TokenCancelAirdropTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenCancelAirdropTransaction {
	TokenCancel := &TokenCancelAirdropTransaction{
		Transaction: tx,
	}

	for _, pendingAirdrops := range pb.GetTokenCancelAirdrop().PendingAirdrops {
		TokenCancel.pendingAirdropIds = append(TokenCancel.pendingAirdropIds, _PendingAirdropIdFromProtobuf(pendingAirdrops))
	}

	return TokenCancel
}

// SetPendingAirdropIds sets the pending airdrop IDs for this TokenCancelAirdropTransaction.
func (tx *TokenCancelAirdropTransaction) SetPendingAirdropIds(ids []*PendingAirdropId) *TokenCancelAirdropTransaction {
	tx._RequireNotFrozen()
	tx.pendingAirdropIds = ids
	return tx
}

// AddPendingAirdropId adds a pending airdrop ID to this TokenCancelAirdropTransaction.
func (tx *TokenCancelAirdropTransaction) AddPendingAirdropId(id PendingAirdropId) *TokenCancelAirdropTransaction {
	tx._RequireNotFrozen()
	tx.pendingAirdropIds = append(tx.pendingAirdropIds, &id)
	return tx
}

// GetPendingAirdropIds returns the pending airdrop IDs for this TokenCancelAirdropTransaction.
func (tx *TokenCancelAirdropTransaction) GetPendingAirdropIds() []*PendingAirdropId {
	return tx.pendingAirdropIds
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenCancelAirdropTransaction) Sign(privateKey PrivateKey) *TokenCancelAirdropTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenCancelAirdropTransaction) SignWithOperator(client *Client) (*TokenCancelAirdropTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenCancelAirdropTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenCancelAirdropTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenCancelAirdropTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenCancelAirdropTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenCancelAirdropTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenCancelAirdropTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenCancelAirdropTransaction) Freeze() (*TokenCancelAirdropTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenCancelAirdropTransaction) FreezeWith(client *Client) (*TokenCancelAirdropTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenCancelAirdropTransaction.
func (tx *TokenCancelAirdropTransaction) SetMaxTransactionFee(fee Hbar) *TokenCancelAirdropTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenCancelAirdropTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenCancelAirdropTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenCancelAirdropTransaction.
func (tx *TokenCancelAirdropTransaction) SetTransactionMemo(memo string) *TokenCancelAirdropTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenCancelAirdropTransaction.
func (tx *TokenCancelAirdropTransaction) SetTransactionValidDuration(duration time.Duration) *TokenCancelAirdropTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenCancelAirdropTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenCancelAirdropTransaction.
func (tx *TokenCancelAirdropTransaction) SetTransactionID(transactionID TransactionID) *TokenCancelAirdropTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenCancelAirdropTransaction.
func (tx *TokenCancelAirdropTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenCancelAirdropTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenCancelAirdropTransaction) SetMaxRetry(count int) *TokenCancelAirdropTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenCancelAirdropTransaction) SetMaxBackoff(max time.Duration) *TokenCancelAirdropTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenCancelAirdropTransaction) SetMinBackoff(min time.Duration) *TokenCancelAirdropTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenCancelAirdropTransaction) SetLogLevel(level LogLevel) *TokenCancelAirdropTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenCancelAirdropTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenCancelAirdropTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenCancelAirdropTransaction) getName() string {
	return "TokenCancelAirdropTransaction"
}

func (tx *TokenCancelAirdropTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	for _, pendingAirdropId := range tx.pendingAirdropIds {
		if pendingAirdropId.sender != nil {
			if err := pendingAirdropId.sender.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if pendingAirdropId.receiver != nil {
			if err := pendingAirdropId.receiver.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if pendingAirdropId.nftID != nil {
			if err := pendingAirdropId.nftID.Validate(client); err != nil {
				return err
			}
		}

		if pendingAirdropId.tokenID != nil {
			if err := pendingAirdropId.tokenID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}
	return nil
}

func (tx *TokenCancelAirdropTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenCancelAirdrop{
			TokenCancelAirdrop: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenCancelAirdropTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Data: &services.SchedulableTransactionBody_TokenCancelAirdrop{
			TokenCancelAirdrop: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenCancelAirdropTransaction) buildProtoBody() *services.TokenCancelAirdropTransactionBody {
	pendingAirdrops := make([]*services.PendingAirdropId, len(tx.pendingAirdropIds))
	for i, pendingAirdropId := range tx.pendingAirdropIds {
		pendingAirdrops[i] = pendingAirdropId._ToProtobuf()
	}

	return &services.TokenCancelAirdropTransactionBody{
		PendingAirdrops: pendingAirdrops,
	}
}

func (tx *TokenCancelAirdropTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().CancelAirdrop,
	}
}

func (tx *TokenCancelAirdropTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_cancel_airdrop_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

const tokenCancelAirdropTransferAmount = 100

func TestIntegrationTokenCancelAirdropCanExecute(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create nft
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver).
		AddTokenTransfer(tokenID, receiver, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Cancel the tokens with the operator
	cancelTx, err := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[1].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[2].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	cancelResp, err := cancelTx.Sign(env.OperatorKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = cancelResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Verify the operator does hold the tokens
	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(1_000_000), operatorBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(10), operatorBalance.Tokens.Get(nftID))
}

func TestIntegrationTokenCancelAirdropMultipleReceivers(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create nft
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	// Create receiver1
	receiver1, receiver1Key, err := createAccount(&env)
	require.NoError(t, err)

	// Create receiver2
	receiver2, receiver2Key, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens to both
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver1).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver1).
		AddTokenTransfer(tokenID, receiver1, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		AddNftTransfer(nftID.Nft(nftSerials[2]), env.OperatorID, receiver2).
		AddNftTransfer(nftID.Nft(nftSerials[3]), env.OperatorID, receiver2).
		AddTokenTransfer(tokenID, receiver2, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Verify the txn record
	assert.Equal(t, 6, len(record.PendingAirdropRecords))

	// Cancel the tokens signing with receiver1 and receiver2
	cancelTx, err := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[1].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[2].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[3].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[4].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[5].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	cancelResp, err := cancelTx.Sign(receiver1Key).Sign(receiver2Key).Execute(env.Client)
	require.NoError(t, err)

	_, err = cancelResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Verify the operator does hold the tokens
	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(1_000_000), operatorBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(10), operatorBalance.Tokens.Get(nftID))

}

func TestIntegrationTokenCancelAirdropMultipleAirdropTxns(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create nft
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop some of the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver).
		Execute(env.Client)
	require.NoError(t, err)

	record1, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Airdrop some of the tokens
	airdropTx, err = NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver).
		Execute(env.Client)
	require.NoError(t, err)

	record2, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Airdrop some of the tokens
	airdropTx, err = NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record3, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Collect pending airdrop IDs into a slice
	pendingAirdrop1 := record1.PendingAirdropRecords[0].GetPendingAirdropId()
	pendingAirdrop2 := record2.PendingAirdropRecords[0].GetPendingAirdropId()
	pendingAirdrop3 := record3.PendingAirdropRecords[0].GetPendingAirdropId()
	pendingAirdropIDs := make([]*PendingAirdropId, 0)
	pendingAirdropIDs = append(pendingAirdropIDs, &pendingAirdrop1)
	pendingAirdropIDs = append(pendingAirdropIDs, &pendingAirdrop2)
	pendingAirdropIDs = append(pendingAirdropIDs, &pendingAirdrop3)

	// Cancel the all the tokens with the receiver
	cancelTx, err := NewTokenCancelAirdropTransaction().
		SetPendingAirdropIds(pendingAirdropIDs).
		FreezeWith(env.Client)
	require.NoError(t, err)

	cancelResp, err := cancelTx.Sign(env.OperatorKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = cancelResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Verify the receiver does not hold the tokens via query
	reciverBalance, err := NewAccountBalanceQuery().
		SetAccountID(receiver).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(0), reciverBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(0), reciverBalance.Tokens.Get(nftID))

	// Verify the operator does hold the tokens
	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(1_000_000), operatorBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(10), operatorBalance.Tokens.Get(nftID))
}

func TestIntegrationTokenCancelAirdropCannotCancelNonExistingAirdrop(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)
	// Create random account
	randomAccount, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Cancel the tokens with the random account which has not created pending airdrops
	_, err = NewTokenCancelAirdropTransaction().
		SetTransactionID(TransactionIDGenerate(randomAccount)).
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		Execute(env.Client)
	require.ErrorContains(t, err, "INVALID_SIGNATURE")
}

func TestIntegrationTokenCancelAirdropCannotCancelAlreadyCanceledAirdrop(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Cancel the tokens with the operator
	cancelTx, err := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	cancelResp, err := cancelTx.Sign(env.OperatorKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = cancelResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Cancel the tokens with the operator again
	cancelTx, err = NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	cancelResp, err = cancelTx.Sign(env.OperatorKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = cancelResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_PENDING_AIRDROP_ID")
}

func TestIntegrationTokenCancelAirdropCannotCancelWithEmptyPendingAirdrops(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Cancel the tokens with the operator without setting pendingAirdropIds
	_, err := NewTokenCancelAirdropTransaction().
		Execute(env.Client)
	require.ErrorContains(t, err, "EMPTY_PENDING_AIRDROP_ID_LIST")
}

func TestIntegrationTokenCancelAirdropCannotCancelWithDupblicateEntries(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Cancel the tokens with duplicate pending airdrop token ids
	cancelTx, err := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	_, err = cancelTx.Sign(env.OperatorKey).Execute(env.Client)
	require.ErrorContains(t, err, "PENDING_AIRDROP_ID_REPEATED")
}

func TestIntegrationTokenCancelAirdropCanCancelWithPausedToken(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Pause the token
	pauseResp, err := NewTokenPauseTransaction().SetTokenID(tokenID).Execute(env.Client)
	require.NoError(t, err)
	_, err = pauseResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Cancel the tokens with receiver
	cancelTx, err := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	cancelResp, err := cancelTx.Sign(env.OperatorKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = cancelResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func TestIntegrationTokenCancelAirdropCanCancelWithDeletedToken(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Delete the token
	deleteResp, err := NewTokenDeleteTransaction().SetTokenID(tokenID).Execute(env.Client)
	require.NoError(t, err)
	_, err = deleteResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Cancel the tokens with receiver
	cancelTx, err := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	cancelResp, err := cancelTx.Sign(env.OperatorKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = cancelResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func TestIntegrationTokenCancelAirdropCanCancelWithFrozenToken(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, receiverKey, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenCancelAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenCancelAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Associate the token
	associateTx, err := NewTokenAssociateTransaction().AddTokenID(tokenID).SetAccountID(receiver).FreezeWith(env.Client)
	require.NoError(t, err)
	associateResp, err := associateTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = associateResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Freeze the token
	freezeTx, err := NewTokenFreezeTransaction().SetTokenID(tokenID).SetAccountID(receiver).FreezeWith(env.Client)
	require.NoError(t, err)
	freezeResp, err := freezeTx.Sign(receiverKey).Execute(env.Client)
	_, err = freezeResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Cancel the tokens with receiver
	cancelTx, err := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	cancelResp, err := cancelTx.Sign(env.OperatorKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = cancelResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}
// Filename: token_cancel_airdrop_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnitTokenCancelAirdropTransactionSetPendingAirdropIds(t *testing.T) {
	t.Parallel()

	pendingAirdropId1 := &PendingAirdropId{tokenID: &TokenID{Token: 1}}
	pendingAirdropId2 := &PendingAirdropId{tokenID: &TokenID{Token: 2}}

	transaction := NewTokenCancelAirdropTransaction().
		SetPendingAirdropIds([]*PendingAirdropId{pendingAirdropId1, pendingAirdropId2})

	assert.Equal(t, []*PendingAirdropId{pendingAirdropId1, pendingAirdropId2}, transaction.GetPendingAirdropIds())
}

func TestUnitTokenCancelAirdropTransactionAddPendingAirdropId(t *testing.T) {
	t.Parallel()

	pendingAirdropId1 := PendingAirdropId{tokenID: &TokenID{Token: 1}}
	pendingAirdropId2 := PendingAirdropId{tokenID: &TokenID{Token: 2}}

	transaction := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(pendingAirdropId1).
		AddPendingAirdropId(pendingAirdropId2)

	assert.Equal(t, []*PendingAirdropId{&pendingAirdropId1, &pendingAirdropId2}, transaction.GetPendingAirdropIds())
}

func TestUnitTokenCancelAirdropTransactionFreeze(t *testing.T) {
	t.Parallel()

	pendingAirdropId := PendingAirdropId{tokenID: &TokenID{Token: 1}, sender: &AccountID{Account: 3}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})
	transaction := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(pendingAirdropId).
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID)

	_, err := transaction.Freeze()
	require.NoError(t, err)
}

func TestUnitTokenCancelAirdropTransactionToBytes(t *testing.T) {
	t.Parallel()

	pendingAirdropId := PendingAirdropId{tokenID: &TokenID{Token: 1}}

	transaction := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(pendingAirdropId)

	bytes, err := transaction.ToBytes()
	require.NoError(t, err)
	require.NotNil(t, bytes)
}

func TestUnitTokenCancelAirdropTransactionFromBytes(t *testing.T) {
	t.Parallel()

	pendingAirdropId := PendingAirdropId{tokenID: &TokenID{Token: 1}, sender: &AccountID{Account: 3}, receiver: &AccountID{Account: 4}}

	transaction := NewTokenCancelAirdropTransaction().
		AddPendingAirdropId(pendingAirdropId)

	bytes, err := transaction.ToBytes()
	require.NoError(t, err)
	require.NotNil(t, bytes)

	deserializedTransaction, err := TransactionFromBytes(bytes)
	require.NoError(t, err)

	switch tx := deserializedTransaction.(type) {
	case TokenCancelAirdropTransaction:
		assert.Equal(t, transaction.GetPendingAirdropIds(), tx.GetPendingAirdropIds())
	default:
		t.Fatalf("expected TokenCancelAirdropTransaction, got %T", deserializedTransaction)
	}
}

func TestUnitTokenCancelAirdropTransactionScheduleProtobuf(t *testing.T) {
	t.Parallel()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	pendingAirdropId1 := PendingAirdropId{tokenID: &TokenID{Token: 1}}
	pendingAirdropId2 := PendingAirdropId{tokenID: &TokenID{Token: 2}}

	tx, err := NewTokenCancelAirdropTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddPendingAirdropId(pendingAirdropId1).
		AddPendingAirdropId(pendingAirdropId2).
		Freeze()
	require.NoError(t, err)

	expected := &services.SchedulableTransactionBody{
		TransactionFee: 100000000,
		Data: &services.SchedulableTransactionBody_TokenCancelAirdrop{
			TokenCancelAirdrop: &services.TokenCancelAirdropTransactionBody{
				PendingAirdrops: []*services.PendingAirdropId{
					pendingAirdropId1._ToProtobuf(),
					pendingAirdropId2._ToProtobuf(),
				},
			},
		},
	}

	actual, err := tx.buildScheduled()
	require.NoError(t, err)
	require.Equal(t, expected.String(), actual.String())
}

func TestUnitTokenCancelAirdropTransactionValidateNetworkOnIDs(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	checksum := "dmqui"
	pendingAirdropId := &PendingAirdropId{
		tokenID:  &TokenID{Token: 3, checksum: &checksum},
		sender:   &AccountID{Account: 3, checksum: &checksum},
		receiver: &AccountID{Account: 3, checksum: &checksum},
	}

	transaction := NewTokenCancelAirdropTransaction().
		SetPendingAirdropIds([]*PendingAirdropId{pendingAirdropId})

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
}
// Filename: token_claim_airdrop_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

type TokenClaimAirdropTransaction struct {
	Transaction
	pendingAirdropIds []*PendingAirdropId
}

func NewTokenClaimAirdropTransaction() *TokenClaimAirdropTransaction {
	tx := TokenClaimAirdropTransaction{
		Transaction:       _NewTransaction(),
		pendingAirdropIds: make([]*PendingAirdropId, 0),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(1))

	return &tx
}

func _TokenClaimAirdropTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenClaimAirdropTransaction {
	tokenClaim := &TokenClaimAirdropTransaction{
		Transaction: tx,
	}

	for _, pendingAirdrops := range pb.GetTokenClaimAirdrop().PendingAirdrops {
		tokenClaim.pendingAirdropIds = append(tokenClaim.pendingAirdropIds, _PendingAirdropIdFromProtobuf(pendingAirdrops))
	}

	return tokenClaim
}

// SetPendingAirdropIds sets the pending airdrop IDs for this TokenClaimAirdropTransaction.
func (tx *TokenClaimAirdropTransaction) SetPendingAirdropIds(ids []*PendingAirdropId) *TokenClaimAirdropTransaction {
	tx._RequireNotFrozen()
	tx.pendingAirdropIds = ids
	return tx
}

// AddPendingAirdropId adds a pending airdrop ID to this TokenClaimAirdropTransaction.
func (tx *TokenClaimAirdropTransaction) AddPendingAirdropId(id PendingAirdropId) *TokenClaimAirdropTransaction {
	tx._RequireNotFrozen()
	tx.pendingAirdropIds = append(tx.pendingAirdropIds, &id)
	return tx
}

// GetPendingAirdropIds returns the pending airdrop IDs for this TokenClaimAirdropTransaction.
func (tx *TokenClaimAirdropTransaction) GetPendingAirdropIds() []*PendingAirdropId {
	return tx.pendingAirdropIds
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenClaimAirdropTransaction) Sign(privateKey PrivateKey) *TokenClaimAirdropTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenClaimAirdropTransaction) SignWithOperator(client *Client) (*TokenClaimAirdropTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenClaimAirdropTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenClaimAirdropTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenClaimAirdropTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenClaimAirdropTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenClaimAirdropTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenClaimAirdropTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenClaimAirdropTransaction) Freeze() (*TokenClaimAirdropTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenClaimAirdropTransaction) FreezeWith(client *Client) (*TokenClaimAirdropTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenClaimAirdropTransaction.
func (tx *TokenClaimAirdropTransaction) SetMaxTransactionFee(fee Hbar) *TokenClaimAirdropTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenClaimAirdropTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenClaimAirdropTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenClaimAirdropTransaction.
func (tx *TokenClaimAirdropTransaction) SetTransactionMemo(memo string) *TokenClaimAirdropTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenClaimAirdropTransaction.
func (tx *TokenClaimAirdropTransaction) SetTransactionValidDuration(duration time.Duration) *TokenClaimAirdropTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenClaimAirdropTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenClaimAirdropTransaction.
func (tx *TokenClaimAirdropTransaction) SetTransactionID(transactionID TransactionID) *TokenClaimAirdropTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenClaimAirdropTransaction.
func (tx *TokenClaimAirdropTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenClaimAirdropTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenClaimAirdropTransaction) SetMaxRetry(count int) *TokenClaimAirdropTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenClaimAirdropTransaction) SetMaxBackoff(max time.Duration) *TokenClaimAirdropTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenClaimAirdropTransaction) SetMinBackoff(min time.Duration) *TokenClaimAirdropTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenClaimAirdropTransaction) SetLogLevel(level LogLevel) *TokenClaimAirdropTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenClaimAirdropTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenClaimAirdropTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenClaimAirdropTransaction) getName() string {
	return "TokenClaimAirdropTransaction"
}

func (tx *TokenClaimAirdropTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	for _, pendingAirdropId := range tx.pendingAirdropIds {
		if pendingAirdropId.sender != nil {
			if err := pendingAirdropId.sender.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if pendingAirdropId.receiver != nil {
			if err := pendingAirdropId.receiver.ValidateChecksum(client); err != nil {
				return err
			}
		}

		if pendingAirdropId.nftID != nil {
			if err := pendingAirdropId.nftID.Validate(client); err != nil {
				return err
			}
		}

		if pendingAirdropId.tokenID != nil {
			if err := pendingAirdropId.tokenID.ValidateChecksum(client); err != nil {
				return err
			}
		}
	}
	return nil
}

func (tx *TokenClaimAirdropTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenClaimAirdrop{
			TokenClaimAirdrop: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenClaimAirdropTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Data: &services.SchedulableTransactionBody_TokenClaimAirdrop{
			TokenClaimAirdrop: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenClaimAirdropTransaction) buildProtoBody() *services.TokenClaimAirdropTransactionBody {
	pendingAirdrops := make([]*services.PendingAirdropId, len(tx.pendingAirdropIds))
	for i, pendingAirdropId := range tx.pendingAirdropIds {
		pendingAirdrops[i] = pendingAirdropId._ToProtobuf()
	}

	return &services.TokenClaimAirdropTransactionBody{
		PendingAirdrops: pendingAirdrops,
	}
}

func (tx *TokenClaimAirdropTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().ClaimAirdrop,
	}
}

func (tx *TokenClaimAirdropTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_claim_airdrop_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

const tokenClaimAirdropTransferAmount = 100

func TestIntegrationTokenClaimAirdropCanExecute(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create nft
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	// Create receiver with 0 auto associations
	receiver, receiverKey, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver).
		AddTokenTransfer(tokenID, receiver, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Claim the tokens with the receiver
	claimTx, err := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[1].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[2].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	claimResp, err := claimTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = claimResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Verify the receiver holds the tokens via query
	reciverBalance, err := NewAccountBalanceQuery().
		SetAccountID(receiver).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(tokenClaimAirdropTransferAmount), reciverBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(2), reciverBalance.Tokens.Get(nftID))

	// Verify the operator does not hold the tokens
	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(1_000_000-tokenClaimAirdropTransferAmount), operatorBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(8), operatorBalance.Tokens.Get(nftID))
}

func TestIntegrationTokenClaimAirdropMultipleReceivers(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create nft
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	// Create receiver1
	receiver1, receiver1Key, err := createAccount(&env)
	require.NoError(t, err)

	// Create receiver2
	receiver2, receiver2Key, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens to both
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver1).
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver1).
		AddTokenTransfer(tokenID, receiver1, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		AddNftTransfer(nftID.Nft(nftSerials[2]), env.OperatorID, receiver2).
		AddNftTransfer(nftID.Nft(nftSerials[3]), env.OperatorID, receiver2).
		AddTokenTransfer(tokenID, receiver2, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Verify the txn record
	assert.Equal(t, 6, len(record.PendingAirdropRecords))

	// Claim the tokens signing with receiver1 and receiver2
	claimTx, err := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[1].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[2].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[3].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[4].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[5].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	claimResp, err := claimTx.Sign(receiver1Key).Sign(receiver2Key).Execute(env.Client)
	require.NoError(t, err)

	_, err = claimResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Verify the receiver1 holds the tokens via query
	reciverBalance, err := NewAccountBalanceQuery().
		SetAccountID(receiver1).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(tokenClaimAirdropTransferAmount), reciverBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(2), reciverBalance.Tokens.Get(nftID))

	// Verify the receiver2 holds the tokens via query
	reciverBalance, err = NewAccountBalanceQuery().
		SetAccountID(receiver2).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(tokenClaimAirdropTransferAmount), reciverBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(2), reciverBalance.Tokens.Get(nftID))

	// Verify the operator does not hold the tokens
	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(1_000_000-tokenClaimAirdropTransferAmount*2), operatorBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(6), operatorBalance.Tokens.Get(nftID))

}

func TestIntegrationTokenClaimAirdropMultipleAirdropTxns(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create nft
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// Mint some NFTs
	txResponse, err := NewTokenMintTransaction().
		SetTokenID(nftID).
		SetMetadatas(mintMetadata).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txResponse.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	// Create receiver
	receiver, receiverKey, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop some of the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[0]), env.OperatorID, receiver).
		Execute(env.Client)
	require.NoError(t, err)

	record1, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Airdrop some of the tokens
	airdropTx, err = NewTokenAirdropTransaction().
		AddNftTransfer(nftID.Nft(nftSerials[1]), env.OperatorID, receiver).
		Execute(env.Client)
	require.NoError(t, err)

	record2, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Airdrop some of the tokens
	airdropTx, err = NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record3, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Collect pending airdrop IDs into a slice
	pendingAirdrop1 := record1.PendingAirdropRecords[0].GetPendingAirdropId()
	pendingAirdrop2 := record2.PendingAirdropRecords[0].GetPendingAirdropId()
	pendingAirdrop3 := record3.PendingAirdropRecords[0].GetPendingAirdropId()
	pendingAirdropIDs := make([]*PendingAirdropId, 0)
	pendingAirdropIDs = append(pendingAirdropIDs, &pendingAirdrop1)
	pendingAirdropIDs = append(pendingAirdropIDs, &pendingAirdrop2)
	pendingAirdropIDs = append(pendingAirdropIDs, &pendingAirdrop3)

	// Claim the all the tokens with the receiver
	claimTx, err := NewTokenClaimAirdropTransaction().
		SetPendingAirdropIds(pendingAirdropIDs).
		FreezeWith(env.Client)
	require.NoError(t, err)

	claimResp, err := claimTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = claimResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Verify the receiver holds the tokens via query
	reciverBalance, err := NewAccountBalanceQuery().
		SetAccountID(receiver).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(tokenClaimAirdropTransferAmount), reciverBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(2), reciverBalance.Tokens.Get(nftID))

	// Verify the operator does not hold the tokens
	operatorBalance, err := NewAccountBalanceQuery().
		SetAccountID(env.OperatorID).
		Execute(env.Client)
	require.NoError(t, err)

	require.Equal(t, uint64(1_000_000-tokenClaimAirdropTransferAmount), operatorBalance.Tokens.Get(tokenID))
	require.Equal(t, uint64(8), operatorBalance.Tokens.Get(nftID))
}

func TestIntegrationTokenClaimAirdropCannotClaimNonExistingAirdrop(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, _, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Claim the tokens with the operator which does not have pending airdrops
	claimResp, err := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = claimResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_SIGNATURE")
}

func TestIntegrationTokenClaimAirdropCannotClaimAlreadyClaimedAirdrop(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, receiverKey, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Claim the tokens with the receiver
	claimTx, err := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	claimResp, err := claimTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = claimResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Claim the tokens with the receiver again
	claimTx, err = NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	claimResp, err = claimTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = claimResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_PENDING_AIRDROP_ID")
}

func TestIntegrationTokenClaimAirdropCannotClaimWithEmptyPendingAirdrops(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Claim the tokens with the receiver without setting pendingAirdropIds
	_, err := NewTokenClaimAirdropTransaction().
		Execute(env.Client)
	require.ErrorContains(t, err, "EMPTY_PENDING_AIRDROP_ID_LIST")
}

func TestIntegrationTokenClaimAirdropCannotClaimWithDupblicateEntries(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, receiverKey, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Claim the tokens with duplicate pending airdrop token ids
	claimTx, err := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	_, err = claimTx.Sign(receiverKey).Execute(env.Client)
	require.ErrorContains(t, err, "PENDING_AIRDROP_ID_REPEATED")
}

func TestIntegrationTokenClaimAirdropCannotClaimWithPausedToken(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, receiverKey, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Pause the token
	pauseResp, err := NewTokenPauseTransaction().SetTokenID(tokenID).Execute(env.Client)
	require.NoError(t, err)
	_, err = pauseResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Claim the tokens with receiver
	claimTx, err := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	claimResp, err := claimTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = claimResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_IS_PAUSED")
}

func TestIntegrationTokenClaimAirdropCannotClaimWithDeletedToken(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, receiverKey, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Delete the token
	deleteResp, err := NewTokenDeleteTransaction().SetTokenID(tokenID).Execute(env.Client)
	require.NoError(t, err)
	_, err = deleteResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Claim the tokens with receiver
	claimTx, err := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	claimResp, err := claimTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = claimResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_WAS_DELETED")
}

func TestIntegrationTokenClaimAirdropCannotClaimWithFrozenToken(t *testing.T) {
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	// Create fungible token
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// Create receiver
	receiver, receiverKey, err := createAccount(&env)
	require.NoError(t, err)

	// Airdrop the tokens
	airdropTx, err := NewTokenAirdropTransaction().
		AddTokenTransfer(tokenID, receiver, tokenClaimAirdropTransferAmount).
		AddTokenTransfer(tokenID, env.OperatorID, -tokenClaimAirdropTransferAmount).
		Execute(env.Client)
	require.NoError(t, err)

	record, err := airdropTx.SetValidateStatus(true).GetRecord(env.Client)
	require.NoError(t, err)

	// Associate the token
	associateTx, err := NewTokenAssociateTransaction().AddTokenID(tokenID).SetAccountID(receiver).FreezeWith(env.Client)
	require.NoError(t, err)
	associateResp, err := associateTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = associateResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Freeze the token
	freezeResp, err := NewTokenFreezeTransaction().SetTokenID(tokenID).SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	_, err = freezeResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Claim the tokens with receiver
	claimTx, err := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(record.PendingAirdropRecords[0].GetPendingAirdropId()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	claimResp, err := claimTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)

	_, err = claimResp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "ACCOUNT_FROZEN_FOR_TOKEN")
}
// Filename: token_claim_airdrop_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnitTokenClaimAirdropTransactionSetPendingAirdropIds(t *testing.T) {
	t.Parallel()

	pendingAirdropId1 := &PendingAirdropId{tokenID: &TokenID{Token: 1}}
	pendingAirdropId2 := &PendingAirdropId{tokenID: &TokenID{Token: 2}}

	transaction := NewTokenClaimAirdropTransaction().
		SetPendingAirdropIds([]*PendingAirdropId{pendingAirdropId1, pendingAirdropId2})

	assert.Equal(t, []*PendingAirdropId{pendingAirdropId1, pendingAirdropId2}, transaction.GetPendingAirdropIds())
}

func TestUnitTokenClaimAirdropTransactionAddPendingAirdropId(t *testing.T) {
	t.Parallel()

	pendingAirdropId1 := PendingAirdropId{tokenID: &TokenID{Token: 1}}
	pendingAirdropId2 := PendingAirdropId{tokenID: &TokenID{Token: 2}}

	transaction := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(pendingAirdropId1).
		AddPendingAirdropId(pendingAirdropId2)

	assert.Equal(t, []*PendingAirdropId{&pendingAirdropId1, &pendingAirdropId2}, transaction.GetPendingAirdropIds())
}

func TestUnitTokenClaimAirdropTransactionFreeze(t *testing.T) {
	t.Parallel()

	pendingAirdropId := PendingAirdropId{tokenID: &TokenID{Token: 1}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})
	transaction := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(pendingAirdropId).
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID)

	_, err := transaction.Freeze()
	require.NoError(t, err)
}

func TestUnitTokenClaimAirdropTransactionToBytes(t *testing.T) {
	t.Parallel()

	pendingAirdropId := PendingAirdropId{tokenID: &TokenID{Token: 1}, sender: &AccountID{Account: 3}}

	transaction := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(pendingAirdropId)

	bytes, err := transaction.ToBytes()
	require.NoError(t, err)
	require.NotNil(t, bytes)
}

func TestUnitTokenClaimAirdropTransactionFromBytes(t *testing.T) {
	t.Parallel()

	pendingAirdropId := PendingAirdropId{tokenID: &TokenID{Token: 1}}

	transaction := NewTokenClaimAirdropTransaction().
		AddPendingAirdropId(pendingAirdropId)

	bytes, err := transaction.ToBytes()
	require.NoError(t, err)
	require.NotNil(t, bytes)

	deserializedTransaction, err := TransactionFromBytes(bytes)
	require.NoError(t, err)

	switch tx := deserializedTransaction.(type) {
	case TokenClaimAirdropTransaction:
		assert.Equal(t, transaction.GetPendingAirdropIds(), tx.GetPendingAirdropIds())
	default:
		t.Fatalf("expected TokenClaimAirdropTransaction, got %T", deserializedTransaction)
	}
}

func TestUnitTokenClaimAirdropTransactionScheduleProtobuf(t *testing.T) {
	t.Parallel()

	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	pendingAirdropId1 := PendingAirdropId{tokenID: &TokenID{Token: 1}}
	pendingAirdropId2 := PendingAirdropId{tokenID: &TokenID{Token: 2}}

	tx, err := NewTokenClaimAirdropTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddPendingAirdropId(pendingAirdropId1).
		AddPendingAirdropId(pendingAirdropId2).
		Freeze()
	require.NoError(t, err)

	expected := &services.SchedulableTransactionBody{
		TransactionFee: 100000000,
		Data: &services.SchedulableTransactionBody_TokenClaimAirdrop{
			TokenClaimAirdrop: &services.TokenClaimAirdropTransactionBody{
				PendingAirdrops: []*services.PendingAirdropId{
					pendingAirdropId1._ToProtobuf(),
					pendingAirdropId2._ToProtobuf(),
				},
			},
		},
	}

	actual, err := tx.buildScheduled()
	require.NoError(t, err)
	require.Equal(t, expected.String(), actual.String())
}

func TestUnitTokenClaimAirdropTransactionValidateNetworkOnIDs(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	checksum := "dmqui"
	pendingAirdropId := &PendingAirdropId{
		tokenID:  &TokenID{Token: 3, checksum: &checksum},
		sender:   &AccountID{Account: 3, checksum: &checksum},
		receiver: &AccountID{Account: 3, checksum: &checksum},
	}

	transaction := NewTokenClaimAirdropTransaction().
		SetPendingAirdropIds([]*PendingAirdropId{pendingAirdropId})

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
}
// Filename: token_create_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenCreateTransaction
// Create a new token. After the token is created, the Token ID for it is in the receipt.
// The specified Treasury Account is receiving the initial supply of tokens as-well as the tokens
// from the Token Mint operation once executed. The balance of the treasury account is decreased
// when the Token Burn operation is executed.
//
// The initialSupply is the initial supply of the smallest parts of a token (like a
// tinybar, not an hbar). These are the smallest units of the token which may be transferred.
//
// The supply can change over time. If the total supply at some moment is S parts of tokens,
// and the token is using D decimals, then S must be less than or equal to
// 2<sup>63</sup>-1, which is 9,223,372,036,854,775,807. The number of whole tokens (not parts) will
// be S / 10<sup>D</sup>.
//
// If decimals is 8 or 11, then the number of whole tokens can be at most a few billions or
// millions, respectively. For example, it could match Bitcoin (21 million whole tokens with 8
// decimals) or hbars (50 billion whole tokens with 8 decimals). It could even match Bitcoin with
// milli-satoshis (21 million whole tokens with 11 decimals).
//
// Note that a created token is immutable if the adminKey is omitted. No property of
// an immutable token can ever change, with the sole exception of its expiry. Anyone can pay to
// extend the expiry time of an immutable token.
//
// A token can be either FUNGIBLE_COMMON or NON_FUNGIBLE_UNIQUE, based on its
// TokenType. If it has been omitted, FUNGIBLE_COMMON type is used.
//
// A token can have either INFINITE or FINITE supply type, based on its
// TokenType. If it has been omitted, INFINITE type is used.
//
// If a FUNGIBLE TokenType is used, initialSupply should explicitly be set to a
// non-negative. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
//
// If a NON_FUNGIBLE_UNIQUE TokenType is used, initialSupply should explicitly be set
// to 0. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
//
// If an INFINITE TokenSupplyType is used, maxSupply should explicitly be set to 0. If
// it is not 0, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
//
// If a FINITE TokenSupplyType is used, maxSupply should be explicitly set to a
// non-negative value. If it is not, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
type TokenCreateTransaction struct {
	Transaction
	treasuryAccountID  *AccountID
	autoRenewAccountID *AccountID
	customFees         []Fee
	tokenName          string
	memo               string
	tokenSymbol        string
	decimals           uint32
	tokenSupplyType    TokenSupplyType
	tokenType          TokenType
	maxSupply          int64
	metadata           []byte
	adminKey           Key
	kycKey             Key
	freezeKey          Key
	wipeKey            Key
	scheduleKey        Key
	supplyKey          Key
	pauseKey           Key
	metadataKey        Key
	initialSupply      uint64
	freezeDefault      *bool
	expirationTime     *time.Time
	autoRenewPeriod    *time.Duration
}

// NewTokenCreateTransaction creates TokenCreateTransaction which creates a new token.
// After the token is created, the Token ID for it is in the receipt.
// The specified Treasury Account is receiving the initial supply of tokens as-well as the tokens
// from the Token Mint operation once executed. The balance of the treasury account is decreased
// when the Token Burn operation is executed.
//
// The initialSupply is the initial supply of the smallest parts of a token (like a
// tinybar, not an hbar). These are the smallest units of the token which may be transferred.
//
// The supply can change over time. If the total supply at some moment is S parts of tokens,
// and the token is using D decimals, then S must be less than or equal to
// 2<sup>63</sup>-1, which is 9,223,372,036,854,775,807. The number of whole tokens (not parts) will
// be S / 10<sup>D</sup>.
//
// If decimals is 8 or 11, then the number of whole tokens can be at most a few billions or
// millions, respectively. For example, it could match Bitcoin (21 million whole tokens with 8
// decimals) or hbars (50 billion whole tokens with 8 decimals). It could even match Bitcoin with
// milli-satoshis (21 million whole tokens with 11 decimals).
//
// Note that a created token is immutable if the adminKey is omitted. No property of
// an immutable token can ever change, with the sole exception of its expiry. Anyone can pay to
// extend the expiry time of an immutable token.
//
// A token can be either FUNGIBLE_COMMON or NON_FUNGIBLE_UNIQUE, based on its
// TokenType. If it has been omitted, FUNGIBLE_COMMON type is used.
//
// A token can have either INFINITE or FINITE supply type, based on its
// TokenType. If it has been omitted, INFINITE type is used.
//
// If a FUNGIBLE TokenType is used, initialSupply should explicitly be set to a
// non-negative. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
//
// If a NON_FUNGIBLE_UNIQUE TokenType is used, initialSupply should explicitly be set
// to 0. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
//
// If an INFINITE TokenSupplyType is used, maxSupply should explicitly be set to 0. If
// it is not 0, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
//
// If a FINITE TokenSupplyType is used, maxSupply should be explicitly set to a
// non-negative value. If it is not, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
func NewTokenCreateTransaction() *TokenCreateTransaction {
	tx := TokenCreateTransaction{
		Transaction: _NewTransaction(),
	}

	tx.SetAutoRenewPeriod(7890000 * time.Second)
	tx._SetDefaultMaxTransactionFee(NewHbar(40))
	tx.SetTokenType(TokenTypeFungibleCommon)

	return &tx
}

func _TokenCreateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenCreateTransaction {
	customFees := make([]Fee, 0)

	for _, fee := range pb.GetTokenCreation().GetCustomFees() {
		customFees = append(customFees, _CustomFeeFromProtobuf(fee))
	}
	adminKey, _ := _KeyFromProtobuf(pb.GetTokenCreation().GetAdminKey())
	kycKey, _ := _KeyFromProtobuf(pb.GetTokenCreation().GetKycKey())
	freezeKey, _ := _KeyFromProtobuf(pb.GetTokenCreation().GetFreezeKey())
	wipeKey, _ := _KeyFromProtobuf(pb.GetTokenCreation().GetWipeKey())
	scheduleKey, _ := _KeyFromProtobuf(pb.GetTokenCreation().GetFeeScheduleKey())
	supplyKey, _ := _KeyFromProtobuf(pb.GetTokenCreation().GetSupplyKey())
	pauseKey, _ := _KeyFromProtobuf(pb.GetTokenCreation().GetPauseKey())
	metadataKey, _ := _KeyFromProtobuf(pb.GetTokenCreation().GetMetadataKey())

	freezeDefault := pb.GetTokenCreation().GetFreezeDefault()

	expirationTime := _TimeFromProtobuf(pb.GetTokenCreation().GetExpiry())
	autoRenew := _DurationFromProtobuf(pb.GetTokenCreation().GetAutoRenewPeriod())

	return &TokenCreateTransaction{
		Transaction:        tx,
		treasuryAccountID:  _AccountIDFromProtobuf(pb.GetTokenCreation().GetTreasury()),
		autoRenewAccountID: _AccountIDFromProtobuf(pb.GetTokenCreation().GetAutoRenewAccount()),
		customFees:         customFees,
		tokenName:          pb.GetTokenCreation().GetName(),
		memo:               pb.GetTokenCreation().GetMemo(),
		tokenSymbol:        pb.GetTokenCreation().GetSymbol(),
		decimals:           pb.GetTokenCreation().GetDecimals(),
		tokenSupplyType:    TokenSupplyType(pb.GetTokenCreation().GetSupplyType()),
		tokenType:          TokenType(pb.GetTokenCreation().GetTokenType()),
		maxSupply:          pb.GetTokenCreation().GetMaxSupply(),
		metadata:           pb.GetTokenCreation().GetMetadata(),
		adminKey:           adminKey,
		kycKey:             kycKey,
		freezeKey:          freezeKey,
		wipeKey:            wipeKey,
		scheduleKey:        scheduleKey,
		supplyKey:          supplyKey,
		pauseKey:           pauseKey,
		metadataKey:        metadataKey,
		initialSupply:      pb.GetTokenCreation().InitialSupply,
		freezeDefault:      &freezeDefault,
		expirationTime:     &expirationTime,
		autoRenewPeriod:    &autoRenew,
	}
}

// SetTokenName Sets the publicly visible name of the token, specified as a string of only ASCII characters
func (tx *TokenCreateTransaction) SetTokenName(name string) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.tokenName = name
	return tx
}

// GetTokenName returns the token name
func (tx *TokenCreateTransaction) GetTokenName() string {
	return tx.tokenName
}

// SetTokenSymbol Sets the publicly visible token symbol. It is UTF-8 capitalized alphabetical string identifying the token
func (tx *TokenCreateTransaction) SetTokenSymbol(symbol string) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.tokenSymbol = symbol
	return tx
}

// SetTokenMemo Sets the publicly visible token memo. It is max 100 bytes.
func (tx *TokenCreateTransaction) SetTokenMemo(memo string) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo
	return tx
}

// GetTokenMemo returns the token memo
func (tx *TokenCreateTransaction) GetTokenMemo() string {
	return tx.memo
}

// GetTokenSymbol returns the token symbol
func (tx *TokenCreateTransaction) GetTokenSymbol() string {
	return tx.tokenSymbol
}

// SetDecimals Sets the number of decimal places a token is divisible by. This field can never be changed!
func (tx *TokenCreateTransaction) SetDecimals(decimals uint) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.decimals = uint32(decimals)
	return tx
}

// GetDecimals returns the number of decimal places a token is divisible by
func (tx *TokenCreateTransaction) GetDecimals() uint {
	return uint(tx.decimals)
}

// SetTokenType Specifies the token type. Defaults to FUNGIBLE_COMMON
func (tx *TokenCreateTransaction) SetTokenType(t TokenType) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.tokenType = t
	return tx
}

// GetTokenType returns the token type
func (tx *TokenCreateTransaction) GetTokenType() TokenType {
	return tx.tokenType
}

// SetSupplyType Specifies the token supply type. Defaults to INFINITE
func (tx *TokenCreateTransaction) SetSupplyType(tokenSupply TokenSupplyType) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.tokenSupplyType = tokenSupply
	return tx
}

// GetSupplyType returns the token supply type
func (tx *TokenCreateTransaction) GetSupplyType() TokenSupplyType {
	return tx.tokenSupplyType
}

// SetMaxSupply Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - sets the
// maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -
// sets the maximum number of NFTs (serial numbers) that can be minted. This field can never be
// changed!
func (tx *TokenCreateTransaction) SetMaxSupply(maxSupply int64) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.maxSupply = maxSupply
	return tx
}

// GetMaxSupply returns the max supply
func (tx *TokenCreateTransaction) GetMaxSupply() int64 {
	return tx.maxSupply
}

// SetTokenMetadata Sets the metadata for the token
func (tx *TokenCreateTransaction) SetTokenMetadata(metadata []byte) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.metadata = metadata
	return tx
}

// GetTokenMetadata returns token class metadata
func (tx *TokenCreateTransaction) GetTokenMetadata() []byte {
	return tx.metadata
}

// SetTreasuryAccountID Sets the account which will act as a treasury for the token. This account will receive the specified initial supply
func (tx *TokenCreateTransaction) SetTreasuryAccountID(treasuryAccountID AccountID) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.treasuryAccountID = &treasuryAccountID
	return tx
}

// GetTreasuryAccountID returns the treasury account ID
func (tx *TokenCreateTransaction) GetTreasuryAccountID() AccountID {
	if tx.treasuryAccountID == nil {
		return AccountID{}
	}

	return *tx.treasuryAccountID
}

// SetAdminKey Sets the key which can perform update/delete operations on the token. If empty, the token can be perceived as immutable (not being able to be updated/deleted)
func (tx *TokenCreateTransaction) SetAdminKey(publicKey Key) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.adminKey = publicKey
	return tx
}

// GetAdminKey returns the admin key
func (tx *TokenCreateTransaction) GetAdminKey() Key {
	return tx.adminKey
}

// SetKycKey Sets the key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required, and KYC grant or revoke operations are not possible.
func (tx *TokenCreateTransaction) SetKycKey(publicKey Key) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.kycKey = publicKey
	return tx
}

func (tx *TokenCreateTransaction) GetKycKey() Key {
	return tx.kycKey
}

// SetFreezeKey Sets the key which can sign to freeze or unfreeze an account for token transactions. If empty, freezing is not possible
func (tx *TokenCreateTransaction) SetFreezeKey(publicKey Key) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.freezeKey = publicKey
	return tx
}

// GetFreezeKey returns the freeze key
func (tx *TokenCreateTransaction) GetFreezeKey() Key {
	return tx.freezeKey
}

// SetWipeKey Sets the key which can wipe the token balance of an account. If empty, wipe is not possible
func (tx *TokenCreateTransaction) SetWipeKey(publicKey Key) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.wipeKey = publicKey
	return tx
}

// GetWipeKey returns the wipe key
func (tx *TokenCreateTransaction) GetWipeKey() Key {
	return tx.wipeKey
}

// SetFeeScheduleKey Set the key which can change the token's custom fee schedule; must sign a TokenFeeScheduleUpdate
// transaction
func (tx *TokenCreateTransaction) SetFeeScheduleKey(key Key) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.scheduleKey = key
	return tx
}

// GetFeeScheduleKey returns the fee schedule key
func (tx *TokenCreateTransaction) GetFeeScheduleKey() Key {
	return tx.scheduleKey
}

// SetPauseKey Set the Key which can pause and unpause the Token.
// If Empty the token pause status defaults to PauseNotApplicable, otherwise Unpaused.
func (tx *TokenCreateTransaction) SetPauseKey(key Key) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.pauseKey = key
	return tx
}

// GetPauseKey returns the pause key
func (tx *TokenCreateTransaction) GetPauseKey() Key {
	return tx.pauseKey
}

// SetMetadataKey Set the Key which can update the metadata.
func (tx *TokenCreateTransaction) SetMetadataKey(key Key) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.metadataKey = key
	return tx
}

// GetMetadataKey returns the metadata key
func (tx *TokenCreateTransaction) GetMetadataKey() Key {
	return tx.metadataKey
}

// SetCustomFees Set the custom fees to be assessed during a CryptoTransfer that transfers units of this token
func (tx *TokenCreateTransaction) SetCustomFees(customFee []Fee) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.customFees = customFee
	return tx
}

// GetCustomFees returns the custom fees
func (tx *TokenCreateTransaction) GetCustomFees() []Fee {
	return tx.customFees
}

// The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
// SetInitialBalance sets the initial number of Hbar to put into the token
func (tx *TokenCreateTransaction) SetSupplyKey(publicKey Key) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.supplyKey = publicKey
	return tx
}

func (tx *TokenCreateTransaction) GetSupplyKey() Key {
	return tx.supplyKey
}

// Specifies the initial supply of tokens to be put in circulation. The initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.
func (tx *TokenCreateTransaction) SetInitialSupply(initialSupply uint64) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.initialSupply = initialSupply
	return tx
}

func (tx *TokenCreateTransaction) GetInitialSupply() uint64 {
	return tx.initialSupply
}

// The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If true, an account must be unfrozen before it can receive the token
func (tx *TokenCreateTransaction) SetFreezeDefault(freezeDefault bool) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.freezeDefault = &freezeDefault
	return tx
}

// GetFreezeDefault returns the freeze default
func (tx *TokenCreateTransaction) GetFreezeDefault() bool {
	return *tx.freezeDefault
}

// The epoch second at which the token should expire; if an auto-renew account and period are specified, this is coerced to the current epoch second plus the autoRenewPeriod
func (tx *TokenCreateTransaction) SetExpirationTime(expirationTime time.Time) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = nil
	tx.expirationTime = &expirationTime

	return tx
}

func (tx *TokenCreateTransaction) GetExpirationTime() time.Time {
	if tx.expirationTime != nil {
		return *tx.expirationTime
	}

	return time.Time{}
}

// An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
func (tx *TokenCreateTransaction) SetAutoRenewAccount(autoRenewAccountID AccountID) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewAccountID = &autoRenewAccountID
	return tx
}

func (tx *TokenCreateTransaction) GetAutoRenewAccount() AccountID {
	if tx.autoRenewAccountID == nil {
		return AccountID{}
	}

	return *tx.autoRenewAccountID
}

// The interval at which the auto-renew account will be charged to extend the token's expiry
func (tx *TokenCreateTransaction) SetAutoRenewPeriod(autoRenewPeriod time.Duration) *TokenCreateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = &autoRenewPeriod
	return tx
}

func (tx *TokenCreateTransaction) GetAutoRenewPeriod() time.Duration {
	if tx.autoRenewPeriod != nil {
		return time.Duration(int64(tx.autoRenewPeriod.Seconds()) * time.Second.Nanoseconds())
	}

	return time.Duration(0)
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenCreateTransaction) Sign(privateKey PrivateKey) *TokenCreateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenCreateTransaction) SignWithOperator(client *Client) (*TokenCreateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenCreateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenCreateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenCreateTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenCreateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenCreateTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenCreateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenCreateTransaction) Freeze() (*TokenCreateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenCreateTransaction) FreezeWith(client *Client) (*TokenCreateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenCreateTransaction.
func (tx *TokenCreateTransaction) SetMaxTransactionFee(fee Hbar) *TokenCreateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenCreateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenCreateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenCreateTransaction.
func (tx *TokenCreateTransaction) SetTransactionMemo(memo string) *TokenCreateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenCreateTransaction.
func (tx *TokenCreateTransaction) SetTransactionValidDuration(duration time.Duration) *TokenCreateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenCreateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenCreateTransaction.
func (tx *TokenCreateTransaction) SetTransactionID(transactionID TransactionID) *TokenCreateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenCreateTransaction.
func (tx *TokenCreateTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenCreateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenCreateTransaction) SetMaxRetry(count int) *TokenCreateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenCreateTransaction) SetMaxBackoff(max time.Duration) *TokenCreateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenCreateTransaction) SetMinBackoff(min time.Duration) *TokenCreateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenCreateTransaction) SetLogLevel(level LogLevel) *TokenCreateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenCreateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenCreateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenCreateTransaction) getName() string {
	return "TokenCreateTransaction"
}

func (tx *TokenCreateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.treasuryAccountID != nil {
		if err := tx.treasuryAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.autoRenewAccountID != nil {
		if err := tx.autoRenewAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	for _, customFee := range tx.customFees {
		if err := customFee.validateNetworkOnIDs(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenCreateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenCreation{
			TokenCreation: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenCreateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenCreation{
			TokenCreation: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenCreateTransaction) buildProtoBody() *services.TokenCreateTransactionBody {
	body := &services.TokenCreateTransactionBody{
		Name:          tx.tokenName,
		Symbol:        tx.tokenSymbol,
		Memo:          tx.memo,
		Decimals:      tx.decimals,
		TokenType:     services.TokenType(tx.tokenType),
		SupplyType:    services.TokenSupplyType(tx.tokenSupplyType),
		MaxSupply:     tx.maxSupply,
		InitialSupply: tx.initialSupply,
	}

	if tx.autoRenewPeriod != nil {
		body.AutoRenewPeriod = _DurationToProtobuf(*tx.autoRenewPeriod)
	}

	if tx.expirationTime != nil {
		body.Expiry = _TimeToProtobuf(*tx.expirationTime)
	}

	if tx.treasuryAccountID != nil {
		body.Treasury = tx.treasuryAccountID._ToProtobuf()
	}

	if tx.autoRenewAccountID != nil {
		body.AutoRenewAccount = tx.autoRenewAccountID._ToProtobuf()
	}

	if body.CustomFees == nil {
		body.CustomFees = make([]*services.CustomFee, 0)
	}
	for _, customFee := range tx.customFees {
		body.CustomFees = append(body.CustomFees, customFee._ToProtobuf())
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	if tx.freezeKey != nil {
		body.FreezeKey = tx.freezeKey._ToProtoKey()
	}

	if tx.scheduleKey != nil {
		body.FeeScheduleKey = tx.scheduleKey._ToProtoKey()
	}

	if tx.kycKey != nil {
		body.KycKey = tx.kycKey._ToProtoKey()
	}

	if tx.wipeKey != nil {
		body.WipeKey = tx.wipeKey._ToProtoKey()
	}

	if tx.supplyKey != nil {
		body.SupplyKey = tx.supplyKey._ToProtoKey()
	}

	if tx.pauseKey != nil {
		body.PauseKey = tx.pauseKey._ToProtoKey()
	}

	if tx.metadataKey != nil {
		body.MetadataKey = tx.metadataKey._ToProtoKey()
	}

	if tx.freezeDefault != nil {
		body.FreezeDefault = *tx.freezeDefault
	}

	if tx.metadata != nil {
		body.Metadata = tx.metadata
	}

	return body
}

func (tx *TokenCreateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().CreateToken,
	}
}

func (tx *TokenCreateTransaction) preFreezeWith(client *Client) {
	if tx.autoRenewAccountID == nil && tx.autoRenewPeriod != nil && client != nil && !client.GetOperatorAccountID()._IsZero() {
		tx.SetAutoRenewAccount(client.GetOperatorAccountID())
	}
}

func (tx *TokenCreateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_create_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenCreateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenCreateTransactionMultipleKeys(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	keys := make([]PrivateKey, 6)
	pubKeys := make([]PublicKey, 6)

	for i := range keys {
		newKey, err := PrivateKeyGenerateEd25519()
		require.NoError(t, err)

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(pubKeys[0]).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetFreezeKey(pubKeys[1]).
			SetWipeKey(pubKeys[2]).
			SetKycKey(pubKeys[3]).
			SetSupplyKey(pubKeys[4]).
			SetMetadataKey(pubKeys[5])
	})
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenCreateTransactionNoKeys(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	keys := make([]PrivateKey, 6)
	pubKeys := make([]PublicKey, 6)

	for i := range keys {
		newKey, err := PrivateKeyGenerateEd25519()
		require.NoError(t, err)

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(pubKeys[0]).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenCreateTransaction().
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTreasuryAccountID(env.Client.GetOperatorAccountID()).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tokenID := *receipt.TokenID

	info, err := NewTokenInfoQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		Execute(env.Client)

	require.NoError(t, err)
	assert.Equal(t, info.Name, "ffff")
	assert.Equal(t, info.Symbol, "F")
	assert.Equal(t, info.Decimals, uint32(0))
	assert.Equal(t, info.TotalSupply, uint64(0))
	assert.Equal(t, info.Treasury.String(), env.Client.GetOperatorAccountID().String())
	assert.Nil(t, info.AdminKey)
	assert.Nil(t, info.FreezeKey)
	assert.Nil(t, info.KycKey)
	assert.Nil(t, info.WipeKey)
	assert.Nil(t, info.SupplyKey)
	assert.Nil(t, info.DefaultFreezeStatus)
	assert.Nil(t, info.DefaultKycStatus)
	assert.NotNil(t, info.AutoRenewPeriod)
	assert.Equal(t, *info.AutoRenewPeriod, 7890000*time.Second)
	assert.NotNil(t, info.AutoRenewAccountID)
	assert.Equal(t, info.AutoRenewAccountID.String(), env.Client.GetOperatorAccountID().String())
	assert.NotNil(t, info.ExpirationTime)
}

func TestIntegrationTokenCreateTransactionAdminSign(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	keys := make([]PrivateKey, 6)
	pubKeys := make([]PublicKey, 6)

	for i := range keys {
		newKey, err := PrivateKeyGenerateEd25519()
		require.NoError(t, err)

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(pubKeys[0]).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetFreezeKey(pubKeys[1]).
			SetWipeKey(pubKeys[2]).
			SetKycKey(pubKeys[3]).
			SetSupplyKey(pubKeys[4]).
			SetMetadataKey(pubKeys[5]).
			FreezeWith(env.Client)
		transaction.
			Sign(keys[0]).
			Sign(keys[1])
	})

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenNftCreateTransaction(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createNft(&env)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenCreateTransactionWithCustomFees(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetCustomFees([]Fee{
				NewCustomFixedFee().
					SetFeeCollectorAccountID(env.OperatorID).
					SetAmount(10),
				NewCustomFractionalFee().
					SetFeeCollectorAccountID(env.OperatorID).
					SetNumerator(1).
					SetDenominator(20).
					SetMin(1).
					SetAssessmentMethod(true).
					SetMax(10),
			})
	})

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenCreateTransactionWithCustomFeesDenominatorZero(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetCustomFees([]Fee{
				CustomFixedFee{
					CustomFee: CustomFee{
						FeeCollectorAccountID: &env.OperatorID,
					},
					Amount: 10,
				},
				CustomFractionalFee{
					CustomFee: CustomFee{
						FeeCollectorAccountID: &env.OperatorID,
					},
					Numerator:     1,
					Denominator:   0,
					MinimumAmount: 1,
					MaximumAmount: 10,
				},
			})
	})
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: FRACTION_DIVIDES_BY_ZERO", err.Error())
	}
}

func TestIntegrationTokenCreateTransactionWithInvalidFeeCollectorAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetCustomFees([]Fee{
				NewCustomFractionalFee().
					SetFeeCollectorAccountID(AccountID{}).
					SetNumerator(1).
					SetDenominator(20).
					SetMin(1).
					SetMax(10),
			})
	})
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_CUSTOM_FEE_COLLECTOR", err.Error())
	}
}

func TestIntegrationTokenCreateTransactionWithMaxLessThanMin(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetCustomFees([]Fee{
				CustomFractionalFee{
					CustomFee: CustomFee{
						FeeCollectorAccountID: &env.OperatorID,
					},
					Numerator:     1,
					Denominator:   20,
					MinimumAmount: 100,
					MaximumAmount: 10,
				},
			})
	})
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT", err.Error())
	}
}

func TestIntegrationTokenCreateTransactionWithRoyaltyCustomFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetCustomFees([]Fee{
				NewCustomRoyaltyFee().
					SetFeeCollectorAccountID(env.OperatorID).
					SetNumerator(1).
					SetDenominator(20).
					SetFallbackFee(
						NewCustomFixedFee().
							SetFeeCollectorAccountID(env.OperatorID).
							SetAmount(10),
					),
			})
	})
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenCreateTransactionWithRoyaltyCannotExceedOne(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetCustomFees([]Fee{
				NewCustomRoyaltyFee().
					SetFeeCollectorAccountID(env.OperatorID).
					SetNumerator(2).
					SetDenominator(1),
			})
	})
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: ROYALTY_FRACTION_CANNOT_EXCEED_ONE", err.Error())
	}
}

func TestIntegrationTokenCreateTransactionFeeCollectorMissing(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetCustomFees([]Fee{
				NewCustomRoyaltyFee().
					SetNumerator(1).
					SetDenominator(20),
			})
	})
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_CUSTOM_FEE_COLLECTOR", err.Error())
	}
}

func TestIntegrationTokenCreateTransactionRoyaltyFeeOnlyAllowedForNonFungibleUnique(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetCustomFees([]Fee{
				NewCustomRoyaltyFee().
					SetFeeCollectorAccountID(env.OperatorID).
					SetNumerator(1).
					SetDenominator(20),
			})
	})
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE", err.Error())
	}
}

func TestIntegrationTokenAccountStillOwnsNfts(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetTreasuryAccountID(accountID).
			SetAdminKey(newKey.PublicKey()).
			SetFreezeKey(newKey.PublicKey()).
			SetWipeKey(newKey.PublicKey()).
			SetKycKey(newKey.PublicKey()).
			SetSupplyKey(newKey.PublicKey()).
			FreezeWith(env.Client)

		transaction.Sign(newKey)
	})
	require.NoError(t, err)

	metaData := make([]byte, 50, 101)

	mintTx, err := NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetMetadata(metaData).
		FreezeWith(env.Client)
	require.NoError(t, err)

	mintTx.Sign(newKey)

	mint, err := mintTx.Execute(env.Client)
	require.NoError(t, err)

	_, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	deleteTx, err := NewTokenDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTokenID(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	deleteTx.Sign(newKey)

	resp, err = deleteTx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func TestIntegrationTokenCreateTransactionMetadataKey(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	pubKey := newKey.PublicKey()

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(pubKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetMetadataKey(pubKey)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(2)).
		SetTokenID(tokenID).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)

	require.NoError(t, err)
	assert.Equal(t, pubKey, info.MetadataKey)

	err = CloseIntegrationTestEnv(env, &tokenID)
}
// Filename: token_create_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

var testMetadata = []byte{1, 2, 3, 4, 5}

func TestUnitTokenCreateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	supple := TokenSupplyTypeFinite

	println("token supply type", supple.String())

	typ := TokenTypeFungibleCommon

	println("token type", typ.String())

	tokenCreate := NewTokenCreateTransaction().
		SetAutoRenewAccount(accountID).
		SetTreasuryAccountID(accountID)

	err = tokenCreate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenCreateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenCreate := NewTokenCreateTransaction().
		SetAutoRenewAccount(accountID).
		SetTreasuryAccountID(accountID)

	err = tokenCreate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenCreateTransactionGet(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	accountID := AccountID{Account: 3, checksum: &checksum}

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetTokenMemo("fnord").
		SetDecimals(3).
		SetCustomFees([]Fee{}).
		SetTokenType(TokenTypeFungibleCommon).
		SetSupplyType(TokenSupplyTypeFinite).
		SetMaxSupply(12312123123123).
		SetInitialSupply(1000000).
		SetTreasuryAccountID(accountID).
		SetAdminKey(newKey).
		SetFreezeKey(newKey).
		SetWipeKey(newKey).
		SetKycKey(newKey).
		SetSupplyKey(newKey).
		SetPauseKey(newKey).
		SetMetadataKey(newKey).
		SetTokenMetadata(testMetadata).
		SetExpirationTime(time.Now()).
		SetFreezeDefault(false).
		SetAutoRenewPeriod(60 * time.Second).
		SetAutoRenewAccount(accountID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		SetGrpcDeadline(&grpc).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenName()
	transaction.GetTokenSymbol()
	transaction.GetTokenMemo()
	transaction.GetDecimals()
	transaction.GetCustomFees()
	transaction.GetTokenType()
	transaction.GetSupplyType()
	transaction.GetMaxSupply()
	transaction.GetInitialSupply()
	transaction.GetTreasuryAccountID()
	transaction.GetAdminKey()
	transaction.GetFreezeKey()
	transaction.GetWipeKey()
	transaction.GetKycKey()
	transaction.GetSupplyKey()
	transaction.GetPauseKey()
	transaction.GetMetadataKey()
	transaction.GetTokenMetadata()
	transaction.GetExpirationTime()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenCreateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenCreateTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenName()
	transaction.GetTokenSymbol()
	transaction.GetTokenMemo()
	transaction.GetDecimals()
	transaction.GetCustomFees()
	transaction.GetTokenType()
	transaction.GetSupplyType()
	transaction.GetMaxSupply()
	transaction.GetInitialSupply()
	transaction.GetTreasuryAccountID()
	transaction.GetAdminKey()
	transaction.GetFreezeKey()
	transaction.GetWipeKey()
	transaction.GetKycKey()
	transaction.GetSupplyKey()
	transaction.GetPauseKey()
	transaction.GetMetadataKey()
	transaction.GetExpirationTime()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	proto := transaction.build().GetTokenCreation()
	require.Nil(t, proto.AutoRenewAccount)
	require.Nil(t, proto.AdminKey)
	require.Nil(t, proto.Expiry)
	require.Nil(t, proto.FeeScheduleKey)
	require.Nil(t, proto.FreezeKey)
	require.Nil(t, proto.KycKey)
	require.Nil(t, proto.FeeScheduleKey)
	require.Nil(t, proto.PauseKey)
	require.Nil(t, proto.SupplyKey)
	require.Nil(t, proto.MetadataKey)
	require.Nil(t, proto.Metadata)
	require.Nil(t, proto.Treasury)
}

func TestUnitTokenCreateTransactionKeyCheck(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	keys := make([]PrivateKey, 8)
	var err error

	for i := 0; i < len(keys); i++ {
		keys[i], err = PrivateKeyGenerateEd25519()
		require.NoError(t, err)
	}

	transaction, err := NewTokenCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(keys[0]).
		SetFreezeKey(keys[1]).
		SetWipeKey(keys[2]).
		SetKycKey(keys[3]).
		SetSupplyKey(keys[4]).
		SetPauseKey(keys[5]).
		SetFeeScheduleKey(keys[6]).
		SetMetadataKey(keys[7]).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenCreation()
	require.Equal(t, proto.AdminKey.String(), keys[0]._ToProtoKey().String())
	require.Equal(t, proto.FreezeKey.String(), keys[1]._ToProtoKey().String())
	require.Equal(t, proto.WipeKey.String(), keys[2]._ToProtoKey().String())
	require.Equal(t, proto.KycKey.String(), keys[3]._ToProtoKey().String())
	require.Equal(t, proto.SupplyKey.String(), keys[4]._ToProtoKey().String())
	require.Equal(t, proto.PauseKey.String(), keys[5]._ToProtoKey().String())
	require.Equal(t, proto.FeeScheduleKey.String(), keys[6]._ToProtoKey().String())
	require.Equal(t, proto.MetadataKey.String(), keys[7]._ToProtoKey().String())
}

func TestUnitTokenCreateTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	accountID := AccountID{Account: 3, checksum: &checksum}

	freez, err := NewTokenCreateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTreasuryAccountID(accountID).
		SetAdminKey(newKey).
		SetFreezeKey(newKey).
		SetWipeKey(newKey).
		SetKycKey(newKey).
		SetSupplyKey(newKey).
		SetPauseKey(newKey).
		SetTokenMetadata(testMetadata).
		SetMetadataKey(newKey).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}

func TestUnitTokenCreateAutoRenewAccountSetting(t *testing.T) {
	client, err := _NewMockClient()
	autoRenewAccount := AccountID{Account: 3}
	frozenTx, err := NewTokenCreateTransaction().
		SetAutoRenewAccount(autoRenewAccount).
		SetAutoRenewPeriod(24 * time.Hour).
		FreezeWith(client)
	require.NoError(t, err)
	require.Equal(t, autoRenewAccount, frozenTx.GetAutoRenewAccount())
}
// Filename: token_decimal_map.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

type TokenDecimalMap struct {
	decimals map[string]uint64
}

// Get returns the balance of the given tokenID
func (tokenDecimals *TokenDecimalMap) Get(tokenID TokenID) uint64 {
	return tokenDecimals.decimals[TokenID{
		Shard: tokenID.Shard,
		Realm: tokenID.Realm,
		Token: tokenID.Token,
	}.String()]
}

func _TokenDecimalMapFromProtobuf(pb []*services.TokenBalance) TokenDecimalMap {
	decimals := make(map[string]uint64)

	for _, tokenDecimal := range pb {
		decimals[_TokenIDFromProtobuf(tokenDecimal.TokenId).String()] = uint64(tokenDecimal.Decimals)
	}

	return TokenDecimalMap{decimals}
}

func (tokenDecimals TokenDecimalMap) _ToProtobuf() []*services.TokenBalance { // nolint
	decimals := make([]*services.TokenBalance, 0)

	for s, t := range tokenDecimals.decimals {
		token, err := TokenIDFromString(s)
		if err != nil {
			return []*services.TokenBalance{}
		}
		decimals = append(decimals, &services.TokenBalance{
			TokenId:  token._ToProtobuf(),
			Decimals: uint32(t),
		})
	}

	return decimals
}
// Filename: token_decimal_map_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
)

func TestUnitTokenDecimalMapGet(t *testing.T) {
	t.Parallel()

	tokenDecimals := TokenDecimalMap{
		decimals: map[string]uint64{
			"0.0.123": 9,
			"0.0.124": 10,
		},
	}

	assert.Equal(t, uint64(9), tokenDecimals.Get(TokenID{Shard: 0, Realm: 0, Token: 123}))
	assert.Equal(t, uint64(10), tokenDecimals.Get(TokenID{Shard: 0, Realm: 0, Token: 124}))
}

func TestUnitTokenDecimalMapToProtobuf(t *testing.T) {
	t.Parallel()

	tokenDecimals := TokenDecimalMap{
		decimals: map[string]uint64{
			"0.0.123": 9,
			"0.0.124": 10,
		},
	}

	decimals := tokenDecimals._ToProtobuf()

	assert.Equal(t, 2, len(decimals))

	// The order of the decimals is not guaranteed
	for _, dec := range decimals {
		switch dec.TokenId.TokenNum {
		case 123:
			assert.Equal(t, uint32(9), dec.Decimals)
		case 124:
			assert.Equal(t, uint32(10), dec.Decimals)
		default:
			t.Errorf("Unexpected TokenID: %v", dec.TokenId.String())
		}
	}
}

func TestUnitTokenDecimalMapFromProtobuf(t *testing.T) {
	t.Parallel()

	decimals := make([]*services.TokenBalance, 0)
	decimals = append(decimals, &services.TokenBalance{
		TokenId:  &services.TokenID{ShardNum: 0, RealmNum: 0, TokenNum: 123},
		Decimals: uint32(9),
	})
	decimals = append(decimals, &services.TokenBalance{
		TokenId:  &services.TokenID{ShardNum: 0, RealmNum: 0, TokenNum: 124},
		Decimals: uint32(10),
	})

	tokenDecimals := _TokenDecimalMapFromProtobuf(decimals)

	assert.Equal(t, uint64(9), tokenDecimals.Get(TokenID{Shard: 0, Realm: 0, Token: 123}))
	assert.Equal(t, uint64(10), tokenDecimals.Get(TokenID{Shard: 0, Realm: 0, Token: 124}))
}

func TestUnitTokenDecimalMapFromProtobufEmpty(t *testing.T) {
	t.Parallel()

	tokenDecimals := TokenDecimalMap{
		decimals: map[string]uint64{
			"0.123":   9, // invalid token
			"0.0.124": 10,
		},
	}
	pb := tokenDecimals._ToProtobuf()
	assert.Equal(t, []*services.TokenBalance{}, pb)
}
// Filename: token_delete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenDeleteTransaction
// Marks a token as deleted, though it will remain in the ledger.
// The operation must be signed by the specified Admin Key of the Token. If
// admin key is not set, transaction will result in TOKEN_IS_IMMUTABlE.
// Once deleted update, mint, burn, wipe, freeze, unfreeze, grant kyc, revoke
// kyc and token transfer transactions will resolve to TOKEN_WAS_DELETED.
type TokenDeleteTransaction struct {
	Transaction
	tokenID *TokenID
}

// NewTokenDeleteTransaction creates TokenDeleteTransaction which marks a token as deleted,
// though it will remain in the ledger.
// The operation must be signed by the specified Admin Key of the Token. If
// admin key is not set, Transaction will result in TOKEN_IS_IMMUTABlE.
// Once deleted update, mint, burn, wipe, freeze, unfreeze, grant kyc, revoke
// kyc and token transfer transactions will resolve to TOKEN_WAS_DELETED.
func NewTokenDeleteTransaction() *TokenDeleteTransaction {
	tx := TokenDeleteTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenDeleteTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenDeleteTransaction {
	return &TokenDeleteTransaction{
		Transaction: tx,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenDeletion().GetToken()),
	}
}

// SetTokenID Sets the Token to be deleted
func (tx *TokenDeleteTransaction) SetTokenID(tokenID TokenID) *TokenDeleteTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the TokenID of the token to be deleted
func (tx *TokenDeleteTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenDeleteTransaction) Sign(privateKey PrivateKey) *TokenDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenDeleteTransaction) SignWithOperator(client *Client) (*TokenDeleteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenDeleteTransaction) Freeze() (*TokenDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenDeleteTransaction) FreezeWith(client *Client) (*TokenDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenDeleteTransaction.
func (tx *TokenDeleteTransaction) SetMaxTransactionFee(fee Hbar) *TokenDeleteTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenDeleteTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenDeleteTransaction.
func (tx *TokenDeleteTransaction) SetTransactionMemo(memo string) *TokenDeleteTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenDeleteTransaction.
func (tx *TokenDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *TokenDeleteTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenDeleteTransaction.
func (tx *TokenDeleteTransaction) SetTransactionID(transactionID TransactionID) *TokenDeleteTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenDeleteTransaction.
func (tx *TokenDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenDeleteTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenDeleteTransaction) SetMaxRetry(count int) *TokenDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenDeleteTransaction) SetMaxBackoff(max time.Duration) *TokenDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenDeleteTransaction) SetMinBackoff(min time.Duration) *TokenDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenDeleteTransaction) SetLogLevel(level LogLevel) *TokenDeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenDeleteTransaction) getName() string {
	return "TokenDeleteTransaction"
}

func (tx *TokenDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenDeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenDeletion{
			TokenDeletion: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenDeletion{
			TokenDeletion: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenDeleteTransaction) buildProtoBody() *services.TokenDeleteTransactionBody {
	body := &services.TokenDeleteTransactionBody{}
	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	return body
}

func (tx *TokenDeleteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().DeleteToken,
	}
}
func (tx *TokenDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_delete_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenDeleteTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenDeleteTransactionNoKeys(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	tokenCreate, err := NewTokenCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetDecimals(3).
		SetInitialSupply(1000000).
		SetTreasuryAccountID(env.Client.GetOperatorAccountID()).
		SetAdminKey(env.OperatorKey.PublicKey()).
		SetFreezeDefault(false).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tokenCreate, err = tokenCreate.
		SignWithOperator(env.Client)
	require.NoError(t, err)

	resp, err := tokenCreate.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, receipt.TokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenDeleteTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTokenDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_TOKEN_ID received for transaction %s", resp.TransactionID), err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: token_delete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenDeleteTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenDelete := NewTokenDeleteTransaction().
		SetTokenID(tokenID)

	err = tokenDelete.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenDeleteTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenDelete := NewTokenDeleteTransaction().
		SetTokenID(tokenID)

	err = tokenDelete.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenDeleteTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenDeleteTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenDeleteTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(token).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenDeleteTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenDeleteTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}

	freez, err := NewTokenDeleteTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: token_dissociate_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenDissociateTransaction
// Dissociates the provided account with the provided tokens. Must be signed by the provided Account's key.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an association between the provided account and any of the tokens does not exist, the
// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If a token has not been deleted and has not expired, and the user has a nonzero balance, the
// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.
// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is
// not zero.
// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token
// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.
// On success, associations between the provided account and tokens are removed.
type TokenDissociateTransaction struct {
	Transaction
	accountID *AccountID
	tokens    []TokenID
}

// NewTokenDissociateTransaction creates TokenDissociateTransaction which
// dissociates the provided account with the provided tokens. Must be signed by the provided Account's key.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an association between the provided account and any of the tokens does not exist, the
// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If a token has not been deleted and has not expired, and the user has a nonzero balance, the
// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.
// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is
// not zero.
// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token
// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.
// On success, associations between the provided account and tokens are removed.
func NewTokenDissociateTransaction() *TokenDissociateTransaction {
	tx := TokenDissociateTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _TokenDissociateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenDissociateTransaction {
	tokens := make([]TokenID, 0)
	for _, token := range pb.GetTokenDissociate().Tokens {
		if tokenID := _TokenIDFromProtobuf(token); tokenID != nil {
			tokens = append(tokens, *tokenID)
		}
	}

	return &TokenDissociateTransaction{
		Transaction: tx,
		accountID:   _AccountIDFromProtobuf(pb.GetTokenDissociate().GetAccount()),
		tokens:      tokens,
	}
}

// SetAccountID Sets the account to be dissociated with the provided tokens
func (tx *TokenDissociateTransaction) SetAccountID(accountID AccountID) *TokenDissociateTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

func (tx *TokenDissociateTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// SetTokenIDs Sets the tokens to be dissociated with the provided account
func (tx *TokenDissociateTransaction) SetTokenIDs(ids ...TokenID) *TokenDissociateTransaction {
	tx._RequireNotFrozen()
	tx.tokens = make([]TokenID, len(ids))
	copy(tx.tokens, ids)

	return tx
}

// AddTokenID Adds the token to the list of tokens to be dissociated.
func (tx *TokenDissociateTransaction) AddTokenID(id TokenID) *TokenDissociateTransaction {
	tx._RequireNotFrozen()
	if tx.tokens == nil {
		tx.tokens = make([]TokenID, 0)
	}

	tx.tokens = append(tx.tokens, id)

	return tx
}

// GetTokenIDs returns the tokens to be associated with the provided account
func (tx *TokenDissociateTransaction) GetTokenIDs() []TokenID {
	tokenIDs := make([]TokenID, len(tx.tokens))
	copy(tokenIDs, tx.tokens)

	return tokenIDs
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenDissociateTransaction) Sign(privateKey PrivateKey) *TokenDissociateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenDissociateTransaction) SignWithOperator(client *Client) (*TokenDissociateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenDissociateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenDissociateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenDissociateTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenDissociateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenDissociateTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenDissociateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenDissociateTransaction) Freeze() (*TokenDissociateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenDissociateTransaction) FreezeWith(client *Client) (*TokenDissociateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenDissociateTransaction.
func (tx *TokenDissociateTransaction) SetMaxTransactionFee(fee Hbar) *TokenDissociateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenDissociateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenDissociateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenDissociateTransaction.
func (tx *TokenDissociateTransaction) SetTransactionMemo(memo string) *TokenDissociateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenDissociateTransaction.
func (tx *TokenDissociateTransaction) SetTransactionValidDuration(duration time.Duration) *TokenDissociateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenDissociateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenDissociateTransaction.
func (tx *TokenDissociateTransaction) SetTransactionID(transactionID TransactionID) *TokenDissociateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenDissociateTransaction.
func (tx *TokenDissociateTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenDissociateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenDissociateTransaction) SetMaxRetry(count int) *TokenDissociateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenDissociateTransaction) SetMaxBackoff(max time.Duration) *TokenDissociateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenDissociateTransaction) SetMinBackoff(min time.Duration) *TokenDissociateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenDissociateTransaction) SetLogLevel(level LogLevel) *TokenDissociateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenDissociateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenDissociateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenDissociateTransaction) getName() string {
	return "TokenDissociateTransaction"
}

func (tx *TokenDissociateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	for _, tokenID := range tx.tokens {
		if err := tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenDissociateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenDissociate{
			TokenDissociate: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenDissociateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenDissociate{
			TokenDissociate: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenDissociateTransaction) buildProtoBody() *services.TokenDissociateTransactionBody {
	body := &services.TokenDissociateTransactionBody{}
	if tx.accountID != nil {
		body.Account = tx.accountID._ToProtobuf()
	}

	if len(tx.tokens) > 0 {
		for _, tokenID := range tx.tokens {
			if body.Tokens == nil {
				body.Tokens = make([]*services.TokenID, 0)
			}
			body.Tokens = append(body.Tokens, tokenID._ToProtobuf())
		}
	}

	return body
}

func (tx *TokenDissociateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().DissociateTokens,
	}
}

func (tx *TokenDissociateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_dissociate_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenDissociateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	associateTx, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = associateTx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	dissociateTx, err := NewTokenDissociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = dissociateTx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenDissociateTransactionNoSigningOne(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	_, err = NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	_, err = NewTokenDissociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	_, err = NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenDissociateTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	associateTx, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = associateTx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	dissociateTx, err := NewTokenDissociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = dissociateTx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	_, err = NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenDissociateTransactionNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	associateTx, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = associateTx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	dissociateTx, err := NewTokenDissociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp2, err := dissociateTx.
		Sign(newKey).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_ACCOUNT_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	_, err = NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}
// Filename: token_dissociate_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenDissociateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenDissociate := NewTokenDissociateTransaction().
		SetAccountID(accountID).
		SetTokenIDs(tokenID)

	err = tokenDissociate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenDissociateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenDissociate := NewTokenDissociateTransaction().
		SetAccountID(accountID).
		SetTokenIDs(tokenID)

	err = tokenDissociate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenDissociateTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenDissociateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(tokenID, TokenID{Token: 4}, TokenID{Token: 3}).
		SetAccountID(AccountID{Account: 3}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenIDs()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenDissociateTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenDissociateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenIDs()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenDissociateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	tokenID2 := TokenID{Token: 4}
	tokenID3 := TokenID{Token: 3}
	accountID := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenDissociateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(tokenID, tokenID2, tokenID3).
		SetAccountID(accountID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenDissociate()
	require.Equal(t, proto.Tokens[0].String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.Tokens[1].String(), tokenID2._ToProtobuf().String())
	require.Equal(t, proto.Tokens[2].String(), tokenID3._ToProtobuf().String())
	require.Equal(t, proto.Account.String(), accountID._ToProtobuf().String())
}

func TestUnitTokenDissociateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenDissociateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(token).
		AddTokenID(token).
		SetAccountID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenIDs()
	transaction.GetAccountID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenDissociateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenDissociateTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		key, _ := PrivateKeyFromStringEd25519("302e020100300506032b657004220420d45e1557156908c967804615af59a000be88c7aa7058bfcbe0f46b16c28f887d")
		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		require.Equal(t, bytes.Compare(sigMap.SigPair[1].PubKeyPrefix, key.PublicKey().BytesRaw()), 0)
		require.Equal(t, bytes.Compare(sigMap.SigPair[0].PubKeyPrefix, newKey.PublicKey().BytesRaw()), 0)

		if bod, ok := transactionBody.Data.(*services.TransactionBody_TokenAssociate); ok {
			require.Equal(t, bod.TokenAssociate.Account.GetAccountNum(), int64(123))
			require.Equal(t, bod.TokenAssociate.Tokens[0].TokenNum, int64(123))
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	freez, err := NewTokenDissociateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAccountID(AccountID{Account: 123}).
		SetTokenIDs(TokenID{Token: 123}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.
		Sign(newKey).
		Execute(client)
	require.NoError(t, err)
}
// Filename: token_fee_schedule_update_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/pkg/errors"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenFeeScheduleUpdateTransaction
// At consensus, updates a token type's fee schedule to the given list of custom fees.
//
// If the target token type has no fee_schedule_key, resolves to TOKEN_HAS_NO_FEE_SCHEDULE_KEY.
// Otherwise this transaction must be signed to the fee_schedule_key, or the transaction will
// resolve to INVALID_SIGNATURE.
//
// If the custom_fees list is empty, clears the fee schedule or resolves to
// CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES if the fee schedule was already empty.
type TokenFeeScheduleUpdateTransaction struct {
	Transaction
	tokenID    *TokenID
	customFees []Fee
}

// NewTokenFeeScheduleUpdateTransaction creates TokenFeeScheduleUpdateTransaction which
// at consensus, updates a token type's fee schedule to the given list of custom fees.
//
// If the target token type has no fee_schedule_key, resolves to TOKEN_HAS_NO_FEE_SCHEDULE_KEY.
// Otherwise this transaction must be signed to the fee_schedule_key, or the transaction will
// resolve to INVALID_SIGNATURE.
//
// If the custom_fees list is empty, clears the fee schedule or resolves to
// CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES if the fee schedule was already empty.
func NewTokenFeeScheduleUpdateTransaction() *TokenFeeScheduleUpdateTransaction {
	tx := TokenFeeScheduleUpdateTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(5))

	return &tx
}

func _TokenFeeScheduleUpdateTransactionFromProtobuf(transaction Transaction, pb *services.TransactionBody) *TokenFeeScheduleUpdateTransaction {
	customFees := make([]Fee, 0)

	for _, fee := range pb.GetTokenFeeScheduleUpdate().GetCustomFees() {
		customFees = append(customFees, _CustomFeeFromProtobuf(fee))
	}

	return &TokenFeeScheduleUpdateTransaction{
		Transaction: transaction,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenFeeScheduleUpdate().TokenId),
		customFees:  customFees,
	}
}

// SetTokenID Sets the token whose fee schedule is to be updated
func (tx *TokenFeeScheduleUpdateTransaction) SetTokenID(tokenID TokenID) *TokenFeeScheduleUpdateTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the token whose fee schedule is to be updated
func (tx *TokenFeeScheduleUpdateTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// SetCustomFees Sets the new custom fees to be assessed during a CryptoTransfer that transfers units of this token
func (tx *TokenFeeScheduleUpdateTransaction) SetCustomFees(fees []Fee) *TokenFeeScheduleUpdateTransaction {
	tx._RequireNotFrozen()
	tx.customFees = fees
	return tx
}

// GetCustomFees returns the new custom fees to be assessed during a CryptoTransfer that transfers units of this token
func (tx *TokenFeeScheduleUpdateTransaction) GetCustomFees() []Fee {
	return tx.customFees
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenFeeScheduleUpdateTransaction) Sign(privateKey PrivateKey) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenFeeScheduleUpdateTransaction) SignWithOperator(client *Client) (*TokenFeeScheduleUpdateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenFeeScheduleUpdateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenFeeScheduleUpdateTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenFeeScheduleUpdateTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenFeeScheduleUpdateTransaction) Freeze() (*TokenFeeScheduleUpdateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenFeeScheduleUpdateTransaction) FreezeWith(client *Client) (*TokenFeeScheduleUpdateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenFeeScheduleUpdateTransaction.
func (tx *TokenFeeScheduleUpdateTransaction) SetMaxTransactionFee(fee Hbar) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenFeeScheduleUpdateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenFeeScheduleUpdateTransaction.
func (tx *TokenFeeScheduleUpdateTransaction) SetTransactionMemo(memo string) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenFeeScheduleUpdateTransaction.
func (tx *TokenFeeScheduleUpdateTransaction) SetTransactionValidDuration(duration time.Duration) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenFeeScheduleUpdateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenFeeScheduleUpdateTransaction.
func (tx *TokenFeeScheduleUpdateTransaction) SetTransactionID(transactionID TransactionID) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenFeeScheduleUpdateTransaction.
func (tx *TokenFeeScheduleUpdateTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenFeeScheduleUpdateTransaction) SetMaxRetry(count int) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenFeeScheduleUpdateTransaction) SetMaxBackoff(max time.Duration) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenFeeScheduleUpdateTransaction) SetMinBackoff(min time.Duration) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenFeeScheduleUpdateTransaction) SetLogLevel(level LogLevel) *TokenFeeScheduleUpdateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenFeeScheduleUpdateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenFeeScheduleUpdateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenFeeScheduleUpdateTransaction) getName() string {
	return "TokenFeeScheduleUpdateTransaction"
}

func (tx *TokenFeeScheduleUpdateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	for _, customFee := range tx.customFees {
		if err := customFee.validateNetworkOnIDs(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenFeeScheduleUpdateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenFeeScheduleUpdate{
			TokenFeeScheduleUpdate: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenFeeScheduleUpdateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return nil, errors.New("cannot schedule `TokenFeeScheduleUpdateTransaction")
}

func (tx *TokenFeeScheduleUpdateTransaction) buildProtoBody() *services.TokenFeeScheduleUpdateTransactionBody {
	body := &services.TokenFeeScheduleUpdateTransactionBody{}
	if tx.tokenID != nil {
		body.TokenId = tx.tokenID._ToProtobuf()
	}

	if len(tx.customFees) > 0 {
		for _, customFee := range tx.customFees {
			if body.CustomFees == nil {
				body.CustomFees = make([]*services.CustomFee, 0)
			}
			body.CustomFees = append(body.CustomFees, customFee._ToProtobuf())
		}
	}

	return body
}

func (tx *TokenFeeScheduleUpdateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().UpdateTokenFeeSchedule,
	}
}
func (tx *TokenFeeScheduleUpdateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_fee_schedule_update_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenFeeScheduleUpdateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFixedFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &env.OperatorID,
		},
		Amount:              1,
		DenominationTokenID: &tokenID,
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{customFee}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.True(t, len(info.CustomFees) > 0)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenFeeScheduleUpdateTransactionWithFractional(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFractionalFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &env.OperatorID,
		},
		Numerator:        1,
		Denominator:      20,
		MinimumAmount:    1,
		MaximumAmount:    10,
		AssessmentMethod: FeeAssessmentMethodExclusive,
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{customFee}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.True(t, len(info.CustomFees) > 0)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenFeeScheduleUpdateTransactionNoFeeScheduleKey(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetFeeScheduleKey(nil)
	})

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFixedFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &env.OperatorID,
		},
		Amount:              1,
		DenominationTokenID: &tokenID,
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{customFee}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: TOKEN_HAS_NO_FEE_SCHEDULE_KEY", err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenFeeScheduleUpdateTransactionWrongScheduleKey(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetFeeScheduleKey(newKey.PublicKey())
	})

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFixedFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &env.OperatorID,
		},
		Amount:              1,
		DenominationTokenID: &tokenID,
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{customFee}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_CUSTOM_FEE_SCHEDULE_KEY", err.Error())
	}

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.True(t, len(info.CustomFees) > 0)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenFeeScheduleUpdateTransactionScheduleAlreadyHasNoFees(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "exceptional receipt status: CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES")

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenFeeScheduleUpdateTransactionFractionalFeeOnlyForFungibleCommon(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createNft(&env)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFractionalFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &env.OperatorID,
		},
		Numerator:        1,
		Denominator:      20,
		MinimumAmount:    1,
		MaximumAmount:    10,
		AssessmentMethod: FeeAssessmentMethodExclusive,
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{customFee}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON", err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenFeeScheduleUpdateTransactionDenominationMustBeFungibleCommon(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	tokenIDNonFungible, err := createNft(&env)
	require.NoError(t, err)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFixedFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &env.OperatorID,
		},
		Amount:              5,
		DenominationTokenID: &tokenIDNonFungible,
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{customFee}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON", err.Error())
	}
}

func TestIntegrationTokenFeeScheduleUpdateTransactionCustomFeeListTooLong(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFixedFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &env.OperatorID,
		},
		Amount:              1,
		DenominationTokenID: &tokenID,
	}

	feeArr := make([]Fee, 0)

	for i := 0; i < 21; i++ {
		feeArr = append(feeArr, customFee)
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees(feeArr).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: CUSTOM_FEES_LIST_TOO_LONG", err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}
// Filename: token_fee_schedule_update_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenFeeScheduleUpdateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	fee := NewCustomFixedFee().SetDenominatingTokenID(tokenID).SetFeeCollectorAccountID(accountID)
	require.NoError(t, err)

	tokenFeeUpdate := NewTokenFeeScheduleUpdateTransaction().
		SetCustomFees([]Fee{fee}).
		SetTokenID(tokenID)

	err = tokenFeeUpdate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenFeeScheduleUpdateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	fee := NewCustomFixedFee().SetDenominatingTokenID(tokenID).SetFeeCollectorAccountID(accountID)
	require.NoError(t, err)

	tokenFeeUpdate := NewTokenFeeScheduleUpdateTransaction().
		SetCustomFees([]Fee{fee}).
		SetTokenID(tokenID)

	err = tokenFeeUpdate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenFeeScheduleUpdateTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenFeeScheduleUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetCustomFees([]Fee{}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetCustomFees()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenFeeScheduleUpdateTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenFeeScheduleUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetCustomFees()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenFeeScheduleUpdateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenFeeScheduleUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetCustomFees([]Fee{NewCustomFixedFee().SetHbarAmount(NewHbar(4))}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	proto := transaction.build().GetTokenFeeScheduleUpdate()
	require.Equal(t, proto.TokenId.String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.CustomFees[0].Fee.(*services.CustomFee_FixedFee).FixedFee.String(),
		NewCustomFixedFee().SetHbarAmount(NewHbar(4))._ToProtobuf().Fee.(*services.CustomFee_FixedFee).FixedFee.String())
}

func TestUnitTokenFeeScheduleUpdateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenFeeScheduleUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(token).
		SetCustomFees([]Fee{NewCustomFixedFee().SetHbarAmount(NewHbar(4))}).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenID()
	transaction.GetCustomFees()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenFeeScheduleUpdateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenFeeScheduleUpdateTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}

	freez, err := NewTokenFeeScheduleUpdateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		SetCustomFees([]Fee{NewCustomFixedFee().SetHbarAmount(NewHbar(4))}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: token_freeze_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenFreezeTransaction
// Freezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
// Once executed the Account is marked as Frozen and will not be able to receive or send tokens
// unless unfrozen. The operation is idempotent.
type TokenFreezeTransaction struct {
	Transaction
	tokenID   *TokenID
	accountID *AccountID
}

// NewTokenFreezeTransaction creates TokenFreezeTransaction which
// freezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
// Once executed the Account is marked as Frozen and will not be able to receive or send tokens
// unless unfrozen. The operation is idempotent.
func NewTokenFreezeTransaction() *TokenFreezeTransaction {
	tx := TokenFreezeTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenFreezeTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenFreezeTransaction {
	return &TokenFreezeTransaction{
		Transaction: tx,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenFreeze().GetToken()),
		accountID:   _AccountIDFromProtobuf(pb.GetTokenFreeze().GetAccount()),
	}
}

// SetTokenID Sets the token for which this account will be frozen. If token does not exist, transaction results
// in INVALID_TOKEN_ID
func (tx *TokenFreezeTransaction) SetTokenID(tokenID TokenID) *TokenFreezeTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the token for which this account will be frozen.
func (tx *TokenFreezeTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// SetAccountID Sets the account to be frozen
func (tx *TokenFreezeTransaction) SetAccountID(accountID AccountID) *TokenFreezeTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetAccountID returns the account to be frozen
func (tx *TokenFreezeTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenFreezeTransaction) Sign(privateKey PrivateKey) *TokenFreezeTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenFreezeTransaction) SignWithOperator(client *Client) (*TokenFreezeTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenFreezeTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenFreezeTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenFreezeTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenFreezeTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenFreezeTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenFreezeTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenFreezeTransaction) Freeze() (*TokenFreezeTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenFreezeTransaction) FreezeWith(client *Client) (*TokenFreezeTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenFreezeTransaction.
func (tx *TokenFreezeTransaction) SetMaxTransactionFee(fee Hbar) *TokenFreezeTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenFreezeTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenFreezeTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenFreezeTransaction.
func (tx *TokenFreezeTransaction) SetTransactionMemo(memo string) *TokenFreezeTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenFreezeTransaction.
func (tx *TokenFreezeTransaction) SetTransactionValidDuration(duration time.Duration) *TokenFreezeTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenFreezeTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenFreezeTransaction.
func (tx *TokenFreezeTransaction) SetTransactionID(transactionID TransactionID) *TokenFreezeTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenFreezeTransaction.
func (tx *TokenFreezeTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenFreezeTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenFreezeTransaction) SetMaxRetry(count int) *TokenFreezeTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenFreezeTransaction) SetMaxBackoff(max time.Duration) *TokenFreezeTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenFreezeTransaction) SetMinBackoff(min time.Duration) *TokenFreezeTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenFreezeTransaction) SetLogLevel(level LogLevel) *TokenFreezeTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenFreezeTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenFreezeTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenFreezeTransaction) getName() string {
	return "TokenFreezeTransaction"
}

func (tx *TokenFreezeTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenFreezeTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenFreeze{
			TokenFreeze: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenFreezeTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenFreeze{
			TokenFreeze: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenFreezeTransaction) buildProtoBody() *services.TokenFreezeAccountTransactionBody {
	body := &services.TokenFreezeAccountTransactionBody{}
	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	if tx.accountID != nil {
		body.Account = tx.accountID._ToProtobuf()
	}

	return body
}

func (tx *TokenFreezeTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().FreezeTokenAccount,
	}
}
func (tx *TokenFreezeTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_freeze_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenFreezeTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenFreezeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenFreezeTransactionNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenFreezeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_TOKEN_ID received for transaction %s", resp.TransactionID), err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}
// Filename: token_freeze_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenFreezeTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenFreeze := NewTokenFreezeTransaction().
		SetAccountID(accountID).
		SetTokenID(tokenID)

	err = tokenFreeze.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenFreezeTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenFreeze := NewTokenFreezeTransaction().
		SetAccountID(accountID).
		SetTokenID(tokenID)

	err = tokenFreeze.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenFreezeTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenFreezeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAccountID(AccountID{Account: 3}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenFreezeTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenFreezeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenFreezeTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	accountID := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenFreezeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenFreeze()
	require.Equal(t, proto.Token.String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.Account.String(), accountID._ToProtobuf().String())
}

func TestUnitTokenFreezeTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenFreezeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(token).
		SetAccountID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenID()
	transaction.GetAccountID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenFreezeTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenFreezeTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}

	freez, err := NewTokenFreezeTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		SetAccountID(account).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: token_grant_kyc_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenGrantKycTransaction
// Grants KYC to the account for the given token. Must be signed by the Token's kycKey.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
// Once executed the Account is marked as KYC Granted.
type TokenGrantKycTransaction struct {
	Transaction
	tokenID   *TokenID
	accountID *AccountID
}

// NewTokenGrantKycTransaction creates TokenGrantKycTransaction which
// grants KYC to the account for the given token. Must be signed by the Token's kycKey.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
// Once executed the Account is marked as KYC Granted.
func NewTokenGrantKycTransaction() *TokenGrantKycTransaction {
	tx := TokenGrantKycTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenGrantKycTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenGrantKycTransaction {
	return &TokenGrantKycTransaction{
		Transaction: tx,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenGrantKyc().GetToken()),
		accountID:   _AccountIDFromProtobuf(pb.GetTokenGrantKyc().GetAccount()),
	}
}

// SetTokenID Sets the token for which this account will be granted KYC.
// If token does not exist, transaction results in INVALID_TOKEN_ID
func (tx *TokenGrantKycTransaction) SetTokenID(tokenID TokenID) *TokenGrantKycTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the token for which this account will be granted KYC.
func (tx *TokenGrantKycTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// SetAccountID Sets the account to be KYCed
func (tx *TokenGrantKycTransaction) SetAccountID(accountID AccountID) *TokenGrantKycTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetAccountID returns the AccountID that is being KYCed
func (tx *TokenGrantKycTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenGrantKycTransaction) Sign(privateKey PrivateKey) *TokenGrantKycTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenGrantKycTransaction) SignWithOperator(client *Client) (*TokenGrantKycTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenGrantKycTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenGrantKycTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenGrantKycTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenGrantKycTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenGrantKycTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenGrantKycTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenGrantKycTransaction) Freeze() (*TokenGrantKycTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenGrantKycTransaction) FreezeWith(client *Client) (*TokenGrantKycTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenGrantKycTransaction.
func (tx *TokenGrantKycTransaction) SetMaxTransactionFee(fee Hbar) *TokenGrantKycTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenGrantKycTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenGrantKycTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenGrantKycTransaction.
func (tx *TokenGrantKycTransaction) SetTransactionMemo(memo string) *TokenGrantKycTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenGrantKycTransaction.
func (tx *TokenGrantKycTransaction) SetTransactionValidDuration(duration time.Duration) *TokenGrantKycTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenGrantKycTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenGrantKycTransaction.
func (tx *TokenGrantKycTransaction) SetTransactionID(transactionID TransactionID) *TokenGrantKycTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenGrantKycTransaction.
func (tx *TokenGrantKycTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenGrantKycTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenGrantKycTransaction) SetMaxRetry(count int) *TokenGrantKycTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenGrantKycTransaction) SetMaxBackoff(max time.Duration) *TokenGrantKycTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenGrantKycTransaction) SetMinBackoff(min time.Duration) *TokenGrantKycTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenGrantKycTransaction) SetLogLevel(level LogLevel) *TokenGrantKycTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenGrantKycTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenGrantKycTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenGrantKycTransaction) getName() string {
	return "TokenGrantKycTransaction"
}

func (tx *TokenGrantKycTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenGrantKycTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenGrantKyc{
			TokenGrantKyc: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenGrantKycTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenGrantKyc{
			TokenGrantKyc: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenGrantKycTransaction) buildProtoBody() *services.TokenGrantKycTransactionBody {
	body := &services.TokenGrantKycTransactionBody{}
	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	if tx.accountID != nil {
		body.Account = tx.accountID._ToProtobuf()
	}

	return body
}

func (tx *TokenGrantKycTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().GrantKycToTokenAccount,
	}
}
func (tx *TokenGrantKycTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_grant_kyc_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenGrantKycTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenGrantKycTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_TOKEN_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenGrantKycTransactionNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_ACCOUNT_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenGrantKycTransactionNoKycSet(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(nil)
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	assert.Equal(t, "exceptional receipt status: TOKEN_HAS_NO_KYC_KEY", err.Error())

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}
// Filename: token_grant_kyc_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenGrantKycTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenGrantKyc := NewTokenGrantKycTransaction().
		SetAccountID(accountID).
		SetTokenID(tokenID)

	err = tokenGrantKyc.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenGrantKycTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenGrantKyc := NewTokenGrantKycTransaction().
		SetAccountID(accountID).
		SetTokenID(tokenID)

	err = tokenGrantKyc.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenGrantKycTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenGrantKycTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAccountID(AccountID{Account: 3}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenGrantKycTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenGrantKycTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenGrantKycTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	accountID := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenGrantKycTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenGrantKyc()
	require.Equal(t, proto.Token.String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.Account.String(), accountID._ToProtobuf().String())
}

func TestUnitTokenGrantKycTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenGrantKycTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(token).
		SetAccountID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenID()
	transaction.GetAccountID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenGrantKycTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenGrantKycTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}

	freez, err := NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		SetAccountID(account).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: token_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/pkg/errors"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// TokenID is the ID for a Hedera token
type TokenID struct {
	Shard    uint64
	Realm    uint64
	Token    uint64
	checksum *string
}

func _TokenIDFromProtobuf(tokenID *services.TokenID) *TokenID {
	if tokenID == nil {
		return nil
	}

	return &TokenID{
		Shard: uint64(tokenID.ShardNum),
		Realm: uint64(tokenID.RealmNum),
		Token: uint64(tokenID.TokenNum),
	}
}

func (id *TokenID) _ToProtobuf() *services.TokenID {
	return &services.TokenID{
		ShardNum: int64(id.Shard),
		RealmNum: int64(id.Realm),
		TokenNum: int64(id.Token),
	}
}

// String returns a string representation of the TokenID formatted as `Shard.Realm.TokenID` (for example "0.0.3")
func (id TokenID) String() string {
	return fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Token)
}

// ToStringWithChecksum returns a string representation of the TokenID formatted as `Shard.Realm.TokenID-Checksum` (for example "0.0.3-abcd")
func (id TokenID) ToStringWithChecksum(client Client) (string, error) {
	if client.GetNetworkName() == nil && client.GetLedgerID() == nil {
		return "", errNetworkNameMissing
	}
	var checksum _ParseAddressResult
	var err error
	if client.network.ledgerID != nil {
		checksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Token))
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%d.%d.%d-%s", id.Shard, id.Realm, id.Token, checksum.correctChecksum), nil
}

// ToBytes returns a byte array representation of the TokenID
func (id TokenID) ToBytes() []byte {
	data, err := protobuf.Marshal(id._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TokenIDFromBytes returns a TokenID from a byte array
func TokenIDFromBytes(data []byte) (TokenID, error) {
	if data == nil {
		return TokenID{}, errByteArrayNull
	}
	pb := services.TokenID{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TokenID{}, err
	}

	return *_TokenIDFromProtobuf(&pb), nil
}

// NftID constructs an NftID from a TokenID and a serial number
func (id *TokenID) Nft(serial int64) NftID {
	return NftID{
		TokenID:      *id,
		SerialNumber: serial,
	}
}

// TokenIDFromString constructs an TokenID from a string formatted as
// `Shard.Realm.TokenID` (for example "0.0.3")
func TokenIDFromString(data string) (TokenID, error) {
	shard, realm, num, checksum, err := _IdFromString(data)
	if err != nil {
		return TokenID{}, err
	}

	return TokenID{
		Shard:    uint64(shard),
		Realm:    uint64(realm),
		Token:    uint64(num),
		checksum: checksum,
	}, nil
}

// Verify that the client has a valid checksum.
func (id *TokenID) ValidateChecksum(client *Client) error {
	if !id._IsZero() && client != nil {
		var tempChecksum _ParseAddressResult
		var err error
		tempChecksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Token))
		if err != nil {
			return err
		}
		err = _ChecksumVerify(tempChecksum.status)
		if err != nil {
			return err
		}
		if id.checksum == nil {
			return errChecksumMissing
		}
		if tempChecksum.correctChecksum != *id.checksum {
			networkName := NetworkNameOther
			if client.network.ledgerID != nil {
				networkName, _ = client.network.ledgerID.ToNetworkName()
			}
			return errors.New(fmt.Sprintf("network mismatch or wrong checksum given, given checksum: %s, correct checksum %s, network: %s",
				*id.checksum,
				tempChecksum.correctChecksum,
				networkName))
		}
	}

	return nil
}

// Deprecated - use ValidateChecksum instead
func (id *TokenID) Validate(client *Client) error {
	return id.ValidateChecksum(client)
}

// TokenIDFromSolidityAddress constructs a TokenID from a string
// representation of a _Solidity address
func TokenIDFromSolidityAddress(s string) (TokenID, error) {
	shard, realm, token, err := _IdFromSolidityAddress(s)
	if err != nil {
		return TokenID{}, err
	}

	return TokenID{
		Shard:    shard,
		Realm:    realm,
		Token:    token,
		checksum: nil,
	}, nil
}

// ToSolidityAddress returns the string representation of the TokenID as a
// _Solidity address.
func (id TokenID) ToSolidityAddress() string {
	return _IdToSolidityAddress(id.Shard, id.Realm, id.Token)
}

func (id TokenID) _IsZero() bool {
	return id.Shard == 0 && id.Realm == 0 && id.Token == 0
}

// equals returns true if this TokenID and the given TokenID are identical
func (id TokenID) equals(other TokenID) bool {
	return id.Shard == other.Shard && id.Realm == other.Realm
}

// Compare compares two TokenIDs
func (id TokenID) Compare(given TokenID) int {
	if id.Shard > given.Shard { //nolint
		return 1
	} else if id.Shard < given.Shard {
		return -1
	}

	if id.Realm > given.Realm { //nolint
		return 1
	} else if id.Realm < given.Realm {
		return -1
	}

	if id.Token > given.Token { //nolint
		return 1
	} else if id.Token < given.Token {
		return -1
	} else { //nolint
		return 0
	}
}
// Filename: token_id_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenIDFromString(t *testing.T) {
	t.Parallel()

	tokID := TokenID{
		Shard: 1,
		Realm: 2,
		Token: 3,
	}

	gotTokID, err := TokenIDFromString(tokID.String())
	require.NoError(t, err)
	assert.Equal(t, tokID.Token, gotTokID.Token)
}

func TestUnitTokenIDChecksumFromString(t *testing.T) {
	t.Parallel()

	id, err := TokenIDFromString("0.0.123-rmkyk")
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	id.ToStringWithChecksum(*client)
	sol := id.ToSolidityAddress()
	TokenIDFromSolidityAddress(sol)
	id.Validate(client)
	pb := id._ToProtobuf()
	_TokenIDFromProtobuf(pb)

	idByte := id.ToBytes()
	TokenIDFromBytes(idByte)

	id.Compare(TokenID{Token: 32})

	assert.Equal(t, id.Token, uint64(123))
}

func TestUnitTokenIDChecksumToString(t *testing.T) {
	t.Parallel()

	id := AccountID{
		Shard:   50,
		Realm:   150,
		Account: 520,
	}
	assert.Equal(t, "50.150.520", id.String())
}

func TestUnitTokenIDFromStringEVM(t *testing.T) {
	t.Parallel()

	id, err := TokenIDFromString("0.0.434")
	require.NoError(t, err)

	require.Equal(t, "0.0.434", id.String())
}

func TestUnitTokenIDProtobuf(t *testing.T) {
	t.Parallel()

	id, err := TokenIDFromString("0.0.434")
	require.NoError(t, err)

	pb := id._ToProtobuf()

	require.Equal(t, pb, &services.TokenID{
		ShardNum: 0,
		RealmNum: 0,
		TokenNum: 434,
	})

	pbFrom := _TokenIDFromProtobuf(pb)

	require.Equal(t, id, *pbFrom)
}
// Filename: token_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// TokenInfo is the information about a token
type TokenInfo struct {
	TokenID             TokenID
	Name                string
	Symbol              string
	Decimals            uint32
	TotalSupply         uint64
	Treasury            AccountID
	AdminKey            Key
	KycKey              Key
	FreezeKey           Key
	WipeKey             Key
	SupplyKey           Key
	DefaultFreezeStatus *bool
	DefaultKycStatus    *bool
	Deleted             bool
	AutoRenewPeriod     *time.Duration
	AutoRenewAccountID  AccountID
	ExpirationTime      *time.Time
	TokenMemo           string
	TokenType           TokenType
	SupplyType          TokenSupplyType
	MaxSupply           int64
	FeeScheduleKey      Key
	CustomFees          []Fee
	PauseKey            Key
	PauseStatus         *bool
	MetadataKey         Key
	Metadata            []byte
	LedgerID            LedgerID
}

func _FreezeStatusFromProtobuf(pb services.TokenFreezeStatus) *bool {
	var freezeStatus bool
	switch pb.Number() {
	case 1:
		freezeStatus = true
	case 2:
		freezeStatus = false
	default:
		return nil
	}

	return &freezeStatus
}

func _KycStatusFromProtobuf(pb services.TokenKycStatus) *bool {
	var kycStatus bool
	switch pb.Number() {
	case 1:
		kycStatus = true
	case 2:
		kycStatus = false
	default:
		return nil
	}
	return &kycStatus
}

func _PauseStatusFromProtobuf(pb services.TokenPauseStatus) *bool {
	var pauseStatus bool
	switch pb.Number() {
	case 1:
		pauseStatus = true
	case 2:
		pauseStatus = false
	default:
		return nil
	}
	return &pauseStatus
}

// FreezeStatusToProtobuf converts the TokenInfo's DefaultFreezeStatus to a protobuf TokenFreezeStatus
func (tokenInfo *TokenInfo) FreezeStatusToProtobuf() *services.TokenFreezeStatus {
	var freezeStatus services.TokenFreezeStatus

	if tokenInfo.DefaultFreezeStatus == nil {
		freezeStatus = services.TokenFreezeStatus_FreezeNotApplicable
		return &freezeStatus
	}

	switch *tokenInfo.DefaultFreezeStatus {
	case true:
		freezeStatus = services.TokenFreezeStatus_Frozen
	case false:
		freezeStatus = services.TokenFreezeStatus_Unfrozen
	default:
		freezeStatus = services.TokenFreezeStatus_FreezeNotApplicable
	}

	return &freezeStatus
}

// KycStatusToProtobuf converts the TokenInfo's DefaultKycStatus to a protobuf TokenKycStatus
func (tokenInfo *TokenInfo) KycStatusToProtobuf() *services.TokenKycStatus {
	var kycStatus services.TokenKycStatus

	if tokenInfo.DefaultKycStatus == nil {
		kycStatus = services.TokenKycStatus_KycNotApplicable
		return &kycStatus
	}

	switch *tokenInfo.DefaultKycStatus {
	case true:
		kycStatus = services.TokenKycStatus_Granted
	case false:
		kycStatus = services.TokenKycStatus_Revoked
	default:
		kycStatus = services.TokenKycStatus_KycNotApplicable
	}

	return &kycStatus
}

// PauseStatusToProtobuf converts the TokenInfo's PauseStatus to a protobuf TokenPauseStatus
func (tokenInfo *TokenInfo) PauseStatusToProtobuf() *services.TokenPauseStatus {
	var pauseStatus services.TokenPauseStatus

	if tokenInfo.PauseStatus == nil {
		pauseStatus = services.TokenPauseStatus_PauseNotApplicable
		return &pauseStatus
	}

	switch *tokenInfo.PauseStatus {
	case true:
		pauseStatus = services.TokenPauseStatus_Paused
	case false:
		pauseStatus = services.TokenPauseStatus_Unpaused
	default:
		pauseStatus = services.TokenPauseStatus_PauseNotApplicable
	}

	return &pauseStatus
}

func _TokenInfoFromProtobuf(pb *services.TokenInfo) TokenInfo {
	if pb == nil {
		return TokenInfo{}
	}

	var adminKey Key
	if pb.AdminKey != nil {
		adminKey, _ = _KeyFromProtobuf(pb.AdminKey)
	}

	var kycKey Key
	if pb.KycKey != nil {
		kycKey, _ = _KeyFromProtobuf(pb.KycKey)
	}

	var freezeKey Key
	if pb.FreezeKey != nil {
		freezeKey, _ = _KeyFromProtobuf(pb.FreezeKey)
	}

	var wipeKey Key
	if pb.WipeKey != nil {
		wipeKey, _ = _KeyFromProtobuf(pb.WipeKey)
	}

	var supplyKey Key
	if pb.SupplyKey != nil {
		supplyKey, _ = _KeyFromProtobuf(pb.SupplyKey)
	}

	var pauseKey Key
	if pb.PauseKey != nil {
		pauseKey, _ = _KeyFromProtobuf(pb.PauseKey)
	}

	var metadataKey Key
	if pb.MetadataKey != nil {
		metadataKey, _ = _KeyFromProtobuf(pb.MetadataKey)
	}

	var feeScheduleKey Key
	if pb.FeeScheduleKey != nil {
		feeScheduleKey, _ = _KeyFromProtobuf(pb.FeeScheduleKey)
	}

	var autoRenewPeriod time.Duration
	if pb.AutoRenewPeriod != nil {
		autoRenewPeriod = time.Duration(pb.GetAutoRenewPeriod().Seconds * time.Second.Nanoseconds())
	}

	var expirationTime time.Time
	if pb.Expiry != nil {
		expirationTime = time.Unix(pb.GetExpiry().Seconds, int64(pb.GetExpiry().Nanos))
	}

	var autoRenewAccountID AccountID
	if pb.AutoRenewAccount != nil {
		autoRenewAccountID = *_AccountIDFromProtobuf(pb.AutoRenewAccount)
	}

	var treasury AccountID
	if pb.Treasury != nil {
		treasury = *_AccountIDFromProtobuf(pb.Treasury)
	}

	customFees := make([]Fee, 0)
	if pb.CustomFees != nil {
		for _, custom := range pb.CustomFees {
			customFees = append(customFees, _CustomFeeFromProtobuf(custom))
		}
	}

	tokenID := TokenID{}
	if pb.TokenId != nil {
		tokenID = *_TokenIDFromProtobuf(pb.TokenId)
	}

	var metadata []byte
	if pb.Metadata != nil {
		metadata = pb.Metadata
	}

	return TokenInfo{
		TokenID:             tokenID,
		Name:                pb.Name,
		Symbol:              pb.Symbol,
		Decimals:            pb.Decimals,
		TotalSupply:         pb.TotalSupply,
		Treasury:            treasury,
		AdminKey:            adminKey,
		KycKey:              kycKey,
		FreezeKey:           freezeKey,
		WipeKey:             wipeKey,
		SupplyKey:           supplyKey,
		DefaultFreezeStatus: _FreezeStatusFromProtobuf(pb.DefaultFreezeStatus),
		DefaultKycStatus:    _KycStatusFromProtobuf(pb.DefaultKycStatus),
		Deleted:             pb.Deleted,
		AutoRenewPeriod:     &autoRenewPeriod,
		AutoRenewAccountID:  autoRenewAccountID,
		ExpirationTime:      &expirationTime,
		TokenMemo:           pb.Memo,
		TokenType:           TokenType(pb.TokenType),
		SupplyType:          TokenSupplyType(pb.SupplyType),
		MaxSupply:           pb.MaxSupply,
		FeeScheduleKey:      feeScheduleKey,
		CustomFees:          customFees,
		PauseKey:            pauseKey,
		MetadataKey:         metadataKey,
		Metadata:            metadata,
		PauseStatus:         _PauseStatusFromProtobuf(pb.PauseStatus),
		LedgerID:            LedgerID{pb.LedgerId},
	}
}

func (tokenInfo *TokenInfo) _ToProtobuf() *services.TokenInfo {
	var adminKey *services.Key
	if tokenInfo.AdminKey != nil {
		adminKey = tokenInfo.AdminKey._ToProtoKey()
	}

	var kycKey *services.Key
	if tokenInfo.KycKey != nil {
		kycKey = tokenInfo.KycKey._ToProtoKey()
	}

	var freezeKey *services.Key
	if tokenInfo.FreezeKey != nil {
		freezeKey = tokenInfo.FreezeKey._ToProtoKey()
	}

	var wipeKey *services.Key
	if tokenInfo.WipeKey != nil {
		wipeKey = tokenInfo.WipeKey._ToProtoKey()
	}

	var supplyKey *services.Key
	if tokenInfo.SupplyKey != nil {
		supplyKey = tokenInfo.SupplyKey._ToProtoKey()
	}

	var pauseKey *services.Key
	if tokenInfo.PauseKey != nil {
		pauseKey = tokenInfo.PauseKey._ToProtoKey()
	}

	var metadataKey *services.Key
	if tokenInfo.MetadataKey != nil {
		metadataKey = tokenInfo.MetadataKey._ToProtoKey()
	}

	var feeScheduleKey *services.Key
	if tokenInfo.FeeScheduleKey != nil {
		feeScheduleKey = tokenInfo.FeeScheduleKey._ToProtoKey()
	}

	var autoRenewPeriod *services.Duration
	if tokenInfo.AutoRenewPeriod != nil {
		autoRenewPeriod = _DurationToProtobuf(*tokenInfo.AutoRenewPeriod)
	}

	var expirationTime *services.Timestamp
	if tokenInfo.ExpirationTime != nil {
		expirationTime = _TimeToProtobuf(*tokenInfo.ExpirationTime)
	}

	customFees := make([]*services.CustomFee, 0)
	if tokenInfo.CustomFees != nil {
		for _, customFee := range tokenInfo.CustomFees {
			customFees = append(customFees, customFee._ToProtobuf())
		}
	}

	var metadata []byte
	if tokenInfo.Metadata != nil {
		metadata = tokenInfo.Metadata
	}

	return &services.TokenInfo{
		TokenId:             tokenInfo.TokenID._ToProtobuf(),
		Name:                tokenInfo.Name,
		Symbol:              tokenInfo.Symbol,
		Decimals:            tokenInfo.Decimals,
		TotalSupply:         tokenInfo.TotalSupply,
		Treasury:            tokenInfo.Treasury._ToProtobuf(),
		AdminKey:            adminKey,
		KycKey:              kycKey,
		FreezeKey:           freezeKey,
		WipeKey:             wipeKey,
		SupplyKey:           supplyKey,
		DefaultFreezeStatus: *tokenInfo.FreezeStatusToProtobuf(),
		DefaultKycStatus:    *tokenInfo.KycStatusToProtobuf(),
		Deleted:             tokenInfo.Deleted,
		AutoRenewAccount:    tokenInfo.AutoRenewAccountID._ToProtobuf(),
		AutoRenewPeriod:     autoRenewPeriod,
		Expiry:              expirationTime,
		Memo:                tokenInfo.TokenMemo,
		TokenType:           services.TokenType(tokenInfo.TokenType),
		SupplyType:          services.TokenSupplyType(tokenInfo.SupplyType),
		MaxSupply:           tokenInfo.MaxSupply,
		FeeScheduleKey:      feeScheduleKey,
		CustomFees:          customFees,
		PauseKey:            pauseKey,
		MetadataKey:         metadataKey,
		Metadata:            metadata,
		PauseStatus:         *tokenInfo.PauseStatusToProtobuf(),
		LedgerId:            tokenInfo.LedgerID.ToBytes(),
	}
}

// ToBytes returns the byte representation of the TokenInfo
func (tokenInfo TokenInfo) ToBytes() []byte {
	data, err := protobuf.Marshal(tokenInfo._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TokenInfoFromBytes returns a TokenInfo struct from a raw protobuf byte array
func TokenInfoFromBytes(data []byte) (TokenInfo, error) {
	if data == nil {
		return TokenInfo{}, errByteArrayNull
	}
	pb := services.TokenInfo{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TokenInfo{}, err
	}

	return _TokenInfoFromProtobuf(&pb), nil
}
// Filename: token_info_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenInfoQuery Used get information about Token instance
type TokenInfoQuery struct {
	Query
	tokenID *TokenID
}

// NewTokenInfoQuery creates a TokenInfoQuery which is used get information about Token instance
func NewTokenInfoQuery() *TokenInfoQuery {
	header := services.QueryHeader{}
	return &TokenInfoQuery{
		Query: _NewQuery(true, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *TokenInfoQuery) SetGrpcDeadline(deadline *time.Duration) *TokenInfoQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetTokenID Sets the topic to retrieve info about (the parameters and running state of).
func (q *TokenInfoQuery) SetTokenID(tokenID TokenID) *TokenInfoQuery {
	q.tokenID = &tokenID
	return q
}

// GetTokenID returns the TokenID for this TokenInfoQuery
func (q *TokenInfoQuery) GetTokenID() TokenID {
	if q.tokenID == nil {
		return TokenID{}
	}

	return *q.tokenID
}

func (q *TokenInfoQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the TopicInfoQuery using the provided client
func (q *TokenInfoQuery) Execute(client *Client) (TokenInfo, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return TokenInfo{}, err
	}

	info := _TokenInfoFromProtobuf(resp.GetTokenGetInfo().TokenInfo)

	return info, nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *TokenInfoQuery) SetMaxQueryPayment(maxPayment Hbar) *TokenInfoQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *TokenInfoQuery) SetQueryPayment(paymentAmount Hbar) *TokenInfoQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenInfoQuery.
func (q *TokenInfoQuery) SetNodeAccountIDs(accountID []AccountID) *TokenInfoQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *TokenInfoQuery) SetMaxRetry(count int) *TokenInfoQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *TokenInfoQuery) SetMaxBackoff(max time.Duration) *TokenInfoQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *TokenInfoQuery) SetMinBackoff(min time.Duration) *TokenInfoQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *TokenInfoQuery) SetPaymentTransactionID(transactionID TransactionID) *TokenInfoQuery {
	q.paymentTransactionIDs._Clear()._Push(transactionID)._SetLocked(true)
	return q
}

func (q *TokenInfoQuery) SetLogLevel(level LogLevel) *TokenInfoQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *TokenInfoQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetToken().GetTokenInfo,
	}
}

func (q *TokenInfoQuery) getName() string {
	return "TokenInfoQuery"
}

func (q *TokenInfoQuery) buildQuery() *services.Query {
	body := &services.TokenGetInfoQuery{
		Header: q.pbHeader,
	}
	if q.tokenID != nil {
		body.Token = q.tokenID._ToProtobuf()
	}

	return &services.Query{
		Query: &services.Query_TokenGetInfo{
			TokenGetInfo: body,
		},
	}
}

func (q *TokenInfoQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.tokenID != nil {
		if err := q.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *TokenInfoQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetTokenGetInfo()
}
// Filename: token_info_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenInfoQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetTokenMetadata([]byte{1, 2, 3}).
			SetKycKey(env.Client.GetOperatorPublicKey()).
			SetDecimals(3)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetMaxQueryPayment(NewHbar(2)).
		SetTokenID(tokenID).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, info.TokenID, tokenID)
	assert.Equal(t, info.Name, "ffff")
	assert.Equal(t, info.Symbol, "F")
	assert.Equal(t, info.Decimals, uint32(3))
	assert.Equal(t, info.Treasury, env.Client.GetOperatorAccountID())
	assert.NotNil(t, info.AdminKey)
	assert.NotNil(t, info.KycKey)
	assert.NotNil(t, info.FreezeKey)
	assert.NotNil(t, info.WipeKey)
	assert.NotNil(t, info.SupplyKey)
	assert.Equal(t, info.AdminKey.String(), env.Client.GetOperatorPublicKey().String())
	assert.Equal(t, info.KycKey.String(), env.Client.GetOperatorPublicKey().String())
	assert.Equal(t, info.FreezeKey.String(), env.Client.GetOperatorPublicKey().String())
	assert.Equal(t, info.WipeKey.String(), env.Client.GetOperatorPublicKey().String())
	assert.Equal(t, info.SupplyKey.String(), env.Client.GetOperatorPublicKey().String())
	assert.Equal(t, info.MetadataKey.String(), env.Client.GetOperatorPublicKey().String())
	assert.Equal(t, info.Metadata, []byte{1, 2, 3})
	assert.False(t, *info.DefaultFreezeStatus)
	assert.False(t, *info.DefaultKycStatus)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenInfoQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	infoQuery := NewTokenInfoQuery().
		SetMaxQueryPayment(NewHbar(1)).
		SetTokenID(tokenID)

	cost, err := infoQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = infoQuery.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenInfoQuerySetBigMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	infoQuery := NewTokenInfoQuery().
		SetMaxQueryPayment(NewHbar(1000000)).
		SetTokenID(tokenID)

	cost, err := infoQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = infoQuery.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenInfoQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	infoQuery := NewTokenInfoQuery().
		SetMaxQueryPayment(HbarFromTinybar(1)).
		SetTokenID(tokenID)

	cost, err := infoQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = infoQuery.Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "cost of TokenInfoQuery ("+cost.String()+") without explicit payment is greater than the max query payment of 1 tℏ", err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenInfoQueryInsufficientCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	infoQuery := NewTokenInfoQuery().
		SetMaxQueryPayment(NewHbar(1)).
		SetTokenID(tokenID)

	_, err = infoQuery.GetCost(env.Client)
	require.NoError(t, err)

	_, err = infoQuery.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_TX_FEE", err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenInfoQueryNoPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetDecimals(3).
			SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetQueryPayment(NewHbar(1)).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, info.TokenID, tokenID)
	assert.Equal(t, info.Name, "ffff")
	assert.Equal(t, info.Symbol, "F")
	assert.Equal(t, info.Decimals, uint32(3))
	assert.Equal(t, info.Treasury, env.Client.GetOperatorAccountID())
	assert.False(t, *info.DefaultFreezeStatus)
	assert.False(t, *info.DefaultKycStatus)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenInfoQueryNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewTokenInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_TOKEN_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: token_info_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/base64"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenInfoQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenInfo := NewTokenInfoQuery().
		SetTokenID(tokenID)

	err = tokenInfo.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenInfoQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenInfo := NewTokenInfoQuery().
		SetTokenID(tokenID)

	err = tokenInfo.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenInfoFromBytesBadBytes(t *testing.T) {
	t.Parallel()

	bytes, err := base64.StdEncoding.DecodeString("tfhyY++/Q4BycortAgD4cmMKACB/")
	require.NoError(t, err)

	_, err = TokenInfoFromBytes(bytes)
	require.NoError(t, err)
}

func TestUnitTokenInfoFromBytesEmptyBytes(t *testing.T) {
	t.Parallel()

	_, err := TokenInfoFromBytes([]byte{})
	require.NoError(t, err)
}

func TestUnitTokenInfoQueryGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	deadline := time.Duration(time.Minute)
	accountId := AccountID{Account: 123}
	validStart := time.Now().Add(10 * time.Minute)
	balance := NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}}).
		SetMaxRetry(3).
		SetMinBackoff(300 * time.Millisecond).
		SetMaxBackoff(10 * time.Second).
		SetPaymentTransactionID(TransactionID{AccountID: &accountId, ValidStart: &validStart}).
		SetMaxQueryPayment(NewHbar(500)).
		SetGrpcDeadline(&deadline)

	require.Equal(t, tokenID, balance.GetTokenID())
	require.Equal(t, []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}, balance.GetNodeAccountIDs())
	require.Equal(t, 300*time.Millisecond, balance.GetMinBackoff())
	require.Equal(t, 10*time.Second, balance.GetMaxBackoff())
	require.Equal(t, 3, balance.GetMaxRetryCount())
	require.Equal(t, TransactionID{AccountID: &accountId, ValidStart: &validStart}, balance.GetPaymentTransactionID())
	require.Equal(t, HbarFromTinybar(25), balance.GetQueryPayment())
	require.Equal(t, NewHbar(500), balance.GetMaxQueryPayment())
}

func TestUnitTokenInfoQueryNothingSet(t *testing.T) {
	t.Parallel()

	balance := NewTokenInfoQuery()

	require.Equal(t, TokenID{}, balance.GetTokenID())
	require.Equal(t, []AccountID{}, balance.GetNodeAccountIDs())
	require.Equal(t, 250*time.Millisecond, balance.GetMinBackoff())
	require.Equal(t, 8*time.Second, balance.GetMaxBackoff())
	require.Equal(t, 10, balance.GetMaxRetryCount())
	require.Equal(t, TransactionID{}, balance.GetPaymentTransactionID())
	require.Equal(t, Hbar{}, balance.GetQueryPayment())
	require.Equal(t, Hbar{}, balance.GetMaxQueryPayment())
}

func TestUnitTokenInfoQueryCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	deadline := time.Second * 3
	token := TokenID{Token: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewTokenInfoQuery().
		SetTokenID(token).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3)).
		SetGrpcDeadline(&deadline)

	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)

	require.Equal(t, nodeAccountID, query.GetNodeAccountIDs())
	require.Equal(t, time.Second*30, query.GetMaxBackoff())
	require.Equal(t, time.Second*10, query.GetMinBackoff())
	require.Equal(t, token, query.GetTokenID())
	require.Equal(t, NewHbar(3), query.GetQueryPayment())
	require.Equal(t, NewHbar(23), query.GetMaxQueryPayment())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}

func TestUnitTokenInfoQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_TokenGetInfo{
				TokenGetInfo: &services.TokenGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TokenGetInfo{
				TokenGetInfo: &services.TokenGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TokenGetInfo{
				TokenGetInfo: &services.TokenGetInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					TokenInfo: &services.TokenInfo{
						TokenId:             nil,
						Name:                "",
						Symbol:              "",
						Decimals:            0,
						TotalSupply:         0,
						Treasury:            nil,
						AdminKey:            nil,
						KycKey:              nil,
						FreezeKey:           nil,
						WipeKey:             nil,
						SupplyKey:           nil,
						DefaultFreezeStatus: 0,
						DefaultKycStatus:    0,
						Deleted:             false,
						AutoRenewAccount:    nil,
						AutoRenewPeriod:     nil,
						Expiry:              nil,
						Memo:                "",
						TokenType:           0,
						SupplyType:          0,
						MaxSupply:           0,
						FeeScheduleKey:      nil,
						CustomFees:          nil,
						PauseKey:            nil,
						PauseStatus:         0,
						MetadataKey:         nil,
						LedgerId:            nil,
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	query := NewTokenInfoQuery().
		SetTokenID(TokenID{Token: 3}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMaxQueryPayment(NewHbar(1))

	cost, err := query.GetCost(client)
	require.NoError(t, err)
	require.Equal(t, HbarFromTinybar(2), cost)
	_, err = query.Execute(client)
	require.NoError(t, err)
}
// Filename: token_info_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestUnitTokenInfo_Protobuf(t *testing.T) {
	t.Parallel()

	tokenInfo := setupTokenInfo()
	pb := tokenInfo._ToProtobuf()
	actual := _TokenInfoFromProtobuf(pb)

	assertTokenInfo(t, tokenInfo, actual)
}

func TestUnitTokenInfo_Bytes(t *testing.T) {
	t.Parallel()

	tokenInfo := setupTokenInfo()
	pb := tokenInfo.ToBytes()
	actual, _ := TokenInfoFromBytes(pb)

	assertTokenInfo(t, tokenInfo, actual)
}

func TestUnitTokenInfo_ProtobufCoverage(t *testing.T) {
	t.Parallel()

	tokenInfo := setupTokenInfo()

	_true := true
	_false := false

	tokenInfo.DefaultKycStatus = &_false
	tokenInfo.DefaultFreezeStatus = &_false
	tokenInfo.PauseStatus = &_true

	pb := tokenInfo._ToProtobuf()
	actual := _TokenInfoFromProtobuf(pb)

	assertTokenInfo(t, tokenInfo, actual)
}

func setupTokenInfo() TokenInfo {
	adminPK, _ := PrivateKeyGenerate()
	adminPubK := adminPK.PublicKey()

	kycPK, _ := PrivateKeyGenerate()
	kycPubK := kycPK.PublicKey()

	freezePK, _ := PrivateKeyGenerate()
	freezePubK := freezePK.PublicKey()

	wipePK, _ := PrivateKeyGenerate()
	wipePubK := wipePK.PublicKey()

	supplyPK, _ := PrivateKeyGenerate()
	supplyPubK := supplyPK.PublicKey()

	pausePK, _ := PrivateKeyGenerate()
	pausePubK := pausePK.PublicKey()

	metadataPK, _ := PrivateKeyGenerate()
	metadataPubK := metadataPK.PublicKey()

	feeSchedulePK, _ := PrivateKeyGenerate()
	feeSchedulePubK := feeSchedulePK.PublicKey()

	accId, _ := AccountIDFromString("0.0.1111")

	_true := true
	_false := false
	ledgerId := NewLedgerIDTestnet()
	timeDuration := time.Duration(2230000) * time.Second

	timeTime := time.Unix(1230000, 0)
	tokenId, _ := TokenIDFromString("0.0.123")
	feeCollectorAccountId, _ := AccountIDFromString("0.0.123")

	customFees := []Fee{
		NewCustomFixedFee().
			SetAmount(1).
			SetDenominatingTokenID(tokenId).
			SetFeeCollectorAccountID(feeCollectorAccountId),
	}

	return TokenInfo{
		TokenID:             tokenId,
		Name:                "Test Token",
		Symbol:              "TST",
		Decimals:            8,
		TotalSupply:         10000,
		Treasury:            accId,
		AdminKey:            adminPubK,
		KycKey:              kycPubK,
		FreezeKey:           freezePubK,
		WipeKey:             wipePubK,
		SupplyKey:           supplyPubK,
		DefaultFreezeStatus: &_true,
		DefaultKycStatus:    &_true,
		Deleted:             false,
		AutoRenewPeriod:     &timeDuration,
		AutoRenewAccountID:  accId,
		ExpirationTime:      &timeTime,
		TokenMemo:           "test-memo",
		TokenType:           TokenTypeFungibleCommon,
		SupplyType:          TokenSupplyTypeInfinite,
		MaxSupply:           10000000,
		FeeScheduleKey:      feeSchedulePubK,
		CustomFees:          customFees,
		PauseKey:            pausePubK,
		MetadataKey:         metadataPubK,
		Metadata:            testMetadata,
		PauseStatus:         &_false,
		LedgerID:            *ledgerId,
	}
}

func assertTokenInfo(t assert.TestingT, tokenInfo TokenInfo, actual TokenInfo) {
	assert.Equal(t, tokenInfo.TokenID, actual.TokenID)
	assert.Equal(t, tokenInfo.Name, actual.Name)
	assert.Equal(t, tokenInfo.Symbol, actual.Symbol)
	assert.Equal(t, tokenInfo.Decimals, actual.Decimals)
	assert.Equal(t, tokenInfo.TotalSupply, actual.TotalSupply)
	assert.Equal(t, tokenInfo.Treasury, actual.Treasury)
	assert.Equal(t, tokenInfo.AdminKey, actual.AdminKey)
	assert.Equal(t, tokenInfo.KycKey, actual.KycKey)
	assert.Equal(t, tokenInfo.FreezeKey, actual.FreezeKey)
	assert.Equal(t, tokenInfo.WipeKey, actual.WipeKey)
	assert.Equal(t, tokenInfo.SupplyKey, actual.SupplyKey)
	assert.Equal(t, tokenInfo.DefaultFreezeStatus, actual.DefaultFreezeStatus)
	assert.Equal(t, tokenInfo.DefaultKycStatus, actual.DefaultKycStatus)
	assert.Equal(t, tokenInfo.Deleted, actual.Deleted)
	assert.Equal(t, tokenInfo.AutoRenewPeriod, actual.AutoRenewPeriod)
	assert.Equal(t, tokenInfo.AutoRenewAccountID, actual.AutoRenewAccountID)
	assert.Equal(t, tokenInfo.ExpirationTime, actual.ExpirationTime)
	assert.Equal(t, tokenInfo.TokenMemo, actual.TokenMemo)
	assert.Equal(t, tokenInfo.TokenType, actual.TokenType)
	assert.Equal(t, tokenInfo.SupplyType, actual.SupplyType)
	assert.Equal(t, tokenInfo.MaxSupply, actual.MaxSupply)
	assert.Equal(t, tokenInfo.FeeScheduleKey, actual.FeeScheduleKey)
	assert.Equal(t, tokenInfo.PauseKey, actual.PauseKey)
	assert.Equal(t, tokenInfo.MetadataKey, actual.MetadataKey)
	assert.Equal(t, tokenInfo.Metadata, actual.Metadata)
	assert.Equal(t, tokenInfo.PauseStatus, actual.PauseStatus)
	assert.Equal(t, tokenInfo.LedgerID, actual.LedgerID)
}
// Filename: token_mint_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenMintTransaction
// Mints tokens from the Token's treasury Account. If no Supply Key is defined, the transaction
// will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
// The operation decreases the Total Supply of the Token. Total supply cannot go below zero.
// The amount provided must be in the lowest denomination possible. Example:
// Token A has 2 decimals. In order to mint 100 tokens, one must provide amount of 10000. In order
// to mint 100.55 tokens, one must provide amount of 10055.
type TokenMintTransaction struct {
	Transaction
	tokenID *TokenID
	amount  uint64
	meta    [][]byte
}

// NewTokenMintTransaction creates TokenMintTransaction which
// mints tokens from the Token's treasury Account. If no Supply Key is defined, the transaction
// will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
// The operation decreases the Total Supply of the Token. Total supply cannot go below zero.
// The amount provided must be in the lowest denomination possible. Example:
// Token A has 2 decimals. In order to mint 100 tokens, one must provide amount of 10000. In order
// to mint 100.55 tokens, one must provide amount of 10055.
func NewTokenMintTransaction() *TokenMintTransaction {
	tx := TokenMintTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenMintTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenMintTransaction {
	return &TokenMintTransaction{
		Transaction: tx,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenMint().GetToken()),
		amount:      pb.GetTokenMint().GetAmount(),
		meta:        pb.GetTokenMint().GetMetadata(),
	}
}

// SetTokenID Sets the token for which to mint tokens. If token does not exist, transaction results in
// INVALID_TOKEN_ID
func (tx *TokenMintTransaction) SetTokenID(tokenID TokenID) *TokenMintTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the TokenID for this TokenMintTransaction
func (tx *TokenMintTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// SetAmount Sets the amount to mint from the Treasury Account. Amount must be a positive non-zero number, not
// bigger than the token balance of the treasury account (0; balance], represented in the lowest
// denomination.
func (tx *TokenMintTransaction) SetAmount(amount uint64) *TokenMintTransaction {
	tx._RequireNotFrozen()
	tx.amount = amount
	return tx
}

// GetAmount returns the amount to mint from the Treasury Account
func (tx *TokenMintTransaction) GetAmount() uint64 {
	return tx.amount
}

// SetMetadatas
// Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.
// Maximum allowed size of each metadata is 100 bytes
func (tx *TokenMintTransaction) SetMetadatas(meta [][]byte) *TokenMintTransaction {
	tx._RequireNotFrozen()
	tx.meta = meta
	return tx
}

// SetMetadata
// Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.
// Maximum allowed size of each metadata is 100 bytes
func (tx *TokenMintTransaction) SetMetadata(meta []byte) *TokenMintTransaction {
	tx._RequireNotFrozen()
	if tx.meta == nil {
		tx.meta = make([][]byte, 0)
	}
	tx.meta = append(tx.meta, [][]byte{meta}...)
	return tx
}

// GetMetadatas returns the metadata that are being created.
func (tx *TokenMintTransaction) GetMetadatas() [][]byte {
	return tx.meta
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenMintTransaction) Sign(privateKey PrivateKey) *TokenMintTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenMintTransaction) SignWithOperator(client *Client) (*TokenMintTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenMintTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenMintTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenMintTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenMintTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenMintTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenMintTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenMintTransaction) Freeze() (*TokenMintTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenMintTransaction) FreezeWith(client *Client) (*TokenMintTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenMintTransaction.
func (tx *TokenMintTransaction) SetMaxTransactionFee(fee Hbar) *TokenMintTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenMintTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenMintTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenMintTransaction.
func (tx *TokenMintTransaction) SetTransactionMemo(memo string) *TokenMintTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenMintTransaction.
func (tx *TokenMintTransaction) SetTransactionValidDuration(duration time.Duration) *TokenMintTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenMintTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenMintTransaction.
func (tx *TokenMintTransaction) SetTransactionID(transactionID TransactionID) *TokenMintTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenMintTransaction.
func (tx *TokenMintTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenMintTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenMintTransaction) SetMaxRetry(count int) *TokenMintTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenMintTransaction) SetMaxBackoff(max time.Duration) *TokenMintTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenMintTransaction) SetMinBackoff(min time.Duration) *TokenMintTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenMintTransaction) SetLogLevel(level LogLevel) *TokenMintTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenMintTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenMintTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenMintTransaction) getName() string {
	return "TokenMintTransaction"
}

func (tx *TokenMintTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenMintTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenMint{
			TokenMint: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenMintTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenMint{
			TokenMint: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenMintTransaction) buildProtoBody() *services.TokenMintTransactionBody {
	body := &services.TokenMintTransactionBody{
		Amount: tx.amount,
	}

	if tx.meta != nil {
		body.Metadata = tx.meta
	}

	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	return body
}

func (tx *TokenMintTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().MintToken,
	}
}
func (tx *TokenMintTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_mint_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenMintTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	resp, err = NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAmount(10).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, uint64(1000010), info.TotalSupply)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenMintTransactionNoAmount(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	_, err = NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		Execute(env.Client)
	// It is now possible to perform Zero Token Operations https://hips.hedera.com/hip/hip-564
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenMintTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	resp2, err := NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAmount(10).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_TOKEN_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenMintTransactionMaxReached(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetDecimals(3).
			SetInitialSupply(10).
			SetSupplyType(TokenSupplyTypeFinite).
			SetMaxSupply(30)
	})
	require.NoError(t, err)

	resp, err = NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAmount(10000000).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: TOKEN_MAX_SUPPLY_REACHED", err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenMintTransactionMetadataTooLong(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	metaData := make([]byte, 50, 101)

	mint, err := NewTokenMintTransaction().
		SetTokenID(tokenID).
		SetMetadata(metaData).
		Execute(env.Client)
	require.NoError(t, err)

	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftID := tokenID.Nft(mintReceipt.SerialNumbers[0])

	nftID.SerialNumber = 3

	_, err = NewTokenNftInfoQuery().
		SetNftID(nftID).
		Execute(env.Client)
	assert.Error(t, err)
}

func DisabledTestIntegrationTokenMintTransactionInvalidMetadata(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	mint, err := NewTokenMintTransaction().
		SetTokenID(tokenID).
		SetAmount(1).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_TOKEN_MINT_METADATA", err.Error())
	}
}
// Filename: token_mint_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenMintTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenMint := NewTokenMintTransaction().
		SetTokenID(tokenID)

	err = tokenMint.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenMintTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenMint := NewTokenMintTransaction().
		SetTokenID(tokenID)

	err = tokenMint.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenMintTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenMintTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAmount(123).
		SetMetadata([]byte{123, 123}).
		SetMetadatas([][]byte{{123, 123}, {13, 13}}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAmount()
	transaction.GetMetadatas()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenMintTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenMintTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAmount()
	transaction.GetMetadatas()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenMintTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenMintTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAmount(323).
		SetMetadatas([][]byte{{50}, {50}}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenMint()
	require.Equal(t, proto.Token.String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.Amount, uint64(323))
	require.Equal(t, proto.Metadata, [][]byte{{50}, {50}})
}

func TestUnitTokenMintTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenMintTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(token).
		SetMetadata([]byte{1}).
		SetMetadatas([][]byte{{1, 0}}).
		SetAmount(5).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenID()
	transaction.GetMetadatas()
	transaction.GetAmount()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenMintTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenMintTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}

	freez, err := NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		SetMetadata([]byte{1}).
		SetAmount(5).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: token_nft_allowance.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

// TokenNftAllowance is a struct to encapsulate the nft methods for token allowance's.
type TokenNftAllowance struct {
	TokenID           *TokenID
	SpenderAccountID  *AccountID
	OwnerAccountID    *AccountID
	SerialNumbers     []int64
	AllSerials        bool
	DelegatingSpender *AccountID
}

// NewTokenNftAllowance creates a TokenNftAllowance delegate for the given tokenID, owner, spender, serialNumbers, approvedForAll, and delegatingSpender
func NewTokenNftAllowance(tokenID TokenID, owner AccountID, spender AccountID, serialNumbers []int64, approvedForAll bool, delegatingSpender AccountID) TokenNftAllowance {
	return TokenNftAllowance{
		TokenID:           &tokenID,
		SpenderAccountID:  &spender,
		OwnerAccountID:    &owner,
		SerialNumbers:     serialNumbers,
		AllSerials:        approvedForAll,
		DelegatingSpender: &delegatingSpender,
	}
}

func _TokenNftAllowanceFromProtobuf(pb *services.NftAllowance) TokenNftAllowance {
	body := TokenNftAllowance{
		AllSerials:    pb.ApprovedForAll.GetValue(),
		SerialNumbers: pb.SerialNumbers,
	}

	if pb.TokenId != nil {
		body.TokenID = _TokenIDFromProtobuf(pb.TokenId)
	}

	if pb.Spender != nil {
		body.SpenderAccountID = _AccountIDFromProtobuf(pb.Spender)
	}

	if pb.Owner != nil {
		body.OwnerAccountID = _AccountIDFromProtobuf(pb.Owner)
	}

	if pb.DelegatingSpender != nil {
		body.DelegatingSpender = _AccountIDFromProtobuf(pb.DelegatingSpender)
	}

	return body
}

func _TokenNftWipeAllowanceProtobuf(pb *services.NftRemoveAllowance) TokenNftAllowance {
	body := TokenNftAllowance{
		SerialNumbers: pb.SerialNumbers,
	}

	if pb.TokenId != nil {
		body.TokenID = _TokenIDFromProtobuf(pb.TokenId)
	}

	if pb.Owner != nil {
		body.SpenderAccountID = _AccountIDFromProtobuf(pb.Owner)
	}

	return body
}

func (approval *TokenNftAllowance) _ToProtobuf() *services.NftAllowance {
	body := &services.NftAllowance{
		ApprovedForAll: &wrapperspb.BoolValue{Value: approval.AllSerials},
		SerialNumbers:  approval.SerialNumbers,
	}

	if approval.SpenderAccountID != nil {
		body.Spender = approval.SpenderAccountID._ToProtobuf()
	}

	if approval.OwnerAccountID != nil {
		body.Owner = approval.OwnerAccountID._ToProtobuf()
	}

	if approval.TokenID != nil {
		body.TokenId = approval.TokenID._ToProtobuf()
	}

	if approval.DelegatingSpender != nil {
		body.DelegatingSpender = approval.DelegatingSpender._ToProtobuf()
	}

	return body
}

func (approval *TokenNftAllowance) _ToWipeProtobuf() *services.NftRemoveAllowance {
	body := &services.NftRemoveAllowance{
		SerialNumbers: approval.SerialNumbers,
	}

	if approval.OwnerAccountID != nil {
		body.Owner = approval.OwnerAccountID._ToProtobuf()
	}

	if approval.TokenID != nil {
		body.TokenId = approval.TokenID._ToProtobuf()
	}

	return body
}

// String returns a string representation of the TokenNftAllowance
func (approval *TokenNftAllowance) String() string {
	var owner string
	var spender string
	var token string
	var serials string

	if approval.OwnerAccountID != nil {
		owner = approval.OwnerAccountID.String()
	}

	if approval.SpenderAccountID != nil {
		spender = approval.SpenderAccountID.String()
	}

	if approval.TokenID != nil {
		token = approval.TokenID.String()
	}

	for _, serial := range approval.SerialNumbers {
		serials += fmt.Sprintf("%d, ", serial)
	}

	return fmt.Sprintf("OwnerAccountID: %s, SpenderAccountID: %s, TokenID: %s, Serials: %s, ApprovedForAll: %t", owner, spender, token, serials, approval.AllSerials)
}
// Filename: token_nft_allowance_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestIntegrationCantTransferOnBehalfOfSpenderWithoutAllowanceApproval(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	spenderKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	spenderCreate, err := NewAccountCreateTransaction().SetKey(spenderKey).SetInitialBalance(NewHbar(2)).Execute(env.Client)
	require.NoError(t, err)
	spenderReceipt, err := spenderCreate.SetValidateStatus(true).GetReceipt(env.Client)
	spenderAccountId := spenderReceipt.AccountID
	receiverKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	receiverCreate, err := NewAccountCreateTransaction().SetKey(receiverKey).SetInitialBalance(NewHbar(2)).SetMaxAutomaticTokenAssociations(10).Execute(env.Client)
	require.NoError(t, err)
	receiverReceipt, err := receiverCreate.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	receiverAccountId := receiverReceipt.AccountID
	tokenID, err := createNft(&env)
	require.NoError(t, err)
	frozenTxn, err := NewTokenAssociateTransaction().SetTokenIDs(tokenID).SetAccountID(*spenderAccountId).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTxn.Sign(spenderKey).Execute(env.Client)
	require.NoError(t, err)

	mint, err := NewTokenMintTransaction().
		SetTokenID(tokenID).
		SetMetadata([]byte{0x01}).
		Execute(env.Client)
	require.NoError(t, err)
	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	serials := mintReceipt.SerialNumbers
	nft1 := NftID{TokenID: tokenID, SerialNumber: serials[0]}
	onBehalfOfTxId := TransactionIDGenerate(*spenderAccountId)

	frozenTransfer, err := NewTransferTransaction().AddApprovedNftTransfer(nft1, env.OperatorID, *receiverAccountId, true).SetTransactionID(onBehalfOfTxId).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTransfer.Sign(spenderKey).Execute(env.Client)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.Error(t, err)
	require.Equal(t, "exceptional receipt status: SPENDER_DOES_NOT_HAVE_ALLOWANCE", err.Error())

}

func TestIntegrationCantTransferOnBehalfOfSpenderAfterRemovingTheAllowanceApproval(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	spenderKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	spenderCreate, err := NewAccountCreateTransaction().
		SetKey(spenderKey.PublicKey()).
		SetInitialBalance(NewHbar(2)).
		Execute(env.Client)
	require.NoError(t, err)
	spenderAccountReceipt, err := spenderCreate.SetValidateStatus(true).GetReceipt(env.Client)
	spenderAccountId := spenderAccountReceipt.AccountID
	receiverKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	receiverCreate, err := NewAccountCreateTransaction().
		SetKey(receiverKey.PublicKey()).
		SetInitialBalance(NewHbar(2)).
		Execute(env.Client)
	require.NoError(t, err)
	receiverAccountReceipt, err := receiverCreate.SetValidateStatus(true).GetReceipt(env.Client)
	receiverAccountId := receiverAccountReceipt.AccountID

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	frozenTx, err := NewTokenAssociateTransaction().SetTokenIDs(tokenID).SetAccountID(*spenderAccountId).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTx.Sign(spenderKey).Execute(env.Client)
	require.NoError(t, err)

	frozenTx, err = NewTokenAssociateTransaction().SetTokenIDs(tokenID).SetAccountID(*receiverAccountId).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTx.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)

	mint, err := NewTokenMintTransaction().SetTokenID(tokenID).SetMetadata([]byte{0x01}).SetMetadata([]byte{0x02}).Execute(env.Client)
	require.NoError(t, err)
	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	serials := mintReceipt.SerialNumbers
	nft1 := NftID{TokenID: tokenID, SerialNumber: serials[0]}
	nft2 := NftID{TokenID: tokenID, SerialNumber: serials[1]}
	approveTx, err := NewAccountAllowanceApproveTransaction().ApproveTokenNftAllowance(nft1, env.OperatorID, *spenderAccountId).
		ApproveTokenNftAllowance(nft2, env.OperatorID, *spenderAccountId).Execute(env.Client)
	require.NoError(t, err)
	_, err = approveTx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	deleteTx, err := NewAccountAllowanceDeleteTransaction().DeleteAllTokenNftAllowances(nft2, &env.OperatorID).Execute(env.Client)
	require.NoError(t, err)
	_, err = deleteTx.SetValidateStatus(true).GetReceipt(env.Client)

	onBehalfOfTxId := TransactionIDGenerate(*spenderAccountId)
	frozenTransfer, err := NewTransferTransaction().AddApprovedNftTransfer(nft1, env.OperatorID, *receiverAccountId, true).SetTransactionID(onBehalfOfTxId).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTransfer.Sign(spenderKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenNftInfoQuery().SetNftID(nft1).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, *receiverAccountId, info[0].AccountID)

	onBehalfOfTxId2 := TransactionIDGenerate(*spenderAccountId)
	frozenTransfer2, err := NewTransferTransaction().AddApprovedNftTransfer(nft2, env.OperatorID, *receiverAccountId, true).SetTransactionID(onBehalfOfTxId2).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err = frozenTransfer2.Sign(spenderKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.Error(t, err)
	require.Equal(t, "exceptional receipt status: SPENDER_DOES_NOT_HAVE_ALLOWANCE", err.Error())

}

func TestIntegrationCantRemoveSingleSerialNumberAllowanceWhenAllowanceIsForAllSerials(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	spenderKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	spenderCreate, err := NewAccountCreateTransaction().
		SetKey(spenderKey.PublicKey()).
		SetInitialBalance(NewHbar(2)).
		Execute(env.Client)
	require.NoError(t, err)
	spenderAccountReceipt, err := spenderCreate.SetValidateStatus(true).GetReceipt(env.Client)
	spenderAccountId := spenderAccountReceipt.AccountID

	receiverKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	receiverCreate, err := NewAccountCreateTransaction().
		SetKey(receiverKey.PublicKey()).
		SetInitialBalance(NewHbar(2)).
		Execute(env.Client)
	require.NoError(t, err)
	receiverAccountReceipt, err := receiverCreate.SetValidateStatus(true).GetReceipt(env.Client)
	receiverAccountId := receiverAccountReceipt.AccountID

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	frozenTxn, err := NewTokenAssociateTransaction().SetTokenIDs(tokenID).SetAccountID(*spenderAccountId).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTxn.Sign(spenderKey).Execute(env.Client)
	require.NoError(t, err)

	frozenTxn, err = NewTokenAssociateTransaction().SetTokenIDs(tokenID).SetAccountID(*receiverAccountId).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTxn.Sign(receiverKey).Execute(env.Client)
	require.NoError(t, err)

	mint, err := NewTokenMintTransaction().SetTokenID(tokenID).SetMetadata([]byte{0x01}).SetMetadata([]byte{0x02}).Execute(env.Client)
	require.NoError(t, err)
	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	serials := mintReceipt.SerialNumbers
	nft1 := NftID{TokenID: tokenID, SerialNumber: serials[0]}
	nft2 := NftID{TokenID: tokenID, SerialNumber: serials[1]}
	approveTx, err := NewAccountAllowanceApproveTransaction().ApproveTokenNftAllowanceAllSerials(nft1.TokenID, env.OperatorID, *spenderAccountId).Execute(env.Client)
	require.NoError(t, err)
	_, err = approveTx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	onBehalfOfTransactionId := TransactionIDGenerate(*spenderAccountId)
	frozenTransfer, err := NewTransferTransaction().AddApprovedNftTransfer(nft1, env.OperatorID, *receiverAccountId, true).SetTransactionID(onBehalfOfTransactionId).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTransfer.Sign(spenderKey).Execute(env.Client)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	deleteTx, err := NewAccountAllowanceDeleteTransaction().DeleteAllTokenNftAllowances(nft2, &env.OperatorID).Execute(env.Client)
	require.NoError(t, err)
	_, err = deleteTx.SetValidateStatus(true).GetReceipt(env.Client)

	onBehalfOfTransactionId2 := TransactionIDGenerate(*spenderAccountId)
	frozenTransfer2, err := NewTransferTransaction().AddApprovedNftTransfer(nft2, env.OperatorID, *receiverAccountId, true).SetTransactionID(onBehalfOfTransactionId2).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err = frozenTransfer2.Sign(spenderKey).Execute(env.Client)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)

	info, err := NewTokenNftInfoQuery().SetNftID(nft1).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, *receiverAccountId, info[0].AccountID)

	info2, err := NewTokenNftInfoQuery().SetNftID(nft2).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, *receiverAccountId, info2[0].AccountID)
}

func TestIntegrationAfterGivenAllowanceForAllSerialsCanGiveSingleSerialToOtherAccounts(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	spenderKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	spenderCreate, err := NewAccountCreateTransaction().
		SetKey(spenderKey.PublicKey()).
		SetInitialBalance(NewHbar(2)).
		Execute(env.Client)
	require.NoError(t, err)
	spenderAccountReceipt, err := spenderCreate.SetValidateStatus(true).GetReceipt(env.Client)
	spenderAccountId := spenderAccountReceipt.AccountID

	delegateSpenderKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	delegateSpenderCreate, err := NewAccountCreateTransaction().SetKey(delegateSpenderKey.PublicKey()).SetInitialBalance(NewHbar(2)).Execute(env.Client)
	require.NoError(t, err)
	delegateSpenderAccountReceipt, err := delegateSpenderCreate.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	delegateSpenderAccountId := delegateSpenderAccountReceipt.AccountID

	receiverKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	receiverCreate, err := NewAccountCreateTransaction().SetKey(receiverKey.PublicKey()).SetInitialBalance(NewHbar(2)).Execute(env.Client)
	require.NoError(t, err)
	receiverAccountReceipt, err := receiverCreate.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	receiverAccountId := receiverAccountReceipt.AccountID

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	frozenTx, err := NewTokenAssociateTransaction().SetTokenIDs(tokenID).SetAccountID(*spenderAccountId).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTx.Sign(spenderKey).Execute(env.Client)
	require.NoError(t, err)

	frozenTxn, err := NewTokenAssociateTransaction().SetTokenIDs(tokenID).SetAccountID(*receiverAccountId).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTxn.Sign(receiverKey).Execute(env.Client)

	mint, err := NewTokenMintTransaction().SetTokenID(tokenID).SetMetadata([]byte{0x01}).SetMetadata([]byte{0x02}).Execute(env.Client)
	require.NoError(t, err)
	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	serials := mintReceipt.SerialNumbers
	nft1 := NftID{TokenID: tokenID, SerialNumber: serials[0]}
	nft2 := NftID{TokenID: tokenID, SerialNumber: serials[1]}

	approveTx, err := NewAccountAllowanceApproveTransaction().
		ApproveTokenNftAllowanceAllSerials(tokenID, env.OperatorID, *spenderAccountId).Execute(env.Client)
	require.NoError(t, err)
	_, err = approveTx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	env.Client.SetOperator(*spenderAccountId, spenderKey)

	approveDelegateTx, err := NewAccountAllowanceApproveTransaction().
		ApproveTokenNftAllowanceWithDelegatingSpender(nft1, env.OperatorID, *delegateSpenderAccountId, *spenderAccountId).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = approveDelegateTx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	env.Client.SetOperator(env.OperatorID, env.OperatorKey)

	onBehalfOfTransactionId := TransactionIDGenerate(*delegateSpenderAccountId)
	frozenTransfer, err := NewTransferTransaction().AddApprovedNftTransfer(nft1, env.OperatorID, *receiverAccountId, true).SetTransactionID(onBehalfOfTransactionId).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTransfer.Sign(delegateSpenderKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	onBehalfOfTransactionId2 := TransactionIDGenerate(*delegateSpenderAccountId)
	frozenTransfer2, err := NewTransferTransaction().AddApprovedNftTransfer(nft2, env.OperatorID, *receiverAccountId, true).SetTransactionID(onBehalfOfTransactionId2).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err = frozenTransfer2.Sign(delegateSpenderKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.Error(t, err)
	require.Equal(t, "exceptional receipt status: SPENDER_DOES_NOT_HAVE_ALLOWANCE", err.Error())

	info, err := NewTokenNftInfoQuery().SetNftID(nft1).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, *receiverAccountId, info[0].AccountID)
	info2, err := NewTokenNftInfoQuery().SetNftID(nft2).Execute(env.Client)
	require.NoError(t, err)
	require.Equal(t, env.OperatorID, info2[0].AccountID)
}
// Filename: token_nft_allowance_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestUnitNewTokenNftAllowance(t *testing.T) {
	tokenID := TokenID{Token: 1}
	owner := AccountID{Account: 2}
	spender := AccountID{Account: 3}
	serialNumbers := []int64{1, 2, 3}
	approvedForAll := true
	delegatingSpender := AccountID{Account: 4}

	allowance := NewTokenNftAllowance(tokenID, owner, spender, serialNumbers, approvedForAll, delegatingSpender)

	assert.Equal(t, &tokenID, allowance.TokenID)
	assert.Equal(t, &owner, allowance.OwnerAccountID)
	assert.Equal(t, &spender, allowance.SpenderAccountID)
	assert.Equal(t, serialNumbers, allowance.SerialNumbers)
	assert.Equal(t, approvedForAll, allowance.AllSerials)
	assert.Equal(t, &delegatingSpender, allowance.DelegatingSpender)
}

func TestUnitTokenNftAllowance_String(t *testing.T) {
	approval := TokenNftAllowance{
		TokenID:           &TokenID{Token: 1},
		SpenderAccountID:  &AccountID{Account: 2},
		OwnerAccountID:    &AccountID{Account: 3},
		SerialNumbers:     []int64{1, 2, 3},
		AllSerials:        true,
		DelegatingSpender: &AccountID{Account: 4},
	}

	assert.Equal(t, "OwnerAccountID: 0.0.3, SpenderAccountID: 0.0.2, TokenID: 0.0.1, Serials: 1, 2, 3, , ApprovedForAll: true", approval.String())
}
// Filename: token_nft_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// TokenNftInfo is the information about a NFT
type TokenNftInfo struct {
	NftID        NftID
	AccountID    AccountID
	CreationTime time.Time
	Metadata     []byte
	LedgerID     LedgerID
	SpenderID    AccountID
}

func _TokenNftInfoFromProtobuf(pb *services.TokenNftInfo) TokenNftInfo {
	if pb == nil {
		return TokenNftInfo{}
	}

	accountID := AccountID{}
	if pb.AccountID != nil {
		accountID = *_AccountIDFromProtobuf(pb.AccountID)
	}

	spenderID := AccountID{}
	if pb.SpenderId != nil {
		spenderID = *_AccountIDFromProtobuf(pb.SpenderId)
	}

	return TokenNftInfo{
		NftID:        _NftIDFromProtobuf(pb.NftID),
		AccountID:    accountID,
		CreationTime: _TimeFromProtobuf(pb.CreationTime),
		Metadata:     pb.Metadata,
		LedgerID:     LedgerID{pb.LedgerId},
		SpenderID:    spenderID,
	}
}

func (tokenNftInfo *TokenNftInfo) _ToProtobuf() *services.TokenNftInfo {
	return &services.TokenNftInfo{
		NftID:        tokenNftInfo.NftID._ToProtobuf(),
		AccountID:    tokenNftInfo.AccountID._ToProtobuf(),
		CreationTime: _TimeToProtobuf(tokenNftInfo.CreationTime),
		Metadata:     tokenNftInfo.Metadata,
		LedgerId:     tokenNftInfo.LedgerID.ToBytes(),
		SpenderId:    tokenNftInfo.SpenderID._ToProtobuf(),
	}
}

// ToBytes returns the byte representation of the TokenNftInfo
func (tokenNftInfo *TokenNftInfo) ToBytes() []byte {
	data, err := protobuf.Marshal(tokenNftInfo._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TokenNftInfoFromBytes returns the TokenNftInfo from a byte array representation
func TokenNftInfoFromBytes(data []byte) (TokenNftInfo, error) {
	if data == nil {
		return TokenNftInfo{}, errByteArrayNull
	}
	pb := services.TokenNftInfo{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TokenNftInfo{}, err
	}

	return _TokenNftInfoFromProtobuf(&pb), nil
}
// Filename: token_nft_info_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenNftInfoQuery
// Applicable only to tokens of type NON_FUNGIBLE_UNIQUE.
// Gets info on a NFT for a given TokenID (of type NON_FUNGIBLE_UNIQUE) and serial number
type TokenNftInfoQuery struct {
	Query
	nftID *NftID
}

// NewTokenNftInfoQuery creates TokenNftInfoQuery which
// gets info on a NFT for a given TokenID (of type NON_FUNGIBLE_UNIQUE) and serial number
// Applicable only to tokens of type NON_FUNGIBLE_UNIQUE.
func NewTokenNftInfoQuery() *TokenNftInfoQuery {
	header := services.QueryHeader{}
	return &TokenNftInfoQuery{
		Query: _NewQuery(true, &header),
		nftID: nil,
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *TokenNftInfoQuery) SetGrpcDeadline(deadline *time.Duration) *TokenNftInfoQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetNftID Sets the ID of the NFT
func (q *TokenNftInfoQuery) SetNftID(nftID NftID) *TokenNftInfoQuery {
	q.nftID = &nftID
	return q
}

// GetNftID returns the ID of the NFT
func (q *TokenNftInfoQuery) GetNftID() NftID {
	if q.nftID == nil {
		return NftID{}
	}

	return *q.nftID
}

// Deprecated
func (q *TokenNftInfoQuery) SetTokenID(id TokenID) *TokenNftInfoQuery {
	return q
}

// Deprecated
func (q *TokenNftInfoQuery) GetTokenID() TokenID {
	return TokenID{}
}

// Deprecated
func (q *TokenNftInfoQuery) SetAccountID(id AccountID) *TokenNftInfoQuery {
	return q
}

// Deprecated
func (q *TokenNftInfoQuery) GetAccountID() AccountID {
	return AccountID{}
}

// Deprecated
func (q *TokenNftInfoQuery) SetStart(start int64) *TokenNftInfoQuery {
	return q
}

// Deprecated
func (q *TokenNftInfoQuery) GetStart() int64 {
	return 0
}

// Deprecated
func (q *TokenNftInfoQuery) SetEnd(end int64) *TokenNftInfoQuery {
	return q
}

// Deprecated
func (q *TokenNftInfoQuery) GetEnd() int64 {
	return 0
}

// Deprecated
func (q *TokenNftInfoQuery) ByNftID(id NftID) *TokenNftInfoQuery {
	q.nftID = &id
	return q
}

// Deprecated
func (q *TokenNftInfoQuery) ByTokenID(id TokenID) *TokenNftInfoQuery {
	return q
}

// Deprecated
func (q *TokenNftInfoQuery) ByAccountID(id AccountID) *TokenNftInfoQuery {
	return q
}

func (q *TokenNftInfoQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *TokenNftInfoQuery) Execute(client *Client) ([]TokenNftInfo, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return []TokenNftInfo{}, err
	}

	tokenInfos := make([]TokenNftInfo, 0)
	tokenInfos = append(tokenInfos, _TokenNftInfoFromProtobuf(resp.GetTokenGetNftInfo().GetNft()))
	return tokenInfos, nil
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *TokenNftInfoQuery) SetMaxQueryPayment(maxPayment Hbar) *TokenNftInfoQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *TokenNftInfoQuery) SetQueryPayment(paymentAmount Hbar) *TokenNftInfoQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenNftInfoQuery.
func (q *TokenNftInfoQuery) SetNodeAccountIDs(accountID []AccountID) *TokenNftInfoQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *TokenNftInfoQuery) SetMaxRetry(count int) *TokenNftInfoQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *TokenNftInfoQuery) SetMaxBackoff(max time.Duration) *TokenNftInfoQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *TokenNftInfoQuery) SetMinBackoff(min time.Duration) *TokenNftInfoQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *TokenNftInfoQuery) SetPaymentTransactionID(transactionID TransactionID) *TokenNftInfoQuery {
	q.paymentTransactionIDs._Clear()._Push(transactionID)._SetLocked(true)
	return q
}

func (q *TokenNftInfoQuery) SetLogLevel(level LogLevel) *TokenNftInfoQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *TokenNftInfoQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetToken().GetTokenNftInfo,
	}
}

func (q *TokenNftInfoQuery) getName() string {
	return "TokenNftInfoQuery"
}

func (q *TokenNftInfoQuery) buildQuery() *services.Query {
	body := &services.TokenGetNftInfoQuery{
		Header: q.pbHeader,
	}

	if q.nftID != nil {
		body.NftID = q.nftID._ToProtobuf()
	}

	return &services.Query{
		Query: &services.Query_TokenGetNftInfo{
			TokenGetNftInfo: body,
		},
	}
}

func (q *TokenNftInfoQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.nftID != nil {
		if err := q.nftID.Validate(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *TokenNftInfoQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetTokenGetNftInfo()
}
// Filename: token_nft_info_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenNftGetInfoByNftIDCanExecute(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	metaData := []byte{50}

	mint, err := NewTokenMintTransaction().
		SetTokenID(tokenID).
		SetMetadata(metaData).
		Execute(env.Client)
	require.NoError(t, err)

	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nftID := tokenID.Nft(mintReceipt.SerialNumbers[0])

	info, err := NewTokenNftInfoQuery().
		SetNftID(nftID).
		Execute(env.Client)
	require.NoError(t, err)

	value := false
	for _, nftInfo := range info {
		if tokenID.String() == nftInfo.NftID.TokenID.String() {
			value = true
		}
	}
	assert.Truef(t, value, "token nft transfer transaction failed")
	assert.Equal(t, len(info), 1)
	assert.Equal(t, info[0].NftID, nftID)
	assert.Equal(t, info[0].Metadata[0], byte(50))
	parsedInfo, err := TokenNftInfoFromBytes(info[0].ToBytes())
	assert.NoError(t, err)
	assert.Equal(t, parsedInfo, info[0])
}
// Filename: token_nft_info_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenNftGetInfoByNftIDValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	nftID, err := NftIDFromString("2@0.0.123-esxsf")
	require.NoError(t, err)

	nftInfo := NewTokenNftInfoQuery().
		SetNftID(nftID)

	err = nftInfo.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenNftGetInfoByNftIDValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	nftID, err := NftIDFromString("2@0.0.123-rmkykd")
	require.NoError(t, err)

	nftInfo := NewTokenNftInfoQuery().
		SetNftID(nftID)

	err = nftInfo.validateNetworkOnIDs(client)
	require.Error(t, err)
	if err != nil {
		require.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenNftInfoQueryNothingSet(t *testing.T) {
	t.Parallel()

	query := NewTokenNftInfoQuery()

	require.Equal(t, NftID{TokenID: TokenID{Shard: 0x0, Realm: 0x0, Token: 0x0, checksum: (*string)(nil)}, SerialNumber: 0}, query.GetNftID())
	require.Equal(t, []AccountID{}, query.GetNodeAccountIDs())
	require.Equal(t, 250*time.Millisecond, query.GetMinBackoff())
	require.Equal(t, 8*time.Second, query.GetMaxBackoff())
	require.Equal(t, 10, query.GetMaxRetryCount())
	require.Equal(t, TransactionID{}, query.GetPaymentTransactionID())
	require.Equal(t, Hbar{}, query.GetQueryPayment())
	require.Equal(t, Hbar{}, query.GetMaxQueryPayment())
}

func TestUnitTokenNftInfoQueryGet(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	deadline := time.Second * 3
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(account)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	query := NewTokenNftInfoQuery().
		SetTokenID(token).
		SetNftID(token.Nft(334)).
		SetAccountID(account).
		SetEnd(5).
		SetStart(4).
		ByAccountID(account).
		ByTokenID(token).
		ByNftID(token.Nft(334)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetNodeAccountIDs(nodeAccountID).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(23)).
		SetQueryPayment(NewHbar(3)).
		SetGrpcDeadline(&deadline)

	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)

	// Some assertions like SetStart, SetEnd, etc. are missing, because those fucntions are deprecated and empty
	require.Equal(t, token.Nft(334).String(), query.GetNftID().String())
	require.Equal(t, token.Nft(334).String(), query.GetNftID().String())
	require.Equal(t, nodeAccountID, nodeAccountID, query.GetNodeAccountIDs())
	require.Equal(t, time.Second*30, query.GetMaxBackoff())
	require.Equal(t, time.Second*10, query.GetMinBackoff())
	require.Equal(t, NewHbar(3), query.GetQueryPayment())
	require.Equal(t, NewHbar(23), query.GetMaxQueryPayment())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}

func TestUnitTokenNftInfoQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_TokenGetNftInfo{
				TokenGetNftInfo: &services.TokenGetNftInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TokenGetNftInfo{
				TokenGetNftInfo: &services.TokenGetNftInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TokenGetNftInfo{
				TokenGetNftInfo: &services.TokenGetNftInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					Nft: &services.TokenNftInfo{
						NftID:        nil,
						AccountID:    nil,
						CreationTime: nil,
						Metadata:     nil,
						LedgerId:     nil,
						SpenderId:    nil,
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}

	query := NewTokenNftInfoQuery().
		SetNftID(token.Nft(43)).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMaxQueryPayment(NewHbar(1))

	cost, err := query.GetCost(client)
	require.NoError(t, err)
	require.Equal(t, HbarFromTinybar(2), cost)
	_, err = query.Execute(client)
	require.NoError(t, err)
}
// Filename: token_nft_transfer.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// _TokenNftTransfer is the information about a NFT transfer
type _TokenNftTransfer struct {
	SenderAccountID   AccountID
	ReceiverAccountID AccountID
	SerialNumber      int64
	IsApproved        bool
}

func _NftTransferFromProtobuf(pb *services.NftTransfer) _TokenNftTransfer {
	if pb == nil {
		return _TokenNftTransfer{}
	}

	senderAccountID := AccountID{}
	if pb.SenderAccountID != nil {
		senderAccountID = *_AccountIDFromProtobuf(pb.SenderAccountID)
	}

	receiverAccountID := AccountID{}
	if pb.ReceiverAccountID != nil {
		receiverAccountID = *_AccountIDFromProtobuf(pb.ReceiverAccountID)
	}

	return _TokenNftTransfer{
		SenderAccountID:   senderAccountID,
		ReceiverAccountID: receiverAccountID,
		SerialNumber:      pb.SerialNumber,
		IsApproved:        pb.IsApproval,
	}
}

func (transfer *_TokenNftTransfer) _ToProtobuf() *services.NftTransfer {
	return &services.NftTransfer{
		SenderAccountID:   transfer.SenderAccountID._ToProtobuf(),
		ReceiverAccountID: transfer.ReceiverAccountID._ToProtobuf(),
		SerialNumber:      transfer.SerialNumber,
		IsApproval:        transfer.IsApproved,
	}
}

// ToBytes returns the byte representation of the TokenNftTransfer
func (transfer _TokenNftTransfer) ToBytes() []byte {
	data, err := protobuf.Marshal(transfer._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TokenNftTransfersFromBytes returns the TokenNftTransfer from a raw protobuf bytes representation
func NftTransferFromBytes(data []byte) (_TokenNftTransfer, error) {
	if data == nil {
		return _TokenNftTransfer{}, errByteArrayNull
	}
	pb := services.NftTransfer{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return _TokenNftTransfer{}, err
	}

	return _NftTransferFromProtobuf(&pb), nil
}
// Filename: token_nft_transfer_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

// testinf func (transfer TokenNftTransfer) ToBytes() and func NftTransferFromBytes(data []byte)
func TestUnitTokenNftTransferToBytes(t *testing.T) {
	t.Parallel()

	transfer := _TokenNftTransfer{
		SenderAccountID:   AccountID{Account: 3},
		ReceiverAccountID: AccountID{Account: 4},
		SerialNumber:      5,
		IsApproved:        true,
	}

	transferBytes := transfer.ToBytes()
	transferFromBytes, err := NftTransferFromBytes(transferBytes)

	assert.NoError(t, err)
	assert.Equal(t, transfer, transferFromBytes)

	// test invalid data from and to bytes
	_, err = NftTransferFromBytes([]byte{1, 2, 3})
	assert.Error(t, err)

	// test nil data from bytes and to bytes
	_, err = NftTransferFromBytes(nil)
	assert.Error(t, err)
}
// Filename: token_pause_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenPauseTransaction
// Pauses the Token from being involved in any kind of Transaction until it is unpaused.
// Must be signed with the Token's pause key.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
// Once executed the Token is marked as paused and will be not able to be a part of any transaction.
// The operation is idempotent - becomes a no-op if the Token is already Paused.
type TokenPauseTransaction struct {
	Transaction
	tokenID *TokenID
}

// NewTokenPauseTransaction creates TokenPauseTransaction which
// pauses the Token from being involved in any kind of Transaction until it is unpaused.
// Must be signed with the Token's pause key.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
// Once executed the Token is marked as paused and will be not able to be a part of any transaction.
// The operation is idempotent - becomes a no-op if the Token is already Paused.
func NewTokenPauseTransaction() *TokenPauseTransaction {
	tx := TokenPauseTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenPauseTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenPauseTransaction {
	return &TokenPauseTransaction{
		Transaction: tx,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenDeletion().GetToken()),
	}
}

// SetTokenID Sets the token to be paused
func (tx *TokenPauseTransaction) SetTokenID(tokenID TokenID) *TokenPauseTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the token to be paused
func (tx *TokenPauseTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenPauseTransaction) Sign(privateKey PrivateKey) *TokenPauseTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenPauseTransaction) SignWithOperator(client *Client) (*TokenPauseTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenPauseTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenPauseTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenPauseTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenPauseTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenPauseTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenPauseTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenPauseTransaction) Freeze() (*TokenPauseTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenPauseTransaction) FreezeWith(client *Client) (*TokenPauseTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenPauseTransaction.
func (tx *TokenPauseTransaction) SetMaxTransactionFee(fee Hbar) *TokenPauseTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenPauseTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenPauseTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenPauseTransaction.
func (tx *TokenPauseTransaction) SetTransactionMemo(memo string) *TokenPauseTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenPauseTransaction.
func (tx *TokenPauseTransaction) SetTransactionValidDuration(duration time.Duration) *TokenPauseTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenPauseTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenPauseTransaction.
func (tx *TokenPauseTransaction) SetTransactionID(transactionID TransactionID) *TokenPauseTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenPauseTransaction.
func (tx *TokenPauseTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenPauseTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenPauseTransaction) SetMaxRetry(count int) *TokenPauseTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenPauseTransaction) SetMaxBackoff(max time.Duration) *TokenPauseTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenPauseTransaction) SetMinBackoff(min time.Duration) *TokenPauseTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenPauseTransaction) SetLogLevel(level LogLevel) *TokenPauseTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenPauseTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenPauseTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenPauseTransaction) getName() string {
	return "TokenPauseTransaction"
}

func (tx *TokenPauseTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenPauseTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenPause{
			TokenPause: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenPauseTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) { //nolint
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenPause{
			TokenPause: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenPauseTransaction) buildProtoBody() *services.TokenPauseTransactionBody {
	body := &services.TokenPauseTransactionBody{}
	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}
	return body
}

func (tx *TokenPauseTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().DeleteToken,
	}
}

func (tx *TokenPauseTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_pause_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenPauseTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(env.Client)

	require.NotNil(t, info.PauseStatus)
	require.False(t, *info.PauseStatus)

	resp, err := NewTokenPauseTransaction().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	require.NotNil(t, info.PauseStatus)
	require.True(t, *info.PauseStatus)

	//Unpause token to avoid error in CloseIntegrationTestEnv
	resp, err = NewTokenUnpauseTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		Execute(env.Client)

	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}
// Filename: token_pause_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnitTokenPause(t *testing.T) {
	t.Parallel()

	accountID, err := AccountIDFromString("0.0.5005")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.5005")
	require.NoError(t, err)

	tx, err := NewTokenPauseTransaction().
		SetNodeAccountIDs([]AccountID{accountID}).
		SetTransactionID(TransactionIDGenerate(accountID)).
		SetTokenID(tokenID).
		Freeze()
	require.NoError(t, err)

	pb := tx.build()
	require.Equal(t, pb.GetTokenPause().GetToken().String(), tokenID._ToProtobuf().String())
}

func TestUnitTokenUnpause(t *testing.T) {
	t.Parallel()

	accountID, err := AccountIDFromString("0.0.5005")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.5005")
	require.NoError(t, err)

	tx, err := NewTokenUnpauseTransaction().
		SetNodeAccountIDs([]AccountID{accountID}).
		SetTransactionID(TransactionIDGenerate(accountID)).
		SetTokenID(tokenID).
		Freeze()
	require.NoError(t, err)

	pb := tx.build()
	require.Equal(t, pb.GetTokenUnpause().GetToken().String(), tokenID._ToProtobuf().String())
}
func TestUnitTokenPauseSchedule(t *testing.T) {
	accountID, err := AccountIDFromString("0.0.5005")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.5005")
	require.NoError(t, err)

	tx, err := NewTokenPauseTransaction().
		SetNodeAccountIDs([]AccountID{accountID}).
		SetTransactionID(TransactionIDGenerate(accountID)).
		SetTokenID(tokenID).
		Schedule()
	require.NoError(t, err)

	scheduled := tx.schedulableBody.GetTokenPause()
	require.Equal(t, scheduled.Token.String(), tokenID._ToProtobuf().String())
}

func TestUnitTokenPauseTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenPauseTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenPauseTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenPauseTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenUnpauseTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenUnpauseTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenUnpauseTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenUnpauseTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenUnpauseTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenUnpauseTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(token).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenUnpauseTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenUnpauseTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}

	freez, err := NewTokenUnpauseTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}

func TestUnitTokenPauseTransaction_SetMaxRetry(t *testing.T) {
	t.Parallel()
	transaction := NewTokenPauseTransaction()
	transaction.SetMaxRetry(5)

	require.Equal(t, 5, transaction.GetMaxRetry())
}

func TestUnitTokenPauseTransaction_AddSignature(t *testing.T) {
	t.Parallel()
	client, _ := ClientFromConfig([]byte(testClientJSONWithoutMirrorNetwork))

	nodeAccountId, err := AccountIDFromString("0.0.3")
	require.NoError(t, err)

	nodeIdList := []AccountID{nodeAccountId}

	transaction, err := NewTokenPauseTransaction().
		SetNodeAccountIDs(nodeIdList).
		FreezeWith(client)

	privateKey, _ := PrivateKeyGenerateEd25519()

	signature, err := privateKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	signs, err := transaction.GetSignatures()
	for key := range signs[nodeAccountId] {
		require.Equal(t, signs[nodeAccountId][key], signature)
	}

	require.NoError(t, err)

	privateKey2, _ := PrivateKeyGenerateEd25519()
	publicKey2 := privateKey2.PublicKey()

	signedTransaction := transaction.AddSignature(publicKey2, signature)
	signs2, err := signedTransaction.GetSignatures()
	require.NoError(t, err)

	for key := range signs2[nodeAccountId] {
		require.Equal(t, signs2[nodeAccountId][key], signature)
	}
}

func TestUnitTokenPauseTransaction_SignWithOperator(t *testing.T) {
	t.Parallel()
	client, _ := ClientFromConfig([]byte(testClientJSONWithoutMirrorNetwork))
	privateKey, _ := PrivateKeyGenerateEd25519()
	publicKey := privateKey.PublicKey()
	operatorId, _ := AccountIDFromString("0.0.10")

	client.SetOperator(operatorId, privateKey)

	nodeAccountId, err := AccountIDFromString("0.0.3")
	require.NoError(t, err)
	nodeIdList := []AccountID{nodeAccountId}

	transaction, err := NewTokenPauseTransaction().
		SetNodeAccountIDs(nodeIdList).
		SetTokenID(TokenID{Token: 3}).
		SignWithOperator(client)

	require.NoError(t, err)
	require.NotNil(t, transaction)

	privateKey2, _ := PrivateKeyGenerateEd25519()
	publicKey2 := privateKey2.PublicKey()
	client.SetOperator(operatorId, privateKey2)

	transactionSignedWithOp, err := transaction.SignWithOperator(client)
	require.NoError(t, err)
	require.NotNil(t, transactionSignedWithOp)

	assert.Contains(t, transactionSignedWithOp.Transaction.publicKeys, publicKey)
	assert.Contains(t, transactionSignedWithOp.Transaction.publicKeys, publicKey2)

	// test errors
	client.operator = nil
	tx, err := NewTokenPauseTransaction().
		SetNodeAccountIDs(nodeIdList).
		SetTokenID(TokenID{Token: 3}).
		SignWithOperator(client)

	require.Error(t, err)
	require.Nil(t, tx)

	client = nil
	tx, err = NewTokenPauseTransaction().
		SetNodeAccountIDs(nodeIdList).
		SetTokenID(TokenID{Token: 3}).
		SignWithOperator(client)

	require.Error(t, err)
	require.Nil(t, tx)
}

func TestUnitTokenPauseTransaction_SetMaxBackoff(t *testing.T) {
	t.Parallel()
	transaction := NewTokenPauseTransaction()
	maxBackoff := 10 * time.Second

	transaction.SetMaxBackoff(maxBackoff)

	require.Equal(t, maxBackoff, transaction.GetMaxBackoff())

	// test max.Nanoseconds() < 0
	transaction2 := NewTokenPauseTransaction()
	maxBackoff2 := -1 * time.Second

	require.Panics(t, func() { transaction2.SetMaxBackoff(maxBackoff2) })

	// test max.Nanoseconds() < min.Nanoseconds()
	transaction3 := NewTokenPauseTransaction()
	maxBackoff3 := 1 * time.Second
	minBackoff3 := 2 * time.Second

	transaction3.SetMinBackoff(minBackoff3)

	require.Panics(t, func() { transaction3.SetMaxBackoff(maxBackoff3) })
}

func TestUnitTokenPauseTransaction_GetMaxBackoff(t *testing.T) {
	t.Parallel()
	transaction := NewTokenPauseTransaction()

	require.Equal(t, 8*time.Second, transaction.GetMaxBackoff())
}

func TestUnitTokenPauseTransaction_SetMinBackoff(t *testing.T) {
	t.Parallel()
	transaction := NewTokenPauseTransaction()
	minBackoff := 1 * time.Second

	transaction.SetMinBackoff(minBackoff)

	require.Equal(t, minBackoff, transaction.GetMinBackoff())

	// test min.Nanoseconds() < 0
	transaction2 := NewTokenPauseTransaction()
	minBackoff2 := -1 * time.Second

	require.Panics(t, func() { transaction2.SetMinBackoff(minBackoff2) })

	// test transaction.maxBackoff.Nanoseconds() < min.Nanoseconds()
	transaction3 := NewTokenPauseTransaction()
	minBackoff3 := 10 * time.Second

	require.Panics(t, func() { transaction3.SetMinBackoff(minBackoff3) })
}

func TestUnitTokenPauseTransaction_GetMinBackoff(t *testing.T) {
	t.Parallel()
	transaction := NewTokenPauseTransaction()

	require.Equal(t, 250*time.Millisecond, transaction.GetMinBackoff())
}

func TestUnitTokenPauseTransaction_SetLogLevel(t *testing.T) {
	t.Parallel()
	transaction := NewTokenPauseTransaction()

	transaction.SetLogLevel(LoggerLevelDebug)

	level := transaction.GetLogLevel()
	require.Equal(t, LoggerLevelDebug, *level)
}
// Filename: token_reject_flow.go
package hedera

import (
	"time"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

type TokenRejectFlow struct {
	Transaction
	ownerID           *AccountID
	tokenIDs          []TokenID
	nftIDs            []NftID
	freezeWithClient  *Client
	signPrivateKey    *PrivateKey
	signPublicKey     *PublicKey
	transactionSigner *TransactionSigner
}

func NewTokenRejectFlow() *TokenRejectFlow {
	tx := TokenRejectFlow{
		Transaction: _NewTransaction(),
	}
	return &tx
}

// SetOwnerID Sets the account which owns the tokens to be rejected
func (tx *TokenRejectFlow) SetOwnerID(ownerID AccountID) *TokenRejectFlow {
	tx._RequireNotFrozen()
	tx.ownerID = &ownerID
	return tx
}

// GetOwnerID Gets the account which owns the tokens to be rejected
func (tx *TokenRejectFlow) GetOwnerID() AccountID {
	if tx.ownerID == nil {
		return AccountID{}
	}
	return *tx.ownerID
}

// SetTokenIDs Sets the tokens to be rejected
func (tx *TokenRejectFlow) SetTokenIDs(ids ...TokenID) *TokenRejectFlow {
	tx._RequireNotFrozen()
	tx.tokenIDs = make([]TokenID, len(ids))
	copy(tx.tokenIDs, ids)

	return tx
}

// AddTokenID Adds a token to be rejected
func (tx *TokenRejectFlow) AddTokenID(id TokenID) *TokenRejectFlow {
	tx._RequireNotFrozen()
	tx.tokenIDs = append(tx.tokenIDs, id)
	return tx
}

// GetTokenIDs Gets the tokens to be rejected
func (tx *TokenRejectFlow) GetTokenIDs() []TokenID {
	return tx.tokenIDs
}

// SetNftIDs Sets the NFTs to be rejected
func (tx *TokenRejectFlow) SetNftIDs(ids ...NftID) *TokenRejectFlow {
	tx._RequireNotFrozen()
	tx.nftIDs = make([]NftID, len(ids))
	copy(tx.nftIDs, ids)

	return tx
}

// AddNftID Adds an NFT to be rejected
func (tx *TokenRejectFlow) AddNftID(id NftID) *TokenRejectFlow {
	tx._RequireNotFrozen()
	tx.nftIDs = append(tx.nftIDs, id)
	return tx
}

// GetNftIDs Gets the NFTs to be rejected
func (tx *TokenRejectFlow) GetNftIDs() []NftID {
	return tx.nftIDs
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenRejectFlow) Sign(privateKey PrivateKey) *TokenRejectFlow {
	tx.signPrivateKey = &privateKey
	return tx
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenRejectFlow) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenRejectFlow {
	tx.signPublicKey = &publicKey
	tx.transactionSigner = &signer
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenRejectFlow) AddSignature(publicKey PublicKey, signature []byte) *TokenRejectFlow {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenRejectFlow) SetGrpcDeadline(deadline *time.Duration) *TokenRejectFlow {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenRejectFlow) Freeze() (*TokenRejectFlow, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenRejectFlow) FreezeWith(client *Client) (*TokenRejectFlow, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	tx.freezeWithClient = client
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenRejectFlow.
func (tx *TokenRejectFlow) SetMaxTransactionFee(fee Hbar) *TokenRejectFlow {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenRejectFlow) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenRejectFlow {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenRejectFlow.
func (tx *TokenRejectFlow) SetTransactionMemo(memo string) *TokenRejectFlow {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenRejectFlow.
func (tx *TokenRejectFlow) SetTransactionValidDuration(duration time.Duration) *TokenRejectFlow {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenRejectFlow) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenRejectFlow.
func (tx *TokenRejectFlow) SetTransactionID(transactionID TransactionID) *TokenRejectFlow {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenRejectFlow.
func (tx *TokenRejectFlow) SetNodeAccountIDs(nodeID []AccountID) *TokenRejectFlow {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenRejectFlow) SetMaxRetry(count int) *TokenRejectFlow {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenRejectFlow) SetMaxBackoff(max time.Duration) *TokenRejectFlow {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenRejectFlow) SetMinBackoff(min time.Duration) *TokenRejectFlow {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenRejectFlow) SetLogLevel(level LogLevel) *TokenRejectFlow {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenRejectFlow) _CreateTokenDissociateTransaction(client *Client) (*TokenDissociateTransaction, error) {
	if client == nil {
		return &TokenDissociateTransaction{}, nil
	}
	tokenDissociateTxn := NewTokenDissociateTransaction()

	if tx.ownerID != nil {
		tokenDissociateTxn.SetAccountID(*tx.ownerID)
	}

	tokenIDs := make([]TokenID, 0)
	if tx.tokenIDs != nil {
		tokenIDs = append(tokenIDs, tx.tokenIDs...)
	}

	if tx.nftIDs != nil {
		seenTokenIDs := make(map[TokenID]struct{})
		for _, nftID := range tx.nftIDs {
			if _, exists := seenTokenIDs[nftID.TokenID]; !exists {
				seenTokenIDs[nftID.TokenID] = struct{}{}
				tokenIDs = append(tokenIDs, nftID.TokenID)
			}
		}
	}

	if len(tokenIDs) != 0 {
		tokenDissociateTxn.SetTokenIDs(tokenIDs...)
	}

	if tx.freezeWithClient != nil {
		_, err := tokenDissociateTxn.freezeWith(tx.freezeWithClient, tokenDissociateTxn)
		if err != nil {
			return nil, err
		}
	}

	if tx.signPrivateKey != nil {
		tokenDissociateTxn = tokenDissociateTxn.Sign(*tx.signPrivateKey)
	}

	if tx.signPublicKey != nil && tx.transactionSigner != nil {
		tokenDissociateTxn = tokenDissociateTxn.SignWith(*tx.signPublicKey, *tx.transactionSigner)
	}

	return tokenDissociateTxn, nil
}

func (tx *TokenRejectFlow) _CreateTokenRejectTransaction(client *Client) (*TokenRejectTransaction, error) {
	if client == nil {
		return &TokenRejectTransaction{}, nil
	}
	tokenRejectTxn := NewTokenRejectTransaction()

	if tx.ownerID != nil {
		tokenRejectTxn.SetOwnerID(*tx.ownerID)
	}

	if tx.tokenIDs != nil {
		tokenRejectTxn.SetTokenIDs(tx.tokenIDs...)
	}

	if tx.nftIDs != nil {
		tokenRejectTxn.SetNftIDs(tx.nftIDs...)
	}

	if tx.freezeWithClient != nil {
		_, err := tokenRejectTxn.freezeWith(tx.freezeWithClient, tokenRejectTxn)
		if err != nil {
			return nil, err
		}
	}

	if tx.signPrivateKey != nil {
		tokenRejectTxn = tokenRejectTxn.Sign(*tx.signPrivateKey)
	}

	if tx.signPublicKey != nil && tx.transactionSigner != nil {
		tokenRejectTxn = tokenRejectTxn.SignWith(*tx.signPublicKey, *tx.transactionSigner)
	}

	return tokenRejectTxn, nil
}

func (tx *TokenRejectFlow) Execute(client *Client) (TransactionResponse, error) {
	tokenRejectTxn, err := tx._CreateTokenRejectTransaction(client)
	if err != nil {
		return TransactionResponse{}, err
	}
	tokenRejectResponse, err := tokenRejectTxn.Execute(client)
	if err != nil {
		return TransactionResponse{}, err
	}
	_, err = tokenRejectResponse.GetReceipt(client)
	if err != nil {
		return TransactionResponse{}, err
	}

	tokenDissociateTxn, err := tx._CreateTokenDissociateTransaction(client)
	if err != nil {
		return TransactionResponse{}, err
	}
	tokenDissociateResponse, err := tokenDissociateTxn.Execute(client)
	if err != nil {
		return TransactionResponse{}, err
	}
	_, err = tokenDissociateResponse.GetReceipt(client)
	if err != nil {
		return TransactionResponse{}, err
	}

	return tokenRejectResponse, nil
}

func (tx *TokenRejectFlow) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}
func (tx *TokenRejectFlow) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.ownerID != nil {
		if err := tx.ownerID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	for _, tokenID := range tx.tokenIDs {
		if err := tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	for _, nftID := range tx.nftIDs {
		if err := nftID.TokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}
// Filename: token_reject_flow_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

func TestCustomizer(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	newKey, _ := GeneratePrivateKey()

	// TODO - remove this once the customizer is implemented
	_, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		_, err := transaction.SetAdminKey(newKey).FreezeWith(env.Client)
		require.NoError(t, err)
		transaction.Sign(newKey)
	})

	require.NoError(t, err)
}
func TestIntegrationTokenRejectFlowCanExecuteForFungibleToken(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create fungible tokens with treasury
	tokenID1, err := createFungibleToken(&env)
	require.NoError(t, err)
	tokenID2, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create receiver account with 0 auto associations
	receiver, key, err := createAccount(&env)
	require.NoError(t, err)

	// associate the tokens with the receiver
	frozenAssociateTxn, err := NewTokenAssociateTransaction().SetAccountID(receiver).AddTokenID(tokenID1).AddTokenID(tokenID2).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenAssociateTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer fts to the receiver
	tx, err := NewTransferTransaction().
		AddTokenTransfer(tokenID1, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID1, receiver, 10).
		AddTokenTransfer(tokenID2, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID2, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token + dissociate
	frozenTxn, err := NewTokenRejectFlow().
		SetOwnerID(receiver).
		SetTokenIDs(tokenID1, tokenID2).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err = frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance of the receiver is 0
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	assert.Zero(t, tokenBalance.Tokens.Get(tokenID1))
	assert.Zero(t, tokenBalance.Tokens.Get(tokenID2))

	// verify the tokens are transferred back to the treasury
	tokenBalance, err = NewAccountBalanceQuery().SetAccountID(env.OperatorID).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1_000_000), tokenBalance.Tokens.Get(tokenID1))
	assert.Equal(t, uint64(1_000_000), tokenBalance.Tokens.Get(tokenID2))

	// verify the tokens are not associated with the receiver
	tx, err = NewTransferTransaction().
		AddTokenTransfer(tokenID1, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID1, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT")

	tx, err = NewTransferTransaction().
		AddTokenTransfer(tokenID2, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID2, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT")
}

func TestIntegrationTokenRejectFlowCanExecuteForNFT(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create nft collections with treasury
	nftID1, err := createNft(&env)
	require.NoError(t, err)
	nftID2, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID1).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	mint, err = NewTokenMintTransaction().SetTokenID(nftID2).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// create receiver account
	receiver, key, err := createAccount(&env)
	require.NoError(t, err)

	// associate the tokens with the receiver
	frozenAssociateTxn, err := NewTokenAssociateTransaction().SetAccountID(receiver).AddTokenID(nftID1).AddTokenID(nftID2).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenAssociateTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer nfts to the receiver
	tx, err := NewTransferTransaction().
		AddNftTransfer(nftID1.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID1.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID2.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID2.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token + dissociate
	frozenTxn, err := NewTokenRejectFlow().
		SetOwnerID(receiver).
		SetNftIDs(nftID1.Nft(serials[0]), nftID1.Nft(serials[1]), nftID2.Nft(serials[0]), nftID2.Nft(serials[1])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err = frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance is decremented by 2
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(0), tokenBalance.Tokens.Get(nftID1))
	assert.Equal(t, uint64(0), tokenBalance.Tokens.Get(nftID2))

	// verify the token is transferred back to the treasury
	nftBalance, err := NewTokenNftInfoQuery().SetNftID(nftID1.Nft(serials[1])).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, env.OperatorID, nftBalance[0].AccountID)

	nftBalance, err = NewTokenNftInfoQuery().SetNftID(nftID2.Nft(serials[1])).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, env.OperatorID, nftBalance[0].AccountID)

	// verify the tokens are not associated with the receiver
	tx, err = NewTransferTransaction().
		AddNftTransfer(nftID1.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID1.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT")
}

func TestIntegrationTokenRejectFlowFailsWhenNotRejectingAllNFTs(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create nft collections with treasury
	nftID1, err := createNft(&env)
	require.NoError(t, err)
	nftID2, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID1).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	mint, err = NewTokenMintTransaction().SetTokenID(nftID2).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// create receiver account
	receiver, key, err := createAccount(&env)
	require.NoError(t, err)

	// associate the tokens with the receiver
	frozenAssociateTxn, err := NewTokenAssociateTransaction().SetAccountID(receiver).AddTokenID(nftID1).AddTokenID(nftID2).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenAssociateTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer nfts to the receiver
	tx, err := NewTransferTransaction().
		AddNftTransfer(nftID1.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID1.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID2.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID2.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token + dissociate
	frozenTxn, err := NewTokenRejectFlow().
		SetOwnerID(receiver).
		SetNftIDs(nftID1.Nft(serials[0]), nftID1.Nft(serials[1]), nftID2.Nft(serials[0])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err = frozenTxn.Sign(key).Execute(env.Client)
	require.ErrorContains(t, err, "ACCOUNT_STILL_OWNS_NFTS")
}
// Filename: token_reject_flow_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenRejectFlowValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenAssociate := NewTokenRejectFlow().
		SetOwnerID(accountID).
		SetTokenIDs(tokenID)

	err = tokenAssociate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenRejectFlowValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenAssociate := NewTokenRejectFlow().
		SetOwnerID(accountID).
		SetTokenIDs(tokenID)

	err = tokenAssociate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenRejectFlowGet(t *testing.T) {
	t.Parallel()

	tokenIDs := []TokenID{{Token: 3}, {Token: 5}, {Token: 7}}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenRejectFlow().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(tokenIDs...).
		SetOwnerID(AccountID{Account: 7}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetOwnerID()
	transaction.GetTokenIDs()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenRejectFlowNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenRejectFlow().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetOwnerID()
	transaction.GetTokenIDs()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenRejectFlowCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenRejectFlow().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(token).
		AddTokenID(token).
		SetOwnerID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenIDs()
	transaction.GetOwnerID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
}
// Filename: token_reject_transaction.go
package hedera

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/**
 * A transaction body to "reject" undesired tokens.<br/>
 * This transaction will transfer one or more tokens or token
 * balances held by the requesting account to the treasury
 * for each token type.
 * <p>
 * Each transfer MUST be one of the following:
 * <ul>
 *   <li>A single non-fungible/unique token.</li>
 *   <li>The full balance held for a fungible/common
 *       token type.</li>
 * </ul>
 * When complete, the requesting account SHALL NOT hold the
 * rejected tokens.<br/>
 * Custom fees and royalties defined for the tokens rejected
 * SHALL NOT be charged for this transaction.
 */
type TokenRejectTransaction struct {
	Transaction
	ownerID  *AccountID
	tokenIDs []TokenID
	nftIDs   []NftID
}

func NewTokenRejectTransaction() *TokenRejectTransaction {
	tx := TokenRejectTransaction{
		Transaction: _NewTransaction(),
	}
	return &tx
}

func _TokenRejectTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenRejectTransaction {
	rejectTransaction := &TokenRejectTransaction{
		Transaction: tx,
		ownerID:     _AccountIDFromProtobuf(pb.GetTokenReject().Owner),
	}

	for _, rejection := range pb.GetTokenReject().Rejections {
		if rejection.GetFungibleToken() != nil {
			rejectTransaction.AddTokenID(*_TokenIDFromProtobuf(rejection.GetFungibleToken()))
		} else if rejection.GetNft() != nil {
			rejectTransaction.AddNftID(_NftIDFromProtobuf(rejection.GetNft()))
		}
	}

	return rejectTransaction
}

// SetOwnerID Sets the account which owns the tokens to be rejected
func (tx *TokenRejectTransaction) SetOwnerID(ownerID AccountID) *TokenRejectTransaction {
	tx._RequireNotFrozen()
	tx.ownerID = &ownerID
	return tx
}

// GetOwnerID Gets the account which owns the tokens to be rejected
func (tx *TokenRejectTransaction) GetOwnerID() AccountID {
	if tx.ownerID == nil {
		return AccountID{}
	}
	return *tx.ownerID
}

// SetTokenIDs Sets the tokens to be rejected
func (tx *TokenRejectTransaction) SetTokenIDs(ids ...TokenID) *TokenRejectTransaction {
	tx._RequireNotFrozen()
	tx.tokenIDs = make([]TokenID, len(ids))
	copy(tx.tokenIDs, ids)

	return tx
}

// AddTokenID Adds a token to be rejected
func (tx *TokenRejectTransaction) AddTokenID(id TokenID) *TokenRejectTransaction {
	tx._RequireNotFrozen()
	tx.tokenIDs = append(tx.tokenIDs, id)
	return tx
}

// GetTokenIDs Gets the tokens to be rejected
func (tx *TokenRejectTransaction) GetTokenIDs() []TokenID {
	return tx.tokenIDs
}

// SetNftIDs Sets the NFTs to be rejected
func (tx *TokenRejectTransaction) SetNftIDs(ids ...NftID) *TokenRejectTransaction {
	tx._RequireNotFrozen()
	tx.nftIDs = make([]NftID, len(ids))
	copy(tx.nftIDs, ids)

	return tx
}

// AddNftID Adds an NFT to be rejected
func (tx *TokenRejectTransaction) AddNftID(id NftID) *TokenRejectTransaction {
	tx._RequireNotFrozen()
	tx.nftIDs = append(tx.nftIDs, id)
	return tx
}

// GetNftIDs Gets the NFTs to be rejected
func (tx *TokenRejectTransaction) GetNftIDs() []NftID {
	return tx.nftIDs
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenRejectTransaction) Sign(privateKey PrivateKey) *TokenRejectTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenRejectTransaction) SignWithOperator(client *Client) (*TokenRejectTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenRejectTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenRejectTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenRejectTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenRejectTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenRejectTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenRejectTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenRejectTransaction) Freeze() (*TokenRejectTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenRejectTransaction) FreezeWith(client *Client) (*TokenRejectTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenRejectTransaction.
func (tx *TokenRejectTransaction) SetMaxTransactionFee(fee Hbar) *TokenRejectTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenRejectTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenRejectTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenRejectTransaction.
func (tx *TokenRejectTransaction) SetTransactionMemo(memo string) *TokenRejectTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenRejectTransaction.
func (tx *TokenRejectTransaction) SetTransactionValidDuration(duration time.Duration) *TokenRejectTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenRejectTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenRejectTransaction.
func (tx *TokenRejectTransaction) SetTransactionID(transactionID TransactionID) *TokenRejectTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenRejectTransaction.
func (tx *TokenRejectTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenRejectTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenRejectTransaction) SetMaxRetry(count int) *TokenRejectTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenRejectTransaction) SetMaxBackoff(max time.Duration) *TokenRejectTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenRejectTransaction) SetMinBackoff(min time.Duration) *TokenRejectTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenRejectTransaction) SetLogLevel(level LogLevel) *TokenRejectTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenRejectTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenRejectTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenRejectTransaction) getName() string {
	return "TokenRejectTransaction"
}

func (tx *TokenRejectTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.ownerID != nil {
		if err := tx.ownerID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	for _, tokenID := range tx.tokenIDs {
		if err := tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	for _, nftID := range tx.nftIDs {
		if err := nftID.TokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenRejectTransaction) build() *services.TransactionBody {
	body := tx.buildProtoBody()

	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenReject{
			TokenReject: body,
		},
	}
}

func (tx *TokenRejectTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenReject{
			TokenReject: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenRejectTransaction) buildProtoBody() *services.TokenRejectTransactionBody {
	body := &services.TokenRejectTransactionBody{}

	if tx.ownerID != nil {
		body.Owner = tx.ownerID._ToProtobuf()
	}

	for _, tokenID := range tx.tokenIDs {
		tokenReference := &services.TokenReference_FungibleToken{
			FungibleToken: tokenID._ToProtobuf(),
		}

		body.Rejections = append(body.Rejections, &services.TokenReference{
			TokenIdentifier: tokenReference,
		})
	}

	for _, nftID := range tx.nftIDs {
		tokenReference := &services.TokenReference_Nft{
			Nft: nftID._ToProtobuf(),
		}

		body.Rejections = append(body.Rejections, &services.TokenReference{
			TokenIdentifier: tokenReference,
		})
	}

	return body
}

func (tx *TokenRejectTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().RejectToken,
	}
}

func (tx *TokenRejectTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_reject_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

func TestIntegrationTokenRejectTransactionCanExecuteForFungibleToken(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create fungible tokens with treasury
	tokenID1, err := createFungibleToken(&env)
	require.NoError(t, err)
	tokenID2, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// transfer fts to the receiver
	tx, err := NewTransferTransaction().
		AddTokenTransfer(tokenID1, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID1, receiver, 10).
		AddTokenTransfer(tokenID2, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID2, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetTokenIDs(tokenID1, tokenID2).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance of the receiver is 0
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	assert.Zero(t, tokenBalance.Tokens.Get(tokenID1))
	assert.Zero(t, tokenBalance.Tokens.Get(tokenID2))

	// verify the tokens are transferred back to the treasury
	tokenBalance, err = NewAccountBalanceQuery().SetAccountID(env.OperatorID).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1_000_000), tokenBalance.Tokens.Get(tokenID1))
	assert.Equal(t, uint64(1_000_000), tokenBalance.Tokens.Get(tokenID2))
}

func TestIntegrationTokenRejectTransactionCanExecuteForNFT(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create nft collections with treasury
	nftID1, err := createNft(&env)
	require.NoError(t, err)
	nftID2, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID1).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	mint, err = NewTokenMintTransaction().SetTokenID(nftID2).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// transfer nfts to the receiver
	tx, err := NewTransferTransaction().
		AddNftTransfer(nftID1.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID1.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID2.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID2.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject one of the nfts
	frozenTxn, err := NewTokenRejectTransaction().SetOwnerID(receiver).SetNftIDs(nftID1.Nft(serials[1]), nftID2.Nft(serials[1])).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance is decremented by 1
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1), tokenBalance.Tokens.Get(nftID1))
	assert.Equal(t, uint64(1), tokenBalance.Tokens.Get(nftID2))

	// verify the token is transferred back to the treasury
	nftBalance, err := NewTokenNftInfoQuery().SetNftID(nftID1.Nft(serials[1])).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, env.OperatorID, nftBalance[0].AccountID)

	nftBalance, err = NewTokenNftInfoQuery().SetNftID(nftID2.Nft(serials[1])).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, env.OperatorID, nftBalance[0].AccountID)
}

func TestIntegrationTokenRejectTransactionCanExecuteForFTAndNFTAtTheSameTime(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create fungible tokens with treasury
	tokenID1, err := createFungibleToken(&env)
	require.NoError(t, err)
	tokenID2, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create nft collections with treasury
	nftID1, err := createNft(&env)
	require.NoError(t, err)
	nftID2, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID1).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	mint, err = NewTokenMintTransaction().SetTokenID(nftID2).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// transfer fts to the receiver
	tx1, err := NewTransferTransaction().
		AddTokenTransfer(tokenID1, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID1, receiver, 10).
		AddTokenTransfer(tokenID2, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID2, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx1.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// transfer nfts to the receiver
	tx2, err := NewTransferTransaction().
		AddNftTransfer(nftID1.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID1.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID2.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID2.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx2.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetTokenIDs(tokenID1, tokenID2).
		SetNftIDs(nftID1.Nft(serials[1]), nftID2.Nft(serials[1])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance of the receiver
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	assert.Zero(t, tokenBalance.Tokens.Get(tokenID1))
	assert.Zero(t, tokenBalance.Tokens.Get(tokenID2))
	assert.Equal(t, uint64(1), tokenBalance.Tokens.Get(nftID1))
	assert.Equal(t, uint64(1), tokenBalance.Tokens.Get(nftID2))

	// verify the tokens are transferred back to the treasury
	tokenBalance, err = NewAccountBalanceQuery().SetAccountID(env.OperatorID).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1_000_000), tokenBalance.Tokens.Get(tokenID1))
	assert.Equal(t, uint64(1_000_000), tokenBalance.Tokens.Get(tokenID2))

	nftBalance, err := NewTokenNftInfoQuery().SetNftID(nftID1.Nft(serials[1])).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, env.OperatorID, nftBalance[0].AccountID)

	nftBalance, err = NewTokenNftInfoQuery().SetNftID(nftID2.Nft(serials[1])).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, env.OperatorID, nftBalance[0].AccountID)
}

func TestIntegrationTokenRejectTransactionReceiverSigRequired(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create nft with treasury with receiver sig required
	treasuryKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	accountCreateFrozen, err := NewAccountCreateTransaction().
		SetKey(treasuryKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(0)).
		SetReceiverSignatureRequired(true).
		SetMaxAutomaticTokenAssociations(100).FreezeWith(env.Client)
	require.NoError(t, err)
	accountCreate, err := accountCreateFrozen.Sign(treasuryKey).Execute(env.Client)
	receipt, err := accountCreate.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	treasury := *receipt.AccountID

	nftID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetTreasuryAccountID(treasury).FreezeWith(env.Client)
		transaction.Sign(treasuryKey)
	})
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// transfer nft to the receiver
	frozenTransfer, err := NewTransferTransaction().
		AddNftTransfer(nftID.Nft(serials[0]), treasury, receiver).
		AddNftTransfer(nftID.Nft(serials[1]), treasury, receiver).
		FreezeWith(env.Client)
	require.NoError(t, err)
	transfer, err := frozenTransfer.Sign(treasuryKey).Execute(env.Client)
	_, err = transfer.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetNftIDs(nftID.Nft(serials[1])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance is decremented by 1
	tokenBalance, err := NewAccountBalanceQuery().SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1), tokenBalance.Tokens.Get(nftID))

	// verify the token is transferred back to the treasury
	nftBalance, err := NewTokenNftInfoQuery().SetNftID(nftID.Nft(serials[1])).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, treasury, nftBalance[0].AccountID)

	// same test for fungible token

	// create fungible token with treasury with receiver sig required
	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetTreasuryAccountID(treasury).FreezeWith(env.Client)
		transaction.Sign(treasuryKey)
	})
	require.NoError(t, err)

	// transfer ft to the receiver
	frozenTransfer, err = NewTransferTransaction().
		AddTokenTransfer(tokenID, treasury, -10).
		AddTokenTransfer(tokenID, receiver, 10).
		FreezeWith(env.Client)
	transfer, err = frozenTransfer.Sign(treasuryKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = transfer.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token
	frozenTxn, err = NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err = frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the balance of the receiver is 0
	tokenBalance, err = NewAccountBalanceQuery().SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	assert.Zero(t, tokenBalance.Tokens.Get(tokenID))

	// verify the tokens are transferred back to the treasury
	tokenBalance, err = NewAccountBalanceQuery().SetAccountID(treasury).Execute(env.Client)
	require.NoError(t, err)
	assert.Equal(t, uint64(1_000_000), tokenBalance.Tokens.Get(tokenID))

}

func TestIntegrationTokenRejectTransactionTokenFrozen(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create nft with treasury
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// transfer nft to the receiver
	tx, err := NewTransferTransaction().
		AddNftTransfer(nftID.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// freeze the token
	tokenFreeze, err := NewTokenFreezeTransaction().SetTokenID(nftID).SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	_, err = tokenFreeze.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token - should fail with ACCOUNT_FROZEN_FOR_TOKEN
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetNftIDs(nftID.Nft(serials[1])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "ACCOUNT_FROZEN_FOR_TOKEN")

	// same test with fungible token

	// create fungible token with treasury
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// transfer ft to the receiver
	tx, err = NewTransferTransaction().
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// freeze the token
	tokenFreeze, err = NewTokenFreezeTransaction().SetTokenID(tokenID).SetAccountID(receiver).Execute(env.Client)
	require.NoError(t, err)
	_, err = tokenFreeze.SetValidateStatus(true).GetReceipt(env.Client)

	// reject the token - should fail with ACCOUNT_FROZEN_FOR_TOKEN
	frozenTxn, err = NewTokenRejectTransaction().
		SetOwnerID(receiver).
		AddTokenID(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err = frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "ACCOUNT_FROZEN_FOR_TOKEN")

}

func TestIntegrationTokenRejectTransactionTokenPaused(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create nft with treasury
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// transfer nft to the receiver
	tx, err := NewTransferTransaction().
		AddNftTransfer(nftID.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// pause the token
	tokenPause, err := NewTokenPauseTransaction().SetTokenID(nftID).Execute(env.Client)
	require.NoError(t, err)
	_, err = tokenPause.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token - should fail with TOKEN_IS_PAUSED
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetNftIDs(nftID.Nft(serials[1])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_IS_PAUSED")

	// same test with fungible token

	// create fungible token with treasury
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// transfer ft to the receiver
	tx, err = NewTransferTransaction().
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// pause the token
	tokenPause, err = NewTokenPauseTransaction().SetTokenID(tokenID).Execute(env.Client)
	require.NoError(t, err)
	_, err = tokenPause.SetValidateStatus(true).GetReceipt(env.Client)

	// reject the token - should fail with TOKEN_IS_PAUSED
	frozenTxn, err = NewTokenRejectTransaction().
		SetOwnerID(receiver).
		AddTokenID(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err = frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_IS_PAUSED")
}

func TestIntegrationTokenRejectTransactionDoesNotRemoveAllowanceFT(t *testing.T) {
	t.Skip("Skipping test as this flow is currently not working as expected in services")
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create fungible token with treasury
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)
	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)
	// create spender account to be approved
	spender, spenderKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// transfer ft to the receiver
	tx, err := NewTransferTransaction().
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// approve allowance to the spender
	frozenApprove, err := NewAccountAllowanceApproveTransaction().
		ApproveTokenAllowance(tokenID, receiver, spender, 10).FreezeWith(env.Client)
	require.NoError(t, err)
	approve, err := frozenApprove.Sign(key).Execute(env.Client)
	require.NoError(t, err)
	_, err = approve.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the spender has allowance
	env.Client.SetOperator(spender, spenderKey)
	frozenTx, err := NewTransferTransaction().
		AddApprovedTokenTransfer(tokenID, receiver, -5, true).
		AddTokenTransfer(tokenID, spender, 5).
		FreezeWith(env.Client)
	require.NoError(t, err)
	transfer, err := frozenTx.SignWith(spenderKey.PublicKey(), spenderKey.Sign).Execute(env.Client)
	require.NoError(t, err)
	_, err = transfer.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	env.Client.SetOperator(env.OperatorID, env.OperatorKey)

	// reject the token
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		AddTokenID(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the allowance - should be 0 , because the receiver is no longer the owner
	env.Client.SetOperator(spender, spenderKey)
	frozenTx, err = NewTransferTransaction().
		AddApprovedTokenTransfer(tokenID, receiver, -5, true).
		AddTokenTransfer(tokenID, spender, 5).FreezeWith(env.Client)
	tx, err = frozenTx.Sign(spenderKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INSUFFICIENT_TOKEN_BALANCE")
	env.Client.SetOperator(env.OperatorID, env.OperatorKey)

	// transfer ft to the back to the receiver
	tx, err = NewTransferTransaction().
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the spender has allowance
	env.Client.SetOperator(spender, spenderKey)
	frozenTx, err = NewTransferTransaction().
		AddApprovedTokenTransfer(tokenID, receiver, -5, true).
		AddTokenTransfer(tokenID, spender, 5).
		FreezeWith(env.Client)
	require.NoError(t, err)
	transfer, err = frozenTx.SignWith(spenderKey.PublicKey(), spenderKey.Sign).Execute(env.Client)
	require.NoError(t, err)
	_, err = transfer.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func TestIntegrationTokenRejectTransactionDoesNotRemoveAllowanceNFT(t *testing.T) {
	t.Skip("Skipping test as this flow is currently not working as expected in services")
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)
	// create spender account to be approved
	spender, spenderKey, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)
	// create nft with treasury
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(mintMetadata).Execute(env.Client)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// transfer nfts to the receiver
	tx, err := NewTransferTransaction().
		AddNftTransfer(nftID.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[2]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[3]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// approve allowance to the spender
	frozenApprove, err := NewAccountAllowanceApproveTransaction().
		ApproveTokenNftAllowance(nftID.Nft(serials[0]), receiver, spender).
		ApproveTokenNftAllowance(nftID.Nft(serials[1]), receiver, spender).
		FreezeWith(env.Client)
	require.NoError(t, err)
	approve, err := frozenApprove.Sign(key).Execute(env.Client)
	require.NoError(t, err)
	_, err = approve.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the spender has allowance
	env.Client.SetOperator(spender, spenderKey)
	frozenTx, err := NewTransferTransaction().
		AddApprovedNftTransfer(nftID.Nft(serials[0]), receiver, spender, true).
		FreezeWith(env.Client)
	require.NoError(t, err)
	transfer, err := frozenTx.SignWith(spenderKey.PublicKey(), spenderKey.Sign).Execute(env.Client)
	require.NoError(t, err)
	_, err = transfer.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	env.Client.SetOperator(env.OperatorID, env.OperatorKey)

	// reject the token
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetNftIDs(nftID.Nft(serials[1]), nftID.Nft(serials[2]), nftID.Nft(serials[3])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the allowance - should be 0 , because the receiver is no longer the owner
	env.Client.SetOperator(spender, spenderKey)
	frozenTx, err = NewTransferTransaction().
		AddApprovedNftTransfer(nftID.Nft(serials[1]), receiver, spender, true).
		FreezeWith(env.Client)
	tx, err = frozenTx.Sign(spenderKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "SPENDER_DOES_NOT_HAVE_ALLOWANCE")
	env.Client.SetOperator(env.OperatorID, env.OperatorKey)

	// transfer nfts to the back to the receiver
	tx, err = NewTransferTransaction().
		AddNftTransfer(nftID.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[2]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[3]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// verify the spender has allowance
	env.Client.SetOperator(spender, spenderKey)
	frozenTx, err = NewTransferTransaction().
		AddApprovedNftTransfer(nftID.Nft(serials[1]), receiver, spender, true).
		FreezeWith(env.Client)
	require.NoError(t, err)
	transfer, err = frozenTx.SignWith(spenderKey.PublicKey(), spenderKey.Sign).Execute(env.Client)
	require.NoError(t, err)
	_, err = transfer.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func TestIntegrationTokenRejectTransactionFailsWhenRejectingNFTWithTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create nft with treasury
	nftID, err := createNft(&env)
	require.NoError(t, err)
	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(mintMetadata).Execute(env.Client)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// transfer nfts to the receiver
	tx, err := NewTransferTransaction().
		AddNftTransfer(nftID.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[2]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the whole collection - should fail
	frozenTxn, err := NewTokenRejectTransaction().SetOwnerID(receiver).AddTokenID(nftID).FreezeWith(env.Client)
	require.NoError(t, err)
	resp, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON")
}

func TestIntegrationTokenRejectTransactionFailsWithTokenReferenceRepeated(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create fungible token with treasury
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// transfer ft to the receiver
	tx, err := NewTransferTransaction().
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token with duplicate token id - should fail with TOKEN_REFERENCE_REPEATED
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetTokenIDs(tokenID, tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTxn.Sign(key).Execute(env.Client)
	require.ErrorContains(t, err, "TOKEN_REFERENCE_REPEATED")

	// same test for nft

	// create nft with treasury
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// transfer nft to the receiver
	tx, err = NewTransferTransaction().
		AddNftTransfer(nftID.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the nft with duplicate nft id - should fail with TOKEN_REFERENCE_REPEATED
	frozenTxn, err = NewTokenRejectTransaction().SetOwnerID(receiver).SetNftIDs(nftID.Nft(serials[0]), nftID.Nft(serials[0])).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTxn.Sign(key).Execute(env.Client)
	require.ErrorContains(t, err, "TOKEN_REFERENCE_REPEATED")
}

func TestIntegrationTokenRejectTransactionFailsWhenOwnerHasNoBalance(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create fungible token with treasury
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)
	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// skip the transfer
	// associate the receiver
	frozenAssociate, err := NewTokenAssociateTransaction().
		SetAccountID(receiver).
		AddTokenID(tokenID).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenAssociate.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	// reject the token - should fail with INSUFFICIENT_TOKEN_BALANCE
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	tx, err := frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INSUFFICIENT_TOKEN_BALANCE")

	// same test for nft

	// create nft with treasury
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// skip the transfer
	// associate the receiver
	frozenAssociate, err = NewTokenAssociateTransaction().
		SetAccountID(receiver).
		AddTokenID(nftID).FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenAssociate.Sign(key).Execute(env.Client)
	require.NoError(t, err)

	// reject the nft - should fail with INVALID_OWNER_ID
	frozenTxn, err = NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetNftIDs(nftID.Nft(serials[0])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	tx, err = frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_OWNER_ID")

}

func TestIntegrationTokenRejectTransactionFailsTreasuryRejects(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create fungible token with treasury
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// skip the transfer
	// reject the token with the treasury - should fail with ACCOUNT_IS_TREASURY
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(env.OperatorID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	tx, err := frozenTxn.Sign(env.OperatorKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "ACCOUNT_IS_TREASURY")

	// same test for nft

	// create nft with treasury
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// skip the transfer
	// reject the nft with the treasury - should fail with ACCOUNT_IS_TREASURY
	frozenTxn, err = NewTokenRejectTransaction().
		SetOwnerID(env.OperatorID).
		SetNftIDs(nftID.Nft(serials[0])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	tx, err = frozenTxn.Sign(env.OperatorKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "ACCOUNT_IS_TREASURY")
}

func TestIntegrationTokenRejectTransactionFailsWithInvalidToken(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// reject the token with invalid token - should fail with EMPTY_TOKEN_REFERENCE_LIST
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(env.OperatorID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	_, err = frozenTxn.Sign(env.OperatorKey).Execute(env.Client)
	require.ErrorContains(t, err, "EMPTY_TOKEN_REFERENCE_LIST")
}

func TestIntegrationTokenRejectTransactionFailsWithReferenceSizeExceeded(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create receiver account with auto associations
	receiver, key, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// create fungible token with treasury
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create nft with treasury
	nftID, err := createNft(&env)
	require.NoError(t, err)

	// mint
	mint, err := NewTokenMintTransaction().SetTokenID(nftID).SetMetadatas(mintMetadata).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	serials := receipt.SerialNumbers

	// transfer the tokens to the receiver
	tx, err := NewTransferTransaction().
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, receiver, 10).
		AddNftTransfer(nftID.Nft(serials[0]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[1]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[2]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[3]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[4]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[5]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[6]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[7]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[8]), env.Client.GetOperatorAccountID(), receiver).
		AddNftTransfer(nftID.Nft(serials[9]), env.Client.GetOperatorAccountID(), receiver).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token with 11 token references - should fail with TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetTokenIDs(tokenID).
		SetNftIDs(nftID.Nft(serials[0]), nftID.Nft(serials[1]),
			nftID.Nft(serials[2]), nftID.Nft(serials[3]),
			nftID.Nft(serials[4]), nftID.Nft(serials[5]),
			nftID.Nft(serials[6]), nftID.Nft(serials[7]),
			nftID.Nft(serials[8]), nftID.Nft(serials[9])).
		FreezeWith(env.Client)
	require.NoError(t, err)
	tx, err = frozenTxn.Sign(key).Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED")

}

func TestIntegrationTokenRejectTransactionFailsWithInvalidSignature(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// create fungible token with treasury
	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	// create receiver account with auto associations
	receiver, _, err := createAccount(&env, func(tx *AccountCreateTransaction) {
		tx.SetMaxAutomaticTokenAssociations(100)
	})
	require.NoError(t, err)

	// craete helper key
	otherKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// transfer ft to the receiver
	tx, err := NewTransferTransaction().
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, receiver, 10).
		Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// reject the token with different key - should fail with INVALID_SIGNATURE
	frozenTxn, err := NewTokenRejectTransaction().
		SetOwnerID(receiver).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)
	tx, err = frozenTxn.Sign(otherKey).Execute(env.Client)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_SIGNATURE")
}
// Filename: token_reject_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenRejectTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenAssociate := NewTokenRejectTransaction().
		SetOwnerID(accountID).
		SetTokenIDs(tokenID)

	err = tokenAssociate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenRejectTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenAssociate := NewTokenRejectTransaction().
		SetOwnerID(accountID).
		SetTokenIDs(tokenID)

	err = tokenAssociate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenRejectTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		key, _ := PrivateKeyFromStringEd25519("302e020100300506032b657004220420d45e1557156908c967804615af59a000be88c7aa7058bfcbe0f46b16c28f887d")
		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		require.Equal(t, bytes.Compare(sigMap.SigPair[1].PubKeyPrefix, key.PublicKey().BytesRaw()), 0)
		require.Equal(t, bytes.Compare(sigMap.SigPair[0].PubKeyPrefix, newKey.PublicKey().BytesRaw()), 0)

		if bod, ok := transactionBody.Data.(*services.TransactionBody_TokenAssociate); ok {
			require.Equal(t, bod.TokenAssociate.Account.GetAccountNum(), int64(123))
			require.Equal(t, bod.TokenAssociate.Tokens[0].TokenNum, int64(123))
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	freez, err := NewTokenRejectTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetOwnerID(AccountID{Account: 123}).
		SetTokenIDs(TokenID{Token: 123}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.
		Sign(newKey).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitTokenRejectTransactionGet(t *testing.T) {
	t.Parallel()

	tokenIDs := []TokenID{{Token: 3}, {Token: 5}, {Token: 7}}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenRejectTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(tokenIDs...).
		SetOwnerID(AccountID{Account: 7}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetOwnerID()
	transaction.GetTokenIDs()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenRejectTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenRejectTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetOwnerID()
	transaction.GetTokenIDs()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenRejectTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	tokenID2 := TokenID{Token: 4}
	tokenID3 := TokenID{Token: 3}
	accountID := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenRejectTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(tokenID, tokenID2, tokenID3).
		SetOwnerID(accountID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenReject()
	require.Equal(t, proto.Rejections[0].GetFungibleToken().String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.Rejections[1].GetFungibleToken().String(), tokenID2._ToProtobuf().String())
	require.Equal(t, proto.Rejections[2].GetFungibleToken().String(), tokenID3._ToProtobuf().String())
	require.Equal(t, proto.Owner.String(), accountID._ToProtobuf().String())
}

func TestUnitTokenRejectTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenRejectTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenIDs(token).
		AddTokenID(token).
		SetOwnerID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenIDs()
	transaction.GetOwnerID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenRejectTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}
// Filename: token_relationship.go
package hedera

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/pkg/errors"
	protobuf "google.golang.org/protobuf/proto"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// TokenRelationship is the information about a token relationship
type TokenRelationship struct {
	TokenID              TokenID
	Symbol               string
	Balance              uint64
	KycStatus            *bool
	FreezeStatus         *bool
	Decimals             uint32
	AutomaticAssociation bool
}

func _TokenRelationshipFromProtobuf(pb *services.TokenRelationship) *TokenRelationship {
	if pb == nil {
		return &TokenRelationship{}
	}

	tokenID := TokenID{}
	if pb.TokenId != nil {
		tokenID = *_TokenIDFromProtobuf(pb.TokenId)
	}

	return &TokenRelationship{
		TokenID:              tokenID,
		Symbol:               pb.Symbol,
		Balance:              pb.Balance,
		KycStatus:            _KycStatusFromProtobuf(pb.KycStatus),
		FreezeStatus:         _FreezeStatusFromProtobuf(pb.FreezeStatus),
		Decimals:             pb.Decimals,
		AutomaticAssociation: pb.AutomaticAssociation,
	}
}

func (relationship *TokenRelationship) _ToProtobuf() *services.TokenRelationship {
	var freezeStatus services.TokenFreezeStatus
	switch *relationship.FreezeStatus {
	case true:
		freezeStatus = 1
	case false:
		freezeStatus = 2
	default:
		freezeStatus = 0
	}

	var kycStatus services.TokenKycStatus
	switch *relationship.KycStatus {
	case true:
		kycStatus = 1
	case false:
		kycStatus = 2
	default:
		kycStatus = 0
	}

	return &services.TokenRelationship{
		TokenId:              relationship.TokenID._ToProtobuf(),
		Symbol:               relationship.Symbol,
		Balance:              relationship.Balance,
		KycStatus:            kycStatus,
		FreezeStatus:         freezeStatus,
		Decimals:             relationship.Decimals,
		AutomaticAssociation: relationship.AutomaticAssociation,
	}
}

func (relationship TokenRelationship) ToBytes() []byte {
	data, err := protobuf.Marshal(relationship._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

func _TokenRelationshipsFromProtobuf(rels []*services.TokenRelationship) []*TokenRelationship {
	tokenRelationships := make([]*TokenRelationship, 0)
	for _, tokenRelationship := range rels {
		tokenRelationships = append(tokenRelationships, _TokenRelationshipFromProtobuf(tokenRelationship))
	}
	return tokenRelationships
}

func TokenRelationshipFromBytes(data []byte) (*TokenRelationship, error) {
	if data == nil {
		return &TokenRelationship{}, errors.New("byte array can't be null")
	}
	pb := services.TokenRelationship{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return &TokenRelationship{}, err
	}

	return _TokenRelationshipFromProtobuf(&pb), nil
}
// Filename: token_revoke_kyc_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenRevokeKycTransaction
// Revokes KYC to the account for the given token. Must be signed by the Token's kycKey.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
// Once executed the Account is marked as KYC Revoked
type TokenRevokeKycTransaction struct {
	Transaction
	tokenID   *TokenID
	accountID *AccountID
}

// NewTokenRevokeKycTransaction creates TokenRevokeKycTransaction which
// revokes KYC to the account for the given token. Must be signed by the Token's kycKey.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
// Once executed the Account is marked as KYC Revoked
func NewTokenRevokeKycTransaction() *TokenRevokeKycTransaction {
	tx := TokenRevokeKycTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenRevokeKycTransactionFromProtobuf(transaction Transaction, pb *services.TransactionBody) *TokenRevokeKycTransaction {
	return &TokenRevokeKycTransaction{
		Transaction: transaction,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenRevokeKyc().GetToken()),
		accountID:   _AccountIDFromProtobuf(pb.GetTokenRevokeKyc().GetAccount()),
	}
}

// SetTokenID Sets the token for which this account will get his KYC revoked.
// If token does not exist, transaction results in INVALID_TOKEN_ID
func (tx *TokenRevokeKycTransaction) SetTokenID(tokenID TokenID) *TokenRevokeKycTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the token for which this account will get his KYC revoked.
func (tx *TokenRevokeKycTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// SetAccountID Sets the account to be KYC Revoked
func (tx *TokenRevokeKycTransaction) SetAccountID(accountID AccountID) *TokenRevokeKycTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetAccountID returns the AccountID that is being KYC Revoked
func (tx *TokenRevokeKycTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenRevokeKycTransaction) Sign(privateKey PrivateKey) *TokenRevokeKycTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenRevokeKycTransaction) SignWithOperator(client *Client) (*TokenRevokeKycTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenRevokeKycTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenRevokeKycTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenRevokeKycTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenRevokeKycTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenRevokeKycTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenRevokeKycTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenRevokeKycTransaction) Freeze() (*TokenRevokeKycTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenRevokeKycTransaction) FreezeWith(client *Client) (*TokenRevokeKycTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenRevokeKycTransaction.
func (tx *TokenRevokeKycTransaction) SetMaxTransactionFee(fee Hbar) *TokenRevokeKycTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenRevokeKycTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenRevokeKycTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenRevokeKycTransaction.
func (tx *TokenRevokeKycTransaction) SetTransactionMemo(memo string) *TokenRevokeKycTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenRevokeKycTransaction.
func (tx *TokenRevokeKycTransaction) SetTransactionValidDuration(duration time.Duration) *TokenRevokeKycTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenRevokeKycTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenRevokeKycTransaction.
func (tx *TokenRevokeKycTransaction) SetTransactionID(transactionID TransactionID) *TokenRevokeKycTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenRevokeKycTransaction.
func (tx *TokenRevokeKycTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenRevokeKycTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenRevokeKycTransaction) SetMaxRetry(count int) *TokenRevokeKycTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenRevokeKycTransaction) SetMaxBackoff(max time.Duration) *TokenRevokeKycTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenRevokeKycTransaction) SetMinBackoff(min time.Duration) *TokenRevokeKycTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenRevokeKycTransaction) SetLogLevel(level LogLevel) *TokenRevokeKycTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenRevokeKycTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenRevokeKycTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenRevokeKycTransaction) getName() string {
	return "TokenRevokeKycTransaction"
}

func (tx *TokenRevokeKycTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenRevokeKycTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenRevokeKyc{
			TokenRevokeKyc: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenRevokeKycTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenRevokeKyc{
			TokenRevokeKyc: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenRevokeKycTransaction) buildProtoBody() *services.TokenRevokeKycTransactionBody {
	body := &services.TokenRevokeKycTransactionBody{}
	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	if tx.accountID != nil {
		body.Account = tx.accountID._ToProtobuf()
	}

	return body
}

func (tx *TokenRevokeKycTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().RevokeKycFromTokenAccount,
	}
}

func (tx *TokenRevokeKycTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_revoke_kyc_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenRevokeKycTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenRevokeKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenRevokeKycTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTokenRevokeKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_TOKEN_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenRevokeKycTransactionNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTokenRevokeKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_ACCOUNT_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}
// Filename: token_revoke_kys_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenRevokeKycTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenRevokeKyc := NewTokenRevokeKycTransaction().
		SetAccountID(accountID).
		SetTokenID(tokenID)

	err = tokenRevokeKyc.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenRevokeKycTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenRevokeKyc := NewTokenRevokeKycTransaction().
		SetAccountID(accountID).
		SetTokenID(tokenID)

	err = tokenRevokeKyc.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenRevokeKycTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenRevokeKycTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAccountID(AccountID{Account: 7}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenRevokeKycTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenRevokeKycTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenRevokeKycTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	accountID := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenRevokeKycTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenRevokeKyc()
	require.Equal(t, proto.Token.String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.Account.String(), accountID._ToProtobuf().String())
}

func TestUnitTokenRevokeKycTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenRevokeKycTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(token).
		SetAccountID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenID()
	transaction.GetAccountID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenRevokeKycTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenRevokeKycTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}

	freez, err := NewTokenRevokeKycTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		SetAccountID(account).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: token_supply_type.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import "fmt"

type TokenSupplyType int32

const (
	TokenSupplyTypeInfinite TokenSupplyType = 0
	TokenSupplyTypeFinite   TokenSupplyType = 1
)

// String returns a string representation of the TokenSupplyType
func (tokenSupplyType TokenSupplyType) String() string {
	switch tokenSupplyType {
	case TokenSupplyTypeInfinite:
		return "TOKEN_SUPPLY_TYPE_INFINITE"
	case TokenSupplyTypeFinite:
		return "TOKEN_SUPPLY_TYPE_FINITE"
	}

	panic(fmt.Sprintf("unreachable: TokenType.String() switch statement is non-exhaustive. Status: %v", uint32(tokenSupplyType)))
}
// Filename: token_transfer.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// TokenTransfer is a token transfer record.
type TokenTransfer struct {
	AccountID  AccountID
	Amount     int64
	IsApproved bool
}

type _TokenTransfers struct {
	transfers []TokenTransfer
}

// NewTokenTransfer creates a TokenTransfer with the given accountID and amount
func NewTokenTransfer(accountID AccountID, amount int64) TokenTransfer {
	return TokenTransfer{
		AccountID: accountID,
		Amount:    amount,
	}
}

func _TokenTransferFromProtobuf(pb *services.AccountAmount) TokenTransfer {
	if pb == nil {
		return TokenTransfer{}
	}

	accountID := AccountID{}
	if pb.AccountID != nil {
		accountID = *_AccountIDFromProtobuf(pb.AccountID)
	}

	return TokenTransfer{
		AccountID:  accountID,
		Amount:     pb.Amount,
		IsApproved: pb.IsApproval,
	}
}

func (transfer *TokenTransfer) _ToProtobuf() *services.AccountAmount {
	return &services.AccountAmount{
		AccountID:  transfer.AccountID._ToProtobuf(),
		Amount:     transfer.Amount,
		IsApproval: transfer.IsApproved,
	}
}

// ToBytes returns a protobuf encoded version of the TokenTransfer
func (transfer TokenTransfer) ToBytes() []byte {
	data, err := protobuf.Marshal(transfer._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TokenTransferFromBytes returns a TokenTransfer struct from a protobuf encoded byte array
func TokenTransferFromBytes(data []byte) (TokenTransfer, error) {
	if data == nil {
		return TokenTransfer{}, errByteArrayNull
	}
	pb := services.AccountAmount{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TokenTransfer{}, err
	}

	return _TokenTransferFromProtobuf(&pb), nil
}

func (transfer TokenTransfer) String() string {
	return fmt.Sprintf("accountID: %s, amount: %d", transfer.AccountID.String(), transfer.Amount)
}

func (transfers _TokenTransfers) Len() int {
	return len(transfers.transfers)
}
func (transfers _TokenTransfers) Swap(i, j int) {
	transfers.transfers[i], transfers.transfers[j] = transfers.transfers[j], transfers.transfers[i]
}

func (transfers _TokenTransfers) Less(i, j int) bool {
	if transfers.transfers[i].AccountID.Compare(transfers.transfers[j].AccountID) < 0 { //nolint
		return true
	}

	return false
}
// Filename: token_transfer_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenTransferTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, accountID, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	_, err = NewAccountBalanceQuery().
		SetAccountID(env.Client.GetOperatorAccountID()).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	// TODO assert.Contains(t, balance.Tokens.balances, tokenID.String())
	// TODO amount := balance.Tokens.balances[tokenID.String()]
	// TODO assert.Equal(t, uint64(999990), amount, "token transfer transaction failed")
	resp, err = NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetAmount(10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenTransferTransactionNotZeroSum(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	nodeID := resp.NodeID

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN received for transaction %s", resp2.TransactionID), err.Error())
	}

	resp, err = NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetAmount(10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func DisabledTestIntegrationNftTransferTransaction(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	metaData := [][]byte{{50}, {50}}

	mint, err := NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetMetadatas(metaData).
		Execute(env.Client)
	require.NoError(t, err)

	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[0]), env.OperatorID, accountID).
		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[1]), env.OperatorID, accountID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenNftInfoQuery().
		SetNftID(tokenID.Nft(mintReceipt.SerialNumbers[0])).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, accountID.String(), info[0].AccountID.String())

	info, err = NewTokenNftInfoQuery().
		SetNftID(tokenID.Nft(mintReceipt.SerialNumbers[1])).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, accountID.String(), info[0].AccountID.String())

	resp, err = NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetSerialNumbers(mintReceipt.SerialNumbers).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenFeeScheduleUpdateRecursionDepthTransaction(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(10)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFixedFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &env.OperatorID,
		},
		Amount:              100000000,
		DenominationTokenID: nil,
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{customFee}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transferTx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID, accountID, -1).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), 1).
		FreezeWith(env.Client)
	require.NoError(t, err)

	transferTx.Sign(newKey)

	resp, err = transferTx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH", err.Error())
	}
}

func TestIntegrationTokenFeeScheduleUpdateHugeAmountTransaction(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFixedFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &env.OperatorID,
		},
		Amount:              1000,
		DenominationTokenID: nil,
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{customFee}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transferTx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -5).
		AddTokenTransfer(tokenID, accountID, 5).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transferTx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenFeeScheduleUpdateHugeAmountOneTransaction(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	resp, err = NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID2 := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := CustomFixedFee{
		CustomFee: CustomFee{
			FeeCollectorAccountID: &accountID2,
		},
		Amount:              1000,
		DenominationTokenID: nil,
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{customFee}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transferTx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -5).
		AddTokenTransfer(tokenID, accountID, 5).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transferTx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func TestIntegrationNftTransferTransactionAccountAmountTransfersOnlyForFungibleCommon(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, accountID, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON", err.Error())
	}

	resp, err = NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetAmount(10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_WIPING_AMOUNT", err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func DisabledTestIntegrationNftAccountStillOwnsNfts(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	metaData := [][]byte{{50}, {50}}

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	mint, err := NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetMetadatas(metaData).
		Execute(env.Client)
	require.NoError(t, err)

	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[0]), env.OperatorID, accountID).
		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[1]), env.OperatorID, accountID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenNftInfoQuery().
		ByNftID(tokenID.Nft(mintReceipt.SerialNumbers[0])).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, accountID.String(), info[0].AccountID.String())

	info, err = NewTokenNftInfoQuery().
		ByNftID(tokenID.Nft(mintReceipt.SerialNumbers[1])).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, accountID.String(), info[0].AccountID.String())

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func TestIntegrationTokenFeeScheduleUpdateTokenNotAssociatedToFeeCollector(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey()).
			SetFeeScheduleKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees([]Fee{NewCustomFixedFee().
			SetFeeCollectorAccountID(accountID).
			SetAmount(1).
			SetDenominatingTokenToSameToken()}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INVALID_TOKEN_ID_IN_CUSTOM_FEES", err.Error())
	}
}

func DisabledTestIntegrationTokenFeeScheduleUpdateCustomFeeChargingExceededMax(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	resp, err = NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID2 := *receipt.AccountID

	resp, err = NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID3 := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	tokenID2, err := createFungibleToken(&env)
	require.NoError(t, err)

	tokenID3, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transaction, err = NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID2).
		SetTokenIDs(tokenID2).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transaction, err = NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID3).
		SetTokenIDs(tokenID3).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee := NewCustomFixedFee().SetDenominatingTokenToSameToken().SetAmount(1).SetFeeCollectorAccountID(accountID)

	feeArray := make([]Fee, 0)

	for i := 0; i < 10; i++ {
		feeArray = append(feeArray, customFee)
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID).
		SetCustomFees(feeArray).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee2 := NewCustomFixedFee().SetDenominatingTokenToSameToken().SetAmount(1).SetFeeCollectorAccountID(accountID2)

	feeArray2 := make([]Fee, 0)

	for i := 0; i < 10; i++ {
		feeArray2 = append(feeArray2, customFee2)
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID2).
		SetCustomFees(feeArray2).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	customFee3 := NewCustomFixedFee().SetDenominatingTokenToSameToken().SetAmount(1).SetFeeCollectorAccountID(accountID3)

	feeArray3 := make([]Fee, 0)

	for i := 0; i < 10; i++ {
		feeArray3 = append(feeArray3, customFee3)
	}

	resp, err = NewTokenFeeScheduleUpdateTransaction().
		SetTokenID(tokenID3).
		SetCustomFees(feeArray3).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID2).
		SetTokenID(tokenID2).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID3).
		SetTokenID(tokenID3).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transferTx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID3, env.Client.GetOperatorAccountID(), -1).
		AddTokenTransfer(tokenID, accountID, 1).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -1).
		AddTokenTransfer(tokenID2, accountID2, 1).
		AddTokenTransfer(tokenID2, env.Client.GetOperatorAccountID(), -1).
		AddTokenTransfer(tokenID3, accountID3, 1).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transferTx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}
// Filename: token_transfer_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	protobuf "google.golang.org/protobuf/proto"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenTransferTransactionTransfers(t *testing.T) {
	t.Parallel()

	amount := NewHbar(1)
	accountID1 := AccountID{Account: 3}
	accountID2 := AccountID{Account: 4}
	tokenID1 := TokenID{Token: 5}
	tokenID2 := TokenID{Token: 6}
	tokenID3 := TokenID{Token: 7}
	tokenID4 := TokenID{Token: 8}
	nftID1 := NftID{TokenID: tokenID3, SerialNumber: 9}
	nftID2 := NftID{TokenID: tokenID4, SerialNumber: 10}

	transactionID := TransactionIDGenerate(AccountID{Account: 1111})

	tokenTransfer := NewTransferTransaction().
		AddHbarTransfer(accountID1, amount).
		AddHbarTransfer(accountID2, amount.Negated()).
		AddTokenTransfer(tokenID1, accountID1, 10).
		AddTokenTransfer(tokenID1, accountID2, -10).
		AddTokenTransfer(tokenID2, accountID1, 10).
		AddTokenTransfer(tokenID2, accountID2, -10).
		SetTransactionID(transactionID).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddNftTransfer(nftID1, accountID1, accountID2).
		AddNftTransfer(nftID2, accountID2, accountID1).
		build()

	require.ElementsMatch(t, tokenTransfer.GetCryptoTransfer().Transfers.AccountAmounts, []*services.AccountAmount{
		{
			AccountID: accountID1._ToProtobuf(),
			Amount:    amount.AsTinybar(),
		},
		{
			AccountID: accountID2._ToProtobuf(),
			Amount:    amount.Negated().AsTinybar(),
		},
	})

	require.ElementsMatch(t, tokenTransfer.GetCryptoTransfer().TokenTransfers, []*services.TokenTransferList{
		{
			Token: tokenID1._ToProtobuf(),
			Transfers: []*services.AccountAmount{
				{
					AccountID: accountID1._ToProtobuf(),
					Amount:    10,
				},
				{
					AccountID: accountID2._ToProtobuf(),
					Amount:    -10,
				},
			}},
		{
			Token: tokenID2._ToProtobuf(),
			Transfers: []*services.AccountAmount{
				{
					AccountID: accountID1._ToProtobuf(),
					Amount:    10,
				},
				{
					AccountID: accountID2._ToProtobuf(),
					Amount:    -10,
				},
			}},
		{
			Token: tokenID3._ToProtobuf(),
			NftTransfers: []*services.NftTransfer{
				{
					SenderAccountID:   accountID1._ToProtobuf(),
					ReceiverAccountID: accountID2._ToProtobuf(),
					SerialNumber:      int64(9),
				},
			},
		},
		{
			Token: tokenID4._ToProtobuf(),
			NftTransfers: []*services.NftTransfer{
				{
					SenderAccountID:   accountID2._ToProtobuf(),
					ReceiverAccountID: accountID1._ToProtobuf(),
					SerialNumber:      int64(10),
				},
			},
		},
	})
}

func TestUnitTokenTransferTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	nftID, err := NftIDFromString("2@0.0.123-esxsf")
	require.NoError(t, err)

	tokenTransfer := NewTransferTransaction().
		AddTokenTransfer(tokenID, accountID, 1).
		AddNftTransfer(nftID, accountID, accountID)

	err = tokenTransfer.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenTransferTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	nftID, err := NftIDFromString("2@0.0.123-rmkykd")
	require.NoError(t, err)

	tokenTransfer := NewTransferTransaction().
		AddTokenTransfer(tokenID, accountID, 1).
		AddNftTransfer(nftID, accountID, accountID)

	err = tokenTransfer.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTransferTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	accountID := AccountID{Account: 3}
	nftID := tokenID.Nft(32)

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTransferTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetHbarTransferApproval(accountID, true).
		SetTokenTransferApproval(tokenID, accountID, true).
		SetNftTransferApproval(nftID, true).
		AddHbarTransfer(accountID, NewHbar(34)).
		AddTokenTransferWithDecimals(tokenID, accountID, 123, 12).
		AddTokenTransfer(tokenID, accountID, 123).
		AddNftTransfer(nftID, accountID, accountID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetHbarTransfers()
	transaction.GetTokenTransfers()
	transaction.GetNftTransfers()
	transaction.GetTokenIDDecimals()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTransferTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTransferTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetHbarTransfers()
	transaction.GetTokenTransfers()
	transaction.GetNftTransfers()
	transaction.GetTokenIDDecimals()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTransferTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	freez, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}

func TestUnitTokenTransferEncodeDecode(t *testing.T) {
	transfer := NewTokenTransfer(AccountID{Account: 5}, 123)
	decoded, err := TokenTransferFromBytes(transfer.ToBytes())

	require.NoError(t, err)
	require.Equal(t, transfer, decoded)
}
// Filename: token_type.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import "fmt"

type TokenType uint32

const (
	TokenTypeFungibleCommon    TokenType = 0
	TokenTypeNonFungibleUnique TokenType = 1
)

// String returns a string representation of the TokenType
func (tokenType TokenType) String() string {
	switch tokenType {
	case TokenTypeFungibleCommon:
		return "TOKEN_TYPE_FUNGIBLE_COMMON"
	case TokenTypeNonFungibleUnique:
		return "TOKEN_TYPE_NON_FUNGIBLE_UNIQUE"
	}

	panic(fmt.Sprintf("unreachable: TokenType.String() switch statement is non-exhaustive. Status: %v", uint32(tokenType)))
}
// Filename: token_unfreeze_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenUnfreezeTransaction
// Unfreezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
// Once executed the Account is marked as Unfrozen and will be able to receive or send tokens. The
// operation is idempotent.
type TokenUnfreezeTransaction struct {
	Transaction
	tokenID   *TokenID
	accountID *AccountID
}

// NewTokenUnfreezeTransaction creates TokenUnfreezeTransaction which
// unfreezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
// Once executed the Account is marked as Unfrozen and will be able to receive or send tokens. The
// operation is idempotent.
func NewTokenUnfreezeTransaction() *TokenUnfreezeTransaction {
	tx := TokenUnfreezeTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenUnfreezeTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenUnfreezeTransaction {
	return &TokenUnfreezeTransaction{
		Transaction: tx,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenUnfreeze().GetToken()),
		accountID:   _AccountIDFromProtobuf(pb.GetTokenUnfreeze().GetAccount()),
	}
}

// SetTokenID Sets the token for which this account will be unfrozen.
// If token does not exist, transaction results in INVALID_TOKEN_ID
func (tx *TokenUnfreezeTransaction) SetTokenID(tokenID TokenID) *TokenUnfreezeTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the token for which this account will be unfrozen.
func (tx *TokenUnfreezeTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// SetAccountID Sets the account to be unfrozen
func (tx *TokenUnfreezeTransaction) SetAccountID(accountID AccountID) *TokenUnfreezeTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetAccountID returns the account to be unfrozen
func (tx *TokenUnfreezeTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenUnfreezeTransaction) Sign(privateKey PrivateKey) *TokenUnfreezeTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenUnfreezeTransaction) SignWithOperator(client *Client) (*TokenUnfreezeTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenUnfreezeTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenUnfreezeTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenUnfreezeTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenUnfreezeTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenUnfreezeTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenUnfreezeTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenUnfreezeTransaction) Freeze() (*TokenUnfreezeTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenUnfreezeTransaction) FreezeWith(client *Client) (*TokenUnfreezeTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenUnfreezeTransaction.
func (tx *TokenUnfreezeTransaction) SetMaxTransactionFee(fee Hbar) *TokenUnfreezeTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenUnfreezeTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenUnfreezeTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenUnfreezeTransaction.
func (tx *TokenUnfreezeTransaction) SetTransactionMemo(memo string) *TokenUnfreezeTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenUnfreezeTransaction.
func (tx *TokenUnfreezeTransaction) SetTransactionValidDuration(duration time.Duration) *TokenUnfreezeTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenUnfreezeTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenUnfreezeTransaction.
func (tx *TokenUnfreezeTransaction) SetTransactionID(transactionID TransactionID) *TokenUnfreezeTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenUnfreezeTransaction.
func (tx *TokenUnfreezeTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenUnfreezeTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenUnfreezeTransaction) SetMaxRetry(count int) *TokenUnfreezeTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenUnfreezeTransaction) SetMaxBackoff(max time.Duration) *TokenUnfreezeTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenUnfreezeTransaction) SetMinBackoff(min time.Duration) *TokenUnfreezeTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenUnfreezeTransaction) SetLogLevel(level LogLevel) *TokenUnfreezeTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenUnfreezeTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenUnfreezeTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenUnfreezeTransaction) getName() string {
	return "TokenUnfreezeTransaction"
}

func (tx *TokenUnfreezeTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenUnfreezeTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenUnfreeze{
			TokenUnfreeze: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenUnfreezeTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenUnfreeze{
			TokenUnfreeze: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenUnfreezeTransaction) buildProtoBody() *services.TokenUnfreezeAccountTransactionBody {
	body := &services.TokenUnfreezeAccountTransactionBody{}
	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	if tx.accountID != nil {
		body.Account = tx.accountID._ToProtobuf()
	}

	return body
}

func (tx *TokenUnfreezeTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().UnfreezeTokenAccount,
	}
}
func (tx *TokenUnfreezeTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_unfreeze_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenUnfreezeTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenFreezeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenUnfreezeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUnfreezeTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenFreezeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTokenUnfreezeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_TOKEN_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUnfreezeTransactionNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenFreezeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTokenUnfreezeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_ACCOUNT_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}
// Filename: token_unfreeze_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenUnfreezeTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenUnfreeze := NewTokenUnfreezeTransaction().
		SetTokenID(tokenID).
		SetAccountID(accountID)

	err = tokenUnfreeze.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenUnfreezeTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenUnfreeze := NewTokenUnfreezeTransaction().
		SetTokenID(tokenID).
		SetAccountID(accountID)

	err = tokenUnfreeze.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenUnfreezeTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenUnfreezeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAccountID(AccountID{Account: 7}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenUnfreezeTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenUnfreezeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenUnfreezeTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenUnfreezeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(token).
		SetAccountID(account).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenID()
	transaction.GetAccountID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenUnfreezeTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenUnfreezeTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}

	freez, err := NewTokenUnfreezeTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		SetAccountID(account).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: token_unpause_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenUnpauseTransaction
// Unpauses the Token. Must be signed with the Token's pause key.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
// Once executed the Token is marked as Unpaused and can be used in Transactions.
// The operation is idempotent - becomes a no-op if the Token is already unpaused.
type TokenUnpauseTransaction struct {
	Transaction
	tokenID *TokenID
}

// NewTokenUnpauseTransaction creates TokenUnpauseTransaction which unpauses the Token.
// Must be signed with the Token's pause key.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
// Once executed the Token is marked as Unpaused and can be used in Transactions.
// The operation is idempotent - becomes a no-op if the Token is already unpaused.
func NewTokenUnpauseTransaction() *TokenUnpauseTransaction {
	tx := TokenUnpauseTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenUnpauseTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenUnpauseTransaction {
	return &TokenUnpauseTransaction{
		Transaction: tx,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenDeletion().GetToken()),
	}
}

// SetTokenID Sets the token to be unpaused.
func (tx *TokenUnpauseTransaction) SetTokenID(tokenID TokenID) *TokenUnpauseTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the TokenID of the token to be unpaused.
func (tx *TokenUnpauseTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenUnpauseTransaction) Sign(privateKey PrivateKey) *TokenUnpauseTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenUnpauseTransaction) SignWithOperator(client *Client) (*TokenUnpauseTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenUnpauseTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenUnpauseTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenUnpauseTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenUnpauseTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenUnpauseTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenUnpauseTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenUnpauseTransaction) Freeze() (*TokenUnpauseTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenUnpauseTransaction) FreezeWith(client *Client) (*TokenUnpauseTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenUnpauseTransaction.
func (tx *TokenUnpauseTransaction) SetMaxTransactionFee(fee Hbar) *TokenUnpauseTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenUnpauseTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenUnpauseTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenUnpauseTransaction.
func (tx *TokenUnpauseTransaction) SetTransactionMemo(memo string) *TokenUnpauseTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenUnpauseTransaction.
func (tx *TokenUnpauseTransaction) SetTransactionValidDuration(duration time.Duration) *TokenUnpauseTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenUnpauseTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenUnpauseTransaction.
func (tx *TokenUnpauseTransaction) SetTransactionID(transactionID TransactionID) *TokenUnpauseTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenUnpauseTransaction.
func (tx *TokenUnpauseTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenUnpauseTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenUnpauseTransaction) SetMaxRetry(count int) *TokenUnpauseTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenUnpauseTransaction) SetMaxBackoff(max time.Duration) *TokenUnpauseTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenUnpauseTransaction) SetMinBackoff(min time.Duration) *TokenUnpauseTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenUnpauseTransaction) SetLogLevel(level LogLevel) *TokenUnpauseTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenUnpauseTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenUnpauseTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenUnpauseTransaction) getName() string {
	return "TokenUnpauseTransaction"
}

func (tx *TokenUnpauseTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenUnpauseTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenUnpause{
			TokenUnpause: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenUnpauseTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) { //nolint
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenUnpause{
			TokenUnpause: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenUnpauseTransaction) buildProtoBody() *services.TokenUnpauseTransactionBody { //nolint
	body := &services.TokenUnpauseTransactionBody{}
	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	return body
}

func (tx *TokenUnpauseTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().DeleteToken,
	}
}
func (tx *TokenUnpauseTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_update_nfts_transaction.go
package hedera

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

type TokenUpdateNfts struct {
	Transaction
	tokenID       *TokenID
	serialNumbers []int64
	metadata      *[]byte
}

func NewTokenUpdateNftsTransaction() *TokenUpdateNfts {
	return &TokenUpdateNfts{
		Transaction: _NewTransaction(),
	}
}

func _NewTokenUpdateNftsTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenUpdateNfts {
	return &TokenUpdateNfts{
		Transaction:   tx,
		tokenID:       _TokenIDFromProtobuf(pb.GetTokenUpdateNfts().GetToken()),
		serialNumbers: append([]int64{}, pb.GetTokenUpdateNfts().GetSerialNumbers()...),
	}
}

// Getter for tokenID
func (t *TokenUpdateNfts) GetTokenID() *TokenID {
	return t.tokenID
}

// Setter for tokenID
func (t *TokenUpdateNfts) SetTokenID(tokenID TokenID) *TokenUpdateNfts {
	t._RequireNotFrozen()
	t.tokenID = &tokenID
	return t
}

// Getter for serialNumbers
func (t *TokenUpdateNfts) GetSerialNumbers() []int64 {
	return t.serialNumbers
}

// Setter for serialNumbers
func (t *TokenUpdateNfts) SetSerialNumbers(serialNumbers []int64) *TokenUpdateNfts {
	t._RequireNotFrozen()
	t.serialNumbers = serialNumbers
	return t
}

// Getter for metadata
func (t *TokenUpdateNfts) GetMetadata() *[]byte {
	return t.metadata
}

// Setter for metadata
func (t *TokenUpdateNfts) SetMetadata(metadata []byte) *TokenUpdateNfts {
	t._RequireNotFrozen()
	t.metadata = &metadata
	return t
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenUpdateNfts) Sign(privateKey PrivateKey) *TokenUpdateNfts {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenUpdateNfts) SignWithOperator(client *Client) (*TokenUpdateNfts, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenUpdateNfts) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenUpdateNfts {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenUpdateNfts) AddSignature(publicKey PublicKey, signature []byte) *TokenUpdateNfts {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenUpdateNfts) SetGrpcDeadline(deadline *time.Duration) *TokenUpdateNfts {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenUpdateNfts) Freeze() (*TokenUpdateNfts, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenUpdateNfts) FreezeWith(client *Client) (*TokenUpdateNfts, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenUpdateNfts.
func (tx *TokenUpdateNfts) SetMaxTransactionFee(fee Hbar) *TokenUpdateNfts {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenUpdateNfts) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenUpdateNfts {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenUpdateNfts.
func (tx *TokenUpdateNfts) SetTransactionMemo(memo string) *TokenUpdateNfts {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenUpdateNfts.
func (tx *TokenUpdateNfts) SetTransactionValidDuration(duration time.Duration) *TokenUpdateNfts {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenUpdateNfts) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenUpdateNfts.
func (tx *TokenUpdateNfts) SetTransactionID(transactionID TransactionID) *TokenUpdateNfts {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenUpdateNfts.
func (tx *TokenUpdateNfts) SetNodeAccountIDs(nodeID []AccountID) *TokenUpdateNfts {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenUpdateNfts) SetMaxRetry(count int) *TokenUpdateNfts {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenUpdateNfts) SetMaxBackoff(max time.Duration) *TokenUpdateNfts {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenUpdateNfts) SetMinBackoff(min time.Duration) *TokenUpdateNfts {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenUpdateNfts) SetLogLevel(level LogLevel) *TokenUpdateNfts {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenUpdateNfts) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenUpdateNfts) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

func (tx *TokenUpdateNfts) getName() string {
	return "TokenUpdateNfts"
}

func (tx *TokenUpdateNfts) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}
	return nil
}

func (tx *TokenUpdateNfts) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenUpdateNfts{
			TokenUpdateNfts: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenUpdateNfts) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenUpdateNfts{
			TokenUpdateNfts: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenUpdateNfts) buildProtoBody() *services.TokenUpdateNftsTransactionBody {
	body := &services.TokenUpdateNftsTransactionBody{}

	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}
	serialNumbers := make([]int64, 0)
	if len(tx.serialNumbers) != 0 {
		for _, serialNumber := range tx.serialNumbers {
			serialNumbers = append(serialNumbers, serialNumber)
			body.SerialNumbers = serialNumbers
		}
	}
	if tx.metadata != nil {
		body.Metadata = wrapperspb.Bytes(*tx.metadata)
	}
	return body
}

func (tx *TokenUpdateNfts) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().UpdateNfts,
	}
}

func (tx *TokenUpdateNfts) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_update_nfts_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

func TestTokenUpdateNftsUpdatesMetadata(t *testing.T) {
	env := NewIntegrationTestEnv(t)

	// create supply key
	supplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	supplyPublicKey := supplyKey.PublicKey()

	// create metadata key
	metadataKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	metadataPublicKey := metadataKey.PublicKey()

	nftCount := 4
	// create metadata list for all NFTs
	mintMetadata := generateNftMetadata([]byte{4, 2, 0}, nftCount)
	updatedMetadata := []byte{6, 9}
	// create updated metadata list  for all NFTs
	updatedMetadataList := generateNftMetadata(updatedMetadata, nftCount/2)

	// create token with metadata key
	tokenID := createTokenWithMetadataKey(t, &env, &metadataPublicKey, &supplyPublicKey)

	// mint tokens using the metadata list
	tokenMintTx, _ := NewTokenMintTransaction().
		SetMetadatas(mintMetadata).
		SetTokenID(tokenID).
		FreezeWith(env.Client)
	tx, err := tokenMintTx.Sign(supplyKey).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := tx.GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	// verify the metadata is set in the new tokens
	metadataListAfterMint := getMetadataList(t, &env, tokenID, nftSerials)

	assert.True(t, reflect.DeepEqual(metadataListAfterMint, mintMetadata), "metadata after minting should match initial metadata")

	// update nft metadata for half of the NFTs
	_, err = updateNftMetadata(t, &env, tokenID, nftSerials[:nftCount/2], updatedMetadata, &metadataKey)
	require.NoError(t, err)

	// verify the metadata is updated
	metadataListAfterUpdate := getMetadataList(t, &env, tokenID, nftSerials[:nftCount/2])
	assert.True(t, reflect.DeepEqual(metadataListAfterUpdate, updatedMetadataList), "updated metadata should match expected updated metadata")

	// verify the remaining NFTs' metadata is unchanged
	metadataList := getMetadataList(t, &env, tokenID, nftSerials[nftCount/2:])

	assert.True(t, reflect.DeepEqual(metadataList, mintMetadata[nftCount/2:]), "remaining NFTs' metadata should remain unchanged")
}

func TestCanUpdateEmptyNFTMetadata(t *testing.T) {
	env := NewIntegrationTestEnv(t)

	// create supply key
	supplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	supplyPublicKey := supplyKey.PublicKey()

	// Generate metadata key
	metadataKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	metadataPublicKey := metadataKey.PublicKey()

	nftCount := 4
	mintMetadata := generateNftMetadata([]byte{4, 2, 0}, nftCount)
	updatedMetadata := make([]byte, 0)
	updatedMetadataList := make([][]byte, 4)

	// Create a token with a metadata key
	tokenID := createTokenWithMetadataKey(t, &env, &metadataPublicKey, &supplyPublicKey)

	// Mint tokens
	tokenMintTx, _ := NewTokenMintTransaction().
		SetMetadatas(mintMetadata).
		SetTokenID(tokenID).
		FreezeWith(env.Client)
	tx, err := tokenMintTx.Sign(supplyKey).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := tx.GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	metadataListAfterMint := getMetadataList(t, &env, tokenID, nftSerials)
	assert.Equal(t, mintMetadata, metadataListAfterMint, "metadata after minting should match initial metadata")

	// Update metadata for all NFTs
	_, err = updateNftMetadata(t, &env, tokenID, nftSerials, updatedMetadata, &metadataKey)
	require.NoError(t, err)

	// Verify updated metadata for NFTs
	metadataListAfterUpdate := getMetadataList(t, &env, tokenID, nftSerials)
	assert.Equal(t, updatedMetadataList, metadataListAfterUpdate, "updated metadata should match expected updated metadata")
}

func TestCannotUpdateNFTMetadataWhenKeyIsNotSet(t *testing.T) {
	env := NewIntegrationTestEnv(t)

	// create supply key
	supplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	supplyPublicKey := supplyKey.PublicKey()

	// Generate metadata key
	metadataKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	nftCount := 4
	mintMetadata := generateNftMetadata([]byte{4, 2, 0}, nftCount)
	updatedMetadata := []byte{6, 9}

	// Create a token without a metadata key
	tokenID := createTokenWithMetadataKey(t, &env, nil, &supplyPublicKey)

	// Mint tokens
	tokenMintTx, _ := NewTokenMintTransaction().
		SetMetadatas(mintMetadata).
		SetTokenID(tokenID).
		FreezeWith(env.Client)
	tx, err := tokenMintTx.Sign(supplyKey).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := tx.GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	metadataListAfterMint := getMetadataList(t, &env, tokenID, nftSerials)
	assert.Equal(t, mintMetadata, metadataListAfterMint, "metadata after minting should match initial metadata")

	// Update metadata for the first half of the NFTs
	_, err = updateNftMetadata(t, &env, tokenID, nftSerials[:nftCount/2], updatedMetadata, &metadataKey)
	require.Error(t, err)
}

func TestCannotUpdateNFTMetadataWhenTransactionIsNotSignedWithMetadataKey(t *testing.T) {
	env := NewIntegrationTestEnv(t)

	// create supply key
	supplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	supplyPublicKey := supplyKey.PublicKey()

	// Generate metadata key
	metadataKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	metadataPublicKey := metadataKey.PublicKey()

	nftCount := 4
	mintMetadata := generateNftMetadata([]byte{4, 2, 0}, nftCount)
	updatedMetadata := []byte{6, 9}

	// Create a token with a metadata key
	tokenID := createTokenWithMetadataKey(t, &env, &metadataPublicKey, &supplyPublicKey)

	// Mint tokens
	tokenMintTx, _ := NewTokenMintTransaction().
		SetMetadatas(mintMetadata).
		SetTokenID(tokenID).
		FreezeWith(env.Client)
	tx, err := tokenMintTx.Sign(supplyKey).Execute(env.Client)
	require.NoError(t, err)
	receipt, err := tx.GetReceipt(env.Client)
	require.NoError(t, err)
	nftSerials := receipt.SerialNumbers

	// Assert this will fail
	_, err = updateNftMetadata(t, &env, tokenID, nftSerials, updatedMetadata, &env.OperatorKey)
	require.Error(t, err)

	_, err = updateNftMetadata(t, &env, tokenID, nftSerials, updatedMetadata, nil)
	require.Error(t, err)
}

// Utility functions
func createTokenWithMetadataKey(t *testing.T, env *IntegrationTestEnv, metadataKey *PublicKey, supplyKey *PublicKey) TokenID {
	var tokenCreateTx *TokenCreateTransaction
	if metadataKey == nil {
		tokenCreateTx = NewTokenCreateTransaction().
			SetNodeAccountIDs(env.NodeAccountIDs).
			SetTokenName("ffff").
			SetTokenSymbol("F").
			SetTokenType(TokenTypeNonFungibleUnique).
			SetTreasuryAccountID(env.Client.GetOperatorAccountID()).
			SetAdminKey(env.Client.GetOperatorPublicKey()).
			SetSupplyKey(supplyKey)
	} else {
		tokenCreateTx = NewTokenCreateTransaction().
			SetNodeAccountIDs(env.NodeAccountIDs).
			SetTokenName("ffff").
			SetTokenSymbol("F").
			SetTokenType(TokenTypeNonFungibleUnique).
			SetTreasuryAccountID(env.Client.GetOperatorAccountID()).
			SetAdminKey(env.Client.GetOperatorPublicKey()).
			SetSupplyKey(supplyKey).
			SetMetadataKey(metadataKey)
	}

	tx, err := tokenCreateTx.Execute(env.Client)
	require.NoError(t, err)

	receipt, err := tx.GetReceipt(env.Client)
	require.NoError(t, err)

	return *receipt.TokenID
}

func updateNftMetadata(t *testing.T, env *IntegrationTestEnv, tokenID TokenID, serials []int64, updatedMetadata []byte, metadataKey *PrivateKey) (*TransactionReceipt, error) {
	var tokenUpdateNftsTx *TokenUpdateNfts
	if metadataKey == nil {
		tokenUpdateNftsTx = NewTokenUpdateNftsTransaction().
			SetTokenID(tokenID).
			SetSerialNumbers(serials).
			SetMetadata(updatedMetadata)
	} else {
		frozenTx, err := NewTokenUpdateNftsTransaction().
			SetTokenID(tokenID).
			SetSerialNumbers(serials).
			SetMetadata(updatedMetadata).
			FreezeWith(env.Client)
		require.NoError(t, err)

		tokenUpdateNftsTx = frozenTx.Sign(*metadataKey)
	}

	tx, err := tokenUpdateNftsTx.Execute(env.Client)
	require.NoError(t, err)

	receipt, err := tx.GetReceipt(env.Client)

	return &receipt, err
}

func getMetadataList(t *testing.T, env *IntegrationTestEnv, tokenID TokenID, nftSerials []int64) [][]byte {
	var metadataList [][]byte

	for _, serial := range nftSerials {
		nftID := NftID{
			TokenID:      tokenID,
			SerialNumber: serial,
		}

		tokenNftInfoQuery := NewTokenNftInfoQuery().
			SetNodeAccountIDs(env.NodeAccountIDs).
			SetNftID(nftID)

		nftInfo, err := tokenNftInfoQuery.Execute(env.Client)
		require.NoError(t, err)
		metadataList = append(metadataList, nftInfo[0].Metadata)
	}

	return metadataList
}

func generateNftMetadata(data []byte, count int) [][]byte {
	var metadataList [][]byte

	for i := 0; i < count; i++ {
		metadataList = append(metadataList, data)
	}

	return metadataList
}
// Filename: token_update_nfts_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	protobuf "google.golang.org/protobuf/proto"
)

func TestUnitTokenUpdateNftsTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenUpdate := NewTokenUpdateNftsTransaction().
		SetTokenID(tokenID).
		SetSerialNumbers([]int64{1, 2, 3}).
		SetMetadata([]byte("metadata"))

	err = tokenUpdate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenUpdateNftsTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenUpdate := NewTokenUpdateNftsTransaction().
		SetTokenID(tokenID).
		SetSerialNumbers([]int64{1, 2, 3}).
		SetMetadata([]byte("metadata"))

	err = tokenUpdate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenUpdateNftsTransactionGet(t *testing.T) {
	t.Parallel()

	grpc := time.Second * 30
	checksum := "dmqui"
	tokenID := TokenID{Token: 3, checksum: &checksum}

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenUpdateNftsTransaction().
		SetTokenID(tokenID).
		SetSerialNumbers([]int64{1, 2, 3}).
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetMetadata([]byte("metadata")).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		SetGrpcDeadline(&grpc).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetMaxTransactionFee(NewHbar(10)).
		SetLogLevel(LoggerLevelInfo).
		Freeze()

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)

	require.NotNil(t, transaction.GetTokenID())
	require.NotNil(t, transaction.GetSerialNumbers())
	require.NotNil(t, transaction.GetMetadata())
	require.NotNil(t, transaction.GetMaxTransactionFee())
	require.NotNil(t, transaction.GetTransactionMemo())
	require.NotNil(t, transaction.GetRegenerateTransactionID())
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	require.NotNil(t, transaction.GetRegenerateTransactionID())
	require.NotNil(t, transaction.GetMaxTransactionFee())
	require.NotNil(t, transaction.GetRegenerateTransactionID())
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)
	require.NotNil(t, transaction.getName())
	require.NotNil(t, transaction.GetMaxRetry())
	require.NotNil(t, transaction.GetMaxBackoff())
	require.NotNil(t, transaction.GetMinBackoff())
	switch b := txFromBytes.(type) {
	case TokenUpdateNfts:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenUpdateNftsTransactionNothingSet(t *testing.T) {
	t.Parallel()
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenUpdateNftsTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).Freeze()

	require.NoError(t, err)
	require.Nil(t, transaction.GetTokenID())
	require.Nil(t, transaction.GetSerialNumbers())
	require.Nil(t, transaction.GetMetadata())
	require.NotNil(t, transaction.GetMaxTransactionFee())
	require.NotNil(t, transaction.GetTransactionMemo())
	require.NotNil(t, transaction.GetRegenerateTransactionID())
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	require.NotNil(t, transaction.GetRegenerateTransactionID())
	require.NotNil(t, transaction.GetMaxTransactionFee())
	require.NotNil(t, transaction.GetRegenerateTransactionID())
	require.NotNil(t, transaction.getName())
	require.NotNil(t, transaction.GetMaxRetry())
	require.NotNil(t, transaction.GetMaxBackoff())
	require.NotNil(t, transaction.GetMinBackoff())
	proto := transaction.build().GetTokenUpdateNfts()
	require.Nil(t, proto.Metadata)
	require.Nil(t, proto.SerialNumbers)
	require.Nil(t, proto.Token)
}

func TestUnitTokenUpdateNftTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}

	freeze, err := NewTokenUpdateNftsTransaction().
		SetTokenID(token).
		SetSerialNumbers([]int64{1, 2, 3}).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMetadata([]byte("metadata")).FreezeWith(client)
	require.NoError(t, err)

	_, err = freeze.Sign(newKey).Execute(client)
	require.NoError(t, err)

}

func TestUnitTokenUpdateNftsTransactionSignWithOperator(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)

	tokenID, err := TokenIDFromString("0.0.123")
	require.NoError(t, err)

	tokenUpdate := NewTokenUpdateNftsTransaction().
		SetTokenID(tokenID).
		SetSerialNumbers([]int64{1, 2, 3}).
		SetMetadata([]byte("metadata"))

	_, err = tokenUpdate.SignWithOperator(client)
	require.NoError(t, err)
}
// Filename: token_update_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenUpdateTransaction
// At consensus, updates an already created token to the given values.
//
// If no value is given for a field, that field is left unchanged. For an immutable tokens (that is,
// a token without an admin key), only the expiry may be updated. Setting any other field in that
// case will cause the transaction status to resolve to TOKEN_IS_IMMUTABLE.
//
// --- Signing Requirements ---
//  1. Whether or not a token has an admin key, its expiry can be extended with only the transaction
//     payer's signature.
//  2. Updating any other field of a mutable token requires the admin key's signature.
//  3. If a new admin key is set, this new key must sign <b>unless</b> it is exactly an empty
//     <tt>KeyList</tt>. This special sentinel key removes the existing admin key and causes the
//     token to become immutable. (Other <tt>Key</tt> structures without a constituent
//     <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
//  4. If a new treasury is set, the new treasury account's key must sign the transaction.
//
// --- Nft Requirements ---
//  1. If a non fungible token has a positive treasury balance, the operation will abort with
//     CURRENT_TREASURY_STILL_OWNS_NFTS.
type TokenUpdateTransaction struct {
	Transaction
	tokenID                  *TokenID
	treasuryAccountID        *AccountID
	autoRenewAccountID       *AccountID
	tokenName                string
	memo                     *string
	metadata                 []byte
	tokenSymbol              string
	adminKey                 Key
	kycKey                   Key
	freezeKey                Key
	wipeKey                  Key
	scheduleKey              Key
	supplyKey                Key
	pauseKey                 Key
	metadataKey              Key
	tokenKeyVerificationMode TokenKeyValidation
	expirationTime           *time.Time
	autoRenewPeriod          *time.Duration
}

// NewTokenUpdateTransaction creates TokenUpdateTransaction which at consensus,
// updates an already created token to the given values.
//
// If no value is given for a field, that field is left unchanged. For an immutable tokens (that is,
// a token without an admin key), only the expiry may be updated. Setting any other field in that
// case will cause the transaction status to resolve to TOKEN_IS_IMMUTABLE.
//
// --- Signing Requirements ---
//  1. Whether or not a token has an admin key, its expiry can be extended with only the transaction
//     payer's signature.
//  2. Updating any other field of a mutable token requires the admin key's signature.
//  3. If a new admin key is set, this new key must sign <b>unless</b> it is exactly an empty
//     <tt>KeyList</tt>. This special sentinel key removes the existing admin key and causes the
//     token to become immutable. (Other <tt>Key</tt> structures without a constituent
//     <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
//  4. If a new treasury is set, the new treasury account's key must sign the transaction.
//
// --- Nft Requirements ---
//  1. If a non fungible token has a positive treasury balance, the operation will abort with
//     CURRENT_TREASURY_STILL_OWNS_NFTS.
func NewTokenUpdateTransaction() *TokenUpdateTransaction {
	tx := TokenUpdateTransaction{
		Transaction: _NewTransaction(),
		memo:        nil,
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenUpdateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenUpdateTransaction {
	adminKey, _ := _KeyFromProtobuf(pb.GetTokenUpdate().GetAdminKey())
	kycKey, _ := _KeyFromProtobuf(pb.GetTokenUpdate().GetKycKey())
	freezeKey, _ := _KeyFromProtobuf(pb.GetTokenUpdate().GetFreezeKey())
	wipeKey, _ := _KeyFromProtobuf(pb.GetTokenUpdate().GetWipeKey())
	scheduleKey, _ := _KeyFromProtobuf(pb.GetTokenUpdate().GetFeeScheduleKey())
	supplyKey, _ := _KeyFromProtobuf(pb.GetTokenUpdate().GetSupplyKey())
	pauseKey, _ := _KeyFromProtobuf(pb.GetTokenUpdate().GetPauseKey())
	metadataKey, _ := _KeyFromProtobuf(pb.GetTokenUpdate().GetMetadataKey())
	keyVerificationMode := pb.GetTokenUpdate().GetKeyVerificationMode()

	expirationTime := _TimeFromProtobuf(pb.GetTokenUpdate().GetExpiry())
	autoRenew := _DurationFromProtobuf(pb.GetTokenUpdate().GetAutoRenewPeriod())

	var memo *string
	if m := pb.GetTokenUpdate().GetMemo(); m != nil {
		memo = &m.Value
	}

	var metadata []byte
	if m := pb.GetTokenUpdate().GetMetadata(); m != nil {
		metadata = m.Value
	}

	return &TokenUpdateTransaction{
		Transaction:              tx,
		tokenID:                  _TokenIDFromProtobuf(pb.GetTokenUpdate().GetToken()),
		treasuryAccountID:        _AccountIDFromProtobuf(pb.GetTokenUpdate().GetTreasury()),
		autoRenewAccountID:       _AccountIDFromProtobuf(pb.GetTokenUpdate().GetAutoRenewAccount()),
		tokenName:                pb.GetTokenUpdate().GetName(),
		memo:                     memo,
		metadata:                 metadata,
		tokenSymbol:              pb.GetTokenUpdate().GetSymbol(),
		adminKey:                 adminKey,
		kycKey:                   kycKey,
		freezeKey:                freezeKey,
		wipeKey:                  wipeKey,
		scheduleKey:              scheduleKey,
		supplyKey:                supplyKey,
		pauseKey:                 pauseKey,
		metadataKey:              metadataKey,
		tokenKeyVerificationMode: TokenKeyValidation(keyVerificationMode),
		expirationTime:           &expirationTime,
		autoRenewPeriod:          &autoRenew,
	}
}

type TokenKeyValidation int32

const (
	// FULL_VALIDATION performs all token key validations.
	FULL_VALIDATION TokenKeyValidation = iota
	// NO_VALIDATION performs no validations at all for all passed token keys.
	NO_VALIDATION
)

// SetTokenID Sets the Token to be updated
func (tx *TokenUpdateTransaction) SetTokenID(tokenID TokenID) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the TokenID for this TokenUpdateTransaction
func (tx *TokenUpdateTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// SetTokenSymbol Sets the new Symbol of the Token.
// Must be UTF-8 capitalized alphabetical string identifying the token.
func (tx *TokenUpdateTransaction) SetTokenSymbol(symbol string) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.tokenSymbol = symbol
	return tx
}

func (tx *TokenUpdateTransaction) GetTokenSymbol() string {
	return tx.tokenSymbol
}

// SetTokenName Sets the new Name of the Token. Must be a string of ASCII characters.
func (tx *TokenUpdateTransaction) SetTokenName(name string) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.tokenName = name
	return tx
}

// GetTokenName returns the TokenName for this TokenUpdateTransaction
func (tx *TokenUpdateTransaction) GetTokenName() string {
	return tx.tokenName
}

// SetTreasuryAccountID sets thehe new Treasury account of the Token.
// If the provided treasury account is not existing or deleted,
// the _Response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token
// balance held in the previous Treasury Account is transferred to the new one.
func (tx *TokenUpdateTransaction) SetTreasuryAccountID(treasuryAccountID AccountID) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.treasuryAccountID = &treasuryAccountID
	return tx
}

func (tx *TokenUpdateTransaction) GetTreasuryAccountID() AccountID {
	if tx.treasuryAccountID == nil {
		return AccountID{}
	}

	return *tx.treasuryAccountID
}

// SetAdminKey Sets the new Admin key of the Token.
// If Token is immutable, transaction will resolve to TOKEN_IS_IMMUTABlE.
func (tx *TokenUpdateTransaction) SetAdminKey(publicKey Key) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.adminKey = publicKey
	return tx
}

func (tx *TokenUpdateTransaction) GetAdminKey() Key {
	return tx.adminKey
}

// SetPauseKey Sets the Key which can pause and unpause the Token. If the Token does not currently have a pause key,
// transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY
func (tx *TokenUpdateTransaction) SetPauseKey(publicKey Key) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.pauseKey = publicKey
	return tx
}

// GetPauseKey returns the Key which can pause and unpause the Token
func (tx *TokenUpdateTransaction) GetPauseKey() Key {
	return tx.pauseKey
}

// SetMetadataKey Set the Key which can update the metadata.
func (tx *TokenUpdateTransaction) SetMetadataKey(key Key) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.metadataKey = key
	return tx
}

// GetMetadataKey returns the metadata key
func (tx *TokenUpdateTransaction) GetMetadataKey() Key {
	return tx.metadataKey
}

// SetKycKey Sets the new KYC key of the Token. If Token does not have currently a KYC key, transaction will
// resolve to TOKEN_HAS_NO_KYC_KEY.
func (tx *TokenUpdateTransaction) SetKycKey(publicKey Key) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.kycKey = publicKey
	return tx
}

// GetKycKey returns the new KYC key of the Token
func (tx *TokenUpdateTransaction) GetKycKey() Key {
	return tx.kycKey
}

// SetFreezeKey Sets the new Freeze key of the Token. If the Token does not have currently a Freeze key, transaction
// will resolve to TOKEN_HAS_NO_FREEZE_KEY.
func (tx *TokenUpdateTransaction) SetFreezeKey(publicKey Key) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.freezeKey = publicKey
	return tx
}

// GetFreezeKey returns the new Freeze key of the Token
func (tx *TokenUpdateTransaction) GetFreezeKey() Key {
	return tx.freezeKey
}

// SetWipeKey Sets the new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction
// will resolve to TOKEN_HAS_NO_WIPE_KEY.
func (tx *TokenUpdateTransaction) SetWipeKey(publicKey Key) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.wipeKey = publicKey
	return tx
}

// GetWipeKey returns the new Wipe key of the Token
func (tx *TokenUpdateTransaction) GetWipeKey() Key {
	return tx.wipeKey
}

// SetSupplyKey Sets the new Supply key of the Token. If the Token does not have currently a Supply key, transaction
// will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
func (tx *TokenUpdateTransaction) SetSupplyKey(publicKey Key) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.supplyKey = publicKey
	return tx
}

// GetSupplyKey returns the new Supply key of the Token
func (tx *TokenUpdateTransaction) GetSupplyKey() Key {
	return tx.supplyKey
}

// SetFeeScheduleKey
// If set, the new key to use to update the token's custom fee schedule; if the token does not
// currently have this key, transaction will resolve to TOKEN_HAS_NO_FEE_SCHEDULE_KEY
func (tx *TokenUpdateTransaction) SetFeeScheduleKey(key Key) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.scheduleKey = key
	return tx
}

// GetFeeScheduleKey returns the new key to use to update the token's custom fee schedule
func (tx *TokenUpdateTransaction) GetFeeScheduleKey() Key {
	return tx.scheduleKey
}

// SetAutoRenewAccount Sets the new account which will be automatically charged to renew the token's expiration, at
// autoRenewPeriod interval.
func (tx *TokenUpdateTransaction) SetAutoRenewAccount(autoRenewAccountID AccountID) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewAccountID = &autoRenewAccountID
	return tx
}

func (tx *TokenUpdateTransaction) GetAutoRenewAccount() AccountID {
	if tx.autoRenewAccountID == nil {
		return AccountID{}
	}

	return *tx.autoRenewAccountID
}

// SetAutoRenewPeriod Sets the new interval at which the auto-renew account will be charged to extend the token's expiry.
func (tx *TokenUpdateTransaction) SetAutoRenewPeriod(autoRenewPeriod time.Duration) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = &autoRenewPeriod
	return tx
}

// GetAutoRenewPeriod returns the new interval at which the auto-renew account will be charged to extend the token's expiry.
func (tx *TokenUpdateTransaction) GetAutoRenewPeriod() time.Duration {
	if tx.autoRenewPeriod != nil {
		return time.Duration(int64(tx.autoRenewPeriod.Seconds()) * time.Second.Nanoseconds())
	}

	return time.Duration(0)
}

// SetExpirationTime Sets the new expiry time of the token. Expiry can be updated even if admin key is not set.
// If the provided expiry is earlier than the current token expiry, transaction wil resolve to
// INVALID_EXPIRATION_TIME
func (tx *TokenUpdateTransaction) SetExpirationTime(expirationTime time.Time) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.expirationTime = &expirationTime
	return tx
}

func (tx *TokenUpdateTransaction) GetExpirationTime() time.Time {
	if tx.expirationTime != nil {
		return *tx.expirationTime
	}
	return time.Time{}
}

// SetTokenMemo
// If set, the new memo to be associated with the token (UTF-8 encoding max 100 bytes)
func (tx *TokenUpdateTransaction) SetTokenMemo(memo string) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.memo = &memo

	return tx
}

func (tx *TokenUpdateTransaction) GetTokenMemo() string {
	return *tx.memo
}

// SetTokenMetadata sets the token metadata
func (tx *TokenUpdateTransaction) SetTokenMetadata(metadata []byte) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.metadata = metadata

	return tx
}

// GetTokenMetadata returns the token metadata
func (tx *TokenUpdateTransaction) GetTokenMetadata() []byte {
	return tx.metadata
}

// SetKeyVerificationMode sets the token key verification mode
func (tx *TokenUpdateTransaction) SetKeyVerificationMode(verificationMode TokenKeyValidation) *TokenUpdateTransaction {
	tx._RequireNotFrozen()
	tx.tokenKeyVerificationMode = verificationMode
	return tx
}

// GetKeyVerificationMode returns the token metadata
func (tx *TokenUpdateTransaction) GetKeyVerificationMode() TokenKeyValidation {
	return tx.tokenKeyVerificationMode
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenUpdateTransaction) Sign(privateKey PrivateKey) *TokenUpdateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenUpdateTransaction) SignWithOperator(client *Client) (*TokenUpdateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenUpdateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenUpdateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenUpdateTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenUpdateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenUpdateTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenUpdateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TokenUpdateTransaction) Freeze() (*TokenUpdateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenUpdateTransaction) FreezeWith(client *Client) (*TokenUpdateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenUpdateTransaction.
func (tx *TokenUpdateTransaction) SetMaxTransactionFee(fee Hbar) *TokenUpdateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenUpdateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenUpdateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenUpdateTransaction.
func (tx *TokenUpdateTransaction) SetTransactionMemo(memo string) *TokenUpdateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenUpdateTransaction.
func (tx *TokenUpdateTransaction) SetTransactionValidDuration(duration time.Duration) *TokenUpdateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenUpdateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenUpdateTransaction.
func (tx *TokenUpdateTransaction) SetTransactionID(transactionID TransactionID) *TokenUpdateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenUpdateTransaction.
func (tx *TokenUpdateTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenUpdateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenUpdateTransaction) SetMaxRetry(count int) *TokenUpdateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenUpdateTransaction) SetMaxBackoff(max time.Duration) *TokenUpdateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenUpdateTransaction) SetMinBackoff(min time.Duration) *TokenUpdateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenUpdateTransaction) SetLogLevel(level LogLevel) *TokenUpdateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenUpdateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenUpdateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenUpdateTransaction) getName() string {
	return "TokenUpdateTransaction"
}

func (tx *TokenUpdateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.treasuryAccountID != nil {
		if err := tx.treasuryAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.autoRenewAccountID != nil {
		if err := tx.autoRenewAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenUpdateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenUpdate{
			TokenUpdate: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenUpdateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenUpdate{
			TokenUpdate: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenUpdateTransaction) buildProtoBody() *services.TokenUpdateTransactionBody {
	body := &services.TokenUpdateTransactionBody{
		Name:                tx.tokenName,
		Symbol:              tx.tokenSymbol,
		KeyVerificationMode: services.TokenKeyValidation(tx.tokenKeyVerificationMode),
	}

	if tx.memo != nil {
		body.Memo = &wrapperspb.StringValue{Value: *tx.memo}
	}

	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	if tx.autoRenewPeriod != nil {
		body.AutoRenewPeriod = _DurationToProtobuf(*tx.autoRenewPeriod)
	}

	if tx.expirationTime != nil {
		body.Expiry = _TimeToProtobuf(*tx.expirationTime)
	}

	if tx.treasuryAccountID != nil {
		body.Treasury = tx.treasuryAccountID._ToProtobuf()
	}

	if tx.autoRenewAccountID != nil {
		body.AutoRenewAccount = tx.autoRenewAccountID._ToProtobuf()
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	if tx.freezeKey != nil {
		body.FreezeKey = tx.freezeKey._ToProtoKey()
	}

	if tx.scheduleKey != nil {
		body.FeeScheduleKey = tx.scheduleKey._ToProtoKey()
	}

	if tx.kycKey != nil {
		body.KycKey = tx.kycKey._ToProtoKey()
	}

	if tx.wipeKey != nil {
		body.WipeKey = tx.wipeKey._ToProtoKey()
	}

	if tx.supplyKey != nil {
		body.SupplyKey = tx.supplyKey._ToProtoKey()
	}

	if tx.pauseKey != nil {
		body.PauseKey = tx.pauseKey._ToProtoKey()
	}

	if tx.metadataKey != nil {
		body.MetadataKey = tx.metadataKey._ToProtoKey()
	}

	if tx.metadata != nil {
		body.Metadata = &wrapperspb.BytesValue{Value: tx.metadata}
	}

	return body
}

func (tx *TokenUpdateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().UpdateToken,
	}
}
func (tx *TokenUpdateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_update_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenUpdateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, "A", info.Symbol, "token failed to update")

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUpdateTransactionDifferentKeys(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	keys := make([]PrivateKey, 5)
	pubKeys := make([]PublicKey, 5)

	for i := range keys {
		newKey, err := PrivateKeyGenerateEd25519()
		require.NoError(t, err)

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(pubKeys[0]).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(pubKeys[0])
	})
	require.NoError(t, err)

	resp, err = NewTokenUpdateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTokenName("ffffc").
		SetTokenID(tokenID).
		SetTokenSymbol("K").
		SetTreasuryAccountID(env.Client.GetOperatorAccountID()).
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetFreezeKey(pubKeys[1]).
		SetWipeKey(pubKeys[2]).
		SetKycKey(pubKeys[3]).
		SetSupplyKey(pubKeys[4]).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	assert.Equal(t, "K", info.Symbol)
	assert.Equal(t, "ffffc", info.Name)
	if info.FreezeKey != nil {
		freezeKey := info.FreezeKey
		assert.Equal(t, pubKeys[1].String(), freezeKey.String())
	}
	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUpdateTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env)
	require.NoError(t, err)

	resp2, err := NewTokenUpdateTransaction().
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_TOKEN_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenUpdateTransactionTreasury(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	metaData := make([]byte, 50, 101)

	mint, err := NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetMetadata(metaData).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	update, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenSymbol("A").
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTreasuryAccountID(accountID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	update.Sign(newKey)

	resp, err = update.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, "A", info.Symbol, "token failed to update")

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

var newMetadata = []byte{3, 4, 5, 6}

func TestIntegrationTokenUpdateTransactionFungibleMetadata(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetTokenMetadata(initialMetadata)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata(newMetadata).
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, newMetadata, info.Metadata, "updated metadata did not match")

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUpdateTransactionNFTMetadata(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetTokenMetadata(initialMetadata)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata(newMetadata).
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, newMetadata, info.Metadata, "updated metadata did not match")

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUpdateTransactionMetadataImmutableFunbigleToken(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	metadataKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	pubKey := metadataKey.PublicKey()

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetMetadataKey(pubKey).
			SetTokenMetadata(initialMetadata).
			SetAdminKey(nil)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")
	assert.Equalf(t, pubKey.String(), info.MetadataKey.String(), "metadata key did not match")
	assert.Equalf(t, nil, info.AdminKey, "admin key did not match")

	tx, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata(newMetadata).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err := tx.Sign(metadataKey).
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, newMetadata, info.Metadata, "updated metadata did not match")
}

func TestIntegrationTokenUpdateTransactionMetadataImmutableNFT(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	metadataKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetMetadataKey(metadataKey.PublicKey()).
			SetAdminKey(nil).
			SetTokenMetadata(initialMetadata)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")
	assert.Equalf(t, metadataKey.PublicKey().String(), info.MetadataKey.String(), "metadata key did not match")
	assert.Equalf(t, nil, info.AdminKey, "admin key did not match")

	tx, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata(newMetadata).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err := tx.Sign(metadataKey).
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, newMetadata, info.Metadata, "updated metadata did not match")
}

func TestIntegrationTokenUpdateTransactionCannotUpdateMetadataFungible(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetTokenMetadata(initialMetadata)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMemo("asdf").
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUpdateTransactionCannotUpdateMetadataNFT(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetTokenMetadata(initialMetadata)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMemo("asdf").
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUpdateTransactionEraseMetadataFungibleToken(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetTokenMetadata(initialMetadata)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata([]byte{}).
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, []byte(nil), info.Metadata, "metadata did not match")

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUpdateTransactionEraseMetadataNFT(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetTokenMetadata(initialMetadata)
	})
	require.NoError(t, err)

	info, err := NewTokenInfoQuery().
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, initialMetadata, info.Metadata, "metadata did not match")

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata([]byte{}).
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTokenInfoQuery().
		SetTokenID(tokenID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)
	assert.Equalf(t, []byte(nil), info.Metadata, "metadata did not match")

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenUpdateTransactionCannotUpdateMetadataWithoutKeyFungible(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	metadataKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	adminKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	pubKey := metadataKey.PublicKey()

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetAdminKey(adminKey).
			SetMetadataKey(pubKey).
			FreezeWith(env.Client)

		transaction.Sign(adminKey)
	})
	require.NoError(t, err)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata(newMetadata).
		Execute(env.Client)

	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_SIGNATURE")
}

func TestIntegrationTokenUpdateTransactionCannotUpdateMetadataWithoutKeyNFT(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	metadataKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	adminKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	pubKey := metadataKey.PublicKey()

	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetAdminKey(adminKey).
			SetSupplyKey(adminKey).
			SetMetadataKey(pubKey).
			FreezeWith(env.Client)

		transaction.Sign(adminKey)
	})
	require.NoError(t, err)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata(newMetadata).
		Execute(env.Client)

	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_SIGNATURE")
}

func TestIntegrationTokenUpdateTransactionCannotUpdateImmutableFungibleToken(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetAdminKey(nil).
			SetMetadataKey(nil)
	})
	require.NoError(t, err)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata(newMetadata).
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_IS_IMMUTABLE")
}

func TestIntegrationTokenUpdateTransactionCannotUpdateImmutableNFT(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetAdminKey(nil).
			SetMetadataKey(nil)
	})
	require.NoError(t, err)

	resp, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetTokenMetadata(newMetadata).
		Execute(env.Client)
	assert.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "TOKEN_IS_IMMUTABLE")
}
// Filename: token_update_transaction_hip540_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// HIP-540 tests

// KeyType represents different types of keys
type KeyType int

// Define enum values for different key types
const (
	WIPE_KEY KeyType = iota
	KYC_KEY
	SUPPLY_KEY
	FREEZE_KEY
	FEE_SCHEDULE_KEY
	PAUSE_KEY
	METADATA_KEY
	ADMIN_KEY
	ALL
	LOWER_PRIVILEGE
	NONE
)

func TestIntegrationTokenUpdateTransactionUpdateKeysToEmptyKeyListMakesTokenImmutable(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	validNewKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Make token immutable
	resp, tokenID, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, ALL, ALL, env.Client, NewKeyList(), env.OperatorKey, env.OperatorKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Verify token is immutable
	resp, err = updateTokenKeysHelper(t, tokenID, ALL, env.Client, validNewKey, env.OperatorKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "exceptional receipt status: TOKEN_IS_IMMUTABLE")

	tokenInfo, err := NewTokenInfoQuery().SetTokenID(tokenID).Execute(env.Client)
	verifyAdminKeyNil(t, tokenInfo)
	verifyLowerPrivilegeKeysNil(t, tokenInfo)
}

func TestIntegrationTokenUpdateTransactionUpdateKeysToZeroKeyFails(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	zeroNewKey, err := ZeroKey()
	require.NoError(t, err)

	// Make token immutable
	resp, _, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, ALL, ALL, env.Client, zeroNewKey, env.OperatorKey, env.OperatorKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)

	require.ErrorContains(t, err, "INVALID_SIGNATURE")
}

func TestIntegrationTokenUpdateTransactionUpdateLowerPrivilegeKeysWithAdminKeyFullValidation(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Update lower privilege keys to zero key list with admin key
	zeroKey, err := ZeroKey()
	require.NoError(t, err)

	resp, tokenID, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, ALL, LOWER_PRIVILEGE, env.Client, zeroKey, env.OperatorKey, env.OperatorKey, FULL_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	// Verify keys are set to zero
	tokenInfo, err := NewTokenInfoQuery().SetTokenID(tokenID).Execute(env.Client)
	verifyLowerPrivilegeKeys(t, tokenInfo, zeroKey)

	// Update lower privilege keys to valid key list with admin key
	validKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	resp, err = updateTokenKeysHelper(t, tokenID, LOWER_PRIVILEGE, env.Client, validKey, env.OperatorKey, FULL_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	// Verify keys are set to valid key
	tokenInfo, err = NewTokenInfoQuery().SetTokenID(tokenID).Execute(env.Client)
	verifyLowerPrivilegeKeys(t, tokenInfo, validKey.PublicKey())

	// Update lower privilege keys to empty key list with admin key
	resp, err = updateTokenKeysHelper(t, tokenID, LOWER_PRIVILEGE, env.Client, NewKeyList(), env.OperatorKey, FULL_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	// Verify keys are set to empty
	tokenInfo, err = NewTokenInfoQuery().SetTokenID(tokenID).Execute(env.Client)
	verifyLowerPrivilegeKeysNil(t, tokenInfo)
}

func TestIntegrationTokenUpdateTransactionUpdateLowerPrivilegeKeysWithAdminKeyNoValidation(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	// Update lower privilege keys to zero key list with admin key
	zeroKey, err := ZeroKey()
	require.NoError(t, err)

	resp, tokenID, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, ALL, LOWER_PRIVILEGE, env.Client, zeroKey, env.OperatorKey, env.OperatorKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	// Verify keys are set to zero
	tokenInfo, err := NewTokenInfoQuery().SetTokenID(tokenID).Execute(env.Client)
	verifyLowerPrivilegeKeys(t, tokenInfo, zeroKey)

	// Update lower privilege keys to valid key list with admin key
	validKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	resp, err = updateTokenKeysHelper(t, tokenID, LOWER_PRIVILEGE, env.Client, validKey, env.OperatorKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	// Verify keys are set to valid key
	tokenInfo, err = NewTokenInfoQuery().SetTokenID(tokenID).Execute(env.Client)
	verifyLowerPrivilegeKeys(t, tokenInfo, validKey.PublicKey())

	// Update lower privilege keys to empty key list with admin key
	resp, err = updateTokenKeysHelper(t, tokenID, LOWER_PRIVILEGE, env.Client, NewKeyList(), env.OperatorKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
	// Verify keys are set to empty
	tokenInfo, err = NewTokenInfoQuery().SetTokenID(tokenID).Execute(env.Client)
	verifyLowerPrivilegeKeysNil(t, tokenInfo)
}

func TestIntegrationTokenUpdateTransactionUpdateLowerPrivilegeKeysWithInvalidKeyFails(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	adminKey, err := GeneratePrivateKey()
	require.NoError(t, err)

	nonAdminKey, err := GeneratePrivateKey()
	require.NoError(t, err)

	someKey, err := GeneratePrivateKey()
	require.NoError(t, err)

	// create the token
	resp, tokenID, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, ALL, LOWER_PRIVILEGE, env.Client, nonAdminKey, adminKey, adminKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	// Cannot remove tokens without admin key
	resp, err = updateTokenKeysHelper(t, tokenID, LOWER_PRIVILEGE, env.Client, NewKeyList(), nonAdminKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_SIGNATURE")

	// Cannot upadate token with some random key
	resp, err = updateTokenKeysHelper(t, tokenID, LOWER_PRIVILEGE, env.Client, NewKeyList(), someKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_SIGNATURE")

	zeroKey, err := ZeroKey()
	require.NoError(t, err)

	// Cannot upadate token with some random key
	resp, err = updateTokenKeysHelper(t, tokenID, LOWER_PRIVILEGE, env.Client, zeroKey, someKey, NO_VALIDATION)
	require.NoError(t, err)
	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "INVALID_SIGNATURE")
}

func TestIntegrationTokenUpdateTransactionUpdateAdminKeyWithoutAlreadySetKeyFails(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	someKey, err := GeneratePrivateKey()
	require.NoError(t, err)

	// Create token without keys and fail updating them
	for _, keyType := range []KeyType{WIPE_KEY, KYC_KEY, SUPPLY_KEY, FREEZE_KEY, FEE_SCHEDULE_KEY, PAUSE_KEY, METADATA_KEY, ADMIN_KEY} {
		resp, _, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, NONE, keyType, env.Client, someKey, env.OperatorKey, env.OperatorKey, NO_VALIDATION)
		require.NoError(t, err)
		_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
		require.ErrorContains(t, err, "TOKEN_IS_IMMUTABLE")
	}
}

func TestIntegrationTokenUpdateTransactionUpdateKeysLowerPrivKeysUpdateThemselvesNoValidation(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	zeroNewKey, err := ZeroKey()
	require.NoError(t, err)

	validNewKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	initialKey := env.OperatorKey

	// Update to valid key
	for _, keyType := range []KeyType{WIPE_KEY, KYC_KEY, SUPPLY_KEY, FREEZE_KEY, FEE_SCHEDULE_KEY, PAUSE_KEY, METADATA_KEY} {
		resp, _, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, keyType, keyType, env.Client, validNewKey, initialKey, initialKey, NO_VALIDATION)
		_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
		require.NoError(t, err)
	}

	// Zero keys
	for _, keyType := range []KeyType{WIPE_KEY, KYC_KEY, SUPPLY_KEY, FREEZE_KEY, FEE_SCHEDULE_KEY, PAUSE_KEY, METADATA_KEY} {
		resp, _, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, keyType, keyType, env.Client, zeroNewKey, initialKey, initialKey, NO_VALIDATION)
		_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
		require.NoError(t, err)
	}
}

func TestIntegrationTokenUpdateTransactionUpdateKeysLowerPrivilegeKeysUpdateThemselvesFullValidation(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	validNewKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	initialKey := env.OperatorKey

	// Update to valid key
	for _, keyType := range []KeyType{WIPE_KEY, KYC_KEY, SUPPLY_KEY, FREEZE_KEY, FEE_SCHEDULE_KEY, PAUSE_KEY, METADATA_KEY} {
		resp, _, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, keyType, keyType, env.Client, validNewKey, initialKey, initialKey, FULL_VALIDATION)
		_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
		require.NoError(t, err)
	}

}

func TestIntegrationTokenUpdateTransactionUpdateKeysLowerPrivilegeKeysUpdateFullValidationFails(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	zeroNewKey, err := ZeroKey()
	require.NoError(t, err)

	initialKey := env.OperatorKey

	// Zero out keys
	for _, keyType := range []KeyType{WIPE_KEY, KYC_KEY, SUPPLY_KEY, FREEZE_KEY, FEE_SCHEDULE_KEY, PAUSE_KEY, METADATA_KEY} {
		resp, _, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, keyType, keyType, env.Client, zeroNewKey, initialKey, initialKey, FULL_VALIDATION)
		_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
		require.ErrorContains(t, err, "exceptional receipt status: INVALID_SIGNATURE")
	}
}

func TestIntegrationTokenUpdateTransactionRemoveKeysWithoutAdminKeyFails(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	initialKey := env.OperatorKey

	// Cannot remove keys without admin key
	for _, keyType := range []KeyType{WIPE_KEY, KYC_KEY, SUPPLY_KEY, FREEZE_KEY, FEE_SCHEDULE_KEY, PAUSE_KEY, METADATA_KEY} {
		resp, _, err := createTokenWithKeysAndUpdateTokenKeyHelper(t, keyType, keyType, env.Client, NewKeyList(), initialKey, initialKey, NO_VALIDATION)
		_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
		require.ErrorContains(t, err, "TOKEN_IS_IMMUTABLE")
	}
}

func TestIntegrationTokenUpdateTransactionRemoveKeysWithoutAdminKeySignFails(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	initialKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	wipeKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Create NFT with wipe and supply keys
	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetWipeKey(initialKey).
			SetKycKey(initialKey).
			SetSupplyKey(initialKey).
			SetFreezeKey(initialKey).
			SetFeeScheduleKey(initialKey).
			SetPauseKey(initialKey).
			SetMetadataKey(initialKey).
			SetAdminKey(initialKey).
			FreezeWith(env.Client)
		transaction.Sign(initialKey)
	})
	require.NoError(t, err)

	// Update supply key
	tx1, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetWipeKey(newKey).
		SetKycKey(newKey).
		SetSupplyKey(newKey).
		SetFreezeKey(newKey).
		SetFeeScheduleKey(newKey).
		SetPauseKey(newKey).
		SetMetadataKey(newKey).
		SetAdminKey(newKey).
		SetKeyVerificationMode(NO_VALIDATION).
		FreezeWith(env.Client)
	assert.NoError(t, err)

	// Cannot remove keys without admin key signing
	resp, err := tx1.Sign(wipeKey).Execute(env.Client)
	assert.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "exceptional receipt status: INVALID_SIGNATURE")
}

func TestIntegrationTokenUpdateTransactionUpdateSupplyKeyFailsWhenSignWithWipeKey(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newSupplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	supplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	wipeKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Create NFT with wipe and supply keys
	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetAdminKey(nil).
			SetWipeKey(wipeKey).
			SetSupplyKey(supplyKey)
	})
	require.NoError(t, err)

	// Update supply key
	tx, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetSupplyKey(newSupplyKey).
		SetKeyVerificationMode(NO_VALIDATION).
		FreezeWith(env.Client)
	assert.NoError(t, err)

	// Sign with the supply key
	resp, err := tx.Sign(wipeKey).Execute(env.Client)
	assert.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "exceptional receipt status: INVALID_SIGNATURE")
}

func TestIntegrationTokenUpdateTransactionUpdateSupplyKeyToEmptyKeyAndVerifyItsImmutable(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newSupplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	supplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Create NFT with admin and supply keys
	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetSupplyKey(supplyKey).
			SetAdminKey(env.OperatorKey)
	})
	require.NoError(t, err)

	// Update supply key
	tx, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetSupplyKey(NewKeyList()).
		SetKeyVerificationMode(NO_VALIDATION).
		FreezeWith(env.Client)
	assert.NoError(t, err)

	// Sign with the supply key
	resp, err := tx.Sign(supplyKey).Execute(env.Client)
	assert.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err = NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetSupplyKey(newSupplyKey).
		SetKeyVerificationMode(NO_VALIDATION).
		FreezeWith(env.Client)
	assert.NoError(t, err)

	// Sign with the admin key
	resp, err = tx.Sign(env.OperatorKey).Execute(env.Client)
	assert.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "exceptional receipt status: TOKEN_HAS_NO_SUPPLY_KEY")
}

func TestIntegrationTokenUpdateTransactionUpdateSupplyKeyFullValidationFails(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newSupplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	supplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Create NFT with supply key
	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.
			SetSupplyKey(supplyKey).
			SetAdminKey(nil)
	})
	require.NoError(t, err)

	// Update supply key
	tx, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetSupplyKey(newSupplyKey).
		SetKeyVerificationMode(FULL_VALIDATION).
		FreezeWith(env.Client)
	assert.NoError(t, err)

	_, err = supplyKey.SignTransaction(&tx.Transaction)
	assert.NoError(t, err)

	// Sign with the old supply key, should fail
	resp, err := tx.Execute(env.Client)
	assert.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "exceptional receipt status: INVALID_SIGNATURE")

	// Update supply key
	tx2, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetSupplyKey(newSupplyKey).
		SetKeyVerificationMode(FULL_VALIDATION).
		FreezeWith(env.Client)
	assert.NoError(t, err)

	// Sign with only the new supply key, should fail
	_, err = newSupplyKey.SignTransaction(&tx2.Transaction)
	assert.NoError(t, err)

	resp, err = tx2.Execute(env.Client)
	assert.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.ErrorContains(t, err, "exceptional receipt status: INVALID_SIGNATURE")
}

func TestIntegrationTokenUpdateTransactionUpdateSupplyKeyWithInvalidKey(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	var invalidKey _Ed25519PublicKey
	randomBytes := make([]byte, 32)
	keyData := [32]byte{
		0x01, 0x23, 0x45, 0x67,
		0x89, 0xab, 0xcd, 0xef,
		0xfe, 0xdc, 0xba, 0x98,
		0x76, 0x54, 0x32, 0x10,
		0x00, 0x11, 0x22, 0x33,
		0x44, 0x55, 0x66, 0x77,
		0x88, 0x99, 0xaa, 0xbb,
		0xcc, 0xdd, 0xee, 0xff,
	}
	randomBytes = keyData[:]
	copy(invalidKey.keyData[:], randomBytes)
	invalidSupplyKey := PublicKey{
		ed25519PublicKey: &invalidKey,
	}

	supplyKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	// Create NFT with supplyKey
	tokenID, err := createNft(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetSupplyKey(supplyKey)
	})
	require.NoError(t, err)

	// Update supply key
	tx, err := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetSupplyKey(invalidSupplyKey).
		SetKeyVerificationMode(NO_VALIDATION).
		FreezeWith(env.Client)
	assert.NoError(t, err)

	_, err = supplyKey.SignTransaction(&tx.Transaction)
	assert.NoError(t, err)

	//Sign with the old supply key
	_, err = tx.Execute(env.Client)
	assert.ErrorContains(t, err, "exceptional precheck status INVALID_SUPPLY_KEY")

}

func createTokenWithKeysAndUpdateTokenKeyHelper(t *testing.T, createKeyType KeyType, updateKeyType KeyType, client *Client, newKey Key, initialKey Key, signerKey PrivateKey, verificationMode TokenKeyValidation) (TransactionResponse, TokenID, error) {
	// Create Fungible token with keys
	tx := NewTokenCreateTransaction().
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetTreasuryAccountID(client.GetOperatorAccountID()).
		SetFreezeDefault(false)

	switch createKeyType {
	case WIPE_KEY:
		tx.SetWipeKey(initialKey)
	case KYC_KEY:
		tx.SetKycKey(initialKey)
	case SUPPLY_KEY:
		tx.SetSupplyKey(initialKey)
	case FREEZE_KEY:
		tx.SetFreezeKey(initialKey)
	case FEE_SCHEDULE_KEY:
		tx.SetFeeScheduleKey(initialKey)
	case PAUSE_KEY:
		tx.SetPauseKey(initialKey)
	case METADATA_KEY:
		tx.SetMetadataKey(initialKey)
	case ADMIN_KEY:
		tx.SetAdminKey(initialKey)
	case LOWER_PRIVILEGE:
		tx.SetWipeKey(initialKey).
			SetKycKey(initialKey).
			SetSupplyKey(initialKey).
			SetFreezeKey(initialKey).
			SetFeeScheduleKey(initialKey).
			SetPauseKey(initialKey).
			SetMetadataKey(initialKey)
	case ALL:
		tx.SetWipeKey(initialKey).
			SetKycKey(initialKey).
			SetSupplyKey(initialKey).
			SetFreezeKey(initialKey).
			SetFeeScheduleKey(initialKey).
			SetPauseKey(initialKey).
			SetMetadataKey(initialKey).
			SetAdminKey(initialKey)
	}
	frozenTx, err := tx.FreezeWith(client)
	require.NoError(t, err)
	resp, err := frozenTx.Sign(signerKey).Execute(client)
	require.NoError(t, err)
	receipt, err := resp.SetValidateStatus(true).GetReceipt(client)
	require.NoError(t, err)

	resp, err = updateTokenKeysHelper(t, *receipt.TokenID, updateKeyType, client, newKey, signerKey, verificationMode)
	return resp, *receipt.TokenID, err
}

func updateTokenKeysHelper(t *testing.T, tokenID TokenID, updateKeyType KeyType, client *Client, newKey Key, signerKey PrivateKey, verificationMode TokenKeyValidation) (TransactionResponse, error) {
	privateKey, _ := newKey.(PrivateKey)
	// Update the key
	tx := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetKeyVerificationMode(verificationMode)

	switch updateKeyType {
	case WIPE_KEY:
		tx.SetWipeKey(newKey)
	case KYC_KEY:
		tx.SetKycKey(newKey)
	case SUPPLY_KEY:
		tx.SetSupplyKey(newKey)
	case FREEZE_KEY:
		tx.SetFreezeKey(newKey)
	case FEE_SCHEDULE_KEY:
		tx.SetFeeScheduleKey(newKey)
	case PAUSE_KEY:
		tx.SetPauseKey(newKey)
	case METADATA_KEY:
		tx.SetMetadataKey(newKey)
	case ADMIN_KEY:
		tx.SetAdminKey(newKey)
	case LOWER_PRIVILEGE:
		tx.SetWipeKey(newKey).
			SetKycKey(newKey).
			SetSupplyKey(newKey).
			SetFreezeKey(newKey).
			SetFeeScheduleKey(newKey).
			SetPauseKey(newKey).
			SetMetadataKey(newKey)
	case ALL:
		tx.SetWipeKey(newKey).
			SetKycKey(newKey).
			SetSupplyKey(newKey).
			SetFreezeKey(newKey).
			SetFeeScheduleKey(newKey).
			SetPauseKey(newKey).
			SetMetadataKey(newKey).
			SetAdminKey(newKey)
	}
	frozenTx, err := tx.FreezeWith(client)
	assert.NoError(t, err)

	if updateKeyType == ADMIN_KEY || updateKeyType == ALL || verificationMode == FULL_VALIDATION {
		privateKey.SignTransaction(&tx.Transaction)
		signerKey.SignTransaction(&tx.Transaction)
		resp, err := frozenTx.Execute(client)
		return resp, err

	} else {
		// Sign with the signer key
		resp, err := frozenTx.Sign(signerKey).Execute(client)
		return resp, err
	}
}

func verifyAdminKey(t *testing.T, tokenInfo TokenInfo, expectedKey Key) {
	assert.Equalf(t, expectedKey.String(), tokenInfo.AdminKey.String(), " admin key did not match")
}

func verifyAdminKeyNil(t *testing.T, tokenInfo TokenInfo) {
	assert.Nil(t, tokenInfo.AdminKey)
}

func verifyLowerPrivilegeKeysNil(t *testing.T, tokenInfo TokenInfo) {
	assert.Nil(t, tokenInfo.WipeKey)
	assert.Nil(t, tokenInfo.KycKey)
	assert.Nil(t, tokenInfo.SupplyKey)
	assert.Nil(t, tokenInfo.FreezeKey)
	assert.Nil(t, tokenInfo.FeeScheduleKey)
	assert.Nil(t, tokenInfo.PauseKey)
	assert.Nil(t, tokenInfo.MetadataKey)
}

func verifyLowerPrivilegeKeys(t *testing.T, tokenInfo TokenInfo, expectedKey Key) {
	assert.Equalf(t, expectedKey.String(), tokenInfo.WipeKey.String(), "wipe key did not match")
	assert.Equalf(t, expectedKey.String(), tokenInfo.KycKey.String(), "kyc key did not match")
	assert.Equalf(t, expectedKey.String(), tokenInfo.SupplyKey.String(), "supply key did not match")
	assert.Equalf(t, expectedKey.String(), tokenInfo.FreezeKey.String(), "freeze key did not match")
	assert.Equalf(t, expectedKey.String(), tokenInfo.FeeScheduleKey.String(), "fee schedule key did not match")
	assert.Equalf(t, expectedKey.String(), tokenInfo.PauseKey.String(), "pause key did not match")
	assert.Equalf(t, expectedKey.String(), tokenInfo.MetadataKey.String(), "metadata key did not match")
}
// Filename: token_update_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenUpdateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenUpdate := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetAutoRenewAccount(accountID).
		SetTreasuryAccountID(accountID)

	err = tokenUpdate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenUpdateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenUpdate := NewTokenUpdateTransaction().
		SetTokenID(tokenID).
		SetAutoRenewAccount(accountID).
		SetTreasuryAccountID(accountID)

	err = tokenUpdate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenUpdateTransactionGet(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	accountID := AccountID{Account: 3, checksum: &checksum}
	token := TokenID{Token: 3, checksum: &checksum}

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetTokenMemo("fnord").
		SetTokenMetadata([]byte{1, 2, 3}).
		SetTreasuryAccountID(accountID).
		SetTokenID(token).
		SetAdminKey(newKey).
		SetFreezeKey(newKey).
		SetWipeKey(newKey).
		SetKycKey(newKey).
		SetSupplyKey(newKey).
		SetPauseKey(newKey).
		SetMetadataKey(newKey).
		SetKeyVerificationMode(NO_VALIDATION).
		SetExpirationTime(time.Now()).
		SetAutoRenewPeriod(60 * time.Second).
		SetAutoRenewAccount(accountID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		SetGrpcDeadline(&grpc).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTokenName()
	transaction.GetTokenSymbol()
	transaction.GetTreasuryAccountID()
	transaction.GetAdminKey()
	transaction.GetFreezeKey()
	transaction.GetWipeKey()
	transaction.GetKycKey()
	transaction.GetSupplyKey()
	transaction.GetPauseKey()
	transaction.GetMetadataKey()
	transaction.GetKeyVerificationMode()
	transaction.GetExpirationTime()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)
	transaction.getName()
	transaction.GetMaxRetry()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	switch b := txFromBytes.(type) {
	case TokenUpdateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenUpdateTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenName()
	transaction.GetTokenSymbol()
	transaction.GetTreasuryAccountID()
	transaction.GetAdminKey()
	transaction.GetFreezeKey()
	transaction.GetWipeKey()
	transaction.GetKycKey()
	transaction.GetSupplyKey()
	transaction.GetPauseKey()
	transaction.GetMetadataKey()
	transaction.GetKeyVerificationMode()
	transaction.GetExpirationTime()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
	proto := transaction.build().GetTokenUpdate()
	require.Nil(t, proto.Token)
	require.Nil(t, proto.AutoRenewAccount)
	require.Nil(t, proto.AdminKey)
	require.Nil(t, proto.Expiry)
	require.Nil(t, proto.FeeScheduleKey)
	require.Nil(t, proto.FreezeKey)
	require.Nil(t, proto.KycKey)
	require.Nil(t, proto.FeeScheduleKey)
	require.Nil(t, proto.PauseKey)
	require.Nil(t, proto.SupplyKey)
	require.Nil(t, proto.MetadataKey)
	require.Nil(t, proto.Treasury)
}

func TestUnitTokenUpdateTransactionKeyCheck(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	keys := make([]PrivateKey, 8)
	var err error

	for i := 0; i < len(keys); i++ {
		keys[i], err = PrivateKeyGenerateEd25519()
		require.NoError(t, err)
	}

	transaction, err := NewTokenUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(keys[0]).
		SetFreezeKey(keys[1]).
		SetWipeKey(keys[2]).
		SetKycKey(keys[3]).
		SetSupplyKey(keys[4]).
		SetPauseKey(keys[5]).
		SetFeeScheduleKey(keys[6]).
		SetMetadataKey(keys[7]).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenUpdate()
	require.Equal(t, proto.AdminKey.String(), keys[0]._ToProtoKey().String())
	require.Equal(t, proto.FreezeKey.String(), keys[1]._ToProtoKey().String())
	require.Equal(t, proto.WipeKey.String(), keys[2]._ToProtoKey().String())
	require.Equal(t, proto.KycKey.String(), keys[3]._ToProtoKey().String())
	require.Equal(t, proto.SupplyKey.String(), keys[4]._ToProtoKey().String())
	require.Equal(t, proto.PauseKey.String(), keys[5]._ToProtoKey().String())
	require.Equal(t, proto.FeeScheduleKey.String(), keys[6]._ToProtoKey().String())
	require.Equal(t, proto.MetadataKey.String(), keys[7]._ToProtoKey().String())
}

func TestUnitTokenUpdateTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	accountID := AccountID{Account: 3, checksum: &checksum}
	token := TokenID{Token: 3, checksum: &checksum}

	freez, err := NewTokenUpdateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		SetTreasuryAccountID(accountID).
		SetAdminKey(newKey).
		SetFreezeKey(newKey).
		SetWipeKey(newKey).
		SetKycKey(newKey).
		SetSupplyKey(newKey).
		SetPauseKey(newKey).
		SetMetadataKey(newKey).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: token_wipe_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TokenWipeTransaction
// Wipes the provided amount of tokens from the specified Account. Must be signed by the Token's Wipe key.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If Wipe Key is not present in the Token, transaction results in TOKEN_HAS_NO_WIPE_KEY.
// If the provided account is the Token's Treasury Account, transaction results in
// CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT
// On success, tokens are removed from the account and the total supply of the token is decreased
// by the wiped amount.
//
// The amount provided is in the lowest denomination possible. Example:
// Token A has 2 decimals. In order to wipe 100 tokens from account, one must provide amount of
// 10000. In order to wipe 100.55 tokens, one must provide amount of 10055.
type TokenWipeTransaction struct {
	Transaction
	tokenID   *TokenID
	accountID *AccountID
	amount    uint64
	serial    []int64
}

// NewTokenWipeTransaction creates TokenWipeTransaction which
// wipes the provided amount of tokens from the specified Account. Must be signed by the Token's Wipe key.
// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
// If an Association between the provided token and account is not found, the transaction will
// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
// If Wipe Key is not present in the Token, transaction results in TOKEN_HAS_NO_WIPE_KEY.
// If the provided account is the Token's Treasury Account, transaction results in
// CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT
// On success, tokens are removed from the account and the total supply of the token is decreased
// by the wiped amount.
//
// The amount provided is in the lowest denomination possible. Example:
// Token A has 2 decimals. In order to wipe 100 tokens from account, one must provide amount of
// 10000. In order to wipe 100.55 tokens, one must provide amount of 10055.
func NewTokenWipeTransaction() *TokenWipeTransaction {
	tx := TokenWipeTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(30))

	return &tx
}

func _TokenWipeTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TokenWipeTransaction {
	return &TokenWipeTransaction{
		Transaction: tx,
		tokenID:     _TokenIDFromProtobuf(pb.GetTokenWipe().GetToken()),
		accountID:   _AccountIDFromProtobuf(pb.GetTokenWipe().GetAccount()),
		amount:      pb.GetTokenWipe().Amount,
		serial:      pb.GetTokenWipe().GetSerialNumbers(),
	}
}

// SetTokenID Sets the token for which the account will be wiped. If token does not exist, transaction results in
// INVALID_TOKEN_ID
func (tx *TokenWipeTransaction) SetTokenID(tokenID TokenID) *TokenWipeTransaction {
	tx._RequireNotFrozen()
	tx.tokenID = &tokenID
	return tx
}

// GetTokenID returns the TokenID that is being wiped
func (tx *TokenWipeTransaction) GetTokenID() TokenID {
	if tx.tokenID == nil {
		return TokenID{}
	}

	return *tx.tokenID
}

// SetAccountID Sets the account to be wiped
func (tx *TokenWipeTransaction) SetAccountID(accountID AccountID) *TokenWipeTransaction {
	tx._RequireNotFrozen()
	tx.accountID = &accountID
	return tx
}

// GetAccountID returns the AccountID that is being wiped
func (tx *TokenWipeTransaction) GetAccountID() AccountID {
	if tx.accountID == nil {
		return AccountID{}
	}

	return *tx.accountID
}

// SetAmount Sets the amount of tokens to wipe from the specified account. Amount must be a positive non-zero
// number in the lowest denomination possible, not bigger than the token balance of the account
// (0; balance]
func (tx *TokenWipeTransaction) SetAmount(amount uint64) *TokenWipeTransaction {
	tx._RequireNotFrozen()
	tx.amount = amount
	return tx
}

// GetAmount returns the amount of tokens to be wiped from the specified account
func (tx *TokenWipeTransaction) GetAmount() uint64 {
	return tx.amount
}

// GetSerialNumbers returns the list of serial numbers to be wiped.
func (tx *TokenWipeTransaction) GetSerialNumbers() []int64 {
	return tx.serial
}

// SetSerialNumbers
// Sets applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be wiped.
func (tx *TokenWipeTransaction) SetSerialNumbers(serial []int64) *TokenWipeTransaction {
	tx._RequireNotFrozen()
	tx.serial = serial
	return tx
}

// ---- Required Interfaces ---- //

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TokenWipeTransaction) SetGrpcDeadline(deadline *time.Duration) *TokenWipeTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

// Sign uses the provided privateKey to sign the transaction.
func (tx *TokenWipeTransaction) Sign(privateKey PrivateKey) *TokenWipeTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TokenWipeTransaction) SignWithOperator(client *Client) (*TokenWipeTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TokenWipeTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TokenWipeTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TokenWipeTransaction) AddSignature(publicKey PublicKey, signature []byte) *TokenWipeTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

func (tx *TokenWipeTransaction) Freeze() (*TokenWipeTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TokenWipeTransaction) FreezeWith(client *Client) (*TokenWipeTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TokenWipeTransaction.
func (tx *TokenWipeTransaction) SetMaxTransactionFee(fee Hbar) *TokenWipeTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TokenWipeTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TokenWipeTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TokenWipeTransaction.
func (tx *TokenWipeTransaction) SetTransactionMemo(memo string) *TokenWipeTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TokenWipeTransaction.
func (tx *TokenWipeTransaction) SetTransactionValidDuration(duration time.Duration) *TokenWipeTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TokenWipeTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TokenWipeTransaction.
func (tx *TokenWipeTransaction) SetTransactionID(transactionID TransactionID) *TokenWipeTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TokenWipeTransaction.
func (tx *TokenWipeTransaction) SetNodeAccountIDs(nodeID []AccountID) *TokenWipeTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TokenWipeTransaction) SetMaxRetry(count int) *TokenWipeTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TokenWipeTransaction) SetMaxBackoff(max time.Duration) *TokenWipeTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TokenWipeTransaction) SetMinBackoff(min time.Duration) *TokenWipeTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TokenWipeTransaction) SetLogLevel(level LogLevel) *TokenWipeTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TokenWipeTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TokenWipeTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TokenWipeTransaction) getName() string {
	return "TokenWipeTransaction"
}

func (tx *TokenWipeTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.tokenID != nil {
		if err := tx.tokenID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.accountID != nil {
		if err := tx.accountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TokenWipeTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_TokenWipe{
			TokenWipe: tx.buildProtoBody(),
		},
	}
}

func (tx *TokenWipeTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_TokenWipe{
			TokenWipe: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TokenWipeTransaction) buildProtoBody() *services.TokenWipeAccountTransactionBody {
	body := &services.TokenWipeAccountTransactionBody{
		Amount: tx.amount,
	}

	if len(tx.serial) > 0 {
		body.SerialNumbers = tx.serial
	}

	if tx.tokenID != nil {
		body.Token = tx.tokenID._ToProtobuf()
	}

	if tx.accountID != nil {
		body.Account = tx.accountID._ToProtobuf()
	}

	return body
}

func (tx *TokenWipeTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetToken().WipeTokenAccount,
	}
}
func (tx *TokenWipeTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: token_wipe_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTokenWipeTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -100).
		AddTokenTransfer(tokenID, accountID, 100).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewAccountBalanceQuery().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	var value uint64
	for balanceTokenID, balance := range info.Token {
		if tokenID.String() == balanceTokenID.String() {
			value = balance
		}
	}

	// TODO: assert.Equal(t, uint64(100), value)

	resp, err = NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetAmount(100).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewAccountBalanceQuery().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	for balanceTokenID, balance := range info.Token {
		if tokenID.String() == balanceTokenID.String() {
			value = balance
		}
	}

	assert.Equal(t, uint64(0), value)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenWipeTransactionNoAmount(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	nodeID := resp.NodeID

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, accountID, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		Execute(env.Client)

	// It is now possible to perform Zero Token Operations https://hips.hedera.com/hip/hip-564
	receipt, err = resp2.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES", err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenWipeTransactionNoTokenID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, accountID, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetAmount(10).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_TOKEN_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES", err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenWipeTransactionNoAccountID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	nodeID := resp.NodeID

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, accountID, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp2, err := NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{nodeID}).
		SetTokenID(tokenID).
		SetAmount(10).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("exceptional precheck status INVALID_ACCOUNT_ID received for transaction %s", resp2.TransactionID), err.Error())
	}

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES", err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func TestIntegrationTokenWipeTransactionNotZeroTokensAtDelete(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetKycKey(env.Client.GetOperatorPublicKey())
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -100).
		AddTokenTransfer(tokenID, accountID, 100).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err := NewAccountBalanceQuery().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	var value uint64
	for balanceTokenID, balance := range info.Token {
		if tokenID.String() == balanceTokenID.String() {
			value = balance
		}
	}

	assert.Equal(t, value, value)
	// TODO: assert.Equal(t, value, uint64(100))

	resp, err = NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetAmount(10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewAccountBalanceQuery().
		SetAccountID(accountID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	for balanceTokenID, balance := range info.Token {
		if tokenID.String() == balanceTokenID.String() {
			value = balance
		}
	}

	// TODO: assert.Equal(t, value, uint64(90))

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES", err.Error())
	}

	err = CloseIntegrationTestEnv(env, &tokenID)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenWipeTransactionNftsIfNotOwned(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	metaData := []byte{50, 50}

	mint, err := NewTokenMintTransaction().
		SetTokenID(tokenID).
		SetMetadata(metaData).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(2)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	freezeAssociate, err := NewTokenAssociateTransaction().
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		SetNodeAccountIDs(env.NodeAccountIDs).
		FreezeWith(env.Client)
	require.NoError(t, err)

	freezeAssociate.Sign(newKey)

	resp, err = freezeAssociate.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTransactionID(TransactionIDGenerate(accountID)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx = tx.Sign(newKey)

	resp, err = tx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}
// Filename: token_wipe_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTokenWipeTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	tokenWipe := NewTokenWipeTransaction().
		SetTokenID(tokenID).
		SetAccountID(accountID)

	err = tokenWipe.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTokenWipeTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	tokenWipe := NewTokenWipeTransaction().
		SetTokenID(tokenID).
		SetAccountID(accountID)

	err = tokenWipe.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTokenWipeTransactionGet(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenWipeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAccountID(AccountID{Account: 7}).
		SetAmount(323).
		SetSerialNumbers([]int64{123, 3123, 31}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetAmount()
	transaction.GetSerialNumbers()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenWipeTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenWipeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetAmount()
	transaction.GetSerialNumbers()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTokenWipeTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 7}
	accountID := AccountID{Account: 7}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTokenWipeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetAmount(323).
		SetSerialNumbers([]int64{123, 3123, 31}).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetTokenWipe()
	require.Equal(t, proto.Token.String(), tokenID._ToProtobuf().String())
	require.Equal(t, proto.Account.String(), accountID._ToProtobuf().String())
	require.Equal(t, proto.Amount, uint64(323))
	require.Equal(t, proto.SerialNumbers, []int64{123, 3123, 31})
}

func TestUnitTokenWipeTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTokenWipeTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTokenID(token).
		SetAccountID(account).
		SetAmount(5).
		SetSerialNumbers([]int64{34}).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTokenID()
	transaction.GetAccountID()
	transaction.GetAmount()
	transaction.GetSerialNumbers()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TokenWipeTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTokenWipeTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	token := TokenID{Token: 3, checksum: &checksum}
	account := AccountID{Account: 3, checksum: &checksum}

	freez, err := NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTokenID(token).
		SetAccountID(account).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: topic_create_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// A TopicCreateTransaction is for creating a new Topic on HCS.
type TopicCreateTransaction struct {
	Transaction
	autoRenewAccountID *AccountID
	adminKey           Key
	submitKey          Key
	memo               string
	autoRenewPeriod    *time.Duration
}

// NewTopicCreateTransaction creates a TopicCreateTransaction transaction which can be
// used to construct and execute a  Create Topic Transaction.
func NewTopicCreateTransaction() *TopicCreateTransaction {
	tx := TopicCreateTransaction{
		Transaction: _NewTransaction(),
	}

	tx.SetAutoRenewPeriod(7890000 * time.Second)
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _TopicCreateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TopicCreateTransaction {
	adminKey, _ := _KeyFromProtobuf(pb.GetConsensusCreateTopic().GetAdminKey())
	submitKey, _ := _KeyFromProtobuf(pb.GetConsensusCreateTopic().GetSubmitKey())

	autoRenew := _DurationFromProtobuf(pb.GetConsensusCreateTopic().GetAutoRenewPeriod())
	return &TopicCreateTransaction{
		Transaction:        tx,
		autoRenewAccountID: _AccountIDFromProtobuf(pb.GetConsensusCreateTopic().GetAutoRenewAccount()),
		adminKey:           adminKey,
		submitKey:          submitKey,
		memo:               pb.GetConsensusCreateTopic().GetMemo(),
		autoRenewPeriod:    &autoRenew,
	}
}

// SetAdminKey sets the key required to update or delete the topic. If unspecified, anyone can increase the topic's
// expirationTime.
func (tx *TopicCreateTransaction) SetAdminKey(publicKey Key) *TopicCreateTransaction {
	tx._RequireNotFrozen()
	tx.adminKey = publicKey
	return tx
}

// GetAdminKey returns the key required to update or delete the topic
func (tx *TopicCreateTransaction) GetAdminKey() (Key, error) {
	return tx.adminKey, nil
}

// SetSubmitKey sets the key required for submitting messages to the topic. If unspecified, all submissions are allowed.
func (tx *TopicCreateTransaction) SetSubmitKey(publicKey Key) *TopicCreateTransaction {
	tx._RequireNotFrozen()
	tx.submitKey = publicKey
	return tx
}

// GetSubmitKey returns the key required for submitting messages to the topic
func (tx *TopicCreateTransaction) GetSubmitKey() (Key, error) {
	return tx.submitKey, nil
}

// SetTopicMemo sets a short publicly visible memo about the topic. No guarantee of uniqueness.
func (tx *TopicCreateTransaction) SetTopicMemo(memo string) *TopicCreateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo
	return tx
}

// GetTopicMemo returns the memo for this topic
func (tx *TopicCreateTransaction) GetTopicMemo() string {
	return tx.memo
}

// SetAutoRenewPeriod sets the initial lifetime of the topic and the amount of time to extend the topic's lifetime
// automatically at expirationTime if the autoRenewAccount is configured and has sufficient funds.
//
// Required. Limited to a maximum of 90 days (server-sIDe configuration which may change).
func (tx *TopicCreateTransaction) SetAutoRenewPeriod(period time.Duration) *TopicCreateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = &period
	return tx
}

// GetAutoRenewPeriod returns the auto renew period for this topic
func (tx *TopicCreateTransaction) GetAutoRenewPeriod() time.Duration {
	if tx.autoRenewPeriod != nil {
		return *tx.autoRenewPeriod
	}

	return time.Duration(0)
}

// SetAutoRenewAccountID sets an optional account to be used at the topic's expirationTime to extend the life of the
// topic. The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic can be
// extended using all funds on the account (whichever is the smaller duration/amount).
//
// If specified, there must be an adminKey and the autoRenewAccount must sign this transaction.
func (tx *TopicCreateTransaction) SetAutoRenewAccountID(autoRenewAccountID AccountID) *TopicCreateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewAccountID = &autoRenewAccountID
	return tx
}

// GetAutoRenewAccountID returns the auto renew account ID for this topic
func (tx *TopicCreateTransaction) GetAutoRenewAccountID() AccountID {
	if tx.autoRenewAccountID == nil {
		return AccountID{}
	}

	return *tx.autoRenewAccountID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TopicCreateTransaction) Sign(privateKey PrivateKey) *TopicCreateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TopicCreateTransaction) SignWithOperator(client *Client) (*TopicCreateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TopicCreateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TopicCreateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TopicCreateTransaction) AddSignature(publicKey PublicKey, signature []byte) *TopicCreateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TopicCreateTransaction) SetGrpcDeadline(deadline *time.Duration) *TopicCreateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TopicCreateTransaction) Freeze() (*TopicCreateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TopicCreateTransaction) FreezeWith(client *Client) (*TopicCreateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TopicCreateTransaction.
func (tx *TopicCreateTransaction) SetMaxTransactionFee(fee Hbar) *TopicCreateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TopicCreateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TopicCreateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TopicCreateTransaction.
func (tx *TopicCreateTransaction) SetTransactionMemo(memo string) *TopicCreateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TopicCreateTransaction.
func (tx *TopicCreateTransaction) SetTransactionValidDuration(duration time.Duration) *TopicCreateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TopicCreateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TopicCreateTransaction.
func (tx *TopicCreateTransaction) SetTransactionID(transactionID TransactionID) *TopicCreateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TopicCreateTransaction.
func (tx *TopicCreateTransaction) SetNodeAccountIDs(nodeID []AccountID) *TopicCreateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TopicCreateTransaction) SetMaxRetry(count int) *TopicCreateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TopicCreateTransaction) SetMaxBackoff(max time.Duration) *TopicCreateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TopicCreateTransaction) SetMinBackoff(min time.Duration) *TopicCreateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TopicCreateTransaction) SetLogLevel(level LogLevel) *TopicCreateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TopicCreateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TopicCreateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TopicCreateTransaction) getName() string {
	return "TopicCreateTransaction"
}

func (tx *TopicCreateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.autoRenewAccountID != nil {
		if err := tx.autoRenewAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TopicCreateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ConsensusCreateTopic{
			ConsensusCreateTopic: tx.buildProtoBody(),
		},
	}
}

func (tx *TopicCreateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_ConsensusCreateTopic{
			ConsensusCreateTopic: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TopicCreateTransaction) buildProtoBody() *services.ConsensusCreateTopicTransactionBody {
	body := &services.ConsensusCreateTopicTransactionBody{
		Memo: tx.memo,
	}

	if tx.autoRenewPeriod != nil {
		body.AutoRenewPeriod = _DurationToProtobuf(*tx.autoRenewPeriod)
	}

	if tx.autoRenewAccountID != nil {
		body.AutoRenewAccount = tx.autoRenewAccountID._ToProtobuf()
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	if tx.submitKey != nil {
		body.SubmitKey = tx.submitKey._ToProtoKey()
	}

	return body
}

func (tx *TopicCreateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetTopic().CreateTopic,
	}
}
func (tx *TopicCreateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: topic_create_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTopicCreateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetSubmitKey(env.Client.GetOperatorPublicKey()).
		SetTopicMemo(topicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	info, err := NewTopicInfoQuery().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, info)

	assert.Equal(t, topicMemo, info.TopicMemo)
	assert.Equal(t, uint64(0), info.SequenceNumber)
	assert.Equal(t, env.Client.GetOperatorPublicKey().String(), info.AdminKey.String())

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicCreateTransactionDifferentKeys(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	keys := make([]PrivateKey, 2)
	pubKeys := make([]PublicKey, 2)

	for i := range keys {
		newKey, err := PrivateKeyGenerateEd25519()
		require.NoError(t, err)

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	tx, err := NewTopicCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetAdminKey(pubKeys[0]).
		SetSubmitKey(pubKeys[1]).
		SetTopicMemo(topicMemo).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx, err = tx.SignWithOperator(env.Client)
	require.NoError(t, err)
	tx.Sign(keys[0])
	resp, err := tx.Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	info, err := NewTopicInfoQuery().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, info)

	assert.Equal(t, topicMemo, info.TopicMemo)
	assert.Equal(t, uint64(0), info.SequenceNumber)
	assert.Equal(t, pubKeys[0].String(), info.AdminKey.String())

	txDelete, err := NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = txDelete.Sign(keys[0]).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicCreateTransactionJustSetMemo(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTopicCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(topicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: topic_create_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTopicCreateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	topicCreate := NewTopicCreateTransaction().
		SetAutoRenewAccountID(accountID)

	err = topicCreate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTopicCreateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	topicCreate := NewTopicCreateTransaction().
		SetAutoRenewAccountID(accountID)

	err = topicCreate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTopicCreateTransactionGet(t *testing.T) {
	t.Parallel()

	accountID := AccountID{Account: 3}

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTopicCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAutoRenewAccountID(accountID).
		SetAdminKey(newKey).
		SetSubmitKey(newKey).
		SetTopicMemo("ad").
		SetAutoRenewPeriod(60 * time.Second).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAutoRenewAccountID()
	transaction.GetAdminKey()
	transaction.GetSubmitKey()
	transaction.GetTopicMemo()
	transaction.GetAutoRenewPeriod()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTopicCreateTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTopicCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetAutoRenewAccountID()
	transaction.GetAdminKey()
	transaction.GetSubmitKey()
	transaction.GetTopicMemo()
	transaction.GetAutoRenewPeriod()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTopicCreateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	accountID := AccountID{Account: 23}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	newKey2, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	transaction, err := NewTopicCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(newKey).
		SetSubmitKey(newKey2).
		SetAutoRenewAccountID(accountID).
		SetTopicMemo("memo").
		SetAutoRenewPeriod(time.Second * 3).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetConsensusCreateTopic()
	require.Equal(t, proto.AdminKey.String(), newKey._ToProtoKey().String())
	require.Equal(t, proto.SubmitKey.String(), newKey2._ToProtoKey().String())
	require.Equal(t, proto.Memo, "memo")
	require.Equal(t, proto.AutoRenewPeriod.Seconds, _DurationToProtobuf(time.Second*3).Seconds)
	require.Equal(t, proto.AutoRenewAccount.String(), accountID._ToProtobuf().String())
}

func TestUnitTopicCreateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	account := AccountID{Account: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTopicCreateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAdminKey(newKey).
		SetTopicMemo("ad").
		SetSubmitKey(newKey).
		SetAutoRenewAccountID(account).
		SetAutoRenewPeriod(time.Second * 30).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetAdminKey()
	transaction.GetSubmitKey()
	transaction.GetTopicMemo()
	transaction.GetAutoRenewAccountID()
	transaction.GetAutoRenewPeriod()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TopicCreateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTopicCreateTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	freez, err := NewTopicCreateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetAdminKey(newKey).
		SetSubmitKey(newKey).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}

func TestUnitTopicCreateTransactionSerialization(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})
	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	topicCreate, err := NewTopicCreateTransaction().
		SetTransactionID(transactionID).
		SetAdminKey(newKey).
		SetNodeAccountIDs(nodeAccountID).
		SetSubmitKey(newKey).
		SetTopicMemo("ad").
		SetAutoRenewPeriod(time.Second * 30).
		Freeze()
	require.NoError(t, err)

	transactionBytes, err := topicCreate.ToBytes()
	require.NoError(t, err)

	txParsed, err := TransactionFromBytes(transactionBytes)
	require.NoError(t, err)

	result, ok := txParsed.(TopicCreateTransaction)
	require.True(t, ok)

	require.Equal(t, topicCreate.GetTopicMemo(), result.GetTopicMemo())
	require.Equal(t, topicCreate.GetAutoRenewPeriod(), result.GetAutoRenewPeriod())
	adminKey, _ := result.GetAdminKey()
	require.Equal(t, newKey.PublicKey(), adminKey)
	submitKey, _ := result.GetSubmitKey()
	require.Equal(t, newKey.PublicKey(), submitKey)
}
// Filename: topic_delete_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"

	"time"
)

// TopicDeleteTransaction is for deleting a topic on HCS.
type TopicDeleteTransaction struct {
	Transaction
	topicID *TopicID
}

// NewTopicDeleteTransaction creates a TopicDeleteTransaction which can be used to construct
// and execute a Consensus Delete Topic Transaction.
func NewTopicDeleteTransaction() *TopicDeleteTransaction {
	tx := TopicDeleteTransaction{
		Transaction: _NewTransaction(),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _TopicDeleteTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TopicDeleteTransaction {
	return &TopicDeleteTransaction{
		Transaction: tx,
		topicID:     _TopicIDFromProtobuf(pb.GetConsensusDeleteTopic().GetTopicID()),
	}
}

// SetTopicID sets the topic IDentifier.
func (tx *TopicDeleteTransaction) SetTopicID(topicID TopicID) *TopicDeleteTransaction {
	tx._RequireNotFrozen()
	tx.topicID = &topicID
	return tx
}

// GetTopicID returns the topic IDentifier.
func (tx *TopicDeleteTransaction) GetTopicID() TopicID {
	if tx.topicID == nil {
		return TopicID{}
	}

	return *tx.topicID
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TopicDeleteTransaction) Sign(privateKey PrivateKey) *TopicDeleteTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TopicDeleteTransaction) SignWithOperator(client *Client) (*TopicDeleteTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TopicDeleteTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TopicDeleteTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TopicDeleteTransaction) AddSignature(publicKey PublicKey, signature []byte) *TopicDeleteTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TopicDeleteTransaction) SetGrpcDeadline(deadline *time.Duration) *TopicDeleteTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TopicDeleteTransaction) Freeze() (*TopicDeleteTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TopicDeleteTransaction) FreezeWith(client *Client) (*TopicDeleteTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TopicDeleteTransaction.
func (tx *TopicDeleteTransaction) SetMaxTransactionFee(fee Hbar) *TopicDeleteTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TopicDeleteTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TopicDeleteTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TopicDeleteTransaction.
func (tx *TopicDeleteTransaction) SetTransactionMemo(memo string) *TopicDeleteTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TopicDeleteTransaction.
func (tx *TopicDeleteTransaction) SetTransactionValidDuration(duration time.Duration) *TopicDeleteTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TopicDeleteTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TopicDeleteTransaction.
func (tx *TopicDeleteTransaction) SetTransactionID(transactionID TransactionID) *TopicDeleteTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TopicDeleteTransaction.
func (tx *TopicDeleteTransaction) SetNodeAccountIDs(nodeID []AccountID) *TopicDeleteTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TopicDeleteTransaction) SetMaxRetry(count int) *TopicDeleteTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TopicDeleteTransaction) SetMaxBackoff(max time.Duration) *TopicDeleteTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TopicDeleteTransaction) SetMinBackoff(min time.Duration) *TopicDeleteTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TopicDeleteTransaction) SetLogLevel(level LogLevel) *TopicDeleteTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TopicDeleteTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TopicDeleteTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TopicDeleteTransaction) getName() string {
	return "TopicDeleteTransaction"
}

func (tx *TopicDeleteTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.topicID != nil {
		if err := tx.topicID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TopicDeleteTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ConsensusDeleteTopic{
			ConsensusDeleteTopic: tx.buildProtoBody(),
		},
	}
}

func (tx *TopicDeleteTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_ConsensusDeleteTopic{
			ConsensusDeleteTopic: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TopicDeleteTransaction) buildProtoBody() *services.ConsensusDeleteTopicTransactionBody {
	body := &services.ConsensusDeleteTopicTransactionBody{}
	if tx.topicID != nil {
		body.TopicID = tx.topicID._ToProtobuf()
	}

	return body
}

func (tx *TopicDeleteTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetTopic().DeleteTopic,
	}
}
func (tx *TopicDeleteTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: topic_delete_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTopicDeleteTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	topicMemo := "go-sdk::TestConsensusTopicDeleteTransaction_Execute"

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(topicMemo).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	_, err = NewTopicInfoQuery().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	_, err = NewTopicInfoQuery().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTopicID(topicID).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_TOPIC_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicDeleteTransactionNoTopicID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	topicMemo := "go-sdk::TestConsensusTopicDeleteTransaction_Execute"

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(topicMemo).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	_, err = NewTopicInfoQuery().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	resp, err = NewTopicDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.Error(t, err)
	if err != nil {
		assert.ErrorContains(t, err, "exceptional precheck status INVALID_TOPIC_ID")
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: topic_delete_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTopicDeleteTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	topicID, err := TopicIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	topicDelete := NewTopicDeleteTransaction().
		SetTopicID(topicID)

	err = topicDelete.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTopicDeleteTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	topicID, err := TopicIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	topicDelete := NewTopicDeleteTransaction().
		SetTopicID(topicID)

	err = topicDelete.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTopicDeleteTransactionGet(t *testing.T) {
	t.Parallel()

	topicID := TopicID{Topic: 7}

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTopicDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTopicID(topicID).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTopicID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTopicDeleteTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTopicDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTopicID()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTopicDeleteTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	topic := TopicID{Topic: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTopicDeleteTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTopicID(topic).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTopicID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TopicDeleteTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTopicDeleteTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	topic := TopicID{Topic: 3, checksum: &checksum}

	freez, err := NewTopicDeleteTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTopicID(topic).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: topic_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/pkg/errors"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// TopicID is a unique identifier for a topic (used by the  service)
type TopicID struct {
	Shard    uint64
	Realm    uint64
	Topic    uint64
	checksum *string
}

// TopicIDFromString constructs a TopicID from a string formatted as `Shard.Realm.Topic` (for example "0.0.3")
func TopicIDFromString(data string) (TopicID, error) {
	shard, realm, num, checksum, err := _IdFromString(data)
	if err != nil {
		return TopicID{}, err
	}

	return TopicID{
		Shard:    uint64(shard),
		Realm:    uint64(realm),
		Topic:    uint64(num),
		checksum: checksum,
	}, nil
}

// Verify that the client has a valid checksum.
func (id *TopicID) ValidateChecksum(client *Client) error {
	if !id._IsZero() && client != nil {
		tempChecksum, err := _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Topic))
		if err != nil {
			return err
		}
		err = _ChecksumVerify(tempChecksum.status)
		if err != nil {
			return err
		}
		if id.checksum == nil {
			return errChecksumMissing
		}
		if tempChecksum.correctChecksum != *id.checksum {
			networkName := NetworkNameOther
			if client.network.ledgerID != nil {
				networkName, _ = client.network.ledgerID.ToNetworkName()
			}
			return errors.New(fmt.Sprintf("network mismatch or wrong checksum given, given checksum: %s, correct checksum %s, network: %s",
				*id.checksum,
				tempChecksum.correctChecksum,
				networkName))
		}
	}

	return nil
}

// Deprecated - use ValidateChecksum instead
func (id *TopicID) Validate(client *Client) error {
	return id.ValidateChecksum(client)
}

func (id TopicID) _IsZero() bool {
	return id.Shard == 0 && id.Realm == 0 && id.Topic == 0
}

// String returns the string representation of a TopicID in `Shard.Realm.Topic` (for example "0.0.3")
func (id TopicID) String() string {
	return fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Topic)
}

// ToStringWithChecksum returns the string representation of a TopicID in `Shard.Realm.Topic-Checksum` (for example "0.0.3-abcde")
func (id TopicID) ToStringWithChecksum(client Client) (string, error) {
	if client.GetNetworkName() == nil && client.GetLedgerID() == nil {
		return "", errNetworkNameMissing
	}
	var checksum _ParseAddressResult
	var err error
	if client.network.ledgerID != nil {
		checksum, err = _ChecksumParseAddress(client.GetLedgerID(), fmt.Sprintf("%d.%d.%d", id.Shard, id.Realm, id.Topic))
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%d.%d.%d-%s", id.Shard, id.Realm, id.Topic, checksum.correctChecksum), nil
}

func (id TopicID) _ToProtobuf() *services.TopicID {
	return &services.TopicID{
		ShardNum: int64(id.Shard),
		RealmNum: int64(id.Realm),
		TopicNum: int64(id.Topic),
	}
}

func _TopicIDFromProtobuf(topicID *services.TopicID) *TopicID {
	if topicID == nil {
		return nil
	}

	return &TopicID{
		Shard: uint64(topicID.ShardNum),
		Realm: uint64(topicID.RealmNum),
		Topic: uint64(topicID.TopicNum),
	}
}

// ToBytes returns a byte array representation of the TopicID
func (id TopicID) ToBytes() []byte {
	data, err := protobuf.Marshal(id._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TopicIDFromBytes constructs a TopicID from a byte array
func TopicIDFromBytes(data []byte) (TopicID, error) {
	if data == nil {
		return TopicID{}, errByteArrayNull
	}
	pb := services.TopicID{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TopicID{}, err
	}

	return *_TopicIDFromProtobuf(&pb), nil
}

// TopicIDFromSolidityAddress constructs an TopicID from a string
// representation of a _Solidity address
func TopicIDFromSolidityAddress(s string) (TopicID, error) {
	shard, realm, topic, err := _IdFromSolidityAddress(s)
	if err != nil {
		return TopicID{}, err
	}

	return TopicID{
		Shard:    shard,
		Realm:    realm,
		Topic:    topic,
		checksum: nil,
	}, nil
}

// ToSolidityAddress returns the string representation of the TopicID as a
// _Solidity address.
func (id TopicID) ToSolidityAddress() string {
	return _IdToSolidityAddress(id.Shard, id.Realm, id.Topic)
}
// Filename: topic_info.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// TopicInfo is the information about a topic
type TopicInfo struct {
	TopicMemo          string
	RunningHash        []byte
	SequenceNumber     uint64
	ExpirationTime     time.Time
	AdminKey           Key
	SubmitKey          Key
	AutoRenewPeriod    time.Duration
	AutoRenewAccountID *AccountID
	LedgerID           LedgerID
}

func _TopicInfoFromProtobuf(topicInfo *services.ConsensusTopicInfo) (TopicInfo, error) {
	if topicInfo == nil {
		return TopicInfo{}, errParameterNull
	}
	var err error
	tempTopicInfo := TopicInfo{
		TopicMemo:      topicInfo.Memo,
		RunningHash:    topicInfo.RunningHash,
		SequenceNumber: topicInfo.SequenceNumber,
		LedgerID:       LedgerID{topicInfo.LedgerId},
	}

	if autoRenewPeriod := topicInfo.AutoRenewPeriod; autoRenewPeriod != nil {
		tempTopicInfo.AutoRenewPeriod = _DurationFromProtobuf(topicInfo.AutoRenewPeriod)
	}

	if expirationTime := topicInfo.ExpirationTime; expirationTime != nil {
		tempTopicInfo.ExpirationTime = _TimeFromProtobuf(expirationTime)
	}

	if adminKey := topicInfo.AdminKey; adminKey != nil {
		tempTopicInfo.AdminKey, err = _KeyFromProtobuf(adminKey)
	}

	if submitKey := topicInfo.SubmitKey; submitKey != nil {
		tempTopicInfo.SubmitKey, err = _KeyFromProtobuf(submitKey)
	}

	if autoRenewAccount := topicInfo.AutoRenewAccount; autoRenewAccount != nil {
		tempTopicInfo.AutoRenewAccountID = _AccountIDFromProtobuf(autoRenewAccount)
	}

	return tempTopicInfo, err
}

func (topicInfo *TopicInfo) _ToProtobuf() *services.ConsensusTopicInfo {
	return &services.ConsensusTopicInfo{
		Memo:           topicInfo.TopicMemo,
		RunningHash:    topicInfo.RunningHash,
		SequenceNumber: topicInfo.SequenceNumber,
		ExpirationTime: &services.Timestamp{
			Seconds: int64(topicInfo.ExpirationTime.Second()),
			Nanos:   int32(topicInfo.ExpirationTime.Nanosecond()),
		},
		AdminKey:         topicInfo.AdminKey._ToProtoKey(),
		SubmitKey:        topicInfo.SubmitKey._ToProtoKey(),
		AutoRenewPeriod:  _DurationToProtobuf(topicInfo.AutoRenewPeriod),
		AutoRenewAccount: topicInfo.AutoRenewAccountID._ToProtobuf(),
		LedgerId:         topicInfo.LedgerID.ToBytes(),
	}
}

// ToBytes returns a byte array representation of the TopicInfo object
func (topicInfo TopicInfo) ToBytes() []byte {
	data, err := protobuf.Marshal(topicInfo._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TopicInfoFromBytes returns a TopicInfo object from a byte array
func TopicInfoFromBytes(data []byte) (TopicInfo, error) {
	if data == nil {
		return TopicInfo{}, errByteArrayNull
	}
	pb := services.ConsensusTopicInfo{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TopicInfo{}, err
	}

	info, err := _TopicInfoFromProtobuf(&pb)
	if err != nil {
		return TopicInfo{}, err
	}

	return info, nil
}
// Filename: topic_info_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TopicInfo is the Query for retrieving information about a topic stored on the Hedera network.
type TopicInfoQuery struct {
	Query
	topicID *TopicID
}

// NewTopicInfoQuery creates a TopicInfoQuery query which can be used to construct and execute a
//
//	Get Topic Info Query.
func NewTopicInfoQuery() *TopicInfoQuery {
	header := services.QueryHeader{}
	return &TopicInfoQuery{
		Query: _NewQuery(true, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *TopicInfoQuery) SetGrpcDeadline(deadline *time.Duration) *TopicInfoQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetTopicID sets the topic to retrieve info about (the parameters and running state of).
func (q *TopicInfoQuery) SetTopicID(topicID TopicID) *TopicInfoQuery {
	q.topicID = &topicID
	return q
}

// GetTopicID returns the TopicID for this TopicInfoQuery
func (q *TopicInfoQuery) GetTopicID() TopicID {
	if q.topicID == nil {
		return TopicID{}
	}

	return *q.topicID
}

func (q *TopicInfoQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the TopicInfoQuery using the provided client
func (q *TopicInfoQuery) Execute(client *Client) (TopicInfo, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		return TopicInfo{}, err
	}

	return _TopicInfoFromProtobuf(resp.GetConsensusGetTopicInfo().TopicInfo)
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *TopicInfoQuery) SetMaxQueryPayment(maxPayment Hbar) *TopicInfoQuery {
	q.Query.SetMaxQueryPayment(maxPayment)
	return q
}

// SetQueryPayment sets the payment amount for this Query.
func (q *TopicInfoQuery) SetQueryPayment(paymentAmount Hbar) *TopicInfoQuery {
	q.Query.SetQueryPayment(paymentAmount)
	return q
}

// SetNodeAccountIDs sets the _Node AccountID for this TopicInfoQuery.
func (q *TopicInfoQuery) SetNodeAccountIDs(accountID []AccountID) *TopicInfoQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *TopicInfoQuery) SetMaxRetry(count int) *TopicInfoQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *TopicInfoQuery) SetMaxBackoff(max time.Duration) *TopicInfoQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *TopicInfoQuery) SetMinBackoff(min time.Duration) *TopicInfoQuery {
	q.Query.SetMinBackoff(min)
	return q
}

func (q *TopicInfoQuery) SetPaymentTransactionID(transactionID TransactionID) *TopicInfoQuery {
	q.paymentTransactionIDs._Clear()._Push(transactionID)._SetLocked(true)
	return q
}

func (q *TopicInfoQuery) SetLogLevel(level LogLevel) *TopicInfoQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *TopicInfoQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetTopic().GetTopicInfo,
	}
}

func (q *TopicInfoQuery) getName() string {
	return "TopicInfoQuery"
}

func (q *TopicInfoQuery) buildQuery() *services.Query {
	body := &services.ConsensusGetTopicInfoQuery{
		Header: q.pbHeader,
	}

	if q.topicID != nil {
		body.TopicID = q.topicID._ToProtobuf()
	}

	return &services.Query{
		Query: &services.Query_ConsensusGetTopicInfo{
			ConsensusGetTopicInfo: body,
		},
	}
}

func (q *TopicInfoQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if q.topicID != nil {
		if err := q.topicID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (q *TopicInfoQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetConsensusGetTopicInfo()
}
// Filename: topic_info_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

const topicMemo = "go-sdk::topic memo"

func TestIntegrationTopicInfoQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	txID, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(topicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txID.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	info, err := NewTopicInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicID(topicID).
		SetMaxQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, info)

	assert.Equal(t, topicMemo, info.TopicMemo)
	assert.Equal(t, uint64(0), info.SequenceNumber)
	assert.Equal(t, env.Client.GetOperatorPublicKey().String(), info.AdminKey.String())

	_, err = NewTopicDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicID(topicID).
		Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicInfoQueryGetCost(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(topicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	topicInfo := NewTopicInfoQuery().
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTopicID(topicID)

	cost, err := topicInfo.GetCost(env.Client)
	require.NoError(t, err)

	_, err = topicInfo.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	_, err = NewTopicDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicID(topicID).
		Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicInfoQuerySetBigMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(topicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	topicInfo := NewTopicInfoQuery().
		SetMaxQueryPayment(NewHbar(100000)).
		SetTopicID(topicID)

	cost, err := topicInfo.GetCost(env.Client)
	require.NoError(t, err)

	_, err = topicInfo.SetQueryPayment(cost).Execute(env.Client)
	require.NoError(t, err)

	_, err = NewTopicDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicID(topicID).
		Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicInfoQuerySetSmallMaxPayment(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(topicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	topicInfo := NewTopicInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetMaxQueryPayment(HbarFromTinybar(1)).
		SetTopicID(topicID)

	cost, err := topicInfo.GetCost(env.Client)
	require.NoError(t, err)

	_, err = topicInfo.Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "cost of TopicInfoQuery ("+cost.String()+") without explicit payment is greater than the max query payment of 1 tℏ", err.Error())
	}

	_, err = NewTopicDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicID(topicID).
		Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicInfoQueryInsufficientFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(topicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	topicInfo := NewTopicInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetMaxQueryPayment(NewHbar(1)).
		SetTopicID(topicID)

	_, err = topicInfo.GetCost(env.Client)
	require.NoError(t, err)

	_, err = topicInfo.SetQueryPayment(HbarFromTinybar(1)).Execute(env.Client)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INSUFFICIENT_TX_FEE", err.Error())
	}

	_, err = NewTopicDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicID(topicID).
		Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicInfoQueryThreshold(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	keys := make([]PrivateKey, 3)
	pubKeys := make([]PublicKey, 3)

	for i := range keys {
		newKey, err := PrivateKeyGenerateEd25519()
		if err != nil {
			panic(err)
		}

		keys[i] = newKey
		pubKeys[i] = newKey.PublicKey()
	}

	thresholdKey := KeyListWithThreshold(2).
		AddAllPublicKeys(pubKeys)

	txID, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetSubmitKey(thresholdKey).
		SetTopicMemo(topicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := txID.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	info, err := NewTopicInfoQuery().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicID(topicID).
		SetMaxQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, info)

	assert.Equal(t, topicMemo, info.TopicMemo)
	assert.Equal(t, uint64(0), info.SequenceNumber)
	assert.Equal(t, env.Client.GetOperatorPublicKey().String(), info.AdminKey.String())
	assert.NotEmpty(t, info.SubmitKey.String())

	_, err = NewTopicDeleteTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicID(topicID).
		Execute(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicInfoQueryNoTopicID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	_, err := NewTopicInfoQuery().
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional precheck status INVALID_TOPIC_ID", err.Error())
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: topic_info_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/stretchr/testify/require"
)

func TestUnitTopicInfoQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	topicID, err := TopicIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	err = topicID.Validate(client)
	require.NoError(t, err)
	topicInfo := NewTopicInfoQuery().
		SetTopicID(topicID)

	err = topicInfo.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTopicInfoQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	topicID, err := TopicIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	err = topicID.Validate(client)
	require.Error(t, err)
	topicInfo := NewTopicInfoQuery().
		SetTopicID(topicID)

	err = topicInfo.validateNetworkOnIDs(client)
	require.Error(t, err)
	if err != nil {
		require.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTopicInfoQueryGet(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	topicID := TopicID{Topic: 3, checksum: &checksum}
	deadline := time.Duration(time.Minute)
	accountId := AccountID{Account: 123}
	transactionID := TransactionIDGenerate(accountId)
	query := NewTopicInfoQuery().
		SetTopicID(topicID).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}}).
		SetMaxRetry(3).
		SetMinBackoff(300 * time.Millisecond).
		SetMaxBackoff(10 * time.Second).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(500)).
		SetGrpcDeadline(&deadline)
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	err = query.validateNetworkOnIDs(client)
	require.NoError(t, err)
	require.Equal(t, topicID, query.GetTopicID())
	require.Equal(t, []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}, query.GetNodeAccountIDs())
	require.Equal(t, 300*time.Millisecond, query.GetMinBackoff())
	require.Equal(t, 10*time.Second, query.GetMaxBackoff())
	require.Equal(t, 3, query.GetMaxRetryCount())
	require.Equal(t, transactionID, query.GetPaymentTransactionID())
	require.Equal(t, HbarFromTinybar(25), query.GetQueryPayment())
	require.Equal(t, NewHbar(500), query.GetMaxQueryPayment())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}

func TestUnitTopicInfoQueryNothingSet(t *testing.T) {
	t.Parallel()

	query := NewTopicInfoQuery()

	require.Equal(t, TopicID{}, query.GetTopicID())
	require.Equal(t, []AccountID{}, query.GetNodeAccountIDs())
	require.Equal(t, 250*time.Millisecond, query.GetMinBackoff())
	require.Equal(t, 8*time.Second, query.GetMaxBackoff())
	require.Equal(t, 10, query.GetMaxRetryCount())
	require.Equal(t, TransactionID{}, query.GetPaymentTransactionID())
	require.Equal(t, Hbar{}, query.GetQueryPayment())
	require.Equal(t, Hbar{}, query.GetMaxQueryPayment())
}

func TestUnitTopicInfoQueryMock(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.Response{
			Response: &services.Response_ConsensusGetTopicInfo{
				ConsensusGetTopicInfo: &services.ConsensusGetTopicInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_ConsensusGetTopicInfo{
				ConsensusGetTopicInfo: &services.ConsensusGetTopicInfoResponse{
					Header: &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_COST_ANSWER, Cost: 2},
				},
			},
		},
		&services.Response{
			Response: &services.Response_ConsensusGetTopicInfo{
				ConsensusGetTopicInfo: &services.ConsensusGetTopicInfoResponse{
					Header:  &services.ResponseHeader{NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK, ResponseType: services.ResponseType_ANSWER_ONLY, Cost: 2},
					TopicID: nil,
					TopicInfo: &services.ConsensusTopicInfo{
						Memo:             "",
						RunningHash:      nil,
						SequenceNumber:   0,
						ExpirationTime:   nil,
						AdminKey:         nil,
						SubmitKey:        nil,
						AutoRenewPeriod:  nil,
						AutoRenewAccount: nil,
						LedgerId:         nil,
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	topic := TopicID{Topic: 3, checksum: &checksum}

	query := NewTopicInfoQuery().
		SetTopicID(topic).
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMaxQueryPayment(NewHbar(1))

	cost, err := query.GetCost(client)
	require.NoError(t, err)
	require.Equal(t, HbarFromTinybar(2), cost)
	_, err = query.Execute(client)
	require.NoError(t, err)
}
// Filename: topic_message.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/mirror"
)

// TopicMessage is a message from a topic}
type TopicMessage struct {
	ConsensusTimestamp time.Time
	Contents           []byte
	RunningHash        []byte
	SequenceNumber     uint64
	Chunks             []TopicMessageChunk
	TransactionID      *TransactionID
}

func _TopicMessageOfSingle(resp *mirror.ConsensusTopicResponse) TopicMessage {
	return TopicMessage{
		ConsensusTimestamp: _TimeFromProtobuf(resp.ConsensusTimestamp),
		Contents:           resp.Message,
		RunningHash:        resp.RunningHash,
		SequenceNumber:     resp.SequenceNumber,
		Chunks:             nil,
		TransactionID:      nil,
	}
}

func _TopicMessageOfMany(message []*mirror.ConsensusTopicResponse) TopicMessage {
	length := len(message)
	size := uint64(0)
	chunks := make([]TopicMessageChunk, length)
	messages := make([][]byte, length)
	var transactionID *TransactionID = nil

	for _, m := range message {
		if transactionID == nil {
			value := _TransactionIDFromProtobuf(m.ChunkInfo.InitialTransactionID)
			transactionID = &value
		}

		chunks[m.ChunkInfo.Number-1] = _NewTopicMessageChunk(m)
		messages[m.ChunkInfo.Number-1] = m.Message
		size += uint64(len(m.Message))
	}

	finalMessage := make([]byte, 0, size)

	for _, m := range messages {
		finalMessage = append(finalMessage, m...)
	}

	return TopicMessage{
		ConsensusTimestamp: _TimeFromProtobuf(message[length-1].ConsensusTimestamp),
		RunningHash:        message[length-1].RunningHash,
		SequenceNumber:     message[length-1].SequenceNumber,
		Contents:           finalMessage,
		Chunks:             chunks,
		TransactionID:      transactionID,
	}
}
// Filename: topic_message_chunk.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/mirror"
)

// TopicMessageChunk is a chunk of a topic message
type TopicMessageChunk struct {
	ConsensusTimestamp time.Time
	ContentSize        uint64
	RunningHash        []byte
	SequenceNumber     uint64
}

func _NewTopicMessageChunk(resp *mirror.ConsensusTopicResponse) TopicMessageChunk {
	return TopicMessageChunk{
		ConsensusTimestamp: _TimeFromProtobuf(resp.ConsensusTimestamp),
		ContentSize:        uint64(len(resp.Message)),
		RunningHash:        resp.RunningHash,
		SequenceNumber:     resp.SequenceNumber,
	}
}
// Filename: topic_message_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"context"
	"io"
	"math"
	"regexp"
	"sync"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"

	"github.com/hashgraph/hedera-protobufs-go/mirror"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var rstStream = regexp.MustCompile("(?i)\\brst[^0-9a-zA-Z]stream\\b") //nolint

// TopicMessageQuery
// Query that listens to messages sent to the specific TopicID
type TopicMessageQuery struct {
	errorHandler      func(stat status.Status)
	completionHandler func()
	retryHandler      func(err error) bool
	attempt           uint64
	maxAttempts       uint64
	topicID           *TopicID
	startTime         *time.Time
	endTime           *time.Time
	limit             uint64
	mu                sync.Mutex
}

// NewTopicMessageQuery creates TopicMessageQuery which
// listens to messages sent to the specific TopicID
func NewTopicMessageQuery() *TopicMessageQuery {
	return &TopicMessageQuery{
		maxAttempts:       maxAttempts,
		errorHandler:      _DefaultErrorHandler,
		retryHandler:      _DefaultRetryHandler,
		completionHandler: _DefaultCompletionHandler,
	}
}

// SetTopicID Sets topic ID to retrieve messages for.
// Required
func (query *TopicMessageQuery) SetTopicID(topicID TopicID) *TopicMessageQuery {
	query.topicID = &topicID
	return query
}

// GetTopicID returns the TopicID for this TopicMessageQuery
func (query *TopicMessageQuery) GetTopicID() TopicID {
	if query.topicID == nil {
		return TopicID{}
	}

	return *query.topicID
}

// SetStartTime Sets time for when to start listening for messages. Defaults to current time if
// not set.
func (query *TopicMessageQuery) SetStartTime(startTime time.Time) *TopicMessageQuery {
	query.startTime = &startTime
	return query
}

// GetStartTime returns the start time for this TopicMessageQuery
func (query *TopicMessageQuery) GetStartTime() time.Time {
	if query.startTime != nil {
		return *query.startTime
	}

	return time.Time{}
}

// SetEndTime Sets time when to stop listening for messages. If not set it will receive
// indefinitely.
func (query *TopicMessageQuery) SetEndTime(endTime time.Time) *TopicMessageQuery {
	query.endTime = &endTime
	return query
}

func (query *TopicMessageQuery) GetEndTime() time.Time {
	if query.endTime != nil {
		return *query.endTime
	}

	return time.Time{}
}

// SetLimit Sets the maximum number of messages to receive before stopping. If not set or set to zero it will
// return messages indefinitely.
func (query *TopicMessageQuery) SetLimit(limit uint64) *TopicMessageQuery {
	query.limit = limit
	return query
}

func (query *TopicMessageQuery) GetLimit() uint64 {
	return query.limit
}

// SetMaxAttempts Sets the amount of attempts to try to retrieve message
func (query *TopicMessageQuery) SetMaxAttempts(maxAttempts uint64) *TopicMessageQuery {
	query.maxAttempts = maxAttempts
	return query
}

// GetMaxAttempts returns the amount of attempts to try to retrieve message
func (query *TopicMessageQuery) GetMaxAttempts() uint64 {
	return query.maxAttempts
}

// SetErrorHandler Sets the error handler for this query
func (query *TopicMessageQuery) SetErrorHandler(errorHandler func(stat status.Status)) *TopicMessageQuery {
	query.errorHandler = errorHandler
	return query
}

// SetCompletionHandler Sets the completion handler for this query
func (query *TopicMessageQuery) SetCompletionHandler(completionHandler func()) *TopicMessageQuery {
	query.completionHandler = completionHandler
	return query
}

// SetRetryHandler Sets the retry handler for this query
func (query *TopicMessageQuery) SetRetryHandler(retryHandler func(err error) bool) *TopicMessageQuery {
	query.retryHandler = retryHandler
	return query
}

func (query *TopicMessageQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if query.topicID != nil {
		if err := query.topicID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (query *TopicMessageQuery) build() *mirror.ConsensusTopicQuery {
	body := &mirror.ConsensusTopicQuery{
		Limit: query.limit,
	}
	if query.topicID != nil {
		body.TopicID = query.topicID._ToProtobuf()
	}

	if query.startTime != nil {
		body.ConsensusStartTime = _TimeToProtobuf(*query.startTime)
	} else {
		body.ConsensusStartTime = &services.Timestamp{}
	}

	if query.endTime != nil {
		body.ConsensusEndTime = _TimeToProtobuf(*query.endTime)
	}

	return body
}

// Subscribe subscribes to messages sent to the specific TopicID
func (query *TopicMessageQuery) Subscribe(client *Client, onNext func(TopicMessage)) (SubscriptionHandle, error) {
	var once sync.Once
	done := make(chan struct{})
	handle := SubscriptionHandle{}

	err := query.validateNetworkOnIDs(client)
	if err != nil {
		return SubscriptionHandle{}, err
	}

	pb := query.build()

	messages := make(map[string][]*mirror.ConsensusTopicResponse)

	channel, err := client.mirrorNetwork._GetNextMirrorNode()._GetConsensusServiceClient()
	if err != nil {
		return handle, err
	}

	go func() {
		query.mu.Lock()
		defer query.mu.Unlock()
		var subClient mirror.ConsensusService_SubscribeTopicClient
		var err error

		for {
			if err != nil {
				handle.Unsubscribe()

				if grpcErr, ok := status.FromError(err); ok { // nolint
					if query.attempt < query.maxAttempts && query.retryHandler(err) {
						subClient = nil

						delay := math.Min(250.0*math.Pow(2.0, float64(query.attempt)), 8000)
						time.Sleep(time.Duration(delay) * time.Millisecond)
						query.attempt++
					} else {
						query.errorHandler(*grpcErr)
						break
					}
				} else if err == io.EOF {
					query.completionHandler()
					break
				} else {
					panic(err)
				}
			}

			if subClient == nil {
				ctx, cancel := context.WithCancel(context.TODO())
				handle.onUnsubscribe = cancel
				once.Do(func() {
					close(done)
				})
				subClient, err = (*channel).SubscribeTopic(ctx, pb)

				if err != nil {
					continue
				}
			}

			var resp *mirror.ConsensusTopicResponse
			resp, err = subClient.Recv()

			if err != nil {
				continue
			}

			if resp.ConsensusTimestamp != nil {
				pb.ConsensusStartTime = _TimeToProtobuf(_TimeFromProtobuf(resp.ConsensusTimestamp).Add(1 * time.Nanosecond))
			}

			if pb.Limit > 0 {
				pb.Limit--
			}

			if resp.ChunkInfo == nil || resp.ChunkInfo.Total == 1 {
				onNext(_TopicMessageOfSingle(resp))
			} else {
				txID := _TransactionIDFromProtobuf(resp.ChunkInfo.InitialTransactionID).String()
				message, ok := messages[txID]
				if !ok {
					message = make([]*mirror.ConsensusTopicResponse, 0, resp.ChunkInfo.Total)
				}

				message = append(message, resp)
				messages[txID] = message

				if int32(len(message)) == resp.ChunkInfo.Total {
					delete(messages, txID)

					onNext(_TopicMessageOfMany(message))
				}
			}
		}
	}()
	<-done
	return handle, nil
}

func _DefaultErrorHandler(stat status.Status) {
	println("Failed to subscribe to topic with status", stat.Code().String())
}

func _DefaultCompletionHandler() {
	println("Subscription to topic finished")
}

func _DefaultRetryHandler(err error) bool {
	code := status.Code(err)

	switch code {
	case codes.NotFound, codes.ResourceExhausted, codes.Unavailable:
		return true
	case codes.Internal:
		grpcErr, ok := status.FromError(err)

		if !ok {
			return false
		}

		return rstStream.FindIndex([]byte(grpcErr.Message())) != nil
	default:
		return false
	}
}
// Filename: topic_message_query_e2e_test.go
//go:build all || e2e || testnets
// +build all e2e testnets

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"errors"
	"sync/atomic"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

// nolint
const bigContents = `
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.

Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.

Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.

Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.

Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.

Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.

Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.

Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.

Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.

In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.

Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.

Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.

Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.

Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.

Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.

Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.

Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.

Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.

Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.

Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.

Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.

In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.
`

func TestIntegrationTopicMessageQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	var finished int32 // 0 for false, 1 for true

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	time.Sleep(3 * time.Second)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	start := time.Now()

	_, err = NewTopicMessageQuery().
		SetTopicID(topicID).
		SetStartTime(time.Unix(0, 0)).
		SetLimit(1).
		SetCompletionHandler(func() {
			atomic.StoreInt32(&finished, 1)
		}).
		Subscribe(env.Client, func(message TopicMessage) {
			println(string(message.Contents))
			atomic.StoreInt32(&finished, 1)
		})
	require.NoError(t, err)

	resp, err = NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMessage("message").
		SetTopicID(topicID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	for {
		condition := atomic.LoadInt32(&finished) == 1 || uint64(time.Since(start).Seconds()) > 60
		if condition {
			break
		}

		time.Sleep(3 * time.Second)
	}

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	if atomic.LoadInt32(&finished) != 1 {
		err = errors.New("Message was not received within 60 seconds")
	}
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicMessageQueryNoTopicID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	var wait int32 = 1 // 1 for true, 0 for false
	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	start := time.Now()

	_, err = NewTopicMessageQuery().
		SetTopicID(topicID).
		SetStartTime(time.Unix(0, 0)).
		Subscribe(env.Client, func(message TopicMessage) {
			if string(message.Contents) == bigContents {
				atomic.StoreInt32(&wait, 0)
			}
		})
	require.NoError(t, err)

	_, err = NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMessage([]byte(bigContents)).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		require.ErrorContains(t, err, "exceptional precheck status INVALID_TOPIC_ID")
	}

	for {
		condition := atomic.LoadInt32(&wait) == 0 || err != nil || uint64(time.Since(start).Seconds()) > 30
		if condition {
			break
		}

		time.Sleep(3 * time.Second)
	}

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	if atomic.LoadInt32(&wait) == 1 {
		err = errors.New("Message was not received within 30 seconds")
	}
	assert.Error(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicMessageQueryNoMessage(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	var wait int32 = 1 // 1 for true, 0 for false
	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	start := time.Now()

	_, err = NewTopicMessageQuery().
		SetTopicID(topicID).
		SetStartTime(time.Unix(0, 0)).
		Subscribe(env.Client, func(message TopicMessage) {
			if string(message.Contents) == bigContents {
				atomic.StoreInt32(&wait, 0)
			}
		})
	require.NoError(t, err)

	_, err = NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTopicID(topicID).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "no transactions to execute", err.Error())
	}

	for {
		condition := atomic.LoadInt32(&wait) == 0 || err != nil || uint64(time.Since(start).Seconds()) > 30
		if condition {
			break
		}

		time.Sleep(3 * time.Second)
	}

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	if atomic.LoadInt32(&wait) == 1 {
		err = errors.New("Message was not received within 30 seconds")
	}

	assert.Error(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicMessageQueryNoStartTime(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	var finished int32 = 0 // 0 for false, 1 for true

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	start := time.Now()

	_, err = NewTopicMessageQuery().
		SetTopicID(topicID).
		SetLimit(14).
		SetEndTime(time.Now().Add(time.Second*20)).
		Subscribe(env.Client, func(message TopicMessage) {
			if string(message.Contents) == bigContents {
				atomic.StoreInt32(&finished, 1)
			}
		})

	require.NoError(t, err)

	resp, err = NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMessage([]byte(bigContents)).
		SetTopicID(topicID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	for {
		condition := atomic.LoadInt32(&finished) == 1 || uint64(time.Since(start).Seconds()) > 60
		if condition {
			break
		}

		time.Sleep(3 * time.Second)
	}

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	if atomic.LoadInt32(&finished) == 0 {
		err = errors.New("Message was not received within 60 seconds")
	}

	assert.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicMessageQueryWrongMessageType(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	var finished int32 // 0 for false, 1 for true

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	time.Sleep(3 * time.Second)

	topicID := *receipt.TopicID
	assert.NotNil(t, topicID)

	_, err = NewTopicMessageQuery().
		SetTopicID(topicID).
		SetStartTime(time.Unix(0, 0)).
		SetLimit(1).
		SetCompletionHandler(func() {
			atomic.StoreInt32(&finished, 1)
		}).
		Subscribe(env.Client, func(message TopicMessage) {
			println(string(message.Contents))
			atomic.StoreInt32(&finished, 1)
		})
	require.NoError(t, err)

	resp, err = NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMessage(1234). // wrong message type
		SetTopicID(topicID).
		Execute(env.Client)
	require.ErrorContains(t, err, "no transactions to execute")
}
// Filename: topic_message_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc/status"
)

func TestUnitTopicMessageQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	topicID, err := TopicIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	topicInfo := NewTopicMessageQuery().
		SetTopicID(topicID)

	err = topicInfo.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTopicMessageQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	topicID, err := TopicIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	topicInfo := NewTopicMessageQuery().
		SetTopicID(topicID)

	err = topicInfo.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTopicMessageQueryGet(t *testing.T) {
	t.Parallel()

	topicID := TopicID{Topic: 7}

	balance := NewTopicMessageQuery().
		SetTopicID(topicID).
		SetStartTime(time.Now()).
		SetMaxAttempts(23).
		SetEndTime(time.Now()).
		SetLimit(32).
		SetCompletionHandler(func() {}).
		SetErrorHandler(func(stat status.Status) {}).
		SetRetryHandler(func(err error) bool { return false })

	balance.GetTopicID()
	balance.GetStartTime()
	balance.GetMaxAttempts()
	balance.GetEndTime()
	balance.GetLimit()
}

func TestUnitTopicMessageQueryNothingSet(t *testing.T) {
	t.Parallel()

	balance := NewTopicMessageQuery()

	balance.GetTopicID()
	balance.GetStartTime()
	balance.GetMaxAttempts()
	balance.GetEndTime()
	balance.GetLimit()
}
// Filename: topic_message_submit_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/pkg/errors"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

const chunkSize = 1024

// TopicMessageSubmitTransaction
// Sends a message/messages to the Topic ID
type TopicMessageSubmitTransaction struct {
	Transaction
	maxChunks uint64
	message   []byte
	topicID   *TopicID
}

// NewTopicMessageSubmitTransaction createsTopicMessageSubmitTransaction which
// sends a message/messages to the Topic ID
func NewTopicMessageSubmitTransaction() *TopicMessageSubmitTransaction {
	tx := TopicMessageSubmitTransaction{
		Transaction: _NewTransaction(),
		maxChunks:   20,
		message:     make([]byte, 0),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _TopicMessageSubmitTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TopicMessageSubmitTransaction {
	return &TopicMessageSubmitTransaction{
		Transaction: tx,
		maxChunks:   20,
		message:     pb.GetConsensusSubmitMessage().GetMessage(),
		topicID:     _TopicIDFromProtobuf(pb.GetConsensusSubmitMessage().GetTopicID()),
	}
}

// SetTopicID Sets the topic to submit message to.
func (tx *TopicMessageSubmitTransaction) SetTopicID(topicID TopicID) *TopicMessageSubmitTransaction {
	tx._RequireNotFrozen()
	tx.topicID = &topicID
	return tx
}

// GetTopicID returns the TopicID for this TopicMessageSubmitTransaction
func (tx *TopicMessageSubmitTransaction) GetTopicID() TopicID {
	if tx.topicID == nil {
		return TopicID{}
	}

	return *tx.topicID
}

// SetMessage Sets the message to be submitted.
// The message should be a byte array or a string
// If other types are provided, it will not set the value
func (tx *TopicMessageSubmitTransaction) SetMessage(message interface{}) *TopicMessageSubmitTransaction {
	tx._RequireNotFrozen()
	switch m := message.(type) {
	case string:
		tx.message = []byte(m)
	case []byte:
		tx.message = m
	}
	return tx
}

func (tx *TopicMessageSubmitTransaction) GetMessage() []byte {
	return tx.message
}

// SetMaxChunks sets the maximum amount of chunks to use to send the message
func (tx *TopicMessageSubmitTransaction) SetMaxChunks(maxChunks uint64) *TopicMessageSubmitTransaction {
	tx._RequireNotFrozen()
	tx.maxChunks = maxChunks
	return tx
}

// GetMaxChunks returns the maximum amount of chunks to use to send the message
func (tx *TopicMessageSubmitTransaction) GetMaxChunks() uint64 {
	return tx.maxChunks
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TopicMessageSubmitTransaction) Sign(privateKey PrivateKey) *TopicMessageSubmitTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TopicMessageSubmitTransaction) SignWithOperator(client *Client) (*TopicMessageSubmitTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TopicMessageSubmitTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TopicMessageSubmitTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TopicMessageSubmitTransaction) AddSignature(publicKey PublicKey, signature []byte) *TopicMessageSubmitTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TopicMessageSubmitTransaction) SetGrpcDeadline(deadline *time.Duration) *TopicMessageSubmitTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TopicMessageSubmitTransaction) Freeze() (*TopicMessageSubmitTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TopicMessageSubmitTransaction) FreezeWith(client *Client) (*TopicMessageSubmitTransaction, error) {
	var err error
	if tx.nodeAccountIDs._Length() == 0 {
		if client == nil {
			return tx, errNoClientOrTransactionIDOrNodeId
		}

		tx.SetNodeAccountIDs(client.network._GetNodeAccountIDsForExecute())
	}

	tx._InitFee(client)
	err = tx.validateNetworkOnIDs(client)
	if err != nil {
		return &TopicMessageSubmitTransaction{}, err
	}
	if err := tx._InitTransactionID(client); err != nil {
		return tx, err
	}
	body := tx.build()

	chunks := uint64((len(tx.message) + (chunkSize - 1)) / chunkSize)
	if chunks > tx.maxChunks {
		return tx, ErrMaxChunksExceeded{
			Chunks:    chunks,
			MaxChunks: tx.maxChunks,
		}
	}

	initialTransactionID := tx.transactionIDs._GetCurrent().(TransactionID)
	nextTransactionID, _ := TransactionIdFromString(initialTransactionID.String())

	tx.transactionIDs = _NewLockableSlice()
	tx.transactions = _NewLockableSlice()
	tx.signedTransactions = _NewLockableSlice()
	if b, ok := body.Data.(*services.TransactionBody_ConsensusSubmitMessage); ok {
		for i := 0; uint64(i) < chunks; i++ {
			start := i * chunkSize
			end := start + chunkSize

			if end > len(tx.message) {
				end = len(tx.message)
			}

			tx.transactionIDs._Push(_TransactionIDFromProtobuf(nextTransactionID._ToProtobuf()))

			b.ConsensusSubmitMessage.Message = tx.message[start:end]
			b.ConsensusSubmitMessage.ChunkInfo = &services.ConsensusMessageChunkInfo{
				InitialTransactionID: initialTransactionID._ToProtobuf(),
				Total:                int32(chunks),
				Number:               int32(i) + 1,
			}

			body.TransactionID = nextTransactionID._ToProtobuf()
			body.Data = &services.TransactionBody_ConsensusSubmitMessage{
				ConsensusSubmitMessage: b.ConsensusSubmitMessage,
			}

			for _, nodeAccountID := range tx.nodeAccountIDs.slice {
				body.NodeAccountID = nodeAccountID.(AccountID)._ToProtobuf()

				bodyBytes, err := protobuf.Marshal(body)
				if err != nil {
					return tx, errors.Wrap(err, "error serializing tx body for topic submission")
				}

				tx.signedTransactions._Push(&services.SignedTransaction{
					BodyBytes: bodyBytes,
					SigMap:    &services.SignatureMap{},
				})
			}

			validStart := *nextTransactionID.ValidStart

			*nextTransactionID.ValidStart = validStart.Add(1 * time.Nanosecond)
		}
	}

	return tx, nil
}

// SetMaxTransactionFee sets the max transaction fee for this TopicMessageSubmitTransaction.
func (tx *TopicMessageSubmitTransaction) SetMaxTransactionFee(fee Hbar) *TopicMessageSubmitTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TopicMessageSubmitTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TopicMessageSubmitTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TopicMessageSubmitTransaction.
func (tx *TopicMessageSubmitTransaction) SetTransactionMemo(memo string) *TopicMessageSubmitTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TopicMessageSubmitTransaction.
func (tx *TopicMessageSubmitTransaction) SetTransactionValidDuration(duration time.Duration) *TopicMessageSubmitTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TopicMessageSubmitTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TopicMessageSubmitTransaction.
func (tx *TopicMessageSubmitTransaction) SetTransactionID(transactionID TransactionID) *TopicMessageSubmitTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TopicMessageSubmitTransaction.
func (tx *TopicMessageSubmitTransaction) SetNodeAccountIDs(nodeID []AccountID) *TopicMessageSubmitTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TopicMessageSubmitTransaction) SetMaxRetry(count int) *TopicMessageSubmitTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TopicMessageSubmitTransaction) SetMaxBackoff(max time.Duration) *TopicMessageSubmitTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TopicMessageSubmitTransaction) SetMinBackoff(min time.Duration) *TopicMessageSubmitTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TopicMessageSubmitTransaction) SetLogLevel(level LogLevel) *TopicMessageSubmitTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TopicMessageSubmitTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	chunks := uint64((len(tx.message) + (chunkSize - 1)) / chunkSize)
	if chunks > 1 {
		return &ScheduleCreateTransaction{}, ErrMaxChunksExceeded{
			Chunks:    chunks,
			MaxChunks: 1,
		}
	}

	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TopicMessageSubmitTransaction) getName() string {
	return "TopicMessageSubmitTransaction"
}
func (tx *TopicMessageSubmitTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.topicID != nil {
		if err := tx.topicID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TopicMessageSubmitTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ConsensusSubmitMessage{
			ConsensusSubmitMessage: tx.buildProtoBody(),
		},
	}
}

func (tx *TopicMessageSubmitTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_ConsensusSubmitMessage{
			ConsensusSubmitMessage: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TopicMessageSubmitTransaction) buildProtoBody() *services.ConsensusSubmitMessageTransactionBody {
	body := &services.ConsensusSubmitMessageTransactionBody{
		Message: tx.message,
	}

	if tx.topicID != nil {
		body.TopicID = tx.topicID._ToProtobuf()
	}

	return body
}

func (tx *TopicMessageSubmitTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetTopic().SubmitMessage,
	}
}

// Execute executes the Query with the provided client
func (tx *TopicMessageSubmitTransaction) Execute(
	client *Client,
) (TransactionResponse, error) {
	if client == nil {
		return TransactionResponse{}, errNoClientProvided
	}

	if tx.freezeError != nil {
		return TransactionResponse{}, tx.freezeError
	}

	list, err := tx.ExecuteAll(client)

	if err != nil {
		return TransactionResponse{}, err
	}

	if len(list) > 0 {
		return list[0], nil
	}

	return TransactionResponse{}, errNoTransactions
}

// ExecuteAll executes the all the Transactions with the provided client
func (tx *TopicMessageSubmitTransaction) ExecuteAll(
	client *Client,
) ([]TransactionResponse, error) {
	if !tx.IsFrozen() {
		_, err := tx.FreezeWith(client)
		if err != nil {
			return []TransactionResponse{}, err
		}
	}
	transactionID := tx.GetTransactionID()
	accountID := AccountID{}
	if transactionID.AccountID != nil {
		accountID = *transactionID.AccountID
	}

	if !client.GetOperatorAccountID()._IsZero() && client.GetOperatorAccountID()._Equals(accountID) {
		tx.SignWith(
			client.GetOperatorPublicKey(),
			client.operator.signer,
		)
	}

	size := tx.signedTransactions._Length() / tx.nodeAccountIDs._Length()
	list := make([]TransactionResponse, size)

	for i := 0; i < size; i++ {
		resp, err := _Execute(client, tx)

		if err != nil {
			return []TransactionResponse{}, err
		}

		list[i] = resp.(TransactionResponse)
	}

	return list, nil
}

func (tx *TopicMessageSubmitTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: topic_message_submit_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
	protobuf "google.golang.org/protobuf/proto"
)

const bigContents2 = `
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.

Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.

Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.

Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.

Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.

Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.

Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.

Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.

Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.

In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.

Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.

Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.

Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.

Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.

Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.

Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.

Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.

Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.

Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.

Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.

Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.

In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.
`

func TestUnitTopicMessageSubmitTransactionMock(t *testing.T) {
	t.Parallel()

	var previousTransactionID string
	var previousContent []byte

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)
		if previousTransactionID == "" {
			previousTransactionID = transactionId
		} else {
			require.NotEqual(t, transactionId, previousTransactionID)
			previousTransactionID = transactionId
		}

		content := transactionBody.Data.(*services.TransactionBody_ConsensusSubmitMessage).ConsensusSubmitMessage.Message

		if len(previousContent) == 0 {
			previousContent = content
		} else {
			require.NotEqual(t, previousContent, content)
			previousContent = content
		}

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call, call, call, call, call, call, call, call, call, call, call, call, call, call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	_, err := NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMessage([]byte(bigContents2)).
		SetTopicID(TopicID{Topic: 3}).
		Execute(client)
	require.NoError(t, err)
}

func TestUnitTopicMessageSubmitTransactionFreezeMock(t *testing.T) {
	t.Parallel()

	var previousTransactionID string
	var previousContent []byte

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)
		if previousTransactionID == "" {
			previousTransactionID = transactionId
		} else {
			require.NotEqual(t, transactionId, previousTransactionID)
			previousTransactionID = transactionId
		}

		content := transactionBody.Data.(*services.TransactionBody_ConsensusSubmitMessage).ConsensusSubmitMessage.Message

		if len(previousContent) == 0 {
			previousContent = content
		} else {
			require.NotEqual(t, previousContent, content)
			previousContent = content
		}

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		for _, sigPair := range sigMap.SigPair {
			verified := false

			switch k := sigPair.Signature.(type) {
			case *services.SignaturePair_Ed25519:
				pbTemp, _ := PublicKeyFromBytesEd25519(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.Ed25519)
			case *services.SignaturePair_ECDSASecp256K1:
				pbTemp, _ := PublicKeyFromBytesECDSA(sigPair.PubKeyPrefix)
				verified = pbTemp.Verify(signedTransaction.BodyBytes, k.ECDSASecp256K1)
			}
			require.True(t, verified)
		}

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call, call, call, call, call, call, call, call, call, call, call, call, call, call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	submit, err := NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetMessage([]byte(bigContents2)).
		SetTopicID(TopicID{Topic: 3}).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = submit.Execute(client)
	require.NoError(t, err)
}

func TestUnitTopicMessageSubmitTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	topic := TopicID{Topic: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTopicMessageSubmitTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTopicID(topic).
		SetMessage([]byte("nothing to see here")).
		SetMaxChunks(30).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetTopicID()
	transaction.GetMessage()
	transaction.GetMaxChunks()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TopicMessageSubmitTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTopicMessageSubmitTransactionSerialization(t *testing.T) {
	t.Parallel()

	topic := TopicID{Topic: 3}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTopicMessageSubmitTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTopicID(topic).
		SetMessage([]byte("nothing to see here")).
		SetMaxChunks(30).
		SetTransactionMemo("no").
		Freeze()
	require.NoError(t, err)

	txBytes, err := transaction.ToBytes()
	require.NoError(t, err)

	txParsed, err := TransactionFromBytes(txBytes)
	require.NoError(t, err)

	result, ok := txParsed.(TopicMessageSubmitTransaction)
	require.True(t, ok)

	require.Equal(t, transactionID.AccountID, result.GetTransactionID().AccountID)
	require.Equal(t, transaction.GetMessage(), result.GetMessage())
	require.Equal(t, transaction.GetTransactionMemo(), result.GetTransactionMemo())
}

func TestUnitTopicMessageSubmitTransactionSetMessage(t *testing.T) {
	t.Parallel()

	transaction := NewTopicMessageSubmitTransaction().
		SetNodeAccountIDs(nodeAccountID).
		SetMessage("String message").
		SetMaxChunks(30).
		SetTransactionMemo("no")

	txBytes, err := transaction.ToBytes()
	require.NoError(t, err)

	txParsed, err := TransactionFromBytes(txBytes)
	require.NoError(t, err)

	result, ok := txParsed.(TopicMessageSubmitTransaction)
	require.True(t, ok)

	require.Equal(t, transaction.GetMessage(), result.GetMessage())
	require.Equal(t, transaction.GetTransactionMemo(), result.GetTransactionMemo())

	transaction = NewTopicMessageSubmitTransaction().
		SetMessage(1234) // wrong type - NOOP

	require.Equal(t, []byte{}, transaction.GetMessage())
}
// Filename: topic_update_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TopicUpdateTransaction
// Updates all fields on a Topic that are set in the transaction.
type TopicUpdateTransaction struct {
	Transaction
	topicID            *TopicID
	autoRenewAccountID *AccountID
	adminKey           Key
	submitKey          Key
	memo               string
	autoRenewPeriod    *time.Duration
	expirationTime     *time.Time
}

// NewTopicUpdateTransaction creates a TopicUpdateTransaction transaction which
// updates all fields on a Topic that are set in the transaction.
func NewTopicUpdateTransaction() *TopicUpdateTransaction {
	tx := TopicUpdateTransaction{
		Transaction: _NewTransaction(),
	}

	tx.SetAutoRenewPeriod(7890000 * time.Second)
	tx._SetDefaultMaxTransactionFee(NewHbar(2))

	return &tx
}

func _TopicUpdateTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TopicUpdateTransaction {
	adminKey, _ := _KeyFromProtobuf(pb.GetConsensusUpdateTopic().GetAdminKey())
	submitKey, _ := _KeyFromProtobuf(pb.GetConsensusUpdateTopic().GetSubmitKey())

	expirationTime := _TimeFromProtobuf(pb.GetConsensusUpdateTopic().GetExpirationTime())
	autoRenew := _DurationFromProtobuf(pb.GetConsensusUpdateTopic().GetAutoRenewPeriod())
	return &TopicUpdateTransaction{
		Transaction:        tx,
		topicID:            _TopicIDFromProtobuf(pb.GetConsensusUpdateTopic().GetTopicID()),
		autoRenewAccountID: _AccountIDFromProtobuf(pb.GetConsensusUpdateTopic().GetAutoRenewAccount()),
		adminKey:           adminKey,
		submitKey:          submitKey,
		memo:               pb.GetConsensusUpdateTopic().GetMemo().Value,
		autoRenewPeriod:    &autoRenew,
		expirationTime:     &expirationTime,
	}
}

// SetTopicID sets the topic to be updated.
func (tx *TopicUpdateTransaction) SetTopicID(topicID TopicID) *TopicUpdateTransaction {
	tx._RequireNotFrozen()
	tx.topicID = &topicID
	return tx
}

// GetTopicID returns the topic to be updated.
func (tx *TopicUpdateTransaction) GetTopicID() TopicID {
	if tx.topicID == nil {
		return TopicID{}
	}

	return *tx.topicID
}

// SetAdminKey sets the key required to update/delete the topic. If unset, the key will not be changed.
//
// Setting the AdminKey to an empty KeyList will clear the adminKey.
func (tx *TopicUpdateTransaction) SetAdminKey(publicKey Key) *TopicUpdateTransaction {
	tx._RequireNotFrozen()
	tx.adminKey = publicKey
	return tx
}

// GetAdminKey returns the key required to update/delete the topic.
func (tx *TopicUpdateTransaction) GetAdminKey() (Key, error) {
	return tx.adminKey, nil
}

// SetSubmitKey will set the key allowed to submit messages to the topic.  If unset, the key will not be changed.
//
// Setting the submitKey to an empty KeyList will clear the submitKey.
func (tx *TopicUpdateTransaction) SetSubmitKey(publicKey Key) *TopicUpdateTransaction {
	tx._RequireNotFrozen()
	tx.submitKey = publicKey
	return tx
}

// GetSubmitKey returns the key allowed to submit messages to the topic.
func (tx *TopicUpdateTransaction) GetSubmitKey() (Key, error) {
	return tx.submitKey, nil
}

// SetTopicMemo sets a short publicly visible memo about the topic. No guarantee of uniqueness.
func (tx *TopicUpdateTransaction) SetTopicMemo(memo string) *TopicUpdateTransaction {
	tx._RequireNotFrozen()
	tx.memo = memo
	return tx
}

// GetTopicMemo returns the short publicly visible memo about the topic.
func (tx *TopicUpdateTransaction) GetTopicMemo() string {
	return tx.memo
}

// SetExpirationTime sets the effective  timestamp at (and after) which all  transactions and queries
// will fail. The expirationTime may be no longer than 90 days from the  timestamp of this transaction.
func (tx *TopicUpdateTransaction) SetExpirationTime(expiration time.Time) *TopicUpdateTransaction {
	tx._RequireNotFrozen()
	tx.expirationTime = &expiration
	return tx
}

// GetExpirationTime returns the effective  timestamp at (and after) which all transactions and queries will fail.
func (tx *TopicUpdateTransaction) GetExpirationTime() time.Time {
	if tx.expirationTime != nil {
		return *tx.expirationTime
	}

	return time.Time{}
}

// SetAutoRenewPeriod sets the amount of time to extend the topic's lifetime automatically at expirationTime if the
// autoRenewAccount is configured and has funds. This is limited to a maximum of 90 days (server-sIDe configuration
// which may change).
func (tx *TopicUpdateTransaction) SetAutoRenewPeriod(period time.Duration) *TopicUpdateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewPeriod = &period
	return tx
}

// GetAutoRenewPeriod returns the amount of time to extend the topic's lifetime automatically at expirationTime if the
// autoRenewAccount is configured and has funds.
func (tx *TopicUpdateTransaction) GetAutoRenewPeriod() time.Duration {
	if tx.autoRenewPeriod != nil {
		return *tx.autoRenewPeriod
	}

	return time.Duration(0)
}

// SetAutoRenewAccountID sets the optional account to be used at the topic's expirationTime to extend the life of the
// topic. The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic can be
// extended using all funds on the account (whichever is the smaller duration/amount). If specified as the default value
// (0.0.0), the autoRenewAccount will be removed.
func (tx *TopicUpdateTransaction) SetAutoRenewAccountID(autoRenewAccountID AccountID) *TopicUpdateTransaction {
	tx._RequireNotFrozen()
	tx.autoRenewAccountID = &autoRenewAccountID
	return tx
}

// GetAutoRenewAccountID returns the optional account to be used at the topic's expirationTime to extend the life of the
// topic.
func (tx *TopicUpdateTransaction) GetAutoRenewAccountID() AccountID {
	if tx.autoRenewAccountID == nil {
		return AccountID{}
	}

	return *tx.autoRenewAccountID
}

// ClearTopicMemo explicitly clears any memo on the topic by sending an empty string as the memo
func (tx *TopicUpdateTransaction) ClearTopicMemo() *TopicUpdateTransaction {
	return tx.SetTopicMemo("")
}

// ClearAdminKey explicitly clears any admin key on the topic by sending an empty key list as the key
func (tx *TopicUpdateTransaction) ClearAdminKey() *TopicUpdateTransaction {
	return tx.SetAdminKey(PublicKey{nil, nil})
}

// ClearSubmitKey explicitly clears any submit key on the topic by sending an empty key list as the key
func (tx *TopicUpdateTransaction) ClearSubmitKey() *TopicUpdateTransaction {
	return tx.SetSubmitKey(PublicKey{nil, nil})
}

// ClearAutoRenewAccountID explicitly clears any auto renew account ID on the topic by sending an empty accountID
func (tx *TopicUpdateTransaction) ClearAutoRenewAccountID() *TopicUpdateTransaction {
	tx.autoRenewAccountID = &AccountID{}
	return tx
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TopicUpdateTransaction) Sign(privateKey PrivateKey) *TopicUpdateTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TopicUpdateTransaction) SignWithOperator(client *Client) (*TopicUpdateTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TopicUpdateTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TopicUpdateTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TopicUpdateTransaction) AddSignature(publicKey PublicKey, signature []byte) *TopicUpdateTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TopicUpdateTransaction) SetGrpcDeadline(deadline *time.Duration) *TopicUpdateTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TopicUpdateTransaction) Freeze() (*TopicUpdateTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TopicUpdateTransaction) FreezeWith(client *Client) (*TopicUpdateTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TopicUpdateTransaction.
func (tx *TopicUpdateTransaction) SetMaxTransactionFee(fee Hbar) *TopicUpdateTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TopicUpdateTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TopicUpdateTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TopicUpdateTransaction.
func (tx *TopicUpdateTransaction) SetTransactionMemo(memo string) *TopicUpdateTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TopicUpdateTransaction.
func (tx *TopicUpdateTransaction) SetTransactionValidDuration(duration time.Duration) *TopicUpdateTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TopicUpdateTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TopicUpdateTransaction.
func (tx *TopicUpdateTransaction) SetTransactionID(transactionID TransactionID) *TopicUpdateTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TopicUpdateTransaction.
func (tx *TopicUpdateTransaction) SetNodeAccountIDs(nodeID []AccountID) *TopicUpdateTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TopicUpdateTransaction) SetMaxRetry(count int) *TopicUpdateTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TopicUpdateTransaction) SetMaxBackoff(max time.Duration) *TopicUpdateTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TopicUpdateTransaction) SetMinBackoff(min time.Duration) *TopicUpdateTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TopicUpdateTransaction) SetLogLevel(level LogLevel) *TopicUpdateTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TopicUpdateTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TopicUpdateTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TopicUpdateTransaction) getName() string {
	return "TopicUpdateTransaction"
}

func (tx *TopicUpdateTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if tx.topicID != nil {
		if err := tx.topicID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	if tx.autoRenewAccountID != nil {
		if err := tx.autoRenewAccountID.ValidateChecksum(client); err != nil {
			return err
		}
	}

	return nil
}

func (tx *TopicUpdateTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_ConsensusUpdateTopic{
			ConsensusUpdateTopic: tx.buildProtoBody(),
		},
	}
}

func (tx *TopicUpdateTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_ConsensusUpdateTopic{
			ConsensusUpdateTopic: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TopicUpdateTransaction) buildProtoBody() *services.ConsensusUpdateTopicTransactionBody {
	body := &services.ConsensusUpdateTopicTransactionBody{
		Memo: &wrapperspb.StringValue{Value: tx.memo},
	}

	if tx.topicID != nil {
		body.TopicID = tx.topicID._ToProtobuf()
	}

	if tx.autoRenewAccountID != nil {
		body.AutoRenewAccount = tx.autoRenewAccountID._ToProtobuf()
	}

	if tx.autoRenewPeriod != nil {
		body.AutoRenewPeriod = _DurationToProtobuf(*tx.autoRenewPeriod)
	}

	if tx.expirationTime != nil {
		body.ExpirationTime = _TimeToProtobuf(*tx.expirationTime)
	}

	if tx.adminKey != nil {
		body.AdminKey = tx.adminKey._ToProtoKey()
	}

	if tx.submitKey != nil {
		body.SubmitKey = tx.submitKey._ToProtoKey()
	}

	return body
}

func (tx *TopicUpdateTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetTopic().UpdateTopic,
	}
}
func (tx *TopicUpdateTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return tx.buildScheduled()
}
// Filename: topic_update_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

const oldTopicMemo = "go-sdk::TestConsensusTopicUpdateTransaction_Execute::initial"

func TestIntegrationTopicUpdateTransactionCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(oldTopicMemo).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	require.NoError(t, err)

	info, err := NewTopicInfoQuery().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, info)

	assert.Equal(t, oldTopicMemo, info.TopicMemo)
	assert.Equal(t, uint64(0), info.SequenceNumber)
	assert.Equal(t, env.Client.GetOperatorPublicKey().String(), info.AdminKey.String())

	newTopicMemo := "go-sdk::TestConsensusTopicUpdateTransaction_Execute::updated"

	resp, err = NewTopicUpdateTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTopicMemo(newTopicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	info, err = NewTopicInfoQuery().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, info)

	assert.Equal(t, newTopicMemo, info.TopicMemo)
	assert.Equal(t, uint64(0), info.SequenceNumber)
	assert.Equal(t, env.Client.GetOperatorPublicKey().String(), info.AdminKey.String())

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicUpdateTransactionNoMemo(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(oldTopicMemo).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	require.NoError(t, err)

	info, err := NewTopicInfoQuery().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, info)

	assert.Equal(t, oldTopicMemo, info.TopicMemo)
	assert.Equal(t, uint64(0), info.SequenceNumber)
	assert.Equal(t, env.Client.GetOperatorPublicKey().String(), info.AdminKey.String())

	resp, err = NewTopicUpdateTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTopicUpdateTransactionNoTopicID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTopicCreateTransaction().
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTopicMemo(oldTopicMemo).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	topicID := *receipt.TopicID
	require.NoError(t, err)

	info, err := NewTopicInfoQuery().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)
	assert.NotNil(t, info)

	assert.Equal(t, oldTopicMemo, info.TopicMemo)
	assert.Equal(t, uint64(0), info.SequenceNumber)
	assert.Equal(t, env.Client.GetOperatorPublicKey().String(), info.AdminKey.String())

	_, err = NewTopicUpdateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.Error(t, err)
	if err != nil {
		assert.ErrorContains(t, err, "exceptional precheck status INVALID_TOPIC_ID")
	}

	resp, err = NewTopicDeleteTransaction().
		SetTopicID(topicID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: topic_update_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTopicUpdateTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)
	topicID, err := TopicIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	topicUpdate := NewTopicUpdateTransaction().
		SetTopicID(topicID).
		SetAutoRenewAccountID(accountID)

	err = topicUpdate.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTopicUpdateTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)
	topicID, err := TopicIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	topicUpdate := NewTopicUpdateTransaction().
		SetTopicID(topicID).
		SetAutoRenewAccountID(accountID)

	err = topicUpdate.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTopicUpdateTransactionGet(t *testing.T) {
	t.Parallel()

	accountID := AccountID{Account: 3}

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTopicUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetAutoRenewAccountID(accountID).
		SetTopicID(TopicID{Topic: 7}).
		SetAdminKey(newKey).
		SetSubmitKey(newKey).
		SetTopicMemo("ad").
		SetAutoRenewPeriod(60 * time.Second).
		SetMaxTransactionFee(NewHbar(10)).
		SetTransactionMemo("").
		SetTransactionValidDuration(60 * time.Second).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTopicID()
	transaction.GetAutoRenewAccountID()
	transaction.GetAdminKey()
	transaction.GetSubmitKey()
	transaction.GetTopicMemo()
	transaction.GetAutoRenewPeriod()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTopicUpdateTransactionNothingSet(t *testing.T) {
	t.Parallel()

	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	transaction, err := NewTopicUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.GetTopicID()
	transaction.GetAutoRenewAccountID()
	transaction.GetAdminKey()
	transaction.GetSubmitKey()
	transaction.GetTopicMemo()
	transaction.GetAutoRenewPeriod()
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.GetRegenerateTransactionID()
	transaction.GetMaxTransactionFee()
	transaction.GetRegenerateTransactionID()
}

func TestUnitTopicUpdateTransactionProtoCheck(t *testing.T) {
	t.Parallel()

	topicID := TopicID{Topic: 5}
	accountID := AccountID{Account: 23}
	nodeAccountID := []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)
	newKey2, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	transaction, err := NewTopicUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTopicID(topicID).
		SetAutoRenewAccountID(accountID).
		SetAdminKey(newKey).
		SetSubmitKey(newKey2).
		SetTopicMemo("memo").
		SetAutoRenewPeriod(time.Second * 3).
		SetExpirationTime(time.Unix(34, 12)).
		Freeze()
	require.NoError(t, err)

	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()

	proto := transaction.build().GetConsensusUpdateTopic()
	require.Equal(t, proto.AdminKey.String(), newKey._ToProtoKey().String())
	require.Equal(t, proto.TopicID.String(), topicID._ToProtobuf().String())
	require.Equal(t, proto.AutoRenewAccount.String(), accountID._ToProtobuf().String())
	require.Equal(t, proto.SubmitKey.String(), newKey2._ToProtoKey().String())
	require.Equal(t, proto.Memo.Value, "memo")
	require.Equal(t, proto.AutoRenewPeriod.Seconds, _DurationToProtobuf(time.Second*3).Seconds)
	require.Equal(t, proto.ExpirationTime.String(), _TimeToProtobuf(time.Unix(34, 12)).String())
}

func TestUnitTopicUpdateTransactionCoverage(t *testing.T) {
	t.Parallel()

	checksum := "dmqui"
	grpc := time.Second * 30
	account := AccountID{Account: 3, checksum: &checksum}
	topic := TopicID{Topic: 3, checksum: &checksum}
	nodeAccountID := []AccountID{{Account: 10}}
	transactionID := TransactionIDGenerate(AccountID{Account: 324})

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)

	transaction, err := NewTopicUpdateTransaction().
		SetTransactionID(transactionID).
		SetNodeAccountIDs(nodeAccountID).
		SetTopicID(topic).
		SetAdminKey(newKey).
		SetTopicMemo("ad").
		SetSubmitKey(newKey).
		SetAutoRenewAccountID(account).
		SetAutoRenewPeriod(time.Second * 30).
		SetGrpcDeadline(&grpc).
		SetMaxTransactionFee(NewHbar(3)).
		SetMaxRetry(3).
		SetMaxBackoff(time.Second * 30).
		SetMinBackoff(time.Second * 10).
		SetTransactionMemo("no").
		SetTransactionValidDuration(time.Second * 30).
		SetRegenerateTransactionID(false).
		Freeze()
	require.NoError(t, err)

	err = transaction.validateNetworkOnIDs(client)
	require.NoError(t, err)
	_, err = transaction.Schedule()
	require.NoError(t, err)
	transaction.GetTransactionID()
	transaction.GetNodeAccountIDs()
	transaction.GetMaxRetry()
	transaction.GetMaxTransactionFee()
	transaction.GetMaxBackoff()
	transaction.GetMinBackoff()
	transaction.GetRegenerateTransactionID()
	byt, err := transaction.ToBytes()
	require.NoError(t, err)
	txFromBytes, err := TransactionFromBytes(byt)
	require.NoError(t, err)
	sig, err := newKey.SignTransaction(&transaction.Transaction)
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)
	transaction.GetMaxTransactionFee()
	transaction.GetTransactionMemo()
	transaction.GetRegenerateTransactionID()
	transaction.GetAdminKey()
	transaction.GetSubmitKey()
	transaction.GetTopicMemo()
	transaction.GetAutoRenewAccountID()
	transaction.GetAutoRenewPeriod()
	_, err = transaction.GetSignatures()
	require.NoError(t, err)
	transaction.getName()
	switch b := txFromBytes.(type) {
	case TopicCreateTransaction:
		b.AddSignature(newKey.PublicKey(), sig)
	}
}

func TestUnitTopicUpdateTransactionMock(t *testing.T) {
	t.Parallel()

	newKey, err := PrivateKeyFromStringEd25519("302e020100300506032b657004220420a869f4c6191b9c8c99933e7f6b6611711737e4b1a1a5a4cb5370e719a1f6df98")
	require.NoError(t, err)

	call := func(request *services.Transaction) *services.TransactionResponse {
		require.NotEmpty(t, request.SignedTransactionBytes)
		signedTransaction := services.SignedTransaction{}
		_ = protobuf.Unmarshal(request.SignedTransactionBytes, &signedTransaction)

		require.NotEmpty(t, signedTransaction.BodyBytes)
		transactionBody := services.TransactionBody{}
		_ = protobuf.Unmarshal(signedTransaction.BodyBytes, &transactionBody)

		require.NotNil(t, transactionBody.TransactionID)
		transactionId := transactionBody.TransactionID.String()
		require.NotEqual(t, "", transactionId)

		sigMap := signedTransaction.GetSigMap()
		require.NotNil(t, sigMap)

		return &services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		}
	}
	responses := [][]interface{}{{
		call,
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()

	checksum := "dmqui"
	topic := TopicID{Topic: 3, checksum: &checksum}

	freez, err := NewTopicUpdateTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		SetTopicID(topic).
		SetAdminKey(newKey).
		SetSubmitKey(newKey).
		FreezeWith(client)
	require.NoError(t, err)

	_, err = freez.Sign(newKey).Execute(client)
	require.NoError(t, err)
}
// Filename: transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"bytes"
	"crypto/sha512"
	"fmt"
	"reflect"

	"github.com/pkg/errors"

	"time"

	"github.com/hashgraph/hedera-protobufs-go/sdk"
	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// transaction contains the protobuf of a prepared transaction which can be signed and executed.

type ITransaction interface {
	_ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error)
}

type TransactionInterface interface {
	Executable

	build() *services.TransactionBody
	buildScheduled() (*services.SchedulableTransactionBody, error)
	preFreezeWith(*Client)
	regenerateID(*Client) bool
}

// Transaction is base struct for all transactions that may be built and submitted to Hedera.
type Transaction struct {
	executable

	transactionFee           uint64
	defaultMaxTransactionFee uint64
	memo                     string
	transactionValidDuration *time.Duration
	transactionID            TransactionID

	transactions       *_LockableSlice
	signedTransactions *_LockableSlice

	publicKeys         []PublicKey
	transactionSigners []TransactionSigner

	freezeError error

	regenerateTransactionID bool
}

func _NewTransaction() Transaction {
	duration := 120 * time.Second
	minBackoff := 250 * time.Millisecond
	maxBackoff := 8 * time.Second
	return Transaction{
		transactionValidDuration: &duration,
		transactions:             _NewLockableSlice(),
		signedTransactions:       _NewLockableSlice(),
		freezeError:              nil,
		regenerateTransactionID:  true,
		executable: executable{
			transactionIDs: _NewLockableSlice(),
			nodeAccountIDs: _NewLockableSlice(),
			minBackoff:     &minBackoff,
			maxBackoff:     &maxBackoff,
			maxRetry:       10,
		},
	}
}

func (tx *Transaction) GetSignedTransactionBodyBytes(transactionIndex int) []byte {
	return tx.signedTransactions._Get(transactionIndex).(*services.SignedTransaction).GetBodyBytes()
}

// TransactionFromBytes converts transaction bytes to a related *transaction.
func TransactionFromBytes(data []byte) (interface{}, error) { // nolint
	list := sdk.TransactionList{}
	minBackoff := 250 * time.Millisecond
	maxBackoff := 8 * time.Second
	err := protobuf.Unmarshal(data, &list)
	if err != nil {
		return Transaction{}, errors.Wrap(err, "error deserializing from bytes to transaction List")
	}

	transactions := _NewLockableSlice()

	for _, transaction := range list.TransactionList {
		transactions._Push(transaction)
	}

	tx := Transaction{
		transactions:            transactions,
		signedTransactions:      _NewLockableSlice(),
		publicKeys:              make([]PublicKey, 0),
		transactionSigners:      make([]TransactionSigner, 0),
		freezeError:             nil,
		regenerateTransactionID: true,
		executable: executable{
			transactionIDs: _NewLockableSlice(),
			nodeAccountIDs: _NewLockableSlice(),
			minBackoff:     &minBackoff,
			maxBackoff:     &maxBackoff,
			maxRetry:       10,
		},
	}

	comp, err := _TransactionCompare(&list)
	if err != nil {
		return Transaction{}, err
	}

	if !comp {
		return Transaction{}, errors.New("failed to validate transaction bodies")
	}

	var first *services.TransactionBody = nil
	// We introduce a boolean value to distinguish flow for signed tx vs unsigned transactions
	txIsSigned := true

	for i, transactionFromList := range list.TransactionList {
		var signedTransaction services.SignedTransaction
		var body services.TransactionBody

		// If the transaction is not signed/locked:
		if len(transactionFromList.SignedTransactionBytes) == 0 {
			txIsSigned = false
			if err := protobuf.Unmarshal(transactionFromList.BodyBytes, &body); err != nil { // nolint
				return Transaction{}, errors.Wrap(err, "error deserializing BodyBytes in TransactionFromBytes")
			}
		} else { // If the transaction is signed/locked
			if err := protobuf.Unmarshal(transactionFromList.SignedTransactionBytes, &signedTransaction); err != nil {
				return Transaction{}, errors.Wrap(err, "error deserializing SignedTransactionBytes in TransactionFromBytes")
			}
		}

		if txIsSigned {
			tx.signedTransactions = tx.signedTransactions._Push(&signedTransaction)

			if i == 0 {
				for _, sigPair := range signedTransaction.GetSigMap().GetSigPair() {
					key, err := PublicKeyFromBytes(sigPair.GetPubKeyPrefix())
					if err != nil {
						return Transaction{}, err
					}

					tx.publicKeys = append(tx.publicKeys, key)
					tx.transactionSigners = append(tx.transactionSigners, nil)
				}
			}

			if err := protobuf.Unmarshal(signedTransaction.GetBodyBytes(), &body); err != nil {
				return Transaction{}, errors.Wrap(err, "error deserializing BodyBytes in TransactionFromBytes")
			}
		}

		if first == nil {
			first = &body
		}
		var transactionID TransactionID
		var nodeAccountID AccountID

		if body.GetTransactionValidDuration() != nil {
			duration := _DurationFromProtobuf(body.GetTransactionValidDuration())
			tx.transactionValidDuration = &duration
		}

		if body.GetTransactionID() != nil {
			transactionID = _TransactionIDFromProtobuf(body.GetTransactionID())
		}

		if body.GetNodeAccountID() != nil {
			nodeAccountID = *_AccountIDFromProtobuf(body.GetNodeAccountID())
		}

		// If the transaction was serialised, without setting "NodeId", or "TransactionID", we should leave them empty
		if transactionID.AccountID.Account != 0 {
			tx.transactionIDs = tx.transactionIDs._Push(transactionID)
		}
		if !nodeAccountID._IsZero() {
			tx.nodeAccountIDs = tx.nodeAccountIDs._Push(nodeAccountID)
		}

		if i == 0 {
			tx.memo = body.Memo
			if body.TransactionFee != 0 {
				tx.transactionFee = body.TransactionFee
			}
		}
	}

	if txIsSigned {
		if tx.transactionIDs._Length() > 0 {
			tx.transactionIDs.locked = true
		}

		if tx.nodeAccountIDs._Length() > 0 {
			tx.nodeAccountIDs.locked = true
		}
	}

	if first == nil {
		return nil, errNoTransactionInBytes
	}

	switch first.Data.(type) {
	case *services.TransactionBody_ContractCall:
		return *_ContractExecuteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ContractCreateInstance:
		return *_ContractCreateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ContractUpdateInstance:
		return *_ContractUpdateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ContractDeleteInstance:
		return *_ContractDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_CryptoAddLiveHash:
		return *_LiveHashAddTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_CryptoCreateAccount:
		return *_AccountCreateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_CryptoDelete:
		return *_AccountDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_CryptoDeleteLiveHash:
		return *_LiveHashDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_CryptoTransfer:
		return *_TransferTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_CryptoUpdateAccount:
		return *_AccountUpdateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_CryptoApproveAllowance:
		return *_AccountAllowanceApproveTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_CryptoDeleteAllowance:
		return *_AccountAllowanceDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_FileAppend:
		return *_FileAppendTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_FileCreate:
		return *_FileCreateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_FileDelete:
		return *_FileDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_FileUpdate:
		return *_FileUpdateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_SystemDelete:
		return *_SystemDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_SystemUndelete:
		return *_SystemUndeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_Freeze:
		return *_FreezeTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ConsensusCreateTopic:
		return *_TopicCreateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ConsensusUpdateTopic:
		return *_TopicUpdateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ConsensusDeleteTopic:
		return *_TopicDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ConsensusSubmitMessage:
		return *_TopicMessageSubmitTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenCreation:
		return *_TokenCreateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenFreeze:
		return *_TokenFreezeTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenUnfreeze:
		return *_TokenUnfreezeTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenGrantKyc:
		return *_TokenGrantKycTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenRevokeKyc:
		return *_TokenRevokeKycTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenDeletion:
		return *_TokenDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenUpdate:
		return *_TokenUpdateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenMint:
		return *_TokenMintTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenBurn:
		return *_TokenBurnTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenWipe:
		return *_TokenWipeTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenAssociate:
		return *_TokenAssociateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenDissociate:
		return *_TokenDissociateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ScheduleCreate:
		return *_ScheduleCreateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ScheduleSign:
		return *_ScheduleSignTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_ScheduleDelete:
		return *_ScheduleDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenFeeScheduleUpdate:
		return *_TokenFeeScheduleUpdateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenPause:
		return *_TokenPauseTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenUnpause:
		return *_TokenUnpauseTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_EthereumTransaction:
		return *_EthereumTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_UtilPrng:
		return *_PrngTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenUpdateNfts:
		return *_NewTokenUpdateNftsTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenReject:
		return *_TokenRejectTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_NodeCreate:
		return *_NodeCreateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_NodeUpdate:
		return *_NodeUpdateTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_NodeDelete:
		return *_NodeDeleteTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenAirdrop:
		return *_TokenAirdropTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenClaimAirdrop:
		return *_TokenClaimAirdropTransactionFromProtobuf(tx, first), nil
	case *services.TransactionBody_TokenCancelAirdrop:
		return *_TokenCancelAirdropTransactionFromProtobuf(tx, first), nil
	default:
		return Transaction{}, errFailedToDeserializeBytes
	}
}

func _TransactionCompare(list *sdk.TransactionList) (bool, error) {
	signed := make([]*services.SignedTransaction, 0)
	var err error
	for _, s := range list.TransactionList {
		temp := services.SignedTransaction{}
		err = protobuf.Unmarshal(s.SignedTransactionBytes, &temp)
		if err != nil {
			return false, err
		}
		signed = append(signed, &temp)
	}
	body := make([]*services.TransactionBody, 0)
	for _, s := range signed {
		temp := services.TransactionBody{}
		err = protobuf.Unmarshal(s.BodyBytes, &temp)
		if err != nil {
			return false, err
		}
		body = append(body, &temp)
	}

	for i := 1; i < len(body); i++ {
		// #nosec G602
		if reflect.TypeOf(body[0].Data) != reflect.TypeOf(body[i].Data) {
			return false, nil
		}
	}

	return true, nil
}

// GetSignatures Gets all of the signatures stored in the transaction
func (tx *Transaction) GetSignatures() (map[AccountID]map[*PublicKey][]byte, error) {
	returnMap := make(map[AccountID]map[*PublicKey][]byte, tx.nodeAccountIDs._Length())

	if tx.signedTransactions._Length() == 0 {
		return returnMap, nil
	}

	for i, nodeID := range tx.nodeAccountIDs.slice {
		var sigMap *services.SignatureMap
		var tempID AccountID
		switch k := tx.signedTransactions._Get(i).(type) { //nolint
		case *services.SignedTransaction:
			sigMap = k.SigMap
		}

		switch k := nodeID.(type) { //nolint
		case AccountID:
			tempID = k
		}
		inner := make(map[*PublicKey][]byte, len(sigMap.SigPair))

		for _, sigPair := range sigMap.SigPair {
			key, err := PublicKeyFromBytes(sigPair.PubKeyPrefix)
			if err != nil {
				return make(map[AccountID]map[*PublicKey][]byte), err
			}
			switch sigPair.Signature.(type) {
			case *services.SignaturePair_Contract:
				inner[&key] = sigPair.GetContract()
			case *services.SignaturePair_Ed25519:
				inner[&key] = sigPair.GetEd25519()
			case *services.SignaturePair_RSA_3072:
				inner[&key] = sigPair.GetRSA_3072()
			case *services.SignaturePair_ECDSA_384:
				inner[&key] = sigPair.GetECDSA_384()
			}
		}

		returnMap[tempID] = inner
	}
	tx.transactionIDs.locked = true

	return returnMap, nil
}

func (tx *Transaction) GetTransactionHash() ([]byte, error) {
	current, err := tx._BuildTransaction(0)
	if err != nil {
		return nil, err
	}
	hash := sha512.New384()
	_, err = hash.Write(current.GetSignedTransactionBytes())
	if err != nil {
		return nil, err
	}

	return hash.Sum(nil), nil
}

func (tx *Transaction) GetTransactionHashPerNode() (map[AccountID][]byte, error) {
	transactionHash := make(map[AccountID][]byte)
	if !tx.IsFrozen() {
		return transactionHash, errTransactionIsNotFrozen
	}

	allTx, err := tx._BuildAllTransactions()
	if err != nil {
		return transactionHash, err
	}
	tx.transactionIDs.locked = true

	for i, node := range tx.nodeAccountIDs.slice {
		switch n := node.(type) { //nolint
		case AccountID:
			hash := sha512.New384()
			_, err := hash.Write(allTx[i].GetSignedTransactionBytes())
			if err != nil {
				return transactionHash, err
			}

			finalHash := hash.Sum(nil)

			transactionHash[n] = finalHash
		}
	}

	return transactionHash, nil
}

// Sets the maxTransaction fee based on priority:
// 1. Explicitly set for this Transaction
// 2. Client has a default value set for all transactions
// 3. The default for this type of Transaction, which is set during creation
func (tx *Transaction) _InitFee(client *Client) {
	if tx.transactionFee == 0 {
		if client != nil && client.GetDefaultMaxTransactionFee().AsTinybar() != 0 {
			tx.SetMaxTransactionFee(client.GetDefaultMaxTransactionFee())
		} else {
			tx.SetMaxTransactionFee(tx.GetDefaultMaxTransactionFee())
		}
	}
}

func (tx *Transaction) _InitTransactionID(client *Client) error {
	if tx.transactionIDs._Length() == 0 {
		if client != nil {
			if client.operator != nil {
				tx.transactionIDs = _NewLockableSlice()
				tx.transactionIDs = tx.transactionIDs._Push(TransactionIDGenerate(client.operator.accountID))
			} else {
				return errNoClientOrTransactionID
			}
		} else {
			return errNoClientOrTransactionID
		}
	}

	tx.transactionID = tx.transactionIDs._GetCurrent().(TransactionID)
	return nil
}

func (tx *Transaction) IsFrozen() bool {
	return tx.signedTransactions._Length() > 0
}

func (tx *Transaction) _RequireFrozen() {
	if !tx.IsFrozen() {
		tx.freezeError = errTransactionIsNotFrozen
	}
}

func (tx *Transaction) _RequireNotFrozen() {
	if tx.IsFrozen() {
		tx.freezeError = errTransactionIsFrozen
	}
}

func (tx *Transaction) _RequireOneNodeAccountID() {
	if tx.nodeAccountIDs._Length() != 1 {
		panic("transaction has more than one _Node ID set")
	}
}

func _TransactionFreezeWith(
	transaction *Transaction,
	client *Client,
	body *services.TransactionBody,
) error {
	if transaction.nodeAccountIDs._IsEmpty() {
		if client != nil {
			for _, nodeAccountID := range client.network._GetNodeAccountIDsForExecute() {
				transaction.nodeAccountIDs._Push(nodeAccountID)
			}
		} else {
			return errNoClientOrTransactionIDOrNodeId
		}
	}

	if client != nil {
		if client.defaultRegenerateTransactionIDs != transaction.regenerateTransactionID {
			transaction.regenerateTransactionID = client.defaultRegenerateTransactionIDs
		}
	}

	for _, nodeAccountID := range transaction.nodeAccountIDs.slice {
		body.NodeAccountID = nodeAccountID.(AccountID)._ToProtobuf()
		bodyBytes, err := protobuf.Marshal(body)

		if err != nil {
			// This should be unreachable
			// From the documentation this appears to only be possible if there are missing proto types
			panic(err)
		}
		transaction.signedTransactions = transaction.signedTransactions._Push(&services.SignedTransaction{
			BodyBytes: bodyBytes,
			SigMap: &services.SignatureMap{
				SigPair: make([]*services.SignaturePair, 0),
			},
		})
	}

	return nil
}

func (tx *Transaction) _SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) {
	tx.transactions = _NewLockableSlice()
	tx.publicKeys = append(tx.publicKeys, publicKey)
	tx.transactionSigners = append(tx.transactionSigners, signer)
}

func (tx *Transaction) _KeyAlreadySigned(
	pk PublicKey,
) bool {
	for _, key := range tx.publicKeys {
		if key.String() == pk.String() {
			return true
		}
	}

	return false
}

// String returns a string representation of the transaction
func (tx *Transaction) String() string {
	switch sig := tx.signedTransactions._Get(0).(type) { //nolint
	case *services.SignedTransaction:
		return fmt.Sprintf("%+v", sig)
	}

	return ""
}

// ToBytes Builds then converts the current transaction to []byte
// Requires transaction to be frozen
func (tx *Transaction) ToBytes() ([]byte, error) {
	return tx.toBytes(tx)
}

func (tx *Transaction) toBytes(e TransactionInterface) ([]byte, error) {
	var pbTransactionList []byte
	var allTx []*services.Transaction
	var err error
	// If transaction is frozen, build all transactions and "signedTransactions"
	if tx.IsFrozen() {
		allTx, err = tx._BuildAllTransactions()
		tx.transactionIDs.locked = true
	} else { // Build only onlt "BodyBytes" for each transaction in the list
		allTx, err = tx.buildAllUnsignedTransactions(e)
	}
	// If error has occurred, when building transactions
	if err != nil {
		return make([]byte, 0), err
	}

	pbTransactionList, err = protobuf.Marshal(&sdk.TransactionList{
		TransactionList: allTx,
	})
	if err != nil {
		return make([]byte, 0), errors.Wrap(err, "error serializing tx list")
	}
	return pbTransactionList, nil
}

func (tx *Transaction) buildAllUnsignedTransactions(e TransactionInterface) ([]*services.Transaction, error) {
	// All unsigned transactions would always be exactly 1
	allTx := make([]*services.Transaction, 0)
	if tx.nodeAccountIDs._IsEmpty() {
		t, err := tx.buildUnsignedTransaction(e, 0)
		if err != nil {
			return allTx, err
		}
		allTx = append(allTx, t)
	} else { // If we have set some node account ids, we have to make one transaction copy per node account
		for range tx.nodeAccountIDs.slice {
			t, err := tx.buildUnsignedTransaction(e, tx.nodeAccountIDs.index)
			tx.nodeAccountIDs._Advance()
			if err != nil {
				return allTx, err
			}
			allTx = append(allTx, t)
		}
	}
	return allTx, nil
}

func (tx *Transaction) buildUnsignedTransaction(e TransactionInterface, index int) (*services.Transaction, error) {
	body := e.build()
	if body.NodeAccountID == nil && !tx.nodeAccountIDs._IsEmpty() {
		body.NodeAccountID = tx.nodeAccountIDs._Get(index).(AccountID)._ToProtobuf()
	}

	bodyBytes, err := protobuf.Marshal(body)
	if err != nil {
		return &services.Transaction{}, errors.Wrap(err, "failed to update tx ID")
	}

	return &services.Transaction{BodyBytes: bodyBytes}, nil
}

func (tx *Transaction) _SignTransaction(index int) {
	initialTx := tx.signedTransactions._Get(index).(*services.SignedTransaction)
	bodyBytes := initialTx.GetBodyBytes()
	if len(initialTx.SigMap.SigPair) != 0 {
		for i, key := range tx.publicKeys {
			if tx.transactionSigners[i] != nil {
				if key.ed25519PublicKey != nil {
					if bytes.Equal(initialTx.SigMap.SigPair[0].PubKeyPrefix, key.ed25519PublicKey.keyData) {
						if !tx.regenerateTransactionID {
							return
						}
						switch t := initialTx.SigMap.SigPair[0].Signature.(type) { //nolint
						case *services.SignaturePair_Ed25519:
							if bytes.Equal(t.Ed25519, tx.transactionSigners[0](bodyBytes)) && len(t.Ed25519) > 0 {
								return
							}
						}
					}
				}
				if key.ecdsaPublicKey != nil {
					if bytes.Equal(initialTx.SigMap.SigPair[0].PubKeyPrefix, key.ecdsaPublicKey._BytesRaw()) {
						if !tx.regenerateTransactionID {
							return
						}
						switch t := initialTx.SigMap.SigPair[0].Signature.(type) { //nolint
						case *services.SignaturePair_ECDSASecp256K1:
							if bytes.Equal(t.ECDSASecp256K1, tx.transactionSigners[0](bodyBytes)) && len(t.ECDSASecp256K1) > 0 {
								return
							}
						}
					}
				}
			}
		}
	}

	if tx.regenerateTransactionID && !tx.transactionIDs.locked {
		modifiedTx := tx.signedTransactions._Get(index).(*services.SignedTransaction)
		modifiedTx.SigMap.SigPair = make([]*services.SignaturePair, 0)
		tx.signedTransactions._Set(index, modifiedTx)
	}

	for i := 0; i < len(tx.publicKeys); i++ {
		publicKey := tx.publicKeys[i]
		signer := tx.transactionSigners[i]

		if signer == nil {
			continue
		}

		modifiedTx := tx.signedTransactions._Get(index).(*services.SignedTransaction)
		modifiedTx.SigMap.SigPair = append(modifiedTx.SigMap.SigPair, publicKey._ToSignaturePairProtobuf(signer(bodyBytes)))
		tx.signedTransactions._Set(index, modifiedTx)
	}
}

func (tx *Transaction) _BuildAllTransactions() ([]*services.Transaction, error) {
	allTx := make([]*services.Transaction, 0)
	for i := 0; i < tx.signedTransactions._Length(); i++ {
		curr, err := tx._BuildTransaction(i)
		tx.transactionIDs._Advance()
		if err != nil {
			return []*services.Transaction{}, err
		}
		allTx = append(allTx, curr)
	}

	return allTx, nil
}

func (tx *Transaction) _BuildTransaction(index int) (*services.Transaction, error) {
	signedTx := tx.signedTransactions._Get(index).(*services.SignedTransaction)

	txID := tx.transactionIDs._GetCurrent().(TransactionID)
	originalBody := services.TransactionBody{}
	_ = protobuf.Unmarshal(signedTx.BodyBytes, &originalBody)

	if originalBody.NodeAccountID == nil {
		originalBody.NodeAccountID = tx.nodeAccountIDs._GetCurrent().(AccountID)._ToProtobuf()
	}

	if originalBody.TransactionID.String() != txID._ToProtobuf().String() {
		originalBody.TransactionID = txID._ToProtobuf()
	}

	originalBody.Memo = tx.memo
	if tx.transactionFee != 0 {
		originalBody.TransactionFee = tx.transactionFee
	} else {
		originalBody.TransactionFee = tx.defaultMaxTransactionFee
	}

	updatedBody, err := protobuf.Marshal(&originalBody)
	if err != nil {
		return &services.Transaction{}, errors.Wrap(err, "failed to update tx ID")
	}

	// Bellow are checks whether we need to sign the transaction or we already have the same signed
	if bytes.Equal(signedTx.BodyBytes, updatedBody) {
		sigPairLen := len(signedTx.SigMap.GetSigPair())
		// For cases where we need more than 1 signature
		if sigPairLen > 0 && sigPairLen == len(tx.publicKeys) {
			data, err := protobuf.Marshal(signedTx)
			if err != nil {
				return &services.Transaction{}, errors.Wrap(err, "failed to serialize transactions for building")
			}
			transaction := &services.Transaction{
				SignedTransactionBytes: data,
			}

			return transaction, nil
		}
	}

	signedTx.BodyBytes = updatedBody
	tx.signedTransactions._Set(index, signedTx)
	tx._SignTransaction(index)

	signed := tx.signedTransactions._Get(index).(*services.SignedTransaction)
	data, err := protobuf.Marshal(signed)
	if err != nil {
		return &services.Transaction{}, errors.Wrap(err, "failed to serialize transactions for building")
	}

	transaction := &services.Transaction{
		SignedTransactionBytes: data,
	}

	return transaction, nil
}

//
// Shared
//

// GetMaxTransactionFee returns the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *Transaction) GetMaxTransactionFee() Hbar {
	return HbarFromTinybar(int64(tx.transactionFee))
}

// SetMaxTransactionFee sets the maximum transaction fee the operator (paying account) is willing to pay.
func (tx *Transaction) SetMaxTransactionFee(fee Hbar) *Transaction {
	tx.transactionFee = uint64(fee.AsTinybar())
	return tx
}
func (tx *Transaction) GetDefaultMaxTransactionFee() Hbar {
	return HbarFromTinybar(int64(tx.defaultMaxTransactionFee))
}

// SetMaxTransactionFee sets the max Transaction fee for this Transaction.
func (tx *Transaction) _SetDefaultMaxTransactionFee(fee Hbar) {
	tx.defaultMaxTransactionFee = uint64(fee.AsTinybar())
}

// GetRegenerateTransactionID returns true if transaction ID regeneration is enabled
func (tx *Transaction) GetRegenerateTransactionID() bool {
	return tx.regenerateTransactionID
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when \`TRANSACTION_EXPIRED\` is received
func (tx *Transaction) SetRegenerateTransactionID(regenerateTransactionID bool) *Transaction {
	tx.regenerateTransactionID = regenerateTransactionID
	return tx
}

// GetTransactionMemo returns the memo for this	transaction.
func (tx *Transaction) GetTransactionMemo() string {
	return tx.memo
}

// SetTransactionMemo sets the memo for this transaction.
func (tx *Transaction) SetTransactionMemo(memo string) *Transaction {
	tx.memo = memo
	return tx
}

// GetTransactionValidDuration returns the duration that this transaction is valid for.
func (tx *Transaction) GetTransactionValidDuration() time.Duration {
	if tx.transactionValidDuration != nil {
		return *tx.transactionValidDuration
	}

	return 0
}

// SetTransactionValidDuration sets the valid duration for this transaction.
func (tx *Transaction) SetTransactionValidDuration(duration time.Duration) *Transaction {
	tx.transactionValidDuration = &duration
	return tx
}

// GetTransactionID gets the TransactionID for this	transaction.
func (tx *Transaction) GetTransactionID() TransactionID {
	if tx.transactionIDs._Length() > 0 {
		t := tx.transactionIDs._GetCurrent().(TransactionID)
		return t
	}

	return TransactionID{}
}

// SetTransactionID sets the TransactionID for this transaction.
func (tx *Transaction) SetTransactionID(transactionID TransactionID) *Transaction {
	tx.transactionIDs._Clear()._Push(transactionID)._SetLocked(true)
	return tx
}

// SetNodeAccountIDs sets the node AccountID for this transaction.
func (tx *Transaction) SetNodeAccountIDs(nodeAccountIDs []AccountID) *Transaction {
	for _, nodeAccountID := range nodeAccountIDs {
		tx.nodeAccountIDs._Push(nodeAccountID)
	}
	tx.nodeAccountIDs._SetLocked(true)
	return tx
}

// ------------ Transaction methdos ---------------
func (tx *Transaction) Sign(privateKey PrivateKey) TransactionInterface {
	return tx.SignWith(privateKey.PublicKey(), privateKey.Sign)
}
func (tx *Transaction) signWithOperator(client *Client, e TransactionInterface) (TransactionInterface, error) { // nolint
	// If the transaction is not signed by the _Operator, we need
	// to sign the transaction with the _Operator
	if client == nil {
		return nil, errNoClientProvided
	} else if client.operator == nil {
		return nil, errClientOperatorSigning
	}

	if !tx.IsFrozen() {
		_, err := tx.freezeWith(client, e)
		if err != nil {
			return tx, err
		}
	}
	return tx.SignWith(client.operator.publicKey, client.operator.signer), nil
}
func (tx *Transaction) SignWith(publicKey PublicKey, signer TransactionSigner) TransactionInterface {
	// We need to make sure the request is frozen
	tx._RequireFrozen()

	if !tx._KeyAlreadySigned(publicKey) {
		tx._SignWith(publicKey, signer)
	}

	return tx
}
func (tx *Transaction) AddSignature(publicKey PublicKey, signature []byte) TransactionInterface {
	tx._RequireOneNodeAccountID()

	if tx._KeyAlreadySigned(publicKey) {
		return tx
	}

	if tx.signedTransactions._Length() == 0 {
		return tx
	}

	tx.transactions = _NewLockableSlice()
	tx.publicKeys = append(tx.publicKeys, publicKey)
	tx.transactionSigners = append(tx.transactionSigners, nil)
	tx.transactionIDs.locked = true

	for index := 0; index < tx.signedTransactions._Length(); index++ {
		var temp *services.SignedTransaction
		switch t := tx.signedTransactions._Get(index).(type) { //nolint
		case *services.SignedTransaction:
			temp = t
		}
		temp.SigMap.SigPair = append(
			temp.SigMap.SigPair,
			publicKey._ToSignaturePairProtobuf(signature),
		)
		tx.signedTransactions._Set(index, temp)
	}

	return tx
}

// Building empty object as "default" implementation. All inhertents must implement their own implementation.
func (tx *Transaction) build() *services.TransactionBody {
	return &services.TransactionBody{}
}

// Building empty object as "default" implementation. All inhertents must implement their own implementation.
func (tx *Transaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{}, nil
}

// -------------------------------------

func TransactionSign(transaction interface{}, privateKey PrivateKey) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.Sign(privateKey), nil
	case AccountDeleteTransaction:
		return i.Sign(privateKey), nil
	case AccountUpdateTransaction:
		return i.Sign(privateKey), nil
	case AccountAllowanceApproveTransaction:
		return i.Sign(privateKey), nil
	case AccountAllowanceDeleteTransaction:
		return i.Sign(privateKey), nil
	case ContractCreateTransaction:
		return i.Sign(privateKey), nil
	case ContractDeleteTransaction:
		return i.Sign(privateKey), nil
	case ContractExecuteTransaction:
		return i.Sign(privateKey), nil
	case ContractUpdateTransaction:
		return i.Sign(privateKey), nil
	case FileAppendTransaction:
		return i.Sign(privateKey), nil
	case FileCreateTransaction:
		return i.Sign(privateKey), nil
	case FileDeleteTransaction:
		return i.Sign(privateKey), nil
	case FileUpdateTransaction:
		return i.Sign(privateKey), nil
	case LiveHashAddTransaction:
		return i.Sign(privateKey), nil
	case LiveHashDeleteTransaction:
		return i.Sign(privateKey), nil
	case ScheduleCreateTransaction:
		return i.Sign(privateKey), nil
	case ScheduleDeleteTransaction:
		return i.Sign(privateKey), nil
	case ScheduleSignTransaction:
		return i.Sign(privateKey), nil
	case SystemDeleteTransaction:
		return i.Sign(privateKey), nil
	case SystemUndeleteTransaction:
		return i.Sign(privateKey), nil
	case TokenAssociateTransaction:
		return i.Sign(privateKey), nil
	case TokenBurnTransaction:
		return i.Sign(privateKey), nil
	case TokenCreateTransaction:
		return i.Sign(privateKey), nil
	case TokenDeleteTransaction:
		return i.Sign(privateKey), nil
	case TokenDissociateTransaction:
		return i.Sign(privateKey), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.Sign(privateKey), nil
	case TokenFreezeTransaction:
		return i.Sign(privateKey), nil
	case TokenGrantKycTransaction:
		return i.Sign(privateKey), nil
	case TokenMintTransaction:
		return i.Sign(privateKey), nil
	case TokenRevokeKycTransaction:
		return i.Sign(privateKey), nil
	case TokenUnfreezeTransaction:
		return i.Sign(privateKey), nil
	case TokenUpdateTransaction:
		return i.Sign(privateKey), nil
	case TokenWipeTransaction:
		return i.Sign(privateKey), nil
	case TopicCreateTransaction:
		return i.Sign(privateKey), nil
	case TopicDeleteTransaction:
		return i.Sign(privateKey), nil
	case TopicMessageSubmitTransaction:
		return i.Sign(privateKey), nil
	case TopicUpdateTransaction:
		return i.Sign(privateKey), nil
	case TransferTransaction:
		return i.Sign(privateKey), nil
	case *AccountCreateTransaction:
		return i.Sign(privateKey), nil
	case *AccountDeleteTransaction:
		return i.Sign(privateKey), nil
	case *AccountUpdateTransaction:
		return i.Sign(privateKey), nil
	case *AccountAllowanceApproveTransaction:
		return i.Sign(privateKey), nil
	case *AccountAllowanceDeleteTransaction:
		return i.Sign(privateKey), nil
	case *ContractCreateTransaction:
		return i.Sign(privateKey), nil
	case *ContractDeleteTransaction:
		return i.Sign(privateKey), nil
	case *ContractExecuteTransaction:
		return i.Sign(privateKey), nil
	case *ContractUpdateTransaction:
		return i.Sign(privateKey), nil
	case *FileAppendTransaction:
		return i.Sign(privateKey), nil
	case *FileCreateTransaction:
		return i.Sign(privateKey), nil
	case *FileDeleteTransaction:
		return i.Sign(privateKey), nil
	case *FileUpdateTransaction:
		return i.Sign(privateKey), nil
	case *LiveHashAddTransaction:
		return i.Sign(privateKey), nil
	case *LiveHashDeleteTransaction:
		return i.Sign(privateKey), nil
	case *ScheduleCreateTransaction:
		return i.Sign(privateKey), nil
	case *ScheduleDeleteTransaction:
		return i.Sign(privateKey), nil
	case *ScheduleSignTransaction:
		return i.Sign(privateKey), nil
	case *SystemDeleteTransaction:
		return i.Sign(privateKey), nil
	case *SystemUndeleteTransaction:
		return i.Sign(privateKey), nil
	case *TokenAssociateTransaction:
		return i.Sign(privateKey), nil
	case *TokenBurnTransaction:
		return i.Sign(privateKey), nil
	case *TokenCreateTransaction:
		return i.Sign(privateKey), nil
	case *TokenDeleteTransaction:
		return i.Sign(privateKey), nil
	case *TokenDissociateTransaction:
		return i.Sign(privateKey), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.Sign(privateKey), nil
	case *TokenFreezeTransaction:
		return i.Sign(privateKey), nil
	case *TokenGrantKycTransaction:
		return i.Sign(privateKey), nil
	case *TokenMintTransaction:
		return i.Sign(privateKey), nil
	case *TokenRevokeKycTransaction:
		return i.Sign(privateKey), nil
	case *TokenUnfreezeTransaction:
		return i.Sign(privateKey), nil
	case *TokenUpdateTransaction:
		return i.Sign(privateKey), nil
	case *TokenWipeTransaction:
		return i.Sign(privateKey), nil
	case *TopicCreateTransaction:
		return i.Sign(privateKey), nil
	case *TopicDeleteTransaction:
		return i.Sign(privateKey), nil
	case *TopicMessageSubmitTransaction:
		return i.Sign(privateKey), nil
	case *TopicUpdateTransaction:
		return i.Sign(privateKey), nil
	case *TransferTransaction:
		return i.Sign(privateKey), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionSignWth(transaction interface{}, publicKKey PublicKey, signer TransactionSigner) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case AccountDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case AccountUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case AccountAllowanceApproveTransaction:
		return i.SignWith(publicKKey, signer), nil
	case AccountAllowanceDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case ContractCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case ContractDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case ContractExecuteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case ContractUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case FileAppendTransaction:
		return i.SignWith(publicKKey, signer), nil
	case FileCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case FileDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case FileUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case LiveHashAddTransaction:
		return i.SignWith(publicKKey, signer), nil
	case LiveHashDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case ScheduleCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case ScheduleDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case ScheduleSignTransaction:
		return i.SignWith(publicKKey, signer), nil
	case SystemDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case SystemUndeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenAssociateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenBurnTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenDissociateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenFreezeTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenGrantKycTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenMintTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenRevokeKycTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenUnfreezeTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TokenWipeTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TopicCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TopicDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TopicMessageSubmitTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TopicUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case TransferTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *AccountCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *AccountDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *AccountUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *AccountAllowanceApproveTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *AccountAllowanceDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *ContractCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *ContractDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *ContractExecuteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *ContractUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *FileAppendTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *FileCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *FileDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *FileUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *LiveHashAddTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *LiveHashDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *ScheduleCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *ScheduleDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *ScheduleSignTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *SystemDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *SystemUndeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenAssociateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenBurnTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenDissociateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenFreezeTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenGrantKycTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenMintTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenRevokeKycTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenUnfreezeTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TokenWipeTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TopicCreateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TopicDeleteTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TopicMessageSubmitTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TopicUpdateTransaction:
		return i.SignWith(publicKKey, signer), nil
	case *TransferTransaction:
		return i.SignWith(publicKKey, signer), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionSignWithOperator(transaction interface{}, client *Client) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.SignWithOperator(client)
	case AccountDeleteTransaction:
		return i.SignWithOperator(client)
	case AccountUpdateTransaction:
		return i.SignWithOperator(client)
	case AccountAllowanceApproveTransaction:
		return i.SignWithOperator(client)
	case AccountAllowanceDeleteTransaction:
		return i.SignWithOperator(client)
	case ContractCreateTransaction:
		return i.SignWithOperator(client)
	case ContractDeleteTransaction:
		return i.SignWithOperator(client)
	case ContractExecuteTransaction:
		return i.SignWithOperator(client)
	case ContractUpdateTransaction:
		return i.SignWithOperator(client)
	case FileAppendTransaction:
		return i.SignWithOperator(client)
	case FileCreateTransaction:
		return i.SignWithOperator(client)
	case FileDeleteTransaction:
		return i.SignWithOperator(client)
	case FileUpdateTransaction:
		return i.SignWithOperator(client)
	case LiveHashAddTransaction:
		return i.SignWithOperator(client)
	case LiveHashDeleteTransaction:
		return i.SignWithOperator(client)
	case ScheduleCreateTransaction:
		return i.SignWithOperator(client)
	case ScheduleDeleteTransaction:
		return i.SignWithOperator(client)
	case ScheduleSignTransaction:
		return i.SignWithOperator(client)
	case SystemDeleteTransaction:
		return i.SignWithOperator(client)
	case SystemUndeleteTransaction:
		return i.SignWithOperator(client)
	case TokenAssociateTransaction:
		return i.SignWithOperator(client)
	case TokenBurnTransaction:
		return i.SignWithOperator(client)
	case TokenCreateTransaction:
		return i.SignWithOperator(client)
	case TokenDeleteTransaction:
		return i.SignWithOperator(client)
	case TokenDissociateTransaction:
		return i.SignWithOperator(client)
	case TokenFeeScheduleUpdateTransaction:
		return i.SignWithOperator(client)
	case TokenFreezeTransaction:
		return i.SignWithOperator(client)
	case TokenGrantKycTransaction:
		return i.SignWithOperator(client)
	case TokenMintTransaction:
		return i.SignWithOperator(client)
	case TokenRevokeKycTransaction:
		return i.SignWithOperator(client)
	case TokenUnfreezeTransaction:
		return i.SignWithOperator(client)
	case TokenUpdateTransaction:
		return i.SignWithOperator(client)
	case TokenWipeTransaction:
		return i.SignWithOperator(client)
	case TopicCreateTransaction:
		return i.SignWithOperator(client)
	case TopicDeleteTransaction:
		return i.SignWithOperator(client)
	case TopicMessageSubmitTransaction:
		return i.SignWithOperator(client)
	case TopicUpdateTransaction:
		return i.SignWithOperator(client)
	case TransferTransaction:
		return i.SignWithOperator(client)
	case *AccountCreateTransaction:
		return i.SignWithOperator(client)
	case *AccountDeleteTransaction:
		return i.SignWithOperator(client)
	case *AccountUpdateTransaction:
		return i.SignWithOperator(client)
	case *AccountAllowanceApproveTransaction:
		return i.SignWithOperator(client)
	case *AccountAllowanceDeleteTransaction:
		return i.SignWithOperator(client)
	case *ContractCreateTransaction:
		return i.SignWithOperator(client)
	case *ContractDeleteTransaction:
		return i.SignWithOperator(client)
	case *ContractExecuteTransaction:
		return i.SignWithOperator(client)
	case *ContractUpdateTransaction:
		return i.SignWithOperator(client)
	case *FileAppendTransaction:
		return i.SignWithOperator(client)
	case *FileCreateTransaction:
		return i.SignWithOperator(client)
	case *FileDeleteTransaction:
		return i.SignWithOperator(client)
	case *FileUpdateTransaction:
		return i.SignWithOperator(client)
	case *LiveHashAddTransaction:
		return i.SignWithOperator(client)
	case *LiveHashDeleteTransaction:
		return i.SignWithOperator(client)
	case *ScheduleCreateTransaction:
		return i.SignWithOperator(client)
	case *ScheduleDeleteTransaction:
		return i.SignWithOperator(client)
	case *ScheduleSignTransaction:
		return i.SignWithOperator(client)
	case *SystemDeleteTransaction:
		return i.SignWithOperator(client)
	case *SystemUndeleteTransaction:
		return i.SignWithOperator(client)
	case *TokenAssociateTransaction:
		return i.SignWithOperator(client)
	case *TokenBurnTransaction:
		return i.SignWithOperator(client)
	case *TokenCreateTransaction:
		return i.SignWithOperator(client)
	case *TokenDeleteTransaction:
		return i.SignWithOperator(client)
	case *TokenDissociateTransaction:
		return i.SignWithOperator(client)
	case *TokenFeeScheduleUpdateTransaction:
		return i.SignWithOperator(client)
	case *TokenFreezeTransaction:
		return i.SignWithOperator(client)
	case *TokenGrantKycTransaction:
		return i.SignWithOperator(client)
	case *TokenMintTransaction:
		return i.SignWithOperator(client)
	case *TokenRevokeKycTransaction:
		return i.SignWithOperator(client)
	case *TokenUnfreezeTransaction:
		return i.SignWithOperator(client)
	case *TokenUpdateTransaction:
		return i.SignWithOperator(client)
	case *TokenWipeTransaction:
		return i.SignWithOperator(client)
	case *TopicCreateTransaction:
		return i.SignWithOperator(client)
	case *TopicDeleteTransaction:
		return i.SignWithOperator(client)
	case *TopicMessageSubmitTransaction:
		return i.SignWithOperator(client)
	case *TopicUpdateTransaction:
		return i.SignWithOperator(client)
	case *TransferTransaction:
		return i.SignWithOperator(client)
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionAddSignature(transaction interface{}, publicKey PublicKey, signature []byte) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case AccountDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case AccountUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case AccountAllowanceApproveTransaction:
		return i.AddSignature(publicKey, signature), nil
	case AccountAllowanceDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case ContractCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case ContractDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case ContractExecuteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case ContractUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case FileAppendTransaction:
		return i.AddSignature(publicKey, signature), nil
	case FileCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case FileDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case FileUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case LiveHashAddTransaction:
		return i.AddSignature(publicKey, signature), nil
	case LiveHashDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case SystemDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case SystemUndeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenAssociateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenBurnTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenDissociateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenFreezeTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenGrantKycTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenMintTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenRevokeKycTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenUnfreezeTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TokenWipeTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TopicCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TopicDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TopicMessageSubmitTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TopicUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case TransferTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *AccountCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *AccountDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *AccountUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *AccountAllowanceApproveTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *AccountAllowanceDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *ContractCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *ContractDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *ContractExecuteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *ContractUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *FileAppendTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *FileCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *FileDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *FileUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *LiveHashAddTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *LiveHashDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *SystemDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *SystemUndeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenAssociateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenBurnTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenDissociateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenFreezeTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenGrantKycTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenMintTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenRevokeKycTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenUnfreezeTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TokenWipeTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TopicCreateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TopicDeleteTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TopicMessageSubmitTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TopicUpdateTransaction:
		return i.AddSignature(publicKey, signature), nil
	case *TransferTransaction:
		return i.AddSignature(publicKey, signature), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetSignatures(transaction interface{}) (map[AccountID]map[*PublicKey][]byte, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetSignatures()
	case AccountDeleteTransaction:
		return i.GetSignatures()
	case AccountUpdateTransaction:
		return i.GetSignatures()
	case AccountAllowanceApproveTransaction:
		return i.GetSignatures()
	case AccountAllowanceDeleteTransaction:
		return i.GetSignatures()
	case ContractCreateTransaction:
		return i.GetSignatures()
	case ContractDeleteTransaction:
		return i.GetSignatures()
	case ContractExecuteTransaction:
		return i.GetSignatures()
	case ContractUpdateTransaction:
		return i.GetSignatures()
	case FileAppendTransaction:
		return i.GetSignatures()
	case FileCreateTransaction:
		return i.GetSignatures()
	case FileDeleteTransaction:
		return i.GetSignatures()
	case FileUpdateTransaction:
		return i.GetSignatures()
	case LiveHashAddTransaction:
		return i.GetSignatures()
	case LiveHashDeleteTransaction:
		return i.GetSignatures()
	case ScheduleCreateTransaction:
		return i.GetSignatures()
	case ScheduleDeleteTransaction:
		return i.GetSignatures()
	case ScheduleSignTransaction:
		return i.GetSignatures()
	case SystemDeleteTransaction:
		return i.GetSignatures()
	case SystemUndeleteTransaction:
		return i.GetSignatures()
	case TokenAssociateTransaction:
		return i.GetSignatures()
	case TokenBurnTransaction:
		return i.GetSignatures()
	case TokenCreateTransaction:
		return i.GetSignatures()
	case TokenDeleteTransaction:
		return i.GetSignatures()
	case TokenDissociateTransaction:
		return i.GetSignatures()
	case TokenFeeScheduleUpdateTransaction:
		return i.GetSignatures()
	case TokenFreezeTransaction:
		return i.GetSignatures()
	case TokenGrantKycTransaction:
		return i.GetSignatures()
	case TokenMintTransaction:
		return i.GetSignatures()
	case TokenRevokeKycTransaction:
		return i.GetSignatures()
	case TokenUnfreezeTransaction:
		return i.GetSignatures()
	case TokenUpdateTransaction:
		return i.GetSignatures()
	case TokenWipeTransaction:
		return i.GetSignatures()
	case TopicCreateTransaction:
		return i.GetSignatures()
	case TopicDeleteTransaction:
		return i.GetSignatures()
	case TopicMessageSubmitTransaction:
		return i.GetSignatures()
	case TopicUpdateTransaction:
		return i.GetSignatures()
	case TransferTransaction:
		return i.GetSignatures()
	case *AccountCreateTransaction:
		return i.GetSignatures()
	case *AccountDeleteTransaction:
		return i.GetSignatures()
	case *AccountUpdateTransaction:
		return i.GetSignatures()
	case *AccountAllowanceApproveTransaction:
		return i.GetSignatures()
	case *AccountAllowanceDeleteTransaction:
		return i.GetSignatures()
	case *ContractCreateTransaction:
		return i.GetSignatures()
	case *ContractDeleteTransaction:
		return i.GetSignatures()
	case *ContractExecuteTransaction:
		return i.GetSignatures()
	case *ContractUpdateTransaction:
		return i.GetSignatures()
	case *FileAppendTransaction:
		return i.GetSignatures()
	case *FileCreateTransaction:
		return i.GetSignatures()
	case *FileDeleteTransaction:
		return i.GetSignatures()
	case *FileUpdateTransaction:
		return i.GetSignatures()
	case *LiveHashAddTransaction:
		return i.GetSignatures()
	case *LiveHashDeleteTransaction:
		return i.GetSignatures()
	case *ScheduleCreateTransaction:
		return i.GetSignatures()
	case *ScheduleDeleteTransaction:
		return i.GetSignatures()
	case *ScheduleSignTransaction:
		return i.GetSignatures()
	case *SystemDeleteTransaction:
		return i.GetSignatures()
	case *SystemUndeleteTransaction:
		return i.GetSignatures()
	case *TokenAssociateTransaction:
		return i.GetSignatures()
	case *TokenBurnTransaction:
		return i.GetSignatures()
	case *TokenCreateTransaction:
		return i.GetSignatures()
	case *TokenDeleteTransaction:
		return i.GetSignatures()
	case *TokenDissociateTransaction:
		return i.GetSignatures()
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetSignatures()
	case *TokenFreezeTransaction:
		return i.GetSignatures()
	case *TokenGrantKycTransaction:
		return i.GetSignatures()
	case *TokenMintTransaction:
		return i.GetSignatures()
	case *TokenRevokeKycTransaction:
		return i.GetSignatures()
	case *TokenUnfreezeTransaction:
		return i.GetSignatures()
	case *TokenUpdateTransaction:
		return i.GetSignatures()
	case *TokenWipeTransaction:
		return i.GetSignatures()
	case *TopicCreateTransaction:
		return i.GetSignatures()
	case *TopicDeleteTransaction:
		return i.GetSignatures()
	case *TopicMessageSubmitTransaction:
		return i.GetSignatures()
	case *TopicUpdateTransaction:
		return i.GetSignatures()
	case *TransferTransaction:
		return i.GetSignatures()
	default:
		return nil, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionSetTransactionID(transaction interface{}, transactionID TransactionID) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case AccountDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case AccountUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case AccountAllowanceApproveTransaction:
		return i.SetTransactionID(transactionID), nil
	case AccountAllowanceDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case ContractCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case ContractDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case ContractExecuteTransaction:
		return i.SetTransactionID(transactionID), nil
	case ContractUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case FileAppendTransaction:
		return i.SetTransactionID(transactionID), nil
	case FileCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case FileDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case FileUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case LiveHashAddTransaction:
		return i.SetTransactionID(transactionID), nil
	case LiveHashDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case ScheduleCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case ScheduleDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case ScheduleSignTransaction:
		return i.SetTransactionID(transactionID), nil
	case SystemDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case SystemUndeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenAssociateTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenBurnTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenDissociateTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenFreezeTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenGrantKycTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenMintTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenRevokeKycTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenUnfreezeTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case TokenWipeTransaction:
		return i.SetTransactionID(transactionID), nil
	case TopicCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case TopicDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case TopicMessageSubmitTransaction:
		return i.SetTransactionID(transactionID), nil
	case TopicUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case TransferTransaction:
		return i.SetTransactionID(transactionID), nil
	case *AccountCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *AccountDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *AccountUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *AccountAllowanceApproveTransaction:
		return i.SetTransactionID(transactionID), nil
	case *AccountAllowanceDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *ContractCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *ContractDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *ContractExecuteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *ContractUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *FileAppendTransaction:
		return i.SetTransactionID(transactionID), nil
	case *FileCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *FileDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *FileUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *LiveHashAddTransaction:
		return i.SetTransactionID(transactionID), nil
	case *LiveHashDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *ScheduleCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *ScheduleDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *ScheduleSignTransaction:
		return i.SetTransactionID(transactionID), nil
	case *SystemDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *SystemUndeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenAssociateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenBurnTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenDissociateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenFreezeTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenGrantKycTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenMintTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenRevokeKycTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenUnfreezeTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TokenWipeTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TopicCreateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TopicDeleteTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TopicMessageSubmitTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TopicUpdateTransaction:
		return i.SetTransactionID(transactionID), nil
	case *TransferTransaction:
		return i.SetTransactionID(transactionID), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetTransactionID(transaction interface{}) (TransactionID, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetTransactionID(), nil
	case AccountDeleteTransaction:
		return i.GetTransactionID(), nil
	case AccountUpdateTransaction:
		return i.GetTransactionID(), nil
	case AccountAllowanceApproveTransaction:
		return i.GetTransactionID(), nil
	case AccountAllowanceDeleteTransaction:
		return i.GetTransactionID(), nil
	case ContractCreateTransaction:
		return i.GetTransactionID(), nil
	case ContractDeleteTransaction:
		return i.GetTransactionID(), nil
	case ContractExecuteTransaction:
		return i.GetTransactionID(), nil
	case ContractUpdateTransaction:
		return i.GetTransactionID(), nil
	case FileAppendTransaction:
		return i.GetTransactionID(), nil
	case FileCreateTransaction:
		return i.GetTransactionID(), nil
	case FileDeleteTransaction:
		return i.GetTransactionID(), nil
	case FileUpdateTransaction:
		return i.GetTransactionID(), nil
	case LiveHashAddTransaction:
		return i.GetTransactionID(), nil
	case LiveHashDeleteTransaction:
		return i.GetTransactionID(), nil
	case ScheduleCreateTransaction:
		return i.GetTransactionID(), nil
	case ScheduleDeleteTransaction:
		return i.GetTransactionID(), nil
	case ScheduleSignTransaction:
		return i.GetTransactionID(), nil
	case SystemDeleteTransaction:
		return i.GetTransactionID(), nil
	case SystemUndeleteTransaction:
		return i.GetTransactionID(), nil
	case TokenAssociateTransaction:
		return i.GetTransactionID(), nil
	case TokenBurnTransaction:
		return i.GetTransactionID(), nil
	case TokenCreateTransaction:
		return i.GetTransactionID(), nil
	case TokenDeleteTransaction:
		return i.GetTransactionID(), nil
	case TokenDissociateTransaction:
		return i.GetTransactionID(), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionID(), nil
	case TokenFreezeTransaction:
		return i.GetTransactionID(), nil
	case TokenGrantKycTransaction:
		return i.GetTransactionID(), nil
	case TokenMintTransaction:
		return i.GetTransactionID(), nil
	case TokenRevokeKycTransaction:
		return i.GetTransactionID(), nil
	case TokenUnfreezeTransaction:
		return i.GetTransactionID(), nil
	case TokenUpdateTransaction:
		return i.GetTransactionID(), nil
	case TokenWipeTransaction:
		return i.GetTransactionID(), nil
	case TopicCreateTransaction:
		return i.GetTransactionID(), nil
	case TopicDeleteTransaction:
		return i.GetTransactionID(), nil
	case TopicMessageSubmitTransaction:
		return i.GetTransactionID(), nil
	case TopicUpdateTransaction:
		return i.GetTransactionID(), nil
	case TransferTransaction:
		return i.GetTransactionID(), nil
	case *AccountCreateTransaction:
		return i.GetTransactionID(), nil
	case *AccountDeleteTransaction:
		return i.GetTransactionID(), nil
	case *AccountUpdateTransaction:
		return i.GetTransactionID(), nil
	case *AccountAllowanceApproveTransaction:
		return i.GetTransactionID(), nil
	case *AccountAllowanceDeleteTransaction:
		return i.GetTransactionID(), nil
	case *ContractCreateTransaction:
		return i.GetTransactionID(), nil
	case *ContractDeleteTransaction:
		return i.GetTransactionID(), nil
	case *ContractExecuteTransaction:
		return i.GetTransactionID(), nil
	case *ContractUpdateTransaction:
		return i.GetTransactionID(), nil
	case *FileAppendTransaction:
		return i.GetTransactionID(), nil
	case *FileCreateTransaction:
		return i.GetTransactionID(), nil
	case *FileDeleteTransaction:
		return i.GetTransactionID(), nil
	case *FileUpdateTransaction:
		return i.GetTransactionID(), nil
	case *LiveHashAddTransaction:
		return i.GetTransactionID(), nil
	case *LiveHashDeleteTransaction:
		return i.GetTransactionID(), nil
	case *ScheduleCreateTransaction:
		return i.GetTransactionID(), nil
	case *ScheduleDeleteTransaction:
		return i.GetTransactionID(), nil
	case *ScheduleSignTransaction:
		return i.GetTransactionID(), nil
	case *SystemDeleteTransaction:
		return i.GetTransactionID(), nil
	case *SystemUndeleteTransaction:
		return i.GetTransactionID(), nil
	case *TokenAssociateTransaction:
		return i.GetTransactionID(), nil
	case *TokenBurnTransaction:
		return i.GetTransactionID(), nil
	case *TokenCreateTransaction:
		return i.GetTransactionID(), nil
	case *TokenDeleteTransaction:
		return i.GetTransactionID(), nil
	case *TokenDissociateTransaction:
		return i.GetTransactionID(), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionID(), nil
	case *TokenFreezeTransaction:
		return i.GetTransactionID(), nil
	case *TokenGrantKycTransaction:
		return i.GetTransactionID(), nil
	case *TokenMintTransaction:
		return i.GetTransactionID(), nil
	case *TokenRevokeKycTransaction:
		return i.GetTransactionID(), nil
	case *TokenUnfreezeTransaction:
		return i.GetTransactionID(), nil
	case *TokenUpdateTransaction:
		return i.GetTransactionID(), nil
	case *TokenWipeTransaction:
		return i.GetTransactionID(), nil
	case *TopicCreateTransaction:
		return i.GetTransactionID(), nil
	case *TopicDeleteTransaction:
		return i.GetTransactionID(), nil
	case *TopicMessageSubmitTransaction:
		return i.GetTransactionID(), nil
	case *TopicUpdateTransaction:
		return i.GetTransactionID(), nil
	case *TransferTransaction:
		return i.GetTransactionID(), nil
	default:
		return TransactionID{}, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionSetTransactionMemo(transaction interface{}, transactionMemo string) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case AccountDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case AccountUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case AccountAllowanceApproveTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case AccountAllowanceDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case ContractCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case ContractDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case ContractExecuteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case ContractUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case FileAppendTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case FileCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case FileDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case FileUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case LiveHashAddTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case LiveHashDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case ScheduleCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case ScheduleDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case ScheduleSignTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case SystemDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case SystemUndeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenAssociateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenBurnTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenDissociateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenFreezeTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenGrantKycTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenMintTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenRevokeKycTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenUnfreezeTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TokenWipeTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TopicCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TopicDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TopicMessageSubmitTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TopicUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case TransferTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *AccountCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *AccountDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *AccountUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *AccountAllowanceApproveTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *AccountAllowanceDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *ContractCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *ContractDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *ContractExecuteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *ContractUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *FileAppendTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *FileCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *FileDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *FileUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *LiveHashAddTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *LiveHashDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *ScheduleCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *ScheduleDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *ScheduleSignTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *SystemDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *SystemUndeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenAssociateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenBurnTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenDissociateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenFreezeTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenGrantKycTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenMintTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenRevokeKycTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenUnfreezeTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TokenWipeTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TopicCreateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TopicDeleteTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TopicMessageSubmitTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TopicUpdateTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	case *TransferTransaction:
		return i.SetTransactionMemo(transactionMemo), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetTransactionMemo(transaction interface{}) (string, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetTransactionMemo(), nil
	case AccountDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case AccountUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case AccountAllowanceApproveTransaction:
		return i.GetTransactionMemo(), nil
	case AccountAllowanceDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case ContractCreateTransaction:
		return i.GetTransactionMemo(), nil
	case ContractDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case ContractExecuteTransaction:
		return i.GetTransactionMemo(), nil
	case ContractUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case FileAppendTransaction:
		return i.GetTransactionMemo(), nil
	case FileCreateTransaction:
		return i.GetTransactionMemo(), nil
	case FileDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case FileUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case LiveHashAddTransaction:
		return i.GetTransactionMemo(), nil
	case LiveHashDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case ScheduleCreateTransaction:
		return i.GetTransactionMemo(), nil
	case ScheduleDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case ScheduleSignTransaction:
		return i.GetTransactionMemo(), nil
	case SystemDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case SystemUndeleteTransaction:
		return i.GetTransactionMemo(), nil
	case TokenAssociateTransaction:
		return i.GetTransactionMemo(), nil
	case TokenBurnTransaction:
		return i.GetTransactionMemo(), nil
	case TokenCreateTransaction:
		return i.GetTransactionMemo(), nil
	case TokenDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case TokenDissociateTransaction:
		return i.GetTransactionMemo(), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case TokenFreezeTransaction:
		return i.GetTransactionMemo(), nil
	case TokenGrantKycTransaction:
		return i.GetTransactionMemo(), nil
	case TokenMintTransaction:
		return i.GetTransactionMemo(), nil
	case TokenRevokeKycTransaction:
		return i.GetTransactionMemo(), nil
	case TokenUnfreezeTransaction:
		return i.GetTransactionMemo(), nil
	case TokenUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case TokenWipeTransaction:
		return i.GetTransactionMemo(), nil
	case TopicCreateTransaction:
		return i.GetTransactionMemo(), nil
	case TopicDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case TopicMessageSubmitTransaction:
		return i.GetTransactionMemo(), nil
	case TopicUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case TransferTransaction:
		return i.GetTransactionMemo(), nil
	case *AccountCreateTransaction:
		return i.GetTransactionMemo(), nil
	case *AccountDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *AccountUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case *AccountAllowanceApproveTransaction:
		return i.GetTransactionMemo(), nil
	case *AccountAllowanceDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *ContractCreateTransaction:
		return i.GetTransactionMemo(), nil
	case *ContractDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *ContractExecuteTransaction:
		return i.GetTransactionMemo(), nil
	case *ContractUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case *FileAppendTransaction:
		return i.GetTransactionMemo(), nil
	case *FileCreateTransaction:
		return i.GetTransactionMemo(), nil
	case *FileDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *FileUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case *LiveHashAddTransaction:
		return i.GetTransactionMemo(), nil
	case *LiveHashDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *ScheduleCreateTransaction:
		return i.GetTransactionMemo(), nil
	case *ScheduleDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *ScheduleSignTransaction:
		return i.GetTransactionMemo(), nil
	case *SystemDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *SystemUndeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenAssociateTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenBurnTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenCreateTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenDissociateTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenFreezeTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenGrantKycTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenMintTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenRevokeKycTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenUnfreezeTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case *TokenWipeTransaction:
		return i.GetTransactionMemo(), nil
	case *TopicCreateTransaction:
		return i.GetTransactionMemo(), nil
	case *TopicDeleteTransaction:
		return i.GetTransactionMemo(), nil
	case *TopicMessageSubmitTransaction:
		return i.GetTransactionMemo(), nil
	case *TopicUpdateTransaction:
		return i.GetTransactionMemo(), nil
	case *TransferTransaction:
		return i.GetTransactionMemo(), nil
	default:
		return "", errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionSetMaxTransactionFee(transaction interface{}, maxTransactionFee Hbar) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case AccountDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case AccountUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case AccountAllowanceApproveTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case AccountAllowanceDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case ContractCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case ContractDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case ContractExecuteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case ContractUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case FileAppendTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case FileCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case FileDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case FileUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case LiveHashAddTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case LiveHashDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case ScheduleCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case ScheduleDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case ScheduleSignTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case SystemDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case SystemUndeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenAssociateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenBurnTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenDissociateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenFreezeTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenGrantKycTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenMintTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenRevokeKycTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenUnfreezeTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TokenWipeTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TopicCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TopicDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TopicMessageSubmitTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TopicUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case TransferTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *AccountCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *AccountDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *AccountUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *AccountAllowanceApproveTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *AccountAllowanceDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *ContractCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *ContractDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *ContractExecuteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *ContractUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *FileAppendTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *FileCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *FileDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *FileUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *LiveHashAddTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *LiveHashDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *ScheduleCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *ScheduleDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *ScheduleSignTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *SystemDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *SystemUndeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenAssociateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenBurnTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenDissociateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenFreezeTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenGrantKycTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenMintTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenRevokeKycTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenUnfreezeTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TokenWipeTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TopicCreateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TopicDeleteTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TopicMessageSubmitTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TopicUpdateTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	case *TransferTransaction:
		return i.SetMaxTransactionFee(maxTransactionFee), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetMaxTransactionFee(transaction interface{}) (Hbar, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case AccountDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case AccountUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case AccountAllowanceApproveTransaction:
		return i.GetMaxTransactionFee(), nil
	case AccountAllowanceDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case ContractCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case ContractDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case ContractExecuteTransaction:
		return i.GetMaxTransactionFee(), nil
	case ContractUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case FileAppendTransaction:
		return i.GetMaxTransactionFee(), nil
	case FileCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case FileDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case FileUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case LiveHashAddTransaction:
		return i.GetMaxTransactionFee(), nil
	case LiveHashDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case ScheduleCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case ScheduleDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case ScheduleSignTransaction:
		return i.GetMaxTransactionFee(), nil
	case SystemDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case SystemUndeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenAssociateTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenBurnTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenDissociateTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenFreezeTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenGrantKycTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenMintTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenRevokeKycTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenUnfreezeTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case TokenWipeTransaction:
		return i.GetMaxTransactionFee(), nil
	case TopicCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case TopicDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case TopicMessageSubmitTransaction:
		return i.GetMaxTransactionFee(), nil
	case TopicUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case TransferTransaction:
		return i.GetMaxTransactionFee(), nil
	case *AccountCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *AccountDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *AccountUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *AccountAllowanceApproveTransaction:
		return i.GetMaxTransactionFee(), nil
	case *AccountAllowanceDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *ContractCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *ContractDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *ContractExecuteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *ContractUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *FileAppendTransaction:
		return i.GetMaxTransactionFee(), nil
	case *FileCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *FileDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *FileUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *LiveHashAddTransaction:
		return i.GetMaxTransactionFee(), nil
	case *LiveHashDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *ScheduleCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *ScheduleDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *ScheduleSignTransaction:
		return i.GetMaxTransactionFee(), nil
	case *SystemDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *SystemUndeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenAssociateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenBurnTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenDissociateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenFreezeTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenGrantKycTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenMintTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenRevokeKycTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenUnfreezeTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TokenWipeTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TopicCreateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TopicDeleteTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TopicMessageSubmitTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TopicUpdateTransaction:
		return i.GetMaxTransactionFee(), nil
	case *TransferTransaction:
		return i.GetMaxTransactionFee(), nil
	default:
		return Hbar{}, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionSetTransactionValidDuration(transaction interface{}, transactionValidDuration time.Duration) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case AccountDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case AccountUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case AccountAllowanceApproveTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case AccountAllowanceDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case ContractCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case ContractDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case ContractExecuteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case ContractUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case FileAppendTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case FileCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case FileDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case FileUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case LiveHashAddTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case LiveHashDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case ScheduleCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case ScheduleDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case ScheduleSignTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case SystemDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case SystemUndeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenAssociateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenBurnTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenDissociateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenFreezeTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenGrantKycTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenMintTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenRevokeKycTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenUnfreezeTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TokenWipeTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TopicCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TopicDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TopicMessageSubmitTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TopicUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case TransferTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *AccountCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *AccountDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *AccountUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *AccountAllowanceApproveTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *AccountAllowanceDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *ContractCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *ContractDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *ContractExecuteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *ContractUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *FileAppendTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *FileCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *FileDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *FileUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *LiveHashAddTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *LiveHashDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *ScheduleCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *ScheduleDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *ScheduleSignTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *SystemDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *SystemUndeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenAssociateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenBurnTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenDissociateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenFreezeTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenGrantKycTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenMintTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenRevokeKycTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenUnfreezeTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TokenWipeTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TopicCreateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TopicDeleteTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TopicMessageSubmitTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TopicUpdateTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	case *TransferTransaction:
		return i.SetTransactionValidDuration(transactionValidDuration), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetTransactionValidDuration(transaction interface{}) (time.Duration, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case AccountDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case AccountUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case AccountAllowanceApproveTransaction:
		return i.GetTransactionValidDuration(), nil
	case AccountAllowanceDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case ContractCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case ContractDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case ContractExecuteTransaction:
		return i.GetTransactionValidDuration(), nil
	case ContractUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case FileAppendTransaction:
		return i.GetTransactionValidDuration(), nil
	case FileCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case FileDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case FileUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case LiveHashAddTransaction:
		return i.GetTransactionValidDuration(), nil
	case LiveHashDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case ScheduleCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case ScheduleDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case ScheduleSignTransaction:
		return i.GetTransactionValidDuration(), nil
	case SystemDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case SystemUndeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenAssociateTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenBurnTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenDissociateTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenFreezeTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenGrantKycTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenMintTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenRevokeKycTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenUnfreezeTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case TokenWipeTransaction:
		return i.GetTransactionValidDuration(), nil
	case TopicCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case TopicDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case TopicMessageSubmitTransaction:
		return i.GetTransactionValidDuration(), nil
	case TopicUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case TransferTransaction:
		return i.GetTransactionValidDuration(), nil
	case *AccountCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *AccountDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *AccountUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *AccountAllowanceApproveTransaction:
		return i.GetTransactionValidDuration(), nil
	case *AccountAllowanceDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *ContractCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *ContractDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *ContractExecuteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *ContractUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *FileAppendTransaction:
		return i.GetTransactionValidDuration(), nil
	case *FileCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *FileDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *FileUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *LiveHashAddTransaction:
		return i.GetTransactionValidDuration(), nil
	case *LiveHashDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *ScheduleCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *ScheduleDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *ScheduleSignTransaction:
		return i.GetTransactionValidDuration(), nil
	case *SystemDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *SystemUndeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenAssociateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenBurnTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenDissociateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenFreezeTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenGrantKycTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenMintTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenRevokeKycTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenUnfreezeTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TokenWipeTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TopicCreateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TopicDeleteTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TopicMessageSubmitTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TopicUpdateTransaction:
		return i.GetTransactionValidDuration(), nil
	case *TransferTransaction:
		return i.GetTransactionValidDuration(), nil
	default:
		return time.Duration(0), errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionSetNodeAccountIDs(transaction interface{}, nodeAccountIDs []AccountID) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case AccountDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case AccountUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case AccountAllowanceApproveTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case AccountAllowanceDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case ContractCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case ContractDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case ContractExecuteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case ContractUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case FileAppendTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case FileCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case FileDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case FileUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case LiveHashAddTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case LiveHashDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case ScheduleCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case ScheduleDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case ScheduleSignTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case SystemDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case SystemUndeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenAssociateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenBurnTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenDissociateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenFreezeTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenGrantKycTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenMintTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenRevokeKycTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenUnfreezeTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TokenWipeTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TopicCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TopicDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TopicMessageSubmitTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TopicUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case TransferTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *AccountCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *AccountDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *AccountUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *AccountAllowanceApproveTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *AccountAllowanceDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *ContractCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *ContractDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *ContractExecuteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *ContractUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *FileAppendTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *FileCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *FileDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *FileUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *LiveHashAddTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *LiveHashDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *ScheduleCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *ScheduleDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *ScheduleSignTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *SystemDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *SystemUndeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenAssociateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenBurnTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenDissociateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenFreezeTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenGrantKycTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenMintTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenRevokeKycTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenUnfreezeTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TokenWipeTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TopicCreateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TopicDeleteTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TopicMessageSubmitTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TopicUpdateTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	case *TransferTransaction:
		return i.SetNodeAccountIDs(nodeAccountIDs), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetNodeAccountIDs(transaction interface{}) ([]AccountID, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case AccountDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case AccountUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case AccountAllowanceApproveTransaction:
		return i.GetNodeAccountIDs(), nil
	case AccountAllowanceDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case ContractCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case ContractDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case ContractExecuteTransaction:
		return i.GetNodeAccountIDs(), nil
	case ContractUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case FileAppendTransaction:
		return i.GetNodeAccountIDs(), nil
	case FileCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case FileDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case FileUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case LiveHashAddTransaction:
		return i.GetNodeAccountIDs(), nil
	case LiveHashDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case ScheduleCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case ScheduleDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case ScheduleSignTransaction:
		return i.GetNodeAccountIDs(), nil
	case SystemDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case SystemUndeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenAssociateTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenBurnTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenDissociateTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenFreezeTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenGrantKycTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenMintTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenRevokeKycTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenUnfreezeTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case TokenWipeTransaction:
		return i.GetNodeAccountIDs(), nil
	case TopicCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case TopicDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case TopicMessageSubmitTransaction:
		return i.GetNodeAccountIDs(), nil
	case TopicUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case TransferTransaction:
		return i.GetNodeAccountIDs(), nil
	case *AccountCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *AccountDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *AccountUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *AccountAllowanceApproveTransaction:
		return i.GetNodeAccountIDs(), nil
	case *AccountAllowanceDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *ContractCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *ContractDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *ContractExecuteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *ContractUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *FileAppendTransaction:
		return i.GetNodeAccountIDs(), nil
	case *FileCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *FileDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *FileUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *LiveHashAddTransaction:
		return i.GetNodeAccountIDs(), nil
	case *LiveHashDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *ScheduleCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *ScheduleDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *ScheduleSignTransaction:
		return i.GetNodeAccountIDs(), nil
	case *SystemDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *SystemUndeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenAssociateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenBurnTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenDissociateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenFreezeTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenGrantKycTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenMintTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenRevokeKycTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenUnfreezeTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TokenWipeTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TopicCreateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TopicDeleteTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TopicMessageSubmitTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TopicUpdateTransaction:
		return i.GetNodeAccountIDs(), nil
	case *TransferTransaction:
		return i.GetNodeAccountIDs(), nil
	default:
		return []AccountID{}, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetTransactionHash(transaction interface{}) ([]byte, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetTransactionHash()
	case AccountDeleteTransaction:
		return i.GetTransactionHash()
	case AccountUpdateTransaction:
		return i.GetTransactionHash()
	case AccountAllowanceApproveTransaction:
		return i.GetTransactionHash()
	case AccountAllowanceDeleteTransaction:
		return i.GetTransactionHash()
	case ContractCreateTransaction:
		return i.GetTransactionHash()
	case ContractDeleteTransaction:
		return i.GetTransactionHash()
	case ContractExecuteTransaction:
		return i.GetTransactionHash()
	case ContractUpdateTransaction:
		return i.GetTransactionHash()
	case FileAppendTransaction:
		return i.GetTransactionHash()
	case FileCreateTransaction:
		return i.GetTransactionHash()
	case FileDeleteTransaction:
		return i.GetTransactionHash()
	case FileUpdateTransaction:
		return i.GetTransactionHash()
	case LiveHashAddTransaction:
		return i.GetTransactionHash()
	case LiveHashDeleteTransaction:
		return i.GetTransactionHash()
	case ScheduleCreateTransaction:
		return i.GetTransactionHash()
	case ScheduleDeleteTransaction:
		return i.GetTransactionHash()
	case ScheduleSignTransaction:
		return i.GetTransactionHash()
	case SystemDeleteTransaction:
		return i.GetTransactionHash()
	case SystemUndeleteTransaction:
		return i.GetTransactionHash()
	case TokenAssociateTransaction:
		return i.GetTransactionHash()
	case TokenBurnTransaction:
		return i.GetTransactionHash()
	case TokenCreateTransaction:
		return i.GetTransactionHash()
	case TokenDeleteTransaction:
		return i.GetTransactionHash()
	case TokenDissociateTransaction:
		return i.GetTransactionHash()
	case TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionHash()
	case TokenFreezeTransaction:
		return i.GetTransactionHash()
	case TokenGrantKycTransaction:
		return i.GetTransactionHash()
	case TokenMintTransaction:
		return i.GetTransactionHash()
	case TokenRevokeKycTransaction:
		return i.GetTransactionHash()
	case TokenUnfreezeTransaction:
		return i.GetTransactionHash()
	case TokenUpdateTransaction:
		return i.GetTransactionHash()
	case TokenWipeTransaction:
		return i.GetTransactionHash()
	case TopicCreateTransaction:
		return i.GetTransactionHash()
	case TopicDeleteTransaction:
		return i.GetTransactionHash()
	case TopicMessageSubmitTransaction:
		return i.GetTransactionHash()
	case TopicUpdateTransaction:
		return i.GetTransactionHash()
	case TransferTransaction:
		return i.GetTransactionHash()
	case *AccountCreateTransaction:
		return i.GetTransactionHash()
	case *AccountDeleteTransaction:
		return i.GetTransactionHash()
	case *AccountUpdateTransaction:
		return i.GetTransactionHash()
	case *AccountAllowanceApproveTransaction:
		return i.GetTransactionHash()
	case *AccountAllowanceDeleteTransaction:
		return i.GetTransactionHash()
	case *ContractCreateTransaction:
		return i.GetTransactionHash()
	case *ContractDeleteTransaction:
		return i.GetTransactionHash()
	case *ContractExecuteTransaction:
		return i.GetTransactionHash()
	case *ContractUpdateTransaction:
		return i.GetTransactionHash()
	case *FileAppendTransaction:
		return i.GetTransactionHash()
	case *FileCreateTransaction:
		return i.GetTransactionHash()
	case *FileDeleteTransaction:
		return i.GetTransactionHash()
	case *FileUpdateTransaction:
		return i.GetTransactionHash()
	case *LiveHashAddTransaction:
		return i.GetTransactionHash()
	case *LiveHashDeleteTransaction:
		return i.GetTransactionHash()
	case *ScheduleCreateTransaction:
		return i.GetTransactionHash()
	case *ScheduleDeleteTransaction:
		return i.GetTransactionHash()
	case *ScheduleSignTransaction:
		return i.GetTransactionHash()
	case *SystemDeleteTransaction:
		return i.GetTransactionHash()
	case *SystemUndeleteTransaction:
		return i.GetTransactionHash()
	case *TokenAssociateTransaction:
		return i.GetTransactionHash()
	case *TokenBurnTransaction:
		return i.GetTransactionHash()
	case *TokenCreateTransaction:
		return i.GetTransactionHash()
	case *TokenDeleteTransaction:
		return i.GetTransactionHash()
	case *TokenDissociateTransaction:
		return i.GetTransactionHash()
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionHash()
	case *TokenFreezeTransaction:
		return i.GetTransactionHash()
	case *TokenGrantKycTransaction:
		return i.GetTransactionHash()
	case *TokenMintTransaction:
		return i.GetTransactionHash()
	case *TokenRevokeKycTransaction:
		return i.GetTransactionHash()
	case *TokenUnfreezeTransaction:
		return i.GetTransactionHash()
	case *TokenUpdateTransaction:
		return i.GetTransactionHash()
	case *TokenWipeTransaction:
		return i.GetTransactionHash()
	case *TopicCreateTransaction:
		return i.GetTransactionHash()
	case *TopicDeleteTransaction:
		return i.GetTransactionHash()
	case *TopicMessageSubmitTransaction:
		return i.GetTransactionHash()
	case *TopicUpdateTransaction:
		return i.GetTransactionHash()
	case *TransferTransaction:
		return i.GetTransactionHash()
	default:
		return nil, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetTransactionHashPerNode(transaction interface{}) (map[AccountID][]byte, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetTransactionHashPerNode()
	case AccountDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case AccountUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case AccountAllowanceApproveTransaction:
		return i.GetTransactionHashPerNode()
	case AccountAllowanceDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case ContractCreateTransaction:
		return i.GetTransactionHashPerNode()
	case ContractDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case ContractExecuteTransaction:
		return i.GetTransactionHashPerNode()
	case ContractUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case FileAppendTransaction:
		return i.GetTransactionHashPerNode()
	case FileCreateTransaction:
		return i.GetTransactionHashPerNode()
	case FileDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case FileUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case LiveHashAddTransaction:
		return i.GetTransactionHashPerNode()
	case LiveHashDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case ScheduleCreateTransaction:
		return i.GetTransactionHashPerNode()
	case ScheduleDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case ScheduleSignTransaction:
		return i.GetTransactionHashPerNode()
	case SystemDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case SystemUndeleteTransaction:
		return i.GetTransactionHashPerNode()
	case TokenAssociateTransaction:
		return i.GetTransactionHashPerNode()
	case TokenBurnTransaction:
		return i.GetTransactionHashPerNode()
	case TokenCreateTransaction:
		return i.GetTransactionHashPerNode()
	case TokenDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case TokenDissociateTransaction:
		return i.GetTransactionHashPerNode()
	case TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case TokenFreezeTransaction:
		return i.GetTransactionHashPerNode()
	case TokenGrantKycTransaction:
		return i.GetTransactionHashPerNode()
	case TokenMintTransaction:
		return i.GetTransactionHashPerNode()
	case TokenRevokeKycTransaction:
		return i.GetTransactionHashPerNode()
	case TokenUnfreezeTransaction:
		return i.GetTransactionHashPerNode()
	case TokenUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case TokenWipeTransaction:
		return i.GetTransactionHashPerNode()
	case TopicCreateTransaction:
		return i.GetTransactionHashPerNode()
	case TopicDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case TopicMessageSubmitTransaction:
		return i.GetTransactionHashPerNode()
	case TopicUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case TransferTransaction:
		return i.GetTransactionHashPerNode()
	case *AccountCreateTransaction:
		return i.GetTransactionHashPerNode()
	case *AccountDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *AccountUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case *AccountAllowanceApproveTransaction:
		return i.GetTransactionHashPerNode()
	case *AccountAllowanceDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *ContractCreateTransaction:
		return i.GetTransactionHashPerNode()
	case *ContractDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *ContractExecuteTransaction:
		return i.GetTransactionHashPerNode()
	case *ContractUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case *FileAppendTransaction:
		return i.GetTransactionHashPerNode()
	case *FileCreateTransaction:
		return i.GetTransactionHashPerNode()
	case *FileDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *FileUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case *LiveHashAddTransaction:
		return i.GetTransactionHashPerNode()
	case *LiveHashDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *ScheduleCreateTransaction:
		return i.GetTransactionHashPerNode()
	case *ScheduleDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *ScheduleSignTransaction:
		return i.GetTransactionHashPerNode()
	case *SystemDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *SystemUndeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenAssociateTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenBurnTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenCreateTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenDissociateTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenFreezeTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenGrantKycTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenMintTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenRevokeKycTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenUnfreezeTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case *TokenWipeTransaction:
		return i.GetTransactionHashPerNode()
	case *TopicCreateTransaction:
		return i.GetTransactionHashPerNode()
	case *TopicDeleteTransaction:
		return i.GetTransactionHashPerNode()
	case *TopicMessageSubmitTransaction:
		return i.GetTransactionHashPerNode()
	case *TopicUpdateTransaction:
		return i.GetTransactionHashPerNode()
	case *TransferTransaction:
		return i.GetTransactionHashPerNode()
	default:
		return nil, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionSetMinBackoff(transaction interface{}, minBackoff time.Duration) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case AccountDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case AccountUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case AccountAllowanceApproveTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case AccountAllowanceDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case ContractCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case ContractDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case ContractExecuteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case ContractUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case FileAppendTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case FileCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case FileDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case FileUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case LiveHashAddTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case LiveHashDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case ScheduleCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case ScheduleDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case ScheduleSignTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case SystemDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case SystemUndeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenAssociateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenBurnTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenDissociateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenFreezeTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenGrantKycTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenMintTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenRevokeKycTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenUnfreezeTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TokenWipeTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TopicCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TopicDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TopicMessageSubmitTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TopicUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case TransferTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *AccountCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *AccountDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *AccountUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *AccountAllowanceApproveTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *AccountAllowanceDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *ContractCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *ContractDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *ContractExecuteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *ContractUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *FileAppendTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *FileCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *FileDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *FileUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *LiveHashAddTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *LiveHashDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *ScheduleCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *ScheduleDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *ScheduleSignTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *SystemDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *SystemUndeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenAssociateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenBurnTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenDissociateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenFreezeTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenGrantKycTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenMintTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenRevokeKycTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenUnfreezeTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TokenWipeTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TopicCreateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TopicDeleteTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TopicMessageSubmitTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TopicUpdateTransaction:
		return i.SetMinBackoff(minBackoff), nil
	case *TransferTransaction:
		return i.SetMinBackoff(minBackoff), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetMinBackoff(transaction interface{}) (time.Duration, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetMinBackoff(), nil
	case AccountDeleteTransaction:
		return i.GetMinBackoff(), nil
	case AccountUpdateTransaction:
		return i.GetMinBackoff(), nil
	case AccountAllowanceApproveTransaction:
		return i.GetMinBackoff(), nil
	case AccountAllowanceDeleteTransaction:
		return i.GetMinBackoff(), nil
	case ContractCreateTransaction:
		return i.GetMinBackoff(), nil
	case ContractDeleteTransaction:
		return i.GetMinBackoff(), nil
	case ContractExecuteTransaction:
		return i.GetMinBackoff(), nil
	case ContractUpdateTransaction:
		return i.GetMinBackoff(), nil
	case FileAppendTransaction:
		return i.GetMinBackoff(), nil
	case FileCreateTransaction:
		return i.GetMinBackoff(), nil
	case FileDeleteTransaction:
		return i.GetMinBackoff(), nil
	case FileUpdateTransaction:
		return i.GetMinBackoff(), nil
	case LiveHashAddTransaction:
		return i.GetMinBackoff(), nil
	case LiveHashDeleteTransaction:
		return i.GetMinBackoff(), nil
	case ScheduleCreateTransaction:
		return i.GetMinBackoff(), nil
	case ScheduleDeleteTransaction:
		return i.GetMinBackoff(), nil
	case ScheduleSignTransaction:
		return i.GetMinBackoff(), nil
	case SystemDeleteTransaction:
		return i.GetMinBackoff(), nil
	case SystemUndeleteTransaction:
		return i.GetMinBackoff(), nil
	case TokenAssociateTransaction:
		return i.GetMinBackoff(), nil
	case TokenBurnTransaction:
		return i.GetMinBackoff(), nil
	case TokenCreateTransaction:
		return i.GetMinBackoff(), nil
	case TokenDeleteTransaction:
		return i.GetMinBackoff(), nil
	case TokenDissociateTransaction:
		return i.GetMinBackoff(), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.GetMinBackoff(), nil
	case TokenFreezeTransaction:
		return i.GetMinBackoff(), nil
	case TokenGrantKycTransaction:
		return i.GetMinBackoff(), nil
	case TokenMintTransaction:
		return i.GetMinBackoff(), nil
	case TokenRevokeKycTransaction:
		return i.GetMinBackoff(), nil
	case TokenUnfreezeTransaction:
		return i.GetMinBackoff(), nil
	case TokenUpdateTransaction:
		return i.GetMinBackoff(), nil
	case TokenWipeTransaction:
		return i.GetMinBackoff(), nil
	case TopicCreateTransaction:
		return i.GetMinBackoff(), nil
	case TopicDeleteTransaction:
		return i.GetMinBackoff(), nil
	case TopicMessageSubmitTransaction:
		return i.GetMinBackoff(), nil
	case TopicUpdateTransaction:
		return i.GetMinBackoff(), nil
	case TransferTransaction:
		return i.GetMinBackoff(), nil
	case *AccountCreateTransaction:
		return i.GetMinBackoff(), nil
	case *AccountDeleteTransaction:
		return i.GetMinBackoff(), nil
	case *AccountUpdateTransaction:
		return i.GetMinBackoff(), nil
	case *AccountAllowanceApproveTransaction:
		return i.GetMinBackoff(), nil
	case *AccountAllowanceDeleteTransaction:
		return i.GetMinBackoff(), nil
	case *ContractCreateTransaction:
		return i.GetMinBackoff(), nil
	case *ContractDeleteTransaction:
		return i.GetMinBackoff(), nil
	case *ContractExecuteTransaction:
		return i.GetMinBackoff(), nil
	case *ContractUpdateTransaction:
		return i.GetMinBackoff(), nil
	case *FileAppendTransaction:
		return i.GetMinBackoff(), nil
	case *FileCreateTransaction:
		return i.GetMinBackoff(), nil
	case *FileDeleteTransaction:
		return i.GetMinBackoff(), nil
	case *FileUpdateTransaction:
		return i.GetMinBackoff(), nil
	case *LiveHashAddTransaction:
		return i.GetMinBackoff(), nil
	case *LiveHashDeleteTransaction:
		return i.GetMinBackoff(), nil
	case *ScheduleCreateTransaction:
		return i.GetMinBackoff(), nil
	case *ScheduleDeleteTransaction:
		return i.GetMinBackoff(), nil
	case *ScheduleSignTransaction:
		return i.GetMinBackoff(), nil
	case *SystemDeleteTransaction:
		return i.GetMinBackoff(), nil
	case *SystemUndeleteTransaction:
		return i.GetMinBackoff(), nil
	case *TokenAssociateTransaction:
		return i.GetMinBackoff(), nil
	case *TokenBurnTransaction:
		return i.GetMinBackoff(), nil
	case *TokenCreateTransaction:
		return i.GetMinBackoff(), nil
	case *TokenDeleteTransaction:
		return i.GetMinBackoff(), nil
	case *TokenDissociateTransaction:
		return i.GetMinBackoff(), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetMinBackoff(), nil
	case *TokenFreezeTransaction:
		return i.GetMinBackoff(), nil
	case *TokenGrantKycTransaction:
		return i.GetMinBackoff(), nil
	case *TokenMintTransaction:
		return i.GetMinBackoff(), nil
	case *TokenRevokeKycTransaction:
		return i.GetMinBackoff(), nil
	case *TokenUnfreezeTransaction:
		return i.GetMinBackoff(), nil
	case *TokenUpdateTransaction:
		return i.GetMinBackoff(), nil
	case *TokenWipeTransaction:
		return i.GetMinBackoff(), nil
	case *TopicCreateTransaction:
		return i.GetMinBackoff(), nil
	case *TopicDeleteTransaction:
		return i.GetMinBackoff(), nil
	case *TopicMessageSubmitTransaction:
		return i.GetMinBackoff(), nil
	case *TopicUpdateTransaction:
		return i.GetMinBackoff(), nil
	case *TransferTransaction:
		return i.GetMinBackoff(), nil
	default:
		return time.Duration(0), errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionSetMaxBackoff(transaction interface{}, maxBackoff time.Duration) (interface{}, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case AccountDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case AccountUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case AccountAllowanceApproveTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case AccountAllowanceDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case ContractCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case ContractDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case ContractExecuteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case ContractUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case FileAppendTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case FileCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case FileDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case FileUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case LiveHashAddTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case LiveHashDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case ScheduleCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case ScheduleDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case ScheduleSignTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case SystemDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case SystemUndeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenAssociateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenBurnTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenDissociateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenFreezeTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenGrantKycTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenMintTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenRevokeKycTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenUnfreezeTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TokenWipeTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TopicCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TopicDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TopicMessageSubmitTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TopicUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case TransferTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *AccountCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *AccountDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *AccountUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *AccountAllowanceApproveTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *AccountAllowanceDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *ContractCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *ContractDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *ContractExecuteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *ContractUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *FileAppendTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *FileCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *FileDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *FileUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *LiveHashAddTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *LiveHashDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *ScheduleCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *ScheduleDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *ScheduleSignTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *SystemDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *SystemUndeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenAssociateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenBurnTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenDissociateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenFreezeTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenGrantKycTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenMintTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenRevokeKycTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenUnfreezeTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TokenWipeTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TopicCreateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TopicDeleteTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TopicMessageSubmitTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TopicUpdateTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	case *TransferTransaction:
		return i.SetMaxBackoff(maxBackoff), nil
	default:
		return transaction, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionGetMaxBackoff(transaction interface{}) (time.Duration, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.GetMaxBackoff(), nil
	case AccountDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case AccountUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case AccountAllowanceApproveTransaction:
		return i.GetMaxBackoff(), nil
	case AccountAllowanceDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case ContractCreateTransaction:
		return i.GetMaxBackoff(), nil
	case ContractDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case ContractExecuteTransaction:
		return i.GetMaxBackoff(), nil
	case ContractUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case FileAppendTransaction:
		return i.GetMaxBackoff(), nil
	case FileCreateTransaction:
		return i.GetMaxBackoff(), nil
	case FileDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case FileUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case LiveHashAddTransaction:
		return i.GetMaxBackoff(), nil
	case LiveHashDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case ScheduleCreateTransaction:
		return i.GetMaxBackoff(), nil
	case ScheduleDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case ScheduleSignTransaction:
		return i.GetMaxBackoff(), nil
	case SystemDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case SystemUndeleteTransaction:
		return i.GetMaxBackoff(), nil
	case TokenAssociateTransaction:
		return i.GetMaxBackoff(), nil
	case TokenBurnTransaction:
		return i.GetMaxBackoff(), nil
	case TokenCreateTransaction:
		return i.GetMaxBackoff(), nil
	case TokenDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case TokenDissociateTransaction:
		return i.GetMaxBackoff(), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case TokenFreezeTransaction:
		return i.GetMaxBackoff(), nil
	case TokenGrantKycTransaction:
		return i.GetMaxBackoff(), nil
	case TokenMintTransaction:
		return i.GetMaxBackoff(), nil
	case TokenRevokeKycTransaction:
		return i.GetMaxBackoff(), nil
	case TokenUnfreezeTransaction:
		return i.GetMaxBackoff(), nil
	case TokenUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case TokenWipeTransaction:
		return i.GetMaxBackoff(), nil
	case TopicCreateTransaction:
		return i.GetMaxBackoff(), nil
	case TopicDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case TopicMessageSubmitTransaction:
		return i.GetMaxBackoff(), nil
	case TopicUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case TransferTransaction:
		return i.GetMaxBackoff(), nil
	case *AccountCreateTransaction:
		return i.GetMaxBackoff(), nil
	case *AccountDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *AccountUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case *AccountAllowanceApproveTransaction:
		return i.GetMaxBackoff(), nil
	case *AccountAllowanceDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *ContractCreateTransaction:
		return i.GetMaxBackoff(), nil
	case *ContractDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *ContractExecuteTransaction:
		return i.GetMaxBackoff(), nil
	case *ContractUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case *FileAppendTransaction:
		return i.GetMaxBackoff(), nil
	case *FileCreateTransaction:
		return i.GetMaxBackoff(), nil
	case *FileDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *FileUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case *LiveHashAddTransaction:
		return i.GetMaxBackoff(), nil
	case *LiveHashDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *ScheduleCreateTransaction:
		return i.GetMaxBackoff(), nil
	case *ScheduleDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *ScheduleSignTransaction:
		return i.GetMaxBackoff(), nil
	case *SystemDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *SystemUndeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenAssociateTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenBurnTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenCreateTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenDissociateTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenFreezeTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenGrantKycTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenMintTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenRevokeKycTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenUnfreezeTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case *TokenWipeTransaction:
		return i.GetMaxBackoff(), nil
	case *TopicCreateTransaction:
		return i.GetMaxBackoff(), nil
	case *TopicDeleteTransaction:
		return i.GetMaxBackoff(), nil
	case *TopicMessageSubmitTransaction:
		return i.GetMaxBackoff(), nil
	case *TopicUpdateTransaction:
		return i.GetMaxBackoff(), nil
	case *TransferTransaction:
		return i.GetMaxBackoff(), nil
	default:
		return time.Duration(0), errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionString(transaction interface{}) (string, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.String(), nil
	case AccountDeleteTransaction:
		return i.String(), nil
	case AccountUpdateTransaction:
		return i.String(), nil
	case AccountAllowanceApproveTransaction:
		return i.String(), nil
	case AccountAllowanceDeleteTransaction:
		return i.String(), nil
	case ContractCreateTransaction:
		return i.String(), nil
	case ContractDeleteTransaction:
		return i.String(), nil
	case ContractExecuteTransaction:
		return i.String(), nil
	case ContractUpdateTransaction:
		return i.String(), nil
	case FileAppendTransaction:
		return i.String(), nil
	case FileCreateTransaction:
		return i.String(), nil
	case FileDeleteTransaction:
		return i.String(), nil
	case FileUpdateTransaction:
		return i.String(), nil
	case LiveHashAddTransaction:
		return i.String(), nil
	case LiveHashDeleteTransaction:
		return i.String(), nil
	case ScheduleCreateTransaction:
		return i.String(), nil
	case ScheduleDeleteTransaction:
		return i.String(), nil
	case ScheduleSignTransaction:
		return i.String(), nil
	case SystemDeleteTransaction:
		return i.String(), nil
	case SystemUndeleteTransaction:
		return i.String(), nil
	case TokenAssociateTransaction:
		return i.String(), nil
	case TokenBurnTransaction:
		return i.String(), nil
	case TokenCreateTransaction:
		return i.String(), nil
	case TokenDeleteTransaction:
		return i.String(), nil
	case TokenDissociateTransaction:
		return i.String(), nil
	case TokenFeeScheduleUpdateTransaction:
		return i.String(), nil
	case TokenFreezeTransaction:
		return i.String(), nil
	case TokenGrantKycTransaction:
		return i.String(), nil
	case TokenMintTransaction:
		return i.String(), nil
	case TokenRevokeKycTransaction:
		return i.String(), nil
	case TokenUnfreezeTransaction:
		return i.String(), nil
	case TokenUpdateTransaction:
		return i.String(), nil
	case TokenWipeTransaction:
		return i.String(), nil
	case TopicCreateTransaction:
		return i.String(), nil
	case TopicDeleteTransaction:
		return i.String(), nil
	case TopicMessageSubmitTransaction:
		return i.String(), nil
	case TopicUpdateTransaction:
		return i.String(), nil
	case TransferTransaction:
		return i.String(), nil
	case *AccountCreateTransaction:
		return i.String(), nil
	case *AccountDeleteTransaction:
		return i.String(), nil
	case *AccountUpdateTransaction:
		return i.String(), nil
	case *AccountAllowanceApproveTransaction:
		return i.String(), nil
	case *AccountAllowanceDeleteTransaction:
		return i.String(), nil
	case *ContractCreateTransaction:
		return i.String(), nil
	case *ContractDeleteTransaction:
		return i.String(), nil
	case *ContractExecuteTransaction:
		return i.String(), nil
	case *ContractUpdateTransaction:
		return i.String(), nil
	case *FileAppendTransaction:
		return i.String(), nil
	case *FileCreateTransaction:
		return i.String(), nil
	case *FileDeleteTransaction:
		return i.String(), nil
	case *FileUpdateTransaction:
		return i.String(), nil
	case *LiveHashAddTransaction:
		return i.String(), nil
	case *LiveHashDeleteTransaction:
		return i.String(), nil
	case *ScheduleCreateTransaction:
		return i.String(), nil
	case *ScheduleDeleteTransaction:
		return i.String(), nil
	case *ScheduleSignTransaction:
		return i.String(), nil
	case *SystemDeleteTransaction:
		return i.String(), nil
	case *SystemUndeleteTransaction:
		return i.String(), nil
	case *TokenAssociateTransaction:
		return i.String(), nil
	case *TokenBurnTransaction:
		return i.String(), nil
	case *TokenCreateTransaction:
		return i.String(), nil
	case *TokenDeleteTransaction:
		return i.String(), nil
	case *TokenDissociateTransaction:
		return i.String(), nil
	case *TokenFeeScheduleUpdateTransaction:
		return i.String(), nil
	case *TokenFreezeTransaction:
		return i.String(), nil
	case *TokenGrantKycTransaction:
		return i.String(), nil
	case *TokenMintTransaction:
		return i.String(), nil
	case *TokenRevokeKycTransaction:
		return i.String(), nil
	case *TokenUnfreezeTransaction:
		return i.String(), nil
	case *TokenUpdateTransaction:
		return i.String(), nil
	case *TokenWipeTransaction:
		return i.String(), nil
	case *TopicCreateTransaction:
		return i.String(), nil
	case *TopicDeleteTransaction:
		return i.String(), nil
	case *TopicMessageSubmitTransaction:
		return i.String(), nil
	case *TopicUpdateTransaction:
		return i.String(), nil
	case *TransferTransaction:
		return i.String(), nil
	default:
		return "", errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionToBytes(transaction interface{}) ([]byte, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.ToBytes()
	case AccountDeleteTransaction:
		return i.ToBytes()
	case AccountUpdateTransaction:
		return i.ToBytes()
	case AccountAllowanceApproveTransaction:
		return i.ToBytes()
	case AccountAllowanceDeleteTransaction:
		return i.ToBytes()
	case ContractCreateTransaction:
		return i.ToBytes()
	case ContractDeleteTransaction:
		return i.ToBytes()
	case ContractExecuteTransaction:
		return i.ToBytes()
	case ContractUpdateTransaction:
		return i.ToBytes()
	case FileAppendTransaction:
		return i.ToBytes()
	case FileCreateTransaction:
		return i.ToBytes()
	case FileDeleteTransaction:
		return i.ToBytes()
	case FileUpdateTransaction:
		return i.ToBytes()
	case LiveHashAddTransaction:
		return i.ToBytes()
	case LiveHashDeleteTransaction:
		return i.ToBytes()
	case ScheduleCreateTransaction:
		return i.ToBytes()
	case ScheduleDeleteTransaction:
		return i.ToBytes()
	case ScheduleSignTransaction:
		return i.ToBytes()
	case SystemDeleteTransaction:
		return i.ToBytes()
	case SystemUndeleteTransaction:
		return i.ToBytes()
	case TokenAssociateTransaction:
		return i.ToBytes()
	case TokenBurnTransaction:
		return i.ToBytes()
	case TokenCreateTransaction:
		return i.ToBytes()
	case TokenDeleteTransaction:
		return i.ToBytes()
	case TokenDissociateTransaction:
		return i.ToBytes()
	case TokenFeeScheduleUpdateTransaction:
		return i.ToBytes()
	case TokenFreezeTransaction:
		return i.ToBytes()
	case TokenGrantKycTransaction:
		return i.ToBytes()
	case TokenMintTransaction:
		return i.ToBytes()
	case TokenRevokeKycTransaction:
		return i.ToBytes()
	case TokenUnfreezeTransaction:
		return i.ToBytes()
	case TokenUpdateTransaction:
		return i.ToBytes()
	case TokenWipeTransaction:
		return i.ToBytes()
	case TopicCreateTransaction:
		return i.ToBytes()
	case TopicDeleteTransaction:
		return i.ToBytes()
	case TopicMessageSubmitTransaction:
		return i.ToBytes()
	case TopicUpdateTransaction:
		return i.ToBytes()
	case TransferTransaction:
		return i.ToBytes()
	case *AccountCreateTransaction:
		return i.ToBytes()
	case *AccountDeleteTransaction:
		return i.ToBytes()
	case *AccountUpdateTransaction:
		return i.ToBytes()
	case *AccountAllowanceApproveTransaction:
		return i.ToBytes()
	case *AccountAllowanceDeleteTransaction:
		return i.ToBytes()
	case *ContractCreateTransaction:
		return i.ToBytes()
	case *ContractDeleteTransaction:
		return i.ToBytes()
	case *ContractExecuteTransaction:
		return i.ToBytes()
	case *ContractUpdateTransaction:
		return i.ToBytes()
	case *FileAppendTransaction:
		return i.ToBytes()
	case *FileCreateTransaction:
		return i.ToBytes()
	case *FileDeleteTransaction:
		return i.ToBytes()
	case *FileUpdateTransaction:
		return i.ToBytes()
	case *LiveHashAddTransaction:
		return i.ToBytes()
	case *LiveHashDeleteTransaction:
		return i.ToBytes()
	case *ScheduleCreateTransaction:
		return i.ToBytes()
	case *ScheduleDeleteTransaction:
		return i.ToBytes()
	case *ScheduleSignTransaction:
		return i.ToBytes()
	case *SystemDeleteTransaction:
		return i.ToBytes()
	case *SystemUndeleteTransaction:
		return i.ToBytes()
	case *TokenAssociateTransaction:
		return i.ToBytes()
	case *TokenBurnTransaction:
		return i.ToBytes()
	case *TokenCreateTransaction:
		return i.ToBytes()
	case *TokenDeleteTransaction:
		return i.ToBytes()
	case *TokenDissociateTransaction:
		return i.ToBytes()
	case *TokenFeeScheduleUpdateTransaction:
		return i.ToBytes()
	case *TokenFreezeTransaction:
		return i.ToBytes()
	case *TokenGrantKycTransaction:
		return i.ToBytes()
	case *TokenMintTransaction:
		return i.ToBytes()
	case *TokenRevokeKycTransaction:
		return i.ToBytes()
	case *TokenUnfreezeTransaction:
		return i.ToBytes()
	case *TokenUpdateTransaction:
		return i.ToBytes()
	case *TokenWipeTransaction:
		return i.ToBytes()
	case *TopicCreateTransaction:
		return i.ToBytes()
	case *TopicDeleteTransaction:
		return i.ToBytes()
	case *TopicMessageSubmitTransaction:
		return i.ToBytes()
	case *TopicUpdateTransaction:
		return i.ToBytes()
	case *TransferTransaction:
		return i.ToBytes()
	case *TokenUpdateNfts:
		return i.ToBytes()
	case *TokenRejectTransaction:
		return i.ToBytes()
	case *TokenAirdropTransaction:
		return i.ToBytes()
	case *TokenCancelAirdropTransaction:
		return i.ToBytes()
	case *TokenClaimAirdropTransaction:
		return i.ToBytes()
	default:
		return nil, errors.New("(BUG) non-exhaustive switch statement")
	}
}

func TransactionExecute(transaction interface{}, client *Client) (TransactionResponse, error) { // nolint
	switch i := transaction.(type) {
	case AccountCreateTransaction:
		return i.Execute(client)
	case AccountDeleteTransaction:
		return i.Execute(client)
	case AccountUpdateTransaction:
		return i.Execute(client)
	case AccountAllowanceApproveTransaction:
		return i.Execute(client)
	case AccountAllowanceDeleteTransaction:
		return i.Execute(client)
	case ContractCreateTransaction:
		return i.Execute(client)
	case ContractDeleteTransaction:
		return i.Execute(client)
	case ContractExecuteTransaction:
		return i.Execute(client)
	case ContractUpdateTransaction:
		return i.Execute(client)
	case FileAppendTransaction:
		return i.Execute(client)
	case FileCreateTransaction:
		return i.Execute(client)
	case FileDeleteTransaction:
		return i.Execute(client)
	case FileUpdateTransaction:
		return i.Execute(client)
	case FreezeTransaction:
		return i.Execute(client)
	case LiveHashAddTransaction:
		return i.Execute(client)
	case LiveHashDeleteTransaction:
		return i.Execute(client)
	case ScheduleCreateTransaction:
		return i.Execute(client)
	case ScheduleDeleteTransaction:
		return i.Execute(client)
	case ScheduleSignTransaction:
		return i.Execute(client)
	case SystemDeleteTransaction:
		return i.Execute(client)
	case SystemUndeleteTransaction:
		return i.Execute(client)
	case TokenAssociateTransaction:
		return i.Execute(client)
	case TokenBurnTransaction:
		return i.Execute(client)
	case TokenCreateTransaction:
		return i.Execute(client)
	case TokenDeleteTransaction:
		return i.Execute(client)
	case TokenDissociateTransaction:
		return i.Execute(client)
	case TokenFeeScheduleUpdateTransaction:
		return i.Execute(client)
	case TokenFreezeTransaction:
		return i.Execute(client)
	case TokenGrantKycTransaction:
		return i.Execute(client)
	case TokenMintTransaction:
		return i.Execute(client)
	case TokenPauseTransaction:
		return i.Execute(client)
	case TokenRevokeKycTransaction:
		return i.Execute(client)
	case TokenUnfreezeTransaction:
		return i.Execute(client)
	case TokenUnpauseTransaction:
		return i.Execute(client)
	case TokenUpdateTransaction:
		return i.Execute(client)
	case TokenWipeTransaction:
		return i.Execute(client)
	case TopicCreateTransaction:
		return i.Execute(client)
	case TopicDeleteTransaction:
		return i.Execute(client)
	case TopicMessageSubmitTransaction:
		return i.Execute(client)
	case TopicUpdateTransaction:
		return i.Execute(client)
	case TransferTransaction:
		return i.Execute(client)
	case *AccountCreateTransaction:
		return i.Execute(client)
	case *AccountDeleteTransaction:
		return i.Execute(client)
	case *AccountUpdateTransaction:
		return i.Execute(client)
	case *AccountAllowanceApproveTransaction:
		return i.Execute(client)
	case *AccountAllowanceDeleteTransaction:
		return i.Execute(client)
	case *ContractCreateTransaction:
		return i.Execute(client)
	case *ContractDeleteTransaction:
		return i.Execute(client)
	case *ContractExecuteTransaction:
		return i.Execute(client)
	case *ContractUpdateTransaction:
		return i.Execute(client)
	case *FileAppendTransaction:
		return i.Execute(client)
	case *FileCreateTransaction:
		return i.Execute(client)
	case *FileDeleteTransaction:
		return i.Execute(client)
	case *FileUpdateTransaction:
		return i.Execute(client)
	case *FreezeTransaction:
		return i.Execute(client)
	case *LiveHashAddTransaction:
		return i.Execute(client)
	case *LiveHashDeleteTransaction:
		return i.Execute(client)
	case *ScheduleCreateTransaction:
		return i.Execute(client)
	case *ScheduleDeleteTransaction:
		return i.Execute(client)
	case *ScheduleSignTransaction:
		return i.Execute(client)
	case *SystemDeleteTransaction:
		return i.Execute(client)
	case *SystemUndeleteTransaction:
		return i.Execute(client)
	case *TokenAssociateTransaction:
		return i.Execute(client)
	case *TokenBurnTransaction:
		return i.Execute(client)
	case *TokenCreateTransaction:
		return i.Execute(client)
	case *TokenDeleteTransaction:
		return i.Execute(client)
	case *TokenDissociateTransaction:
		return i.Execute(client)
	case *TokenFeeScheduleUpdateTransaction:
		return i.Execute(client)
	case *TokenFreezeTransaction:
		return i.Execute(client)
	case *TokenGrantKycTransaction:
		return i.Execute(client)
	case *TokenMintTransaction:
		return i.Execute(client)
	case *TokenPauseTransaction:
		return i.Execute(client)
	case *TokenRevokeKycTransaction:
		return i.Execute(client)
	case *TokenUnfreezeTransaction:
		return i.Execute(client)
	case *TokenUnpauseTransaction:
		return i.Execute(client)
	case *TokenUpdateTransaction:
		return i.Execute(client)
	case *TokenWipeTransaction:
		return i.Execute(client)
	case *TopicCreateTransaction:
		return i.Execute(client)
	case *TopicDeleteTransaction:
		return i.Execute(client)
	case *TopicMessageSubmitTransaction:
		return i.Execute(client)
	case *TopicUpdateTransaction:
		return i.Execute(client)
	case *TransferTransaction:
		return i.Execute(client)
	case *TokenUpdateNfts:
		return i.Execute(client)
	case *TokenRejectTransaction:
		return i.Execute(client)
	case *TokenAirdropTransaction:
		return i.Execute(client)
	case *TokenCancelAirdropTransaction:
		return i.Execute(client)
	case *TokenClaimAirdropTransaction:
		return i.Execute(client)
	default:
		return TransactionResponse{}, errors.New("(BUG) non-exhaustive switch statement")
	}
}

// ------------ Executable Functions ------------
func (tx *Transaction) shouldRetry(_ Executable, response interface{}) _ExecutionState {
	status := Status(response.(*services.TransactionResponse).NodeTransactionPrecheckCode)

	retryableStatuses := map[Status]bool{
		StatusPlatformTransactionNotCreated: true,
		StatusPlatformNotActive:             true,
		StatusBusy:                          true,
	}

	if retryableStatuses[status] {
		return executionStateRetry
	}

	if status == StatusTransactionExpired {
		return executionStateExpired
	}

	if status == StatusOk {
		return executionStateFinished
	}

	return executionStateError
}

func (tx *Transaction) makeRequest() interface{} {
	index := tx.nodeAccountIDs._Length()*tx.transactionIDs.index + tx.nodeAccountIDs.index
	built, _ := tx._BuildTransaction(index)

	return built
}

func (tx *Transaction) advanceRequest() {
	tx.nodeAccountIDs._Advance()
	tx.signedTransactions._Advance()
}

func (tx *Transaction) getNodeAccountID() AccountID {
	return tx.nodeAccountIDs._GetCurrent().(AccountID)
}

func (tx *Transaction) mapStatusError(
	_ Executable,
	response interface{},
) error {
	return ErrHederaPreCheckStatus{
		Status: Status(response.(*services.TransactionResponse).NodeTransactionPrecheckCode),
		//NodeID: request.transaction.nodeAccountIDs,
		TxID: tx.GetTransactionID(),
	}
}

func (tx *Transaction) mapResponse(_ interface{}, nodeID AccountID, protoRequest interface{}) (interface{}, error) {
	hash := sha512.New384()
	_, err := hash.Write(protoRequest.(*services.Transaction).SignedTransactionBytes)
	if err != nil {
		return nil, err
	}

	return TransactionResponse{
		NodeID:        nodeID,
		TransactionID: tx.transactionIDs._GetNext().(TransactionID),
		Hash:          hash.Sum(nil),
	}, nil
}

// Building empty object as "default" implementation. All inhertents must implement their own implementation.
func (tx *Transaction) getMethod(ch *_Channel) _Method {
	return _Method{}
}

// Building empty object as "default" implementation. All inhertents must implement their own implementation.
func (tx *Transaction) getName() string {
	return "transaction"
}

func (tx *Transaction) getLogID(transactionInterface Executable) string {
	timestamp := tx.transactionIDs._GetCurrent().(TransactionID).ValidStart
	return fmt.Sprintf("%s:%d", transactionInterface.getName(), timestamp.UnixNano())
}

// Building empty object as "default" implementation. All inhertents must implement their own implementation.
func (tx *Transaction) validateNetworkOnIDs(client *Client) error {
	return errors.New("Function not implemented")
}

func (tx *Transaction) preFreezeWith(*Client) {
	// NO-OP
}

func (tx *Transaction) isTransaction() bool {
	return true
}

func (tx *Transaction) getTransactionIDAndMessage() (string, string) {
	return tx.GetTransactionID().String(), "transaction status received"
}

func (tx *Transaction) regenerateID(client *Client) bool {
	if !client.GetOperatorAccountID()._IsZero() && tx.regenerateTransactionID && !tx.transactionIDs.locked {
		tx.transactionIDs._Set(tx.transactionIDs.index, TransactionIDGenerate(client.GetOperatorAccountID()))
		return true
	}
	return false
}

func (tx *Transaction) execute(client *Client, e TransactionInterface) (TransactionResponse, error) {
	if client == nil {
		return TransactionResponse{}, errNoClientProvided
	}

	if tx.freezeError != nil {
		return TransactionResponse{}, tx.freezeError
	}

	if !tx.IsFrozen() {
		_, err := tx.freezeWith(client, e)
		if err != nil {
			return TransactionResponse{}, err
		}
	}

	transactionID := tx.transactionIDs._GetCurrent().(TransactionID)

	if !client.GetOperatorAccountID()._IsZero() && client.GetOperatorAccountID()._Equals(*transactionID.AccountID) {
		tx.SignWith(
			client.GetOperatorPublicKey(),
			client.operator.signer,
		)
	}

	if tx.grpcDeadline == nil {
		tx.grpcDeadline = client.requestTimeout
	}

	resp, err := _Execute(client, e)

	if err != nil {
		return TransactionResponse{
			TransactionID:  tx.GetTransactionID(),
			NodeID:         resp.(TransactionResponse).NodeID,
			ValidateStatus: true,
		}, err
	}
	originalTxID := tx.GetTransactionID()
	e.regenerateID(client)
	return TransactionResponse{
		TransactionID:  originalTxID,
		NodeID:         resp.(TransactionResponse).NodeID,
		Hash:           resp.(TransactionResponse).Hash,
		ValidateStatus: true,
		// set the tx in the response, in case of throttle error in the receipt
		// we can use this to re-submit the transaction
		Transaction: e,
	}, nil
}

func (tx *Transaction) FreezeWith(client *Client, e TransactionInterface) (TransactionInterface, error) {
	return tx.freezeWith(client, e)
}

func (tx *Transaction) freezeWith(client *Client, e TransactionInterface) (TransactionInterface, error) { //nolint
	if tx.IsFrozen() {
		return tx, nil
	}

	e.preFreezeWith(client)

	tx._InitFee(client)
	if err := tx._InitTransactionID(client); err != nil {
		return tx, err
	}

	err := e.validateNetworkOnIDs(client)
	if err != nil {
		return &Transaction{}, err
	}
	body := e.build()

	return tx, _TransactionFreezeWith(tx, client, body)
}

func (tx *Transaction) schedule(e TransactionInterface) (*ScheduleCreateTransaction, error) {
	tx._RequireNotFrozen()

	scheduled, err := e.buildScheduled()
	if err != nil {
		return nil, err
	}

	return NewScheduleCreateTransaction()._SetSchedulableTransactionBody(scheduled), nil
}
// Filename: transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/sdk"
	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
	protobuf "google.golang.org/protobuf/proto"
)

func TestIntegrationTransactionAddSignature(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(*receipt.AccountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	updateBytes, err := tx.ToBytes()
	require.NoError(t, err)

	sig1, err := newKey.SignTransaction(&tx.Transaction)
	require.NoError(t, err)

	tx2, err := TransactionFromBytes(updateBytes)
	require.NoError(t, err)

	if newTx, ok := tx2.(AccountDeleteTransaction); ok {
		resp, err = newTx.AddSignature(newKey.PublicKey(), sig1).Execute(env.Client)
		require.NoError(t, err)
	}

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTransactionSignTransaction(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(*receipt.AccountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	_, err = newKey.SignTransaction(&tx.Transaction)
	require.NoError(t, err)

	resp, err = tx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTransactionGetHash(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	tx, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx, err = tx.SignWithOperator(env.Client)
	require.NoError(t, err)

	hash, err := tx.GetTransactionHash()
	require.NoError(t, err)

	resp, err := tx.Execute(env.Client)
	require.NoError(t, err)

	record, err := resp.GetRecord(env.Client)
	require.NoError(t, err)

	assert.Equal(t, hash, record.TransactionHash)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func DisabledTestTransactionFromBytes(t *testing.T) { // nolint
	id := TransactionIDGenerate(AccountID{0, 0, 542348, nil, nil, nil})

	TransactionBody := services.TransactionBody{
		TransactionID: &services.TransactionID{
			AccountID: &services.AccountID{
				Account: &services.AccountID_AccountNum{AccountNum: 542348},
			},
			TransactionValidStart: &services.Timestamp{
				Seconds: id.ValidStart.Unix(),
				Nanos:   int32(id.ValidStart.Nanosecond()),
			},
		},
		NodeAccountID: &services.AccountID{
			Account: &services.AccountID_AccountNum{AccountNum: 3},
		},
		TransactionFee: 200_000_000,
		TransactionValidDuration: &services.Duration{
			Seconds: 120,
		},
		GenerateRecord: false,
		Memo:           "",
		Data: &services.TransactionBody_CryptoTransfer{
			CryptoTransfer: &services.CryptoTransferTransactionBody{
				Transfers: &services.TransferList{
					AccountAmounts: []*services.AccountAmount{
						{
							AccountID: &services.AccountID{
								Account: &services.AccountID_AccountNum{AccountNum: 47439},
							},
							Amount: 10,
						},
						{
							AccountID: &services.AccountID{
								Account: &services.AccountID_AccountNum{AccountNum: 542348},
							},
							Amount: -10,
						},
					},
				},
			},
		},
	}

	BodyBytes, err := protobuf.Marshal(&TransactionBody)
	require.NoError(t, err)

	key1, _ := PrivateKeyFromString("302e020100300506032b6570042204203e7fda6dde63c3cdb3cb5ecf5264324c5faad7c9847b6db093c088838b35a110")
	key2, _ := PrivateKeyFromString("302e020100300506032b65700422042032d3d5a32e9d06776976b39c09a31fbda4a4a0208223da761c26a2ae560c1755")
	key3, _ := PrivateKeyFromString("302e020100300506032b657004220420195a919056d1d698f632c228dbf248bbbc3955adf8a80347032076832b8299f9")
	key4, _ := PrivateKeyFromString("302e020100300506032b657004220420b9962f17f94ffce73a23649718a11638cac4b47095a7a6520e88c7563865be62")
	key5, _ := PrivateKeyFromString("302e020100300506032b657004220420fef68591819080cd9d48b0cbaa10f65f919752abb50ffb3e7411ac66ab22692e")

	publicKey1 := key1.PublicKey()
	publicKey2 := key2.PublicKey()
	publicKey3 := key3.PublicKey()
	publicKey4 := key4.PublicKey()
	publicKey5 := key5.PublicKey()

	signature1 := key1.Sign(BodyBytes)
	signature2 := key2.Sign(BodyBytes)
	signature3 := key3.Sign(BodyBytes)
	signature4 := key4.Sign(BodyBytes)
	signature5 := key5.Sign(BodyBytes)

	signed := services.SignedTransaction{
		BodyBytes: BodyBytes,
		SigMap: &services.SignatureMap{
			SigPair: []*services.SignaturePair{
				{
					PubKeyPrefix: key1.PublicKey().Bytes(),
					Signature: &services.SignaturePair_Ed25519{
						Ed25519: signature1,
					},
				},
				{
					PubKeyPrefix: key2.PublicKey().Bytes(),
					Signature: &services.SignaturePair_Ed25519{
						Ed25519: signature2,
					},
				},
				{
					PubKeyPrefix: key3.PublicKey().Bytes(),
					Signature: &services.SignaturePair_Ed25519{
						Ed25519: signature3,
					},
				},
				{
					PubKeyPrefix: key4.PublicKey().Bytes(),
					Signature: &services.SignaturePair_Ed25519{
						Ed25519: signature4,
					},
				},
				{
					PubKeyPrefix: key5.PublicKey().Bytes(),
					Signature: &services.SignaturePair_Ed25519{
						Ed25519: signature5,
					},
				},
			},
		},
	}

	bytes, err := protobuf.Marshal(&signed)
	require.NoError(t, err)

	bytes, err = protobuf.Marshal(&sdk.TransactionList{
		TransactionList: []*services.Transaction{{
			SignedTransactionBytes: bytes,
		}},
	})
	require.NoError(t, err)

	transaction, err := TransactionFromBytes(bytes)
	require.NoError(t, err)

	t.Parallel()
	env := NewIntegrationTestEnv(t)

	switch tx := transaction.(type) {
	case TransferTransaction:
		assert.Equal(t, tx.GetHbarTransfers()[AccountID{0, 0, 542348, nil, nil, nil}].AsTinybar(), int64(-10))
		assert.Equal(t, tx.GetHbarTransfers()[AccountID{0, 0, 47439, nil, nil, nil}].AsTinybar(), int64(10))

		signatures, err := tx.GetSignatures()
		require.NoError(t, err)
		assert.Contains(t, signatures[AccountID{0, 0, 3, nil, nil, nil}], &publicKey1)
		assert.Contains(t, signatures[AccountID{0, 0, 3, nil, nil, nil}], &publicKey2)
		assert.Contains(t, signatures[AccountID{0, 0, 3, nil, nil, nil}], &publicKey3)
		assert.Contains(t, signatures[AccountID{0, 0, 3, nil, nil, nil}], &publicKey4)
		assert.Contains(t, signatures[AccountID{0, 0, 3, nil, nil, nil}], &publicKey5)

		assert.Equal(t, len(tx.GetNodeAccountIDs()), 1)
		assert.True(t, tx.GetNodeAccountIDs()[0]._Equals(AccountID{0, 0, 3, nil, nil, nil}))

		resp, err := tx.Execute(env.Client)
		require.NoError(t, err)

		_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
		require.NoError(t, err)
	default:
		panic("Transaction was not a crypto transfer?")
	}
}

func TestIntegrationTransactionFailsWhenSigningWithoutFreezing(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	tx := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs)

	_, err = tx.Sign(newKey).Execute(env.Client)
	require.ErrorContains(t, err, "transaction is not frozen")

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: transaction_fee_schedule.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

type TransactionFeeSchedule struct {
	RequestType RequestType
	// Deprecated: use Fees
	FeeData *FeeData
	Fees    []*FeeData
}

func _TransactionFeeScheduleFromProtobuf(txFeeSchedule *services.TransactionFeeSchedule) (TransactionFeeSchedule, error) {
	if txFeeSchedule == nil {
		return TransactionFeeSchedule{}, errParameterNull
	}

	feeData := make([]*FeeData, 0)

	for _, d := range txFeeSchedule.GetFees() {
		temp, err := _FeeDataFromProtobuf(d)
		if err != nil {
			return TransactionFeeSchedule{}, err
		}
		feeData = append(feeData, &temp)
	}

	return TransactionFeeSchedule{
		RequestType: RequestType(txFeeSchedule.GetHederaFunctionality()),
		Fees:        feeData,
	}, nil
}

func (txFeeSchedule TransactionFeeSchedule) _ToProtobuf() *services.TransactionFeeSchedule {
	feeData := make([]*services.FeeData, 0)
	if txFeeSchedule.Fees != nil {
		for _, data := range txFeeSchedule.Fees {
			feeData = append(feeData, data._ToProtobuf())
		}
	}

	var singleFee *services.FeeData
	if txFeeSchedule.FeeData != nil {
		singleFee = txFeeSchedule.FeeData._ToProtobuf()
	}

	return &services.TransactionFeeSchedule{
		HederaFunctionality: services.HederaFunctionality(txFeeSchedule.RequestType),
		Fees:                feeData,
		FeeData:             singleFee,
	}
}

func (txFeeSchedule TransactionFeeSchedule) ToBytes() []byte {
	data, err := protobuf.Marshal(txFeeSchedule._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

func (txFeeSchedule TransactionFeeSchedule) String() string {
	str := ""
	for _, dat := range txFeeSchedule.Fees {
		str = str + dat.String() + ", "
	}

	if txFeeSchedule.FeeData != nil {
		return fmt.Sprintf("RequestType: %s, Feedata: %s", txFeeSchedule.RequestType.String(), txFeeSchedule.FeeData.String())
	}

	return fmt.Sprintf("RequestType: %s, Feedata: %s", txFeeSchedule.RequestType.String(), str)
}
// Filename: transaction_id.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"math/rand"
	"strconv"
	"strings"
	"time"

	"github.com/pkg/errors"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TransactionID is the id used to identify a Transaction on the Hedera _Network. It consists of an AccountID and a
// a valid start time.
type TransactionID struct {
	AccountID  *AccountID
	ValidStart *time.Time
	scheduled  bool
	Nonce      *int32
}

// NewTransactionID constructs a new Transaction id struct with the provided AccountID and the valid start time set
// to the current time - 10 seconds.
func TransactionIDGenerate(accountID AccountID) TransactionID {
	allowance := -(time.Duration(rand.Int63n(5*int64(time.Second))) + (8 * time.Second)) // nolint
	validStart := time.Now().UTC().Add(allowance)

	return TransactionID{&accountID, &validStart, false, nil}
}

// NewTransactionIDWithValidStart constructs a new Transaction id struct with the provided AccountID and the valid start
// time set to a provided time.
func NewTransactionIDWithValidStart(accountID AccountID, validStart time.Time) TransactionID {
	return TransactionID{&accountID, &validStart, false, nil}
}

// GetReceipt queries the _Network for a receipt corresponding to the TransactionID's transaction. If the status of the
// receipt is exceptional an ErrHederaReceiptStatus will be returned alongside the receipt, otherwise only the receipt
// will be returned.
func (id TransactionID) GetReceipt(client *Client) (TransactionReceipt, error) {
	return NewTransactionReceiptQuery().
		SetTransactionID(id).
		Execute(client)
}

// GetRecord queries the _Network for a record corresponding to the TransactionID's transaction. If the status of the
// record's receipt is exceptional an ErrHederaRecordStatus will be returned alongside the record, otherwise, only the
// record will be returned. If consensus has not been reached, this function will return a HederaReceiptError with a
// status of StatusBusy.
func (id TransactionID) GetRecord(client *Client) (TransactionRecord, error) {
	_, err := NewTransactionReceiptQuery().
		SetTransactionID(id).
		Execute(client)

	if err != nil {
		return TransactionRecord{}, err
	}

	return NewTransactionRecordQuery().
		SetTransactionID(id).
		Execute(client)
}

// String returns a string representation of the TransactionID in `AccountID@ValidStartSeconds.ValidStartNanos?scheduled_bool/nonce` format
func (id TransactionID) String() string {
	var pb *services.Timestamp
	var returnString string
	if id.AccountID != nil && id.ValidStart != nil {
		pb = _TimeToProtobuf(*id.ValidStart)
		// Use fmt.Sprintf to format the string with leading zeros
		returnString = id.AccountID.String() + "@" + fmt.Sprintf("%d.%09d", pb.Seconds, pb.Nanos)
	}

	if id.scheduled {
		returnString += "?scheduled"
	}

	if id.Nonce != nil {
		returnString += "/" + fmt.Sprint(*id.Nonce)
	}

	return returnString
}

// TransactionIDFromString constructs a TransactionID from a string representation
func TransactionIdFromString(data string) (TransactionID, error) { // nolint
	parts := strings.SplitN(data, "/", 2)

	var nonce *int32
	if len(parts) == 2 {
		temp, _ := strconv.ParseInt(parts[1], 10, 32)
		temp32 := int32(temp)
		nonce = &temp32
	}
	parts = strings.SplitN(parts[0], "?", 2)

	var accountID *AccountID
	var validStart *time.Time
	scheduled := len(parts) == 2 && strings.Compare(parts[1], "scheduled") == 0

	parts = strings.SplitN(parts[0], "@", 2)

	if len(parts) != 2 {
		return TransactionID{}, errors.New("expecting [{account}@{seconds}.{nanos}|{nonce}][?scheduled]")
	}

	temp, err := AccountIDFromString(parts[0])
	accountID = &temp
	if err != nil {
		return TransactionID{}, err
	}

	validStartParts := strings.SplitN(parts[1], ".", 2)

	if len(validStartParts) != 2 {
		return TransactionID{}, errors.New("expecting {account}@{seconds}.{nanos}")
	}

	sec, err := strconv.ParseInt(validStartParts[0], 10, 64)
	if err != nil {
		return TransactionID{}, err
	}

	nano, err := strconv.ParseInt(validStartParts[1], 10, 64)
	if err != nil {
		return TransactionID{}, err
	}

	temp2 := time.Unix(sec, nano)
	validStart = &temp2

	return TransactionID{
		AccountID:  accountID,
		ValidStart: validStart,
		scheduled:  scheduled,
		Nonce:      nonce,
	}, nil
}

func (id TransactionID) _ToProtobuf() *services.TransactionID {
	var validStart *services.Timestamp
	if id.ValidStart != nil {
		validStart = _TimeToProtobuf(*id.ValidStart)
	}

	var accountID *services.AccountID
	if id.AccountID != nil {
		accountID = id.AccountID._ToProtobuf()
	}

	var nonce int32
	if id.Nonce != nil {
		nonce = *id.Nonce
	}

	return &services.TransactionID{
		TransactionValidStart: validStart,
		AccountID:             accountID,
		Scheduled:             id.scheduled,
		Nonce:                 nonce,
	}
}

func _TransactionIDFromProtobuf(pb *services.TransactionID) TransactionID {
	if pb == nil {
		return TransactionID{}
	}
	var validStart time.Time
	if pb.TransactionValidStart != nil {
		validStart = _TimeFromProtobuf(pb.TransactionValidStart)
	}

	var accountID AccountID
	if pb.AccountID != nil {
		accountID = *_AccountIDFromProtobuf(pb.AccountID)
	}

	var nonce *int32
	if pb.Nonce != 0 {
		nonce = &pb.Nonce
	}

	return TransactionID{&accountID, &validStart, pb.Scheduled, nonce}
}

// ToBytes returns a byte array representation of the TransactionID
func (id TransactionID) ToBytes() []byte {
	data, err := protobuf.Marshal(id._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TransactionIDFromBytes constructs a TransactionID from a byte array
func TransactionIDFromBytes(data []byte) (TransactionID, error) {
	if data == nil {
		return TransactionID{}, errByteArrayNull
	}
	pb := services.TransactionID{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TransactionID{}, err
	}

	return _TransactionIDFromProtobuf(&pb), nil
}

// SetScheduled sets the scheduled flag on the TransactionID
func (id TransactionID) SetScheduled(scheduled bool) TransactionID {
	id.scheduled = scheduled
	return id
}

// GetScheduled returns the scheduled flag on the TransactionID
func (id TransactionID) GetScheduled() bool {
	return id.scheduled
}

// SetNonce sets the nonce on the TransactionID
func (id TransactionID) SetNonce(nonce int32) TransactionID {
	id.Nonce = &nonce
	return id
}

// GetNonce returns the nonce on the TransactionID
func (id TransactionID) GetNonce() int32 {
	if id.Nonce != nil {
		return *id.Nonce
	}
	return 0
}
// Filename: transaction_id_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"sync"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestUnitTransactionID(t *testing.T) {
	t.Parallel()

	txID := TransactionIDGenerate(AccountID{0, 0, 3, nil, nil, nil})
	txID = txID.SetScheduled(true)
}

func TestUnitTransactionIDFromString(t *testing.T) {
	t.Parallel()

	txID, err := TransactionIdFromString("0.0.3@1614997926.774912965?scheduled")
	require.NoError(t, err)
	require.Equal(t, txID.AccountID.String(), "0.0.3")
	require.True(t, txID.scheduled)
}

func TestUnitTransactionIDFromStringNonce(t *testing.T) {
	t.Parallel()

	txID, err := TransactionIdFromString("0.0.3@1614997926.774912965?scheduled/4")
	require.NoError(t, err)
	require.Equal(t, *txID.Nonce, int32(4))
	require.Equal(t, txID.AccountID.String(), "0.0.3")
}

func TestUnitTransactionIDFromStringLeadingZero(t *testing.T) {
	t.Parallel()

	txID, err := TransactionIdFromString("0.0.3@1614997926.074912965")
	require.NoError(t, err)
	require.Equal(t, txID.String(), "0.0.3@1614997926.074912965")
}

func TestUnitTransactionIDFromStringTrimmedZeroes(t *testing.T) {
	t.Parallel()

	txID, err := TransactionIdFromString("0.0.3@1614997926.5")
	require.NoError(t, err)
	require.Equal(t, txID.String(), "0.0.3@1614997926.000000005")
}

func TestUnitConcurrentTransactionIDsAreUnique(t *testing.T) {
	const numOfTxns = 100000

	account := AccountID{Account: 1}

	// Channel to collect generated transaction IDs
	idsCh := make(chan TransactionID, numOfTxns)

	var wg sync.WaitGroup
	for i := 0; i < numOfTxns; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			idsCh <- TransactionIDGenerate(account)
		}()
	}

	// Close idsCh after all goroutines complete
	go func() {
		wg.Wait()
		close(idsCh)
	}()

	seen := make(map[TransactionID]bool)
	for id := range idsCh {
		require.False(t, seen[id], "Transaction ID %v is not unique", id)
		seen[id] = true
	}

	require.Equal(t, len(seen), numOfTxns)
}
// Filename: transaction_receipt.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"reflect"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"
)

// The consensus result for a transaction, which might not be currently known, or may succeed or fail.
type TransactionReceipt struct {
	Status                  Status
	ExchangeRate            *ExchangeRate
	TopicID                 *TopicID
	FileID                  *FileID
	ContractID              *ContractID
	AccountID               *AccountID
	TokenID                 *TokenID
	TopicSequenceNumber     uint64
	TopicRunningHash        []byte
	TopicRunningHashVersion uint64
	TotalSupply             uint64
	ScheduleID              *ScheduleID
	ScheduledTransactionID  *TransactionID
	SerialNumbers           []int64
	NodeID                  uint64
	Duplicates              []TransactionReceipt
	Children                []TransactionReceipt
	TransactionID           *TransactionID
}

func (receipt *TransactionReceipt) _ToMap() map[string]interface{} {
	m := map[string]interface{}{
		"status":                  receipt.Status.String(),
		"topicSequenceNumber":     receipt.TopicSequenceNumber,
		"topicRunningHash":        hex.EncodeToString(receipt.TopicRunningHash),
		"topicRunningHashVersion": receipt.TopicRunningHashVersion,
		"totalSupply":             receipt.TotalSupply,
		"serialNumbers":           receipt.SerialNumbers,
		"nodeId":                  receipt.NodeID,
	}

	// The real ExchangeRate struct has cents and ExpirationTime fields as private, so they can't be marshalled directly
	type ExchangeRateJSON struct {
		Hbars          int32  `json:"hbars"`
		Cents          int32  `json:"cents"`
		ExpirationTime string `json:"expirationTime"`
	}

	if receipt.ExchangeRate != nil {
		const layout = "2006-01-02T15:04:05.000Z"
		expiration := time.Unix(receipt.ExchangeRate.expirationTime.Seconds, 0)
		expirationStr := expiration.UTC().Format(layout)

		m["exchangeRate"] = ExchangeRateJSON{
			Hbars:          receipt.ExchangeRate.Hbars,
			Cents:          receipt.ExchangeRate.cents,
			ExpirationTime: expirationStr,
		}
	}

	// Handling fields with possible nil values
	fields := map[string]interface{}{
		"topicId":                receipt.TopicID,
		"fileId":                 receipt.FileID,
		"contractId":             receipt.ContractID,
		"accountId":              receipt.AccountID,
		"tokenId":                receipt.TokenID,
		"scheduleId":             receipt.ScheduleID,
		"scheduledTransactionId": receipt.ScheduledTransactionID,
	}
	for key, field := range fields {
		m[key] = nil
		if !reflect.ValueOf(field).IsNil() {
			m[key] = fmt.Sprintf("%v", field)
		}
	}

	m["children"] = receipt.Children
	m["duplicates"] = receipt.Duplicates
	return m
}

// MarshalJSON returns the JSON representation of the TransactionReceipt.
// This should yield the same result in all SDK's.
func (receipt TransactionReceipt) MarshalJSON() ([]byte, error) {
	return json.Marshal(receipt._ToMap())
}

func _TransactionReceiptFromProtobuf(protoResponse *services.TransactionGetReceiptResponse, transactionID *TransactionID) TransactionReceipt {
	if protoResponse == nil {
		return TransactionReceipt{}
	}
	protoReceipt := protoResponse.GetReceipt()
	if protoReceipt == nil {
		return TransactionReceipt{}
	}
	var accountID *AccountID
	if protoReceipt.AccountID != nil {
		accountID = _AccountIDFromProtobuf(protoReceipt.AccountID)
	}

	var contractID *ContractID
	if protoReceipt.ContractID != nil {
		contractID = _ContractIDFromProtobuf(protoReceipt.ContractID)
	}

	var fileID *FileID
	if protoReceipt.FileID != nil {
		fileID = _FileIDFromProtobuf(protoReceipt.FileID)
	}

	var topicID *TopicID
	if protoReceipt.TopicID != nil {
		topicID = _TopicIDFromProtobuf(protoReceipt.TopicID)
	}

	var rate *ExchangeRate
	if protoReceipt.ExchangeRate != nil {
		exchangeRateValue := _ExchangeRateFromProtobuf(protoReceipt.ExchangeRate.GetCurrentRate())
		rate = &exchangeRateValue
	}

	var topicSequenceHash []byte
	if protoReceipt.TopicRunningHash != nil {
		topicHash := protoReceipt.TopicRunningHash
		topicSequenceHash = topicHash
	}

	var tokenID *TokenID
	if protoReceipt.TokenID != nil {
		tokenID = _TokenIDFromProtobuf(protoReceipt.TokenID)
	}

	var scheduleID *ScheduleID
	if protoReceipt.ScheduleID != nil {
		scheduleID = _ScheduleIDFromProtobuf(protoReceipt.ScheduleID)
	}

	var scheduledTransactionID *TransactionID
	if protoReceipt.ScheduledTransactionID != nil {
		scheduledTransactionIDValue := _TransactionIDFromProtobuf(protoReceipt.ScheduledTransactionID)
		scheduledTransactionID = &scheduledTransactionIDValue
	}

	childReceipts := make([]TransactionReceipt, 0)
	if len(protoResponse.ChildTransactionReceipts) > 0 {
		for _, r := range protoResponse.ChildTransactionReceipts {
			childReceipts = append(childReceipts, _TransactionReceiptFromProtobuf(&services.TransactionGetReceiptResponse{Receipt: r}, transactionID))
		}
	}

	duplicateReceipts := make([]TransactionReceipt, 0)
	if len(protoResponse.DuplicateTransactionReceipts) > 0 {
		for _, r := range protoResponse.DuplicateTransactionReceipts {
			duplicateReceipts = append(duplicateReceipts, _TransactionReceiptFromProtobuf(&services.TransactionGetReceiptResponse{Receipt: r}, transactionID))
		}
	}

	return TransactionReceipt{
		Status:                  Status(protoReceipt.Status),
		ExchangeRate:            rate,
		TopicID:                 topicID,
		FileID:                  fileID,
		ContractID:              contractID,
		AccountID:               accountID,
		TopicSequenceNumber:     protoReceipt.TopicSequenceNumber,
		TopicRunningHash:        topicSequenceHash,
		TopicRunningHashVersion: protoReceipt.TopicRunningHashVersion,
		TokenID:                 tokenID,
		TotalSupply:             protoReceipt.NewTotalSupply,
		ScheduleID:              scheduleID,
		ScheduledTransactionID:  scheduledTransactionID,
		SerialNumbers:           protoReceipt.SerialNumbers,
		NodeID:                  protoReceipt.NodeId,
		Children:                childReceipts,
		Duplicates:              duplicateReceipts,
		TransactionID:           transactionID,
	}
}

func (receipt TransactionReceipt) _ToProtobuf() *services.TransactionGetReceiptResponse {
	receiptFinal := services.TransactionReceipt{
		Status:                  services.ResponseCodeEnum(receipt.Status),
		TopicSequenceNumber:     receipt.TopicSequenceNumber,
		TopicRunningHash:        receipt.TopicRunningHash,
		TopicRunningHashVersion: receipt.TopicRunningHashVersion,
		NewTotalSupply:          receipt.TotalSupply,
		SerialNumbers:           receipt.SerialNumbers,
		NodeId:                  receipt.NodeID,
	}

	if receipt.ExchangeRate != nil {
		receiptFinal.ExchangeRate = &services.ExchangeRateSet{
			CurrentRate: receipt.ExchangeRate._ToProtobuf(),
			NextRate:    receipt.ExchangeRate._ToProtobuf(),
		}
	}

	if receipt.TopicID != nil {
		receiptFinal.TopicID = receipt.TopicID._ToProtobuf()
	}

	if receipt.FileID != nil {
		receiptFinal.FileID = receipt.FileID._ToProtobuf()
	}

	if receipt.ContractID != nil {
		receiptFinal.ContractID = receipt.ContractID._ToProtobuf()
	}

	if receipt.AccountID != nil {
		receiptFinal.AccountID = receipt.AccountID._ToProtobuf()
	}

	if receipt.TokenID != nil {
		receiptFinal.TokenID = receipt.TokenID._ToProtobuf()
	}

	if receipt.ScheduleID != nil {
		receiptFinal.ScheduleID = receipt.ScheduleID._ToProtobuf()
	}

	if receipt.ScheduledTransactionID != nil {
		receiptFinal.ScheduledTransactionID = receipt.ScheduledTransactionID._ToProtobuf()
	}

	childReceipts := make([]*services.TransactionReceipt, 0)
	if len(receipt.Children) > 0 {
		for _, r := range receipt.Children {
			childReceipts = append(childReceipts, r._ToProtobuf().GetReceipt())
		}
	}

	duplicateReceipts := make([]*services.TransactionReceipt, 0)
	if len(receipt.Duplicates) > 0 {
		for _, r := range receipt.Duplicates {
			duplicateReceipts = append(duplicateReceipts, r._ToProtobuf().GetReceipt())
		}
	}

	return &services.TransactionGetReceiptResponse{
		Receipt:                      &receiptFinal,
		ChildTransactionReceipts:     childReceipts,
		DuplicateTransactionReceipts: duplicateReceipts,
	}
}

// ValidateStatus validates the status of the receipt
func (receipt TransactionReceipt) ValidateStatus(shouldValidate bool) error {
	if shouldValidate && receipt.Status != StatusSuccess && receipt.Status != StatusFeeScheduleFilePartUploaded {
		if receipt.TransactionID != nil {
			return _NewErrHederaReceiptStatus(*receipt.TransactionID, receipt.Status)
		}
		return _NewErrHederaReceiptStatus(TransactionID{}, receipt.Status)
	}

	return nil
}

// ToBytes returns the byte representation of the receipt
func (receipt TransactionReceipt) ToBytes() []byte {
	data, err := protobuf.Marshal(receipt._ToProtobuf())
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TransactionReceiptFromBytes returns the receipt from the byte representation
func TransactionReceiptFromBytes(data []byte) (TransactionReceipt, error) {
	if data == nil {
		return TransactionReceipt{}, errByteArrayNull
	}
	pb := services.TransactionGetReceiptResponse{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TransactionReceipt{}, err
	}

	return _TransactionReceiptFromProtobuf(&pb, nil), nil
}
// Filename: transaction_receipt_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TransactionReceiptQuery
// Get the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus,
// then information about whether it succeeded or failed will be available until the end of the
// receipt period.  Before and after the receipt period, and for a transaction that was never
// submitted, the receipt is unknown.  This query is free (the payment field is left empty). No
// State proof is available for this response
type TransactionReceiptQuery struct {
	Query
	transactionID *TransactionID
	childReceipts *bool
	duplicates    *bool
}

// NewTransactionReceiptQuery creates TransactionReceiptQuery which
// gets the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus,
// then information about whether it succeeded or failed will be available until the end of the
// receipt period.  Before and after the receipt period, and for a transaction that was never
// submitted, the receipt is unknown.  This query is free (the payment field is left empty). No
// State proof is available for this response
func NewTransactionReceiptQuery() *TransactionReceiptQuery {
	header := services.QueryHeader{}
	return &TransactionReceiptQuery{
		Query: _NewQuery(false, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *TransactionReceiptQuery) SetGrpcDeadline(deadline *time.Duration) *TransactionReceiptQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetIncludeChildren Sets whether the response should include the receipts of any child transactions spawned by the
// top-level transaction with the given transactionID.
func (q *TransactionReceiptQuery) SetIncludeChildren(includeChildReceipts bool) *TransactionReceiptQuery {
	q.childReceipts = &includeChildReceipts
	return q
}

// GetIncludeChildren returns whether the response should include the receipts of any child transactions spawned by the
// top-level transaction with the given transactionID.
func (q *TransactionReceiptQuery) GetIncludeChildren() bool {
	if q.childReceipts != nil {
		return *q.childReceipts
	}

	return false
}

// SetIncludeDuplicates Sets whether receipts of processing duplicate transactions should be returned along with the
// receipt of processing the first consensus transaction with the given id whose status was
// neither INVALID_NODE_ACCOUNT nor INVALID_PAYER_SIGNATURE; or, if no
// such receipt exists, the receipt of processing the first transaction to reach consensus with
// the given transaction id.
func (q *TransactionReceiptQuery) SetIncludeDuplicates(includeDuplicates bool) *TransactionReceiptQuery {
	q.duplicates = &includeDuplicates
	return q
}

// GetIncludeDuplicates returns whether receipts of processing duplicate transactions should be returned along with the
// receipt of processing the first consensus transaction with the given id
func (q *TransactionReceiptQuery) GetIncludeDuplicates() bool {
	if q.duplicates != nil {
		return *q.duplicates
	}

	return false
}

func (q *TransactionReceiptQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *TransactionReceiptQuery) Execute(client *Client) (TransactionReceipt, error) {
	resp, err := q.Query.execute(client, q)

	if err, ok := err.(ErrHederaPreCheckStatus); ok {
		if resp.GetTransactionGetReceipt() != nil {
			return _TransactionReceiptFromProtobuf(resp.GetTransactionGetReceipt(), q.transactionID), err
		}
		// Manually add the receipt status, because an empty receipt has no status and no status defaults to 0, which means success
		return TransactionReceipt{Status: err.Status}, err
	}

	return _TransactionReceiptFromProtobuf(resp.GetTransactionGetReceipt(), q.transactionID), nil
}

// SetTransactionID sets the TransactionID for which the receipt is being requested.
func (q *TransactionReceiptQuery) SetTransactionID(transactionID TransactionID) *TransactionReceiptQuery {
	q.transactionID = &transactionID
	return q
}

// GetTransactionID returns the TransactionID for which the receipt is being requested.
func (q *TransactionReceiptQuery) GetTransactionID() TransactionID {
	if q.transactionID == nil {
		return TransactionID{}
	}

	return *q.transactionID
}

// SetNodeAccountIDs sets the _Node AccountID for this TransactionReceiptQuery.
func (q *TransactionReceiptQuery) SetNodeAccountIDs(accountID []AccountID) *TransactionReceiptQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetQueryPayment sets the Hbar payment to pay the _Node a fee for handling this query
func (q *TransactionReceiptQuery) SetQueryPayment(queryPayment Hbar) *TransactionReceiptQuery {
	q.Query.SetQueryPayment(queryPayment)
	return q
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *TransactionReceiptQuery) SetMaxQueryPayment(queryMaxPayment Hbar) *TransactionReceiptQuery {
	q.Query.SetMaxQueryPayment(queryMaxPayment)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *TransactionReceiptQuery) SetMaxRetry(count int) *TransactionReceiptQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *TransactionReceiptQuery) SetMaxBackoff(max time.Duration) *TransactionReceiptQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *TransactionReceiptQuery) SetMinBackoff(min time.Duration) *TransactionReceiptQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *TransactionReceiptQuery) SetPaymentTransactionID(transactionID TransactionID) *TransactionReceiptQuery {
	q.Query.SetPaymentTransactionID(transactionID)
	return q
}

func (q *TransactionReceiptQuery) SetLogLevel(level LogLevel) *TransactionReceiptQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *TransactionReceiptQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetCrypto().GetTransactionReceipts,
	}
}

func (q *TransactionReceiptQuery) mapStatusError(_ Executable, response interface{}) error {
	status := Status(response.(*services.Response).GetTransactionGetReceipt().GetHeader().GetNodeTransactionPrecheckCode())
	switch status {
	case StatusPlatformTransactionNotCreated, StatusBusy, StatusUnknown, StatusOk:
		break
	default:
		return ErrHederaPreCheckStatus{
			Status: status,
		}
	}

	return ErrHederaPreCheckStatus{
		Status: Status(response.(*services.Response).GetTransactionGetReceipt().GetReceipt().GetStatus()),
	}
}

func (q *TransactionReceiptQuery) getName() string {
	return "TransactionReceiptQuery"
}

func (q *TransactionReceiptQuery) buildQuery() *services.Query {
	body := &services.TransactionGetReceiptQuery{
		Header: q.pbHeader,
	}

	if q.transactionID.AccountID != nil {
		body.TransactionID = q.transactionID._ToProtobuf()
	}

	if q.duplicates != nil {
		body.IncludeDuplicates = *q.duplicates
	}

	if q.childReceipts != nil {
		body.IncludeChildReceipts = q.GetIncludeChildren()
	}

	return &services.Query{
		Query: &services.Query_TransactionGetReceipt{
			TransactionGetReceipt: body,
		},
	}
}

func (q *TransactionReceiptQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if err := q.transactionID.AccountID.ValidateChecksum(client); err != nil {
		return err
	}

	return nil
}

func (q *TransactionReceiptQuery) shouldRetry(_ Executable, response interface{}) _ExecutionState {
	status := Status(response.(*services.Response).GetTransactionGetReceipt().GetHeader().GetNodeTransactionPrecheckCode())

	switch status {
	case StatusPlatformTransactionNotCreated, StatusBusy, StatusUnknown, StatusReceiptNotFound, StatusRecordNotFound, StatusPlatformNotActive:
		return executionStateRetry
	case StatusOk:
		break
	default:
		return executionStateError
	}

	status = Status(response.(*services.Response).GetTransactionGetReceipt().GetReceipt().GetStatus())

	switch status {
	case StatusBusy, StatusUnknown, StatusOk, StatusReceiptNotFound, StatusRecordNotFound, StatusPlatformNotActive:
		return executionStateRetry
	default:
		return executionStateFinished
	}
}

func (q *TransactionReceiptQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetTransactionGetReceipt()
}
// Filename: transaction_receipt_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTransactionReceiptQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tx, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx, err = tx.SignWithOperator(env.Client)
	require.NoError(t, err)

	resp, err := tx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	_, err = resp.GetRecord(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

// what is this
func DisabledTestIntegrationTransactionReceiptQueryInvalidTransactionID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	key, err := GeneratePrivateKey()
	require.NoError(t, err)

	resp, err := NewAccountCreateTransaction().
		SetKey(key).
		SetInitialBalance(NewHbar(2)).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tx := NewTransferTransaction().
		AddHbarTransfer(accountID, NewHbar(1).Negated()).
		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(1))

	scheduleTx, err := tx.Schedule()
	require.NoError(t, err)

	scheduleTx = scheduleTx.
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetPayerAccountID(env.Client.GetOperatorAccountID()).
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetTransactionID(TransactionIDGenerate(env.Client.GetOperatorAccountID()))

	resp, err = scheduleTx.Execute(env.Client)
	require.NoError(t, err)

	receipt, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	scheduleID := *receipt.ScheduleID

	scheduleSignTx, err := NewScheduleSignTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetScheduleID(scheduleID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = scheduleSignTx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	assert.Error(t, err)

	switch receiptErr := err.(type) {
	case ErrHederaReceiptStatus:
		assert.NotNil(t, receiptErr.Receipt.ExchangeRate)
	default:
		panic("err was not a `ErrHederaReceiptStatus")
	}

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationFileUpdateTransactionHandleFeeScheduleUpload(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	defer CloseIntegrationTestEnv(env, nil)

	spenderKey, err := PrivateKeyFromString("302e020100300506032b65700422042091132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137")
	require.NoError(t, err)

	env.Client.SetOperator(AccountID{Realm: 0, Shard: 0, Account: 2}, spenderKey)

	resp, err := NewFileUpdateTransaction().
		SetFileID(FileID{Shard: 0, Realm: 0, File: 111}).
		SetContents([]byte("[e2e::FileUpdateTransaction]")).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	assert.Equal(t, StatusFeeScheduleFilePartUploaded, receipt.Status)
}
// Filename: transaction_receipt_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"encoding/json"
	"testing"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTransactionReceiptQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	transactionID := TransactionIDGenerate(accountID)
	require.NoError(t, err)

	receiptQuery := NewTransactionReceiptQuery().
		SetTransactionID(transactionID)

	err = receiptQuery.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTransactionReceiptQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	transactionID := TransactionIDGenerate(accountID)
	require.NoError(t, err)

	receiptQuery := NewTransactionReceiptQuery().
		SetTransactionID(transactionID)

	err = receiptQuery.validateNetworkOnIDs(client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTransactionReceiptQueryGet(t *testing.T) {
	t.Parallel()

	txID := TransactionIDGenerate(AccountID{Account: 7})

	balance := NewTransactionReceiptQuery().
		SetTransactionID(txID).
		SetIncludeDuplicates(true).
		SetIncludeChildren(true).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(1)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}})

	balance.GetTransactionID()
	balance.GetIncludeChildren()
	balance.GetIncludeDuplicates()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitTransactionReceiptQueryNothingSet(t *testing.T) {
	t.Parallel()

	balance := NewTransactionReceiptQuery()

	balance.GetTransactionID()
	balance.GetIncludeChildren()
	balance.GetIncludeDuplicates()
	balance.GetNodeAccountIDs()
	balance.GetMinBackoff()
	balance.GetMaxBackoff()
	balance.GetMaxRetryCount()
	balance.GetPaymentTransactionID()
	balance.GetQueryPayment()
	balance.GetMaxQueryPayment()
}

func TestUnitTransactionPlatformNotActiveGracefulHandling(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_PLATFORM_NOT_ACTIVE,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
					},
				},
			},
		},
	}}
	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	tx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(1)).
		Execute(client)
	client.SetMaxAttempts(2)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetReceipt(client)
	require.NoError(t, err)
}

func TestUnitTransactionReceiptNotFound(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_RECEIPT_NOT_FOUND,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_RECEIPT_NOT_FOUND,
					},
				},
			},
		},
	}}
	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	tx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(1)).
		Execute(client)
	client.SetMaxAttempts(2)
	require.NoError(t, err)
	receipt, err := tx.SetValidateStatus(true).GetReceipt(client)
	require.Error(t, err)
	require.Equal(t, "exceptional precheck status RECEIPT_NOT_FOUND", err.Error())
	require.Equal(t, StatusReceiptNotFound, receipt.Status)
}

func TestUnitTransactionReceiptUknown(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_UNKNOWN,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
					},
				},
			},
		},
	}}
	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	tx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(1)).
		Execute(client)
	client.SetMaxAttempts(2)
	require.NoError(t, err)
	receipt, err := tx.SetValidateStatus(true).GetReceipt(client)
	require.NoError(t, err)
	require.Equal(t, StatusSuccess, receipt.Status)
}

func TestUnitTransactionReceiptToJson(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
						AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
							AccountNum: 123,
						}},
						ContractID: &services.ContractID{Contract: &services.ContractID_ContractNum{
							ContractNum: 456,
						}},
						FileID:        &services.FileID{FileNum: 789},
						TokenID:       &services.TokenID{TokenNum: 987},
						SerialNumbers: []int64{1, 2, 3},
						TopicID:       &services.TopicID{TopicNum: 654},
						ScheduleID:    &services.ScheduleID{ScheduleNum: 321},
						NodeId:        1,
						ScheduledTransactionID: &services.TransactionID{
							AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
								AccountNum: 123,
							}},
							TransactionValidStart: &services.Timestamp{
								Seconds: 1694689200,
							},
						},
						TopicSequenceNumber: 10,
						TopicRunningHash:    []byte{10},
						ExchangeRate: &services.ExchangeRateSet{
							CurrentRate: &services.ExchangeRate{
								HbarEquiv: 30000,
								CentEquiv: 154271,
								ExpirationTime: &services.TimestampSeconds{
									Seconds: 1694689200,
								},
							},
						},
					},
					ChildTransactionReceipts: []*services.TransactionReceipt{
						{
							Status: services.ResponseCodeEnum_SUCCESS,
							AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
								AccountNum: 123,
							}},
							ContractID: &services.ContractID{Contract: &services.ContractID_ContractNum{
								ContractNum: 456,
							}},
							FileID:        &services.FileID{FileNum: 789},
							TokenID:       &services.TokenID{TokenNum: 987},
							SerialNumbers: []int64{1, 2, 3},
							TopicID:       &services.TopicID{TopicNum: 654},
							ScheduleID:    &services.ScheduleID{ScheduleNum: 321},
							ScheduledTransactionID: &services.TransactionID{
								AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
									AccountNum: 123,
								}},
								TransactionValidStart: &services.Timestamp{
									Seconds: 1694689200,
								},
							},
							TopicSequenceNumber: 10,
							TopicRunningHash:    []byte{10},
							ExchangeRate: &services.ExchangeRateSet{
								CurrentRate: &services.ExchangeRate{
									HbarEquiv: 30000,
									CentEquiv: 154271,
									ExpirationTime: &services.TimestampSeconds{
										Seconds: 1694689200,
									},
								},
							},
						},
					},
					DuplicateTransactionReceipts: []*services.TransactionReceipt{
						{
							Status: services.ResponseCodeEnum_SUCCESS,
							AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
								AccountNum: 123,
							}},
							ContractID: &services.ContractID{Contract: &services.ContractID_ContractNum{
								ContractNum: 456,
							}},
							FileID:        &services.FileID{FileNum: 789},
							TokenID:       &services.TokenID{TokenNum: 987},
							SerialNumbers: []int64{1, 2, 3},
							TopicID:       &services.TopicID{TopicNum: 654},
							ScheduleID:    &services.ScheduleID{ScheduleNum: 321},
							ScheduledTransactionID: &services.TransactionID{
								AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{
									AccountNum: 123,
								}},
								TransactionValidStart: &services.Timestamp{
									Seconds: 1694689200,
								},
							},
							TopicSequenceNumber: 10,
							TopicRunningHash:    []byte{10},
							ExchangeRate: &services.ExchangeRateSet{
								CurrentRate: &services.ExchangeRate{
									HbarEquiv: 30000,
									CentEquiv: 154271,
									ExpirationTime: &services.TimestampSeconds{
										Seconds: 1694689200,
									},
								},
							},
						},
					},
				},
			},
		},
	}}
	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	tx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(1)).
		Execute(client)
	require.NoError(t, err)
	receipt, err := tx.SetValidateStatus(true).GetReceipt(client)
	require.NoError(t, err)
	jsonBytes, err := receipt.MarshalJSON()
	require.NoError(t, err)
	expected := `{"accountId":"0.0.123","children":[{"accountId":"0.0.123","children":[],"contractId":"0.0.456","duplicates":[],"exchangeRate":
	{"hbars":30000,"cents":154271,"expirationTime":"2023-09-14T11:00:00.000Z"},"fileId":"0.0.789","nodeId":0,"scheduleId":"0.0.321",
	"scheduledTransactionId":"0.0.123@1694689200.000000000","serialNumbers":[1,2,3],"status":"SUCCESS","tokenId":"0.0.987","topicId":"0.0.654",
	"topicRunningHash":"0a","topicRunningHashVersion":0,"topicSequenceNumber":10,"totalSupply":0}],"contractId":"0.0.456",
	"duplicates":[{"accountId":"0.0.123","children":[],"contractId":"0.0.456","duplicates":[],"exchangeRate":{"hbars":30000,"cents":154271,
	"expirationTime":"2023-09-14T11:00:00.000Z"},"fileId":"0.0.789","nodeId":0,"scheduleId":"0.0.321","scheduledTransactionId":"0.0.123@1694689200.000000000",
	"serialNumbers":[1,2,3],"status":"SUCCESS","tokenId":"0.0.987","topicId":"0.0.654","topicRunningHash":"0a","topicRunningHashVersion":0,
	"topicSequenceNumber":10,"totalSupply":0}],"exchangeRate":{"hbars":30000,"cents":154271,"expirationTime":"2023-09-14T11:00:00.000Z"},
	"fileId":"0.0.789","nodeId":1,"scheduleId":"0.0.321","scheduledTransactionId":"0.0.123@1694689200.000000000","serialNumbers":[1,2,3],"status":"SUCCESS",
	"tokenId":"0.0.987","topicId":"0.0.654","topicRunningHash":"0a","topicRunningHashVersion":0,"topicSequenceNumber":10,"totalSupply":0}`

	assert.JSONEqf(t, expected, string(jsonBytes), "json should be equal")

}

func TestUnitTransactionResponseToJson(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
					},
				},
			},
		},
	}}
	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	tx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(1)).
		Execute(client)
	require.NoError(t, err)
	jsonBytes, err := tx.MarshalJSON()
	require.NoError(t, err)
	obj := make(map[string]interface{})
	obj["nodeID"] = tx.NodeID.String()
	obj["hash"] = hex.EncodeToString(tx.Hash)
	obj["transactionID"] = tx.TransactionID.String()
	expectedJSON, err := json.Marshal(obj)
	require.NoError(t, err)
	assert.Equal(t, expectedJSON, jsonBytes)
}
// Filename: transaction_record.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"fmt"
	"sort"
	"time"

	jsoniter "github.com/json-iterator/go"
	"google.golang.org/protobuf/types/known/wrapperspb"

	protobuf "google.golang.org/protobuf/proto"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// The complete record for a transaction on Hedera that has reached consensus.
// This is not-free to request and is available for 1 hour after a transaction reaches consensus.
type TransactionRecord struct {
	Receipt                    TransactionReceipt
	TransactionHash            []byte
	ConsensusTimestamp         time.Time
	TransactionID              TransactionID
	TransactionMemo            string
	TransactionFee             Hbar
	Transfers                  []Transfer
	TokenTransfers             map[TokenID][]TokenTransfer
	NftTransfers               map[TokenID][]_TokenNftTransfer
	ExpectedDecimals           map[TokenID]uint32
	CallResult                 *ContractFunctionResult
	CallResultIsCreate         bool
	AssessedCustomFees         []AssessedCustomFee
	AutomaticTokenAssociations []TokenAssociation
	ParentConsensusTimestamp   time.Time
	AliasKey                   *PublicKey
	Duplicates                 []TransactionRecord
	Children                   []TransactionRecord
	// Deprecated
	HbarAllowances []HbarAllowance
	// Deprecated
	TokenAllowances []TokenAllowance
	// Deprecated
	TokenNftAllowances    []TokenNftAllowance
	EthereumHash          []byte
	PaidStakingRewards    map[AccountID]Hbar
	PrngBytes             []byte
	PrngNumber            *int32
	EvmAddress            []byte
	PendingAirdropRecords []PendingAirdropRecord
}

// MarshalJSON returns the JSON representation of the TransactionRecord
func (record TransactionRecord) MarshalJSON() ([]byte, error) {
	var json = jsoniter.ConfigCompatibleWithStandardLibrary
	m := make(map[string]interface{})
	type TransferJSON struct {
		AccountID  string      `json:"accountId"`
		Amount     interface{} `json:"amount"`
		IsApproved bool        `json:"isApproved"`
	}
	var transfersJSON []TransferJSON
	for _, t := range record.Transfers {
		transfersJSON = append(transfersJSON, TransferJSON{
			AccountID:  t.AccountID.String(),
			Amount:     fmt.Sprint(t.Amount.AsTinybar()),
			IsApproved: t.IsApproved,
		})
	}

	// It's weird because we need it without field names to match the specification
	tokenTransfersMap := make(map[string]map[string]string)

	for tokenId, transfers := range record.TokenTransfers {
		accountIdMap := make(map[string]string)
		for _, transfer := range transfers {
			accountIdMap[transfer.AccountID.String()] = fmt.Sprint(transfer.Amount)
		}
		tokenTransfersMap[tokenId.String()] = accountIdMap
	}

	type TransferNftTokensJSON struct {
		SenderAccountID            string `json:"sender"`
		ReceiverAccountIDAccountID string `json:"recipient"`
		IsApproved                 bool   `json:"isApproved"`
		SerialNumber               int64  `json:"serial"`
	}
	var transfersNftTokenJSON []TransferNftTokensJSON
	tokenTransfersNftMap := make(map[string][]TransferNftTokensJSON)
	for k, v := range record.NftTransfers {
		for _, tt := range v {
			transfersNftTokenJSON = append(transfersNftTokenJSON, TransferNftTokensJSON{
				SenderAccountID:            tt.SenderAccountID.String(),
				ReceiverAccountIDAccountID: tt.ReceiverAccountID.String(),
				IsApproved:                 tt.IsApproved,
				SerialNumber:               tt.SerialNumber,
			})
		}
		tokenTransfersNftMap[k.String()] = transfersNftTokenJSON
	}

	m["transactionHash"] = hex.EncodeToString(record.TransactionHash)
	m["transactionId"] = record.TransactionID.String()
	m["transactionMemo"] = record.TransactionMemo
	m["transactionFee"] = fmt.Sprint(record.TransactionFee.AsTinybar())
	m["transfers"] = transfersJSON
	m["tokenTransfers"] = tokenTransfersMap
	m["nftTransfers"] = tokenTransfersNftMap
	m["expectedDecimals"] = record.ExpectedDecimals
	m["callResultIsCreate"] = record.CallResultIsCreate

	type AssessedCustomFeeJSON struct {
		FeeCollectorAccountID string   `json:"feeCollectorAccountId"`
		TokenID               string   `json:"tokenId"`
		Amount                string   `json:"amount"`
		PayerAccountIDs       []string `json:"payerAccountIds"`
	}

	customFeesJSON := make([]AssessedCustomFeeJSON, len(record.AssessedCustomFees))

	for i, fee := range record.AssessedCustomFees {
		payerAccountIDsStr := make([]string, len(fee.PayerAccountIDs))
		for j, accID := range fee.PayerAccountIDs {
			payerAccountIDsStr[j] = accID.String()
		}
		customFeesJSON[i] = AssessedCustomFeeJSON{
			FeeCollectorAccountID: fee.FeeCollectorAccountId.String(),
			TokenID:               fee.TokenID.String(),
			Amount:                fmt.Sprint(fee.Amount),
			PayerAccountIDs:       payerAccountIDsStr,
		}
	}

	m["assessedCustomFees"] = customFeesJSON

	type TokenAssociationOutput struct {
		TokenID   string `json:"tokenId"`
		AccountID string `json:"accountId"`
	}
	automaticTokenAssociations := make([]TokenAssociationOutput, len(record.AutomaticTokenAssociations))
	for i, ta := range record.AutomaticTokenAssociations {
		automaticTokenAssociations[i] = TokenAssociationOutput{
			TokenID:   ta.TokenID.String(),
			AccountID: ta.AccountID.String(),
		}
	}
	m["automaticTokenAssociations"] = automaticTokenAssociations

	consensusTime := record.ConsensusTimestamp.UTC().Format("2006-01-02T15:04:05.000Z")
	parentConsesnusTime := record.ParentConsensusTimestamp.UTC().Format("2006-01-02T15:04:05.000Z")
	m["consensusTimestamp"] = consensusTime
	m["parentConsensusTimestamp"] = parentConsesnusTime

	m["aliasKey"] = fmt.Sprint(record.AliasKey)
	m["ethereumHash"] = hex.EncodeToString(record.EthereumHash)
	type PaidStakingReward struct {
		AccountID  string `json:"accountId"`
		Amount     string `json:"amount"`
		IsApproved bool   `json:"isApproved"`
	}
	var paidStakingRewards []PaidStakingReward
	for k, reward := range record.PaidStakingRewards {
		paidStakingReward := PaidStakingReward{
			AccountID:  k.String(),
			Amount:     fmt.Sprint(reward.AsTinybar()),
			IsApproved: false,
		}
		paidStakingRewards = append(paidStakingRewards, paidStakingReward)
	}

	sort.Slice(paidStakingRewards, func(i, j int) bool {
		return paidStakingRewards[i].AccountID < paidStakingRewards[j].AccountID
	})

	m["paidStakingRewards"] = paidStakingRewards

	m["prngBytes"] = hex.EncodeToString(record.PrngBytes)
	m["prngNumber"] = record.PrngNumber
	m["evmAddress"] = hex.EncodeToString(record.EvmAddress)
	m["receipt"] = record.Receipt
	m["children"] = record.Children
	m["duplicates"] = record.Duplicates

	type PendingAirdropIdOutput struct {
		Sender   string `json:"sender"`
		Receiver string `json:"receiver"`
		TokenID  string `json:"tokenId"`
		NftID    string `json:"nftId"`
	}
	type PendingAirdropsOutput struct {
		PendingAirdropId     PendingAirdropIdOutput `json:"pendingAirdropId"`
		PendingAirdropAmount string                 `json:"pendingAirdropAmount"`
	}
	pendingAirdropRecords := make([]PendingAirdropsOutput, len(record.PendingAirdropRecords))
	for i, p := range record.PendingAirdropRecords {
		var tokenID string
		var nftID string
		var sender string
		var receiver string
		if p.pendingAirdropId.tokenID != nil {
			tokenID = p.pendingAirdropId.tokenID.String()
		}
		if p.pendingAirdropId.nftID != nil {
			nftID = p.pendingAirdropId.nftID.String()
		}
		if p.pendingAirdropId.sender != nil {
			sender = p.pendingAirdropId.sender.String()
		}
		if p.pendingAirdropId.receiver != nil {
			receiver = p.pendingAirdropId.receiver.String()
		}
		pendingAirdropRecords[i] = PendingAirdropsOutput{
			PendingAirdropId: PendingAirdropIdOutput{
				Sender:   sender,
				Receiver: receiver,
				TokenID:  tokenID,
				NftID:    nftID,
			},
			PendingAirdropAmount: fmt.Sprint(p.pendingAirdropAmount),
		}
	}
	m["pendingAirdropRecords"] = pendingAirdropRecords

	receiptBytes, err := record.Receipt.MarshalJSON()
	if err != nil {
		return nil, err
	}
	var receiptInterface interface{}
	err = json.Unmarshal(receiptBytes, &receiptInterface)
	if err != nil {
		return nil, err
	}
	m["receipt"] = receiptInterface

	result, err := json.Marshal(m)
	return result, err
}

// GetContractExecuteResult returns the ContractFunctionResult if the transaction was a contract call
func (record TransactionRecord) GetContractExecuteResult() (ContractFunctionResult, error) {
	if record.CallResult == nil || record.CallResultIsCreate {
		return ContractFunctionResult{}, fmt.Errorf("record does not contain a contract execute result")
	}

	return *record.CallResult, nil
}

// GetContractCreateResult returns the ContractFunctionResult if the transaction was a contract create
func (record TransactionRecord) GetContractCreateResult() (ContractFunctionResult, error) {
	if record.CallResult == nil || !record.CallResultIsCreate {
		return ContractFunctionResult{}, fmt.Errorf("record does not contain a contract create result")
	}

	return *record.CallResult, nil
}

func _TransactionRecordFromProtobuf(protoResponse *services.TransactionGetRecordResponse, txID *TransactionID) TransactionRecord {
	if protoResponse == nil {
		return TransactionRecord{}
	}
	pb := protoResponse.GetTransactionRecord()
	if pb == nil {
		return TransactionRecord{}
	}
	var accountTransfers = make([]Transfer, 0)
	var tokenTransfers = make(map[TokenID][]TokenTransfer)
	var nftTransfers = make(map[TokenID][]_TokenNftTransfer)
	var expectedDecimals = make(map[TokenID]uint32)

	if pb.TransferList != nil {
		for _, element := range pb.TransferList.AccountAmounts {
			accountTransfers = append(accountTransfers, _TransferFromProtobuf(element))
		}
	}

	for _, tokenTransfer := range pb.TokenTransferLists {
		for _, nftTransfer := range tokenTransfer.NftTransfers {
			if token := _TokenIDFromProtobuf(tokenTransfer.Token); token != nil {
				nftTransfers[*token] = append(nftTransfers[*token], _NftTransferFromProtobuf(nftTransfer))
			}
		}

		for _, accountAmount := range tokenTransfer.Transfers {
			if token := _TokenIDFromProtobuf(tokenTransfer.Token); token != nil {
				tokenTransfers[*token] = append(tokenTransfers[*token], _TokenTransferFromProtobuf(accountAmount))
			}
		}

		if tokenTransfer.ExpectedDecimals != nil {
			if token := _TokenIDFromProtobuf(tokenTransfer.Token); token != nil {
				expectedDecimals[*token] = tokenTransfer.ExpectedDecimals.Value
			}
		}
	}

	assessedCustomFees := make([]AssessedCustomFee, 0)
	for _, fee := range pb.AssessedCustomFees {
		assessedCustomFees = append(assessedCustomFees, _AssessedCustomFeeFromProtobuf(fee))
	}

	tokenAssociation := make([]TokenAssociation, 0)
	for _, association := range pb.AutomaticTokenAssociations {
		tokenAssociation = append(tokenAssociation, tokenAssociationFromProtobuf(association))
	}

	paidStakingRewards := make(map[AccountID]Hbar)
	for _, aa := range pb.PaidStakingRewards {
		account := _AccountIDFromProtobuf(aa.AccountID)
		if val, ok := paidStakingRewards[*account]; ok {
			paidStakingRewards[*account] = HbarFromTinybar(val.tinybar + aa.Amount)
		}

		paidStakingRewards[*account] = HbarFromTinybar(aa.Amount)
	}

	var alias *PublicKey
	if len(pb.Alias) != 0 {
		pbKey := services.Key{}
		_ = protobuf.Unmarshal(pb.Alias, &pbKey)
		initialKey, _ := _KeyFromProtobuf(&pbKey)
		switch t2 := initialKey.(type) { //nolint
		case PublicKey:
			alias = &t2
		}
	}

	childReceipts := make([]TransactionRecord, 0)
	if len(protoResponse.ChildTransactionRecords) > 0 {
		for _, r := range protoResponse.ChildTransactionRecords {
			childReceipts = append(childReceipts, _TransactionRecordFromProtobuf(&services.TransactionGetRecordResponse{TransactionRecord: r}, txID))
		}
	}

	duplicateReceipts := make([]TransactionRecord, 0)
	if len(protoResponse.DuplicateTransactionRecords) > 0 {
		for _, r := range protoResponse.DuplicateTransactionRecords {
			duplicateReceipts = append(duplicateReceipts, _TransactionRecordFromProtobuf(&services.TransactionGetRecordResponse{TransactionRecord: r}, txID))
		}
	}

	var transactionID TransactionID
	if pb.TransactionID != nil {
		transactionID = _TransactionIDFromProtobuf(pb.TransactionID)
	}

	var pendingAirdropRecords []PendingAirdropRecord
	for _, pendingAirdropRecord := range pb.NewPendingAirdrops {
		pendingAirdropRecords = append(pendingAirdropRecords, _PendingAirdropRecordFromProtobuf(pendingAirdropRecord))
	}

	txRecord := TransactionRecord{
		Receipt:                    _TransactionReceiptFromProtobuf(&services.TransactionGetReceiptResponse{Receipt: pb.GetReceipt()}, txID),
		TransactionHash:            pb.TransactionHash,
		ConsensusTimestamp:         _TimeFromProtobuf(pb.ConsensusTimestamp),
		TransactionID:              transactionID,
		TransactionMemo:            pb.Memo,
		TransactionFee:             HbarFromTinybar(int64(pb.TransactionFee)),
		Transfers:                  accountTransfers,
		TokenTransfers:             tokenTransfers,
		NftTransfers:               nftTransfers,
		CallResultIsCreate:         true,
		AssessedCustomFees:         assessedCustomFees,
		AutomaticTokenAssociations: tokenAssociation,
		ParentConsensusTimestamp:   _TimeFromProtobuf(pb.ParentConsensusTimestamp),
		AliasKey:                   alias,
		Duplicates:                 duplicateReceipts,
		Children:                   childReceipts,
		EthereumHash:               pb.EthereumHash,
		PaidStakingRewards:         paidStakingRewards,
		EvmAddress:                 pb.EvmAddress,
		PendingAirdropRecords:      pendingAirdropRecords,
	}

	if w, ok := pb.Entropy.(*services.TransactionRecord_PrngBytes); ok {
		txRecord.PrngBytes = w.PrngBytes
	}

	if w, ok := pb.Entropy.(*services.TransactionRecord_PrngNumber); ok {
		txRecord.PrngNumber = &w.PrngNumber
	}

	if pb.GetContractCreateResult() != nil {
		result := _ContractFunctionResultFromProtobuf(pb.GetContractCreateResult())

		txRecord.CallResult = &result
	} else if pb.GetContractCallResult() != nil {
		result := _ContractFunctionResultFromProtobuf(pb.GetContractCallResult())

		txRecord.CallResult = &result
		txRecord.CallResultIsCreate = false
	}

	return txRecord
}

func (record TransactionRecord) _ToProtobuf() (*services.TransactionGetRecordResponse, error) {
	var amounts = make([]*services.AccountAmount, 0)
	for _, amount := range record.Transfers {
		amounts = append(amounts, &services.AccountAmount{
			AccountID: amount.AccountID._ToProtobuf(),
			Amount:    amount.Amount.tinybar,
		})
	}

	var transferList = services.TransferList{
		AccountAmounts: amounts,
	}

	var tokenTransfers = make([]*services.TokenTransferList, 0)

	for tokenID, tokenTransfer := range record.TokenTransfers {
		tokenTemp := make([]*services.AccountAmount, 0)

		for _, accountAmount := range tokenTransfer {
			tokenTemp = append(tokenTemp, accountAmount._ToProtobuf())
		}

		bod := &services.TokenTransferList{
			Token:     tokenID._ToProtobuf(),
			Transfers: tokenTemp,
		}

		if decimal, ok := record.ExpectedDecimals[tokenID]; ok {
			bod.ExpectedDecimals = &wrapperspb.UInt32Value{Value: decimal}
		}

		tokenTransfers = append(tokenTransfers, bod)
	}

	for tokenID, nftTransfers := range record.NftTransfers {
		nftTemp := make([]*services.NftTransfer, 0)

		for _, nftTransfer := range nftTransfers {
			nftTemp = append(nftTemp, nftTransfer._ToProtobuf())
		}

		tokenTransfers = append(tokenTransfers, &services.TokenTransferList{
			Token:        tokenID._ToProtobuf(),
			NftTransfers: nftTemp,
		})
	}

	assessedCustomFees := make([]*services.AssessedCustomFee, 0)
	for _, fee := range record.AssessedCustomFees {
		assessedCustomFees = append(assessedCustomFees, fee._ToProtobuf())
	}

	tokenAssociation := make([]*services.TokenAssociation, 0)
	for _, association := range record.AutomaticTokenAssociations {
		tokenAssociation = append(tokenAssociation, association.toProtobuf())
	}

	var alias []byte
	if record.AliasKey != nil {
		alias, _ = protobuf.Marshal(record.AliasKey._ToProtoKey())
	}

	paidStakingRewards := make([]*services.AccountAmount, 0)
	for account, hbar := range record.PaidStakingRewards {
		paidStakingRewards = append(paidStakingRewards, &services.AccountAmount{
			AccountID: account._ToProtobuf(),
			Amount:    hbar.AsTinybar(),
		})
	}

	var tRecord = services.TransactionRecord{
		Receipt:         record.Receipt._ToProtobuf().GetReceipt(),
		TransactionHash: record.TransactionHash,
		ConsensusTimestamp: &services.Timestamp{
			Seconds: int64(record.ConsensusTimestamp.Second()),
			Nanos:   int32(record.ConsensusTimestamp.Nanosecond()),
		},
		TransactionID:              record.TransactionID._ToProtobuf(),
		Memo:                       record.TransactionMemo,
		TransactionFee:             uint64(record.TransactionFee.AsTinybar()),
		TransferList:               &transferList,
		TokenTransferLists:         tokenTransfers,
		AssessedCustomFees:         assessedCustomFees,
		AutomaticTokenAssociations: tokenAssociation,
		ParentConsensusTimestamp: &services.Timestamp{
			Seconds: int64(record.ParentConsensusTimestamp.Second()),
			Nanos:   int32(record.ParentConsensusTimestamp.Nanosecond()),
		},
		Alias:              alias,
		EthereumHash:       record.EthereumHash,
		PaidStakingRewards: paidStakingRewards,
		EvmAddress:         record.EvmAddress,
	}

	if record.PrngNumber != nil {
		tRecord.Entropy = &services.TransactionRecord_PrngNumber{PrngNumber: *record.PrngNumber}
	} else if len(record.PrngBytes) > 0 {
		tRecord.Entropy = &services.TransactionRecord_PrngBytes{PrngBytes: record.PrngBytes}
	}

	var err error
	if record.CallResultIsCreate {
		var choice, err = record.GetContractCreateResult()

		if err != nil {
			return nil, err
		}

		tRecord.Body = &services.TransactionRecord_ContractCreateResult{
			ContractCreateResult: choice._ToProtobuf(),
		}
	} else {
		var choice, err = record.GetContractExecuteResult()

		if err != nil {
			return nil, err
		}

		tRecord.Body = &services.TransactionRecord_ContractCallResult{
			ContractCallResult: choice._ToProtobuf(),
		}
	}

	childReceipts := make([]*services.TransactionRecord, 0)
	if len(record.Children) > 0 {
		for _, r := range record.Children {
			temp, err := r._ToProtobuf()
			if err != nil {
				return nil, err
			}
			childReceipts = append(childReceipts, temp.GetTransactionRecord())
		}
	}

	duplicateReceipts := make([]*services.TransactionRecord, 0)
	if len(record.Duplicates) > 0 {
		for _, r := range record.Duplicates {
			temp, err := r._ToProtobuf()
			if err != nil {
				return nil, err
			}
			duplicateReceipts = append(duplicateReceipts, temp.GetTransactionRecord())
		}
	}

	if record.PendingAirdropRecords != nil {
		for _, pendingAirdropRecord := range record.PendingAirdropRecords {
			tRecord.NewPendingAirdrops = append(tRecord.NewPendingAirdrops, pendingAirdropRecord._ToProtobuf())
		}
	}

	return &services.TransactionGetRecordResponse{
		TransactionRecord:           &tRecord,
		ChildTransactionRecords:     childReceipts,
		DuplicateTransactionRecords: duplicateReceipts,
	}, err
}

// Validate checks that the receipt status is Success
func (record TransactionRecord) ValidateReceiptStatus(shouldValidate bool) error {
	return record.Receipt.ValidateStatus(shouldValidate)
}

// ToBytes returns the serialized bytes of a TransactionRecord
func (record TransactionRecord) ToBytes() []byte {
	rec, err := record._ToProtobuf()
	if err != nil {
		return make([]byte, 0)
	}
	data, err := protobuf.Marshal(rec)
	if err != nil {
		return make([]byte, 0)
	}

	return data
}

// TransactionRecordFromBytes returns a TransactionRecord from a raw protobuf byte array
func TransactionRecordFromBytes(data []byte) (TransactionRecord, error) {
	if data == nil {
		return TransactionRecord{}, errByteArrayNull
	}
	pb := services.TransactionGetRecordResponse{}
	err := protobuf.Unmarshal(data, &pb)
	if err != nil {
		return TransactionRecord{}, err
	}

	return _TransactionRecordFromProtobuf(&pb, nil), nil
}
// Filename: transaction_record_query.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TransactionRecordQuery
// Get the record for a transaction. If the transaction requested a record, then the record lasts
// for one hour, and a state proof is available for it. If the transaction created an account, file,
// or smart contract instance, then the record will contain the ID for what it created. If the
// transaction called a smart contract function, then the record contains the result of that call.
// If the transaction was a cryptocurrency transfer, then the record includes the TransferList which
// gives the details of that transfer. If the transaction didn't return anything that should be in
// the record, then the results field will be set to nothing.
type TransactionRecordQuery struct {
	Query
	transactionID       *TransactionID
	includeChildRecords *bool
	duplicates          *bool
}

// NewTransactionRecordQuery creates TransactionRecordQuery which
// gets the record for a transaction. If the transaction requested a record, then the record lasts
// for one hour, and a state proof is available for it. If the transaction created an account, file,
// or smart contract instance, then the record will contain the ID for what it created. If the
// transaction called a smart contract function, then the record contains the result of that call.
// If the transaction was a cryptocurrency transfer, then the record includes the TransferList which
// gives the details of that transfer. If the transaction didn't return anything that should be in
// the record, then the results field will be set to nothing.
func NewTransactionRecordQuery() *TransactionRecordQuery {
	header := services.QueryHeader{}
	return &TransactionRecordQuery{
		Query: _NewQuery(true, &header),
	}
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (q *TransactionRecordQuery) SetGrpcDeadline(deadline *time.Duration) *TransactionRecordQuery {
	q.Query.SetGrpcDeadline(deadline)
	return q
}

// SetIncludeChildren Sets whether the response should include the records of any child transactions spawned by the
// top-level transaction with the given transactionID.
func (q *TransactionRecordQuery) SetIncludeChildren(includeChildRecords bool) *TransactionRecordQuery {
	q.includeChildRecords = &includeChildRecords
	return q
}

// GetIncludeChildren returns whether the response should include the records of any child transactions spawned by the
// top-level transaction with the given transactionID.
func (q *TransactionRecordQuery) GetIncludeChildren() bool {
	if q.includeChildRecords != nil {
		return *q.includeChildRecords
	}

	return false
}

// SetIncludeDuplicates Sets whether records of processing duplicate transactions should be returned along with the record
// of processing the first consensus transaction with the given id whose status was neither
// INVALID_NODE_ACCOUNT nor <tt>INVALID_PAYER_SIGNATURE; or, if no such
// record exists, the record of processing the first transaction to reach consensus with the
// given transaction id..
func (q *TransactionRecordQuery) SetIncludeDuplicates(includeDuplicates bool) *TransactionRecordQuery {
	q.duplicates = &includeDuplicates
	return q
}

// GetIncludeDuplicates returns whether records of processing duplicate transactions should be returned along with the record
// of processing the first consensus transaction with the given id.
func (q *TransactionRecordQuery) GetIncludeDuplicates() bool {
	if q.duplicates != nil {
		return *q.duplicates
	}

	return false
}

func (q *TransactionRecordQuery) GetCost(client *Client) (Hbar, error) {
	return q.Query.getCost(client, q)
}

// Execute executes the Query with the provided client
func (q *TransactionRecordQuery) Execute(client *Client) (TransactionRecord, error) {
	resp, err := q.Query.execute(client, q)

	if err != nil {
		if precheckErr, ok := err.(ErrHederaPreCheckStatus); ok {
			return TransactionRecord{}, _NewErrHederaReceiptStatus(precheckErr.TxID, precheckErr.Status)
		}
		return TransactionRecord{}, err
	}

	return _TransactionRecordFromProtobuf(resp.GetTransactionGetRecord(), q.transactionID), nil
}

// SetTransactionID sets the TransactionID for this TransactionRecordQuery.
func (q *TransactionRecordQuery) SetTransactionID(transactionID TransactionID) *TransactionRecordQuery {
	q.transactionID = &transactionID
	return q
}

// GetTransactionID returns the TransactionID for which the receipt is being requested.
func (q *TransactionRecordQuery) GetTransactionID() TransactionID {
	if q.transactionID == nil {
		return TransactionID{}
	}

	return *q.transactionID
}

// SetNodeAccountIDs sets the _Node AccountID for this TransactionRecordQuery.
func (q *TransactionRecordQuery) SetNodeAccountIDs(accountID []AccountID) *TransactionRecordQuery {
	q.Query.SetNodeAccountIDs(accountID)
	return q
}

// SetQueryPayment sets the Hbar payment to pay the _Node a fee for handling this query
func (q *TransactionRecordQuery) SetQueryPayment(queryPayment Hbar) *TransactionRecordQuery {
	q.Query.SetQueryPayment(queryPayment)
	return q
}

// SetMaxQueryPayment sets the maximum payment allowed for this Query.
func (q *TransactionRecordQuery) SetMaxQueryPayment(queryMaxPayment Hbar) *TransactionRecordQuery {
	q.Query.SetMaxQueryPayment(queryMaxPayment)
	return q
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (q *TransactionRecordQuery) SetMaxRetry(count int) *TransactionRecordQuery {
	q.Query.SetMaxRetry(count)
	return q
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (q *TransactionRecordQuery) SetMaxBackoff(max time.Duration) *TransactionRecordQuery {
	q.Query.SetMaxBackoff(max)
	return q
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (q *TransactionRecordQuery) SetMinBackoff(min time.Duration) *TransactionRecordQuery {
	q.Query.SetMinBackoff(min)
	return q
}

// SetPaymentTransactionID assigns the payment transaction id.
func (q *TransactionRecordQuery) SetPaymentTransactionID(transactionID TransactionID) *TransactionRecordQuery {
	q.paymentTransactionIDs._Clear()._Push(transactionID)._SetLocked(true)
	return q
}

func (q *TransactionRecordQuery) SetLogLevel(level LogLevel) *TransactionRecordQuery {
	q.Query.SetLogLevel(level)
	return q
}

// ---------- Parent functions specific implementation ----------

func (q *TransactionRecordQuery) getMethod(channel *_Channel) _Method {
	return _Method{
		query: channel._GetCrypto().GetTxRecordByTxID,
	}
}

func (q *TransactionRecordQuery) mapStatusError(_ Executable, response interface{}) error {
	query := response.(*services.Response)
	switch Status(query.GetTransactionGetRecord().GetHeader().GetNodeTransactionPrecheckCode()) {
	case StatusPlatformTransactionNotCreated, StatusBusy, StatusUnknown, StatusReceiptNotFound, StatusRecordNotFound, StatusOk:
		break
	default:
		return ErrHederaPreCheckStatus{
			Status: Status(query.GetTransactionGetRecord().GetHeader().GetNodeTransactionPrecheckCode()),
		}
	}

	return ErrHederaReceiptStatus{
		Status: Status(query.GetTransactionGetRecord().GetTransactionRecord().GetReceipt().GetStatus()),
		// TxID:    _TransactionIDFromProtobuf(_Request.Query.pb.GetTransactionGetRecord().TransactionID, networkName),
		Receipt: _TransactionReceiptFromProtobuf(query.GetTransactionGetReceipt(), nil),
	}
}

func (q *TransactionRecordQuery) getName() string {
	return "TransactionRecordQuery"
}

func (q *TransactionRecordQuery) buildQuery() *services.Query {
	body := &services.TransactionGetRecordQuery{
		Header: q.pbHeader,
	}

	if q.includeChildRecords != nil {
		body.IncludeChildRecords = q.GetIncludeChildren()
	}

	if q.duplicates != nil {
		body.IncludeDuplicates = q.GetIncludeDuplicates()
	}

	if q.transactionID.AccountID != nil {
		body.TransactionID = q.transactionID._ToProtobuf()
	}

	return &services.Query{
		Query: &services.Query_TransactionGetRecord{
			TransactionGetRecord: body,
		},
	}
}

func (q *TransactionRecordQuery) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}

	if err := q.transactionID.AccountID.ValidateChecksum(client); err != nil {
		return err
	}

	return nil
}

func (q *TransactionRecordQuery) shouldRetry(_ Executable, response interface{}) _ExecutionState {
	status := Status(response.(*services.Response).GetTransactionGetRecord().GetHeader().GetNodeTransactionPrecheckCode())

	switch status {
	case StatusPlatformTransactionNotCreated, StatusBusy, StatusUnknown, StatusReceiptNotFound, StatusRecordNotFound, StatusPlatformNotActive:
		return executionStateRetry
	case StatusOk:
		if response.(*services.Response).GetTransactionGetRecord().GetHeader().ResponseType == services.ResponseType_COST_ANSWER {
			return executionStateFinished
		}
	default:
		return executionStateError
	}

	status = Status(response.(*services.Response).GetTransactionGetRecord().GetTransactionRecord().GetReceipt().GetStatus())

	switch status {
	case StatusBusy, StatusUnknown, StatusOk, StatusReceiptNotFound, StatusRecordNotFound, StatusPlatformNotActive:
		return executionStateRetry
	case StatusSuccess:
		return executionStateFinished
	default:
		return executionStateError
	}
}

func (q *TransactionRecordQuery) getQueryResponse(response *services.Response) queryResponse {
	return response.GetTransactionGetRecord()
}
// Filename: transaction_record_query_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTransactionRecordQueryCanExecute(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tx, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx, err = tx.SignWithOperator(env.Client)
	require.NoError(t, err)

	resp, err := tx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	record, err := NewTransactionRecordQuery().
		SetTransactionID(resp.TransactionID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	accountID := *record.Receipt.AccountID
	assert.NotNil(t, accountID)

	recordBytes := record.ToBytes()

	_, err = TransactionRecordFromBytes(recordBytes)
	require.NoError(t, err)

	transaction, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTransactionRecordQueryReceiptPaymentZero(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tx, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx, err = tx.SignWithOperator(env.Client)
	require.NoError(t, err)

	resp, err := tx.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	record, err := NewTransactionRecordQuery().
		SetTransactionID(resp.TransactionID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(env.Client)
	require.NoError(t, err)

	accountID := *record.Receipt.AccountID
	assert.NotNil(t, accountID)

	transaction, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTransactionRecordQueryInsufficientFee(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	tx, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		FreezeWith(env.Client)
	require.NoError(t, err)

	tx, err = tx.SignWithOperator(env.Client)
	require.NoError(t, err)

	resp, err := tx.Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetIncludeChildren(true).GetReceipt(env.Client)
	require.NoError(t, err)

	_, err = NewTransactionRecordQuery().
		SetTransactionID(resp.TransactionID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetMaxQueryPayment(HbarFromTinybar(99999)).
		SetQueryPayment(HbarFromTinybar(1)).
		Execute(env.Client)
	assert.Error(t, err)
	if err != nil {
		assert.Equal(t, "exceptional receipt status: INSUFFICIENT_TX_FEE", err.Error())
	}

	accountID := receipt.AccountID
	assert.NotNil(t, accountID)

	transaction, err := NewAccountDeleteTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(*accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenTransferRecordsQuery(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createFungibleToken(&env, func(transaction *TokenCreateTransaction) {
		transaction.SetCustomFees([]Fee{CustomFractionalFee{
			CustomFee: CustomFee{
				FeeCollectorAccountID: &env.OperatorID,
			},
			Numerator:     1,
			Denominator:   20,
			MinimumAmount: 1,
			MaximumAmount: 10,
		}})
	})
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddTokenTransfer(tokenID, env.Client.GetOperatorAccountID(), -10).
		AddTokenTransfer(tokenID, accountID, 10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	record, err := resp.GetRecord(env.Client)
	require.NoError(t, err)

	assert.Equal(t, len(record.TokenTransfers), 1)
	assert.Equal(t, len(record.AssessedCustomFees), 0)

	resp, err = NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetAmount(10).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}

func DisabledTestIntegrationTokenNftTransferRecordQuery(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(2)

	assert.Equal(t, 2*HbarUnits.Hbar._NumberOfTinybar(), newBalance.tinybar)

	resp, err := NewAccountCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetKey(newKey.PublicKey()).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	tokenID, err := createNft(&env)
	require.NoError(t, err)

	metaData := [][]byte{{50}, {50}}

	mint, err := NewTokenMintTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetMetadatas(metaData).
		Execute(env.Client)
	require.NoError(t, err)

	mintReceipt, err := mint.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	transaction, err := NewTokenAssociateTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenIDs(tokenID).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = transaction.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTokenGrantKycTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetAccountID(accountID).
		SetTokenID(tokenID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	resp, err = NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[0]), env.OperatorID, accountID).
		AddNftTransfer(tokenID.Nft(mintReceipt.SerialNumbers[1]), env.OperatorID, accountID).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	record, err := resp.GetRecord(env.Client)
	require.NoError(t, err)

	assert.Equal(t, len(record.NftTransfers), 1)

	resp, err = NewTokenWipeTransaction().
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		SetTokenID(tokenID).
		SetAccountID(accountID).
		SetSerialNumbers(mintReceipt.SerialNumbers).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	tx, err := NewAccountDeleteTransaction().
		SetAccountID(accountID).
		SetTransferAccountID(env.Client.GetOperatorAccountID()).
		FreezeWith(env.Client)
	require.NoError(t, err)

	resp, err = tx.
		Sign(newKey).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)
}
// Filename: transaction_record_query_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"encoding/hex"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/services"
	"github.com/stretchr/testify/require"
)

func TestUnitTransactionRecordQueryValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	transactionID := TransactionIDGenerate(accountID)
	require.NoError(t, err)

	recordQuery := NewTransactionRecordQuery().
		SetTransactionID(transactionID)

	err = recordQuery.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTransactionRecordQueryValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	transactionID := TransactionIDGenerate(accountID)
	require.NoError(t, err)

	recordQuery := NewTransactionRecordQuery().
		SetTransactionID(transactionID)

	err = recordQuery.validateNetworkOnIDs(client)
	require.Error(t, err)
	if err != nil {
		require.Equal(t, "network mismatch or wrong checksum given, given checksum: rmkykd, correct checksum esxsf, network: testnet", err.Error())
	}
}

func TestUnitTransactionRecordQueryGet(t *testing.T) {
	t.Parallel()

	txID := TransactionIDGenerate(AccountID{Account: 7})
	deadline := time.Duration(time.Minute)
	accountId := AccountID{Account: 123}
	transactionID := TransactionIDGenerate(accountId)
	query := NewTransactionRecordQuery().
		SetTransactionID(txID).
		SetIncludeDuplicates(true).
		SetIncludeChildren(true).
		SetQueryPayment(NewHbar(2)).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25)).
		SetNodeAccountIDs([]AccountID{{Account: 10}, {Account: 11}, {Account: 12}}).
		SetMaxRetry(3).
		SetMinBackoff(300 * time.Millisecond).
		SetMaxBackoff(10 * time.Second).
		SetPaymentTransactionID(transactionID).
		SetMaxQueryPayment(NewHbar(500)).
		SetGrpcDeadline(&deadline)

	require.Equal(t, txID, query.GetTransactionID())
	require.True(t, query.GetIncludeChildren())
	require.True(t, query.GetIncludeDuplicates())
	require.Equal(t, []AccountID{{Account: 10}, {Account: 11}, {Account: 12}}, query.GetNodeAccountIDs())
	require.Equal(t, 300*time.Millisecond, query.GetMinBackoff())
	require.Equal(t, 10*time.Second, query.GetMaxBackoff())
	require.Equal(t, 3, query.GetMaxRetryCount())
	require.Equal(t, transactionID, query.GetPaymentTransactionID())
	require.Equal(t, HbarFromTinybar(25), query.GetQueryPayment())
	require.Equal(t, NewHbar(500), query.GetMaxQueryPayment())
	require.Equal(t, &deadline, query.GetGrpcDeadline())
}

func TestUnitTransactionRecordQueryNothingSet(t *testing.T) {
	t.Parallel()

	query := NewTransactionRecordQuery()

	require.Equal(t, TransactionID{}, query.GetTransactionID())
	require.False(t, query.GetIncludeChildren())
	require.False(t, query.GetIncludeDuplicates())
	require.Empty(t, query.GetNodeAccountIDs())
	require.Equal(t, 250*time.Millisecond, query.GetMinBackoff())
	require.Equal(t, 8*time.Second, query.GetMaxBackoff())
	require.Equal(t, 10, query.GetMaxRetryCount())
	require.Equal(t, TransactionID{}, query.GetPaymentTransactionID())
	require.Equal(t, Hbar{}, query.GetQueryPayment())
	require.Equal(t, Hbar{}, query.GetMaxQueryPayment())
}

func TestUnitTransactionRecordPlatformNotActiveGracefulHandling(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_SUCCESS,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetRecord{
				TransactionGetRecord: &services.TransactionGetRecordResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					TransactionRecord: &services.TransactionRecord{
						Receipt: &services.TransactionReceipt{
							Status: services.ResponseCodeEnum_PLATFORM_NOT_ACTIVE,
						},
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetRecord{
				TransactionGetRecord: &services.TransactionGetRecordResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					TransactionRecord: &services.TransactionRecord{
						Receipt: &services.TransactionReceipt{
							Status: services.ResponseCodeEnum_SUCCESS,
						},
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetRecord{
				TransactionGetRecord: &services.TransactionGetRecordResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					TransactionRecord: &services.TransactionRecord{
						Receipt: &services.TransactionReceipt{
							Status: services.ResponseCodeEnum_PLATFORM_NOT_ACTIVE,
						},
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetRecord{
				TransactionGetRecord: &services.TransactionGetRecordResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					TransactionRecord: &services.TransactionRecord{
						Receipt: &services.TransactionReceipt{
							Status: services.ResponseCodeEnum_SUCCESS,
						},
					},
				},
			},
		},
	}}

	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	tx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(1)).
		Execute(client)
	client.SetMaxAttempts(2)
	require.NoError(t, err)
	_, err = tx.SetValidateStatus(true).GetRecord(client)
	require.NoError(t, err)
}

func TestUnitTransactionRecordReceiptNotFound(t *testing.T) {
	t.Parallel()

	responses := [][]interface{}{{
		&services.TransactionResponse{
			NodeTransactionPrecheckCode: services.ResponseCodeEnum_OK,
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_RECEIPT_NOT_FOUND,
					},
				},
			},
		},
		&services.Response{
			Response: &services.Response_TransactionGetReceipt{
				TransactionGetReceipt: &services.TransactionGetReceiptResponse{
					Header: &services.ResponseHeader{
						Cost:         0,
						ResponseType: services.ResponseType_ANSWER_ONLY,
					},
					Receipt: &services.TransactionReceipt{
						Status: services.ResponseCodeEnum_RECEIPT_NOT_FOUND,
					},
				},
			},
		},
	}}
	client, server := NewMockClientAndServer(responses)
	defer server.Close()
	tx, err := NewTransferTransaction().
		SetNodeAccountIDs([]AccountID{{Account: 3}}).
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(1)).
		Execute(client)
	client.SetMaxAttempts(2)
	require.NoError(t, err)
	record, err := tx.SetValidateStatus(true).GetRecord(client)
	require.Error(t, err)
	require.Equal(t, "exceptional precheck status RECEIPT_NOT_FOUND", err.Error())
	require.Equal(t, StatusReceiptNotFound, record.Receipt.Status)
}

func TestUnitTransactionRecordQueryMarshalJSON(t *testing.T) {
	t.Parallel()
	hexRecord, err := hex.DecodeString(`1afe010a26081612070800100018de092a130a110801100c1a0b0880ae99a4ffffffffff013800420058001230cac44f2db045ba441f3fbc295217f2eb0f956293d28b3401578f6160e66f4e47ea87952d91c4b1cb5bda6447823b979a1a0c08f3fcb495061083d9be900322190a0c08e8fcb495061098f09cf20112070800100018850918002a0030bee8f013526c0a0f0a0608001000180510d0df820118000a0f0a0608001000186210f08dff1e18000a100a070800100018a00610def1ef0318000a100a070800100018a10610def1ef0318000a110a070800100018850910fbf8b7e10718000a110a070800100018de091080a8d6b90718008a0100aa0100`)
	require.NoError(t, err)
	record, err := TransactionRecordFromBytes([]byte(hexRecord))
	require.NoError(t, err)
	accID, err := AccountIDFromString("0.0.1246")
	require.NoError(t, err)
	tokenID, err := TokenIDFromString("0.0.123")
	require.NoError(t, err)
	contractID, err := ContractIDFromString("0.0.3")
	require.NoError(t, err)
	record.Receipt.ContractID = &contractID
	record.Receipt.NodeID = 1

	tokenTransfer := TokenTransfer{
		AccountID:  accID,
		Amount:     789,
		IsApproved: true,
	}
	tokenTransferList := map[TokenID][]TokenTransfer{}
	tokenTransferList[tokenID] = []TokenTransfer{tokenTransfer}

	tokenNftTransfer := _TokenNftTransfer{
		SenderAccountID:   accID,
		ReceiverAccountID: accID,
		SerialNumber:      123,
		IsApproved:        true,
	}
	tokenNftTransferList := map[TokenID][]_TokenNftTransfer{}
	tokenNftTransferList[tokenID] = []_TokenNftTransfer{tokenNftTransfer}

	assessedCustomFee := AssessedCustomFee{
		FeeCollectorAccountId: &accID,
		Amount:                789,
		TokenID:               &tokenID,
		PayerAccountIDs:       []*AccountID{&accID},
	}

	tokenAssociation := TokenAssociation{
		AccountID: &accID,
		TokenID:   &tokenID,
	}

	plaidStaking := map[AccountID]Hbar{}
	for _, transfer := range record.Transfers {
		plaidStaking[transfer.AccountID] = transfer.Amount
	}

	pk, err := PublicKeyFromString("302a300506032b6570032100d7366c45e4d2f1a6c1d9af054f5ef8edc0b8d3875ba5d08a7f2e81ee8876e9e8")
	require.NoError(t, err)

	prngNumber := int32(123)
	evmAddressBytes, err := hex.DecodeString("deadbeef")
	require.NoError(t, err)

	record.TransactionMemo = "test"
	record.TokenTransfers = tokenTransferList
	record.NftTransfers = tokenNftTransferList
	record.ParentConsensusTimestamp = record.ConsensusTimestamp
	record.AliasKey = &pk
	record.EthereumHash = []byte{1, 2, 3, 4}
	record.PaidStakingRewards = plaidStaking
	record.PrngBytes = []byte{1, 2, 3, 4}
	record.PrngNumber = &prngNumber
	record.EvmAddress = evmAddressBytes
	record.AssessedCustomFees = []AssessedCustomFee{assessedCustomFee}
	record.AutomaticTokenAssociations = []TokenAssociation{tokenAssociation}
	record.PendingAirdropRecords = []PendingAirdropRecord{{pendingAirdropId: PendingAirdropId{&accID, &accID, &tokenID, nil}, pendingAirdropAmount: 789}}
	result, err := record.MarshalJSON()
	require.NoError(t, err)
	expected := `{
        "aliasKey":"302a300506032b6570032100d7366c45e4d2f1a6c1d9af054f5ef8edc0b8d3875ba5d08a7f2e81ee8876e9e8",
        "assessedCustomFees":[{"feeCollectorAccountId":"0.0.1246","tokenId":"0.0.123","amount":"789","payerAccountIds":["0.0.1246"]}],
        "automaticTokenAssociations":[{"tokenId":"0.0.123","accountId":"0.0.1246"}],
        "callResultIsCreate":true,
        "children":[],
        "consensusTimestamp":"2022-06-18T02:54:43.839Z",
        "duplicates":[],
        "ethereumHash":"01020304",
        "evmAddress":"deadbeef",
        "expectedDecimals":null,
        "nftTransfers":{"0.0.123":[{"sender":"0.0.1246","recipient":"0.0.1246","isApproved":true,"serial":123}]},
        "paidStakingRewards":[
            {"accountId":"0.0.1157","amount":"-1041694270","isApproved":false},
            {"accountId":"0.0.1246","amount":"1000000000","isApproved":false},
            {"accountId":"0.0.5","amount":"1071080","isApproved":false},
            {"accountId":"0.0.800","amount":"4062319","isApproved":false},
            {"accountId":"0.0.801","amount":"4062319","isApproved":false},
            {"accountId":"0.0.98","amount":"32498552","isApproved":false}
        ],
        "parentConsensusTimestamp":"2022-06-18T02:54:43.839Z",
        "pendingAirdropRecords":[
            {
                "pendingAirdropAmount":"789",
                "pendingAirdropId":{
                    "nftId":"",
                    "receiver":"0.0.1246",
                    "sender":"0.0.1246",
                    "tokenId":"0.0.123"
                }
            }
        ],
        "prngBytes":"01020304",
        "prngNumber":123,
        "receipt":{
            "accountId":"0.0.1246",
            "children":[],
            "contractId":"0.0.3",
            "duplicates":[],
            "exchangeRate":{"cents":12,"expirationTime":"1963-11-25T17:31:44.000Z","hbars":1},
            "fileId":null,
            "nodeId":1,
            "scheduleId":null,
            "scheduledTransactionId":null,
            "serialNumbers":null,
            "status":"SUCCESS",
            "tokenId":null,
            "topicId":null,
            "topicRunningHash":"",
            "topicRunningHashVersion":0,
            "topicSequenceNumber":0,
            "totalSupply":0
        },
        "tokenTransfers":{"0.0.123":{"0.0.1246":"789"}},
        "transactionFee":"41694270",
        "transactionHash":"cac44f2db045ba441f3fbc295217f2eb0f956293d28b3401578f6160e66f4e47ea87952d91c4b1cb5bda6447823b979a",
        "transactionId":"0.0.1157@1655520872.507983896",
        "transactionMemo":"test",
        "transfers":[
            {"accountId":"0.0.5","amount":"1071080","isApproved":false},
            {"accountId":"0.0.98","amount":"32498552","isApproved":false},
            {"accountId":"0.0.800","amount":"4062319","isApproved":false},
            {"accountId":"0.0.801","amount":"4062319","isApproved":false},
            {"accountId":"0.0.1157","amount":"-1041694270","isApproved":false},
            {"accountId":"0.0.1246","amount":"1000000000","isApproved":false}
        ]
    }`
	require.JSONEqf(t, expected, string(result), "json should be equal")
}
// Filename: transaction_response.go
package hedera

import (
	"encoding/hex"

	jsoniter "github.com/json-iterator/go"
)

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// When the client sends the node a transaction of any kind, the node replies with this, which
// simply says that the transaction passed the precheck (so the node will submit it to the network)
// or it failed (so it won't). If the fee offered was insufficient, this will also contain the
// amount of the required fee. To learn the consensus result, the client should later obtain a
// receipt (free), or can buy a more detailed record (not free).
type TransactionResponse struct {
	TransactionID          TransactionID
	ScheduledTransactionId TransactionID // nolint
	NodeID                 AccountID
	Hash                   []byte
	ValidateStatus         bool
	IncludeChildReceipts   bool
	Transaction            TransactionInterface
}

// MarshalJSON returns the JSON representation of the TransactionResponse.
// This should yield the same result in all SDK's.
func (response TransactionResponse) MarshalJSON() ([]byte, error) {
	var json = jsoniter.ConfigCompatibleWithStandardLibrary
	obj := make(map[string]interface{})
	obj["nodeID"] = response.NodeID.String()
	obj["hash"] = hex.EncodeToString(response.Hash)
	obj["transactionID"] = response.TransactionID.String()
	return json.Marshal(obj)
}

// retryTransaction is a helper function to retry a transaction that was throttled
func retryTransaction(client *Client, transaction TransactionInterface) (TransactionReceipt, error) {
	resp, err := TransactionExecute(transaction, client)
	if err != nil {
		return TransactionReceipt{}, err
	}
	receipt, err := NewTransactionReceiptQuery().
		SetTransactionID(resp.TransactionID).
		SetNodeAccountIDs([]AccountID{resp.NodeID}).
		Execute(client)
	return receipt, err
}

// GetReceipt retrieves the receipt for the transaction
func (response TransactionResponse) GetReceipt(client *Client) (TransactionReceipt, error) {
	receipt, err := NewTransactionReceiptQuery().
		SetTransactionID(response.TransactionID).
		SetNodeAccountIDs([]AccountID{response.NodeID}).
		SetIncludeChildren(response.IncludeChildReceipts).
		Execute(client)

	for receipt.Status == StatusThrottledAtConsensus {
		receipt, err = retryTransaction(client, response.Transaction)
	}

	if err != nil {
		return receipt, err
	}

	return receipt, receipt.ValidateStatus(response.ValidateStatus)
}

// GetRecord retrieves the record for the transaction
func (response TransactionResponse) GetRecord(client *Client) (TransactionRecord, error) {
	receipt, err := NewTransactionReceiptQuery().
		SetTransactionID(response.TransactionID).
		SetNodeAccountIDs([]AccountID{response.NodeID}).
		Execute(client)

	if err != nil {
		// Manually add the receipt, because an empty TransactionRecord will have an empty receipt and empty receipt has no status and no status defaults to 0, which means success
		return TransactionRecord{Receipt: receipt}, err
	}

	return NewTransactionRecordQuery().
		SetTransactionID(response.TransactionID).
		SetNodeAccountIDs([]AccountID{response.NodeID}).
		Execute(client)
}

// GetReceiptQuery retrieves the receipt query for the transaction
func (response TransactionResponse) GetReceiptQuery() *TransactionReceiptQuery {
	return NewTransactionReceiptQuery().
		SetTransactionID(response.TransactionID).
		SetNodeAccountIDs([]AccountID{response.NodeID})
}

// GetRecordQuery retrieves the record query for the transaction
func (response TransactionResponse) GetRecordQuery() *TransactionRecordQuery {
	return NewTransactionRecordQuery().
		SetTransactionID(response.TransactionID).
		SetNodeAccountIDs([]AccountID{response.NodeID})
}

// SetValidateStatus sets the validate status for the transaction
func (response TransactionResponse) SetValidateStatus(validate bool) *TransactionResponse {
	response.ValidateStatus = validate
	return &response
}

// GetValidateStatus returns the validate status for the transaction
func (response TransactionResponse) GetValidateStatus() bool {
	return response.ValidateStatus
}

// SetIncludeChildren Sets whether the response should include the receipts of any child transactions spawned by the
// top-level transaction with the given transactionID.
func (response TransactionResponse) SetIncludeChildren(include bool) *TransactionResponse {
	response.IncludeChildReceipts = include
	return &response
}

// GetIncludeChildren returns whether the response should include the receipts of any child transactions spawned by the
// top-level transaction with the given transactionID.
func (response TransactionResponse) GetIncludeChildren() bool {
	return response.IncludeChildReceipts
}
// Filename: transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"reflect"
	"testing"
	"time"

	"github.com/hashgraph/hedera-protobufs-go/sdk"
	"github.com/hashgraph/hedera-protobufs-go/services"
	protobuf "google.golang.org/protobuf/proto"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

func TestUnitTransactionSerializationDeserialization(t *testing.T) {
	t.Parallel()

	transaction, err := _NewMockTransaction()
	require.NoError(t, err)

	_, err = transaction.Freeze()
	require.NoError(t, err)

	_, err = transaction.GetSignatures()
	require.NoError(t, err)

	_, err = transaction.GetTransactionHash()
	require.NoError(t, err)

	transaction.
		SetTransactionMemo("memo").
		SetMaxTransactionFee(NewHbar(5))

	txBytes, err := transaction.ToBytes()
	require.NoError(t, err)

	deserializedTX, err := TransactionFromBytes(txBytes)
	require.NoError(t, err)

	var deserializedTXTyped TransferTransaction
	switch tx := deserializedTX.(type) {
	case TransferTransaction:
		deserializedTXTyped = tx
	default:
		panic("Transaction was not TransferTransaction")
	}

	require.Equal(t, "memo", deserializedTXTyped.memo)
	require.Equal(t, NewHbar(5), deserializedTXTyped.GetMaxTransactionFee())
	assert.Equal(t, transaction.String(), deserializedTXTyped.String())
}

func TestUnitTransactionValidateBodiesEqual(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyFromString(mockPrivateKey)
	require.NoError(t, err)
	transaction := services.TransactionBody{
		TransactionID:            testTransactionID._ToProtobuf(),
		NodeAccountID:            AccountID{Account: 3}._ToProtobuf(),
		TransactionFee:           0,
		TransactionValidDuration: nil,
		GenerateRecord:           false,
		Memo:                     "",
		Data: &services.TransactionBody_CryptoCreateAccount{
			CryptoCreateAccount: &services.CryptoCreateTransactionBody{
				Key:                           key._ToProtoKey(),
				InitialBalance:                0,
				ProxyAccountID:                AccountID{Account: 123}._ToProtobuf(),
				SendRecordThreshold:           0,
				ReceiveRecordThreshold:        0,
				ReceiverSigRequired:           false,
				AutoRenewPeriod:               nil,
				ShardID:                       nil,
				RealmID:                       nil,
				NewRealmAdminKey:              nil,
				Memo:                          "",
				MaxAutomaticTokenAssociations: 0,
			},
		},
	}

	transactionBody, err := protobuf.Marshal(&transaction)
	require.NoError(t, err)

	signed, err := protobuf.Marshal(&services.SignedTransaction{
		BodyBytes: transactionBody,
	})
	require.NoError(t, err)
	list, err := protobuf.Marshal(&sdk.TransactionList{
		TransactionList: []*services.Transaction{
			{
				SignedTransactionBytes: signed,
			},
			{
				SignedTransactionBytes: signed,
			},
			{
				SignedTransactionBytes: signed,
			},
		},
	})

	deserializedTX, err := TransactionFromBytes(list)
	require.NoError(t, err)

	var deserializedTXTyped AccountCreateTransaction
	switch tx := deserializedTX.(type) {
	case AccountCreateTransaction:
		deserializedTXTyped = tx
	default:
		panic("Transaction was not AccountCreateTransaction")
	}

	assert.Equal(t, uint64(transaction.TransactionID.AccountID.GetAccountNum()), deserializedTXTyped.GetTransactionID().AccountID.Account)
}

func DisabledTestUnitTransactionValidateBodiesNotEqual(t *testing.T) {
	t.Parallel()

	key, err := PrivateKeyFromString(mockPrivateKey)
	require.NoError(t, err)
	transaction := services.TransactionBody{
		TransactionID:            testTransactionID._ToProtobuf(),
		NodeAccountID:            AccountID{Account: 3}._ToProtobuf(),
		TransactionFee:           0,
		TransactionValidDuration: nil,
		GenerateRecord:           false,
		Memo:                     "",
		Data: &services.TransactionBody_CryptoCreateAccount{
			CryptoCreateAccount: &services.CryptoCreateTransactionBody{
				Key:                           key._ToProtoKey(),
				InitialBalance:                0,
				ProxyAccountID:                AccountID{Account: 123}._ToProtobuf(),
				SendRecordThreshold:           0,
				ReceiveRecordThreshold:        0,
				ReceiverSigRequired:           false,
				AutoRenewPeriod:               nil,
				ShardID:                       nil,
				RealmID:                       nil,
				NewRealmAdminKey:              nil,
				Memo:                          "",
				MaxAutomaticTokenAssociations: 0,
			},
		},
	}

	transaction2 := services.TransactionBody{
		TransactionID:            testTransactionID._ToProtobuf(),
		NodeAccountID:            AccountID{Account: 3}._ToProtobuf(),
		TransactionFee:           0,
		TransactionValidDuration: nil,
		GenerateRecord:           false,
		Memo:                     "",
		Data: &services.TransactionBody_CryptoCreateAccount{
			CryptoCreateAccount: &services.CryptoCreateTransactionBody{
				Key:                           key._ToProtoKey(),
				InitialBalance:                0,
				ProxyAccountID:                AccountID{Account: 1}._ToProtobuf(),
				SendRecordThreshold:           0,
				ReceiveRecordThreshold:        0,
				ReceiverSigRequired:           false,
				AutoRenewPeriod:               nil,
				ShardID:                       nil,
				RealmID:                       nil,
				NewRealmAdminKey:              nil,
				Memo:                          "",
				MaxAutomaticTokenAssociations: 0,
			},
		},
	}

	transactionBody, err := protobuf.Marshal(&transaction)
	require.NoError(t, err)

	signed, err := protobuf.Marshal(&services.SignedTransaction{
		BodyBytes: transactionBody,
	})

	transactionBody2, err := protobuf.Marshal(&transaction2)
	require.NoError(t, err)

	signed2, err := protobuf.Marshal(&services.SignedTransaction{
		BodyBytes: transactionBody2,
	})

	require.NoError(t, err)
	list, err := protobuf.Marshal(&sdk.TransactionList{
		TransactionList: []*services.Transaction{
			{
				SignedTransactionBytes: signed,
			},
			{
				SignedTransactionBytes: signed2,
			},
			{
				SignedTransactionBytes: signed2,
			},
		},
	})

	_, err = TransactionFromBytes(list)
	require.Error(t, err)
	if err != nil {
		assert.Equal(t, fmt.Sprintf("failed to validate transaction bodies"), err.Error())
	}
}

func TestUnitTransactionToFromBytes(t *testing.T) {
	t.Parallel()

	duration := time.Second * 10
	operatorID := AccountID{Account: 5}
	recepientID := AccountID{Account: 4}
	node := []AccountID{{Account: 3}}
	transaction, err := NewTransferTransaction().
		SetTransactionID(testTransactionID).
		SetNodeAccountIDs(node).
		AddHbarTransfer(operatorID, NewHbar(-1)).
		AddHbarTransfer(recepientID, NewHbar(1)).
		SetTransactionMemo("go sdk example multi_app_transfer/main.go").
		SetTransactionValidDuration(duration).
		Freeze()
	require.NoError(t, err)

	_ = transaction.GetTransactionID()
	nodeID := transaction.GetNodeAccountIDs()
	require.NotEmpty(t, nodeID)
	require.False(t, nodeID[0]._IsZero())

	var tx services.TransactionBody
	_ = protobuf.Unmarshal(transaction.signedTransactions._Get(0).(*services.SignedTransaction).BodyBytes, &tx)
	require.Equal(t, tx.TransactionID.String(), testTransactionID._ToProtobuf().String())
	require.Equal(t, tx.NodeAccountID.String(), node[0]._ToProtobuf().String())
	require.Equal(t, tx.Memo, "go sdk example multi_app_transfer/main.go")
	require.Equal(t, duration, _DurationFromProtobuf(tx.TransactionValidDuration))
	require.Equal(t, tx.GetCryptoTransfer().Transfers.AccountAmounts,
		[]*services.AccountAmount{
			{
				AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{5}},
				Amount:    -100000000,
			},
			{
				AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{4}},
				Amount:    100000000,
			},
		})

	txBytes, err := transaction.ToBytes()
	require.NoError(t, err)

	newTransaction, err := TransactionFromBytes(txBytes)

	_ = protobuf.Unmarshal(newTransaction.(TransferTransaction).signedTransactions._Get(0).(*services.SignedTransaction).BodyBytes, &tx)
	require.Equal(t, tx.TransactionID.String(), testTransactionID._ToProtobuf().String())
	require.Equal(t, tx.NodeAccountID.String(), node[0]._ToProtobuf().String())
	require.Equal(t, tx.Memo, "go sdk example multi_app_transfer/main.go")
	require.Equal(t, duration, _DurationFromProtobuf(tx.TransactionValidDuration))
	require.Equal(t, tx.GetCryptoTransfer().Transfers.AccountAmounts,
		[]*services.AccountAmount{
			{
				AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{5}},
				Amount:    -100000000,
			},
			{
				AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{4}},
				Amount:    100000000,
			},
		})
}

func TestUnitTransactionToFromBytesWithClient(t *testing.T) {
	t.Parallel()

	duration := time.Second * 10
	operatorID := AccountID{Account: 5}
	recepientID := AccountID{Account: 4}
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	privateKey, err := PrivateKeyFromString(mockPrivateKey)
	client.SetOperator(AccountID{Account: 2}, privateKey)

	transaction, err := NewTransferTransaction().
		AddHbarTransfer(operatorID, NewHbar(-1)).
		AddHbarTransfer(recepientID, NewHbar(1)).
		SetTransactionMemo("go sdk example multi_app_transfer/main.go").
		SetTransactionValidDuration(duration).
		FreezeWith(client)
	require.NoError(t, err)

	var tx services.TransactionBody
	_ = protobuf.Unmarshal(transaction.signedTransactions._Get(0).(*services.SignedTransaction).BodyBytes, &tx)
	require.NotNil(t, tx.TransactionID, tx.NodeAccountID)
	require.Equal(t, tx.Memo, "go sdk example multi_app_transfer/main.go")
	require.Equal(t, duration, _DurationFromProtobuf(tx.TransactionValidDuration))
	require.Equal(t, tx.GetCryptoTransfer().Transfers.AccountAmounts,
		[]*services.AccountAmount{
			{
				AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{5}},
				Amount:    -100000000,
			},
			{
				AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{4}},
				Amount:    100000000,
			},
		})

	initialTxID := tx.TransactionID
	initialNode := tx.NodeAccountID

	txBytes, err := transaction.ToBytes()
	require.NoError(t, err)

	newTransaction, err := TransactionFromBytes(txBytes)

	_ = protobuf.Unmarshal(newTransaction.(TransferTransaction).signedTransactions._Get(0).(*services.SignedTransaction).BodyBytes, &tx)
	require.NotNil(t, tx.TransactionID, tx.NodeAccountID)
	require.Equal(t, tx.TransactionID.String(), initialTxID.String())
	require.Equal(t, tx.NodeAccountID.String(), initialNode.String())
	require.Equal(t, tx.Memo, "go sdk example multi_app_transfer/main.go")
	require.Equal(t, duration, _DurationFromProtobuf(tx.TransactionValidDuration))
	require.Equal(t, tx.GetCryptoTransfer().Transfers.AccountAmounts,
		[]*services.AccountAmount{
			{
				AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{5}},
				Amount:    -100000000,
			},
			{
				AccountID: &services.AccountID{Account: &services.AccountID_AccountNum{4}},
				Amount:    100000000,
			},
		})
}

func TestUnitQueryRegression(t *testing.T) {
	t.Parallel()

	accountID := AccountID{Account: 5}
	node := []AccountID{{Account: 3}}
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	privateKey, err := PrivateKeyFromString(mockPrivateKey)
	client.SetOperator(AccountID{Account: 2}, privateKey)

	query := NewAccountInfoQuery().
		SetAccountID(accountID).
		SetNodeAccountIDs(node).
		SetPaymentTransactionID(testTransactionID).
		SetMaxQueryPayment(NewHbar(1)).
		SetQueryPayment(HbarFromTinybar(25))

	body := query.buildQuery()
	_, err = query.generatePayments(client, HbarFromTinybar(20))
	require.NoError(t, err)

	var paymentTx services.TransactionBody
	_ = protobuf.Unmarshal(query.Query.paymentTransactions[0].BodyBytes, &paymentTx)

	require.Equal(t, body.GetCryptoGetInfo().AccountID.String(), accountID._ToProtobuf().String())
	require.Equal(t, paymentTx.NodeAccountID.String(), node[0]._ToProtobuf().String())
	require.Equal(t, paymentTx.TransactionFee, uint64(NewHbar(1).tinybar))
	require.Equal(t, paymentTx.TransactionValidDuration, &services.Duration{Seconds: 120})
	require.Equal(t, paymentTx.Data, &services.TransactionBody_CryptoTransfer{
		CryptoTransfer: &services.CryptoTransferTransactionBody{
			Transfers: &services.TransferList{
				AccountAmounts: []*services.AccountAmount{
					{
						AccountID: node[0]._ToProtobuf(),
						Amount:    HbarFromTinybar(20).AsTinybar(),
					},
					{
						AccountID: client.GetOperatorAccountID()._ToProtobuf(),
						Amount:    -HbarFromTinybar(20).AsTinybar(),
					},
				},
			},
		},
	})
}
func TestUnitTransactionInitFeeMaxTransactionWithouthSettingFee(t *testing.T) {
	t.Parallel()

	//Default Max Fee for TransferTransaction
	fee := NewHbar(1)
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	transaction, err := NewTransferTransaction().
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-100)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(100)).
		FreezeWith(client)
	require.NoError(t, err)
	require.Equal(t, uint64(fee.AsTinybar()), transaction.transactionFee)
}

func TestUnitTransactionInitFeeMaxTransactionFeeSetExplicitly(t *testing.T) {
	t.Parallel()

	clientMaxFee := NewHbar(14)
	explicitMaxFee := NewHbar(15)
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	client.SetDefaultMaxTransactionFee(clientMaxFee)
	require.NoError(t, err)
	transaction, err := NewTransferTransaction().
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-100)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(100)).
		SetMaxTransactionFee(explicitMaxFee).
		FreezeWith(client)
	require.NoError(t, err)
	require.Equal(t, uint64(explicitMaxFee.AsTinybar()), transaction.transactionFee)
}

func TestUnitTransactionInitFeeMaxTransactionFromClientDefault(t *testing.T) {
	t.Parallel()

	fee := NewHbar(14)
	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	client.SetDefaultMaxTransactionFee(fee)
	require.NoError(t, err)
	transaction, err := NewTransferTransaction().
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-100)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(100)).
		FreezeWith(client)
	require.NoError(t, err)
	require.Equal(t, uint64(fee.AsTinybar()), transaction.transactionFee)
}

func TestUnitTransactionSignSwitchCases(t *testing.T) {
	t.Parallel()

	newKey, client, nodeAccountId := signSwitchCaseaSetup(t)

	txs := []Executable{
		NewAccountCreateTransaction(),
		NewAccountDeleteTransaction(),
		NewAccountUpdateTransaction(),
		NewAccountAllowanceApproveTransaction(),
		NewAccountAllowanceDeleteTransaction(),
		NewFileCreateTransaction(),
		NewFileDeleteTransaction(),
		NewFileUpdateTransaction(),
		NewLiveHashAddTransaction(),
		NewLiveHashDeleteTransaction(),
		NewTokenAssociateTransaction(),
		NewTokenBurnTransaction(),
		NewTokenCreateTransaction(),
		NewTokenDeleteTransaction(),
		NewTokenDissociateTransaction(),
		NewTokenFeeScheduleUpdateTransaction(),
		NewTokenFreezeTransaction(),
		NewTokenGrantKycTransaction(),
		NewTokenMintTransaction(),
		NewTokenRevokeKycTransaction(),
		NewTokenUnfreezeTransaction(),
		NewTokenUpdateTransaction(),
		NewTokenWipeTransaction(),
		NewTopicCreateTransaction(),
		NewTopicDeleteTransaction(),
		NewTopicUpdateTransaction(),
		NewTransferTransaction(),
	}

	for _, tx := range txs {

		txVal, signature, transferTxBytes := signSwitchCaseaHelper(t, tx, newKey, client)

		signTests := signTestsForTransaction(txVal, newKey, signature, client)

		for _, tt := range signTests {
			t.Run(tt.name, func(t *testing.T) {
				transactionInterface, err := TransactionFromBytes(transferTxBytes)
				require.NoError(t, err)

				tx, err := tt.sign(transactionInterface, newKey)
				assert.NoError(t, err)
				assert.NotEmpty(t, tx)

				signs, err := TransactionGetSignatures(transactionInterface)
				assert.NoError(t, err)

				// verify with range because var signs = map[AccountID]map[*PublicKey][]byte, where *PublicKey is unknown memory address
				for key := range signs[nodeAccountId] {
					assert.Equal(t, signs[nodeAccountId][key], signature)
				}
			})
		}
	}
}

func TestUnitTransactionSignSwitchCasesPointers(t *testing.T) {
	t.Parallel()

	newKey, client, nodeAccountId := signSwitchCaseaSetup(t)

	txs := []interface{}{
		NewAccountCreateTransaction(),
		NewAccountDeleteTransaction(),
		NewAccountUpdateTransaction(),
		NewAccountAllowanceApproveTransaction(),
		NewAccountAllowanceDeleteTransaction(),
		NewFileCreateTransaction(),
		NewFileDeleteTransaction(),
		NewFileUpdateTransaction(),
		NewLiveHashAddTransaction(),
		NewLiveHashDeleteTransaction(),
		NewTokenAssociateTransaction(),
		NewTokenBurnTransaction(),
		NewTokenCreateTransaction(),
		NewTokenDeleteTransaction(),
		NewTokenDissociateTransaction(),
		NewTokenFeeScheduleUpdateTransaction(),
		NewTokenFreezeTransaction(),
		NewTokenGrantKycTransaction(),
		NewTokenMintTransaction(),
		NewTokenRevokeKycTransaction(),
		NewTokenUnfreezeTransaction(),
		NewTokenUpdateTransaction(),
		NewTokenWipeTransaction(),
		NewTopicCreateTransaction(),
		NewTopicDeleteTransaction(),
		NewTopicUpdateTransaction(),
		NewTransferTransaction(),
	}

	for _, tx := range txs {

		txVal, signature, transferTxBytes := signSwitchCaseaHelper(t, tx, newKey, client)
		signTests := signTestsForTransaction(txVal, newKey, signature, client)

		for _, tt := range signTests {
			t.Run(tt.name, func(t *testing.T) {
				transactionInterface, err := TransactionFromBytes(transferTxBytes)
				require.NoError(t, err)

				// Convert the transactionInterface to a pointer
				ptr := reflect.New(reflect.TypeOf(transactionInterface))
				ptr.Elem().Set(reflect.ValueOf(transactionInterface))

				tx, err := tt.sign(ptr.Interface(), newKey)
				assert.NoError(t, err)
				assert.NotEmpty(t, tx)

				signs, err := TransactionGetSignatures(ptr.Interface())
				assert.NoError(t, err)

				// verify with range because var signs = map[AccountID]map[*PublicKey][]byte, where *PublicKey is unknown memory address
				for key := range signs[nodeAccountId] {
					assert.Equal(t, signs[nodeAccountId][key], signature)
				}
			})
		}
	}
}

func TestUnitTransactionAttributes(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.SetLedgerID(*NewLedgerIDTestnet())
	nodeAccountIds := client.network._GetNodeAccountIDsForExecute()

	txs := []interface{}{
		NewAccountCreateTransaction(),
		NewAccountDeleteTransaction(),
		NewAccountUpdateTransaction(),
		NewAccountAllowanceApproveTransaction(),
		NewAccountAllowanceDeleteTransaction(),
		NewContractCreateTransaction(),
		NewContractDeleteTransaction(),
		NewContractExecuteTransaction(),
		NewContractUpdateTransaction(),
		NewFileAppendTransaction(),
		NewFileCreateTransaction(),
		NewFileDeleteTransaction(),
		NewFileUpdateTransaction(),
		NewLiveHashAddTransaction(),
		NewLiveHashDeleteTransaction(),
		NewScheduleCreateTransaction(),
		NewScheduleDeleteTransaction(),
		NewScheduleSignTransaction(),
		NewSystemDeleteTransaction(),
		NewSystemUndeleteTransaction(),
		NewTokenAssociateTransaction(),
		NewTokenBurnTransaction(),
		NewTokenCreateTransaction(),
		NewTokenDeleteTransaction(),
		NewTokenDissociateTransaction(),
		NewTokenFeeScheduleUpdateTransaction(),
		NewTokenFreezeTransaction(),
		NewTokenGrantKycTransaction(),
		NewTokenMintTransaction(),
		NewTokenRevokeKycTransaction(),
		NewTokenUnfreezeTransaction(),
		NewTokenUpdateTransaction(),
		NewTokenWipeTransaction(),
		NewTopicCreateTransaction(),
		NewTopicDeleteTransaction(),
		NewTopicUpdateTransaction(),
		NewTransferTransaction(),
	}

	for _, tx := range txs {
		txName := reflect.TypeOf(tx).Elem().Name()

		tests := createTransactionTests(txName, nodeAccountIds)

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				txSet, err := tt.set(tx)
				require.NoError(t, err)

				txGet, err := tt.get(txSet)
				require.NoError(t, err)

				tt.assert(t, txGet)
			})
		}
	}
}

func TestUnitTransactionAttributesDereferanced(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.SetLedgerID(*NewLedgerIDTestnet())
	nodeAccountIds := client.network._GetNodeAccountIDsForExecute()

	txs := []interface{}{
		NewAccountCreateTransaction(),
		NewAccountDeleteTransaction(),
		NewAccountUpdateTransaction(),
		NewAccountAllowanceApproveTransaction(),
		NewAccountAllowanceDeleteTransaction(),
		NewContractCreateTransaction(),
		NewContractDeleteTransaction(),
		NewContractExecuteTransaction(),
		NewContractUpdateTransaction(),
		NewFileAppendTransaction(),
		NewFileCreateTransaction(),
		NewFileDeleteTransaction(),
		NewFileUpdateTransaction(),
		NewLiveHashAddTransaction(),
		NewLiveHashDeleteTransaction(),
		NewScheduleCreateTransaction(),
		NewScheduleDeleteTransaction(),
		NewScheduleSignTransaction(),
		NewSystemDeleteTransaction(),
		NewSystemUndeleteTransaction(),
		NewTokenAssociateTransaction(),
		NewTokenBurnTransaction(),
		NewTokenCreateTransaction(),
		NewTokenDeleteTransaction(),
		NewTokenDissociateTransaction(),
		NewTokenFeeScheduleUpdateTransaction(),
		NewTokenFreezeTransaction(),
		NewTokenGrantKycTransaction(),
		NewTokenMintTransaction(),
		NewTokenRevokeKycTransaction(),
		NewTokenUnfreezeTransaction(),
		NewTokenUpdateTransaction(),
		NewTokenWipeTransaction(),
		NewTopicCreateTransaction(),
		NewTopicDeleteTransaction(),
		NewTopicUpdateTransaction(),
		NewTransferTransaction(),
	}

	for _, tx := range txs {
		txName := reflect.TypeOf(tx).Elem().Name()

		tests := createTransactionTests(txName, nodeAccountIds)

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				txValue := reflect.ValueOf(tx).Elem().Interface()
				txSet, err := tt.set(txValue)
				require.NoError(t, err)

				txGet, err := tt.get(txSet)
				require.NoError(t, err)

				tt.assert(t, txGet)
			})
		}
	}
}

func TestUnitTransactionAttributesSerialization(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.SetLedgerID(*NewLedgerIDTestnet())

	txs := []interface{}{
		NewAccountCreateTransaction(),
		NewAccountDeleteTransaction(),
		NewAccountUpdateTransaction(),
		NewAccountAllowanceApproveTransaction(),
		NewAccountAllowanceDeleteTransaction(),
		NewContractCreateTransaction(),
		NewContractDeleteTransaction(),
		NewContractExecuteTransaction(),
		NewContractUpdateTransaction(),
		NewFileCreateTransaction(),
		NewFileDeleteTransaction(),
		NewFileUpdateTransaction(),
		NewLiveHashAddTransaction(),
		NewLiveHashDeleteTransaction(),
		NewScheduleCreateTransaction(),
		NewScheduleDeleteTransaction(),
		NewScheduleSignTransaction(),
		NewSystemDeleteTransaction(),
		NewSystemUndeleteTransaction(),
		NewTokenAssociateTransaction(),
		NewTokenBurnTransaction(),
		NewTokenCreateTransaction(),
		NewTokenDeleteTransaction(),
		NewTokenDissociateTransaction(),
		NewTokenFeeScheduleUpdateTransaction(),
		NewTokenFreezeTransaction(),
		NewTokenGrantKycTransaction(),
		NewTokenMintTransaction(),
		NewTokenRevokeKycTransaction(),
		NewTokenUnfreezeTransaction(),
		NewTokenUpdateTransaction(),
		NewTokenWipeTransaction(),
		NewTopicCreateTransaction(),
		NewTopicDeleteTransaction(),
		NewTopicUpdateTransaction(),
		NewTransferTransaction(),
	}

	for _, tx := range txs {
		txName := reflect.TypeOf(tx).Elem().Name()

		// Get the reflect.Value of the pointer to the Transaction
		txPtr := reflect.ValueOf(tx)
		txPtr.MethodByName("FreezeWith").Call([]reflect.Value{reflect.ValueOf(client)})

		tests := []struct {
			name string
			act  func(transactionInterface interface{})
		}{
			{
				name: "TransactionString/" + txName,
				act: func(transactionInterface interface{}) {
					txString, err := TransactionString(transactionInterface)
					require.NoError(t, err)
					require.NotEmpty(t, txString)
				},
			},
			{
				name: "TransactionToBytes/" + txName,
				act: func(transactionInterface interface{}) {
					txBytes, err := TransactionToBytes(transactionInterface)
					require.NoError(t, err)
					require.NotEmpty(t, txBytes)
				},
			},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				tt.act(tx)
				txValue := reflect.ValueOf(tx).Elem().Interface()
				tt.act(txValue)
			})
		}
	}
}

func signSwitchCaseaSetup(t *testing.T) (PrivateKey, *Client, AccountID) {
	newKey, err := GeneratePrivateKey()
	require.NoError(t, err)

	client, err := _NewMockClient()
	require.NoError(t, err)
	client.SetLedgerID(*NewLedgerIDTestnet())

	nodeAccountIds := client.network._GetNodeAccountIDsForExecute()
	nodeAccountId := nodeAccountIds[0]

	return newKey, client, nodeAccountId
}

func signSwitchCaseaHelper(t *testing.T, tx interface{}, newKey PrivateKey, client *Client) (txVal reflect.Value, signature []byte, transferTxBytes []byte) {
	// Get the reflect.Value of the pointer to the transaction
	txPtr := reflect.ValueOf(tx)
	txPtr.MethodByName("FreezeWith").Call([]reflect.Value{reflect.ValueOf(client)})

	// Get the reflect.Value of the transaction
	txVal = txPtr.Elem()

	// Get the transaction field by name
	txField := txVal.FieldByName("Transaction")

	// Get the value of the Transaction field
	txValue := txField.Interface().(Transaction)

	refl_signature := reflect.ValueOf(newKey).MethodByName("SignTransaction").Call([]reflect.Value{reflect.ValueOf(&txValue)})
	signature = refl_signature[0].Interface().([]byte)

	transferTxBytes, err := TransactionToBytes(tx)
	assert.NoError(t, err)
	assert.NotEmpty(t, transferTxBytes)

	return txVal, signature, transferTxBytes
}

func signTestsForTransaction(txVal reflect.Value, newKey PrivateKey, signature []byte, client *Client) []struct {
	name string
	sign func(transactionInterface interface{}, key Key) (interface{}, error)
} {
	return []struct {
		name string
		sign func(transactionInterface interface{}, key Key) (interface{}, error)
	}{
		{
			name: "TransactionSign/" + txVal.Type().Name(),
			sign: func(transactionInterface interface{}, key Key) (interface{}, error) {
				privateKey, ok := key.(PrivateKey)
				if !ok {
					panic("key is not a PrivateKey")
				}
				return TransactionSign(transactionInterface, privateKey)
			},
		},
		{
			name: "TransactionSignWith/" + txVal.Type().Name(),
			sign: func(transactionInterface interface{}, key Key) (interface{}, error) {
				return TransactionSignWth(transactionInterface, newKey.PublicKey(), newKey.Sign)
			},
		},
		{
			name: "TransactionSignWithOperator/" + txVal.Type().Name(),
			sign: func(transactionInterface interface{}, key Key) (interface{}, error) {
				return TransactionSignWithOperator(transactionInterface, client)
			},
		},
		{
			name: "TransactionAddSignature/" + txVal.Type().Name(),
			sign: func(transactionInterface interface{}, key Key) (interface{}, error) {
				return TransactionAddSignature(transactionInterface, newKey.PublicKey(), signature)
			},
		},
	}
}

type transactionTest struct {
	name   string
	set    func(transactionInterface interface{}) (interface{}, error)
	get    func(transactionInterface interface{}) (interface{}, error)
	assert func(t *testing.T, actual interface{})
}

func createTransactionTests(txName string, nodeAccountIds []AccountID) []transactionTest {
	return []transactionTest{
		{
			name: "TransactionTransactionID/" + txName,
			set: func(transactionInterface interface{}) (interface{}, error) {
				transactionID := TransactionID{AccountID: &AccountID{Account: 9999}, ValidStart: &time.Time{}, scheduled: false, Nonce: nil}
				return TransactionSetTransactionID(transactionInterface, transactionID)
			},
			get: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionGetTransactionID(transactionInterface)
			},
			assert: func(t *testing.T, actual interface{}) {
				transactionID := TransactionID{AccountID: &AccountID{Account: 9999}, ValidStart: &time.Time{}, scheduled: false, Nonce: nil}
				A := actual.(TransactionID)

				require.Equal(t, transactionID.AccountID, A.AccountID)
			},
		},
		{
			name: "TransactionTransactionMemo/" + txName,
			set: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionSetTransactionMemo(transactionInterface, "test memo")
			},
			get: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionGetTransactionMemo(transactionInterface)
			},
			assert: func(t *testing.T, actual interface{}) {
				require.Equal(t, "test memo", actual)
			},
		},
		{
			name: "TransactionMaxTransactionFee/" + txName,
			set: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionSetMaxTransactionFee(transactionInterface, NewHbar(1))
			},
			get: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionGetMaxTransactionFee(transactionInterface)
			},
			assert: func(t *testing.T, actual interface{}) {
				require.Equal(t, NewHbar(1), actual)
			},
		},
		{
			name: "TransactionTransactionValidDuration/" + txName,
			set: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionSetTransactionValidDuration(transactionInterface, time.Second*10)
			},
			get: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionGetTransactionValidDuration(transactionInterface)
			},
			assert: func(t *testing.T, actual interface{}) {
				require.Equal(t, time.Second*10, actual)
			},
		},
		{
			name: "TransactionNodeAccountIDs/" + txName,
			set: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionSetNodeAccountIDs(transactionInterface, nodeAccountIds)
			},
			get: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionGetNodeAccountIDs(transactionInterface)
			},
			assert: func(t *testing.T, actual interface{}) {
				require.Equal(t, nodeAccountIds, actual)
			},
		},
		{
			name: "TransactionMinBackoff/" + txName,
			set: func(transactionInterface interface{}) (interface{}, error) {
				tx, _ := TransactionSetMaxBackoff(transactionInterface, time.Second*200)
				return TransactionSetMinBackoff(tx, time.Second*10)
			},
			get: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionGetMinBackoff(transactionInterface)
			},
			assert: func(t *testing.T, actual interface{}) {
				require.Equal(t, time.Second*10, actual)
			},
		},
		{
			name: "TransactionMaxBackoff/" + txName,
			set: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionSetMaxBackoff(transactionInterface, time.Second*200)
			},
			get: func(transactionInterface interface{}) (interface{}, error) {
				return TransactionGetMaxBackoff(transactionInterface)
			},
			assert: func(t *testing.T, actual interface{}) {
				require.Equal(t, time.Second*200, actual)
			},
		},
	}
}

// TransactionGetTransactionHash //needs to be tested in e2e tests
// TransactionGetTransactionHashPerNode //needs to be tested in e2e tests
// TransactionExecute //needs to be tested in e2e tests
// Filename: transfer.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"github.com/hashgraph/hedera-protobufs-go/services"
)

// Transfer is a transfer of hbars or tokens from one account to another
type Transfer struct {
	AccountID  AccountID
	Amount     Hbar
	IsApproved bool
}

func _TransferFromProtobuf(pb *services.AccountAmount) Transfer {
	if pb == nil {
		return Transfer{}
	}

	accountID := AccountID{}
	if pb.AccountID != nil {
		accountID = *_AccountIDFromProtobuf(pb.AccountID)
	}

	return Transfer{
		AccountID:  accountID,
		Amount:     HbarFromTinybar(pb.Amount),
		IsApproved: pb.GetIsApproval(),
	}
}

func (transfer Transfer) _ToProtobuf() *services.TransferList { // nolint
	var ammounts = make([]*services.AccountAmount, 0)
	ammounts = append(ammounts, &services.AccountAmount{
		AccountID: transfer.AccountID._ToProtobuf(),
		Amount:    transfer.Amount.AsTinybar(),
	})

	return &services.TransferList{
		AccountAmounts: ammounts,
	}
}
// Filename: transfer_transaction.go
package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"time"

	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/hashgraph/hedera-protobufs-go/services"
)

// TransferTransaction
// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their
// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn
// from the corresponding account (a sender), and each positive one is added to the corresponding
// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars
// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient
// hbars, then the entire transaction fails, and none of those transfers occur, though the
// transaction fee is still charged. This transaction must be signed by the keys for all the sending
// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures
// are in the same order as the accounts, skipping those accounts that don't need a signature.
type TransferTransaction struct {
	Transaction
	tokenTransfers map[TokenID]*_TokenTransfer
	hbarTransfers  []*_HbarTransfer
	nftTransfers   map[TokenID][]*_TokenNftTransfer
}

// NewTransferTransaction creates TransferTransaction which
// transfers cryptocurrency among two or more accounts by making the desired adjustments to their
// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn
// from the corresponding account (a sender), and each positive one is added to the corresponding
// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars
// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient
// hbars, then the entire transaction fails, and none of those transfers occur, though the
// transaction fee is still charged. This transaction must be signed by the keys for all the sending
// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures
// are in the same order as the accounts, skipping those accounts that don't need a signature.
func NewTransferTransaction() *TransferTransaction {
	tx := TransferTransaction{
		Transaction:    _NewTransaction(),
		tokenTransfers: make(map[TokenID]*_TokenTransfer),
		hbarTransfers:  make([]*_HbarTransfer, 0),
		nftTransfers:   make(map[TokenID][]*_TokenNftTransfer),
	}

	tx._SetDefaultMaxTransactionFee(NewHbar(1))

	return &tx
}

func _TransferTransactionFromProtobuf(tx Transaction, pb *services.TransactionBody) *TransferTransaction {
	tokenTransfers := make(map[TokenID]*_TokenTransfer)
	nftTransfers := make(map[TokenID][]*_TokenNftTransfer)

	for _, tokenTransfersList := range pb.GetCryptoTransfer().GetTokenTransfers() {
		tok := _TokenIDFromProtobuf(tokenTransfersList.Token)
		tokenTransfers[*tok] = _TokenTransferPrivateFromProtobuf(tokenTransfersList)
	}

	for _, tokenTransfersList := range pb.GetCryptoTransfer().GetTokenTransfers() {
		if tokenID := _TokenIDFromProtobuf(tokenTransfersList.Token); tokenID != nil {
			for _, aa := range tokenTransfersList.GetNftTransfers() {
				if nftTransfers[*tokenID] == nil {
					nftTransfers[*tokenID] = make([]*_TokenNftTransfer, 0)
				}
				nftTransfer := _NftTransferFromProtobuf(aa)
				nftTransfers[*tokenID] = append(nftTransfers[*tokenID], &nftTransfer)
			}
		}
	}

	return &TransferTransaction{
		Transaction:    tx,
		hbarTransfers:  _HbarTransferFromProtobuf(pb.GetCryptoTransfer().GetTransfers().GetAccountAmounts()),
		tokenTransfers: tokenTransfers,
		nftTransfers:   nftTransfers,
	}
}

// SetTokenTransferApproval Sets the desired token unit balance adjustments
func (tx *TransferTransaction) SetTokenTransferApproval(tokenID TokenID, accountID AccountID, approval bool) *TransferTransaction { //nolint
	for token, tokenTransfer := range tx.tokenTransfers {
		if token.Compare(tokenID) == 0 {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID.Compare(accountID) == 0 {
					transfer.IsApproved = approval
				}
			}
		}
	}

	return tx
}

// SetHbarTransferApproval Sets the desired hbar balance adjustments
func (tx *TransferTransaction) SetHbarTransferApproval(spenderAccountID AccountID, approval bool) *TransferTransaction { //nolint
	for _, k := range tx.hbarTransfers {
		if k.accountID.String() == spenderAccountID.String() {
			k.IsApproved = approval
		}
	}
	return tx
}

// SetNftTransferApproval Sets the desired nft token unit balance adjustments
func (tx *TransferTransaction) SetNftTransferApproval(nftID NftID, approval bool) *TransferTransaction {
	for token, nftTransfers := range tx.nftTransfers {
		if token.Compare(nftID.TokenID) == 0 {
			for _, nftTransfer := range nftTransfers {
				if nftTransfer.SerialNumber == nftID.SerialNumber {
					nftTransfer.IsApproved = approval
				}
			}
		}
	}
	return tx
}

// GetNftTransfers returns the nft transfers
func (tx *TransferTransaction) GetNftTransfers() map[TokenID][]_TokenNftTransfer {
	nftResult := make(map[TokenID][]_TokenNftTransfer)
	for token, nftTransfers := range tx.nftTransfers {
		tempArray := make([]_TokenNftTransfer, 0)
		for _, nftTransfer := range nftTransfers {
			tempArray = append(tempArray, *nftTransfer)
		}

		nftResult[token] = tempArray
	}

	return nftResult
}

// GetTokenTransfers returns the token transfers
func (tx *TransferTransaction) GetTokenTransfers() map[TokenID][]TokenTransfer {
	transfers := make(map[TokenID][]TokenTransfer)
	for tokenID, tokenTransfers := range tx.tokenTransfers {
		tokenTransfersList := make([]TokenTransfer, 0)

		for _, transfer := range tokenTransfers.Transfers {
			var acc AccountID
			if transfer.accountID != nil {
				acc = *transfer.accountID
			}
			tokenTransfersList = append(tokenTransfersList, TokenTransfer{
				AccountID:  acc,
				Amount:     transfer.Amount.AsTinybar(),
				IsApproved: transfer.IsApproved,
			})
		}

		tempTokenTransferList := _TokenTransfers{tokenTransfersList}

		transfers[tokenID] = tempTokenTransferList.transfers
	}

	return transfers
}

// GetHbarTransfers returns the hbar transfers
func (tx *TransferTransaction) GetHbarTransfers() map[AccountID]Hbar {
	result := make(map[AccountID]Hbar)
	for _, hbarTransfers := range tx.hbarTransfers {
		result[*hbarTransfers.accountID] = hbarTransfers.Amount
	}
	return result
}

// AddHbarTransfer Sets The desired hbar balance adjustments
func (tx *TransferTransaction) AddHbarTransfer(accountID AccountID, amount Hbar) *TransferTransaction {
	tx._RequireNotFrozen()

	for _, transfer := range tx.hbarTransfers {
		if transfer.accountID.Compare(accountID) == 0 {
			transfer.Amount = HbarFromTinybar(amount.AsTinybar() + transfer.Amount.AsTinybar())
			return tx
		}
	}

	tx.hbarTransfers = append(tx.hbarTransfers, &_HbarTransfer{
		accountID:  &accountID,
		Amount:     amount,
		IsApproved: false,
	})

	return tx
}

// GetTokenIDDecimals returns the token decimals
func (tx *TransferTransaction) GetTokenIDDecimals() map[TokenID]uint32 {
	result := make(map[TokenID]uint32)
	for token, tokenTransfer := range tx.tokenTransfers {
		if tokenTransfer.ExpectedDecimals != nil {
			result[token] = *tokenTransfer.ExpectedDecimals
		}
	}
	return result
}

// AddTokenTransferWithDecimals Sets the desired token unit balance adjustments with decimals
func (tx *TransferTransaction) AddTokenTransferWithDecimals(tokenID TokenID, accountID AccountID, value int64, decimal uint32) *TransferTransaction { //nolint
	tx._RequireNotFrozen()

	for token, tokenTransfer := range tx.tokenTransfers {
		if token.Compare(tokenID) == 0 {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID.Compare(accountID) == 0 {
					transfer.Amount = HbarFromTinybar(transfer.Amount.AsTinybar() + value)
					tokenTransfer.ExpectedDecimals = &decimal

					return tx
				}
			}
		}
	}

	if v, ok := tx.tokenTransfers[tokenID]; ok {
		v.Transfers = append(v.Transfers, &_HbarTransfer{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: false,
		})
		v.ExpectedDecimals = &decimal

		return tx
	}

	tx.tokenTransfers[tokenID] = &_TokenTransfer{
		Transfers: []*_HbarTransfer{{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: false,
		}},
		ExpectedDecimals: &decimal,
	}

	return tx
}

// AddTokenTransfer Sets the desired token unit balance adjustments
// Applicable to tokens of type FUNGIBLE_COMMON.
func (tx *TransferTransaction) AddTokenTransfer(tokenID TokenID, accountID AccountID, value int64) *TransferTransaction { //nolint
	tx._RequireNotFrozen()

	for token, tokenTransfer := range tx.tokenTransfers {
		if token.Compare(tokenID) == 0 {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID.Compare(accountID) == 0 {
					transfer.Amount = HbarFromTinybar(transfer.Amount.AsTinybar() + value)

					return tx
				}
			}
		}
	}

	if v, ok := tx.tokenTransfers[tokenID]; ok {
		v.Transfers = append(v.Transfers, &_HbarTransfer{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: false,
		})

		return tx
	}

	tx.tokenTransfers[tokenID] = &_TokenTransfer{
		Transfers: []*_HbarTransfer{{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: false,
		}},
	}

	return tx
}

// AddNftTransfer Sets the desired nft token unit balance adjustments
// Applicable to tokens of type NON_FUNGIBLE_UNIQUE.
func (tx *TransferTransaction) AddNftTransfer(nftID NftID, sender AccountID, receiver AccountID) *TransferTransaction {
	tx._RequireNotFrozen()

	if tx.nftTransfers == nil {
		tx.nftTransfers = make(map[TokenID][]*_TokenNftTransfer)
	}

	if tx.nftTransfers[nftID.TokenID] == nil {
		tx.nftTransfers[nftID.TokenID] = make([]*_TokenNftTransfer, 0)
	}

	tx.nftTransfers[nftID.TokenID] = append(tx.nftTransfers[nftID.TokenID], &_TokenNftTransfer{
		SenderAccountID:   sender,
		ReceiverAccountID: receiver,
		SerialNumber:      nftID.SerialNumber,
	})

	return tx
}

// AddHbarTransferWithDecimals adds an approved hbar transfer
func (tx *TransferTransaction) AddApprovedHbarTransfer(accountID AccountID, amount Hbar, approve bool) *TransferTransaction {
	tx._RequireNotFrozen()

	for _, transfer := range tx.hbarTransfers {
		if transfer.accountID.Compare(accountID) == 0 {
			transfer.Amount = HbarFromTinybar(amount.AsTinybar() + transfer.Amount.AsTinybar())
			transfer.IsApproved = approve
			return tx
		}
	}

	tx.hbarTransfers = append(tx.hbarTransfers, &_HbarTransfer{
		accountID:  &accountID,
		Amount:     amount,
		IsApproved: approve,
	})

	return tx
}

// AddHbarTransfer adds an approved hbar transfer with decimals
func (tx *TransferTransaction) AddApprovedTokenTransferWithDecimals(tokenID TokenID, accountID AccountID, value int64, decimal uint32, approve bool) *TransferTransaction { //nolint
	tx._RequireNotFrozen()

	for token, tokenTransfer := range tx.tokenTransfers {
		if token.Compare(tokenID) == 0 {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID.Compare(accountID) == 0 {
					transfer.Amount = HbarFromTinybar(transfer.Amount.AsTinybar() + value)
					tokenTransfer.ExpectedDecimals = &decimal
					for _, transfer := range tokenTransfer.Transfers {
						transfer.IsApproved = approve
					}

					return tx
				}
			}
		}
	}

	if v, ok := tx.tokenTransfers[tokenID]; ok {
		v.Transfers = append(v.Transfers, &_HbarTransfer{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: approve,
		})
		v.ExpectedDecimals = &decimal

		return tx
	}

	tx.tokenTransfers[tokenID] = &_TokenTransfer{
		Transfers: []*_HbarTransfer{{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: approve,
		}},
		ExpectedDecimals: &decimal,
	}

	return tx
}

// AddHbarTransfer adds an approved hbar transfer
func (tx *TransferTransaction) AddApprovedTokenTransfer(tokenID TokenID, accountID AccountID, value int64, approve bool) *TransferTransaction { //nolint
	tx._RequireNotFrozen()

	for token, tokenTransfer := range tx.tokenTransfers {
		if token.Compare(tokenID) == 0 {
			for _, transfer := range tokenTransfer.Transfers {
				if transfer.accountID.Compare(accountID) == 0 {
					transfer.Amount = HbarFromTinybar(transfer.Amount.AsTinybar() + value)
					transfer.IsApproved = approve

					return tx
				}
			}
		}
	}

	if v, ok := tx.tokenTransfers[tokenID]; ok {
		v.Transfers = append(v.Transfers, &_HbarTransfer{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: approve,
		})

		return tx
	}

	tx.tokenTransfers[tokenID] = &_TokenTransfer{
		Transfers: []*_HbarTransfer{{
			accountID:  &accountID,
			Amount:     HbarFromTinybar(value),
			IsApproved: approve,
		}},
	}

	return tx
}

// AddNftTransfer adds an approved nft transfer
func (tx *TransferTransaction) AddApprovedNftTransfer(nftID NftID, sender AccountID, receiver AccountID, approve bool) *TransferTransaction {
	tx._RequireNotFrozen()

	if tx.nftTransfers == nil {
		tx.nftTransfers = make(map[TokenID][]*_TokenNftTransfer)
	}

	if tx.nftTransfers[nftID.TokenID] == nil {
		tx.nftTransfers[nftID.TokenID] = make([]*_TokenNftTransfer, 0)
	}

	tx.nftTransfers[nftID.TokenID] = append(tx.nftTransfers[nftID.TokenID], &_TokenNftTransfer{
		SenderAccountID:   sender,
		ReceiverAccountID: receiver,
		SerialNumber:      nftID.SerialNumber,
		IsApproved:        approve,
	})

	return tx
}

// ---- Required Interfaces ---- //

// Sign uses the provided privateKey to sign the transaction.
func (tx *TransferTransaction) Sign(privateKey PrivateKey) *TransferTransaction {
	tx.Transaction.Sign(privateKey)
	return tx
}

// SignWithOperator signs the transaction with client's operator privateKey.
func (tx *TransferTransaction) SignWithOperator(client *Client) (*TransferTransaction, error) {
	_, err := tx.Transaction.signWithOperator(client, tx)
	if err != nil {
		return nil, err
	}
	return tx, nil
}

// SignWith executes the TransactionSigner and adds the resulting signature data to the Transaction's signature map
// with the publicKey as the map key.
func (tx *TransferTransaction) SignWith(
	publicKey PublicKey,
	signer TransactionSigner,
) *TransferTransaction {
	tx.Transaction.SignWith(publicKey, signer)
	return tx
}

// AddSignature adds a signature to the transaction.
func (tx *TransferTransaction) AddSignature(publicKey PublicKey, signature []byte) *TransferTransaction {
	tx.Transaction.AddSignature(publicKey, signature)
	return tx
}

// When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may subsequently retry the execution.)
func (tx *TransferTransaction) SetGrpcDeadline(deadline *time.Duration) *TransferTransaction {
	tx.Transaction.SetGrpcDeadline(deadline)
	return tx
}

func (tx *TransferTransaction) Freeze() (*TransferTransaction, error) {
	return tx.FreezeWith(nil)
}

func (tx *TransferTransaction) FreezeWith(client *Client) (*TransferTransaction, error) {
	_, err := tx.Transaction.freezeWith(client, tx)
	return tx, err
}

// SetMaxTransactionFee sets the max transaction fee for this TransferTransaction.
func (tx *TransferTransaction) SetMaxTransactionFee(fee Hbar) *TransferTransaction {
	tx.Transaction.SetMaxTransactionFee(fee)
	return tx
}

// SetRegenerateTransactionID sets if transaction IDs should be regenerated when `TRANSACTION_EXPIRED` is received
func (tx *TransferTransaction) SetRegenerateTransactionID(regenerateTransactionID bool) *TransferTransaction {
	tx.Transaction.SetRegenerateTransactionID(regenerateTransactionID)
	return tx
}

// SetTransactionMemo sets the memo for this TransferTransaction.
func (tx *TransferTransaction) SetTransactionMemo(memo string) *TransferTransaction {
	tx.Transaction.SetTransactionMemo(memo)
	return tx
}

// SetTransactionValidDuration sets the valid duration for this TransferTransaction.
func (tx *TransferTransaction) SetTransactionValidDuration(duration time.Duration) *TransferTransaction {
	tx.Transaction.SetTransactionValidDuration(duration)
	return tx
}

// ToBytes serialise the tx to bytes, no matter if it is signed (locked), or not
func (tx *TransferTransaction) ToBytes() ([]byte, error) {
	bytes, err := tx.Transaction.toBytes(tx)
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

// SetTransactionID sets the TransactionID for this TransferTransaction.
func (tx *TransferTransaction) SetTransactionID(transactionID TransactionID) *TransferTransaction {
	tx.Transaction.SetTransactionID(transactionID)
	return tx
}

// SetNodeAccountIDs sets the _Node AccountID for this TransferTransaction.
func (tx *TransferTransaction) SetNodeAccountIDs(nodeID []AccountID) *TransferTransaction {
	tx.Transaction.SetNodeAccountIDs(nodeID)
	return tx
}

// SetMaxRetry sets the max number of errors before execution will fail.
func (tx *TransferTransaction) SetMaxRetry(count int) *TransferTransaction {
	tx.Transaction.SetMaxRetry(count)
	return tx
}

// SetMaxBackoff The maximum amount of time to wait between retries.
// Every retry attempt will increase the wait time exponentially until it reaches this time.
func (tx *TransferTransaction) SetMaxBackoff(max time.Duration) *TransferTransaction {
	tx.Transaction.SetMaxBackoff(max)
	return tx
}

// SetMinBackoff sets the minimum amount of time to wait between retries.
func (tx *TransferTransaction) SetMinBackoff(min time.Duration) *TransferTransaction {
	tx.Transaction.SetMinBackoff(min)
	return tx
}

func (tx *TransferTransaction) SetLogLevel(level LogLevel) *TransferTransaction {
	tx.Transaction.SetLogLevel(level)
	return tx
}

func (tx *TransferTransaction) Execute(client *Client) (TransactionResponse, error) {
	return tx.Transaction.execute(client, tx)
}

func (tx *TransferTransaction) Schedule() (*ScheduleCreateTransaction, error) {
	return tx.Transaction.schedule(tx)
}

// ----------- Overridden functions ----------------

func (tx *TransferTransaction) getName() string {
	return "TransferTransaction"
}

func (tx *TransferTransaction) validateNetworkOnIDs(client *Client) error {
	if client == nil || !client.autoValidateChecksums {
		return nil
	}
	var err error
	for token, tokenTransfer := range tx.tokenTransfers {
		err = token.ValidateChecksum(client)
		if err != nil {
			return err
		}
		for _, transfer := range tokenTransfer.Transfers {
			err = transfer.accountID.ValidateChecksum(client)
			if err != nil {
				return err
			}
		}
		if err != nil {
			return err
		}
	}
	for token, nftTransfers := range tx.nftTransfers {
		err = token.ValidateChecksum(client)
		if err != nil {
			return err
		}
		for _, nftTransfer := range nftTransfers {
			err = nftTransfer.SenderAccountID.ValidateChecksum(client)
			if err != nil {
				return err
			}
			err = nftTransfer.ReceiverAccountID.ValidateChecksum(client)
			if err != nil {
				return err
			}
		}
	}
	for _, hbarTransfer := range tx.hbarTransfers {
		err = hbarTransfer.accountID.ValidateChecksum(client)
		if err != nil {
			return err
		}
	}

	return nil
}

func (tx *TransferTransaction) build() *services.TransactionBody {
	return &services.TransactionBody{
		TransactionFee:           tx.transactionFee,
		Memo:                     tx.Transaction.memo,
		TransactionValidDuration: _DurationToProtobuf(tx.GetTransactionValidDuration()),
		TransactionID:            tx.transactionID._ToProtobuf(),
		Data: &services.TransactionBody_CryptoTransfer{
			CryptoTransfer: tx.buildProtoBody(),
		},
	}
}

func (tx *TransferTransaction) buildScheduled() (*services.SchedulableTransactionBody, error) {
	return &services.SchedulableTransactionBody{
		TransactionFee: tx.transactionFee,
		Memo:           tx.Transaction.memo,
		Data: &services.SchedulableTransactionBody_CryptoTransfer{
			CryptoTransfer: tx.buildProtoBody(),
		},
	}, nil
}

func (tx *TransferTransaction) buildProtoBody() *services.CryptoTransferTransactionBody {
	body := &services.CryptoTransferTransactionBody{
		Transfers: &services.TransferList{
			AccountAmounts: []*services.AccountAmount{},
		},
		TokenTransfers: []*services.TokenTransferList{},
	}

	if len(tx.hbarTransfers) > 0 {
		body.Transfers.AccountAmounts = make([]*services.AccountAmount, 0)
		for _, hbarTransfer := range tx.hbarTransfers {
			body.Transfers.AccountAmounts = append(body.Transfers.AccountAmounts, &services.AccountAmount{
				AccountID:  hbarTransfer.accountID._ToProtobuf(),
				Amount:     hbarTransfer.Amount.AsTinybar(),
				IsApproval: hbarTransfer.IsApproved,
			})
		}
	}

	if len(tx.tokenTransfers) > 0 {
		if body.TokenTransfers == nil {
			body.TokenTransfers = make([]*services.TokenTransferList, 0)
		}

		for tokenID := range tx.tokenTransfers {
			transfers := tx.tokenTransfers[tokenID]._ToProtobuf()

			bod := &services.TokenTransferList{
				Token:     tokenID._ToProtobuf(),
				Transfers: transfers,
			}

			if tx.tokenTransfers[tokenID].ExpectedDecimals != nil {
				bod.ExpectedDecimals = &wrapperspb.UInt32Value{Value: *tx.tokenTransfers[tokenID].ExpectedDecimals}
			}

			body.TokenTransfers = append(body.TokenTransfers, bod)
		}
	}

	if len(tx.nftTransfers) > 0 {
		if body.TokenTransfers == nil {
			body.TokenTransfers = make([]*services.TokenTransferList, 0)
		}

		for tokenID, nftTransferList := range tx.nftTransfers {
			nftTransfers := make([]*services.NftTransfer, 0)

			for _, nftT := range nftTransferList {
				nftTransfers = append(nftTransfers, nftT._ToProtobuf())
			}

			body.TokenTransfers = append(body.TokenTransfers, &services.TokenTransferList{
				Token:        tokenID._ToProtobuf(),
				NftTransfers: nftTransfers,
			})
		}
	}

	return body
}

func (tx *TransferTransaction) getMethod(channel *_Channel) _Method {
	return _Method{
		transaction: channel._GetCrypto().CryptoTransfer,
	}
}

func (this *TransferTransaction) _ConstructScheduleProtobuf() (*services.SchedulableTransactionBody, error) {
	return this.buildScheduled()
}
// Filename: transfer_transaction_e2e_test.go
//go:build all || e2e
// +build all e2e

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestIntegrationTransferTransactionCanTransferHbar(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTransferTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTransferTransactionTransferHbarNothingSet(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	resp, err := NewTransferTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTransferTransactionTransferHbarPositiveFlippedAmount(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	newBalance := NewHbar(10)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	frozen, err := NewTransferTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		AddHbarTransfer(env.Client.GetOperatorAccountID(), NewHbar(10)).
		AddHbarTransfer(accountID, NewHbar(-10)).
		SetMaxTransactionFee(NewHbar(1)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	frozen.Sign(newKey)

	resp, err = frozen.Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func DisabledTestIntegrationTransferTransactionTransferHbarLoadOf1000(t *testing.T) { // nolint
	t.Parallel()
	env := NewIntegrationTestEnv(t)
	var err error
	tx := make([]*TransferTransaction, 500)
	response := make([]TransactionResponse, len(tx))
	receipt := make([]TransactionReceipt, len(tx))

	for i := 0; i < len(tx); i++ {
		tx[i], err = NewTransferTransaction().
			AddHbarTransfer(env.Client.GetOperatorAccountID(), HbarFromTinybar(-10)).
			AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(10)).
			FreezeWith(env.Client)
		if err != nil {
			panic(err)
		}

		_, err = tx[i].SignWithOperator(env.Client)
		if err != nil {
			panic(err)
		}

		response[i], err = tx[i].Execute(env.Client)
		if err != nil {
			panic(err)
		}

		receipt[i], err = response[i].SetValidateStatus(true).GetReceipt(env.Client)
		if err != nil {
			panic(err)
		}

		fmt.Printf("\r%v", i)
	}
}

func TestIntegrationTransferTransactionCanTransferFromBytes(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := GeneratePrivateKey()
	require.NoError(t, err)

	newBalance := NewHbar(10)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	transferTx, err := NewTransferTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		AddHbarTransfer(accountID, NewHbar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, NewHbar(1)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	transferTx.Sign(newKey)

	transferTxBytes, err := transferTx.ToBytes()
	require.NoError(t, err)

	transactionInterface, err := TransactionFromBytes(transferTxBytes)
	require.NoError(t, err)

	resp, err = TransactionExecute(transactionInterface, env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTransferTransactionCanTransferFromBytesAfter(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := GeneratePrivateKey()
	require.NoError(t, err)

	newBalance := NewHbar(10)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	transferTx, err := NewTransferTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		AddHbarTransfer(accountID, NewHbar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, NewHbar(1)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	transferTxBytes, err := transferTx.ToBytes()
	require.NoError(t, err)

	transactionInterface, err := TransactionFromBytes(transferTxBytes)
	require.NoError(t, err)

	signedTx, err := TransactionSign(transactionInterface, newKey)
	require.NoError(t, err)

	resp, err = TransactionExecute(signedTx, env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTransferTransactionCanTransferSignature(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	newKey, err := GeneratePrivateKey()
	require.NoError(t, err)

	newBalance := NewHbar(10)

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(newBalance).
		Execute(env.Client)
	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	accountID := *receipt.AccountID

	transferTx, err := NewTransferTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		AddHbarTransfer(accountID, NewHbar(-1)).
		AddHbarTransfer(AccountID{Account: 3}, NewHbar(1)).
		FreezeWith(env.Client)
	require.NoError(t, err)

	transferTxBytes, err := transferTx.ToBytes()
	require.NoError(t, err)

	signature, err := newKey.SignTransaction(&transferTx.Transaction)

	transactionInterface, err := TransactionFromBytes(transferTxBytes)
	require.NoError(t, err)

	signedTx, err := TransactionAddSignature(transactionInterface, newKey.PublicKey(), signature)
	require.NoError(t, err)

	resp, err = TransactionExecute(signedTx, env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}

func TestIntegrationTransferTransactionCanTransferHbarWithAliasID(t *testing.T) {
	t.Parallel()
	env := NewIntegrationTestEnv(t)

	key, err := GeneratePrivateKey()
	require.NoError(t, err)
	aliasAccountID := key.ToAccountID(0, 0)

	resp, err := NewTransferTransaction().
		AddHbarTransfer(env.OperatorID, NewHbar(1).Negated()).
		AddHbarTransfer(*aliasAccountID, NewHbar(1)).
		Execute(env.Client)
	require.NoError(t, err)

	_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	err = CloseIntegrationTestEnv(env, nil)
	require.NoError(t, err)
}
// Filename: transfer_transaction_unit_test.go
//go:build all || unit
// +build all unit

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestUnitTransferTransactionSetTokenTransferWithDecimals(t *testing.T) {
	t.Parallel()

	tokenID := TokenID{Token: 1}
	senderAccountID := AccountID{Account: 2}
	amount := int64(10)
	decimals := uint32(5)

	transaction := NewTransferTransaction().
		AddTokenTransferWithDecimals(tokenID, senderAccountID, amount, decimals)

	require.Equal(t, transaction.GetTokenIDDecimals()[tokenID], decimals)
}

func TestUnitTransferTransactionValidate(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-esxsf")
	require.NoError(t, err)

	transfer := NewTransferTransaction().
		AddHbarTransfer(accountID, HbarFromTinybar(1))

	err = transfer.validateNetworkOnIDs(client)
	require.NoError(t, err)
}

func TestUnitTransferTransactionValidateWrong(t *testing.T) {
	t.Parallel()

	client, err := _NewMockClient()
	client.SetLedgerID(*NewLedgerIDTestnet())
	require.NoError(t, err)
	client.SetAutoValidateChecksums(true)
	accountID, err := AccountIDFromString("0.0.123-rmkykd")
	require.NoError(t, err)

	transfer := NewTransferTransaction().
		AddHbarTransfer(accountID, HbarFromTinybar(1))

	err = transfer.validateNetworkOnIDs(client)
	require.Error(t, err)
}
// Filename: utilities_for_test.go
//go:build all || unit || e2e || testnets
// +build all unit e2e testnets

package hedera

/*-
 *
 * Hedera Go SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import (
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/stretchr/testify/require"
)

var mockPrivateKey string = "302e020100300506032b6570042204203b054fade7a2b0869c6bd4a63b7017cbae7855d12acc357bea718e2c3e805962"

var accountIDForTransactionID = AccountID{Account: 3}
var validStartForTransacionID = time.Unix(124124, 151515)

var testTransactionID TransactionID = TransactionID{
	AccountID:  &accountIDForTransactionID,
	ValidStart: &validStartForTransacionID,
}

const testClientJSON string = `{
    "network": {
		"35.237.200.180:50211": "0.0.3",
		"35.186.191.247:50211": "0.0.4",
		"35.192.2.25:50211": "0.0.5",
		"35.199.161.108:50211": "0.0.6",
		"35.203.82.240:50211": "0.0.7",
		"35.236.5.219:50211": "0.0.8",
		"35.197.192.225:50211": "0.0.9",
		"35.242.233.154:50211": "0.0.10",
		"35.240.118.96:50211": "0.0.11",
		"35.204.86.32:50211": "0.0.12"
    },
    "mirrorNetwork": "testnet"
}`

type IntegrationTestEnv struct {
	Client              *Client
	OperatorKey         PrivateKey
	OperatorID          AccountID
	OriginalOperatorKey PublicKey
	OriginalOperatorID  AccountID
	NodeAccountIDs      []AccountID
}

func NewIntegrationTestEnv(t *testing.T) IntegrationTestEnv {
	var env IntegrationTestEnv
	var err error

	if os.Getenv("HEDERA_NETWORK") == "previewnet" { // nolint
		env.Client = ClientForPreviewnet()
	} else if os.Getenv("HEDERA_NETWORK") == "localhost" {
		network := make(map[string]AccountID)
		network["127.0.0.1:50213"] = AccountID{Account: 3}
		mirror := []string{"127.0.0.1:5600"}
		env.Client = ClientForNetwork(network)
		env.Client.SetMirrorNetwork(mirror)
	} else if os.Getenv("HEDERA_NETWORK") == "testnet" {
		env.Client = ClientForTestnet()
	} else if os.Getenv("CONFIG_FILE") != "" {
		env.Client, err = ClientFromConfigFile(os.Getenv("CONFIG_FILE"))
	} else {
		err = fmt.Errorf("Failed to construct client from environment variables")
	}
	require.NoError(t, err)
	assert.NotNil(t, env.Client)

	configOperatorID := os.Getenv("OPERATOR_ID")
	configOperatorKey := os.Getenv("OPERATOR_KEY")

	if configOperatorID != "" && configOperatorKey != "" {
		env.OperatorID, err = AccountIDFromString(configOperatorID)
		require.NoError(t, err)

		env.OperatorKey, err = PrivateKeyFromString(configOperatorKey)
		require.NoError(t, err)

		env.Client.SetOperator(env.OperatorID, env.OperatorKey)
	}

	assert.NotNil(t, env.Client.GetOperatorAccountID())
	assert.NotNil(t, env.Client.GetOperatorPublicKey())

	newKey, err := PrivateKeyGenerateEd25519()
	require.NoError(t, err)

	env.Client.SetMaxNodeAttempts(1)
	env.Client.SetMinBackoff(250 * time.Millisecond)
	env.Client.SetMaxBackoff(8 * time.Second)
	env.Client.SetNodeMinReadmitPeriod(5 * time.Second)
	env.Client.SetNodeMaxReadmitPeriod(1 * time.Hour)
	env.Client.SetMaxAttempts(11)
	env.Client.SetDefaultMaxTransactionFee(NewHbar(50))
	env.Client.SetDefaultMaxQueryPayment(NewHbar(50))
	logger := NewLogger("Hedera sdk", LoggerLevelError)
	env.Client.SetLogger(logger)

	env.OriginalOperatorID = env.Client.GetOperatorAccountID()
	env.OriginalOperatorKey = env.Client.GetOperatorPublicKey()

	resp, err := NewAccountCreateTransaction().
		SetKey(newKey.PublicKey()).
		SetInitialBalance(NewHbar(150)).
		SetAutoRenewPeriod(time.Hour*24*81 + time.Minute*26 + time.Second*39).
		Execute(env.Client)

	require.NoError(t, err)

	receipt, err := resp.SetValidateStatus(true).GetReceipt(env.Client)
	require.NoError(t, err)

	env.OperatorID = *receipt.AccountID
	env.OperatorKey = newKey
	env.NodeAccountIDs = []AccountID{resp.NodeID}
	env.Client.SetOperator(env.OperatorID, env.OperatorKey)

	return env
}

func CloseIntegrationTestEnv(env IntegrationTestEnv, token *TokenID) error {
	var resp TransactionResponse
	var err error
	if token != nil {
		deleteTokenTx, err := NewTokenDeleteTransaction().
			SetNodeAccountIDs(env.NodeAccountIDs).
			SetTokenID(*token).
			FreezeWith(env.Client)
		if err != nil {
			return err
		}

		resp, err = deleteTokenTx.
			Sign(env.OperatorKey).
			Execute(env.Client)
		if err != nil {
			return err
		}

		_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
		if err != nil {
			return err
		}

		// Check if env.Client.operator is nil
		if env.Client.operator == nil {
			return fmt.Errorf("client operator is nil")
		}

		// This is needed, because we can't delete the account while still having tokens.
		// This works only, because the token is deleted, otherwise the acount would need to have 0 balance of it before dissociating.
		dissociateTx, err := NewTokenDissociateTransaction().
			SetAccountID(env.Client.operator.accountID).
			SetNodeAccountIDs(env.NodeAccountIDs).
			AddTokenID(*token).
			Execute(env.Client)
		if err != nil {
			return err
		}

		_, err = dissociateTx.SetValidateStatus(true).GetReceipt(env.Client)
		if err != nil {
			return err
		}
	}
	if os.Getenv("HEDERA_NETWORK") != "testnet" {
		resp, err = NewAccountDeleteTransaction().
			SetNodeAccountIDs(env.NodeAccountIDs).
			SetAccountID(env.OperatorID).
			SetTransferAccountID(env.OriginalOperatorID).
			Execute(env.Client)
		if err != nil {
			return err
		}

		_, err = resp.SetValidateStatus(true).GetReceipt(env.Client)
		if err != nil {
			return err
		}
	}

	return env.Client.Close()
}

func _NewMockClient() (*Client, error) {
	privateKey, err := PrivateKeyFromString(mockPrivateKey)

	if err != nil {
		return nil, err
	}

	var net = make(map[string]AccountID)
	net["nonexistent-testnet:56747"] = AccountID{Account: 3}

	client := ClientForNetwork(net)
	defaultNetwork := []string{"nonexistent-mirror-testnet:443"}
	client.SetMirrorNetwork(defaultNetwork)
	client.SetOperator(AccountID{Account: 2}, privateKey)

	return client, nil
}

func _NewMockTransaction() (*TransferTransaction, error) {
	privateKey, err := PrivateKeyFromString(mockPrivateKey)
	if err != nil {
		return &TransferTransaction{}, err
	}

	client, err := _NewMockClient()
	if err != nil {
		return &TransferTransaction{}, err
	}

	tx, err := NewTransferTransaction().
		AddHbarTransfer(AccountID{Account: 2}, HbarFromTinybar(-100)).
		AddHbarTransfer(AccountID{Account: 3}, HbarFromTinybar(100)).
		SetTransactionID(testTransactionID).
		SetNodeAccountIDs([]AccountID{{0, 0, 4, nil, nil, nil}}).
		FreezeWith(client)
	if err != nil {
		return &TransferTransaction{}, err
	}

	tx.Sign(privateKey)

	return tx, nil
}

type TokenCreateTransactionCustomizer func(transaction *TokenCreateTransaction)

var mintMetadata = [][]byte{{1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}}
var initialMetadata = []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

func createNft(env *IntegrationTestEnv, opts ...TokenCreateTransactionCustomizer) (TokenID, error) {
	tokenCreate := NewTokenCreateTransaction().
		SetTokenName("Example Collection").
		SetTokenSymbol("ABC").
		SetTokenType(TokenTypeNonFungibleUnique).
		SetDecimals(0).
		SetInitialSupply(0).
		SetMaxSupply(10).
		SetTreasuryAccountID(env.Client.GetOperatorAccountID()).
		SetSupplyType(TokenSupplyTypeFinite).
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetFreezeKey(env.Client.GetOperatorPublicKey()).
		SetPauseKey(env.Client.GetOperatorPublicKey()).
		SetWipeKey(env.Client.GetOperatorPublicKey()).
		SetFeeScheduleKey(env.Client.GetOperatorPublicKey()).
		SetSupplyKey(env.Client.GetOperatorPublicKey()).
		SetMetadataKey(env.Client.GetOperatorPublicKey())

	for _, opt := range opts {
		opt(tokenCreate)
	}

	tokenCreateExec, err := tokenCreate.Execute(env.Client)
	if err != nil {
		return TokenID{}, err
	}

	receipt, err := tokenCreateExec.SetValidateStatus(true).GetReceipt(env.Client)
	if err != nil {
		return TokenID{}, err
	}
	return *receipt.TokenID, err
}

func createFungibleToken(env *IntegrationTestEnv, opts ...TokenCreateTransactionCustomizer) (TokenID, error) {
	tokenCreate := NewTokenCreateTransaction().
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetTokenName("ffff").
		SetTokenSymbol("F").
		SetTokenMemo("asdf").
		SetDecimals(18).
		SetInitialSupply(1_000_000).
		SetTreasuryAccountID(env.Client.GetOperatorAccountID()).
		SetAdminKey(env.Client.GetOperatorPublicKey()).
		SetFreezeKey(env.Client.GetOperatorPublicKey()).
		SetPauseKey(env.Client.GetOperatorPublicKey()).
		SetWipeKey(env.Client.GetOperatorPublicKey()).
		SetFeeScheduleKey(env.Client.GetOperatorPublicKey()).
		SetMetadataKey(env.Client.GetOperatorPublicKey()).
		SetSupplyKey(env.Client.GetOperatorPublicKey()).
		SetFreezeDefault(false)

	for _, opt := range opts {
		opt(tokenCreate)
	}

	tokenCreateExec, err := tokenCreate.Execute(env.Client)
	if err != nil {
		return TokenID{}, err
	}

	receipt, err := tokenCreateExec.SetValidateStatus(true).GetReceipt(env.Client)
	if err != nil {
		return TokenID{}, err
	}
	return *receipt.TokenID, err
}

type AccountCreateTransactionCustomizer func(transaction *AccountCreateTransaction)

func createAccount(env *IntegrationTestEnv, opts ...AccountCreateTransactionCustomizer) (AccountID, PrivateKey, error) {
	newKey, err := PrivateKeyGenerateEd25519()

	if err != nil {
		return AccountID{}, PrivateKey{}, err
	}

	accountCreate := NewAccountCreateTransaction().
		SetKey(newKey).
		SetNodeAccountIDs(env.NodeAccountIDs).
		SetInitialBalance(NewHbar(1))

	for _, opt := range opts {
		opt(accountCreate)
	}

	accountCreateExec, err := accountCreate.Execute(env.Client)
	if err != nil {
		return AccountID{}, PrivateKey{}, err
	}

	receipt, err := accountCreateExec.SetValidateStatus(true).GetReceipt(env.Client)

	if err != nil {
		return AccountID{}, PrivateKey{}, err
	}

	return *receipt.AccountID, newKey, err
}
